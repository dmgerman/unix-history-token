begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: consarg.c,v $$Revision: 4.0.1.4 $$Date: 92/06/08 12:26:27 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log:	consarg.c,v $  * Revision 4.0.1.4  92/06/08  12:26:27  lwall  * patch20: new warning for use of x with non-numeric right operand  * patch20: modulus with highest bit in left operand set didn't always work  * patch20: illegal lvalue message could be followed by core dump  * patch20: deleted some minor memory leaks  *   * Revision 4.0.1.3  91/11/05  16:21:16  lwall  * patch11: random cleanup  * patch11: added eval {}  * patch11: added sort {} LIST  * patch11: "foo" x -1 dumped core  * patch11: substr() and vec() weren't allowed in an lvalue list  *   * Revision 4.0.1.2  91/06/07  10:33:12  lwall  * patch4: new copyright notice  * patch4: length($`), length($&), length($') now optimized to avoid string copy  *   * Revision 4.0.1.1  91/04/11  17:38:34  lwall  * patch1: fixed "Bad free" error  *   * Revision 4.0  91/03/20  01:06:15  lwall  * 4.0 baseline.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_function_decl
specifier|static
name|int
name|nothing_in_common
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arg_common
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spat_common
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|ARG
modifier|*
name|make_split
parameter_list|(
name|stab
parameter_list|,
name|arg
parameter_list|,
name|limarg
parameter_list|)
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|ARG
modifier|*
name|limarg
decl_stmt|;
block|{
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|!=
name|O_MATCH
condition|)
block|{
name|Newz
argument_list|(
literal|201
argument_list|,
name|spat
argument_list|,
literal|1
argument_list|,
name|SPAT
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_next
operator|=
name|curstash
operator|->
name|tbl_spatroot
expr_stmt|;
comment|/* link into spat list */
name|curstash
operator|->
name|tbl_spatroot
operator|=
name|spat
expr_stmt|;
name|spat
operator|->
name|spat_runtime
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|make_match
argument_list|(
name|O_MATCH
argument_list|,
name|stab2arg
argument_list|(
name|A_STAB
argument_list|,
name|defstab
argument_list|)
argument_list|,
name|spat
argument_list|)
expr_stmt|;
block|}
name|Renew
argument_list|(
name|arg
argument_list|,
literal|4
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_len
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|limarg
condition|)
block|{
if|if
condition|(
name|limarg
operator|->
name|arg_type
operator|==
name|O_ITEM
condition|)
block|{
name|Copy
argument_list|(
name|limarg
operator|+
literal|1
argument_list|,
name|arg
operator|+
literal|3
argument_list|,
literal|1
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
name|limarg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_NULL
expr_stmt|;
name|arg_free
argument_list|(
name|limarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
index|[
literal|3
index|]
operator|.
name|arg_flags
operator|=
literal|0
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_len
operator|=
literal|0
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_type
operator|=
name|A_EXPR
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|limarg
expr_stmt|;
block|}
block|}
else|else
block|{
name|arg
index|[
literal|3
index|]
operator|.
name|arg_flags
operator|=
literal|0
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_len
operator|=
literal|0
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_type
operator|=
name|A_NULL
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|Nullarg
expr_stmt|;
block|}
name|arg
operator|->
name|arg_type
operator|=
name|O_SPLIT
expr_stmt|;
name|spat
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
expr_stmt|;
name|spat
operator|->
name|spat_repl
operator|=
name|stab2arg
argument_list|(
name|A_STAB
argument_list|,
name|aadd
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_short
condition|)
block|{
comment|/* exact match can bypass regexec() */
if|if
condition|(
operator|!
operator|(
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_SCANFIRST
operator|)
operator|&&
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_ALL
operator|)
operator|)
condition|)
block|{
name|str_free
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_short
operator|=
name|Nullstr
expr_stmt|;
block|}
block|}
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|mod_match
parameter_list|(
name|type
parameter_list|,
name|left
parameter_list|,
name|pat
parameter_list|)
specifier|register
name|ARG
modifier|*
name|left
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|pat
decl_stmt|;
block|{
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|newarg
decl_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|Nullarg
return|;
if|if
condition|(
operator|(
name|pat
operator|->
name|arg_type
operator|==
name|O_MATCH
operator|||
name|pat
operator|->
name|arg_type
operator|==
name|O_SUBST
operator|||
name|pat
operator|->
name|arg_type
operator|==
name|O_TRANS
operator|||
name|pat
operator|->
name|arg_type
operator|==
name|O_SPLIT
operator|)
operator|&&
name|pat
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|==
name|defstab
condition|)
block|{
switch|switch
condition|(
name|pat
operator|->
name|arg_type
condition|)
block|{
case|case
name|O_MATCH
case|:
name|newarg
operator|=
name|make_op
argument_list|(
name|type
operator|==
name|O_MATCH
condition|?
name|O_MATCH
else|:
name|O_NMATCH
argument_list|,
name|pat
operator|->
name|arg_len
argument_list|,
name|left
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SUBST
case|:
name|newarg
operator|=
name|l
argument_list|(
name|make_op
argument_list|(
name|type
operator|==
name|O_MATCH
condition|?
name|O_SUBST
else|:
name|O_NSUBST
argument_list|,
name|pat
operator|->
name|arg_len
argument_list|,
name|left
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_TRANS
case|:
name|newarg
operator|=
name|l
argument_list|(
name|make_op
argument_list|(
name|type
operator|==
name|O_MATCH
condition|?
name|O_TRANS
else|:
name|O_NTRANS
argument_list|,
name|pat
operator|->
name|arg_len
argument_list|,
name|left
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SPLIT
case|:
name|newarg
operator|=
name|make_op
argument_list|(
name|type
operator|==
name|O_MATCH
condition|?
name|O_SPLIT
else|:
name|O_SPLIT
argument_list|,
name|pat
operator|->
name|arg_len
argument_list|,
name|left
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pat
operator|->
name|arg_len
operator|>=
literal|2
condition|)
block|{
name|newarg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|=
name|pat
index|[
literal|2
index|]
operator|.
name|arg_type
expr_stmt|;
name|newarg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|=
name|pat
index|[
literal|2
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|newarg
index|[
literal|2
index|]
operator|.
name|arg_len
operator|=
name|pat
index|[
literal|2
index|]
operator|.
name|arg_len
expr_stmt|;
name|newarg
index|[
literal|2
index|]
operator|.
name|arg_flags
operator|=
name|pat
index|[
literal|2
index|]
operator|.
name|arg_flags
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|arg_len
operator|>=
literal|3
condition|)
block|{
name|newarg
index|[
literal|3
index|]
operator|.
name|arg_type
operator|=
name|pat
index|[
literal|3
index|]
operator|.
name|arg_type
expr_stmt|;
name|newarg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|=
name|pat
index|[
literal|3
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|newarg
index|[
literal|3
index|]
operator|.
name|arg_len
operator|=
name|pat
index|[
literal|3
index|]
operator|.
name|arg_len
expr_stmt|;
name|newarg
index|[
literal|3
index|]
operator|.
name|arg_flags
operator|=
name|pat
index|[
literal|3
index|]
operator|.
name|arg_flags
expr_stmt|;
block|}
block|}
name|free_arg
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Newz
argument_list|(
literal|202
argument_list|,
name|spat
argument_list|,
literal|1
argument_list|,
name|SPAT
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_next
operator|=
name|curstash
operator|->
name|tbl_spatroot
expr_stmt|;
comment|/* link into spat list */
name|curstash
operator|->
name|tbl_spatroot
operator|=
name|spat
expr_stmt|;
name|spat
operator|->
name|spat_runtime
operator|=
name|pat
expr_stmt|;
name|newarg
operator|=
name|make_op
argument_list|(
name|type
argument_list|,
literal|2
argument_list|,
name|left
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
name|newarg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|=
name|A_SPAT
operator||
name|A_DONT
expr_stmt|;
name|newarg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|=
name|spat
expr_stmt|;
block|}
return|return
name|newarg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|make_op
parameter_list|(
name|type
parameter_list|,
name|newlen
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|newlen
decl_stmt|;
name|ARG
modifier|*
name|arg1
decl_stmt|;
name|ARG
modifier|*
name|arg2
decl_stmt|;
name|ARG
modifier|*
name|arg3
decl_stmt|;
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|chld
decl_stmt|;
specifier|register
name|unsigned
name|doarg
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|ARG
modifier|*
name|arg4
decl_stmt|;
comment|/* should be normal arguments, really */
specifier|extern
name|ARG
modifier|*
name|arg5
decl_stmt|;
name|arg
operator|=
name|op_new
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|type
expr_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|chld
operator|=
name|arg1
condition|)
block|{
if|if
condition|(
name|chld
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
operator|(
name|hoistable
index|[
name|i
operator|=
operator|(
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
index|]
operator|||
name|i
operator|==
name|A_LVAL
operator|||
operator|(
name|i
operator|==
name|A_LEXPR
operator|&&
operator|(
name|chld
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|==
name|O_LIST
operator|||
name|chld
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|==
name|O_ARRAY
operator|||
name|chld
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|==
name|O_HASH
operator|)
operator|)
operator|)
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_flags
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_len
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_len
expr_stmt|;
name|free_arg
argument_list|(
name|chld
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_EXPR
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|chld
expr_stmt|;
block|}
block|}
comment|/*SUPPRESS 560*/
if|if
condition|(
name|chld
operator|=
name|arg2
condition|)
block|{
if|if
condition|(
name|chld
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
operator|(
name|hoistable
index|[
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
operator|||
operator|(
name|type
operator|==
name|O_ASSIGN
operator|&&
operator|(
operator|(
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_READ
operator|&&
operator|!
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
operator|)
operator|)
operator|||
operator|(
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_INDREAD
operator|&&
operator|!
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
operator|)
operator|)
operator|||
operator|(
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_GLOB
operator|&&
operator|!
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_len
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_len
expr_stmt|;
name|free_arg
argument_list|(
name|chld
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|=
name|A_EXPR
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|chld
expr_stmt|;
block|}
block|}
comment|/*SUPPRESS 560*/
if|if
condition|(
name|chld
operator|=
name|arg3
condition|)
block|{
if|if
condition|(
name|chld
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|hoistable
index|[
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
condition|)
block|{
name|arg
index|[
literal|3
index|]
operator|.
name|arg_type
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_len
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_len
expr_stmt|;
name|free_arg
argument_list|(
name|chld
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
index|[
literal|3
index|]
operator|.
name|arg_type
operator|=
name|A_EXPR
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|chld
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newlen
operator|>=
literal|4
operator|&&
operator|(
name|chld
operator|=
name|arg4
operator|)
condition|)
block|{
if|if
condition|(
name|chld
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|hoistable
index|[
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
condition|)
block|{
name|arg
index|[
literal|4
index|]
operator|.
name|arg_type
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
expr_stmt|;
name|arg
index|[
literal|4
index|]
operator|.
name|arg_ptr
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|arg
index|[
literal|4
index|]
operator|.
name|arg_len
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_len
expr_stmt|;
name|free_arg
argument_list|(
name|chld
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
index|[
literal|4
index|]
operator|.
name|arg_type
operator|=
name|A_EXPR
expr_stmt|;
name|arg
index|[
literal|4
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|chld
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newlen
operator|>=
literal|5
operator|&&
operator|(
name|chld
operator|=
name|arg5
operator|)
condition|)
block|{
if|if
condition|(
name|chld
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|hoistable
index|[
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
condition|)
block|{
name|arg
index|[
literal|5
index|]
operator|.
name|arg_type
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_type
expr_stmt|;
name|arg
index|[
literal|5
index|]
operator|.
name|arg_ptr
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|arg
index|[
literal|5
index|]
operator|.
name|arg_len
operator|=
name|chld
index|[
literal|1
index|]
operator|.
name|arg_len
expr_stmt|;
name|free_arg
argument_list|(
name|chld
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
index|[
literal|5
index|]
operator|.
name|arg_type
operator|=
name|A_EXPR
expr_stmt|;
name|arg
index|[
literal|5
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|chld
expr_stmt|;
block|}
block|}
name|doarg
operator|=
name|opargs
index|[
name|type
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|newlen
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|doarg
operator|&
literal|1
operator|)
condition|)
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator||=
name|A_DONT
expr_stmt|;
if|if
condition|(
name|doarg
operator|&
literal|2
condition|)
name|arg
index|[
name|i
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
name|doarg
operator|>>=
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|16
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lx<= make_op(%s"
argument_list|,
name|arg
argument_list|,
name|opname
index|[
name|arg
operator|->
name|arg_type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|",%s=%lx"
argument_list|,
name|argname
index|[
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|",%s=%lx"
argument_list|,
name|argname
index|[
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|",%s=%lx"
argument_list|,
name|argname
index|[
name|arg
index|[
literal|3
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|>=
literal|4
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|",%s=%lx"
argument_list|,
name|argname
index|[
name|arg
index|[
literal|4
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|",%s=%lx"
argument_list|,
name|argname
index|[
name|arg
index|[
literal|5
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|arg
operator|=
name|evalstatic
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* see if we can consolidate anything */
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|evalstatic
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|STR
modifier|*
name|str
init|=
name|Nullstr
decl_stmt|;
specifier|register
name|STR
modifier|*
name|s1
decl_stmt|;
specifier|register
name|STR
modifier|*
name|s2
decl_stmt|;
name|double
name|value
decl_stmt|;
comment|/* must not be register */
specifier|register
name|char
modifier|*
name|tmps
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|tmplong
decl_stmt|;
name|long
name|tmp2
decl_stmt|;
name|double
name|exp
argument_list|()
decl_stmt|,
name|log
argument_list|()
decl_stmt|,
name|sqrt
argument_list|()
decl_stmt|,
name|modf
argument_list|()
decl_stmt|;
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
name|double
name|sin
argument_list|()
decl_stmt|,
name|cos
argument_list|()
decl_stmt|,
name|atan2
argument_list|()
decl_stmt|,
name|pow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
name|arg
operator|->
name|arg_len
condition|)
return|return
name|arg
return|;
if|if
condition|(
operator|!
name|str
condition|)
name|str
operator|=
name|Str_new
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_SINGLE
condition|)
name|s1
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
else|else
name|s1
operator|=
name|Nullstr
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_len
operator|>=
literal|2
operator|&&
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|==
name|A_SINGLE
condition|)
name|s2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
else|else
name|s2
operator|=
name|Nullstr
expr_stmt|;
define|#
directive|define
name|CHECK1
value|if (!s1) return arg
define|#
directive|define
name|CHECK2
value|if (!s2) return arg
define|#
directive|define
name|CHECK12
value|if (!s1 || !s2) return arg
switch|switch
condition|(
name|arg
operator|->
name|arg_type
condition|)
block|{
default|default:
return|return
name|arg
return|;
case|case
name|O_SORT
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_CMD
condition|)
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator||=
name|A_DONT
expr_stmt|;
return|return
name|arg
return|;
case|case
name|O_EVAL
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_CMD
condition|)
block|{
name|arg
operator|->
name|arg_type
operator|=
name|O_TRY
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator||=
name|A_DONT
expr_stmt|;
return|return
name|arg
return|;
block|}
name|CHECK1
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_EVALONCE
expr_stmt|;
return|return
name|arg
return|;
case|case
name|O_AELEM
case|:
name|CHECK2
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|32767
operator|&&
name|i
operator|>=
literal|0
condition|)
block|{
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
name|arg
operator|->
name|arg_len
operator|=
literal|1
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_ARYSTAB
expr_stmt|;
comment|/* $abc[123] is hoistable now */
name|arg
index|[
literal|1
index|]
operator|.
name|arg_len
operator|=
name|i
expr_stmt|;
name|str_free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
case|case
name|O_CONCAT
case|:
name|CHECK12
expr_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|str
argument_list|,
name|s2
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_REPEAT
case|:
name|CHECK2
expr_stmt|;
if|if
condition|(
name|dowarn
operator|&&
operator|!
name|s2
operator|->
name|str_nok
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|s2
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Right operand of x is not numeric"
argument_list|)
expr_stmt|;
name|CHECK1
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|i
operator|*
name|s1
operator|->
name|str_cur
operator|+
literal|1
argument_list|)
expr_stmt|;
name|repeatcpy
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
name|tmps
argument_list|,
name|s1
operator|->
name|str_cur
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|i
operator|*
name|s1
operator|->
name|str_cur
expr_stmt|;
name|str
operator|->
name|str_ptr
index|[
name|str
operator|->
name|str_cur
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
name|O_MULTIPLY
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|value
operator|*
name|str_gnum
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_DIVIDE
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0.0
condition|)
name|yyerror
argument_list|(
literal|"Illegal division by constant zero"
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|SLOPPYDIVIDE
comment|/* insure that 20./5. == 4. */
block|{
name|double
name|x
decl_stmt|;
name|int
name|k
decl_stmt|;
name|x
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|double
operator|)
operator|(
name|int
operator|)
name|x
operator|==
name|x
operator|&&
operator|(
name|double
operator|)
operator|(
name|int
operator|)
name|value
operator|==
name|value
operator|&&
operator|(
name|k
operator|=
operator|(
name|int
operator|)
name|x
operator|/
operator|(
name|int
operator|)
name|value
operator|)
operator|*
operator|(
name|int
operator|)
name|value
operator|==
operator|(
name|int
operator|)
name|x
condition|)
block|{
name|value
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|x
operator|/
name|value
expr_stmt|;
block|}
name|str_numset
argument_list|(
name|str
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|str_numset
argument_list|(
name|str
argument_list|,
name|str_gnum
argument_list|(
name|s1
argument_list|)
operator|/
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_MODULO
case|:
name|CHECK12
expr_stmt|;
name|tmplong
operator|=
operator|(
name|unsigned
name|long
operator|)
name|str_gnum
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmplong
operator|==
literal|0L
condition|)
block|{
name|yyerror
argument_list|(
literal|"Illegal modulus of constant zero"
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|value
operator|>=
literal|0.0
condition|)
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|%
name|tmplong
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tmp2
operator|=
operator|(
name|long
operator|)
name|value
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|(
name|tmplong
operator|-
operator|(
operator|(
operator|-
name|tmp2
operator|-
literal|1
operator|)
operator|%
name|tmplong
operator|)
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|tmp2
operator|=
name|tmp2
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_ADD
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|value
operator|+
name|str_gnum
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SUBTRACT
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|value
operator|-
name|str_gnum
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LEFT_SHIFT
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|s2
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|value
operator|)
operator|<<
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_RIGHT_SHIFT
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|s2
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|value
operator|)
operator|>>
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_LT
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|value
operator|<
name|str_gnum
argument_list|(
name|s2
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_GT
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|value
operator|>
name|str_gnum
argument_list|(
name|s2
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LE
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|value
operator|<=
name|str_gnum
argument_list|(
name|s2
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_GE
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|value
operator|>=
name|str_gnum
argument_list|(
name|s2
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_EQ
case|:
name|CHECK12
expr_stmt|;
if|if
condition|(
name|dowarn
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|s1
operator|->
name|str_nok
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|s1
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|s2
operator|->
name|str_nok
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|s2
argument_list|)
operator|)
condition|)
name|warn
argument_list|(
literal|"Possible use of == on string value"
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|value
operator|==
name|str_gnum
argument_list|(
name|s2
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_NE
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|value
operator|!=
name|str_gnum
argument_list|(
name|s2
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_NCMP
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|value
operator|-=
name|str_gnum
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
literal|0.0
condition|)
name|value
operator|=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
name|value
operator|=
operator|-
literal|1.0
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_BIT_AND
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|U_L
argument_list|(
name|value
argument_list|)
operator|&
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|s2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_XOR
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|U_L
argument_list|(
name|value
argument_list|)
operator|^
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|s2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_BIT_OR
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|U_L
argument_list|(
name|value
argument_list|)
operator||
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|s2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_AND
case|:
name|CHECK12
expr_stmt|;
if|if
condition|(
name|str_true
argument_list|(
name|s1
argument_list|)
condition|)
name|str_sset
argument_list|(
name|str
argument_list|,
name|s2
argument_list|)
expr_stmt|;
else|else
name|str_sset
argument_list|(
name|str
argument_list|,
name|s1
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_OR
case|:
name|CHECK12
expr_stmt|;
if|if
condition|(
name|str_true
argument_list|(
name|s1
argument_list|)
condition|)
name|str_sset
argument_list|(
name|str
argument_list|,
name|s1
argument_list|)
expr_stmt|;
else|else
name|str_sset
argument_list|(
name|str
argument_list|,
name|s2
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_COND_EXPR
case|:
name|CHECK12
expr_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|3
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|!=
name|A_SINGLE
condition|)
return|return
name|arg
return|;
if|if
condition|(
name|str_true
argument_list|(
name|s1
argument_list|)
condition|)
name|str_sset
argument_list|(
name|str
argument_list|,
name|s2
argument_list|)
expr_stmt|;
else|else
name|str_sset
argument_list|(
name|str
argument_list|,
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|arg
argument_list|,
literal|3
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_NEGATE
case|:
name|CHECK1
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|-
name|str_gnum
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_NOT
case|:
name|CHECK1
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTNOT
block|{
name|char
name|xxx
init|=
name|str_true
argument_list|(
name|s1
argument_list|)
decl_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
operator|!
name|xxx
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|!
name|str_true
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_COMPLEMENT
case|:
name|CHECK1
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|~
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_SIN
case|:
name|CHECK1
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|sin
argument_list|(
name|str_gnum
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_COS
case|:
name|CHECK1
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|cos
argument_list|(
name|str_gnum
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ATAN2
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|atan2
argument_list|(
name|value
argument_list|,
name|str_gnum
argument_list|(
name|s2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_POW
case|:
name|CHECK12
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|pow
argument_list|(
name|value
argument_list|,
name|str_gnum
argument_list|(
name|s2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LENGTH
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_STAB
condition|)
block|{
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LENSTAB
expr_stmt|;
return|return
name|arg
return|;
block|}
name|CHECK1
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|str_len
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SLT
case|:
name|CHECK12
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|<
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SGT
case|:
name|CHECK12
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|>
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SLE
case|:
name|CHECK12
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|<=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SGE
case|:
name|CHECK12
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|>=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SEQ
case|:
name|CHECK12
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|str_eq
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SNE
case|:
name|CHECK12
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|!
name|str_eq
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SCMP
case|:
name|CHECK12
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_CRYPT
case|:
name|CHECK12
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_CRYPT
name|tmps
operator|=
name|str_get
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|crypt
argument_list|(
name|tmps
argument_list|,
name|str_get
argument_list|(
name|s2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|yyerror
argument_list|(
literal|"The crypt() function is unimplemented due to excessive paranoia."
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_EXP
case|:
name|CHECK1
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|exp
argument_list|(
name|str_gnum
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LOG
case|:
name|CHECK1
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|log
argument_list|(
name|str_gnum
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SQRT
case|:
name|CHECK1
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|sqrt
argument_list|(
name|str_gnum
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_INT
case|:
name|CHECK1
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0.0
condition|)
operator|(
name|void
operator|)
name|modf
argument_list|(
name|value
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|modf
argument_list|(
operator|-
name|value
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
block|}
name|str_numset
argument_list|(
name|str
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ORD
case|:
name|CHECK1
expr_stmt|;
ifndef|#
directive|ifndef
name|I286
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|*
name|str_get
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|zapc
decl_stmt|;
name|char
modifier|*
name|zaps
decl_stmt|;
name|zaps
operator|=
name|str_get
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|zapc
operator|=
operator|(
name|int
operator|)
operator|*
name|zaps
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|zapc
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
comment|/* note arg1 type is already SINGLE */
name|str_free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|s2
condition|)
block|{
name|str_free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|Nullstr
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|=
name|A_NULL
expr_stmt|;
block|}
name|str
operator|=
name|Nullstr
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|l
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg1
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg2
decl_stmt|;
name|SPAT
modifier|*
name|spat
decl_stmt|;
name|int
name|arghog
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
name|arg
operator|->
name|arg_flags
operator||=
name|AF_COMMON
expr_stmt|;
comment|/* assume something in common */
comment|/* which forces us to copy things */
if|if
condition|(
name|i
operator|==
name|A_ARYLEN
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LARYLEN
expr_stmt|;
return|return
name|arg
return|;
block|}
if|if
condition|(
name|i
operator|==
name|A_ARYSTAB
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LARYSTAB
expr_stmt|;
return|return
name|arg
return|;
block|}
comment|/* see if it's an array reference */
if|if
condition|(
name|i
operator|==
name|A_EXPR
operator|||
name|i
operator|==
name|A_LEXPR
condition|)
block|{
name|arg1
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_LIST
operator|||
name|arg1
operator|->
name|arg_type
operator|==
name|O_ITEM
condition|)
block|{
comment|/* assign to list */
if|if
condition|(
name|arg
operator|->
name|arg_len
operator|>
literal|1
condition|)
block|{
name|dehoist
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
if|if
condition|(
name|nothing_in_common
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
name|arg
operator|->
name|arg_flags
operator|&=
operator|~
name|AF_COMMON
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
condition|)
block|{
if|if
condition|(
name|arg1
operator|->
name|arg_flags
operator|&
name|AF_LOCAL
condition|)
name|arg
operator|->
name|arg_flags
operator||=
name|AF_LOCAL
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|!=
name|O_CHOP
condition|)
name|arg
operator|->
name|arg_type
operator|=
name|O_ASSIGN
expr_stmt|;
comment|/* possible local(); */
for|for
control|(
name|i
operator|=
name|arg1
operator|->
name|arg_len
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|arg1
index|[
name|i
index|]
operator|.
name|arg_type
condition|)
block|{
case|case
name|A_STAR
case|:
case|case
name|A_LSTAR
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_type
operator|=
name|A_LSTAR
expr_stmt|;
break|break;
case|case
name|A_STAB
case|:
case|case
name|A_LVAL
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_type
operator|=
name|A_LVAL
expr_stmt|;
break|break;
case|case
name|A_ARYLEN
case|:
case|case
name|A_LARYLEN
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_type
operator|=
name|A_LARYLEN
expr_stmt|;
break|break;
case|case
name|A_ARYSTAB
case|:
case|case
name|A_LARYSTAB
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_type
operator|=
name|A_LARYSTAB
expr_stmt|;
break|break;
case|case
name|A_EXPR
case|:
case|case
name|A_LEXPR
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_type
operator|=
name|A_LEXPR
expr_stmt|;
switch|switch
condition|(
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
condition|)
block|{
case|case
name|O_ARRAY
case|:
case|case
name|O_LARRAY
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|=
name|O_LARRAY
expr_stmt|;
name|arghog
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|O_AELEM
case|:
case|case
name|O_LAELEM
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|=
name|O_LAELEM
expr_stmt|;
break|break;
case|case
name|O_HASH
case|:
case|case
name|O_LHASH
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|=
name|O_LHASH
expr_stmt|;
name|arghog
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|O_HELEM
case|:
case|case
name|O_LHELEM
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|=
name|O_LHELEM
expr_stmt|;
break|break;
case|case
name|O_ASLICE
case|:
case|case
name|O_LASLICE
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|=
name|O_LASLICE
expr_stmt|;
break|break;
case|case
name|O_HSLICE
case|:
case|case
name|O_LHSLICE
case|:
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|=
name|O_LHSLICE
expr_stmt|;
break|break;
case|case
name|O_SUBSTR
case|:
case|case
name|O_VEC
case|:
operator|(
name|void
operator|)
name|l
argument_list|(
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|)
expr_stmt|;
name|Renewc
argument_list|(
name|arg1
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|1
argument_list|,
expr|struct
name|lstring
argument_list|,
name|STR
argument_list|)
expr_stmt|;
comment|/* grow string struct to hold an lstring struct */
break|break;
default|default:
goto|goto
name|ill_item
goto|;
block|}
break|break;
default|default:
name|ill_item
label|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"Illegal item (%s) as lvalue"
argument_list|,
name|argname
index|[
name|arg1
index|[
name|i
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|tokenbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arg
operator|->
name|arg_len
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|arg2
operator|->
name|arg_type
operator|==
name|O_SPLIT
operator|&&
operator|!
name|arg2
index|[
literal|3
index|]
operator|.
name|arg_type
operator|&&
operator|!
name|arghog
condition|)
block|{
name|arg2
index|[
literal|3
index|]
operator|.
name|arg_type
operator|=
name|A_SINGLE
expr_stmt|;
name|arg2
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|arg1
operator|->
name|arg_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* limit split len*/
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_AELEM
operator|||
name|arg1
operator|->
name|arg_type
operator|==
name|O_LAELEM
condition|)
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_DEFINED
condition|)
name|arg1
operator|->
name|arg_type
operator|=
name|O_AELEM
expr_stmt|;
else|else
name|arg1
operator|->
name|arg_type
operator|=
name|O_LAELEM
expr_stmt|;
elseif|else
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_ARRAY
operator|||
name|arg1
operator|->
name|arg_type
operator|==
name|O_LARRAY
condition|)
block|{
name|arg1
operator|->
name|arg_type
operator|=
name|O_LARRAY
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_len
operator|>
literal|1
condition|)
block|{
name|dehoist
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
if|if
condition|(
name|arg2
operator|->
name|arg_type
operator|==
name|O_SPLIT
condition|)
block|{
comment|/* use split's builtin =?*/
name|spat
operator|=
name|arg2
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_ONCE
operator|)
operator|&&
name|nothing_in_common
argument_list|(
name|arg1
argument_list|,
name|spat
operator|->
name|spat_repl
argument_list|)
condition|)
block|{
name|spat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|=
name|arg1
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|arg1
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|=
name|Nullstab
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_ONCE
expr_stmt|;
name|arg_free
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* recursive */
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|Nullarg
expr_stmt|;
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* non-recursive */
return|return
name|arg2
return|;
comment|/* split has builtin assign */
block|}
block|}
elseif|else
if|if
condition|(
name|nothing_in_common
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
name|arg
operator|->
name|arg_flags
operator|&=
operator|~
name|AF_COMMON
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
condition|)
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_HELEM
operator|||
name|arg1
operator|->
name|arg_type
operator|==
name|O_LHELEM
condition|)
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_DEFINED
condition|)
name|arg1
operator|->
name|arg_type
operator|=
name|O_HELEM
expr_stmt|;
comment|/* avoid creating one */
else|else
name|arg1
operator|->
name|arg_type
operator|=
name|O_LHELEM
expr_stmt|;
elseif|else
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_HASH
operator|||
name|arg1
operator|->
name|arg_type
operator|==
name|O_LHASH
condition|)
block|{
name|arg1
operator|->
name|arg_type
operator|=
name|O_LHASH
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_len
operator|>
literal|1
condition|)
block|{
name|dehoist
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
if|if
condition|(
name|nothing_in_common
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
name|arg
operator|->
name|arg_flags
operator|&=
operator|~
name|AF_COMMON
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
condition|)
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_ASLICE
condition|)
block|{
name|arg1
operator|->
name|arg_type
operator|=
name|O_LASLICE
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
condition|)
block|{
name|dehoist
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_HSLICE
condition|)
block|{
name|arg1
operator|->
name|arg_type
operator|=
name|O_LHSLICE
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
condition|)
block|{
name|dehoist
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|arg
operator|->
name|arg_type
operator|==
name|O_DEFINED
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_UNDEF
operator|)
operator|&&
operator|(
name|arg1
operator|->
name|arg_type
operator|==
operator|(
name|perldb
condition|?
name|O_DBSUBR
else|:
name|O_SUBR
operator|)
operator|)
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator||=
name|A_DONT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_SUBSTR
operator|||
name|arg1
operator|->
name|arg_type
operator|==
name|O_VEC
condition|)
block|{
operator|(
name|void
operator|)
name|l
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|Renewc
argument_list|(
name|arg1
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|1
argument_list|,
expr|struct
name|lstring
argument_list|,
name|STR
argument_list|)
expr_stmt|;
comment|/* grow string struct to hold an lstring struct */
block|}
elseif|else
if|if
condition|(
name|arg1
operator|->
name|arg_type
operator|==
name|O_ASSIGN
condition|)
comment|/*SUPPRESS 530*/
empty_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"Illegal expression (%s) as lvalue"
argument_list|,
name|opname
index|[
name|arg1
operator|->
name|arg_type
index|]
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|tokenbuf
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LEXPR
operator||
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
operator|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
operator|&&
operator|(
name|arg1
index|[
literal|1
index|]
operator|.
name|arg_flags
operator|&
name|AF_ARYOK
operator|)
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_len
operator|>
literal|1
condition|)
name|arg
index|[
literal|2
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|16
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lval LEXPR\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|arg
return|;
block|}
if|if
condition|(
name|i
operator|==
name|A_STAR
operator|||
name|i
operator|==
name|A_LSTAR
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LSTAR
operator||
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
operator|)
expr_stmt|;
return|return
name|arg
return|;
block|}
comment|/* not an array reference, should be a register name */
if|if
condition|(
name|i
operator|!=
name|A_STAB
operator|&&
name|i
operator|!=
name|A_LVAL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"Illegal item (%s) as lvalue"
argument_list|,
name|argname
index|[
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|tokenbuf
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LVAL
operator||
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|16
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lval LVAL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|fixl
parameter_list|(
name|type
parameter_list|,
name|arg
parameter_list|)
name|int
name|type
decl_stmt|;
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|O_DEFINED
operator|||
name|type
operator|==
name|O_UNDEF
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|!=
name|O_ITEM
condition|)
name|arg
operator|=
name|hide_ary
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ITEM
condition|)
block|{
name|type
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|A_EXPR
operator|||
name|type
operator|==
name|A_LEXPR
condition|)
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LEXPR
operator||
name|A_DONT
expr_stmt|;
block|}
block|}
return|return
name|arg
return|;
block|}
end_function

begin_function
name|void
name|dehoist
parameter_list|(
name|arg
parameter_list|,
name|i
parameter_list|)
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
name|ARG
modifier|*
name|tmparg
decl_stmt|;
if|if
condition|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator|!=
name|A_EXPR
condition|)
block|{
comment|/* dehoist */
name|tmparg
operator|=
name|make_op
argument_list|(
name|O_ITEM
argument_list|,
literal|1
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
name|tmparg
index|[
literal|1
index|]
operator|=
name|arg
index|[
name|i
index|]
expr_stmt|;
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|tmparg
expr_stmt|;
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator|=
name|A_EXPR
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ARG
modifier|*
name|addflags
parameter_list|(
name|i
parameter_list|,
name|flags
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
name|arg
index|[
name|i
index|]
operator|.
name|arg_flags
operator||=
name|flags
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|hide_ary
parameter_list|(
name|arg
parameter_list|)
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ARRAY
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_HASH
condition|)
return|return
name|make_op
argument_list|(
name|O_ITEM
argument_list|,
literal|1
argument_list|,
name|arg
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
return|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* maybe do a join on multiple array dimensions */
end_comment

begin_function
name|ARG
modifier|*
name|jmaybe
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|&&
name|arg
operator|->
name|arg_type
operator|==
name|O_COMMA
condition|)
block|{
name|arg
operator|=
name|listish
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|make_op
argument_list|(
name|O_JOIN
argument_list|,
literal|2
argument_list|,
name|stab2arg
argument_list|(
name|A_STAB
argument_list|,
name|stabent
argument_list|(
literal|";"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|make_list
argument_list|(
name|arg
argument_list|)
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|make_list
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|node
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|nxtnode
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|STR
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
name|arg
operator|=
name|op_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_LIST
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|!=
name|O_COMMA
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|!=
name|O_ARRAY
condition|)
name|arg
operator|->
name|arg_flags
operator||=
name|AF_LISTISH
expr_stmt|;
comment|/* see listish() below */
name|arg
operator|->
name|arg_flags
operator||=
name|AF_LISTISH
expr_stmt|;
comment|/* see listish() below */
return|return
name|arg
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
operator|,
name|node
operator|=
name|arg
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|arg_len
operator|<
literal|2
condition|)
break|break;
if|if
condition|(
name|node
index|[
literal|1
index|]
operator|.
name|arg_type
operator|!=
name|A_EXPR
condition|)
break|break;
name|node
operator|=
name|node
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|arg_type
operator|!=
name|O_COMMA
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|node
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|op_new
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|StructCopy
argument_list|(
name|node
argument_list|,
name|arg
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
comment|/* copy everything except the STR */
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
operator|=
name|tmpstr
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
condition|;
control|)
block|{
name|StructCopy
argument_list|(
name|node
operator|+
literal|2
argument_list|,
name|arg
operator|+
name|j
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
name|arg
index|[
name|j
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
operator|--
name|j
expr_stmt|;
comment|/* Bug in Xenix compiler */
if|if
condition|(
name|j
operator|<
literal|2
condition|)
block|{
name|StructCopy
argument_list|(
name|node
operator|+
literal|1
argument_list|,
name|arg
operator|+
literal|1
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
name|free_arg
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
name|nxtnode
operator|=
name|node
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
name|free_arg
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|nxtnode
expr_stmt|;
block|}
block|}
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_flags
operator||=
name|AF_ARYOK
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_LIST
expr_stmt|;
name|arg
operator|->
name|arg_len
operator|=
name|i
expr_stmt|;
name|str_free
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
operator|=
name|Nullstr
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* turn a single item into a list */
end_comment

begin_function
name|ARG
modifier|*
name|listish
parameter_list|(
name|arg
parameter_list|)
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|&&
name|arg
operator|->
name|arg_flags
operator|&
name|AF_LISTISH
condition|)
name|arg
operator|=
name|make_op
argument_list|(
name|O_LIST
argument_list|,
literal|1
argument_list|,
name|arg
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|maybelistish
parameter_list|(
name|optype
parameter_list|,
name|arg
parameter_list|)
name|int
name|optype
decl_stmt|;
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
name|ARG
modifier|*
name|tmparg
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|optype
operator|==
name|O_RETURN
operator|&&
name|arg
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_EXPR
operator|&&
operator|(
name|tmparg
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|)
operator|&&
operator|(
operator|(
name|tmparg
operator|->
name|arg_flags
operator|&
name|AF_LISTISH
operator|)
operator|||
operator|(
name|tmparg
operator|->
name|arg_type
operator|==
name|O_ARRAY
operator|)
operator|)
condition|)
block|{
name|tmparg
operator|=
name|listish
argument_list|(
name|tmparg
argument_list|)
expr_stmt|;
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tmparg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype
operator|==
name|O_PRTF
operator|||
operator|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASLICE
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_HSLICE
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_F_OR_R
operator|)
condition|)
name|arg
operator|=
name|listish
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* mark list of local variables */
end_comment

begin_function
name|ARG
modifier|*
name|localize
parameter_list|(
name|arg
parameter_list|)
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
name|arg
operator|->
name|arg_flags
operator||=
name|AF_LOCAL
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|rcatmaybe
parameter_list|(
name|arg
parameter_list|)
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
name|ARG
modifier|*
name|arg2
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_CONCAT
operator|&&
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|==
name|A_EXPR
condition|)
block|{
name|arg2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
if|if
condition|(
name|arg2
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|arg2
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_READ
condition|)
block|{
name|arg
operator|->
name|arg_type
operator|=
name|O_RCAT
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|=
name|arg2
index|[
literal|1
index|]
operator|.
name|arg_type
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|=
name|arg2
index|[
literal|1
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|free_arg
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|stab2arg
parameter_list|(
name|atype
parameter_list|,
name|stab
parameter_list|)
name|int
name|atype
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
name|op_new
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|atype
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|=
name|stab
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|cval_to_arg
parameter_list|(
name|cval
parameter_list|)
specifier|register
name|char
modifier|*
name|cval
decl_stmt|;
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
name|op_new
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_SINGLE
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|str_make
argument_list|(
name|cval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|cval
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|op_new
parameter_list|(
name|numargs
parameter_list|)
name|int
name|numargs
decl_stmt|;
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|Newz
argument_list|(
literal|203
argument_list|,
name|arg
argument_list|,
name|numargs
operator|+
literal|1
argument_list|,
name|ARG
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
operator|=
name|Str_new
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_len
operator|=
name|numargs
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|void
name|free_arg
parameter_list|(
name|arg
parameter_list|)
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
name|str_free
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|make_match
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|,
name|spat
parameter_list|)
name|int
name|type
decl_stmt|;
name|ARG
modifier|*
name|expr
decl_stmt|;
name|SPAT
modifier|*
name|spat
decl_stmt|;
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
name|make_op
argument_list|(
name|type
argument_list|,
literal|2
argument_list|,
name|expr
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|=
name|A_SPAT
operator||
name|A_DONT
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|=
name|spat
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|16
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"make_match SPAT=%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|spat
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|O_SUBST
operator|||
name|type
operator|==
name|O_NSUBST
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|!=
name|A_STAB
condition|)
block|{
name|yyerror
argument_list|(
literal|"Illegal lvalue"
argument_list|)
expr_stmt|;
block|}
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LVAL
expr_stmt|;
block|}
return|return
name|arg
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|cmd_to_arg
parameter_list|(
name|cmd
parameter_list|)
name|CMD
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
name|op_new
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_CMD
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
operator|=
name|cmd
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Check two expressions to see if there is any identifier in common */
end_comment

begin_function
specifier|static
name|int
name|nothing_in_common
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|ARG
modifier|*
name|arg1
decl_stmt|;
name|ARG
modifier|*
name|arg2
decl_stmt|;
block|{
specifier|static
name|int
name|thisexpr
init|=
literal|0
decl_stmt|;
comment|/* I don't care if this wraps */
name|thisexpr
operator|++
expr_stmt|;
if|if
condition|(
name|arg_common
argument_list|(
name|arg1
argument_list|,
name|thisexpr
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* hit eval or do {} */
name|stab_lastexpr
argument_list|(
name|defstab
argument_list|)
operator|=
name|thisexpr
expr_stmt|;
comment|/* pretend to hit @_ */
if|if
condition|(
name|arg_common
argument_list|(
name|arg2
argument_list|,
name|thisexpr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* hit identifier again */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Recursively descend an expression and mark any identifier or check  * it to see if it was marked already.  */
end_comment

begin_function
specifier|static
name|int
name|arg_common
parameter_list|(
name|arg
parameter_list|,
name|exprnum
parameter_list|,
name|marking
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|exprnum
decl_stmt|;
name|int
name|marking
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|arg
operator|->
name|arg_len
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
condition|)
block|{
case|case
name|A_NULL
case|:
break|break;
case|case
name|A_LEXPR
case|:
case|case
name|A_EXPR
case|:
if|if
condition|(
name|arg_common
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|,
name|exprnum
argument_list|,
name|marking
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|A_CMD
case|:
return|return
literal|1
return|;
comment|/* assume hanky panky */
case|case
name|A_STAR
case|:
case|case
name|A_LSTAR
case|:
case|case
name|A_STAB
case|:
case|case
name|A_LVAL
case|:
case|case
name|A_ARYLEN
case|:
case|case
name|A_LARYLEN
case|:
if|if
condition|(
name|marking
condition|)
name|stab_lastexpr
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|=
name|exprnum
expr_stmt|;
elseif|else
if|if
condition|(
name|stab_lastexpr
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|==
name|exprnum
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|A_DOUBLE
case|:
case|case
name|A_BACKTICK
case|:
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|->
name|str_ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
init|=
name|s
operator|+
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|->
name|str_cur
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
condition|)
block|{
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|send
argument_list|,
name|tokenbuf
argument_list|)
expr_stmt|;
name|stab
operator|=
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|marking
condition|)
name|stab_lastexpr
argument_list|(
name|stab
argument_list|)
operator|=
name|exprnum
expr_stmt|;
elseif|else
if|if
condition|(
name|stab_lastexpr
argument_list|(
name|stab
argument_list|)
operator|==
name|exprnum
condition|)
return|return
literal|1
return|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
index|[
literal|1
index|]
condition|)
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|A_SPAT
case|:
if|if
condition|(
name|spat_common
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
argument_list|,
name|exprnum
argument_list|,
name|marking
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|A_READ
case|:
case|case
name|A_INDREAD
case|:
case|case
name|A_GLOB
case|:
case|case
name|A_WORD
case|:
case|case
name|A_SINGLE
case|:
break|break;
block|}
block|}
switch|switch
condition|(
name|arg
operator|->
name|arg_type
condition|)
block|{
case|case
name|O_ARRAY
case|:
case|case
name|O_LARRAY
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_STAB
condition|)
operator|(
name|void
operator|)
name|aadd
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_HASH
case|:
case|case
name|O_LHASH
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_STAB
condition|)
operator|(
name|void
operator|)
name|hadd
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_EVAL
case|:
case|case
name|O_SUBR
case|:
case|case
name|O_DBSUBR
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spat_common
parameter_list|(
name|spat
parameter_list|,
name|exprnum
parameter_list|,
name|marking
parameter_list|)
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
name|int
name|exprnum
decl_stmt|;
name|int
name|marking
decl_stmt|;
block|{
if|if
condition|(
name|spat
operator|->
name|spat_runtime
condition|)
if|if
condition|(
name|arg_common
argument_list|(
name|spat
operator|->
name|spat_runtime
argument_list|,
name|exprnum
argument_list|,
name|marking
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spat
operator|->
name|spat_repl
condition|)
block|{
if|if
condition|(
name|arg_common
argument_list|(
name|spat
operator|->
name|spat_repl
argument_list|,
name|exprnum
argument_list|,
name|marking
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

