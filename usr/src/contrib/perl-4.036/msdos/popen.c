begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: popen.c,v $$Revision: 4.0.1.1 $$Date: 91/06/07 11:22:52 $  *  *    (C) Copyright 1988, 1990 Diomidis Spinellis.  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log:	popen.c,v $  * Revision 4.0.1.1  91/06/07  11:22:52  lwall  * patch4: new copyright notice  *   * Revision 4.0  91/03/20  01:34:50  lwall  * 4.0 baseline.  *   * Revision 3.0.1.2  90/08/09  04:04:42  lwall  * patch19: various MSDOS and OS/2 patches folded in  *   * Revision 3.0.1.1  90/03/27  16:11:57  lwall  * patch16: MSDOS support  *   * Revision 1.1  90/03/18  20:32:20  dds  * Initial revision  *  */
end_comment

begin_comment
comment|/*  * Popen and pclose for MS-DOS  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_comment
comment|/*  * Possible actions on an popened file  */
end_comment

begin_enum
enum|enum
name|action
block|{
name|delete
block|,
comment|/* Used for "r". Delete the tmp file */
name|execute
comment|/* Used for "w". Execute the command. */
block|}
enum|;
end_enum

begin_comment
comment|/*  * Linked list of things to do at the end of the program execution.  */
end_comment

begin_struct
specifier|static
struct|struct
name|todo
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* File we are working on (to fclose) */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of the file (to unlink) */
specifier|const
name|char
modifier|*
name|command
decl_stmt|;
comment|/* Command to execute */
name|enum
name|action
name|what
decl_stmt|;
comment|/* What to do (execute or delete) */
name|struct
name|todo
modifier|*
name|next
decl_stmt|;
comment|/* Next structure */
block|}
modifier|*
name|todolist
struct|;
end_struct

begin_comment
comment|/* Clean up function */
end_comment

begin_function_decl
specifier|static
name|int
name|close_pipes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Add a file f running the command command on file name to the list  * of actions to be done at the end.  The action is specified in what.  * Return -1 on failure, 0 if ok.  */
end_comment

begin_function
specifier|static
name|int
name|add
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|command
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|action
name|what
parameter_list|)
block|{
name|struct
name|todo
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
expr|struct
name|todo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|todo
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|p
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|what
operator|=
name|what
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|todolist
expr_stmt|;
name|todolist
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|mypopen
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|,
specifier|const
name|char
modifier|*
name|t
parameter_list|)
block|{
name|char
name|buff
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|static
name|init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
if|if
condition|(
name|onexit
argument_list|(
name|close_pipes
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
name|init
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|tempnam
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"pp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
operator|*
name|t
condition|)
block|{
case|case
literal|'r'
case|:
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s>%s"
argument_list|,
name|command
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|buff
argument_list|)
operator|||
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|add
argument_list|(
name|f
argument_list|,
name|command
argument_list|,
name|name
argument_list|,
name|delete
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|f
return|;
case|case
literal|'w'
case|:
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|add
argument_list|(
name|f
argument_list|,
name|command
argument_list|,
name|name
argument_list|,
name|execute
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|f
return|;
default|default:
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
name|int
name|mypclose
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|todo
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|char
name|buff
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|status
decl_stmt|;
for|for
control|(
name|p
operator|=
name|todolist
operator|,
name|prev
operator|=
operator|&
name|todolist
init|;
name|p
condition|;
name|prev
operator|=
operator|&
operator|(
name|p
operator|->
name|next
operator|)
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|f
operator|==
name|f
condition|)
block|{
operator|*
name|prev
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|name
operator|=
name|p
operator|->
name|name
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|what
condition|)
block|{
case|case
name|delete
case|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
name|status
operator|=
name|EOF
expr_stmt|;
else|else
name|status
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
return|return
name|status
return|;
case|case
name|execute
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s<%s"
argument_list|,
name|p
operator|->
name|command
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|system
argument_list|(
name|buff
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
name|status
operator|=
name|EOF
expr_stmt|;
else|else
name|status
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
return|return
name|status
return|;
default|default:
return|return
name|EOF
return|;
block|}
block|}
return|return
name|EOF
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up at the end.  Called by the onexit handler.  */
end_comment

begin_function
specifier|static
name|int
name|close_pipes
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|todo
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|todolist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
operator|(
name|void
operator|)
name|mypclose
argument_list|(
name|p
operator|->
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

