begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: Activate.c,v 1.16 88/02/02 19:08:46 jim Exp $ */
end_comment

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985	*/
end_comment

begin_include
include|#
directive|include
file|<X11/copyright.h>
end_include

begin_comment
comment|/*  * XMenu:	MIT Project Athena, X Window system menu package  *  *	XMenuActivate -	Maps a given menu to the display and activates  *			the menu for user selection.  The user is allowed to  *			specify which pane and selection will be current,  *			the X and Y location of the menu (relative to the  *			parent window) and the mouse button event mask that  *			will be used to identify a selection request.  *  *			A menu selection is shown to be current by placing  *			a highlight box around the selection as the mouse  *			cursor enters its active region.  Inactive selections  *			will not be highlited.	As the mouse cursor moved  *			from one menu pane to another menu pane the pane being  *			entered is raised and made current and the pane being  *			left is lowered.  *  *			Anytime XMenuActivate returns, the p_num and  *			s_num are left at their last known values (i.e.,  *			the last known current pane and selection indices).  *			The following are the defined return states:  *  *			1)	If at any time an error occurs the data  *				pointer is left untouched and XM_FAILURE  *				is returned.    *  *			2)	When a selection request is recieved (i.e.,  *				when the specified mouse event occurs) the  *				data pointer will be set to the data  *				associated with the particular selection  *				current at the time of the selection request  *				and XM_SUCCESS is returned.  *  *			3)	If no selection was current at the time a  *				selection request is made the data pointer  *				will be left untouched and XM_NO_SELECT will  *				be returned.  *  *			4)	If the selection that was current at the time   *				a selection request is made is not an active  *				selection the data pointer will be left  *				untouched and XM_IA_SELECT will be returned.  *  *			Since X processes events in an asynchronous manner  *			it is likely that XMenuActivate will encounter  *			a "foreign event" while it is executing.  Foreign  *			events are handled in one of three ways:  *  *			1)	The event is discarded.  This is the default  *				mode and requires no action on the part of the  *				application.  *  *			2)	The application has identified an asynchronous  *				event handler that will be called and the  *				foreign event handed off to it.  Note:  *				AEQ mode disables this mode temporarily.  *  *			3)	The application has enabled asynchronous event  *				queueing mode.  In this mode all foreign events  *				will be	queued up untill XMenuActivate  *				terminates; at which time they will be  *				returned to the	X event queue.  As long as  *				AEQ mode is enabled any asynchronous event  *				handler as temporarily disabled.  *  *			Any events encountered while taking down the menu  *			(i.e., exposure events from occluded windows) will  *			automatically be returned to the X event queue after  *			XMenuActivate has cleaned the queue of any of its own  *			events that are no longer needed.  *  *	Author:		Tony Della Fera, DEC  *			March 12, 1986  *  */
end_comment

begin_include
include|#
directive|include
file|"XMenuInt.h"
end_include

begin_function
name|int
name|XMenuActivate
parameter_list|(
name|display
parameter_list|,
name|menu
parameter_list|,
name|p_num
parameter_list|,
name|s_num
parameter_list|,
name|x_pos
parameter_list|,
name|y_pos
parameter_list|,
name|event_mask
parameter_list|,
name|data
parameter_list|)
specifier|register
name|Display
modifier|*
name|display
decl_stmt|;
comment|/* Display to put menu on. */
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
comment|/* Menu to activate. */
name|int
modifier|*
name|p_num
decl_stmt|;
comment|/* Pane number selected. */
name|int
modifier|*
name|s_num
decl_stmt|;
comment|/* Selection number selected. */
name|int
name|x_pos
decl_stmt|;
comment|/* X coordinate of menu position. */
name|int
name|y_pos
decl_stmt|;
comment|/* Y coordinate of menu position. */
name|unsigned
name|int
name|event_mask
decl_stmt|;
comment|/* Mouse button event mask. */
name|char
modifier|*
modifier|*
name|data
decl_stmt|;
comment|/* Pointer to return data value. */
block|{
name|int
name|status
decl_stmt|;
comment|/* X routine call status. */
name|int
name|orig_x
decl_stmt|;
comment|/* Upper left menu origin X coord. */
name|int
name|orig_y
decl_stmt|;
comment|/* Upper left menu origin Y coord. */
name|int
name|ret_val
decl_stmt|;
comment|/* Return value. */
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
comment|/* Current XMPane. */
specifier|register
name|XMPane
modifier|*
name|event_xmp
decl_stmt|;
comment|/* Event XMPane pointer. */
specifier|register
name|XMPane
modifier|*
name|cur_p
decl_stmt|;
comment|/* Current pane. */
specifier|register
name|XMSelect
modifier|*
name|cur_s
decl_stmt|;
comment|/* Current selection. */
name|XMWindow
modifier|*
name|event_xmw
decl_stmt|;
comment|/* Event XMWindow pointer. */
name|XEvent
name|event
decl_stmt|;
comment|/* X input event. */
name|XEvent
name|peek_event
decl_stmt|;
comment|/* X input peek ahead event. */
name|Bool
name|selection
init|=
name|False
decl_stmt|;
comment|/* Selection has been made. */
name|Bool
name|forward
init|=
name|True
decl_stmt|;
comment|/* Moving forward in the pane list. */
name|Window
name|root
decl_stmt|,
name|child
decl_stmt|;
name|int
name|root_x
decl_stmt|,
name|root_y
decl_stmt|,
name|win_x
decl_stmt|,
name|win_y
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
comment|/*      * Define and allocate a foreign event queue to hold events      * that don't belong to XMenu.  These events are later restored      * to the X event queue.      */
typedef|typedef
struct|struct
name|_xmeventque
block|{
name|XEvent
name|event
decl_stmt|;
name|struct
name|_xmeventque
modifier|*
name|next
decl_stmt|;
block|}
name|XMEventQue
typedef|;
name|XMEventQue
modifier|*
name|feq
init|=
name|NULL
decl_stmt|;
comment|/* Foreign event queue. */
name|XMEventQue
modifier|*
name|feq_tmp
decl_stmt|;
comment|/* Foreign event queue temporary. */
comment|/*      * If there are no panes in the menu then return failure      * because the menu is not initialized.      */
if|if
condition|(
name|menu
operator|->
name|p_count
operator|==
literal|0
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_NOT_INIT
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
comment|/*      * Find the desired current pane.      */
name|cur_p
operator|=
name|_XMGetPanePtr
argument_list|(
name|menu
argument_list|,
operator|*
name|p_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_p
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
name|cur_p
operator|->
name|activated
operator|=
name|cur_p
operator|->
name|active
expr_stmt|;
comment|/*      * Find the desired current selection.      * If the current selection index is out of range a null current selection      * will be assumed and the cursor will be placed in the current pane      * header.      */
name|cur_s
operator|=
name|_XMGetSelectionPtr
argument_list|(
name|cur_p
argument_list|,
operator|*
name|s_num
argument_list|)
expr_stmt|;
comment|/*      * Compute origin of menu so that cursor is in      * Correct pane and selection.      */
name|_XMTransToOrigin
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|cur_p
argument_list|,
name|cur_s
argument_list|,
name|x_pos
argument_list|,
name|y_pos
argument_list|,
operator|&
name|orig_x
argument_list|,
operator|&
name|orig_y
argument_list|)
expr_stmt|;
name|menu
operator|->
name|x_pos
operator|=
name|orig_x
expr_stmt|;
comment|/* Store X and Y coords of menu. */
name|menu
operator|->
name|y_pos
operator|=
name|orig_y
expr_stmt|;
if|if
condition|(
name|XMenuRecompute
argument_list|(
name|display
argument_list|,
name|menu
argument_list|)
operator|==
name|XM_FAILURE
condition|)
block|{
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
comment|/*      * Flush the window creation queue.      * This batches all window creates since lazy evaluation      * is more efficient than individual evaluation.      * This routine also does an XFlush().      */
if|if
condition|(
name|_XMWinQueFlush
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|cur_p
argument_list|,
name|cur_s
argument_list|)
operator|==
name|_FAILURE
condition|)
block|{
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
comment|/*      * Make sure windows are in correct order (in case we were passed      * an already created menu in incorrect order.)      */
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|cur_p
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
name|XRaiseWindow
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|prev
init|;
name|p_ptr
operator|!=
name|cur_p
operator|->
name|prev
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|prev
control|)
name|XRaiseWindow
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
comment|/*      * Make sure all selection windows are mapped.      */
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
block|{
name|XMapSubwindows
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
comment|/*      * Synchronize the X buffers and the event queue.      * From here on, all events in the queue that don't belong to      * XMenu are sent back to the application via an application      * provided event handler or discarded if the application has      * not provided an event handler.      */
name|XSync
argument_list|(
name|display
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Grab the mouse for menu input.      */
name|status
operator|=
name|XGrabPointer
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|parent
argument_list|,
name|True
argument_list|,
name|event_mask
argument_list|,
name|GrabModeAsync
argument_list|,
name|GrabModeAsync
argument_list|,
name|None
argument_list|,
name|menu
operator|->
name|mouse_cursor
argument_list|,
name|CurrentTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|_X_FAILURE
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_GRAB_MOUSE
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
comment|/*      * Map the menu panes.      */
name|XMapWindow
argument_list|(
name|display
argument_list|,
name|cur_p
operator|->
name|window
argument_list|)
expr_stmt|;
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|cur_p
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
name|XMapWindow
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
for|for
control|(
name|p_ptr
operator|=
name|cur_p
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
name|XMapWindow
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
name|XRaiseWindow
argument_list|(
name|display
argument_list|,
name|cur_p
operator|->
name|window
argument_list|)
expr_stmt|;
comment|/* Make sure current */
comment|/* pane is on top. */
name|cur_s
operator|=
name|NULL
expr_stmt|;
comment|/* Clear current selection. */
comment|/*      * Begin event processing loop.      */
while|while
condition|(
literal|1
condition|)
block|{
name|XNextEvent
argument_list|(
name|display
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
comment|/* Get next event. */
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
comment|/* Dispatch on the event type. */
case|case
name|Expose
case|:
name|event_xmp
operator|=
operator|(
name|XMPane
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|assoc_tab
argument_list|,
name|event
operator|.
name|xexpose
operator|.
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If AEQ mode is enabled then queue the event. 		 */
if|if
condition|(
name|menu
operator|->
name|aeq
condition|)
block|{
name|feq_tmp
operator|=
operator|(
name|XMEventQue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XMEventQue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|feq_tmp
operator|==
name|NULL
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_CALLOC
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
name|feq_tmp
operator|->
name|event
operator|=
name|event
expr_stmt|;
name|feq_tmp
operator|->
name|next
operator|=
name|feq
expr_stmt|;
name|feq
operator|=
name|feq_tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_XMEventHandler
condition|)
call|(
modifier|*
name|_XMEventHandler
call|)
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|event_xmp
operator|->
name|activated
condition|)
block|{
name|XSetWindowBackground
argument_list|(
name|display
argument_list|,
name|event_xmp
operator|->
name|window
argument_list|,
name|menu
operator|->
name|bkgnd_color
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XSetWindowBackgroundPixmap
argument_list|(
name|display
argument_list|,
name|event_xmp
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inact_pixmap
argument_list|)
expr_stmt|;
block|}
name|_XMRefreshPane
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|event_xmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|EnterNotify
case|:
comment|/*  	     * First wait a small period of time, and see 	     * if another EnterNotify event follows hard on the 	     * heels of this one. i.e., the user is simply 	     * "passing through". If so, ignore this one. 	     */
name|event_xmw
operator|=
operator|(
name|XMWindow
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|assoc_tab
argument_list|,
name|event
operator|.
name|xcrossing
operator|.
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmw
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|event_xmw
operator|->
name|type
operator|==
name|SELECTION
condition|)
block|{
comment|/* 		 * We have entered a selection. 		 */
comment|/* if (XPending(display) == 0) usleep(150000); */
if|if
condition|(
name|XPending
argument_list|(
name|display
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XPeekEvent
argument_list|(
name|display
argument_list|,
operator|&
name|peek_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_event
operator|.
name|type
operator|==
name|LeaveNotify
condition|)
block|{
break|break;
block|}
block|}
name|cur_s
operator|=
operator|(
name|XMSelect
operator|*
operator|)
name|event_xmw
expr_stmt|;
comment|/* 		 * If the pane we are in is active and the 		 * selection entered is active then activate 		 * the selection. 		 */
if|if
condition|(
name|cur_p
operator|->
name|active
operator|&&
name|cur_s
operator|->
name|active
condition|)
block|{
name|cur_s
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
name|_XMRefreshSelection
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|cur_s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We have entered a pane. 		 */
comment|/* if (XPending(display) == 0) usleep(150000); */
if|if
condition|(
name|XPending
argument_list|(
name|display
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|XPeekEvent
argument_list|(
name|display
argument_list|,
operator|&
name|peek_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_event
operator|.
name|type
operator|==
name|EnterNotify
condition|)
break|break;
block|}
name|XQueryPointer
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|parent
argument_list|,
operator|&
name|root
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|root_x
argument_list|,
operator|&
name|root_y
argument_list|,
operator|&
name|win_x
argument_list|,
operator|&
name|win_y
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|event_xmp
operator|=
operator|(
name|XMPane
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|assoc_tab
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmp
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|event_xmp
operator|==
name|cur_p
condition|)
break|break;
if|if
condition|(
name|event_xmp
operator|->
name|serial
operator|>
name|cur_p
operator|->
name|serial
condition|)
name|forward
operator|=
name|True
expr_stmt|;
else|else
name|forward
operator|=
name|False
expr_stmt|;
name|p_ptr
operator|=
name|cur_p
expr_stmt|;
while|while
condition|(
name|p_ptr
operator|!=
name|event_xmp
condition|)
block|{
if|if
condition|(
name|forward
condition|)
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
expr_stmt|;
else|else
name|p_ptr
operator|=
name|p_ptr
operator|->
name|prev
expr_stmt|;
name|XRaiseWindow
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_p
operator|->
name|activated
condition|)
block|{
name|cur_p
operator|->
name|activated
operator|=
name|False
expr_stmt|;
name|XSetWindowBackgroundPixmap
argument_list|(
name|display
argument_list|,
name|cur_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inact_pixmap
argument_list|)
expr_stmt|;
name|_XMRefreshPane
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|cur_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event_xmp
operator|->
name|active
condition|)
name|event_xmp
operator|->
name|activated
operator|=
name|True
expr_stmt|;
name|cur_p
operator|=
name|event_xmp
expr_stmt|;
block|}
break|break;
case|case
name|LeaveNotify
case|:
name|event_xmw
operator|=
operator|(
name|XMWindow
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|assoc_tab
argument_list|,
name|event
operator|.
name|xcrossing
operator|.
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmw
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|cur_s
operator|==
name|NULL
condition|)
break|break;
comment|/* 	     * If the current selection was activated then 	     * deactivate it. 	     */
if|if
condition|(
name|cur_s
operator|->
name|activated
condition|)
block|{
name|cur_s
operator|->
name|activated
operator|=
name|False
expr_stmt|;
name|_XMRefreshSelection
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|cur_s
argument_list|)
expr_stmt|;
block|}
name|cur_s
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|ButtonPress
case|:
case|case
name|ButtonRelease
case|:
operator|*
name|p_num
operator|=
name|cur_p
operator|->
name|serial
expr_stmt|;
comment|/* 		 * Check to see if there is a current selecion. 		 */
if|if
condition|(
name|cur_s
operator|!=
name|NULL
condition|)
block|{
comment|/* 		     * Set the selection number to the current selection. 		     */
operator|*
name|s_num
operator|=
name|cur_s
operator|->
name|serial
expr_stmt|;
comment|/* 		     * If the current selection was activated then 		     * we have a valid selection otherwise we have 		     * an inactive selection. 		     */
if|if
condition|(
name|cur_s
operator|->
name|activated
condition|)
block|{
operator|*
name|data
operator|=
name|cur_s
operator|->
name|data
expr_stmt|;
name|ret_val
operator|=
name|XM_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|XM_IA_SELECT
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * No selection was current. 		     */
name|ret_val
operator|=
name|XM_NO_SELECT
expr_stmt|;
block|}
name|selection
operator|=
name|True
expr_stmt|;
break|break;
default|default:
comment|/* 		 * If AEQ mode is enabled then queue the event. 		 */
if|if
condition|(
name|menu
operator|->
name|aeq
condition|)
block|{
name|feq_tmp
operator|=
operator|(
name|XMEventQue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XMEventQue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|feq_tmp
operator|==
name|NULL
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_CALLOC
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
name|feq_tmp
operator|->
name|event
operator|=
name|event
expr_stmt|;
name|feq_tmp
operator|->
name|next
operator|=
name|feq
expr_stmt|;
name|feq
operator|=
name|feq_tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_XMEventHandler
condition|)
call|(
modifier|*
name|_XMEventHandler
call|)
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If a selection has been made, break out of the event loop. 	 */
if|if
condition|(
name|selection
operator|==
name|True
condition|)
break|break;
block|}
comment|/*      * Unmap the menu.      */
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
block|{
name|XUnmapWindow
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
comment|/*      * Ungrab the mouse.      */
name|XUngrabPointer
argument_list|(
name|display
argument_list|,
name|CurrentTime
argument_list|)
expr_stmt|;
comment|/*       * Restore bits under where the menu was if we managed      * to save them and free the pixmap.      */
comment|/*      * If there is a current selection deactivate it.      */
if|if
condition|(
name|cur_s
operator|!=
name|NULL
condition|)
name|cur_s
operator|->
name|activated
operator|=
literal|0
expr_stmt|;
comment|/*      * Deactivate the current pane.      */
name|cur_p
operator|->
name|activated
operator|=
literal|0
expr_stmt|;
name|XSetWindowBackgroundPixmap
argument_list|(
name|display
argument_list|,
name|cur_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inact_pixmap
argument_list|)
expr_stmt|;
comment|/*      * Synchronize the X buffers and the X event queue.      */
name|XSync
argument_list|(
name|display
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Dispatch any events remaining on the queue.      */
while|while
condition|(
name|QLength
argument_list|(
name|display
argument_list|)
condition|)
block|{
comment|/* 	 * Fetch the next event. 	 */
name|XNextEvent
argument_list|(
name|display
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
comment|/* 	 * Discard any events left on the queue that belong to XMenu. 	 * All others are held and then returned to the event queue. 	 */
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|Expose
case|:
case|case
name|EnterNotify
case|:
case|case
name|LeaveNotify
case|:
case|case
name|ButtonPress
case|:
case|case
name|ButtonRelease
case|:
comment|/* 		 * Does this event belong to one of XMenu's windows? 		 * If so, discard it and process the next event. 		 * If not fall through and treat it as a foreign event. 		 */
name|event_xmp
operator|=
operator|(
name|XMPane
operator|*
operator|)
name|XLookUpAssoc
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|assoc_tab
argument_list|,
name|event
operator|.
name|xbutton
operator|.
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_xmp
operator|!=
name|NULL
condition|)
continue|continue;
default|default:
comment|/* 		 * This is a foreign event. 		 * Queue it for later return to the X event queue. 		 */
name|feq_tmp
operator|=
operator|(
name|XMEventQue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XMEventQue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|feq_tmp
operator|==
name|NULL
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_CALLOC
expr_stmt|;
return|return
operator|(
name|XM_FAILURE
operator|)
return|;
block|}
name|feq_tmp
operator|->
name|event
operator|=
name|event
expr_stmt|;
name|feq_tmp
operator|->
name|next
operator|=
name|feq
expr_stmt|;
name|feq
operator|=
name|feq_tmp
expr_stmt|;
block|}
block|}
comment|/*      * Return any foreign events that were queued to the X event queue.      */
while|while
condition|(
name|feq
operator|!=
name|NULL
condition|)
block|{
name|feq_tmp
operator|=
name|feq
expr_stmt|;
name|XPutBackEvent
argument_list|(
name|display
argument_list|,
operator|&
name|feq_tmp
operator|->
name|event
argument_list|)
expr_stmt|;
name|feq
operator|=
name|feq_tmp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|feq_tmp
argument_list|)
expr_stmt|;
block|}
comment|/*      * Return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

end_unit

