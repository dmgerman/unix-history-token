begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Makeinfo -- convert texinfo format files into info files    Copyright (C) 1987 Free Software Foundation, Inc.  This file is part of GNU Info.  GNU Info is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Info is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Info; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Include File Declarations       	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<perror.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
end_if

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|source
parameter_list|,
name|dest
parameter_list|,
name|count
parameter_list|)
value|memcpy (dest, source, count)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declarations. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|in_fixed_width_font
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some systems don't declare this function in pwd.h. */
end_comment

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			      Global Defines  			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Error levels */
end_comment

begin_define
define|#
directive|define
name|NO_ERROR
value|0
end_define

begin_define
define|#
directive|define
name|SYNTAX
value|2
end_define

begin_define
define|#
directive|define
name|FATAL
value|4
end_define

begin_comment
comment|/* Boolean values. */
end_comment

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_typedef
typedef|typedef
name|int
name|boolean
typedef|;
end_typedef

begin_comment
comment|/* How to allocate permanent storage for STRING. */
end_comment

begin_define
define|#
directive|define
name|savestring
parameter_list|(
name|x
parameter_list|)
define|\
value|((char *)strcpy (xmalloc (1 + ((x) ? strlen (x) : 0)), (x) ? (x) : ""))
end_define

begin_comment
comment|/* C's standard macros don't check to make sure that the characters being    changed are within range.  So I have to check explicitly. */
end_comment

begin_comment
comment|/* GNU Library doesn't have toupper().  Until GNU gets this fixed, I will    have to do it. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|toupper
end_ifndef

begin_define
define|#
directive|define
name|toupper
parameter_list|(
name|c
parameter_list|)
value|((c) - 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|coerce_to_upper
parameter_list|(
name|c
parameter_list|)
value|((islower(c) ? toupper(c) : (c)))
end_define

begin_define
define|#
directive|define
name|coerce_to_lower
parameter_list|(
name|c
parameter_list|)
value|((isupper(c) ? tolower(c) : (c)))
end_define

begin_define
define|#
directive|define
name|control_character_bit
value|0x40
end_define

begin_comment
comment|/* %01000000, must be off. */
end_comment

begin_define
define|#
directive|define
name|meta_character_bit
value|0x080
end_define

begin_comment
comment|/* %10000000, must be on.  */
end_comment

begin_define
define|#
directive|define
name|CTL
parameter_list|(
name|c
parameter_list|)
value|((c)& (~control_character_bit))
end_define

begin_define
define|#
directive|define
name|UNCTL
parameter_list|(
name|c
parameter_list|)
value|coerce_to_upper(((c)|control_character_bit))
end_define

begin_define
define|#
directive|define
name|META
parameter_list|(
name|c
parameter_list|)
value|((c) | (meta_character_bit))
end_define

begin_define
define|#
directive|define
name|UNMETA
parameter_list|(
name|c
parameter_list|)
value|((c)& (~meta_character_bit))
end_define

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == '\t') || ((c) == ' '))
end_define

begin_define
define|#
directive|define
name|sentence_ender
parameter_list|(
name|c
parameter_list|)
value|((c) == '.' || (c) == '?' || (c) == '!')
end_define

begin_define
define|#
directive|define
name|cr_or_whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == '\t') || ((c) == ' ') || ((c) == '\n'))
end_define

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|(index (s, c) != NULL)
end_define

begin_define
define|#
directive|define
name|COMMAND_PREFIX
value|'@'
end_define

begin_comment
comment|/* Stuff for splitting large files. */
end_comment

begin_define
define|#
directive|define
name|SPLIT_SIZE_THRESHOLD
value|70000
end_define

begin_comment
comment|/* What's good enough for Stallman... */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SPLIT_SIZE
value|50000
end_define

begin_comment
comment|/* Is probably good enough for me. */
end_comment

begin_decl_stmt
name|boolean
name|splitting
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Always true for now. */
end_comment

begin_typedef
typedef|typedef
name|int
name|FUNCTION
parameter_list|()
function_decl|;
end_typedef

begin_comment
comment|/* So I can say FUNCTION *foo; */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			    Global Variables			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Global pointer to argv[0]. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current input file state. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|input_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_of_input_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_text_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line_number
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|curchar
parameter_list|()
value|input_text[input_text_offset]
end_define

begin_define
define|#
directive|define
name|command_char
parameter_list|(
name|c
parameter_list|)
value|((!whitespace(c))&& \ 			  ((c) != '\n')&& \ 			  ((c) != '{'))
end_define

begin_define
define|#
directive|define
name|skip_whitespace
parameter_list|()
value|while (input_text_offset != size_of_input_text \&& whitespace(curchar()))\   input_text_offset++
end_define

begin_comment
comment|/* And writing to the output. */
end_comment

begin_comment
comment|/* The output file name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_filename
decl_stmt|,
modifier|*
name|pretty_output_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current output stream. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|output_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position in the output file. */
end_comment

begin_decl_stmt
name|int
name|output_position
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output paragraph buffer. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_paragraph
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset into OUTPUT_PARAGRAPH. */
end_comment

begin_decl_stmt
name|int
name|output_paragraph_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The output paragraph "cursor" horizontal position. */
end_comment

begin_decl_stmt
name|int
name|output_column
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-zero means output_paragraph contains text. */
end_comment

begin_decl_stmt
name|boolean
name|paragraph_is_open
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INITIAL_PARAGRAPH_SPACE
value|5000
end_define

begin_decl_stmt
name|int
name|paragraph_buffer_len
init|=
name|INITIAL_PARAGRAPH_SPACE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filling.. */
end_comment

begin_comment
comment|/* True indicates that filling will take place on long lines. */
end_comment

begin_decl_stmt
name|boolean
name|filling_enabled
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that words are not to be split, even in long lines.  This    gets changed for cm_w (). */
end_comment

begin_decl_stmt
name|int
name|non_splitting_words
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True indicates that filling a line also indents the new line. */
end_comment

begin_decl_stmt
name|boolean
name|indented_fill
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The column at which long lines are broken. */
end_comment

begin_decl_stmt
name|int
name|fill_column
init|=
literal|72
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount of indentation to apply at the start of each line. */
end_comment

begin_decl_stmt
name|int
name|current_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount of indentation to add at the starts of paragraphs.    0 means don't change existing indentation at paragraph starts.> 0 is amount to indent new paragraphs by.< 0 means indent to column zero by removing indentation if necessary.     This is normally zero, but some people prefer paragraph starts to be    somewhat more indented than paragraph bodies.  A pretty value for    this is 3. */
end_comment

begin_decl_stmt
name|int
name|paragraph_start_indent
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the use of paragraph_start_indent is inhibited.    @example uses this to line up the left columns of the example text. */
end_comment

begin_decl_stmt
name|int
name|inhibit_paragraph_indentation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indentation that is pending insertion.  We have this for hacking lines    which look blank, but contain whitespace.  We want to treat those as    blank lines. */
end_comment

begin_decl_stmt
name|int
name|pending_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount that indentation increases/decreases by. */
end_comment

begin_decl_stmt
name|int
name|default_indentation_increment
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True indicates that indentation is temporarily turned off. */
end_comment

begin_decl_stmt
name|boolean
name|no_indent
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command name in the process of being hacked. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index in our internal command table of the currently    executing command. */
end_comment

begin_decl_stmt
name|int
name|command_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A stack of file information records.  If a new file is read in with    "@input", we remember the old input file state on this stack. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fstack
block|{
name|struct
name|fstack
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|line_number
decl_stmt|;
block|}
name|FSTACK
typedef|;
end_typedef

begin_decl_stmt
name|FSTACK
modifier|*
name|filestack
init|=
operator|(
name|FSTACK
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff for nodes. */
end_comment

begin_comment
comment|/* The current nodes node name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current nodes section level. */
end_comment

begin_decl_stmt
name|int
name|current_section
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The filename of the current input file.  This is never freed. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|node_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we remember for each node. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tentry
block|{
name|struct
name|tentry
modifier|*
name|next_ent
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
comment|/* name of this node. */
name|char
modifier|*
name|prev
decl_stmt|;
comment|/* name of "Prev:" for this node. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* name of "Next:" for this node. */
name|char
modifier|*
name|up
decl_stmt|;
comment|/* name of "Up:" for this node.   */
name|int
name|position
decl_stmt|;
comment|/* output file position of this node. */
name|int
name|line_no
decl_stmt|;
comment|/* defining line in source file. */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The file that this node was found in. */
name|int
name|touched
decl_stmt|;
comment|/* non-zero means this node has been referenced. */
name|int
name|flags
decl_stmt|;
comment|/* Room for growth.  Right now, contains 1 bit. */
block|}
name|TAG_ENTRY
typedef|;
end_typedef

begin_comment
comment|/* If node-a has a "Next" for node-b, but node-b has no "Prev" for node-a,    we turn on this flag bit in node-b's tag entry.  This means that when    it is time to validate node-b, we don't report an additional error    if there was no "Prev" field. */
end_comment

begin_define
define|#
directive|define
name|PREV_ERROR
value|0x1
end_define

begin_define
define|#
directive|define
name|NEXT_ERROR
value|0x2
end_define

begin_define
define|#
directive|define
name|UP_ERROR
value|0x4
end_define

begin_define
define|#
directive|define
name|NO_WARN
value|0x8
end_define

begin_decl_stmt
name|TAG_ENTRY
modifier|*
name|tag_table
init|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Menu reference, *note reference, and validation hacking. */
end_comment

begin_comment
comment|/* The various references that we know about. */
end_comment

begin_enum
enum|enum
name|reftype
block|{
name|menu_reference
block|,
name|followed_reference
block|}
enum|;
end_enum

begin_comment
comment|/* A structure to remember references with.  A reference to a node is    either an entry in a menu, or a cross-reference made with [px]ref. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|node_ref
block|{
name|struct
name|node_ref
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
comment|/* Name of node referred to. */
name|char
modifier|*
name|containing_node
decl_stmt|;
comment|/* Name of node containing this reference. */
name|int
name|line_no
decl_stmt|;
comment|/* Line number where the reference occurs. */
name|int
name|section
decl_stmt|;
comment|/* Section level where the reference occurs. */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Name of file where the reference occurs. */
name|enum
name|reftype
name|type
decl_stmt|;
comment|/* Type of reference, either menu or note. */
block|}
name|NODE_REF
typedef|;
end_typedef

begin_comment
comment|/* The linked list of such structures. */
end_comment

begin_decl_stmt
name|NODE_REF
modifier|*
name|node_references
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag which tells us whether to examine menu lines or not. */
end_comment

begin_decl_stmt
name|int
name|in_menu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags controlling the operation of the program. */
end_comment

begin_comment
comment|/* Default is to notify users of bad choices. */
end_comment

begin_decl_stmt
name|boolean
name|print_warnings
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to check node references. */
end_comment

begin_decl_stmt
name|boolean
name|validating
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of errors that we tolerate on a given fileset. */
end_comment

begin_decl_stmt
name|int
name|max_error_level
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of references to a single node before complaining. */
end_comment

begin_decl_stmt
name|int
name|reference_warning_limit
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print out information about what is going on when it    is going on. */
end_comment

begin_decl_stmt
name|int
name|verbose_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of commands that we hack in texinfo.  Each one    has an associated function.  When the command is encountered in the    text, the associated function is called with START as the argument.    If the function expects arguments in braces, it remembers itself on    the stack.  When the corresponding close brace is encountered, the    function is called with END as the argument. */
end_comment

begin_define
define|#
directive|define
name|START
value|0
end_define

begin_define
define|#
directive|define
name|END
value|1
end_define

begin_typedef
typedef|typedef
struct|struct
name|brace_element
block|{
name|struct
name|brace_element
modifier|*
name|next
decl_stmt|;
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|line
decl_stmt|;
block|}
name|BRACE_ELEMENT
typedef|;
end_typedef

begin_decl_stmt
name|BRACE_ELEMENT
modifier|*
name|brace_stack
init|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations. */
end_comment

begin_decl_stmt
name|int
name|insert_self
argument_list|()
decl_stmt|,
name|cm_tex
argument_list|()
decl_stmt|,
name|cm_asterisk
argument_list|()
decl_stmt|,
name|cm_dots
argument_list|()
decl_stmt|,
name|cm_bullet
argument_list|()
decl_stmt|,
name|cm_TeX
argument_list|()
decl_stmt|,
name|cm_copyright
argument_list|()
decl_stmt|,
name|cm_code
argument_list|()
decl_stmt|,
name|cm_samp
argument_list|()
decl_stmt|,
name|cm_file
argument_list|()
decl_stmt|,
name|cm_kbd
argument_list|()
decl_stmt|,
name|cm_key
argument_list|()
decl_stmt|,
name|cm_ctrl
argument_list|()
decl_stmt|,
name|cm_var
argument_list|()
decl_stmt|,
name|cm_dfn
argument_list|()
decl_stmt|,
name|cm_emph
argument_list|()
decl_stmt|,
name|cm_strong
argument_list|()
decl_stmt|,
name|cm_cite
argument_list|()
decl_stmt|,
name|cm_italic
argument_list|()
decl_stmt|,
name|cm_bold
argument_list|()
decl_stmt|,
name|cm_roman
argument_list|()
decl_stmt|,
name|cm_title
argument_list|()
decl_stmt|,
name|cm_w
argument_list|()
decl_stmt|,
name|cm_refill
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cm_chapter
argument_list|()
decl_stmt|,
name|cm_unnumbered
argument_list|()
decl_stmt|,
name|cm_appendix
argument_list|()
decl_stmt|,
name|cm_section
argument_list|()
decl_stmt|,
name|cm_unnumberedsec
argument_list|()
decl_stmt|,
name|cm_appendixsec
argument_list|()
decl_stmt|,
name|cm_subsection
argument_list|()
decl_stmt|,
name|cm_unnumberedsubsec
argument_list|()
decl_stmt|,
name|cm_appendixsubsec
argument_list|()
decl_stmt|,
name|cm_subsubsection
argument_list|()
decl_stmt|,
name|cm_unnumberedsubsubsec
argument_list|()
decl_stmt|,
name|cm_appendixsubsubsec
argument_list|()
decl_stmt|,
name|cm_heading
argument_list|()
decl_stmt|,
name|cm_chapheading
argument_list|()
decl_stmt|,
name|cm_subheading
argument_list|()
decl_stmt|,
name|cm_subsubheading
argument_list|()
decl_stmt|,
name|cm_majorheading
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All @defxxx commands map to cm_defun (). */
end_comment

begin_function_decl
name|int
name|cm_defun
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|cm_node
argument_list|()
decl_stmt|,
name|cm_menu
argument_list|()
decl_stmt|,
name|cm_xref
argument_list|()
decl_stmt|,
name|cm_pxref
argument_list|()
decl_stmt|,
name|cm_inforef
argument_list|()
decl_stmt|,
name|cm_quotation
argument_list|()
decl_stmt|,
name|cm_display
argument_list|()
decl_stmt|,
name|cm_itemize
argument_list|()
decl_stmt|,
name|cm_enumerate
argument_list|()
decl_stmt|,
name|cm_table
argument_list|()
decl_stmt|,
name|cm_itemx
argument_list|()
decl_stmt|,
name|cm_noindent
argument_list|()
decl_stmt|,
name|cm_setfilename
argument_list|()
decl_stmt|,
name|cm_comment
argument_list|()
decl_stmt|,
name|cm_ignore
argument_list|()
decl_stmt|,
name|cm_br
argument_list|()
decl_stmt|,
name|cm_sp
argument_list|()
decl_stmt|,
name|cm_page
argument_list|()
decl_stmt|,
name|cm_group
argument_list|()
decl_stmt|,
name|cm_need
argument_list|()
decl_stmt|,
name|cm_center
argument_list|()
decl_stmt|,
name|cm_include
argument_list|()
decl_stmt|,
name|cm_bye
argument_list|()
decl_stmt|,
name|cm_item
argument_list|()
decl_stmt|,
name|cm_end
argument_list|()
decl_stmt|,
name|cm_infoinclude
argument_list|()
decl_stmt|,
name|cm_ifinfo
argument_list|()
decl_stmt|,
name|cm_iftex
argument_list|()
decl_stmt|,
name|cm_titlepage
argument_list|()
decl_stmt|,
name|cm_titlespec
argument_list|()
decl_stmt|,
name|cm_kindex
argument_list|()
decl_stmt|,
name|cm_cindex
argument_list|()
decl_stmt|,
name|cm_findex
argument_list|()
decl_stmt|,
name|cm_pindex
argument_list|()
decl_stmt|,
name|cm_vindex
argument_list|()
decl_stmt|,
name|cm_tindex
argument_list|()
decl_stmt|,
name|cm_asis
argument_list|()
decl_stmt|,
name|cm_synindex
argument_list|()
decl_stmt|,
name|cm_settitle
argument_list|()
decl_stmt|,
name|cm_setchapternewpage
argument_list|()
decl_stmt|,
name|cm_printindex
argument_list|()
decl_stmt|,
name|cm_minus
argument_list|()
decl_stmt|,
name|cm_footnote
argument_list|()
decl_stmt|,
name|cm_force_abbreviated_whitespace
argument_list|()
decl_stmt|,
name|cm_force_sentence_end
argument_list|()
decl_stmt|,
name|cm_example
argument_list|()
decl_stmt|,
name|cm_smallexample
argument_list|()
decl_stmt|,
name|cm_lisp
argument_list|()
decl_stmt|,
name|cm_format
argument_list|()
decl_stmt|,
name|cm_exdent
argument_list|()
decl_stmt|,
name|cm_defindex
argument_list|()
decl_stmt|,
name|cm_defcodeindex
argument_list|()
decl_stmt|,
name|cm_sc
argument_list|()
decl_stmt|,
name|cm_result
argument_list|()
decl_stmt|,
name|cm_expansion
argument_list|()
decl_stmt|,
name|cm_equiv
argument_list|()
decl_stmt|,
name|cm_print
argument_list|()
decl_stmt|,
name|cm_error
argument_list|()
decl_stmt|,
name|cm_point
argument_list|()
decl_stmt|,
name|cm_smallbook
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|do_nothing
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|misplaced_brace
argument_list|()
decl_stmt|,
name|cm_obsolete
argument_list|()
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
name|boolean
name|argument_in_braces
decl_stmt|;
block|}
name|COMMAND
typedef|;
end_typedef

begin_comment
comment|/* Stuff for defining commands on the fly. */
end_comment

begin_decl_stmt
name|COMMAND
modifier|*
modifier|*
name|user_command_array
init|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|user_command_array_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|COMMAND
name|CommandTable
index|[]
init|=
block|{
block|{
literal|"!"
block|,
name|cm_force_sentence_end
block|,
name|false
block|}
block|,
block|{
literal|"'"
block|,
name|insert_self
block|,
name|false
block|}
block|,
block|{
literal|"*"
block|,
name|cm_asterisk
block|,
name|false
block|}
block|,
block|{
literal|"."
block|,
name|cm_force_sentence_end
block|,
name|false
block|}
block|,
block|{
literal|":"
block|,
name|cm_force_abbreviated_whitespace
block|,
name|false
block|}
block|,
block|{
literal|"?"
block|,
name|cm_force_sentence_end
block|,
name|false
block|}
block|,
block|{
literal|"@"
block|,
name|insert_self
block|,
name|false
block|}
block|,
block|{
literal|" "
block|,
name|insert_self
block|,
name|false
block|}
block|,
block|{
literal|"\n"
block|,
name|insert_self
block|,
name|false
block|}
block|,
block|{
literal|"TeX"
block|,
name|cm_TeX
block|,
name|true
block|}
block|,
block|{
literal|"`"
block|,
name|insert_self
block|,
name|false
block|}
block|,
block|{
literal|"appendix"
block|,
name|cm_appendix
block|,
name|false
block|}
block|,
block|{
literal|"appendixsec"
block|,
name|cm_appendixsec
block|,
name|false
block|}
block|,
block|{
literal|"appendixsubsec"
block|,
name|cm_appendixsubsec
block|,
name|false
block|}
block|,
block|{
literal|"appendixsubsubsec"
block|,
name|cm_appendixsubsubsec
block|,
name|false
block|}
block|,
block|{
literal|"asis"
block|,
name|cm_asis
block|,
name|true
block|}
block|,
block|{
literal|"b"
block|,
name|cm_bold
block|,
name|true
block|}
block|,
block|{
literal|"br"
block|,
name|cm_br
block|,
name|false
block|}
block|,
block|{
literal|"bullet"
block|,
name|cm_bullet
block|,
name|true
block|}
block|,
block|{
literal|"bye"
block|,
name|cm_bye
block|,
name|false
block|}
block|,
block|{
literal|"c"
block|,
name|cm_comment
block|,
name|false
block|}
block|,
block|{
literal|"center"
block|,
name|cm_center
block|,
name|false
block|}
block|,
block|{
literal|"chapheading"
block|,
name|cm_chapheading
block|,
name|false
block|}
block|,
block|{
literal|"chapter"
block|,
name|cm_chapter
block|,
name|false
block|}
block|,
block|{
literal|"cindex"
block|,
name|cm_cindex
block|,
name|false
block|}
block|,
block|{
literal|"cite"
block|,
name|cm_cite
block|,
name|true
block|}
block|,
block|{
literal|"code"
block|,
name|cm_code
block|,
name|true
block|}
block|,
block|{
literal|"comment"
block|,
name|cm_comment
block|,
name|false
block|}
block|,
block|{
literal|"contents"
block|,
name|do_nothing
block|,
name|false
block|}
block|,
block|{
literal|"copyright"
block|,
name|cm_copyright
block|,
name|true
block|}
block|,
block|{
literal|"ctrl"
block|,
name|cm_ctrl
block|,
name|true
block|}
block|,
block|{
literal|"defcodeindex"
block|,
name|cm_defcodeindex
block|,
name|false
block|}
block|,
block|{
literal|"defindex"
block|,
name|cm_defindex
block|,
name|false
block|}
block|,
block|{
literal|"dfn"
block|,
name|cm_dfn
block|,
name|true
block|}
block|,
comment|/* The `def' commands. */
block|{
literal|"defun"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defunx"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defvar"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defvarx"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defopt"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defoptx"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"deffn"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"deffnx"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defspec"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defspecx"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defmac"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
block|{
literal|"defmacx"
block|,
name|cm_defun
block|,
name|false
block|}
block|,
comment|/* The end of the `def' commands. */
block|{
literal|"display"
block|,
name|cm_display
block|,
name|false
block|}
block|,
block|{
literal|"dots"
block|,
name|cm_dots
block|,
name|true
block|}
block|,
block|{
literal|"emph"
block|,
name|cm_emph
block|,
name|true
block|}
block|,
block|{
literal|"end"
block|,
name|cm_end
block|,
name|false
block|}
block|,
block|{
literal|"enumerate"
block|,
name|cm_enumerate
block|,
name|false
block|}
block|,
block|{
literal|"equiv"
block|,
name|cm_equiv
block|,
name|true
block|}
block|,
block|{
literal|"error"
block|,
name|cm_error
block|,
name|true
block|}
block|,
block|{
literal|"example"
block|,
name|cm_example
block|,
name|false
block|}
block|,
block|{
literal|"exdent"
block|,
name|cm_exdent
block|,
name|false
block|}
block|,
block|{
literal|"expansion"
block|,
name|cm_expansion
block|,
name|true
block|}
block|,
block|{
literal|"file"
block|,
name|cm_file
block|,
name|true
block|}
block|,
block|{
literal|"findex"
block|,
name|cm_findex
block|,
name|false
block|}
block|,
block|{
literal|"format"
block|,
name|cm_format
block|,
name|false
block|}
block|,
block|{
literal|"group"
block|,
name|cm_group
block|,
name|false
block|}
block|,
block|{
literal|"heading"
block|,
name|cm_heading
block|,
name|false
block|}
block|,
block|{
literal|"i"
block|,
name|cm_italic
block|,
name|true
block|}
block|,
block|{
literal|"iappendix"
block|,
name|cm_appendix
block|,
name|false
block|}
block|,
block|{
literal|"iappendixsec"
block|,
name|cm_appendixsec
block|,
name|false
block|}
block|,
block|{
literal|"iappendixsubsec"
block|,
name|cm_appendixsubsec
block|,
name|false
block|}
block|,
block|{
literal|"iappendixsubsubsec"
block|,
name|cm_appendixsubsubsec
block|,
name|false
block|}
block|,
block|{
literal|"ichapter"
block|,
name|cm_chapter
block|,
name|false
block|}
block|,
block|{
literal|"ifinfo"
block|,
name|cm_ifinfo
block|,
name|false
block|}
block|,
block|{
literal|"iftex"
block|,
name|cm_iftex
block|,
name|false
block|}
block|,
block|{
literal|"ignore"
block|,
name|cm_ignore
block|,
name|false
block|}
block|,
block|{
literal|"include"
block|,
name|cm_include
block|,
name|false
block|}
block|,
block|{
literal|"inforef"
block|,
name|cm_inforef
block|,
name|true
block|}
block|,
block|{
literal|"input"
block|,
name|cm_include
block|,
name|false
block|}
block|,
block|{
literal|"isection"
block|,
name|cm_section
block|,
name|false
block|}
block|,
block|{
literal|"isubsection"
block|,
name|cm_subsection
block|,
name|false
block|}
block|,
block|{
literal|"isubsubsection"
block|,
name|cm_subsubsection
block|,
name|false
block|}
block|,
block|{
literal|"item"
block|,
name|cm_item
block|,
name|false
block|}
block|,
block|{
literal|"itemize"
block|,
name|cm_itemize
block|,
name|false
block|}
block|,
block|{
literal|"itemx"
block|,
name|cm_itemx
block|,
name|false
block|}
block|,
block|{
literal|"iunnumbered"
block|,
name|cm_unnumbered
block|,
name|false
block|}
block|,
block|{
literal|"iunnumberedsec"
block|,
name|cm_unnumberedsec
block|,
name|false
block|}
block|,
block|{
literal|"iunnumberedsubsec"
block|,
name|cm_unnumberedsubsec
block|,
name|false
block|}
block|,
block|{
literal|"iunnumberedsubsubsec"
block|,
name|cm_unnumberedsubsubsec
block|,
name|false
block|}
block|,
block|{
literal|"kbd"
block|,
name|cm_kbd
block|,
name|true
block|}
block|,
block|{
literal|"key"
block|,
name|cm_key
block|,
name|true
block|}
block|,
block|{
literal|"kindex"
block|,
name|cm_kindex
block|,
name|false
block|}
block|,
block|{
literal|"lisp"
block|,
name|cm_lisp
block|,
name|false
block|}
block|,
block|{
literal|"majorheading"
block|,
name|cm_majorheading
block|,
name|false
block|}
block|,
block|{
literal|"menu"
block|,
name|cm_menu
block|}
block|,
block|{
literal|"minus"
block|,
name|cm_minus
block|,
name|true
block|}
block|,
block|{
literal|"need"
block|,
name|cm_need
block|,
name|false
block|}
block|,
block|{
literal|"node"
block|,
name|cm_node
block|,
name|false
block|}
block|,
block|{
literal|"noindent"
block|,
name|cm_noindent
block|,
name|false
block|}
block|,
block|{
literal|"page"
block|,
name|do_nothing
block|,
name|false
block|}
block|,
block|{
literal|"pindex"
block|,
name|cm_pindex
block|,
name|false
block|}
block|,
block|{
literal|"point"
block|,
name|cm_point
block|,
name|true
block|}
block|,
block|{
literal|"print"
block|,
name|cm_print
block|,
name|true
block|}
block|,
block|{
literal|"printindex"
block|,
name|cm_printindex
block|,
name|false
block|}
block|,
block|{
literal|"pxref"
block|,
name|cm_pxref
block|,
name|true
block|}
block|,
block|{
literal|"quotation"
block|,
name|cm_quotation
block|,
name|false
block|}
block|,
block|{
literal|"r"
block|,
name|cm_roman
block|,
name|true
block|}
block|,
block|{
literal|"ref"
block|,
name|cm_xref
block|,
name|true
block|}
block|,
block|{
literal|"refill"
block|,
name|cm_refill
block|,
name|false
block|}
block|,
block|{
literal|"result"
block|,
name|cm_result
block|,
name|true
block|}
block|,
block|{
literal|"samp"
block|,
name|cm_samp
block|,
name|true
block|}
block|,
block|{
literal|"sc"
block|,
name|cm_sc
block|,
name|true
block|}
block|,
block|{
literal|"section"
block|,
name|cm_section
block|,
name|false
block|}
block|,
block|{
literal|"setchapternewpage"
block|,
name|cm_setchapternewpage
block|,
name|false
block|}
block|,
block|{
literal|"setfilename"
block|,
name|cm_setfilename
block|,
name|false
block|}
block|,
block|{
literal|"settitle"
block|,
name|cm_settitle
block|,
name|false
block|}
block|,
block|{
literal|"smallexample"
block|,
name|cm_smallexample
block|,
name|false
block|}
block|,
block|{
literal|"smallbook"
block|,
name|cm_smallbook
block|,
name|false
block|}
block|,
block|{
literal|"sp"
block|,
name|cm_sp
block|,
name|false
block|}
block|,
block|{
literal|"strong"
block|,
name|cm_strong
block|,
name|true
block|}
block|,
block|{
literal|"subheading"
block|,
name|cm_subheading
block|,
name|false
block|}
block|,
block|{
literal|"subsection"
block|,
name|cm_subsection
block|,
name|false
block|}
block|,
block|{
literal|"subsubheading"
block|,
name|cm_subsubheading
block|,
name|false
block|}
block|,
block|{
literal|"subsubsection"
block|,
name|cm_subsubsection
block|,
name|false
block|}
block|,
block|{
literal|"summarycontents"
block|,
name|do_nothing
block|,
name|false
block|}
block|,
block|{
literal|"syncodeindex"
block|,
name|cm_synindex
block|,
name|false
block|}
block|,
block|{
literal|"synindex"
block|,
name|cm_synindex
block|,
name|false
block|}
block|,
block|{
literal|"t"
block|,
name|cm_title
block|,
name|true
block|}
block|,
block|{
literal|"table"
block|,
name|cm_table
block|,
name|false
block|}
block|,
block|{
literal|"tex"
block|,
name|cm_tex
block|,
name|false
block|}
block|,
block|{
literal|"tindex"
block|,
name|cm_tindex
block|,
name|false
block|}
block|,
block|{
literal|"titlepage"
block|,
name|cm_titlepage
block|,
name|false
block|}
block|,
block|{
literal|"titlespec"
block|,
name|cm_titlespec
block|,
name|false
block|}
block|,
block|{
literal|"unnumbered"
block|,
name|cm_unnumbered
block|,
name|false
block|}
block|,
block|{
literal|"unnumberedsec"
block|,
name|cm_unnumberedsec
block|,
name|false
block|}
block|,
block|{
literal|"unnumberedsubsec"
block|,
name|cm_unnumberedsubsec
block|,
name|false
block|}
block|,
block|{
literal|"unnumberedsubsubsec"
block|,
name|cm_unnumberedsubsubsec
block|,
name|false
block|}
block|,
block|{
literal|"var"
block|,
name|cm_var
block|,
name|true
block|}
block|,
block|{
literal|"vindex"
block|,
name|cm_vindex
block|,
name|false
block|}
block|,
block|{
literal|"w"
block|,
name|cm_w
block|,
name|true
block|}
block|,
block|{
literal|"xref"
block|,
name|cm_xref
block|,
name|true
block|}
block|,
block|{
literal|"{"
block|,
name|insert_self
block|,
name|false
block|}
block|,
block|{
literal|"}"
block|,
name|insert_self
block|,
name|false
block|}
block|,
comment|/* Now @include does what this was supposed to. */
block|{
literal|"infoinclude"
block|,
name|cm_infoinclude
block|,
name|false
block|}
block|,
block|{
literal|"footnote"
block|,
name|cm_footnote
block|,
name|false
block|}
block|,
comment|/* self-arg eater */
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|FUNCTION
operator|*
operator|)
name|NULL
block|}
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means we are running inside of Emacs. */
end_comment

begin_decl_stmt
name|int
name|in_emacs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAKEINFO_MAJOR
end_ifndef

begin_define
define|#
directive|define
name|MAKEINFO_MAJOR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAKEINFO_MINOR
end_ifndef

begin_define
define|#
directive|define
name|MAKEINFO_MINOR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|major_version
init|=
name|MAKEINFO_MAJOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minor_version
init|=
name|MAKEINFO_MINOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"no-validate"
block|,
literal|0
block|,
operator|&
name|validating
block|,
name|false
block|}
block|,
comment|/* formerly -nv */
block|{
literal|"no-warn"
block|,
literal|0
block|,
operator|&
name|print_warnings
block|,
name|false
block|}
block|,
comment|/* formerly -nw */
block|{
literal|"no-split"
block|,
literal|0
block|,
operator|&
name|splitting
block|,
name|false
block|}
block|,
comment|/* formerly -ns */
block|{
literal|"verbose"
block|,
literal|0
block|,
operator|&
name|verbose_mode
block|,
literal|1
block|}
block|,
comment|/* formerly -verbose */
block|{
literal|"fill-column"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
comment|/* formerly -fc */
block|{
literal|"paragraph-indent"
block|,
literal|1
block|,
literal|0
block|,
literal|'p'
block|}
block|,
comment|/* formerly -pi */
block|{
literal|"error-limit"
block|,
literal|1
block|,
literal|0
block|,
literal|'e'
block|}
block|,
comment|/* formerly -el */
block|{
literal|"reference-limit"
block|,
literal|1
block|,
literal|0
block|,
literal|'r'
block|}
block|,
comment|/* formerly -rl */
block|{
literal|"footnote-style"
block|,
literal|1
block|,
literal|0
block|,
literal|'s'
block|}
block|,
comment|/* formerly -ft */
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Main ()  Start of code  		    */
end_comment

begin_comment
comment|/*					        		    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* For each file mentioned in the command line, process it, turning    texinfo commands into wonderfully formatted output text. */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|t
init|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"EMACS"
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|strcmp
argument_list|(
name|t
argument_list|,
literal|"t"
argument_list|)
operator|==
literal|0
condition|)
name|in_emacs
operator|++
expr_stmt|;
comment|/* Parse argument flags from the input line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|,
name|long_options
argument_list|,
operator|&
name|ind
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|ind
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|ind
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* user specified fill_column? */
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|fill_column
argument_list|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* User specified paragraph indent (paragraph_start_index)? */
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|paragraph_start_indent
argument_list|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* User specified error level? */
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|max_error_level
argument_list|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* User specified reference warning limit? */
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|reference_warning_limit
argument_list|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* User specified footnote style? */
name|set_footnote_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* Use requested version info? */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Makeinfo verison %d.%d.\n"
argument_list|,
name|major_version
argument_list|,
name|minor_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|NO_ERROR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* Remaining arguments are file names of texinfo files.      Convert them, one by one. */
while|while
condition|(
name|optind
operator|!=
name|argc
condition|)
name|convert
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|NO_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Generic Utilities			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Just like malloc, but kills the program in case of fatal error. */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Virtual memory exhausted! Needed %d bytes."
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like realloc (), but barfs if there isn't enough memory. */
end_comment

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
block|{
name|error
argument_list|(
literal|"Virtual memory exhausted in realloc ()."
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|pointer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Tell the user how to use this program. */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [options] texinfo-file...\n\ \n\ This program accepts as input files of texinfo commands and text\n\ and outputs a file suitable for reading with GNU Info.\n\ \n\ The options are:\n\ `+no-validate' to suppress node cross reference validation.\n\ `+no-warn' to suppress warning messages (errors are still output).\n\ `+no-split' to suppress the splitting of large files.\n\ `+verbose' to print information about what is being done.\n\ `+version' to print the version number of Makeinfo.\n\ `+paragraph-indent NUM' to set the paragraph indent to NUM (default %d).\n\ `+fill-column NUM' to set the filling column to NUM (default %d).\n\ `+error-limit NUM' to set the error limit to NUM (default %d).\n\ `+reference-limit NUM' to set the reference warning limit to NUM (default %d).\n\ `+footnote-style STYLE' to set the footnote style to STYLE.  STYLE should\n\   either be `MN' for `make node', or `BN' for `bottom node'.\n\n"
argument_list|,
name|progname
argument_list|,
name|paragraph_start_indent
argument_list|,
name|fill_column
argument_list|,
name|max_error_level
argument_list|,
name|reference_warning_limit
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Manipulating Lists      		    */
end_comment

begin_comment
comment|/*					        		    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|generic_list
block|{
name|struct
name|generic_list
modifier|*
name|next
decl_stmt|;
block|}
name|GENERIC_LIST
typedef|;
end_typedef

begin_comment
comment|/* Reverse the chain of structures in LIST.  Output the new head    of the chain.  You should always assign the output value of this    function to something, or you will lose the chain. */
end_comment

begin_function
name|GENERIC_LIST
modifier|*
name|reverse_list
parameter_list|(
name|list
parameter_list|)
specifier|register
name|GENERIC_LIST
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|GENERIC_LIST
modifier|*
name|next
decl_stmt|;
specifier|register
name|GENERIC_LIST
modifier|*
name|prev
init|=
operator|(
name|GENERIC_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Pushing and Popping Files       	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Find and load the file named FILENAME.  Return a pointer to    the loaded file, or NULL if it can't be loaded. */
end_comment

begin_function
name|char
modifier|*
name|find_and_load
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|int
name|file
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|fileinfo
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|<
literal|0
condition|)
goto|goto
name|error_exit
goto|;
comment|/* Load the file. */
name|result
operator|=
name|xmalloc
argument_list|(
name|fileinfo
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* VMS stat lies about the st_size value.  The actual number of      readable bytes is always less than this value.  The arcane      mysteries of VMS/RMS are too much to probe, so this hack     suffices to make things work. */
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|result
operator|+
name|count
argument_list|,
name|fileinfo
operator|.
name|st_size
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|count
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
name|count
operator|=
name|fileinfo
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
name|result
argument_list|,
name|fileinfo
operator|.
name|st_size
argument_list|)
operator|!=
name|fileinfo
operator|.
name|st_size
condition|)
endif|#
directive|endif
name|error_exit
label|:
block|{
if|if
condition|(
name|result
condition|)
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Set the globals to the new file. */
name|input_text
operator|=
name|result
expr_stmt|;
name|size_of_input_text
operator|=
name|fileinfo
operator|.
name|st_size
expr_stmt|;
name|input_filename
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|node_filename
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Save the state of the current input file. */
end_comment

begin_macro
name|pushfile
argument_list|()
end_macro

begin_block
block|{
name|FSTACK
modifier|*
name|newstack
init|=
operator|(
name|FSTACK
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FSTACK
argument_list|)
argument_list|)
decl_stmt|;
name|newstack
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|newstack
operator|->
name|text
operator|=
name|input_text
expr_stmt|;
name|newstack
operator|->
name|size
operator|=
name|size_of_input_text
expr_stmt|;
name|newstack
operator|->
name|offset
operator|=
name|input_text_offset
expr_stmt|;
name|newstack
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|newstack
operator|->
name|next
operator|=
name|filestack
expr_stmt|;
name|filestack
operator|=
name|newstack
expr_stmt|;
name|push_node_filename
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make the current file globals be what is on top of the file stack. */
end_comment

begin_macro
name|popfile
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|executing_string
decl_stmt|;
name|FSTACK
modifier|*
name|temp
init|=
name|filestack
decl_stmt|;
if|if
condition|(
operator|!
name|filestack
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* My fault.  I wonder what I did? */
comment|/* Make sure that commands with braces have been satisfied. */
if|if
condition|(
operator|!
name|executing_string
condition|)
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* Get the top of the stack into the globals. */
name|input_filename
operator|=
name|filestack
operator|->
name|filename
expr_stmt|;
name|input_text
operator|=
name|filestack
operator|->
name|text
expr_stmt|;
name|size_of_input_text
operator|=
name|filestack
operator|->
name|size
expr_stmt|;
name|input_text_offset
operator|=
name|filestack
operator|->
name|offset
expr_stmt|;
name|line_number
operator|=
name|filestack
operator|->
name|line_number
expr_stmt|;
comment|/* Pop the stack. */
name|filestack
operator|=
name|filestack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|pop_node_filename
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Flush all open files on the file stack. */
end_comment

begin_macro
name|flush_file_stack
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|filestack
condition|)
block|{
name|free
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_text
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|int
name|node_filename_stack_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|node_filename_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|node_filename_stack
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_macro
name|push_node_filename
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|node_filename_stack_index
operator|+
literal|1
operator|>
name|node_filename_stack_size
condition|)
block|{
if|if
condition|(
operator|!
name|node_filename_stack
condition|)
name|node_filename_stack
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|node_filename_stack_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|node_filename_stack
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|node_filename_stack
argument_list|,
operator|(
name|node_filename_stack_size
operator|+
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|node_filename_stack
index|[
name|node_filename_stack_index
index|]
operator|=
name|node_filename
expr_stmt|;
name|node_filename_stack_index
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|pop_node_filename
argument_list|()
end_macro

begin_block
block|{
name|node_filename
operator|=
name|node_filename_stack
index|[
operator|--
name|node_filename_stack_index
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return just the simple part of the filename; i.e. the    filename without the path information, or extensions.    This conses up a new string. */
end_comment

begin_function
name|char
modifier|*
name|filename_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|&&
name|filename
index|[
name|i
index|]
operator|!=
literal|'/'
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|REMOVE_OUTPUT_EXTENSIONS
name|result
operator|=
name|savestring
argument_list|(
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* See if there is an extension to remove.  If so, remove it. */
if|if
condition|(
name|rindex
argument_list|(
name|result
argument_list|,
literal|'.'
argument_list|)
condition|)
operator|*
operator|(
name|rindex
argument_list|(
name|result
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|savestring
argument_list|(
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* REMOVE_OUTPUT_EXTENSIONS */
block|}
end_function

begin_comment
comment|/* Return the pathname part of filename.  This can be NULL. */
end_comment

begin_function
name|char
modifier|*
name|pathname_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|expand_filename
parameter_list|()
function_decl|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|filename
operator|=
name|expand_filename
argument_list|(
name|filename
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|&&
name|filename
index|[
name|i
index|]
operator|!=
literal|'/'
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|result
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|filename
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the expansion of FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|expand_filename
parameter_list|(
name|filename
parameter_list|,
name|input_name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|input_name
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|full_pathname
parameter_list|()
function_decl|;
name|filename
operator|=
name|full_pathname
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
operator|(
name|filename
operator|)
return|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|input_name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Make it so that relative names work. */
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|-
literal|1
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|input_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
index|[
name|i
index|]
operator|!=
literal|'/'
operator|&&
name|i
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|result
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|result
index|[
name|i
index|]
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
return|return
operator|(
name|filename
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return the full path to FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|full_pathname
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|initial_character
decl_stmt|;
if|if
condition|(
name|filename
operator|&&
operator|(
name|initial_character
operator|=
operator|*
name|filename
operator|)
condition|)
block|{
if|if
condition|(
name|initial_character
operator|==
literal|'/'
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
if|if
condition|(
name|initial_character
operator|!=
literal|'~'
condition|)
block|{
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Return the concatenation of HOME and the rest of the string. */
name|char
modifier|*
name|temp_home
init|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp_name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|&
name|filename
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
operator|+
name|temp_home
condition|?
name|strlen
argument_list|(
name|temp_home
argument_list|)
else|:
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp_home
condition|)
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|temp_home
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|filename
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp_name
operator|)
return|;
block|}
else|else
block|{
name|struct
name|passwd
modifier|*
name|user_entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|username
init|=
name|xmalloc
argument_list|(
literal|257
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp_name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|c
operator|=
name|filename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
break|break;
else|else
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|user_entry
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user_entry
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
name|temp_name
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|user_entry
operator|->
name|pw_dir
argument_list|)
operator|+
name|strlen
argument_list|(
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|user_entry
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp_name
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Error Handling				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Number of errors encountered. */
end_comment

begin_decl_stmt
name|int
name|errors_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the last error gotten from the file system. */
end_comment

begin_macro
name|fs_error
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|false
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Print an error message, and return false. */
end_comment

begin_macro
name|error
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|false
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Just like error (), but print the line number as well. */
end_comment

begin_macro
name|line_error
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|false
operator|)
return|;
block|}
end_block

begin_macro
name|warning
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|print_warnings
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: Warning: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|false
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Remember that an error has been printed.  If this is the first    error printed, then tell them which program is printing them.    If more than max_error_level have been printed, then exit the    program. */
end_comment

begin_macro
name|remember_error
argument_list|()
end_macro

begin_block
block|{
name|errors_printed
operator|++
expr_stmt|;
if|if
condition|(
name|max_error_level
operator|&&
operator|(
name|errors_printed
operator|>
name|max_error_level
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many errors!  Gave up."
argument_list|)
expr_stmt|;
name|flush_file_stack
argument_list|()
expr_stmt|;
name|cm_bye
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Hacking Tokens and Strings		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return the next token as a string pointer.  We cons the    string. */
end_comment

begin_function
name|char
modifier|*
name|read_token
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|character
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Hack special case.  If the first character to be read is      self-delimiting, then that is the command itself. */
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|self_delimiting
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|result
operator|=
name|savestring
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|character
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|input_text_offset
operator|!=
name|size_of_input_text
operator|)
operator|&&
operator|(
name|character
operator|=
name|curchar
argument_list|()
operator|)
operator|&&
name|command_char
argument_list|(
name|character
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|input_text_offset
operator|++
control|)
empty_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
operator|&
name|input_text
index|[
name|input_text_offset
operator|-
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if CHARACTER is self-delimiting. */
end_comment

begin_function
name|boolean
name|self_delimiting
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
return|return
operator|(
name|member
argument_list|(
name|character
argument_list|,
literal|"{}:.@*'`,!?; \n"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear whitespace from the front and end of string. */
end_comment

begin_macro
name|canon_white
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|string
index|[
name|x
index|]
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|string
argument_list|,
name|string
operator|+
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|len
operator|--
expr_stmt|;
while|while
condition|(
name|len
operator|>
operator|-
literal|1
operator|&&
name|cr_or_whitespace
argument_list|(
name|string
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|string
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Bash STRING, replacing all whitespace with just one space. */
end_comment

begin_macro
name|fix_whitespace
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|string_index
init|=
literal|0
decl_stmt|;
name|int
name|temp_index
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|canon_white
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|string
index|[
name|string_index
index|]
condition|)
block|{
name|c
operator|=
name|temp
index|[
name|temp_index
operator|++
index|]
operator|=
name|string
index|[
name|string_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|temp
index|[
name|temp_index
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|string
index|[
name|string_index
index|]
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
name|string_index
operator|++
expr_stmt|;
block|}
block|}
name|temp
index|[
name|temp_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Discard text until the desired string is found.  The string is    included in the discarded text. */
end_comment

begin_macro
name|discard_until
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|temp
init|=
name|search_forward
argument_list|(
name|string
argument_list|,
name|input_text_offset
argument_list|)
decl_stmt|;
name|int
name|tt
init|=
operator|(
name|temp
operator|<
literal|0
operator|)
condition|?
name|size_of_input_text
else|:
name|temp
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|from
init|=
name|input_text_offset
decl_stmt|;
comment|/* Find out what line we are on. */
while|while
condition|(
name|from
operator|!=
name|tt
condition|)
if|if
condition|(
name|input_text
index|[
name|from
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|input_text_offset
operator|=
name|size_of_input_text
operator|-
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Expected `%s'"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|input_text_offset
operator|=
name|temp
expr_stmt|;
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read characters from the file until we are at MATCH.    Place the characters read into STRING.    On exit input_text_offset is after the match string.    Return the length of STRING. */
end_comment

begin_macro
name|get_until
argument_list|(
argument|match
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|match
decl_stmt|,
modifier|*
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|int
name|current_point
init|=
name|input_text_offset
decl_stmt|;
name|int
name|x
init|=
name|current_point
decl_stmt|;
name|int
name|new_point
init|=
name|search_forward
argument_list|(
name|match
argument_list|,
name|input_text_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_point
operator|<
literal|0
condition|)
name|new_point
operator|=
name|size_of_input_text
expr_stmt|;
name|len
operator|=
name|new_point
operator|-
name|current_point
expr_stmt|;
comment|/* Keep track of which line number we are at. */
while|while
condition|(
name|x
operator|!=
name|new_point
condition|)
if|if
condition|(
name|input_text
index|[
name|x
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
operator|*
name|string
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|string
argument_list|,
operator|&
name|input_text
index|[
name|current_point
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|string
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now leave input_text_offset in a consistent state. */
name|input_text_offset
operator|=
name|new_point
operator|+
operator|(
name|strlen
argument_list|(
name|match
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
name|size_of_input_text
condition|)
name|input_text_offset
operator|=
name|size_of_input_text
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read characters from the file until we are at MATCH or end of line.    Place the characters read into STRING.  */
end_comment

begin_macro
name|get_until_in_line
argument_list|(
argument|match
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|match
decl_stmt|,
modifier|*
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|real_bottom
init|=
name|size_of_input_text
decl_stmt|;
name|int
name|temp
init|=
name|search_forward
argument_list|(
literal|"\n"
argument_list|,
name|input_text_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|temp
operator|=
name|size_of_input_text
expr_stmt|;
name|size_of_input_text
operator|=
name|temp
expr_stmt|;
name|get_until
argument_list|(
name|match
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|size_of_input_text
operator|=
name|real_bottom
expr_stmt|;
block|}
end_block

begin_macro
name|get_rest_of_line
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|get_until
argument_list|(
literal|"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
comment|/* as opposed to the end of the file... */
name|line_number
operator|++
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Read characters from the file until we are at MATCH or closing brace.    Place the characters read into STRING.  */
end_comment

begin_macro
name|get_until_in_braces
argument_list|(
argument|match
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|match
decl_stmt|,
modifier|*
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|brace
init|=
literal|0
decl_stmt|;
name|int
name|match_len
init|=
name|strlen
argument_list|(
name|match
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|i
operator|<
name|size_of_input_text
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'{'
condition|)
name|brace
operator|++
expr_stmt|;
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'}'
condition|)
name|brace
operator|--
expr_stmt|;
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|brace
operator|<
literal|0
operator|||
operator|(
name|brace
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|input_text
operator|+
name|i
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
name|match_len
operator|=
name|i
operator|-
name|input_text_offset
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|match_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|input_text
operator|+
name|input_text_offset
argument_list|,
name|match_len
argument_list|)
expr_stmt|;
name|temp
index|[
name|match_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
operator|*
name|string
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Converting the File     		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Convert the file named by NAME.  The output is saved on the file    named as the argument to the @setfilename command. */
end_comment

begin_macro
name|convert
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|real_output_filename
decl_stmt|,
modifier|*
name|expand_filename
argument_list|()
decl_stmt|,
modifier|*
name|filename_part
argument_list|()
decl_stmt|;
name|init_tag_table
argument_list|()
expr_stmt|;
name|init_indices
argument_list|()
expr_stmt|;
name|init_internals
argument_list|()
expr_stmt|;
name|init_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|find_and_load
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* For some reason, the file couldn't be loaded.  Print a message 	 to that affect, and split. */
name|fs_error
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|input_filename
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Search this file looking for the special string which starts conversion.      Once found, we may truly begin. */
name|input_text_offset
operator|=
name|search_forward
argument_list|(
literal|"@setfilename"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"No `@setfilename' found in `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
else|else
name|input_text_offset
operator|+=
name|strlen
argument_list|(
literal|"@setfilename"
argument_list|)
expr_stmt|;
name|get_until
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|output_filename
argument_list|)
expr_stmt|;
comment|/* no braces expected. */
name|canon_white
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Making info file `%s' from `%s'.\n"
argument_list|,
name|output_filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|real_output_filename
operator|=
name|expand_filename
argument_list|(
name|output_filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|fopen
argument_list|(
name|real_output_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_stream
operator|==
name|NULL
condition|)
block|{
name|fs_error
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* Make the displayable filename from output_filename.  Only the root      portion of the filename need be displayed. */
name|pretty_output_filename
operator|=
name|filename_part
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
comment|/* For this file only, count the number of newlines from the top of      the file to here.  This way, we keep track of line numbers for      error reporting.  Line_number starts at 1, since the user isn't      zero-based. */
block|{
name|int
name|temp
init|=
literal|0
decl_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|input_text_offset
condition|)
if|if
condition|(
name|input_text
index|[
name|temp
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
block|}
name|add_word_args
argument_list|(
literal|"Info file %s, produced by Makeinfo, -*- Text -*-\n\ from input file %s.\n"
argument_list|,
name|output_filename
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|finished
label|:
name|close_paragraph
argument_list|()
expr_stmt|;
name|flush_file_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_stream
operator|!=
name|NULL
condition|)
block|{
name|output_pending_notes
argument_list|()
expr_stmt|;
name|free_pending_notes
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag_table
operator|!=
name|NULL
condition|)
block|{
name|tag_table
operator|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|reverse_list
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
name|write_tag_table
argument_list|()
expr_stmt|;
block|}
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
comment|/* If validating, then validate the entire file right now. */
if|if
condition|(
name|validating
condition|)
name|validate_file
argument_list|(
name|real_output_filename
argument_list|,
name|tag_table
argument_list|)
expr_stmt|;
comment|/* This used to test&& !errors_printed. 	 But some files might have legit warnings.  So split anyway.  */
if|if
condition|(
name|splitting
condition|)
name|split_file
argument_list|(
name|real_output_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|free_and_clear
argument_list|(
argument|pointer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pointer
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pointer
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|pointer
argument_list|)
expr_stmt|;
operator|*
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Initialize some state. */
end_comment

begin_macro
name|init_internals
argument_list|()
end_macro

begin_block
block|{
name|free_and_clear
argument_list|(
operator|&
name|current_node
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|output_filename
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|input_filename
argument_list|)
expr_stmt|;
name|free_node_references
argument_list|()
expr_stmt|;
name|init_insertion_stack
argument_list|()
expr_stmt|;
name|init_brace_stack
argument_list|()
expr_stmt|;
name|command_index
operator|=
literal|0
expr_stmt|;
name|in_menu
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|init_paragraph
argument_list|()
end_macro

begin_block
block|{
name|free_and_clear
argument_list|(
operator|&
name|output_paragraph
argument_list|)
expr_stmt|;
name|output_paragraph
operator|=
name|xmalloc
argument_list|(
name|paragraph_buffer_len
argument_list|)
expr_stmt|;
name|output_position
operator|=
literal|0
expr_stmt|;
name|output_paragraph
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
name|output_column
operator|=
literal|0
expr_stmt|;
name|paragraph_is_open
operator|=
name|false
expr_stmt|;
name|current_indent
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Okay, we are ready to start the conversion.  Call the reader on    some text, and fill the text as it is output.  Handle commands by    remembering things like open braces and the current file position on a    stack, and when the corresponding close brace is found, you can call    the function with the proper arguments. */
end_comment

begin_macro
name|reader_loop
argument_list|()
end_macro

begin_block
block|{
name|int
name|character
decl_stmt|;
name|boolean
name|done
init|=
name|false
decl_stmt|;
name|int
name|dash_count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|input_text_offset
operator|>=
name|size_of_input_text
condition|)
block|{
if|if
condition|(
name|filestack
condition|)
block|{
name|free
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_text
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
block|}
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|in_fixed_width_font
operator|&&
operator|(
name|character
operator|==
literal|'\''
operator|||
name|character
operator|==
literal|'`'
operator|)
operator|&&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
operator|==
name|character
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|character
operator|=
literal|'"'
expr_stmt|;
block|}
if|if
condition|(
name|character
operator|==
literal|'-'
condition|)
block|{
name|dash_count
operator|++
expr_stmt|;
if|if
condition|(
name|dash_count
operator|==
literal|3
operator|&&
operator|!
name|in_fixed_width_font
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|dash_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|in_menu
operator|&&
name|input_text_offset
operator|+
literal|1
operator|<
name|size_of_input_text
condition|)
block|{
name|glean_node_from_menu
argument_list|()
expr_stmt|;
block|}
comment|/* If the following line is all whitespace, advance to the carriage 	     return on it. */
block|{
specifier|register
name|int
name|i
init|=
name|input_text_offset
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size_of_input_text
operator|&&
name|whitespace
argument_list|(
name|input_text
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|size_of_input_text
operator|||
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|input_text_offset
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|character
condition|)
block|{
case|case
name|COMMAND_PREFIX
case|:
name|read_command
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"bye"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'{'
case|:
comment|/* Special case.  I'm not supposed to see this character by itself. 	     If I do, it means there is a syntax error in the input text. 	     Report the error here, but remember this brace on the stack so 	     you can ignore its partner. */
name|line_error
argument_list|(
literal|"Misplaced `{'"
argument_list|)
expr_stmt|;
name|remember_brace
argument_list|(
name|misplaced_brace
argument_list|)
expr_stmt|;
comment|/* Don't advance input_text_offset since this happens in 	     remember_brace (). 	     input_text_offset++;            */
break|break;
case|case
literal|'}'
case|:
name|pop_and_call_brace
argument_list|()
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
break|break;
default|default:
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Find the command corresponding to STRING.  If the command    is found, return a pointer to the data structure.  Otherwise    return (-1). */
end_comment

begin_function
name|COMMAND
modifier|*
name|get_command_entry
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|&
name|CommandTable
index|[
name|i
index|]
operator|)
return|;
comment|/* This command is not in our predefined command table.  Perhaps      it is a user defined command. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|user_command_array_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|user_command_array
index|[
name|i
index|]
operator|&&
operator|(
name|strcmp
argument_list|(
name|user_command_array
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|user_command_array
index|[
name|i
index|]
operator|)
return|;
comment|/* Nope, we never heard of this command. */
return|return
operator|(
operator|(
name|COMMAND
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* input_text_offset is right at the command prefix character.    Read the next token to determine what to do. */
end_comment

begin_macro
name|read_command
argument_list|()
end_macro

begin_block
block|{
name|COMMAND
modifier|*
name|entry
decl_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|read_token
argument_list|()
expr_stmt|;
name|entry
operator|=
name|get_command_entry
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|entry
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown info command `%s'"
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|entry
operator|->
name|argument_in_braces
condition|)
name|remember_brace
argument_list|(
name|entry
operator|->
name|proc
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|entry
operator|->
name|proc
operator|)
operator|)
operator|(
name|START
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the string which invokes PROC; a pointer to a function. */
end_comment

begin_function
name|char
modifier|*
name|find_proc_name
parameter_list|(
name|proc
parameter_list|)
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|proc
operator|==
name|CommandTable
index|[
name|i
index|]
operator|.
name|proc
condition|)
return|return
operator|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
return|return
operator|(
literal|"NO_NAME!"
operator|)
return|;
block|}
end_function

begin_macro
name|init_brace_stack
argument_list|()
end_macro

begin_block
block|{
name|brace_stack
operator|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|remember_brace
argument_list|(
argument|proc
argument_list|)
end_macro

begin_decl_stmt
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|'{'
condition|)
name|line_error
argument_list|(
literal|"@%s expected `{..}'"
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
name|input_text_offset
operator|++
expr_stmt|;
name|remember_brace_1
argument_list|(
name|proc
argument_list|,
name|output_paragraph_offset
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Remember the current output position here.  Save PROC    along with it so you can call it later. */
end_comment

begin_macro
name|remember_brace_1
argument_list|(
argument|proc
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BRACE_ELEMENT
modifier|*
name|new
init|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BRACE_ELEMENT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|brace_stack
expr_stmt|;
name|new
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|new
operator|->
name|pos
operator|=
name|position
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|line_number
expr_stmt|;
name|brace_stack
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Pop the top of the brace stack, and call the associated function    with the args END and POS. */
end_comment

begin_macro
name|pop_and_call_brace
argument_list|()
end_macro

begin_block
block|{
name|BRACE_ELEMENT
modifier|*
name|temp
decl_stmt|;
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|brace_stack
operator|==
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|line_error
argument_list|(
literal|"Unmatched close bracket"
argument_list|)
operator|)
return|;
name|pos
operator|=
name|brace_stack
operator|->
name|pos
expr_stmt|;
name|proc
operator|=
name|brace_stack
operator|->
name|proc
expr_stmt|;
name|temp
operator|=
name|brace_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|brace_stack
argument_list|)
expr_stmt|;
name|brace_stack
operator|=
name|temp
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|proc
call|)
argument_list|(
name|END
argument_list|,
name|pos
argument_list|,
name|output_paragraph_offset
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* You call discard_braces () when you shouldn't have any braces on the stack.    I used to think that this happens for commands that don't take arguments    in braces, but that was wrong because of things like @code{foo @@}.  So now    I only detect it at the beginning of nodes. */
end_comment

begin_macro
name|discard_braces
argument_list|()
end_macro

begin_block
block|{
name|int
name|temp_line_number
init|=
name|line_number
decl_stmt|;
name|char
modifier|*
name|proc_name
decl_stmt|;
if|if
condition|(
operator|!
name|brace_stack
condition|)
return|return;
while|while
condition|(
name|brace_stack
condition|)
block|{
name|line_number
operator|=
name|brace_stack
operator|->
name|line
expr_stmt|;
name|proc_name
operator|=
name|find_proc_name
argument_list|(
name|brace_stack
operator|->
name|proc
argument_list|)
expr_stmt|;
name|line_error
argument_list|(
literal|"@%s missing close brace"
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_line_number
expr_stmt|;
name|pop_and_call_brace
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|get_char_len
argument_list|(
argument|character
argument_list|)
end_macro

begin_decl_stmt
name|int
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Return the printed length of the character. */
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\t'
case|:
name|len
operator|=
operator|(
name|output_column
operator|+
literal|8
operator|)
operator|&
literal|0xf7
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fill_column
condition|)
name|len
operator|=
name|fill_column
operator|-
name|output_column
expr_stmt|;
else|else
name|len
operator|=
name|len
operator|-
name|output_column
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|len
operator|=
name|fill_column
operator|-
name|output_column
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|character
operator|<
literal|' '
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_block

begin_macro
name|add_word_args
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add STRING to output_paragraph. */
end_comment

begin_macro
name|add_word
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|string
condition|)
name|add_char
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|boolean
name|last_char_was_newline
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_inserted_character
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add the character to the current paragraph.  If filling_enabled is    true, then do filling as well. */
end_comment

begin_macro
name|add_char
argument_list|(
argument|character
argument_list|)
end_macro

begin_decl_stmt
name|int
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|must_start_paragraph
decl_stmt|;
comment|/* If we are adding a character now, then we don't have to      ignore close_paragraph () calls any more. */
if|if
condition|(
name|must_start_paragraph
condition|)
block|{
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_indent
operator|>
name|output_column
condition|)
block|{
name|indent
argument_list|(
name|current_indent
operator|-
name|output_column
argument_list|)
expr_stmt|;
name|output_column
operator|=
name|current_indent
expr_stmt|;
block|}
block|}
if|if
condition|(
name|non_splitting_words
operator|&&
name|member
argument_list|(
name|character
argument_list|,
literal|" \t\n"
argument_list|)
condition|)
name|character
operator|=
literal|' '
operator||
literal|0x80
expr_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|filling_enabled
condition|)
block|{
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Should I be flushing output here? * /           flush_output (); */
name|output_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_indent
condition|)
name|indent
argument_list|(
name|output_column
operator|=
name|current_indent
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|sentence_ender
argument_list|(
name|last_inserted_character
argument_list|)
condition|)
block|{
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
name|last_inserted_character
operator|=
name|character
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_char_was_newline
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
name|pending_indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|last_char_was_newline
operator|=
name|true
expr_stmt|;
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|int
name|len
init|=
name|get_char_len
argument_list|(
name|character
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|character
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|last_char_was_newline
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
name|pending_indent
operator|++
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
comment|/* If the paragraph is supposed to be indented a certain way, 	       then discard all of the pending whitespace.  Otherwise, we 	       let the whitespace stay. */
if|if
condition|(
operator|!
name|paragraph_start_indent
condition|)
name|indent
argument_list|(
name|pending_indent
argument_list|)
expr_stmt|;
name|pending_indent
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|output_column
operator|+=
name|len
operator|)
operator|>=
name|fill_column
condition|)
block|{
if|if
condition|(
name|filling_enabled
condition|)
block|{
name|int
name|temp
init|=
name|output_paragraph_offset
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|temp
operator|>
literal|0
operator|&&
name|output_paragraph
index|[
operator|--
name|temp
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|output_paragraph
index|[
name|temp
index|]
operator|==
literal|' '
condition|)
block|{
name|output_paragraph
index|[
name|temp
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* We have correctly broken the line where we want 			   to.  What we don't want is spaces following where 			   we have decided to break the line.  We get rid of 			   them. */
block|{
name|int
name|t1
init|=
name|temp
decl_stmt|;
while|while
condition|(
name|t1
operator|<
name|output_paragraph_offset
operator|&&
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|t1
index|]
argument_list|)
condition|)
name|t1
operator|++
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|temp
condition|)
block|{
name|strncpy
argument_list|(
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
operator|&
name|output_paragraph
index|[
name|t1
index|]
argument_list|,
operator|(
name|output_paragraph_offset
operator|-
name|t1
operator|)
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|-=
operator|(
name|t1
operator|-
name|temp
operator|)
expr_stmt|;
block|}
block|}
comment|/* Filled, but now indent if that is right. */
if|if
condition|(
name|indented_fill
operator|&&
name|current_indent
condition|)
block|{
name|int
name|buffer_len
init|=
operator|(
operator|(
name|output_paragraph_offset
operator|-
name|temp
operator|)
operator|+
name|current_indent
operator|)
decl_stmt|;
name|char
modifier|*
name|temp_buffer
init|=
name|xmalloc
argument_list|(
name|buffer_len
argument_list|)
decl_stmt|;
name|int
name|indentation
init|=
literal|0
decl_stmt|;
comment|/* We have to shift any markers that are in 			       front of the wrap point. */
block|{
specifier|register
name|BRACE_ELEMENT
modifier|*
name|stack
init|=
name|brace_stack
decl_stmt|;
while|while
condition|(
name|stack
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|pos
operator|>
name|temp
condition|)
name|stack
operator|->
name|pos
operator|+=
name|current_indent
expr_stmt|;
name|stack
operator|=
name|stack
operator|->
name|next
expr_stmt|;
block|}
block|}
while|while
condition|(
name|indentation
operator|!=
name|current_indent
condition|)
name|temp_buffer
index|[
name|indentation
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|temp_buffer
index|[
name|current_indent
index|]
argument_list|,
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
name|buffer_len
operator|-
name|current_indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|+
name|buffer_len
operator|>=
name|paragraph_buffer_len
condition|)
block|{
name|char
modifier|*
name|tt
init|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
name|buffer_len
operator|)
argument_list|)
decl_stmt|;
name|output_paragraph
operator|=
name|tt
expr_stmt|;
block|}
name|strncpy
argument_list|(
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
name|temp_buffer
argument_list|,
name|buffer_len
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|+=
name|current_indent
expr_stmt|;
name|free
argument_list|(
name|temp_buffer
argument_list|)
expr_stmt|;
block|}
name|output_column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|output_paragraph_offset
condition|)
name|output_column
operator|+=
name|get_char_len
argument_list|(
name|output_paragraph
index|[
name|temp
operator|++
index|]
argument_list|)
expr_stmt|;
name|output_column
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|insert
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|last_char_was_newline
operator|=
name|false
expr_stmt|;
name|last_inserted_character
operator|=
name|character
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Insert CHARACTER into OUTPUT_PARAGRAPH. */
end_comment

begin_macro
name|insert
argument_list|(
argument|character
argument_list|)
end_macro

begin_decl_stmt
name|int
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|output_paragraph
index|[
name|output_paragraph_offset
operator|++
index|]
operator|=
name|character
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|==
name|paragraph_buffer_len
condition|)
block|{
name|output_paragraph
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
literal|100
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Remove upto COUNT characters of whitespace from the    the current output line.  If COUNT is less than zero,    then remove until none left. */
end_comment

begin_macro
name|kill_self_indent
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Handle infinite case first. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|output_column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|output_paragraph_offset
condition|)
block|{
if|if
condition|(
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
else|else
block|{
while|while
condition|(
name|output_paragraph_offset
operator|&&
name|count
operator|--
condition|)
if|if
condition|(
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
end_block

begin_macro
name|flush_output
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output_paragraph_offset
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|output_paragraph_offset
condition|;
name|i
operator|++
control|)
name|output_paragraph
index|[
name|i
index|]
operator|&=
literal|0x7f
expr_stmt|;
name|fwrite
argument_list|(
name|output_paragraph
argument_list|,
literal|1
argument_list|,
name|output_paragraph_offset
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
name|output_position
operator|+=
name|output_paragraph_offset
expr_stmt|;
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* How to close a paragraph controlling the number of lines between    this one and the last one. */
end_comment

begin_comment
comment|/* Paragraph spacing is controlled by this variable.  It is the number of    blank lines that you wish to appear between paragraphs.  A value of    1 creates a single blank line between paragraphs. */
end_comment

begin_decl_stmt
name|int
name|paragraph_spacing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Close the current paragraph, leaving no blank lines between them. */
end_comment

begin_macro
name|close_single_paragraph
argument_list|()
end_macro

begin_block
block|{
name|close_paragraph_with_lines
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|close_paragraph_with_lines
argument_list|(
argument|lines
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lines
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|old_spacing
init|=
name|paragraph_spacing
decl_stmt|;
name|paragraph_spacing
operator|=
name|lines
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|paragraph_spacing
operator|=
name|old_spacing
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Non-zero means that start_paragraph () MUST be called before we pay    any attention to close_paragraph () calls. */
end_comment

begin_decl_stmt
name|int
name|must_start_paragraph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Close the currently open paragraph. */
end_comment

begin_macro
name|close_paragraph
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|paragraph_is_open
operator|&&
operator|!
name|must_start_paragraph
condition|)
block|{
comment|/* Gobble up blank lines that are extra... */
specifier|register
name|int
name|tindex
init|=
name|output_paragraph_offset
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|tindex
operator|&&
operator|(
operator|(
name|c
operator|=
name|output_paragraph
index|[
name|tindex
operator|-
literal|1
index|]
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
name|output_paragraph
index|[
operator|--
name|tindex
index|]
operator|=
literal|'\n'
expr_stmt|;
name|output_paragraph_offset
operator|=
name|tindex
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paragraph_spacing
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|flush_output
argument_list|()
expr_stmt|;
name|paragraph_is_open
operator|=
name|false
expr_stmt|;
name|no_indent
operator|=
name|false
expr_stmt|;
block|}
name|last_char_was_newline
operator|=
name|true
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Begin a new paragraph. */
end_comment

begin_macro
name|start_paragraph
argument_list|()
end_macro

begin_block
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* First close existing one. */
name|paragraph_is_open
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|must_start_paragraph
condition|)
block|{
name|output_column
operator|=
literal|0
expr_stmt|;
comment|/* If doing indentation, then insert the appropriate amount. */
if|if
condition|(
operator|!
name|no_indent
condition|)
block|{
if|if
condition|(
name|inhibit_paragraph_indentation
operator|||
name|paragraph_start_indent
operator|<
literal|0
condition|)
name|output_column
operator|=
name|current_indent
expr_stmt|;
else|else
name|output_column
operator|=
name|current_indent
operator|+
name|paragraph_start_indent
expr_stmt|;
name|indent
argument_list|(
name|output_column
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert the indentation specified by AMOUNT. */
end_comment

begin_macro
name|indent
argument_list|(
argument|amount
argument_list|)
end_macro

begin_decl_stmt
name|int
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|amount
operator|>=
literal|0
condition|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Search forward for STRING in input_text.    FROM says where where to start. */
end_comment

begin_macro
name|search_forward
argument_list|(
argument|string
argument_list|,
argument|from
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
while|while
condition|(
name|from
operator|<
name|size_of_input_text
condition|)
block|{
if|if
condition|(
name|strnicmp
argument_list|(
name|input_text
operator|+
name|from
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|from
operator|)
return|;
name|from
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Whoops, Unix doesn't have stricmp, or strnicmp. */
end_comment

begin_comment
comment|/* Case independent string compare. */
end_comment

begin_macro
name|stricmp
argument_list|(
argument|string1
argument_list|,
argument|string2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string1
decl_stmt|,
modifier|*
name|string2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ch1
decl_stmt|,
name|ch2
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch1
operator|=
operator|*
name|string1
operator|++
expr_stmt|;
name|ch2
operator|=
operator|*
name|string2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch1
operator||
name|ch2
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ch1
operator|=
name|coerce_to_upper
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|ch2
operator|=
name|coerce_to_upper
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch1
operator|!=
name|ch2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* Compare at most COUNT characters from string1 to string2.  Case    doesn't matter. */
end_comment

begin_macro
name|strnicmp
argument_list|(
argument|string1
argument_list|,
argument|string2
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string1
decl_stmt|,
modifier|*
name|string2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ch1
decl_stmt|,
name|ch2
decl_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|ch1
operator|=
operator|*
name|string1
operator|++
expr_stmt|;
name|ch2
operator|=
operator|*
name|string2
operator|++
expr_stmt|;
if|if
condition|(
name|coerce_to_upper
argument_list|(
name|ch1
argument_list|)
operator|==
name|coerce_to_upper
argument_list|(
name|ch2
argument_list|)
condition|)
name|count
operator|--
expr_stmt|;
else|else
break|break;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_enum
enum|enum
name|insertion_type
block|{
name|menu
block|,
name|quotation
block|,
name|lisp
block|,
name|example
block|,
name|smallexample
block|,
name|display
block|,
name|itemize
block|,
name|format
block|,
name|enumerate
block|,
name|table
block|,
name|group
block|,
name|ifinfo
block|,
name|defun
block|,
name|defvar
block|,
name|defopt
block|,
name|deffn
block|,
name|defspec
block|,
name|defmac
block|,
name|bad_type
block|}
enum|;
end_enum

begin_decl_stmt
name|char
modifier|*
name|insertion_type_names
index|[]
init|=
block|{
literal|"menu"
block|,
literal|"quotation"
block|,
literal|"lisp"
block|,
literal|"example"
block|,
literal|"smallexample"
block|,
literal|"display"
block|,
literal|"itemize"
block|,
literal|"format"
block|,
literal|"enumerate"
block|,
literal|"table"
block|,
literal|"group"
block|,
literal|"ifinfo"
block|,
literal|"defun"
block|,
literal|"defvar"
block|,
literal|"defopt"
block|,
literal|"deffn"
block|,
literal|"defspec"
block|,
literal|"defmac"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|insertion_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|istack_elt
block|{
name|struct
name|istack_elt
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|item_function
decl_stmt|;
name|int
name|line_number
decl_stmt|;
name|int
name|filling_enabled
decl_stmt|;
name|int
name|indented_fill
decl_stmt|;
name|enum
name|insertion_type
name|insertion
decl_stmt|;
name|int
name|inhibited
decl_stmt|;
block|}
name|INSERTION_ELT
typedef|;
end_typedef

begin_decl_stmt
name|INSERTION_ELT
modifier|*
name|insertion_stack
init|=
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_macro
name|init_insertion_stack
argument_list|()
end_macro

begin_block
block|{
name|insertion_stack
operator|=
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the type of the current insertion. */
end_comment

begin_function
name|enum
name|insertion_type
name|current_insertion_type
parameter_list|()
block|{
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return
operator|(
name|bad_type
operator|)
return|;
else|else
return|return
operator|(
name|insertion_stack
operator|->
name|insertion
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the string which is the function    to wrap around items. */
end_comment

begin_function
name|char
modifier|*
name|current_item_function
parameter_list|()
block|{
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|insertion_stack
operator|->
name|item_function
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_item_function
parameter_list|()
block|{
name|char
modifier|*
name|item_function
decl_stmt|;
name|get_until
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|item_function
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|item_function
argument_list|)
expr_stmt|;
return|return
operator|(
name|item_function
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Push the state of the current insertion on the stack. */
end_comment

begin_expr_stmt
name|push_insertion
argument_list|(
name|type
argument_list|,
name|item_function
argument_list|)
expr|enum
name|insertion_type
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|item_function
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|INSERTION_ELT
modifier|*
name|new
init|=
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INSERTION_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|item_function
operator|=
name|item_function
expr_stmt|;
name|new
operator|->
name|filling_enabled
operator|=
name|filling_enabled
expr_stmt|;
name|new
operator|->
name|indented_fill
operator|=
name|indented_fill
expr_stmt|;
name|new
operator|->
name|insertion
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|new
operator|->
name|inhibited
operator|=
name|inhibit_paragraph_indentation
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|insertion_stack
expr_stmt|;
name|insertion_stack
operator|=
name|new
expr_stmt|;
name|insertion_level
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Pop the value on top of the insertion stack into the     global variables. */
end_comment

begin_macro
name|pop_insertion
argument_list|()
end_macro

begin_block
block|{
name|INSERTION_ELT
modifier|*
name|temp
init|=
name|insertion_stack
decl_stmt|;
if|if
condition|(
name|temp
operator|==
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|NULL
condition|)
return|return;
name|inhibit_paragraph_indentation
operator|=
name|temp
operator|->
name|inhibited
expr_stmt|;
name|filling_enabled
operator|=
name|insertion_stack
operator|->
name|filling_enabled
expr_stmt|;
name|indented_fill
operator|=
name|insertion_stack
operator|->
name|indented_fill
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
operator|(
name|temp
operator|->
name|item_function
operator|)
argument_list|)
expr_stmt|;
name|insertion_stack
operator|=
name|insertion_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|insertion_level
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a pointer to the print name of this     enumerated type. */
end_comment

begin_function
name|char
modifier|*
name|insertion_type_pname
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|type
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
return|return
operator|(
name|insertion_type_names
index|[
operator|(
name|int
operator|)
name|type
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|"Broken-Type in insertion_type_pname"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the insertion_type associated with NAME.    If the type is not one of the known ones, return BAD_TYPE. */
end_comment

begin_function
name|enum
name|insertion_type
name|find_type_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
block|{
if|if
condition|(
name|stricmp
argument_list|(
name|name
argument_list|,
name|insertion_type_names
index|[
name|index
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
expr|enum
name|insertion_type
operator|)
name|index
return|;
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|bad_type
operator|)
return|;
block|}
end_function

begin_macro
name|do_nothing
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_function
name|int
name|defun_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
return|return
operator|(
name|type
operator|==
name|defun
operator|||
name|type
operator|==
name|defvar
operator|||
name|type
operator|==
name|defopt
operator|||
name|type
operator|==
name|deffn
operator|||
name|type
operator|==
name|defspec
operator|||
name|type
operator|==
name|defmac
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Non-zero means that we are currently hacking the insides of an    insertion which would use a fixed width font. */
end_comment

begin_decl_stmt
name|int
name|in_fixed_width_font
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is where the work for all the "insertion" style    commands is done.  A huge switch statement handles the    various setups, and generic code is on both sides. */
end_comment

begin_expr_stmt
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr|enum
name|insertion_type
name|type
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|no_discard
init|=
literal|0
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|defun_insertion
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|push_insertion
argument_list|(
name|type
argument_list|,
name|savestring
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|no_discard
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|push_insertion
argument_list|(
name|type
argument_list|,
name|get_item_function
argument_list|()
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|false
expr_stmt|;
comment|/* the general case for insertions. */
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|no_indent
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu
case|:
name|add_word
argument_list|(
literal|"* Menu:\n"
argument_list|)
expr_stmt|;
name|in_menu
operator|++
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|input_text_offset
operator|--
expr_stmt|;
comment|/* discard_until () has already counted the newline.  Discount it. */
name|line_number
operator|--
expr_stmt|;
return|return;
comment|/* I think @quotation is meant to do filling. 	 If you don't want filling, then use @example. */
case|case
name|quotation
case|:
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
name|true
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
comment|/* Just like @example, but no indentation. */
case|case
name|format
case|:
name|in_fixed_width_font
operator|++
expr_stmt|;
break|break;
case|case
name|display
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|itemize
case|:
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|true
expr_stmt|;
comment|/* Make things work for losers who forget the itemize syntax. */
if|if
condition|(
name|type
operator|==
name|itemize
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insertion_stack
operator|->
name|item_function
operator|)
condition|)
block|{
name|free
argument_list|(
name|insertion_stack
operator|->
name|item_function
argument_list|)
expr_stmt|;
name|insertion_stack
operator|->
name|item_function
operator|=
name|savestring
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|enumerate
case|:
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|start_numbering
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|group
case|:
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ifinfo
case|:
comment|/* Undo whatever we just did.  This is a no-op. */
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
name|filling_enabled
operator|=
name|insertion_stack
operator|->
name|filling_enabled
expr_stmt|;
name|indented_fill
operator|=
name|insertion_stack
operator|->
name|indented_fill
expr_stmt|;
break|break;
case|case
name|defun
case|:
case|case
name|defvar
case|:
case|case
name|defopt
case|:
case|case
name|deffn
case|:
case|case
name|defspec
case|:
case|case
name|defmac
case|:
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|true
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|no_discard
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Try to end the quotation with the specified type.    Like begin_insertion (), this uses a giant switch statement as    well.  A big difference is that you *must* pass a valid type to    this function, and a value of bad_type gets translated to match    the value currently on top of the stack.  If, however, the value    passed is a valid type, and it doesn't match the top of the    stack, then we produce an error.  Should fix this, somewhat    unclean. */
end_comment

begin_expr_stmt
name|end_insertion
argument_list|(
name|type
argument_list|)
expr|enum
name|insertion_type
name|type
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|enum
name|insertion_type
name|temp_type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return;
name|temp_type
operator|=
name|current_insertion_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
name|type
operator|=
name|temp_type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|temp_type
condition|)
block|{
name|line_error
argument_list|(
literal|"Expected `%s', but saw `%s'.  Token unread"
argument_list|,
name|insertion_type_pname
argument_list|(
name|temp_type
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pop_insertion
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu
case|:
name|in_menu
operator|--
expr_stmt|;
comment|/* no longer hacking menus. */
break|break;
case|case
name|enumerate
case|:
name|stop_numbering
argument_list|()
expr_stmt|;
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|group
case|:
case|case
name|ifinfo
case|:
break|break;
case|case
name|format
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|display
case|:
case|case
name|lisp
case|:
name|in_fixed_width_font
operator|--
expr_stmt|;
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
break|break;
default|default:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
break|break;
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insertions cannot cross certain boundaries, such as node beginnings.  In    code that creates such boundaries, you should call discard_insertions ()    before doing anything else.  It prints the errors for you, and cleans up    the insertion stack. */
end_comment

begin_macro
name|discard_insertions
argument_list|()
end_macro

begin_block
block|{
name|int
name|real_line_number
init|=
name|line_number
decl_stmt|;
while|while
condition|(
name|insertion_stack
condition|)
block|{
if|if
condition|(
name|insertion_stack
operator|->
name|insertion
operator|==
name|ifinfo
condition|)
break|break;
else|else
block|{
name|char
modifier|*
name|offender
init|=
operator|(
name|char
operator|*
operator|)
name|insertion_type_pname
argument_list|(
name|insertion_stack
operator|->
name|insertion
argument_list|)
decl_stmt|;
name|line_number
operator|=
name|insertion_stack
operator|->
name|line_number
expr_stmt|;
name|line_error
argument_list|(
literal|"This `%s' doesn't have a matching `%cend %s'"
argument_list|,
name|offender
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|offender
argument_list|)
expr_stmt|;
name|pop_insertion
argument_list|()
expr_stmt|;
block|}
block|}
name|line_number
operator|=
name|real_line_number
expr_stmt|;
block|}
end_block

begin_comment
comment|/* MAX_NS is the maximum nesting level for enumerations.  I picked 100    which seemed reasonable.  This doesn't control the number of items,    just the number of nested lists. */
end_comment

begin_define
define|#
directive|define
name|max_ns
value|100
end_define

begin_decl_stmt
name|int
name|number_stack
index|[
name|max_ns
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|the_current_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|start_numbering
argument_list|(
argument|at_number
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|number_offset
operator|+
literal|1
operator|==
name|max_ns
condition|)
block|{
name|line_error
argument_list|(
literal|"Enumeration stack overflow"
argument_list|)
expr_stmt|;
return|return;
block|}
name|number_stack
index|[
name|number_offset
operator|++
index|]
operator|=
name|the_current_number
expr_stmt|;
name|the_current_number
operator|=
name|at_number
expr_stmt|;
block|}
end_block

begin_macro
name|stop_numbering
argument_list|()
end_macro

begin_block
block|{
name|the_current_number
operator|=
name|number_stack
index|[
operator|--
name|number_offset
index|]
expr_stmt|;
if|if
condition|(
name|number_offset
operator|<
literal|0
condition|)
name|number_offset
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Place a number into the output stream. */
end_comment

begin_macro
name|number_item
argument_list|()
end_macro

begin_block
block|{
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d. "
argument_list|,
name|the_current_number
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|output_column
operator|+=
operator|(
name|current_indent
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|the_current_number
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The actual commands themselves. */
end_comment

begin_comment
comment|/* Commands which insert themselves. */
end_comment

begin_macro
name|insert_self
argument_list|()
end_macro

begin_block
block|{
name|add_word
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Force line break */
end_comment

begin_macro
name|cm_asterisk
argument_list|()
end_macro

begin_block
block|{
comment|/* Force a line break in the output. */
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|output_column
operator|=
name|current_indent
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert ellipsis. */
end_comment

begin_macro
name|cm_dots
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_bullet
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_minus
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert "TeX". */
end_comment

begin_macro
name|cm_TeX
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"TeX"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_copyright
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"(C)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_code
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
name|printing_index
condition|)
return|return;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_samp
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_file
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_kbd
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_key
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Convert the character at position-1 into CTL. */
end_comment

begin_macro
name|cm_ctrl
argument_list|(
argument|arg
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|output_paragraph
index|[
name|position
operator|-
literal|1
index|]
operator|=
name|CTL
argument_list|(
name|output_paragraph
index|[
name|position
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Small Caps in makeinfo just does all caps. */
end_comment

begin_macro
name|cm_sc
argument_list|(
argument|arg
argument_list|,
argument|start_pos
argument_list|,
argument|end_pos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
while|while
condition|(
name|start_pos
operator|<
name|end_pos
condition|)
block|{
name|output_paragraph
index|[
name|start_pos
index|]
operator|=
name|coerce_to_upper
argument_list|(
name|output_paragraph
index|[
name|start_pos
index|]
argument_list|)
expr_stmt|;
name|start_pos
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* @var in makeinfo just uppercases the text. */
end_comment

begin_macro
name|cm_var
argument_list|(
argument|arg
argument_list|,
argument|start_pos
argument_list|,
argument|end_pos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
while|while
condition|(
name|start_pos
operator|<
name|end_pos
condition|)
block|{
name|output_paragraph
index|[
name|start_pos
index|]
operator|=
name|coerce_to_upper
argument_list|(
name|output_paragraph
index|[
name|start_pos
index|]
argument_list|)
expr_stmt|;
name|start_pos
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|cm_dfn
argument_list|(
argument|arg
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_char
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_emph
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_strong
argument_list|(
argument|arg
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_emph
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_cite
argument_list|(
argument|arg
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"``"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"''"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_italic
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_macro
name|cm_bold
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{
name|cm_italic
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_roman
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_macro
name|cm_title
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{
name|cm_italic
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_refill
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/* Prevent the argument from being split across two lines. */
end_comment

begin_macro
name|cm_w
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|non_splitting_words
operator|++
expr_stmt|;
else|else
name|non_splitting_words
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Explain that this command is obsolete, thus the user shouldn't    do anything with it. */
end_comment

begin_macro
name|cm_obsolete
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|warning
argument_list|(
literal|"The command `@%s' is obsolete"
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert the text following input_text_offset up to the end of the line    in a new, separate paragraph.  Directly underneath it, insert a    line of WITH_CHAR, the same length of the inserted text. */
end_comment

begin_macro
name|insert_and_underscore
argument_list|(
argument|with_char
argument_list|)
end_macro

begin_decl_stmt
name|int
name|with_char
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|old_no_indent
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|false
expr_stmt|;
name|old_no_indent
operator|=
name|no_indent
expr_stmt|;
name|no_indent
operator|=
name|true
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|len
operator|=
name|output_position
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
operator|(
name|output_position
operator|+
name|output_paragraph_offset
operator|)
operator|-
literal|1
operator|)
operator|-
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|add_char
argument_list|(
name|with_char
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|true
expr_stmt|;
name|no_indent
operator|=
name|old_no_indent
expr_stmt|;
block|}
end_block

begin_macro
name|cm_chapter
argument_list|()
end_macro

begin_block
block|{
name|insert_and_underscore
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_section
argument_list|()
end_macro

begin_block
block|{
name|insert_and_underscore
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_subsection
argument_list|()
end_macro

begin_block
block|{
name|insert_and_underscore
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_subsubsection
argument_list|()
end_macro

begin_block
block|{
name|insert_and_underscore
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_unnumbered
argument_list|()
end_macro

begin_block
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_unnumberedsec
argument_list|()
end_macro

begin_block
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_unnumberedsubsec
argument_list|()
end_macro

begin_block
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_unnumberedsubsubsec
argument_list|()
end_macro

begin_block
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_appendix
argument_list|()
end_macro

begin_block
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_appendixsec
argument_list|()
end_macro

begin_block
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_appendixsubsec
argument_list|()
end_macro

begin_block
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_appendixsubsubsec
argument_list|()
end_macro

begin_block
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_majorheading
argument_list|()
end_macro

begin_block
block|{
name|cm_chapheading
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_chapheading
argument_list|()
end_macro

begin_block
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_heading
argument_list|()
end_macro

begin_block
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_subheading
argument_list|()
end_macro

begin_block
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_subsubheading
argument_list|()
end_macro

begin_block
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   Adding nodes, and making tags		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Start a new tag table. */
end_comment

begin_macro
name|init_tag_table
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|tag_table
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
name|TAG_ENTRY
modifier|*
name|temp
init|=
name|tag_table
decl_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|prev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|up
argument_list|)
expr_stmt|;
name|tag_table
operator|=
name|tag_table
operator|->
name|next_ent
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|write_tag_table
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|write_tag_table_internal
argument_list|(
name|false
argument_list|)
operator|)
return|;
comment|/* Not indirect. */
block|}
end_block

begin_macro
name|write_tag_table_indirect
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|write_tag_table_internal
argument_list|(
name|true
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Write out the contents of the existing tag table.    INDIRECT_P says how to format the output. */
end_comment

begin_macro
name|write_tag_table_internal
argument_list|(
argument|indirect_p
argument_list|)
end_macro

begin_decl_stmt
name|boolean
name|indirect_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TAG_ENTRY
modifier|*
name|node
init|=
name|tag_table
decl_stmt|;
name|filling_enabled
operator|=
name|false
expr_stmt|;
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|indirect_p
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\037\nTag Table:\n%s"
argument_list|,
name|indirect_p
condition|?
literal|"(Indirect)\n"
else|:
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
name|add_word_args
argument_list|(
literal|"Node: %s\177%d\n"
argument_list|,
name|node
operator|->
name|node
argument_list|,
name|node
operator|->
name|position
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|next_ent
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"\037\nEnd Tag Table\n"
argument_list|)
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|get_node_token
parameter_list|()
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|get_until_in_line
argument_list|(
literal|","
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|canon_white
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* Allow things like @@nodename. */
name|normalize_node_name
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a node name in STRING, remove double @ signs, replacing them    with just one. */
end_comment

begin_macro
name|normalize_node_name
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'@'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'@'
condition|)
block|{
name|strncpy
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|string
operator|+
name|i
operator|+
literal|1
argument_list|,
name|l
operator|-
name|i
argument_list|)
expr_stmt|;
name|l
operator|--
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Look up NAME in the tag table, and return the associated    tag_entry.  If the node is not in the table return NULL. */
end_comment

begin_function
name|TAG_ENTRY
modifier|*
name|find_node
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|tag_table
decl_stmt|;
while|while
condition|(
name|tag
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|stricmp
argument_list|(
name|tag
operator|->
name|node
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tag
operator|)
return|;
name|tag
operator|=
name|tag
operator|->
name|next_ent
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remember NODE and associates. */
end_comment

begin_macro
name|remember_node
argument_list|(
argument|node
argument_list|,
argument|prev
argument_list|,
argument|next
argument_list|,
argument|up
argument_list|,
argument|position
argument_list|,
argument|line_no
argument_list|,
argument|no_warn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|up
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|position
decl_stmt|,
name|line_no
decl_stmt|,
name|no_warn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Check for existence of this tag already. */
if|if
condition|(
name|validating
condition|)
block|{
specifier|register
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|find_node
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s' multiply defined (%d is first definition)"
argument_list|,
name|node
argument_list|,
name|tag
operator|->
name|line_no
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* First, make this the current node. */
name|current_node
operator|=
name|node
expr_stmt|;
comment|/* Now add it to the list. */
block|{
name|TAG_ENTRY
modifier|*
name|new
init|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG_ENTRY
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|new
operator|->
name|up
operator|=
name|up
expr_stmt|;
name|new
operator|->
name|position
operator|=
name|position
expr_stmt|;
name|new
operator|->
name|line_no
operator|=
name|line_no
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|node_filename
expr_stmt|;
name|new
operator|->
name|touched
operator|=
literal|0
expr_stmt|;
comment|/* not yet referenced. */
name|new
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|no_warn
condition|)
name|new
operator|->
name|flags
operator||=
name|NO_WARN
expr_stmt|;
name|new
operator|->
name|next_ent
operator|=
name|tag_table
expr_stmt|;
name|tag_table
operator|=
name|new
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Here is a structure which associates sectioning commands with    an integer, hopefully to reflect the `depth' of the current    section. */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|level
decl_stmt|;
block|}
name|section_alist
index|[]
init|=
block|{
block|{
literal|"chapter"
block|,
literal|1
block|}
block|,
block|{
literal|"section"
block|,
literal|2
block|}
block|,
block|{
literal|"subsec"
block|,
literal|3
block|}
block|,
block|{
literal|"subsubsec"
block|,
literal|4
block|}
block|,
block|{
literal|"unnumbered"
block|,
literal|1
block|}
block|,
block|{
literal|"unnumberedsec"
block|,
literal|2
block|}
block|,
block|{
literal|"unnumberedsubsec"
block|,
literal|3
block|}
block|,
block|{
literal|"unnumberedsubsubsec"
block|,
literal|4
block|}
block|,
block|{
literal|"appendix"
block|,
literal|1
block|}
block|,
block|{
literal|"appendixsec"
block|,
literal|2
block|}
block|,
block|{
literal|"appendixsubsec"
block|,
literal|3
block|}
block|,
block|{
literal|"appendixsubsubsec"
block|,
literal|4
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Return an integer which identifies the type section present in TEXT. */
end_comment

begin_function
name|int
name|what_section
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|text
index|[
name|j
index|]
operator|&&
name|whitespace
argument_list|(
name|text
index|[
name|j
index|]
argument_list|)
operator|||
name|text
index|[
name|j
index|]
operator|==
literal|'\n'
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|text
index|[
name|j
index|]
operator|!=
literal|'@'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|text
operator|=
name|text
operator|+
name|j
operator|+
literal|1
expr_stmt|;
comment|/* Handle italicized sectioning commands. */
if|if
condition|(
operator|*
name|text
operator|==
literal|'i'
condition|)
name|text
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
operator|=
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|t
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The order is: nodename, nextnode, prevnode, upnode.    The next, prev, and up fields can be defaulted.    You must follow a node command which has those fields    defaulted with a sectioning command (e.g. @chapter) giving    the "level" of that node.  It is an error not to do so.    The defaults come from the menu in this nodes parent. */
end_comment

begin_macro
name|cm_node
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|int
name|new_node_pos
decl_stmt|,
name|defaulting
decl_stmt|,
name|this_section
decl_stmt|,
name|no_warn
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|already_outputting_pending_notes
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"nwnode"
argument_list|)
operator|==
literal|0
condition|)
name|no_warn
operator|=
literal|1
expr_stmt|;
comment|/* Get rid of unmatched brace arguments from previous commands. */
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* There also might be insertions left lying around that haven't been      ended yet.  Do that also. */
name|discard_insertions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|already_outputting_pending_notes
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
name|output_pending_notes
argument_list|()
expr_stmt|;
name|free_pending_notes
argument_list|()
expr_stmt|;
block|}
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|false
expr_stmt|;
name|new_node_pos
operator|=
name|output_position
operator|+
literal|1
expr_stmt|;
name|node
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|next
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|prev
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|up
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|this_section
operator|=
name|what_section
argument_list|(
name|input_text
operator|+
name|input_text_offset
argument_list|)
expr_stmt|;
comment|/* ??? The first \n in the following string shouldn't be there, but I have      to revamp the @example& @group things so that they always leave a \n      as the last character output.  Until that time, this is the only way      I can produce reliable output. */
name|no_indent
operator|=
name|true
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\n\037\nFile: %s,  Node: %s"
argument_list|,
name|pretty_output_filename
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Check for defaulting of this node's next, prev, and up fields. */
name|defaulting
operator|=
operator|(
operator|(
name|strlen
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|prev
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|up
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* If we are defaulting, then look at the immediately following      sectioning command (error if none) to determine the node's      level.  Find the node that contains the menu mentioning this node      that is one level up (error if not found).  That node is the "Up"      of this node.  Default the "Next" and "Prev" from the menu. */
if|if
condition|(
name|defaulting
condition|)
block|{
name|NODE_REF
modifier|*
name|last_ref
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
decl_stmt|;
name|NODE_REF
modifier|*
name|ref
init|=
name|node_references
decl_stmt|;
if|if
condition|(
name|this_section
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|polite_section_name
init|=
literal|"chapter"
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|==
name|current_section
operator|+
literal|1
condition|)
block|{
name|polite_section_name
operator|=
name|section_alist
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
break|break;
block|}
name|line_error
argument_list|(
literal|"Node `%s' requires a sectioning command (e.g. @%s)"
argument_list|,
name|node
argument_list|,
name|polite_section_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ref
condition|)
block|{
if|if
condition|(
name|ref
operator|->
name|section
operator|==
operator|(
name|this_section
operator|-
literal|1
operator|)
operator|&&
name|ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
name|stricmp
argument_list|(
name|ref
operator|->
name|node
argument_list|,
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
name|savestring
argument_list|(
name|ref
operator|->
name|containing_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_ref
operator|&&
name|strcmp
argument_list|(
name|last_ref
operator|->
name|containing_node
argument_list|,
name|ref
operator|->
name|containing_node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|savestring
argument_list|(
name|last_ref
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ref
operator|->
name|next
operator|&&
name|strcmp
argument_list|(
name|ref
operator|->
name|next
operator|->
name|containing_node
argument_list|,
name|ref
operator|->
name|containing_node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|savestring
argument_list|(
name|ref
operator|->
name|next
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|last_ref
operator|=
name|ref
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|next
condition|)
name|add_word_args
argument_list|(
literal|",  Next: %s"
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prev
condition|)
name|add_word_args
argument_list|(
literal|",  Prev: %s"
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|up
condition|)
name|add_word_args
argument_list|(
literal|",  Up: %s"
argument_list|,
name|up
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|no_indent
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|node
condition|)
block|{
name|line_error
argument_list|(
literal|"No node name specified for `@%s' command"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|*
name|next
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|prev
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|up
condition|)
block|{
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|remember_node
argument_list|(
name|node
argument_list|,
name|prev
argument_list|,
name|next
argument_list|,
name|up
argument_list|,
name|new_node_pos
argument_list|,
name|line_number
argument_list|,
name|no_warn
argument_list|)
expr_stmt|;
block|}
comment|/* Change the section only if there was a sectioning command. */
if|if
condition|(
name|this_section
operator|>=
literal|0
condition|)
name|current_section
operator|=
name|this_section
expr_stmt|;
name|filling_enabled
operator|=
name|true
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Validation of an info file.    Scan through the list of tag entrys touching the Prev, Next, and Up    elements of each.  It is an error not to be able to touch one of them,    except in the case of external node references, such as "(DIR)".     If the Prev is different from the Up,    then the Prev node must have a Next pointing at this node.     Every node except Top must have an Up.    The Up node must contain some sort of reference, other than a Next,    to this node.     If the Next is different from the Next of the Up,    then the Next node must have a Prev pointing at this node. */
end_comment

begin_macro
name|validate_file
argument_list|(
argument|filename
argument_list|,
argument|tag_table
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TAG_ENTRY
modifier|*
name|tag_table
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tags
init|=
name|tag_table
decl_stmt|;
while|while
condition|(
name|tags
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|register
name|TAG_ENTRY
modifier|*
name|temp_tag
decl_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
comment|/* If this node has a Next, then make sure that the Next exists. */
if|if
condition|(
name|tags
operator|->
name|next
condition|)
block|{
name|validate
argument_list|(
name|tags
operator|->
name|next
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Next"
argument_list|)
expr_stmt|;
comment|/* If the Next node exists, and there is no Up, then make 	     sure that the Prev of the Next points back. */
if|if
condition|(
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|next
argument_list|)
condition|)
block|{
name|char
modifier|*
name|prev
init|=
name|temp_tag
operator|->
name|prev
decl_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
operator|(
name|stricmp
argument_list|(
name|prev
argument_list|,
name|tags
operator|->
name|node
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s''s Next field not pointed back to"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
name|line_error
argument_list|(
literal|"This node (`%s') is the one with the bad `Prev'"
argument_list|,
name|temp_tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|temp_tag
operator|->
name|flags
operator||=
name|PREV_ERROR
expr_stmt|;
block|}
block|}
block|}
comment|/* Validate the Prev field if there is one, and we haven't already 	 complained about it in some way.  You don't have to have a Prev 	 field at this stage. */
if|if
condition|(
operator|!
operator|(
name|tags
operator|->
name|flags
operator|&
name|PREV_ERROR
operator|)
operator|&&
name|tags
operator|->
name|prev
condition|)
block|{
name|int
name|valid
init|=
name|validate
argument_list|(
name|tags
operator|->
name|prev
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Prev"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
name|tags
operator|->
name|flags
operator||=
name|PREV_ERROR
expr_stmt|;
else|else
block|{
comment|/* If the Prev field is not the same as the Up field, 		 then the node pointed to by the Prev field must have 		 a Next field which points to this node. */
if|if
condition|(
name|tags
operator|->
name|up
operator|&&
operator|(
name|stricmp
argument_list|(
name|tags
operator|->
name|prev
argument_list|,
name|tags
operator|->
name|up
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp_tag
operator|->
name|next
operator|||
operator|(
name|stricmp
argument_list|(
name|temp_tag
operator|->
name|next
argument_list|,
name|tags
operator|->
name|node
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s''s Prev field not pointed back to"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
name|line_error
argument_list|(
literal|"This node (`%s') is the one with the bad `Next'"
argument_list|,
name|temp_tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|temp_tag
operator|->
name|flags
operator||=
name|NEXT_ERROR
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|tags
operator|->
name|up
operator|&&
operator|(
name|stricmp
argument_list|(
name|tags
operator|->
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|line_error
argument_list|(
literal|"Node `%s' is missing an \"Up\" field"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tags
operator|->
name|up
condition|)
block|{
name|int
name|valid
init|=
name|validate
argument_list|(
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Up"
argument_list|)
decl_stmt|;
comment|/* If node X has Up: Y, then warn if Y fails to have a menu item 	     or note pointing at X, if Y isn't of the form "(Y)". */
if|if
condition|(
name|valid
operator|&&
operator|*
name|tags
operator|->
name|up
operator|!=
literal|'('
condition|)
block|{
name|NODE_REF
modifier|*
name|nref
decl_stmt|,
modifier|*
name|tref
decl_stmt|,
modifier|*
name|list
decl_stmt|;
name|NODE_REF
modifier|*
name|find_node_reference
parameter_list|()
function_decl|;
name|tref
operator|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
expr_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|nref
operator|=
name|find_node_reference
argument_list|(
name|tags
operator|->
name|node
argument_list|,
name|list
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|stricmp
argument_list|(
name|nref
operator|->
name|containing_node
argument_list|,
name|tags
operator|->
name|up
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nref
operator|->
name|type
operator|!=
name|menu_reference
condition|)
block|{
name|tref
operator|=
name|nref
expr_stmt|;
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
else|else
break|break;
block|}
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nref
condition|)
block|{
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|up
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
if|if
condition|(
operator|!
name|tref
condition|)
name|line_error
argument_list|(
literal|"`%s' has an Up field of `%s', but `%s' has no menu item for `%s'"
argument_list|,
name|tags
operator|->
name|node
argument_list|,
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
block|}
block|}
block|}
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
block|}
name|validate_other_references
argument_list|(
name|node_references
argument_list|)
expr_stmt|;
comment|/* We have told the user about the references which didn't exist.      Now tell him about the nodes which aren't referenced. */
name|tags
operator|=
name|tag_table
expr_stmt|;
while|while
condition|(
name|tags
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Special hack.  If the node in question appears to have          been referenced more than REFERENCE_WARNING_LIMIT times,          give a warning. */
if|if
condition|(
name|tags
operator|->
name|touched
operator|>
name|reference_warning_limit
condition|)
block|{
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|warning
argument_list|(
literal|"Node `%s' has been referenced %d times"
argument_list|,
name|tags
operator|->
name|node
argument_list|,
name|tags
operator|->
name|touched
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tags
operator|->
name|touched
operator|==
literal|0
condition|)
block|{
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
comment|/* Notice that the node "Top" is special, and doesn't have to 	     be referenced. */
if|if
condition|(
name|stricmp
argument_list|(
name|tags
operator|->
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"Unreferenced node `%s'"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
block|}
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return 1 if tag correctly validated, or 0 if not. */
end_comment

begin_macro
name|validate
argument_list|(
argument|tag
argument_list|,
argument|line
argument_list|,
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TAG_ENTRY
modifier|*
name|result
decl_stmt|;
comment|/* If there isn't a tag to verify, or if the tag is in another file,      then it must be okay. */
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
operator|*
name|tag
operator|||
operator|*
name|tag
operator|==
literal|'('
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Otherwise, the tag must exist. */
name|result
operator|=
name|find_node
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|line_number
operator|=
name|line
expr_stmt|;
name|line_error
argument_list|(
literal|"Validation error.  `%s' field points to node `%s', which doesn't exist"
argument_list|,
name|label
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|result
operator|->
name|touched
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Split large output files into a series of smaller files.  Each file    is pointed to in the tag table, which then gets written out as the    original file.  The new files have the same name as the original file    with a "-num" attached.  SIZE is the largest number of bytes to allow    in any single split file. */
end_comment

begin_macro
name|split_file
argument_list|(
argument|filename
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|root_filename
decl_stmt|,
modifier|*
name|root_pathname
decl_stmt|;
name|char
modifier|*
name|the_file
decl_stmt|,
modifier|*
name|filename_part
argument_list|()
decl_stmt|;
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|char
modifier|*
name|the_header
decl_stmt|;
name|int
name|header_size
decl_stmt|;
comment|/* Can only do this to files with tag tables. */
if|if
condition|(
operator|!
name|tag_table
condition|)
return|return;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|DEFAULT_SPLIT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|fileinfo
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fileinfo
operator|.
name|st_size
operator|<
name|SPLIT_SIZE_THRESHOLD
operator|)
condition|)
return|return;
name|the_file
operator|=
name|find_and_load
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|the_file
condition|)
return|return;
name|root_filename
operator|=
name|filename_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|root_pathname
operator|=
name|pathname_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root_pathname
condition|)
name|root_pathname
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Start splitting the file.  Walk along the tag table      outputting sections of the file.  When we have written      all of the nodes in the tag table, make the top-level      pointer file, which contains indirect pointers and      tags for the nodes. */
block|{
name|int
name|which_file
init|=
literal|1
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tags
init|=
name|tag_table
decl_stmt|;
name|char
modifier|*
name|indirect_info
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Remember the `header' of this file.  The first tag in the file is        the bottom of the header; the top of the file is the start. */
name|the_header
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|header_size
operator|=
operator|(
name|tags
operator|->
name|position
operator|-
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|the_file
argument_list|,
name|the_header
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|int
name|file_top
decl_stmt|,
name|file_bot
decl_stmt|,
name|limit
decl_stmt|;
comment|/* Have to include the Control-_. */
name|file_top
operator|=
name|file_bot
operator|=
name|tags
operator|->
name|position
operator|-
literal|2
expr_stmt|;
name|limit
operator|=
name|file_top
operator|+
name|size
expr_stmt|;
comment|/* If the rest of this file is only one node, then 	   that is the entire subfile. */
if|if
condition|(
operator|!
name|tags
operator|->
name|next_ent
condition|)
block|{
name|int
name|i
init|=
name|tags
operator|->
name|position
operator|+
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|the_file
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|fileinfo
operator|.
name|st_size
condition|)
block|{
if|if
condition|(
operator|(
name|the_file
index|[
name|i
index|]
operator|==
literal|'\037'
operator|)
operator|&&
operator|(
operator|(
name|last_char
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|last_char
operator|==
literal|'\014'
operator|)
operator|)
condition|)
break|break;
else|else
name|last_char
operator|=
name|the_file
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|file_bot
operator|=
name|i
expr_stmt|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
comment|/* Otherwise, find the largest number of nodes that can fit in 	   this subfile. */
for|for
control|(
init|;
name|tags
condition|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
control|)
block|{
if|if
condition|(
operator|!
name|tags
operator|->
name|next_ent
condition|)
block|{
comment|/* This entry is the last node.  Search forward for the end 	           of this node, and that is the end of this file. */
name|int
name|i
init|=
name|tags
operator|->
name|position
operator|+
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|the_file
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|fileinfo
operator|.
name|st_size
condition|)
block|{
if|if
condition|(
operator|(
name|the_file
index|[
name|i
index|]
operator|==
literal|'\037'
operator|)
operator|&&
operator|(
operator|(
name|last_char
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|last_char
operator|==
literal|'\014'
operator|)
operator|)
condition|)
break|break;
else|else
name|last_char
operator|=
name|the_file
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|file_bot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|file_bot
operator|<
name|limit
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
else|else
block|{
comment|/* Here we want to write out everything before the last 		       node, and then write the last node out in a file 		       by itself. */
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
block|}
if|if
condition|(
name|tags
operator|->
name|next_ent
operator|->
name|position
operator|>
name|limit
condition|)
block|{
if|if
condition|(
operator|(
name|tags
operator|->
name|position
operator|)
operator|-
literal|2
operator|==
name|file_top
condition|)
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
name|write_region
label|:
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|split_file
init|=
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|root_pathname
argument_list|)
operator|+
name|strlen
argument_list|(
name|root_filename
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|split_file
argument_list|,
literal|"%s%s-%d"
argument_list|,
name|root_pathname
argument_list|,
name|root_filename
argument_list|,
name|which_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|split_file
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|write
argument_list|(
name|fd
argument_list|,
name|the_header
argument_list|,
name|header_size
argument_list|)
operator|!=
name|header_size
operator|)
operator|||
operator|(
name|write
argument_list|(
name|fd
argument_list|,
name|the_file
operator|+
name|file_top
argument_list|,
name|file_bot
operator|-
name|file_top
argument_list|)
operator|!=
operator|(
name|file_bot
operator|-
name|file_top
operator|)
operator|)
operator|||
operator|(
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
name|perror
argument_list|(
name|split_file
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|indirect_info
condition|)
block|{
name|indirect_info
operator|=
name|the_file
operator|+
name|file_top
expr_stmt|;
name|sprintf
argument_list|(
name|indirect_info
argument_list|,
literal|"\037\nIndirect:\n"
argument_list|)
expr_stmt|;
name|indirect_info
operator|+=
name|strlen
argument_list|(
name|indirect_info
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|indirect_info
argument_list|,
literal|"%s-%d: %d\n"
argument_list|,
name|root_filename
argument_list|,
name|which_file
argument_list|,
name|file_top
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|split_file
argument_list|)
expr_stmt|;
name|indirect_info
operator|+=
name|strlen
argument_list|(
name|indirect_info
argument_list|)
expr_stmt|;
name|which_file
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* We have sucessfully created the subfiles.  Now write out the        original again.  We must use `output_stream', or        write_tag_table_indirect () won't know where to place the output. */
name|output_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_stream
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|distance
init|=
name|indirect_info
operator|-
name|the_file
decl_stmt|;
name|fwrite
argument_list|(
name|the_file
argument_list|,
literal|1
argument_list|,
name|distance
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
comment|/* Inhibit newlines. */
name|paragraph_is_open
operator|=
name|false
expr_stmt|;
name|write_tag_table_indirect
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_header
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Some menu hacking.  This is used to remember menu references while    reading the input file.  After the output file has been written, if    validation is on, then we use the contents of NODE_REFERENCES as a    list of nodes to validate. */
end_comment

begin_function
name|char
modifier|*
name|reftype_type_string
parameter_list|(
name|type
parameter_list|)
name|enum
name|reftype
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu_reference
case|:
return|return
operator|(
literal|"Menu"
operator|)
return|;
case|case
name|followed_reference
case|:
return|return
operator|(
literal|"Followed-Reference"
operator|)
return|;
default|default:
return|return
operator|(
literal|"Internal-bad-reference-type"
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Remember this node name for later validation use. */
end_comment

begin_macro
name|remember_node_reference
argument_list|(
argument|node
argument_list|,
argument|line
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reftype
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|NODE_REF
modifier|*
name|temp
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE_REF
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|next
operator|=
name|node_references
expr_stmt|;
name|temp
operator|->
name|node
operator|=
name|savestring
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line_no
operator|=
name|line
expr_stmt|;
name|temp
operator|->
name|section
operator|=
name|current_section
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|temp
operator|->
name|containing_node
operator|=
name|savestring
argument_list|(
name|current_node
argument_list|)
expr_stmt|;
name|temp
operator|->
name|filename
operator|=
name|node_filename
expr_stmt|;
name|node_references
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|validate_other_references
argument_list|(
name|ref_list
argument_list|)
specifier|register
name|NODE_REF
operator|*
name|ref_list
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
while|while
condition|(
name|ref_list
operator|!=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
condition|)
block|{
name|input_filename
operator|=
name|ref_list
operator|->
name|filename
expr_stmt|;
name|validate
argument_list|(
name|ref_list
operator|->
name|node
argument_list|,
name|ref_list
operator|->
name|line_no
argument_list|,
name|reftype_type_string
argument_list|(
name|ref_list
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
expr_stmt|;
block|}
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Find NODE in REF_LIST. */
end_comment

begin_function
name|NODE_REF
modifier|*
name|find_node_reference
parameter_list|(
name|node
parameter_list|,
name|ref_list
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
specifier|register
name|NODE_REF
modifier|*
name|ref_list
decl_stmt|;
block|{
while|while
condition|(
name|ref_list
condition|)
block|{
if|if
condition|(
name|stricmp
argument_list|(
name|node
argument_list|,
name|ref_list
operator|->
name|node
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|ref_list
operator|)
return|;
block|}
end_function

begin_macro
name|free_node_references
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|NODE_REF
modifier|*
name|list
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|temp
operator|=
name|list
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|containing_node
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|node_references
operator|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|menu_starter
value|"* "
end_define

begin_macro
name|glean_node_from_menu
argument_list|()
end_macro

begin_block
block|{
comment|/* This function gets called at the start of every line while inside of      a menu.  It checks to see if the line starts with "* ", and if so,      remembers the node reference that this menu refers to.       input_text_offset is at the \n just before the line start. */
name|int
name|i
decl_stmt|,
name|orig_offset
init|=
name|input_text_offset
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
argument_list|,
name|menu_starter
argument_list|,
name|strlen
argument_list|(
name|menu_starter
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
else|else
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|menu_starter
argument_list|)
operator|+
literal|1
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|":"
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|':'
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|canon_white
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|':'
condition|)
goto|goto
name|save_node
goto|;
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|nodename
argument_list|)
expr_stmt|;
comment|/* Special hack: If the nodename follows the menu item name,      then we have to read the rest of the line in order to find      out what the nodename is.  But we still have to read the      line later, in order to process any formatting commands that      might be present.  So un-count the carriage return that has just      been counted. */
name|line_number
operator|--
expr_stmt|;
name|canon_white
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|nodename
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nodename
index|[
name|i
index|]
operator|==
literal|'\t'
operator|||
name|nodename
index|[
name|i
index|]
operator|==
literal|'.'
operator|||
name|nodename
index|[
name|i
index|]
operator|==
literal|','
condition|)
block|{
name|nodename
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|save_node
label|:
name|normalize_node_name
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|remember_node_reference
argument_list|(
name|nodename
argument_list|,
name|line_number
argument_list|,
name|menu_reference
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|input_text_offset
operator|=
name|orig_offset
expr_stmt|;
block|}
end_block

begin_macro
name|cm_menu
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Cross Reference Hacking			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|char
modifier|*
name|get_xref_token
parameter_list|()
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|get_until_in_braces
argument_list|(
literal|","
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|fix_whitespace
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|normalize_node_name
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|px_ref_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls initial output string. */
end_comment

begin_comment
comment|/* Make a cross reference. */
end_comment

begin_macro
name|cm_xref
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|,
modifier|*
name|arg4
decl_stmt|,
modifier|*
name|arg5
decl_stmt|;
name|arg1
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg2
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg3
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg4
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg5
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|add_word_args
argument_list|(
literal|"%s"
argument_list|,
name|px_ref_flag
condition|?
literal|"*note "
else|:
literal|"*Note "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg5
operator|||
operator|*
name|arg4
condition|)
block|{
name|char
modifier|*
name|node_name
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|arg2
condition|)
name|node_name
operator|=
name|arg1
expr_stmt|;
else|else
name|node_name
operator|=
name|arg2
expr_stmt|;
name|add_word_args
argument_list|(
literal|"%s: (%s)%s"
argument_list|,
name|arg2
argument_list|,
name|arg4
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|remember_node_reference
argument_list|(
name|arg1
argument_list|,
name|line_number
argument_list|,
name|followed_reference
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg3
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|arg2
condition|)
block|{
name|add_word_args
argument_list|(
literal|"%s: %s"
argument_list|,
name|arg3
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_word_args
argument_list|(
literal|"%s: %s"
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|*
name|arg2
condition|)
block|{
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|": %s"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_word_args
argument_list|(
literal|"%s::"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Check to make sure that the next non-whitespace character is either          a period or a comma. input_text_offset is pointing at the "}" which          ended the xref or pxref command. */
name|int
name|temp
init|=
name|input_text_offset
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
return|return;
while|while
condition|(
name|temp
operator|<
name|size_of_input_text
condition|)
block|{
if|if
condition|(
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|temp
index|]
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'.'
operator|||
name|input_text
index|[
name|temp
index|]
operator|==
literal|','
operator|||
name|input_text
index|[
name|temp
index|]
operator|==
literal|'\t'
condition|)
return|return;
else|else
block|{
name|line_error
argument_list|(
literal|"Cross-reference must be terminated with a period or a comma"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
end_block

begin_macro
name|cm_pxref
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|px_ref_flag
operator|++
expr_stmt|;
name|cm_xref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|px_ref_flag
operator|--
expr_stmt|;
block|}
else|else
name|add_char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_inforef
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|pname
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|node
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|pname
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|file
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|add_word_args
argument_list|(
literal|"*note %s: (%s)%s"
argument_list|,
name|pname
argument_list|,
name|file
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Insertion Command Stubs			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_macro
name|cm_quotation
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|quotation
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_example
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|example
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_smallexample
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|smallexample
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_lisp
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|lisp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_format
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_display
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_itemize
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|itemize
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_enumerate
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|enumerate
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_table
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_group
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_ifinfo
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|ifinfo
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_tex
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n@end tex"
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_iftex
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n@end iftex"
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_titlespec
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n@end titlespec"
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_titlepage
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n@end titlepage"
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_ignore
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n@end ignore"
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			@itemx, @item				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero means a string is in execution, as opposed to a file. */
end_comment

begin_decl_stmt
name|int
name|executing_string
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Execute the string produced by formatting the ARGs with FORMAT.  This    is like submitting a new file with @include. */
end_comment

begin_macro
name|execute_string
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|temp_string
index|[
literal|4000
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_string
argument_list|,
literal|"@bye\n"
argument_list|)
expr_stmt|;
name|pushfile
argument_list|()
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|input_text
operator|=
name|temp_string
expr_stmt|;
name|input_filename
operator|=
name|savestring
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|size_of_input_text
operator|=
name|strlen
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|executing_string
operator|++
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|executing_string
operator|--
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|savestring
argument_list|(
literal|"not bye"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|itemx_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|cm_itemx
argument_list|()
end_macro

begin_block
block|{
name|itemx_flag
operator|++
expr_stmt|;
name|cm_item
argument_list|()
expr_stmt|;
name|itemx_flag
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|cm_item
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|rest_of_line
decl_stmt|,
modifier|*
name|item_func
decl_stmt|;
comment|/* Can only hack "@item" while inside of an insertion. */
if|if
condition|(
name|insertion_level
condition|)
block|{
name|get_until
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|rest_of_line
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|rest_of_line
argument_list|)
expr_stmt|;
name|item_func
operator|=
name|current_item_function
argument_list|()
expr_stmt|;
comment|/* Okay, do the right thing depending on which insertion function 	 is active. */
switch|switch
condition|(
name|current_insertion_type
argument_list|()
condition|)
block|{
case|case
name|menu
case|:
case|case
name|quotation
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|format
case|:
case|case
name|display
case|:
case|case
name|group
case|:
case|case
name|ifinfo
case|:
name|line_error
argument_list|(
literal|"The `@%s' command is meaningless within a `@%s' block"
argument_list|,
name|command
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|itemize
case|:
case|case
name|enumerate
case|:
if|if
condition|(
name|itemx_flag
condition|)
block|{
name|line_error
argument_list|(
literal|"@itemx is not meaningful inside of a `%s' block"
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|itemize
condition|)
block|{
name|indent
argument_list|(
name|output_column
operator|=
name|current_indent
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* I need some way to determine whether this command 		     takes braces or not.  I believe the user can type 		     either "@bullet" or "@bullet{}".  Of course, they 		     can also type "o" or "#" or whatever else they want. */
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
block|{
if|if
condition|(
operator|*
name|item_func
operator|==
literal|'@'
condition|)
if|if
condition|(
name|item_func
index|[
name|strlen
argument_list|(
name|item_func
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'}'
condition|)
name|execute_string
argument_list|(
literal|"%s{}"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
block|}
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
else|else
name|number_item
argument_list|()
expr_stmt|;
comment|/* Special hack.  This makes close paragraph ignore you until 		 the start_paragraph () function has been called. */
name|must_start_paragraph
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|table
case|:
block|{
comment|/* Get rid of extra characters. */
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* close_paragraph () almost does what we want.  The problem 	       is when paragraph_is_open, and last_char_was_newline, and 	       the last newline has been turned into a space, because 	       filling_enabled. I handle it here. */
if|if
condition|(
name|last_char_was_newline
operator|&&
name|filling_enabled
operator|&&
name|paragraph_is_open
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* Indent on a new line, but back up one indentation level. */
comment|/* force existing indentation. */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|--
expr_stmt|;
name|kill_self_indent
argument_list|(
name|default_indentation_increment
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Add item's argument to the line. */
name|filling_enabled
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|item_func
operator|&&
operator|!
operator|(
operator|*
name|item_func
operator|)
condition|)
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s{%s}"
argument_list|,
name|item_func
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
comment|/* Start a new line, and let start_paragraph () 	       do the indenting of it for you. */
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
name|true
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rest_of_line
argument_list|)
expr_stmt|;
block|}
else|else
name|line_error
argument_list|(
literal|"@%s found outside of an insertion block"
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Defun and Friends       		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The list of args that were passed to the def**** command. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|defun_args
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An alist mapping defun insertion types to the text that we use    to describe them. */
end_comment

begin_struct
struct|struct
block|{
name|enum
name|insertion_type
name|type
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
block|}
name|type_title_alist
index|[]
init|=
block|{
block|{
name|defun
block|,
literal|"Function"
block|}
block|,
block|{
name|defmac
block|,
literal|"Macro"
block|}
block|,
block|{
name|defspec
block|,
literal|"Special form"
block|}
block|,
block|{
name|defopt
block|,
literal|"Option"
block|}
block|,
block|{
name|deffn
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|,
block|{
name|defvar
block|,
literal|"Variable"
block|}
block|,
block|{
operator|(
expr|enum
name|insertion_type
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Return the title string for this type of defun. */
end_comment

begin_function
name|char
modifier|*
name|defun_title
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|type_title_alist
index|[
name|i
index|]
operator|.
name|type
operator|||
name|type_title_alist
index|[
name|i
index|]
operator|.
name|title
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|type_title_alist
index|[
name|i
index|]
operator|.
name|type
operator|==
name|type
condition|)
return|return
operator|(
name|type_title_alist
index|[
name|i
index|]
operator|.
name|title
operator|)
return|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a list of words from the contents of STRING.    You can group words with braces. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|args_from_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|result_index
decl_stmt|,
name|size
decl_stmt|;
name|int
name|len
decl_stmt|,
name|skip_til_brace
init|=
literal|0
decl_stmt|;
name|i
operator|=
name|result_index
operator|=
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Get a token, and stuff it into RESULT.  The tokens are split      at spaces or tabs. */
while|while
condition|(
name|string
index|[
name|i
index|]
condition|)
block|{
comment|/* Skip leading whitespace. */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|start
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|string
index|[
name|i
index|]
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* If this is a command which takes it's argument in braces, then 	 gobble the whole thing. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|COMMAND_PREFIX
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|string
index|[
name|j
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|string
index|[
name|j
index|]
argument_list|)
operator|&&
name|string
index|[
name|j
index|]
operator|!=
literal|'{'
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|string
index|[
name|j
index|]
operator|==
literal|'{'
condition|)
block|{
while|while
condition|(
name|string
index|[
name|j
index|]
operator|&&
name|string
index|[
name|j
index|]
operator|!=
literal|'}'
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|string
index|[
name|j
index|]
condition|)
name|j
operator|++
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
goto|goto
name|add_arg
goto|;
block|}
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'{'
operator|&&
operator|!
name|whitespace
argument_list|(
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|skip_til_brace
operator|=
literal|1
expr_stmt|;
name|start
operator|=
operator|++
name|i
expr_stmt|;
block|}
comment|/* Skip until whitespace or close brace. */
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
operator|(
operator|(
name|skip_til_brace
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|'}'
operator|)
operator|||
operator|(
operator|!
name|skip_til_brace
operator|&&
operator|!
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
operator|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
name|add_arg
label|:
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>=
name|size
condition|)
block|{
if|if
condition|(
operator|!
name|size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size
operator|=
literal|10
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
operator|(
name|size
operator|+=
literal|10
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
index|[
name|result_index
index|]
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result_index
operator|++
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|skip_til_brace
condition|)
block|{
name|skip_til_brace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_macro
name|get_defun_args
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|defun_args
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|defun_args
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|defun_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defun_args
argument_list|)
expr_stmt|;
block|}
name|defun_args
operator|=
name|args_from_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|insert_defun_arg
argument_list|(
argument|string
argument_list|,
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|defun_args
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|defun_args
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|defun_args
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|defun_args
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|i
operator|!=
name|where
condition|;
operator|--
name|i
control|)
name|defun_args
index|[
name|i
index|]
operator|=
name|defun_args
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|defun_args
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make the defun type insertion.    TYPE says which insertion this is.    TITLE is the string to describe the object being described, or NULL    for no title string.    X_P says not to start a new insertion if non-zero. */
end_comment

begin_expr_stmt
name|defun_internal
argument_list|(
name|type
argument_list|,
name|title
argument_list|,
name|x_p
argument_list|)
expr|enum
name|insertion_type
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|title
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|type_name
decl_stmt|,
modifier|*
name|func_name
decl_stmt|;
name|int
name|old_no_indent
init|=
name|no_indent
decl_stmt|;
name|get_defun_args
argument_list|()
expr_stmt|;
if|if
condition|(
name|title
condition|)
name|insert_defun_arg
argument_list|(
name|title
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|defun_args
index|[
literal|0
index|]
condition|)
block|{
name|type_name
operator|=
name|defun_args
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|defun_args
index|[
literal|1
index|]
condition|)
block|{
name|func_name
operator|=
name|defun_args
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
name|func_name
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|type_name
operator|=
literal|""
expr_stmt|;
name|no_indent
operator|=
name|true
expr_stmt|;
name|start_paragraph
argument_list|()
expr_stmt|;
name|execute_string
argument_list|(
literal|" * %s: %s"
argument_list|,
name|type_name
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|no_indent
operator|=
name|old_no_indent
expr_stmt|;
for|for
control|(
init|;
name|defun_args
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|defun_args
index|[
name|i
index|]
operator|==
literal|'&'
condition|)
name|add_word_args
argument_list|(
literal|" %s"
argument_list|,
name|defun_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|" @var{%s}"
argument_list|,
name|defun_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|add_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|defvar
operator|||
name|type
operator|==
name|defopt
condition|)
name|execute_string
argument_list|(
literal|"@vindex %s\n"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"@findex %s\n"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x_p
condition|)
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|start_paragraph
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an entry for a function, macro, special form, variable, or option.    If the name of the calling command ends in `x', then this is an extra    entry included in the body of an insertion of the same type. */
end_comment

begin_macro
name|cm_defun
argument_list|()
end_macro

begin_block
block|{
name|int
name|x_p
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|,
modifier|*
name|temp
init|=
name|savestring
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|x_p
operator|=
operator|(
name|command
index|[
name|strlen
argument_list|(
name|command
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'x'
operator|)
expr_stmt|;
if|if
condition|(
name|x_p
condition|)
name|temp
index|[
name|strlen
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* If we are adding to an already existing insertion, then make sure      that we are already in an insertion of type TYPE. */
if|if
condition|(
name|x_p
operator|&&
operator|(
operator|!
name|insertion_level
operator|||
name|insertion_stack
operator|->
name|insertion
operator|!=
name|type
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Must be in a `%s' insertion in order to use `%s'x"
argument_list|,
name|command
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|title
operator|=
name|defun_title
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|defun_internal
argument_list|(
name|type
argument_list|,
name|title
argument_list|,
name|x_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* End existing insertion block. */
end_comment

begin_macro
name|cm_end
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
block|{
name|line_error
argument_list|(
literal|"Unmatched `@%s'"
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_rest_of_line
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
condition|)
name|line_error
argument_list|(
literal|"`@%s' needs something after it"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
block|{
name|line_error
argument_list|(
literal|"Bad argument to `%s', `%s', using `%s'"
argument_list|,
name|command
argument_list|,
name|temp
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Other Random Commands		   	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* noindent () used to do something valueable, but it didn't follow the    spec for noindent in the texinfo manual.  Now it does nothing, which,    in the case of makeinfo, is correct. */
end_comment

begin_macro
name|cm_noindent
argument_list|()
end_macro

begin_block
block|{
comment|/*  no_indent = true;   indented_fill = false; */
block|}
end_block

begin_comment
comment|/* I don't know exactly what to do with this.  Should I allow    someone to switch filenames in the middle of output?  Since the    file could be partially written, this doesn't seem to make sense.    Another option: ignore it, since they don't *really* want to    switch files.  Finally, complain, or at least warn. */
end_comment

begin_macro
name|cm_setfilename
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
comment|/* warning ("`@%s %s' encountered and ignored", command, filename); */
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_comment
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_br
argument_list|()
end_macro

begin_block
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert the number of blank lines passed as argument. */
end_comment

begin_macro
name|cm_sp
argument_list|()
end_macro

begin_block
block|{
name|int
name|lines
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
comment|/*  close_paragraph (); */
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|lines
argument_list|)
expr_stmt|;
while|while
condition|(
name|lines
operator|--
condition|)
name|add_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_settitle
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_need
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/* Start a new line with just this text on it.    Then center the line of text.    This always ends the current paragraph. */
end_comment

begin_macro
name|cm_center
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|false
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
name|fill_column
condition|)
block|{
name|int
name|i
init|=
operator|(
name|fill_column
operator|-
name|strlen
argument_list|(
name|line
argument_list|)
operator|)
operator|/
literal|2
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|execute_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|true
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Show what an expression returns. */
end_comment

begin_macro
name|cm_result
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"=>"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What an expression expands to. */
end_comment

begin_macro
name|cm_expansion
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"==>"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Indicates two expressions are equivalent. */
end_comment

begin_macro
name|cm_equiv
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"=="
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What an expression may print. */
end_comment

begin_macro
name|cm_print
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"-|"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* An error signaled. */
end_comment

begin_macro
name|cm_error
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"error-->"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The location of point in an example of a buffer. */
end_comment

begin_macro
name|cm_point
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"-!-"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Start a new line with just this text on it.    The text is outdented one level if possible. */
end_comment

begin_macro
name|cm_exdent
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|i
init|=
name|current_indent
decl_stmt|;
if|if
condition|(
name|current_indent
condition|)
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|add_word_args
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|current_indent
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_include
argument_list|()
end_macro

begin_block
block|{
name|cm_infoinclude
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Remember this file, and move onto the next. */
end_comment

begin_macro
name|cm_infoinclude
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
name|pushfile
argument_list|()
expr_stmt|;
comment|/* In verbose mode we print info about including another file. */
if|if
condition|(
name|verbose_mode
condition|)
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|FSTACK
modifier|*
name|stack
init|=
name|filestack
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|stack
operator|=
name|filestack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|i
operator|*=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|find_and_load
argument_list|(
name|filename
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
name|popfile
argument_list|()
expr_stmt|;
comment|/* Cannot "@include foo", in line 5 of "/wh/bar". */
name|line_error
argument_list|(
literal|"`%c%s %s': %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|filename
argument_list|,
operator|(
operator|(
name|errno
operator|<
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|errno
index|]
else|:
literal|"Unknown file system error"
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The other side of a malformed expression. */
end_comment

begin_macro
name|misplaced_brace
argument_list|()
end_macro

begin_block
block|{
name|line_error
argument_list|(
literal|"Misplaced `}'"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Don't let the filling algorithm insert extra whitespace here. */
end_comment

begin_macro
name|cm_force_abbreviated_whitespace
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/* Make the output paragraph end the sentence here, even though it    looks like it shouldn't.  This also inserts the character which    invoked it. */
end_comment

begin_macro
name|cm_force_sentence_end
argument_list|()
end_macro

begin_block
block|{
name|add_char
argument_list|(
name|META
argument_list|(
operator|(
operator|*
name|command
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Signals end of processing.  Easy to make this happen. */
end_comment

begin_macro
name|cm_bye
argument_list|()
end_macro

begin_block
block|{
name|input_text_offset
operator|=
name|size_of_input_text
expr_stmt|;
block|}
end_block

begin_macro
name|cm_asis
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|cm_setchapternewpage
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_smallbook
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Indexing Stuff				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* An index element... */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|index_elt
block|{
name|struct
name|index_elt
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* The index entry itself. */
name|char
modifier|*
name|node
decl_stmt|;
comment|/* The node from whence it came. */
name|int
name|code
decl_stmt|;
comment|/* Non-zero means add `@code{...}' when 				   printing this element. */
block|}
name|INDEX_ELT
typedef|;
end_typedef

begin_comment
comment|/* A list of short-names for each index, and the index to that index in our    index array, the_indices.  In addition, for each index, it is remembered    whether that index is a code index or not.  Code indices have @code{}    inserted around the first word when they are printed with printindex. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|INDEX_ALIST
typedef|;
end_typedef

begin_decl_stmt
name|INDEX_ALIST
modifier|*
modifier|*
name|name_index_alist
init|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array of pointers.  Each one is for a different index.  The    "synindex" command changes which array slot is pointed to by a    given "index". */
end_comment

begin_decl_stmt
name|INDEX_ELT
modifier|*
modifier|*
name|the_indices
init|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of defined indices. */
end_comment

begin_decl_stmt
name|int
name|defined_indices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We predefine these. */
end_comment

begin_define
define|#
directive|define
name|program_index
value|0
end_define

begin_define
define|#
directive|define
name|function_index
value|1
end_define

begin_define
define|#
directive|define
name|concept_index
value|2
end_define

begin_define
define|#
directive|define
name|variable_index
value|3
end_define

begin_define
define|#
directive|define
name|datatype_index
value|4
end_define

begin_define
define|#
directive|define
name|key_index
value|5
end_define

begin_macro
name|init_indices
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Create the default data structures. */
comment|/* Initialize data space. */
if|if
condition|(
operator|!
name|the_indices
condition|)
block|{
name|the_indices
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|defined_indices
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
name|name_index_alist
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|defined_indices
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* If there were existing indices, get rid of them now. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
name|undefindex
argument_list|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Add the default indices. */
name|defindex
argument_list|(
literal|"pg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
literal|"fn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* "fn" is a code index.  */
name|defindex
argument_list|(
literal|"cp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
literal|"vr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
literal|"tp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
literal|"ky"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Find which element in the known list of indices has this name.    Returns -1 if NAME isn't found. */
end_comment

begin_function
name|int
name|find_index_offset
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name_index_alist
index|[
name|i
index|]
operator|&&
name|stricmp
argument_list|(
name|name
argument_list|,
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|index
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the entry of (name . index) for this name.    Return NULL if the index doesn't exist. */
end_comment

begin_function
name|INDEX_ALIST
modifier|*
name|find_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|offset
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
return|return
operator|(
name|name_index_alist
index|[
name|offset
index|]
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an index name, return the offset in the_indices of this index,    or -1 if there is no such index. */
end_comment

begin_macro
name|translate_index
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|INDEX_ALIST
modifier|*
name|which
init|=
name|find_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
condition|)
return|return
operator|(
name|which
operator|->
name|index
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return the index list which belongs to NAME. */
end_comment

begin_function
name|INDEX_ELT
modifier|*
name|index_list
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|which
init|=
name|translate_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|INDEX_ELT
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|the_indices
index|[
name|which
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Please release me, let me go... */
end_comment

begin_macro
name|free_index
argument_list|(
argument|index
argument_list|)
end_macro

begin_decl_stmt
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|INDEX_ELT
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|index
operator|)
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|node
argument_list|)
expr_stmt|;
name|index
operator|=
name|index
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Flush an index by name. */
end_comment

begin_macro
name|undefindex
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|which
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
operator|(
name|which
operator|)
return|;
name|i
operator|=
name|name_index_alist
index|[
name|which
index|]
operator|->
name|index
expr_stmt|;
name|free_index
argument_list|(
name|the_indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|i
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|which
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Define an index known as NAME.  We assign the slot number.    CODE if non-zero says to make this a code index. */
end_comment

begin_macro
name|defindex
argument_list|(
argument|name
argument_list|,
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
comment|/* If it already exists, flush it. */
name|undefindex
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Try to find an empty slot. */
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|name_index_alist
index|[
name|i
index|]
condition|)
block|{
name|slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
comment|/* No such luck.  Make space for another index. */
name|slot
operator|=
name|defined_indices
expr_stmt|;
name|defined_indices
operator|++
expr_stmt|;
name|name_index_alist
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|name_index_alist
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_indices
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We have a slot.  Start assigning. */
name|name_index_alist
index|[
name|slot
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|index
operator|=
name|slot
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|the_indices
index|[
name|slot
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add the arguments to the current index command to the index NAME. */
end_comment

begin_macro
name|index_add_arg
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|index_entry
decl_stmt|;
name|INDEX_ALIST
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|find_index
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|which
operator|=
name|tem
condition|?
name|tem
operator|->
name|index
else|:
operator|-
literal|1
expr_stmt|;
comment|/* close_paragraph (); */
name|get_rest_of_line
argument_list|(
operator|&
name|index_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index reference `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INDEX_ELT
modifier|*
name|new
init|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|the_indices
index|[
name|which
index|]
expr_stmt|;
name|new
operator|->
name|entry
operator|=
name|index_entry
expr_stmt|;
name|new
operator|->
name|node
operator|=
name|current_node
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|tem
operator|->
name|code
expr_stmt|;
name|the_indices
index|[
name|which
index|]
operator|=
name|new
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|INDEX_COMMAND_SUFFIX
value|"index"
end_define

begin_comment
comment|/* The function which user defined index commands call. */
end_comment

begin_macro
name|gen_index
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|name
init|=
name|savestring
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|strlen
argument_list|(
literal|"index"
argument_list|)
condition|)
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|"index"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|index_add_arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Define a new index command.  Arg is name of index. */
end_comment

begin_macro
name|cm_defindex
argument_list|()
end_macro

begin_block
block|{
name|gen_defindex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_defcodeindex
argument_list|()
end_macro

begin_block
block|{
name|gen_defindex
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gen_defindex
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_index
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Index `%s' already exists"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"index"
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sindex"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|define_user_command
argument_list|(
name|temp
argument_list|,
name|gen_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Append LIST2 to LIST1.  Return the head of the list. */
end_comment

begin_function
name|INDEX_ELT
modifier|*
name|index_append
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|INDEX_ELT
modifier|*
name|head
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|INDEX_ELT
modifier|*
name|t_head
init|=
name|head
decl_stmt|;
if|if
condition|(
operator|!
name|t_head
condition|)
return|return
operator|(
name|tail
operator|)
return|;
while|while
condition|(
name|t_head
operator|->
name|next
condition|)
name|t_head
operator|=
name|t_head
operator|->
name|next
expr_stmt|;
name|t_head
operator|->
name|next
operator|=
name|tail
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Expects 2 args, on the same line.  Both are index abbreviations.    Make the first one be a synonym for the second one, i.e. make the    first one have the same index as the second one. */
end_comment

begin_macro
name|cm_synindex
argument_list|()
end_macro

begin_block
block|{
name|int
name|redirector
decl_stmt|,
name|redirectee
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|" "
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|redirectee
operator|=
name|find_index_offset
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|" "
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|redirector
operator|=
name|find_index_offset
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirector
operator|<
literal|0
operator|||
name|redirectee
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index reference"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I think that we should let the user make indices synonymous to          each other without any lossage of info.  This means that one can          say @synindex cp dt anywhere in the file, and things that used to          be in cp will go into dt. */
name|INDEX_ELT
modifier|*
name|i1
init|=
name|the_indices
index|[
name|redirectee
index|]
decl_stmt|,
modifier|*
name|i2
init|=
name|the_indices
index|[
name|redirector
index|]
decl_stmt|;
if|if
condition|(
name|i1
operator|||
name|i2
condition|)
block|{
if|if
condition|(
name|i1
condition|)
name|the_indices
index|[
name|redirectee
index|]
operator|=
name|index_append
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|)
expr_stmt|;
else|else
name|the_indices
index|[
name|redirectee
index|]
operator|=
name|index_append
argument_list|(
name|i2
argument_list|,
name|i1
argument_list|)
expr_stmt|;
block|}
name|name_index_alist
index|[
name|redirectee
index|]
operator|->
name|index
operator|=
name|name_index_alist
index|[
name|redirector
index|]
operator|->
name|index
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cm_pindex
argument_list|()
end_macro

begin_comment
comment|/* Pinhead index. */
end_comment

begin_block
block|{
name|index_add_arg
argument_list|(
literal|"pg"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_vindex
argument_list|()
end_macro

begin_comment
comment|/* variable index */
end_comment

begin_block
block|{
name|index_add_arg
argument_list|(
literal|"vr"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_kindex
argument_list|()
end_macro

begin_comment
comment|/* key index */
end_comment

begin_block
block|{
name|index_add_arg
argument_list|(
literal|"ky"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_cindex
argument_list|()
end_macro

begin_comment
comment|/* concept index */
end_comment

begin_block
block|{
name|index_add_arg
argument_list|(
literal|"cp"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_findex
argument_list|()
end_macro

begin_comment
comment|/* function index */
end_comment

begin_block
block|{
name|index_add_arg
argument_list|(
literal|"fn"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_tindex
argument_list|()
end_macro

begin_comment
comment|/* data type index */
end_comment

begin_block
block|{
name|index_add_arg
argument_list|(
literal|"tp"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Sorting the index. */
end_comment

begin_macro
name|index_element_compare
argument_list|(
argument|element1
argument_list|,
argument|element2
argument_list|)
end_macro

begin_decl_stmt
name|INDEX_ELT
modifier|*
modifier|*
name|element1
decl_stmt|,
modifier|*
modifier|*
name|element2
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* This needs to ignore leading non-text characters. */
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|*
name|element1
operator|)
operator|->
name|entry
argument_list|,
operator|(
operator|*
name|element2
operator|)
operator|->
name|entry
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Sort the index passed in INDEX, returning an array of    pointers to elements.  The array is terminated with a NULL    pointer.  We call qsort because it's supposed to be fast.    I think this looks bad. */
end_comment

begin_function
name|INDEX_ELT
modifier|*
modifier|*
name|sort_index
parameter_list|(
name|index
parameter_list|)
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
block|{
name|INDEX_ELT
modifier|*
name|temp
init|=
name|index
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|temp
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
comment|/* We have the length.  Make an array. */
name|array
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|array
index|[
name|count
operator|++
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|array
index|[
name|count
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* terminate the array. */
comment|/* Sort the array. */
name|qsort
argument_list|(
name|array
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|,
name|index_element_compare
argument_list|)
expr_stmt|;
return|return
operator|(
name|array
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Non-zero means that we are in the middle of printing an index. */
end_comment

begin_decl_stmt
name|int
name|printing_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Takes one arg, a short name of an index to print.    Outputs a menu of the sorted elements of the index. */
end_comment

begin_macro
name|cm_printindex
argument_list|()
end_macro

begin_block
block|{
name|int
name|item
decl_stmt|;
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|char
modifier|*
name|index_name
decl_stmt|;
name|int
name|old_inhibitions
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|boolean
name|previous_filling_enabled_value
init|=
name|filling_enabled
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|index_name
argument_list|)
expr_stmt|;
name|index
operator|=
name|index_list
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|index
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index name `%s'"
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
name|array
operator|=
name|sort_index
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|false
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|add_word
argument_list|(
literal|"* Menu:\n\n"
argument_list|)
expr_stmt|;
name|printing_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|item
operator|=
literal|0
init|;
operator|(
name|index
operator|=
name|array
index|[
name|item
index|]
operator|)
condition|;
name|item
operator|++
control|)
block|{
comment|/* If this particular entry should be printed as a "code" index, 	 then wrap the entry with "@code{...}". */
if|if
condition|(
name|index
operator|->
name|code
condition|)
name|execute_string
argument_list|(
literal|"* @code{%s}: %s.\n"
argument_list|,
name|index
operator|->
name|entry
argument_list|,
name|index
operator|->
name|node
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"* %s: %s.\n"
argument_list|,
name|index
operator|->
name|entry
argument_list|,
name|index
operator|->
name|node
argument_list|)
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
block|}
name|printing_index
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|previous_filling_enabled_value
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|old_inhibitions
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		    Making User Defined Commands		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_macro
name|define_user_command
argument_list|(
argument|name
argument_list|,
argument|proc
argument_list|,
argument|needs_braces_p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|needs_braces_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|slot
init|=
name|user_command_array_len
decl_stmt|;
name|user_command_array_len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|user_command_array
condition|)
name|user_command_array
operator|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
operator|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|user_command_array
argument_list|,
operator|(
literal|1
operator|+
name|user_command_array_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|argument_in_braces
operator|=
name|needs_braces_p
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make ALIAS run the named FUNCTION.  Copies properties from FUNCTION. */
end_comment

begin_macro
name|define_alias
argument_list|(
argument|alias
argument_list|,
argument|function
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|alias
decl_stmt|,
modifier|*
name|function
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Some support for footnotes. */
end_comment

begin_comment
comment|/* Footnotes are a new construct in Info.  We don't know the best method    of implementing them for sure, so we present two possiblities.  MN   1) Make them look like followed references, with the reference         destinations in a makeinfo manufactured node or,  BN   2) Make them appear at the bottom of the node that they originally         appeared in. */
end_comment

begin_define
define|#
directive|define
name|MN
value|0
end_define

begin_define
define|#
directive|define
name|BN
value|1
end_define

begin_decl_stmt
name|int
name|footnote_style
init|=
name|MN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|first_footnote_this_node
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|footnote_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the footnote style based on he style identifier in STRING. */
end_comment

begin_macro
name|set_footnote_style
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"MN"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|footnote_style
operator|=
name|MN
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"BN"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|footnote_style
operator|=
name|BN
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_typedef
typedef|typedef
struct|struct
name|fn
block|{
name|struct
name|fn
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|marker
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
block|}
name|FN
typedef|;
end_typedef

begin_decl_stmt
name|FN
modifier|*
name|pending_notes
init|=
operator|(
name|FN
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A method for remembering footnotes.  Note that this list gets output    at the end of the current node. */
end_comment

begin_macro
name|remember_note
argument_list|(
argument|marker
argument_list|,
argument|note
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|marker
decl_stmt|,
modifier|*
name|note
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FN
modifier|*
name|temp
init|=
operator|(
name|FN
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FN
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|marker
operator|=
name|savestring
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|temp
operator|->
name|note
operator|=
name|savestring
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|pending_notes
expr_stmt|;
name|pending_notes
operator|=
name|temp
expr_stmt|;
name|footnote_count
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* How to get rid of existing footnotes. */
end_comment

begin_macro
name|free_pending_notes
argument_list|()
end_macro

begin_block
block|{
name|FN
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|pending_notes
operator|)
operator|!=
operator|(
name|FN
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|note
argument_list|)
expr_stmt|;
name|pending_notes
operator|=
name|pending_notes
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|first_footnote_this_node
operator|=
name|true
expr_stmt|;
name|footnote_count
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What to do when you see a @footnote construct. */
end_comment

begin_comment
comment|/* Handle a "footnote".     footnote *{this is a footnote}     where "*" is the marker character for this note. */
end_comment

begin_macro
name|cm_footnote
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|marker
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
name|get_until
argument_list|(
literal|"{"
argument_list|,
operator|&
name|marker
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* Read the argument in braces. */
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|'{'
condition|)
block|{
name|line_error
argument_list|(
literal|"`@%s' expected more than just `%s'.  It needs something in `{...}'"
argument_list|,
name|command
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|braces
init|=
literal|1
decl_stmt|;
name|int
name|temp
init|=
operator|++
name|input_text_offset
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
name|braces
condition|)
block|{
if|if
condition|(
name|temp
operator|==
name|size_of_input_text
condition|)
block|{
name|line_error
argument_list|(
literal|"No closing brace for footnote `%s'"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'{'
condition|)
name|braces
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'}'
condition|)
name|braces
operator|--
expr_stmt|;
name|temp
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|temp
operator|-
name|input_text_offset
operator|)
operator|-
literal|1
expr_stmt|;
name|note
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|note
argument_list|,
operator|&
name|input_text
index|[
name|input_text_offset
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|note
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_text_offset
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_node
operator|||
operator|!
operator|*
name|current_node
condition|)
block|{
name|line_error
argument_list|(
literal|"Footnote defined without parent node"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return;
block|}
name|remember_note
argument_list|(
name|marker
argument_list|,
name|note
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|footnote_style
condition|)
block|{
comment|/* your method should at least insert marker. */
case|case
name|MN
case|:
name|add_word_args
argument_list|(
literal|"(%s)"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_footnote_this_node
condition|)
block|{
name|char
modifier|*
name|temp_string
init|=
name|xmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|current_node
argument_list|)
operator|)
operator|+
operator|(
name|strlen
argument_list|(
literal|"-Footnotes"
argument_list|)
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|add_word_args
argument_list|(
literal|" (*note %s-Footnotes::)"
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_string
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_string
argument_list|,
literal|"-Footnotes"
argument_list|)
expr_stmt|;
name|remember_node_reference
argument_list|(
name|temp_string
argument_list|,
name|line_number
argument_list|,
name|followed_reference
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|first_footnote_this_node
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
name|BN
case|:
name|add_word_args
argument_list|(
literal|"(%s)"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Non-zero means that we are currently in the process of outputting    footnotes. */
end_comment

begin_decl_stmt
name|int
name|already_outputting_pending_notes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output the footnotes.  We are at the end of the current node. */
end_comment

begin_macro
name|output_pending_notes
argument_list|()
end_macro

begin_block
block|{
name|FN
modifier|*
name|footnote
init|=
name|pending_notes
decl_stmt|;
if|if
condition|(
operator|!
name|pending_notes
condition|)
return|return;
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|MN
case|:
block|{
name|char
modifier|*
name|old_current_node
init|=
name|current_node
decl_stmt|;
name|char
modifier|*
name|old_command
init|=
name|savestring
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|already_outputting_pending_notes
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"@node %s-Footnotes,,,%s\n"
argument_list|,
name|current_node
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|already_outputting_pending_notes
operator|--
expr_stmt|;
name|current_node
operator|=
name|old_current_node
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|old_command
expr_stmt|;
block|}
break|break;
case|case
name|BN
case|:
name|close_paragraph
argument_list|()
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"---------- Footnotes ----------\n\n"
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
break|break;
block|}
comment|/* Handle the footnotes in reverse order. */
block|{
name|FN
modifier|*
modifier|*
name|array
init|=
operator|(
name|FN
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|footnote_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FN
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|array
index|[
name|footnote_count
index|]
operator|=
operator|(
name|FN
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
operator|--
name|footnote_count
operator|>
operator|-
literal|1
condition|)
block|{
name|array
index|[
name|footnote_count
index|]
operator|=
name|footnote
expr_stmt|;
name|footnote
operator|=
name|footnote
operator|->
name|next
expr_stmt|;
block|}
name|filling_enabled
operator|=
name|true
expr_stmt|;
name|indented_fill
operator|=
name|true
expr_stmt|;
while|while
condition|(
name|footnote
operator|=
name|array
index|[
operator|++
name|footnote_count
index|]
condition|)
block|{
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|MN
case|:
case|case
name|BN
case|:
name|execute_string
argument_list|(
literal|"(%s)  %s"
argument_list|,
name|footnote
operator|->
name|marker
argument_list|,
name|footnote
operator|->
name|note
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Local variables:  * compile-command: "gcc -g -Bstatic -o makeinfo makeinfo.c getopt.c"  * end:  */
end_comment

end_unit

