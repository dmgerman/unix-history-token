begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Merge parameters into a termcap entry string.    Copyright (C) 1985, 1987 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/* config.h may rename various library functions such as malloc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Assuming STRING is the value of a termcap string entry    containing `%' constructs to expand parameters,    merge in parameter values and store result in block OUTSTRING points to.    LEN is the length of OUTSTRING.  If more space is needed,    a block is allocated with `malloc'.     The value returned is the address of the resulting string.    This may be OUTSTRING or may be the address of a block got with `malloc'.    In the latter case, the caller must free the block.     The fourth and following args to tparam serve as the parameter values.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|tparam1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* VARARGS 2 */
end_comment

begin_function
name|char
modifier|*
name|tparam
parameter_list|(
name|string
parameter_list|,
name|outstring
parameter_list|,
name|len
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|outstring
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|int
name|arg
index|[
literal|4
index|]
decl_stmt|;
name|arg
index|[
literal|0
index|]
operator|=
name|arg0
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
name|arg1
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|arg3
expr_stmt|;
return|return
name|tparam1
argument_list|(
name|string
argument_list|,
name|outstring
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|arg
argument_list|)
return|;
else|#
directive|else
return|return
name|tparam1
argument_list|(
name|string
argument_list|,
name|outstring
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|arg0
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tgoto_buf
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|tgoto
parameter_list|(
name|cm
parameter_list|,
name|hpos
parameter_list|,
name|vpos
parameter_list|)
name|char
modifier|*
name|cm
decl_stmt|;
name|int
name|hpos
decl_stmt|,
name|vpos
decl_stmt|;
block|{
name|int
name|args
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cm
condition|)
return|return
literal|0
return|;
name|args
index|[
literal|0
index|]
operator|=
name|vpos
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|hpos
expr_stmt|;
return|return
name|tparam1
argument_list|(
name|cm
argument_list|,
name|tgoto_buf
argument_list|,
literal|50
argument_list|,
name|UP
argument_list|,
name|BC
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tparam1
parameter_list|(
name|string
parameter_list|,
name|outstring
parameter_list|,
name|len
parameter_list|,
name|up
parameter_list|,
name|left
parameter_list|,
name|argp
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|outstring
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|up
decl_stmt|,
decl|*
name|left
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|op
init|=
name|outstring
decl_stmt|;
name|char
modifier|*
name|outend
decl_stmt|;
name|int
name|outlen
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|;
name|int
modifier|*
name|oargp
init|=
name|argp
decl_stmt|;
name|int
name|doleft
init|=
literal|0
decl_stmt|;
name|int
name|doup
init|=
literal|0
decl_stmt|;
name|outend
operator|=
name|outstring
operator|+
name|len
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If the buffer might be too short, make it bigger.  */
if|if
condition|(
name|op
operator|+
literal|5
operator|>=
name|outend
condition|)
block|{
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|outlen
operator|==
literal|0
condition|)
block|{
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|outlen
operator|=
literal|40
operator|+
name|len
argument_list|)
expr_stmt|;
name|outend
operator|+=
literal|40
expr_stmt|;
name|bcopy
argument_list|(
name|outstring
argument_list|,
name|new
argument_list|,
name|op
operator|-
name|outstring
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outend
operator|+=
name|outlen
expr_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|outstring
argument_list|,
name|outlen
operator|*=
literal|2
argument_list|)
expr_stmt|;
block|}
name|op
operator|+=
name|new
operator|-
name|outstring
expr_stmt|;
name|outend
operator|+=
name|new
operator|-
name|outstring
expr_stmt|;
name|outstring
operator|=
name|new
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|tem
operator|=
operator|*
name|argp
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* %d means output in decimal */
if|if
condition|(
name|tem
operator|<
literal|10
condition|)
goto|goto
name|onedigit
goto|;
if|if
condition|(
name|tem
operator|<
literal|100
condition|)
goto|goto
name|twodigit
goto|;
case|case
literal|'3'
case|:
comment|/* %3 means output in decimal, 3 digits. */
if|if
condition|(
name|tem
operator|>
literal|999
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|tem
operator|/
literal|1000
operator|+
literal|'0'
expr_stmt|;
name|tem
operator|%=
literal|1000
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
name|tem
operator|/
literal|100
operator|+
literal|'0'
expr_stmt|;
case|case
literal|'2'
case|:
comment|/* %2 means output in decimal, 2 digits. */
name|twodigit
label|:
name|tem
operator|%=
literal|100
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|tem
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|onedigit
label|:
operator|*
name|op
operator|++
operator|=
name|tem
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|argp
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* For c-100: print quotient of value by 96, if nonzero, 		 then do like %+ */
if|if
condition|(
name|tem
operator|>=
literal|96
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|tem
operator|/
literal|96
expr_stmt|;
name|tem
operator|%=
literal|96
expr_stmt|;
block|}
case|case
literal|'+'
case|:
comment|/* %+x means add character code of char x */
name|tem
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
case|case
literal|'.'
case|:
comment|/* %. means output as character */
if|if
condition|(
name|left
condition|)
block|{
comment|/* If want to forbid output of 0 and \n and \t, 		     and this is one of them, increment it.  */
while|while
condition|(
name|tem
operator|==
literal|0
operator|||
name|tem
operator|==
literal|'\n'
operator|||
name|tem
operator|==
literal|'\t'
condition|)
block|{
name|tem
operator|++
expr_stmt|;
if|if
condition|(
name|argp
operator|==
name|oargp
condition|)
name|doup
operator|++
operator|,
name|outend
operator|-=
name|strlen
argument_list|(
name|up
argument_list|)
expr_stmt|;
else|else
name|doleft
operator|++
operator|,
name|outend
operator|-=
name|strlen
argument_list|(
name|left
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|op
operator|++
operator|=
name|tem
operator||
literal|0200
expr_stmt|;
case|case
literal|'f'
case|:
comment|/* %f means discard next arg */
name|argp
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* %b means back up one arg (and re-use it) */
name|argp
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* %r means interchange following two args */
name|argp
index|[
literal|0
index|]
operator|=
name|argp
index|[
literal|1
index|]
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|=
name|tem
expr_stmt|;
name|oargp
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
comment|/* %>xy means if arg is> char code of x, */
if|if
condition|(
name|argp
index|[
literal|0
index|]
operator|>
operator|*
name|p
operator|++
condition|)
comment|/* then add char code of y to the arg, */
name|argp
index|[
literal|0
index|]
operator|+=
operator|*
name|p
expr_stmt|;
comment|/* and in any case don't output. */
name|p
operator|++
expr_stmt|;
comment|/* Leave the arg to be output later. */
break|break;
case|case
literal|'a'
case|:
comment|/* %a means arithmetic */
comment|/* Next character says what operation. 		 Add or subtract either a constant or some other arg */
comment|/* First following character is + to add or - to subtract 		 or = to assign.  */
comment|/* Next following char is 'p' and an arg spec 		 (0100 plus position of that arg relative to this one) 		 or 'c' and a constant stored in a character */
name|tem
operator|=
name|p
index|[
literal|2
index|]
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
name|tem
operator|=
name|argp
index|[
name|tem
operator|-
literal|0100
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|argp
index|[
literal|0
index|]
operator|-=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|argp
index|[
literal|0
index|]
operator|+=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|argp
index|[
literal|0
index|]
operator|*=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|argp
index|[
literal|0
index|]
operator|/=
name|tem
expr_stmt|;
else|else
name|argp
index|[
literal|0
index|]
operator|=
name|tem
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* %i means add one to arg, */
name|argp
index|[
literal|0
index|]
operator|++
expr_stmt|;
comment|/* and leave it to be output later. */
name|argp
index|[
literal|1
index|]
operator|++
expr_stmt|;
comment|/* Increment the following arg, too!  */
break|break;
case|case
literal|'%'
case|:
comment|/* %% means output %; no arg. */
goto|goto
name|ordinary
goto|;
case|case
literal|'n'
case|:
comment|/* %n means xor each of next two args with 140 */
name|argp
index|[
literal|0
index|]
operator|^=
literal|0140
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|^=
literal|0140
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* %m means xor each of next two args with 177 */
name|argp
index|[
literal|0
index|]
operator|^=
literal|0177
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|^=
literal|0177
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* %B means express arg as BCD char code. */
name|argp
index|[
literal|0
index|]
operator|+=
literal|6
operator|*
operator|(
name|tem
operator|/
literal|10
operator|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* %D means weird Delta Data transformation */
name|argp
index|[
literal|0
index|]
operator|-=
literal|2
operator|*
operator|(
name|tem
operator|%
literal|16
operator|)
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* Ordinary character in the argument string.  */
name|ordinary
label|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|op
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|doup
operator|--
operator|>
literal|0
condition|)
name|strcat
argument_list|(
name|op
argument_list|,
name|up
argument_list|)
expr_stmt|;
while|while
condition|(
name|doleft
operator|--
operator|>
literal|0
condition|)
name|strcat
argument_list|(
name|op
argument_list|,
name|left
argument_list|)
expr_stmt|;
return|return
name|outstring
return|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|args
index|[
literal|3
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|tparam1
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
literal|"LEFT"
argument_list|,
literal|"UP"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

