begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* X Communication module for terminals which understand the X protocol.    Copyright (C) 1985, 1986, 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Yakim Martillo, mods and things by Robert Krawitz  */
end_comment

begin_comment
comment|/*  *	$Source: /u2/third_party/gnuemacs.chow/src/RCS/xterm.c,v $  *	$Author: rlk $  *	$Locker:  $  *	$Header: xterm.c,v 1.28 86/08/27 13:30:57 rlk Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_TrmXTERM_c
init|=
literal|"$Header: xterm.c,v 1.28 86/08/27 13:30:57 rlk Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* On 4.3 this loses if it comes after xterm.h.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* This may include sys/types.h, and that somehow loses    if this is not done before the other system files.  */
end_comment

begin_include
include|#
directive|include
file|"xterm.h"
end_include

begin_comment
comment|/* Load sys/types.h if not already loaded.    In some systems loading it twice is suicidal.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|makedev
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|IBMRTAIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG and not IBMRTAIX */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"sink.h"
end_include

begin_include
include|#
directive|include
file|"sinkmask.h"
end_include

begin_include
include|#
directive|include
file|<X/Xkeyboard.h>
end_include

begin_comment
comment|/*#include<X/Xproto.h>	*/
end_comment

begin_comment
comment|/* Allow config to specify default font.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|X_DEFAULT_FONT
end_ifndef

begin_define
define|#
directive|define
name|X_DEFAULT_FONT
value|"vtsingle"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|sigunblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (0)
end_define

begin_define
define|#
directive|define
name|sigblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (1<< ((sig) - 1))
end_define

begin_decl_stmt
name|XREPBUFFER
name|Xxrepbuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pixelwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pixelheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|PendingExposure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|PendingIconExposure
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXICID
value|80
end_define

begin_decl_stmt
name|char
name|iconidentity
index|[
name|MAXICID
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ICONTAG
value|"emacs@"
end_define

begin_define
define|#
directive|define
name|METABIT
value|0x80
end_define

begin_decl_stmt
name|Window
name|XXIconWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bitmap
name|XXIconMask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|XXcurrentfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|default_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|informflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|alternate_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXdebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_garbaged
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXxoffset
decl_stmt|,
name|XXyoffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|IconWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|WindowMapped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CurHL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flexlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last line affect by dellines or */
end_comment

begin_comment
comment|/* inslines functions */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|VisibleX
decl_stmt|,
name|VisibleY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* genuine location of cursor on screen */
end_comment

begin_comment
comment|/* if it is there */
end_comment

begin_decl_stmt
specifier|static
name|int
name|SavedX
decl_stmt|,
name|SavedY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where the cursor was before update */
end_comment

begin_comment
comment|/* started */
end_comment

begin_decl_stmt
name|int
name|bitblt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to track bit blt events */
end_comment

begin_decl_stmt
name|int
name|CursorExists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* during updates cursor is turned off */
end_comment

begin_decl_stmt
specifier|static
name|int
name|InUpdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* many of functions here may be invoked */
end_comment

begin_comment
comment|/* even if no update in progress, when */
end_comment

begin_comment
comment|/* no update is in progress the action */
end_comment

begin_comment
comment|/* can be slightly different */
end_comment

begin_decl_stmt
name|short
name|MouseCursor
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0008
block|,
literal|0x0018
block|,
literal|0x0038
block|,
literal|0x0078
block|,
literal|0x00f8
block|,
literal|0x01f8
block|,
literal|0x03f8
block|,
literal|0x07f8
block|,
literal|0x00f8
block|,
literal|0x00d8
block|,
literal|0x0188
block|,
literal|0x0180
block|,
literal|0x0300
block|,
literal|0x0300
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|MouseMask
index|[]
init|=
block|{
literal|0x000c
block|,
literal|0x001c
block|,
literal|0x003c
block|,
literal|0x007c
block|,
literal|0x00fc
block|,
literal|0x01fc
block|,
literal|0x03fc
block|,
literal|0x07fc
block|,
literal|0x0ffc
block|,
literal|0x0ffc
block|,
literal|0x01fc
block|,
literal|0x03dc
block|,
literal|0x03cc
block|,
literal|0x0780
block|,
literal|0x0780
block|,
literal|0x0300
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Display
modifier|*
name|XXdisplay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FontInfo
modifier|*
name|fontinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
name|XXwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cursor
name|EmacsCursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fore_color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables to store colors */
end_comment

begin_decl_stmt
name|char
modifier|*
name|back_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|brdr_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|curs_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mous_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|back
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|curs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mous
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WindowInfo
name|windowinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WindowInfo
name|rootwindowinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XKeyPressedEvent
name|XXEvent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* as X messages are read in they are */
end_comment

begin_comment
comment|/* stored here */
end_comment

begin_decl_stmt
specifier|static
name|XREPBUFFER
name|XXqueue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for storing up ExposeRegion */
end_comment

begin_comment
comment|/* replies, so that the SIGIO inter- */
end_comment

begin_comment
comment|/* rupt serving routines do almost */
end_comment

begin_comment
comment|/* no writes to the X socket */
end_comment

begin_comment
comment|/*int CurHL;			/* Current Highlighting actually being */
end_comment

begin_comment
comment|/* being used for bold font right now*/
end_comment

begin_decl_stmt
name|int
name|XXborder
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXInternalBorder
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Display
modifier|*
name|XOpenDisplay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Window
name|XCreateWindow
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Cursor
name|XDefineCursor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Cursor
name|XCreateCursor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FontInfo
modifier|*
name|XOpenFont
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flashback
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* HLmode -- Changes the GX function for output strings.  Could be used to  * change font.  Check an XText library function call.   */
end_comment

begin_expr_stmt
specifier|static
name|HLmode
argument_list|(
argument|new
argument_list|)
name|int
name|new
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CurHL
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_comment
comment|/* External interface to control of standout mode.    Call this when about to modify line at position VPOS    and not change whether it is highlighted.  */
end_comment

begin_macro
name|XTreassert_line_highlight
argument_list|(
argument|highlight
argument_list|,
argument|vpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|highlight
decl_stmt|,
name|vpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HLmode
argument_list|(
name|highlight
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Call this when about to modify line at position VPOS    and change whether it is highlighted.  */
end_comment

begin_expr_stmt
specifier|static
name|XTchange_line_highlight
argument_list|(
argument|new_highlight
argument_list|,
argument|vpos
argument_list|,
argument|first_unused_hpos
argument_list|)
name|int
name|new_highlight
operator|,
name|vpos
operator|,
name|first_unused_hpos
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|HLmode
argument_list|(
name|new_highlight
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x_clear_end_of_line
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Used for starting or restarting (after suspension) the X window.  Puts the  * cursor in a known place, update does not begin with this routine but only  * with a call to redisplay.  The mouse cursor is warped into the window and  * then the cursor is turned on.  */
end_comment

begin_expr_stmt
specifier|static
name|XTset_terminal_modes
argument_list|()
block|{
name|int
name|stuffpending
block|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTset_terminal_modes\n"
argument_list|)
block|;
endif|#
directive|endif
name|InUpdate
operator|=
literal|0
block|;
name|stuffpending
operator|=
literal|0
block|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|VisibleX
operator|=
literal|0
expr_stmt|;
name|VisibleY
operator|=
literal|0
expr_stmt|;
block|}
name|XTclear_screen
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FIONREAD
end_ifdef

begin_expr_stmt
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|stuffpending
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|stuffpending
condition|)
name|SIGNAL_INPUT
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/* XTmove_cursor moves the cursor to the correct location and checks whether an update  * is in progress in order to toggle it on.  */
end_comment

begin_expr_stmt
unit|static
name|XTmove_cursor
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
specifier|register
name|int
name|row
operator|,
name|col
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTmove_cursor\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cursor_hpos
operator|=
name|col
expr_stmt|;
name|cursor_vpos
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|InUpdate
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
comment|/* Generally, XTmove_cursor will be invoked */
comment|/* when InUpdate with !CursorExists */
comment|/* so that wasteful XFlush is not called */
block|}
if|if
condition|(
operator|(
name|row
operator|==
name|VisibleY
operator|)
operator|&&
operator|(
name|col
operator|==
name|VisibleX
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|CursorExists
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|VisibleX
operator|=
name|col
expr_stmt|;
name|VisibleY
operator|=
name|row
expr_stmt|;
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Used to get the terminal back to a known state after resets.  Usually  * used when restarting suspended or waiting emacs  */
end_comment

begin_expr_stmt
specifier|static
name|cleanup
argument_list|()
block|{
name|inverse_video
operator|=
literal|0
block|;
name|HLmode
argument_list|(
literal|0
argument_list|)
block|; }
comment|/* Erase current line from column cursor_hpos to column END.    Leave cursor at END.  */
specifier|static
name|XTclear_end_of_line
argument_list|(
name|end
argument_list|)
specifier|register
name|int
name|end
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|numcols
decl_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTclear_end_of_line\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cursor_vpos
operator|<
literal|0
operator|||
name|cursor_vpos
operator|>=
name|screen_height
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|end
operator|>=
name|screen_width
condition|)
name|end
operator|=
name|screen_width
expr_stmt|;
if|if
condition|(
name|end
operator|<=
name|cursor_hpos
condition|)
return|return;
name|numcols
operator|=
name|end
operator|-
name|cursor_hpos
expr_stmt|;
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|cursor_vpos
operator|==
name|VisibleY
operator|&&
name|VisibleX
operator|>=
name|cursor_hpos
operator|&&
name|VisibleX
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|cursor_hpos
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
argument_list|,
name|cursor_vpos
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|fontinfo
operator|->
name|width
operator|*
name|numcols
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|cursor_vpos
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Erase current line from column START to right margin.    Leave cursor at START.  */
end_comment

begin_expr_stmt
specifier|static
name|x_clear_end_of_line
argument_list|(
name|start
argument_list|)
specifier|register
name|int
name|start
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|numcols
decl_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"x_clear_end_of_line\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cursor_vpos
operator|<
literal|0
operator|||
name|cursor_vpos
operator|>=
name|screen_height
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|screen_width
condition|)
return|return;
name|numcols
operator|=
name|screen_width
operator|-
name|start
expr_stmt|;
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|cursor_vpos
operator|==
name|VisibleY
operator|&&
name|VisibleX
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|start
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
argument_list|,
name|cursor_vpos
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|fontinfo
operator|->
name|width
operator|*
name|numcols
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|cursor_vpos
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|XTreset_terminal_modes
argument_list|()
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTreset_terminal_modes\n"
argument_list|)
block|;
endif|#
directive|endif
name|XTclear_screen
argument_list|()
block|; }
specifier|static
name|XTclear_screen
argument_list|()
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTclear_screen\n"
argument_list|)
block|;
endif|#
directive|endif
name|HLmode
argument_list|(
literal|0
argument_list|)
block|;
name|CursorExists
operator|=
literal|0
block|;
name|cursor_hpos
operator|=
literal|0
block|;
name|cursor_vpos
operator|=
literal|0
block|;
name|SavedX
operator|=
literal|0
block|;
name|SavedY
operator|=
literal|0
block|;
name|VisibleX
operator|=
literal|0
block|;
name|VisibleY
operator|=
literal|0
block|;
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
block|;
name|XClear
argument_list|(
name|XXwindow
argument_list|)
block|;
name|CursorToggle
argument_list|()
block|;
if|if
condition|(
operator|!
name|InUpdate
condition|)
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
block|;   }
end_expr_stmt

begin_comment
unit|}
comment|/* used by dumprectangle which is usually invoked upon ExposeRegion  * events which come from bit blt's or moving an obscuring opaque window  */
end_comment

begin_expr_stmt
unit|static
name|dumpchars
argument_list|(
name|current_screen
argument_list|,
name|numcols
argument_list|,
name|tempX
argument_list|,
name|tempY
argument_list|,
name|tempHL
argument_list|)
specifier|register
expr|struct
name|matrix
operator|*
name|current_screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|numcols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|tempX
decl_stmt|,
name|tempY
decl_stmt|,
name|tempHL
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|numcols
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
operator|(
name|numcols
operator|-
literal|1
operator|)
operator|+
name|tempX
operator|)
operator|>
name|screen_width
condition|)
block|{
name|numcols
operator|=
operator|(
name|screen_width
operator|-
name|tempX
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tempX
operator|<
literal|0
operator|)
operator|||
operator|(
name|tempX
operator|>=
name|screen_width
operator|)
operator|||
operator|(
name|tempY
operator|<
literal|0
operator|)
operator|||
operator|(
name|tempY
operator|>=
name|screen_height
operator|)
condition|)
block|{
return|return;
block|}
name|XText
argument_list|(
name|XXwindow
argument_list|,
operator|(
name|tempX
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
operator|)
argument_list|,
operator|(
name|tempY
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
operator|)
argument_list|,
operator|&
name|current_screen
operator|->
name|contents
index|[
name|tempY
index|]
index|[
name|tempX
index|]
argument_list|,
name|numcols
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
operator|(
name|tempHL
condition|?
name|back
else|:
name|fore
operator|)
argument_list|,
operator|(
name|tempHL
condition|?
name|fore
else|:
name|back
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* When a line has been changed this function is called.  X is so fast  * that the actual sequence is ignore.  Rather, the new version of the  * line is simply output if this function is invoked while in UpDate.  * Sometimes writechars can be invoked when not in update if text is to  * be output at the end of the line.  In this case the whole line is not  * output.  Simply the new text at the current cursor position given  * by VisibleX,Y.  The cursor is moved to the end of the new text.  */
end_comment

begin_expr_stmt
specifier|static
name|writechars
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
specifier|register
name|char
operator|*
name|start
operator|,
operator|*
name|end
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|temp_length
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cursor_vpos
operator|<
literal|0
operator|)
operator|||
operator|(
name|cursor_vpos
operator|>=
name|screen_height
operator|)
condition|)
block|{
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CursorExists
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|InUpdate
condition|)
block|{
if|if
condition|(
name|end
operator|!=
name|start
operator|-
literal|1
condition|)
block|{
name|XText
argument_list|(
name|XXwindow
argument_list|,
operator|(
name|cursor_hpos
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
operator|)
argument_list|,
operator|(
name|cursor_vpos
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
operator|)
argument_list|,
name|start
argument_list|,
name|end
operator|+
literal|1
operator|-
name|start
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
operator|(
name|CurHL
condition|?
name|back
else|:
name|fore
operator|)
argument_list|,
operator|(
name|CurHL
condition|?
name|fore
else|:
name|back
operator|)
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|cursor_vpos
argument_list|,
name|cursor_hpos
operator|+
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|VisibleX
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleX
operator|>=
name|screen_width
operator|)
condition|)
block|{
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|VisibleY
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleY
operator|>=
name|screen_height
operator|)
condition|)
block|{
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
name|VisibleX
operator|)
operator|>=
name|screen_width
condition|)
block|{
name|end
operator|=
name|start
operator|+
operator|(
name|screen_width
operator|-
operator|(
name|VisibleX
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|>=
name|start
condition|)
block|{
name|XText
argument_list|(
name|XXwindow
argument_list|,
operator|(
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
operator|)
argument_list|,
operator|(
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
operator|)
argument_list|,
name|start
argument_list|,
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
operator|)
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
operator|(
name|CurHL
condition|?
name|back
else|:
name|fore
operator|)
argument_list|,
operator|(
name|CurHL
condition|?
name|fore
else|:
name|back
operator|)
argument_list|)
expr_stmt|;
name|VisibleX
operator|=
name|VisibleX
operator|+
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XToutput_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|start
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XToutput_chars\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|writechars
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The following routine is for the deaf or for the pervert who prefers  * that his terminal flash at him rather than beep at him.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flashedback
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|XTflash
argument_list|()
block|{
ifdef|#
directive|ifdef
name|ITIMER_REAL
block|struct
name|itimerval
name|itimer
block|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTflash\n"
argument_list|)
block|;
endif|#
directive|endif
name|stop_polling
argument_list|()
block|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|flashback
argument_list|)
block|;
name|getitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|)
block|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|+=
literal|250000
block|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
block|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
block|;
name|flashedback
operator|=
literal|0
block|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
literal|0
argument_list|)
block|;
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
block|;
name|XPixFill
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|WhitePixel
argument_list|,
name|ClipModeClipped
argument_list|,
name|GXinvert
argument_list|,
name|AllPlanes
argument_list|)
block|;
name|XFlush
argument_list|()
block|;
name|UNBLOCK_INPUT
argument_list|()
block|;   }
while|while
condition|(
operator|!
name|flashedback
condition|)
name|pause
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* have ITIMER_REAL */
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|flashback
argument_list|()
block|{
ifdef|#
directive|ifdef
name|ITIMER_REAL
ifdef|#
directive|ifdef
name|SIGIO
name|int
name|mask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
block|;
else|#
directive|else
name|int
name|mask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
block|;
endif|#
directive|endif
name|XPixFill
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|WhitePixel
argument_list|,
name|ClipModeClipped
argument_list|,
name|GXinvert
argument_list|,
name|AllPlanes
argument_list|)
block|;
name|XFlush
argument_list|()
block|;
name|flashedback
operator|=
literal|1
block|;
name|sigsetmask
argument_list|(
name|mask
argument_list|)
block|;
name|start_polling
argument_list|()
block|;
endif|#
directive|endif
comment|/* have ITIMER_REAL */
block|}
comment|/* A kludge to get a bell */
specifier|static
name|XTfeep
argument_list|()
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
block|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTfeep\n"
argument_list|)
block|;
endif|#
directive|endif
name|XFeep
argument_list|(
literal|0
argument_list|)
block|;
name|UNBLOCK_INPUT
argument_list|()
block|; }
comment|/* Artificially creating a cursor is hard, the actual position on the  * screen (either where it is or last was) is tracked with VisibleX,Y.  * Gnu Emacs code tends to assume a cursor exists in hardward at cursor_hpos,Y  * and that output text will appear there.  During updates, the cursor is  * supposed to be blinked out and will only reappear after the update  * finishes.  */
name|CursorToggle
argument_list|()
block|{
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|VisibleX
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleX
operator|>=
name|screen_width
operator|)
operator|||
operator|(
name|VisibleY
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleY
operator|>=
name|screen_height
operator|)
condition|)
block|{
comment|/* Current Cursor position trash */
comment|/* Not much can be done */
name|XFlush
argument_list|()
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* Currently the return values are not */
comment|/* used, but I could anticipate using */
comment|/* them in the future. */
block|}
end_if

begin_if
if|if
condition|(
name|current_screen
operator|->
name|enable
index|[
name|VisibleY
index|]
operator|&&
operator|(
name|VisibleX
operator|<
name|current_screen
operator|->
name|used
index|[
name|VisibleY
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
block|{
name|XText
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
operator|&
name|current_screen
operator|->
name|contents
index|[
name|VisibleY
index|]
index|[
name|VisibleX
index|]
argument_list|,
literal|1
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
name|fore
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XText
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
operator|&
name|current_screen
operator|->
name|contents
index|[
name|VisibleY
index|]
index|[
name|VisibleX
index|]
argument_list|,
literal|1
argument_list|,
name|fontinfo
operator|->
name|id
argument_list|,
name|back
argument_list|,
name|curs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CursorExists
condition|)
block|{
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|curs
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|CursorExists
operator|=
operator|!
name|CursorExists
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Cursor has either been blinked in */
end_comment

begin_comment
comment|/* or out */
end_comment

begin_if
if|if
condition|(
operator|!
name|InUpdate
condition|)
block|{
name|XFlush
argument_list|()
expr_stmt|;
block|}
end_if

begin_return
return|return
literal|1
return|;
end_return

begin_comment
unit|}
comment|/* This routine is used by routines which are called to paint regions */
end_comment

begin_comment
comment|/* designated by ExposeRegion events.  If the cursor may be in the exposed */
end_comment

begin_comment
comment|/* region, this routine makes sure it is gone so that dumprectangle can */
end_comment

begin_comment
comment|/* toggle it back into existance if dumprectangle is invoked when not in */
end_comment

begin_comment
comment|/* the midst of a screen update. */
end_comment

begin_macro
unit|static
name|ClearCursor
argument_list|()
end_macro

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|VisibleX
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleX
operator|>=
name|screen_width
operator|)
operator|||
operator|(
name|VisibleY
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleY
operator|>=
name|screen_height
operator|)
condition|)
block|{
comment|/* Current Cursor position trash */
comment|/* Not much can be done */
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|fontinfo
operator|->
name|width
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTupdate_begin
argument_list|()
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
block|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTupdate_begin\n"
argument_list|)
block|;
endif|#
directive|endif
name|InUpdate
operator|=
literal|1
block|;
if|if
condition|(
name|CursorExists
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
name|SavedX
operator|=
name|cursor_hpos
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The initial"hardware" cursor position is */
end_comment

begin_comment
comment|/*  saved because that is where gnu emacs */
end_comment

begin_comment
comment|/*  expects the cursor to be at the end of*/
end_comment

begin_comment
comment|/* the update */
end_comment

begin_expr_stmt
name|SavedY
operator|=
name|cursor_vpos
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dumpqueue
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
unit|}   static
name|XTupdate_end
argument_list|()
end_macro

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTupdate_end\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|InUpdate
operator|=
literal|0
expr_stmt|;
name|dumpqueue
argument_list|()
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|SavedY
argument_list|,
name|SavedX
argument_list|)
expr_stmt|;
comment|/* XTmove_cursor invokes cursor toggle */
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Used for expose region and expose copy events.  Have to get the text  * back into the newly blank areas.  */
end_comment

begin_expr_stmt
name|dumprectangle
argument_list|(
name|top
argument_list|,
name|left
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|)
specifier|register
name|int
name|top
operator|,
name|left
operator|,
name|rows
operator|,
name|cols
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|localX
decl_stmt|,
name|localY
decl_stmt|,
name|localHL
decl_stmt|;
name|rows
operator|+=
name|top
expr_stmt|;
name|cols
operator|+=
name|left
expr_stmt|;
name|top
operator|/=
name|fontinfo
operator|->
name|height
expr_stmt|;
comment|/* Get row and col containing up and */
comment|/* left borders of exposed region -- */
comment|/* round down here*/
name|left
operator|/=
name|fontinfo
operator|->
name|width
expr_stmt|;
name|rows
operator|+=
operator|(
name|fontinfo
operator|->
name|height
operator|-
literal|1
operator|)
expr_stmt|;
name|cols
operator|+=
operator|(
name|fontinfo
operator|->
name|width
operator|-
literal|1
operator|)
expr_stmt|;
name|rows
operator|/=
name|fontinfo
operator|->
name|height
expr_stmt|;
comment|/* Get row and col containing bottom and */
comment|/* right borders -- round up here */
name|rows
operator|-=
name|top
expr_stmt|;
name|cols
operator|/=
name|fontinfo
operator|->
name|width
expr_stmt|;
name|cols
operator|-=
name|left
expr_stmt|;
if|if
condition|(
name|rows
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|cols
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|top
operator|>
operator|(
name|screen_height
operator|-
literal|1
operator|)
condition|)
return|return;
if|if
condition|(
name|left
operator|>
operator|(
name|screen_width
operator|-
literal|1
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|VisibleX
operator|>=
name|left
operator|)
operator|&&
operator|(
name|VisibleX
operator|<
operator|(
name|left
operator|+
name|cols
operator|)
operator|)
operator|&&
operator|(
name|VisibleY
operator|>=
name|top
operator|)
operator|&&
operator|(
name|VisibleY
operator|<
operator|(
name|top
operator|+
name|rows
operator|)
operator|)
condition|)
block|{
name|ClearCursor
argument_list|()
expr_stmt|;
block|}
comment|/* should perhaps be DesiredScreen */
comment|/* but PhysScreen is guaranteed to contain*/
comment|/* date which was good for every line on */
comment|/* screen. For desired screen only for */
comment|/* lines which are changing.  Emacs does */
comment|/* not consider a line within a newly */
comment|/* exposed region necessarily to have */
comment|/* been changed.  Emacs knows nothing */
comment|/* about ExposeRegion events.*/
for|for
control|(
name|localY
operator|=
name|top
operator|,
name|index
operator|=
literal|0
init|;
operator|(
name|index
operator|<
name|rows
operator|)
operator|&&
operator|(
name|localY
operator|<
name|screen_height
operator|)
condition|;
operator|++
name|index
operator|,
operator|++
name|localY
control|)
block|{
if|if
condition|(
operator|(
name|localY
operator|<
literal|0
operator|)
operator|||
operator|(
name|localY
operator|>=
name|screen_height
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|current_screen
operator|->
name|enable
index|[
name|localY
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|left
operator|+
literal|1
operator|)
operator|>
name|current_screen
operator|->
name|used
index|[
name|localY
index|]
condition|)
continue|continue;
name|localX
operator|=
name|left
expr_stmt|;
name|localHL
operator|=
name|current_screen
operator|->
name|highlight
index|[
name|localY
index|]
expr_stmt|;
name|dumpchars
argument_list|(
name|current_screen
argument_list|,
name|min
argument_list|(
name|cols
argument_list|,
name|current_screen
operator|->
name|used
index|[
name|localY
index|]
operator|-
name|localX
argument_list|)
argument_list|,
name|localX
argument_list|,
name|localY
argument_list|,
name|localHL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|InUpdate
operator|&&
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
comment|/* Routine usually called */
comment|/* when not in update */
block|}
end_block

begin_comment
comment|/* What sections of the window will be modified from the UpdateDisplay  * routine is totally under software control.  Any line with Y coordinate  * greater than flexlines will not change during an update.  This is really  * used only during dellines and inslines routines (scraplines and stufflines)  */
end_comment

begin_expr_stmt
specifier|static
name|XTset_terminal_window
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTset_terminal_window\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|<=
literal|0
operator|)
operator|||
operator|(
name|n
operator|>
name|screen_height
operator|)
condition|)
name|flexlines
operator|=
name|screen_height
expr_stmt|;
else|else
name|flexlines
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|XTins_del_lines
argument_list|(
argument|vpos
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vpos
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTins_del_lines\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XTmove_cursor
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|stufflines
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|scraplines
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTinsert_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|start
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTinsert_chars\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|writechars
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTdelete_chars
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|msg
init|=
literal|"***Delete Chars Called Outside of Update!!!***"
decl_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTdelete_chars\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|writechars
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|strlen
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|stufflines
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|topregion
decl_stmt|,
name|bottomregion
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|,
name|newtop
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
if|if
condition|(
name|cursor_vpos
operator|>=
name|flexlines
condition|)
return|return;
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|bitblt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|dumpqueue
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|topregion
operator|=
name|cursor_vpos
expr_stmt|;
name|bottomregion
operator|=
name|flexlines
operator|-
operator|(
name|n
operator|+
literal|1
operator|)
expr_stmt|;
name|newtop
operator|=
name|cursor_vpos
operator|+
name|n
expr_stmt|;
name|length
operator|=
operator|(
name|bottomregion
operator|-
name|topregion
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|newtop
operator|<=
name|flexlines
operator|)
condition|)
block|{
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
comment|/* Should already have cleared */
comment|/* queue of events associated */
comment|/* with old bitblts */
name|XMoveArea
argument_list|(
name|XXwindow
argument_list|,
name|XXInternalBorder
argument_list|,
name|topregion
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|XXInternalBorder
argument_list|,
name|newtop
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|length
operator|*
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|WindowMapped
condition|)
name|bitblt
operator|=
literal|1
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|SIGNAL_INPUT_WHILE
argument_list|(
name|bitblt
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
name|newtop
operator|=
name|min
argument_list|(
name|newtop
argument_list|,
operator|(
name|flexlines
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|newtop
operator|-
name|topregion
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|XXInternalBorder
argument_list|,
name|topregion
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|n
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
comment|/*  if (!InUpdate) CursorToggle (); */
block|}
end_block

begin_expr_stmt
specifier|static
name|scraplines
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|bitblt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cursor_vpos
operator|>=
name|flexlines
condition|)
return|return;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|dumpqueue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cursor_vpos
operator|+
name|n
operator|)
operator|>=
name|flexlines
condition|)
block|{
if|if
condition|(
name|flexlines
operator|>=
operator|(
name|cursor_vpos
operator|+
literal|1
operator|)
condition|)
block|{
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|XXInternalBorder
argument_list|,
name|cursor_vpos
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
operator|(
name|flexlines
operator|-
name|cursor_vpos
operator|)
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
block|}
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|XMoveArea
argument_list|(
name|XXwindow
argument_list|,
name|XXInternalBorder
argument_list|,
operator|(
name|cursor_vpos
operator|+
name|n
operator|)
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|XXInternalBorder
argument_list|,
name|cursor_vpos
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
operator|(
name|flexlines
operator|-
operator|(
name|cursor_vpos
operator|+
name|n
operator|)
operator|)
operator|*
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|WindowMapped
condition|)
name|bitblt
operator|=
literal|1
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|SIGNAL_INPUT_WHILE
argument_list|(
name|bitblt
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|XPixSet
argument_list|(
name|XXwindow
argument_list|,
name|XXInternalBorder
argument_list|,
operator|(
name|flexlines
operator|-
name|n
operator|)
operator|*
name|fontinfo
operator|->
name|height
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
argument_list|,
name|n
operator|*
name|fontinfo
operator|->
name|height
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
comment|/* if (!InUpdate) CursorToggle (); */
block|}
end_block

begin_comment
comment|/* Substitutes for standard read routine.  Under X not interested in individual  * bytes but rather individual packets.  */
end_comment

begin_expr_stmt
name|XTread_socket
argument_list|(
name|sd
argument_list|,
name|bufp
argument_list|,
name|numchars
argument_list|)
specifier|register
name|int
name|sd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|numchars
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|where_mapping
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|int
name|stuffpending
decl_stmt|;
name|int
name|temp_width
decl_stmt|,
name|temp_height
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
comment|/* XKeyPressedEvent event; */
comment|/*  typedef struct reply {XEvent event; struct reply *next} Reply;       Reply *replies = NULL;*/
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numchars
operator|<=
literal|0
condition|)
block|{
comment|/* To keep from overflowing read buffer */
name|numchars
operator|=
literal|1
expr_stmt|;
operator|--
name|bufp
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGIO
while|while
condition|(
name|bitblt
operator|||
name|XPending
argument_list|()
operator|!=
literal|0
condition|)
else|#
directive|else
ifndef|#
directive|ifndef
name|HAVE_SELECT
if|if
condition|(
operator|!
operator|(
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|&
name|O_NDELAY
operator|)
condition|)
block|{
specifier|extern
name|int
name|read_alarm_should_throw
decl_stmt|;
if|if
condition|(
name|CursorExists
condition|)
name|xfixscreen
argument_list|()
expr_stmt|;
name|read_alarm_should_throw
operator|=
literal|1
expr_stmt|;
name|XPeekEvent
argument_list|(
operator|&
name|XXEvent
argument_list|)
expr_stmt|;
name|read_alarm_should_throw
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|XPending
argument_list|()
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
comment|/* while there are more events*/
name|XNextEvent
argument_list|(
operator|&
name|XXEvent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XXEvent
operator|.
name|type
condition|)
block|{
comment|/*	case X_Reply: 	{ 	extern char *malloc (); 	Reply *reply = (Reply *) malloc (sizeof (Reply)); 	reply->next = replies; 	reply->event = XXEvent; 	replies = reply; 	break; 	}*/
default|default:
break|break;
case|case
name|ExposeWindow
case|:
if|if
condition|(
operator|(
operator|(
name|XExposeEvent
operator|*
operator|)
operator|&
name|XXEvent
operator|)
operator|->
name|window
operator|==
name|XXIconWindow
condition|)
block|{
name|PendingIconExposure
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|PendingExposure
operator|=
literal|1
expr_stmt|;
comment|/* No reason to repeat */
comment|/* this if several */
comment|/* ExposeWindow events */
comment|/* come in quick succes-*/
comment|/* ion */
break|break;
case|case
name|ExposeRegion
case|:
if|if
condition|(
name|PendingExposure
condition|)
block|{
comment|/* Don't bother with */
comment|/* region events when */
comment|/* full window event */
comment|/* is pending */
break|break;
block|}
name|loadxrepbuffer
argument_list|(
operator|&
name|XXEvent
argument_list|,
operator|&
name|XXqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXqueue
operator|.
name|rindex
operator|==
name|XXqueue
operator|.
name|windex
condition|)
block|{
name|PendingExposure
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|XXqueue
operator|.
name|rindex
operator|>
name|XXqueue
operator|.
name|mindex
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|windex
operator|>
name|XXqueue
operator|.
name|mindex
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|rindex
operator|<
literal|0
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|windex
operator|<
literal|0
operator|)
condition|)
block|{
name|PendingExposure
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ExposeCopy
case|:
comment|/* For ExposeCopy sync */
comment|/* will block all outgoing */
comment|/* requests until this is */
comment|/* decremented */
if|if
condition|(
name|WindowMapped
condition|)
name|bitblt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KeyPressed
case|:
comment|/* bcopy (XXEvent, event, sizeof (XKeyPressedEvent)); */
name|where_mapping
operator|=
name|XLookupMapping
argument_list|(
operator|&
name|XXEvent
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Nasty fix for arrow keys */
if|if
condition|(
operator|!
name|nbytes
operator|&&
name|IsCursorKey
argument_list|(
name|XXEvent
operator|.
name|detail
operator|&
literal|0xff
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|XXEvent
operator|.
name|detail
operator|&
literal|0xff
condition|)
block|{
case|case
name|KC_CURSOR_LEFT
case|:
name|where_mapping
operator|=
literal|"\002"
expr_stmt|;
break|break;
case|case
name|KC_CURSOR_RIGHT
case|:
name|where_mapping
operator|=
literal|"\006"
expr_stmt|;
break|break;
case|case
name|KC_CURSOR_UP
case|:
name|where_mapping
operator|=
literal|"\020"
expr_stmt|;
break|break;
case|case
name|KC_CURSOR_DOWN
case|:
name|where_mapping
operator|=
literal|"\016"
expr_stmt|;
break|break;
block|}
name|nbytes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|numchars
operator|-
name|nbytes
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|where_mapping
argument_list|,
name|bufp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|nbytes
expr_stmt|;
name|count
operator|+=
name|nbytes
expr_stmt|;
name|numchars
operator|-=
name|nbytes
expr_stmt|;
block|}
comment|/*	  else 	    { 	      bcopy (where_mapping, bufp, numchars); 	      bufp += numchars; 	      count += numchars; 	      numchars = 0; 	      *(bufp-1) = *(where_mapping + nbytes - 1); 	    }*/
break|break;
case|case
name|ButtonPressed
case|:
case|case
name|ButtonReleased
case|:
switch|switch
condition|(
name|spacecheck
argument_list|(
name|Xxrepbuffer
operator|.
name|mindex
argument_list|,
name|Xxrepbuffer
operator|.
name|rindex
argument_list|,
name|Xxrepbuffer
operator|.
name|windex
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|loadxrepbuffer
argument_list|(
operator|&
name|XXEvent
argument_list|,
operator|&
name|Xxrepbuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|informflag
operator|&&
operator|(
name|numchars
operator|>
literal|1
operator|)
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
operator|(
name|char
operator|)
literal|'X'
operator|&
literal|037
expr_stmt|;
comment|/* C-x */
operator|++
name|count
expr_stmt|;
operator|--
name|numchars
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
comment|/* C-@ */
operator|++
name|count
expr_stmt|;
operator|--
name|numchars
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|1
case|:
break|break;
case|case
operator|-
literal|2
case|:
default|default:
name|fixxrepbuffer
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
comment|/*  while (replies) {     Reply *reply = replies;     XPutBackEvent (&reply->event);     replies = reply->next;     free (reply);     }*/
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SELECT
if|if
condition|(
name|CursorExists
ifdef|#
directive|ifdef
name|O_NDELAY
ifdef|#
directive|ifdef
name|F_GETFL
operator|&&
operator|(
operator|!
operator|(
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|&
name|O_NDELAY
operator|)
operator|)
endif|#
directive|endif
endif|#
directive|endif
condition|)
name|xfixscreen
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_comment
comment|/* refresh bitmap kitchen sink icon */
end_comment

begin_macro
name|refreshicon
argument_list|()
end_macro

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|XXIconWindow
condition|)
name|XBitmapBitsPut
argument_list|(
name|XXIconWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sink_width
argument_list|,
name|sink_height
argument_list|,
name|sink_bits
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|,
name|XXIconMask
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|XBitmapIcon
argument_list|()
end_macro

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|IconWindow
condition|)
block|{
name|XSetIconWindow
argument_list|(
name|XXwindow
argument_list|,
name|XXIconWindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXIconWindow
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
name|IconWindow
operator|=
operator|!
name|IconWindow
expr_stmt|;
block|}
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|XTextIcon
argument_list|()
end_macro

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|IconWindow
condition|)
block|{
name|XClearIconWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXIconWindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
name|IconWindow
operator|=
operator|!
name|IconWindow
expr_stmt|;
block|}
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Interpreting incoming keycodes. Should have table modifiable as needed  * from elisp.  */
end_comment

begin_comment
comment|/* Exit gracefully from gnuemacs, doing an autosave and giving a status.  */
end_comment

begin_macro
name|XExitGracefully
argument_list|(
argument|disp
argument_list|,
argument|event
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|disp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XErrorEvent
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XCleanUp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|70
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|x_io_error
argument_list|(
argument|disp
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|disp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XCleanUp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|71
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This kludge overcomes the failure to handle EAGAIN and EINTR    in a certain version of X for 386 running system V.  */
end_comment

begin_comment
unit|x_io_error (disp, a, b, c, nwrite)      Display *disp; {   extern _XSend ();   unsigned int pc = ((unsigned int *)&disp)[-1];   if (pc - (unsigned int)&_XSend - 100< 100&& (errno == EAGAIN || errno == EINTR))     {
comment|/* We were called by `writedata' erroneously. 	 Modify a local variable which `writedata' 	 will subtract from the number of bytes to be written.  */
end_comment

begin_endif
unit|nwrite = 0;       return;     }   abort (); }
endif|#
directive|endif
end_endif

begin_macro
name|xfixscreen
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|temp_width
decl_stmt|,
name|temp_height
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
comment|/* register int temp_x, temp_y; */
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|dumpqueue
argument_list|()
expr_stmt|;
comment|/* Check that the connection is in fact open.  This works by doing a nop */
comment|/* (well, almost) write operation.  If there is an XIOerror or a */
comment|/* SIGPIPE, exit gracefully.  This fixes the loop-on-logout bug.*/
comment|/* XIOErrorHandler (XExitGracefully); */
name|XPixFill
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|back
argument_list|,
name|ClipModeClipped
argument_list|,
name|GXnoop
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
comment|/* XIOErrorHandler (0); */
if|if
condition|(
name|PendingIconExposure
condition|)
block|{
name|refreshicon
argument_list|()
expr_stmt|;
name|PendingIconExposure
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|PendingExposure
condition|)
block|{
name|PendingExposure
operator|=
literal|0
expr_stmt|;
name|ClearCursor
argument_list|()
expr_stmt|;
name|XXqueue
operator|.
name|rindex
operator|=
literal|0
expr_stmt|;
name|XXqueue
operator|.
name|windex
operator|=
literal|0
expr_stmt|;
name|XQueryWindow
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|windowinfo
argument_list|)
expr_stmt|;
comment|/* Dangerous to do */
comment|/* writes here but */
comment|/* otherwise would */
comment|/* have to alter */
comment|/* gnu emacs display */
comment|/* routines to query */
comment|/* when screen garbaged */
name|temp_width
operator|=
operator|(
name|windowinfo
operator|.
name|width
operator|-
literal|2
operator|*
name|XXInternalBorder
operator|)
operator|/
name|fontinfo
operator|->
name|width
expr_stmt|;
name|temp_height
operator|=
operator|(
name|windowinfo
operator|.
name|height
operator|-
literal|2
operator|*
name|XXInternalBorder
operator|)
operator|/
name|fontinfo
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|temp_width
operator|!=
name|screen_width
operator|||
name|temp_height
operator|!=
name|screen_height
condition|)
name|change_screen_size
argument_list|(
name|max
argument_list|(
literal|5
argument_list|,
name|temp_height
argument_list|)
argument_list|,
name|max
argument_list|(
literal|10
argument_list|,
name|temp_width
argument_list|)
argument_list|)
expr_stmt|;
name|XXxoffset
operator|=
name|windowinfo
operator|.
name|x
expr_stmt|;
name|XXyoffset
operator|=
name|windowinfo
operator|.
name|y
expr_stmt|;
comment|/*if (temp_x != XXxoffset || temp_y != XXyoffset) 	XSetOffset (temp_x, temp_y);*/
name|dumprectangle
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|InUpdate
condition|)
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|SIGNAL_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|x_term_init
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|vardisplay
decl_stmt|;
name|char
modifier|*
name|temp_font
decl_stmt|;
specifier|register
name|char
modifier|*
name|option
decl_stmt|;
extern|extern XTinterrupt_signal (
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|reversevideo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Color
name|cdef
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Fset
argument_list|(
name|intern
argument_list|(
literal|"window-system-version"
argument_list|)
argument_list|,
name|make_number
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vardisplay
operator|=
operator|(
name|alternate_display
condition|?
name|alternate_display
else|:
operator|(
name|char
operator|*
operator|)
name|egetenv
argument_list|(
literal|"DISPLAY"
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|vardisplay
operator|||
operator|*
name|vardisplay
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DISPLAY environment variable must be set\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|200
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XXdisplay
operator|=
name|XOpenDisplay
argument_list|(
name|vardisplay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XXdisplay
operator|==
operator|(
name|Display
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"X server not responding.  Check your DISPLAY environment variable.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|200
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|x_init_1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Xxrepbuffer
operator|.
name|mindex
operator|=
name|XREPBUFSIZE
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Xxrepbuffer
operator|.
name|windex
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Xxrepbuffer
operator|.
name|rindex
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXqueue
operator|.
name|mindex
operator|=
name|XREPBUFSIZE
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXqueue
operator|.
name|windex
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXqueue
operator|.
name|rindex
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|WindowMapped
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|baud_rate
operator|=
literal|9600
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|min_padding_speed
operator|=
literal|10000
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|must_write_spaces
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|informflag
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|meta_key
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|visible_bell
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_expr_stmt
name|interrupt_input
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|inverse_video
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bitblt
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PendingExposure
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fix_screen_hook
operator|=
name|xfixscreen
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_screen_hook
operator|=
name|XTclear_screen
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_end_of_line_hook
operator|=
name|XTclear_end_of_line
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ins_del_lines_hook
operator|=
name|XTins_del_lines
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|change_line_highlight_hook
operator|=
name|XTchange_line_highlight
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|insert_chars_hook
operator|=
name|XTinsert_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|output_chars_hook
operator|=
name|XToutput_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|delete_chars_hook
operator|=
name|XTdelete_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ring_bell_hook
operator|=
name|XTfeep
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reset_terminal_modes_hook
operator|=
name|XTreset_terminal_modes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|set_terminal_modes_hook
operator|=
name|XTset_terminal_modes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|update_begin_hook
operator|=
name|XTupdate_begin
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|update_end_hook
operator|=
name|XTupdate_end
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|set_terminal_window_hook
operator|=
name|XTset_terminal_window
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|read_socket_hook
operator|=
name|XTread_socket
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|move_cursor_hook
operator|=
name|XTmove_cursor
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* raw_move_cursor_hook = XTraw_move_cursor;  */
end_comment

begin_expr_stmt
name|reassert_line_highlight_hook
operator|=
name|XTreassert_line_highlight
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|scroll_region_ok
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we'll scroll partial screens */
end_comment

begin_expr_stmt
name|char_ins_del_ok
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* just as fast to write the line */
end_comment

begin_expr_stmt
name|line_ins_del_ok
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we'll just blt 'em */
end_comment

begin_expr_stmt
name|fast_clear_end_of_line
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* X does this well */
end_comment

begin_expr_stmt
name|memory_below_screen
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we don't remember what scrolls 				   off the bottom */
end_comment

begin_expr_stmt
name|dont_calculate_costs
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* New options section */
end_comment

begin_expr_stmt
name|IconWindow
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXborder
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXInternalBorder
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|screen_width
operator|=
literal|80
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|screen_height
operator|=
literal|66
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reversevideo
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXxoffset
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXyoffset
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXdebug
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XErrorHandler
argument_list|(
name|XExitGracefully
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XIOErrorHandler
argument_list|(
name|x_io_error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|progname
operator|=
literal|"emacs"
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"ReverseVideo"
argument_list|)
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|reversevideo
operator|=
literal|1
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"BitmapIcon"
argument_list|)
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|IconWindow
operator|=
literal|1
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"BorderWidth"
argument_list|)
condition|)
name|XXborder
operator|=
name|atoi
argument_list|(
name|option
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"InternalBorder"
argument_list|)
condition|)
name|XXInternalBorder
operator|=
name|atoi
argument_list|(
name|option
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|brdr_color
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Border"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|brdr_color
condition|)
name|brdr_color
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"BorderColor"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|back_color
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Background"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fore_color
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Foreground"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mous_color
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Mouse"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curs_color
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"Cursor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|temp_font
operator|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"BodyFont"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|temp_font
operator|==
literal|0
condition|)
name|temp_font
operator|=
name|X_DEFAULT_FONT
expr_stmt|;
end_if

begin_expr_stmt
name|XXcurrentfont
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|temp_font
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|strcpy
argument_list|(
name|XXcurrentfont
argument_list|,
name|temp_font
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If user has specified a special keymap for use with Emacs, use it. */
end_comment

begin_block
block|{
name|char
modifier|*
name|temp
init|=
name|XGetDefault
argument_list|(
name|progname
argument_list|,
literal|"KeyMap"
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
name|XUseKeymap
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|if
condition|(
name|DisplayCells
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|fore_color
operator|&&
name|XParseColor
argument_list|(
name|fore_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|fore
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|fore_color
operator|=
literal|"black"
expr_stmt|;
name|fore
operator|=
name|BlackPixel
expr_stmt|;
block|}
if|if
condition|(
name|back_color
operator|&&
name|XParseColor
argument_list|(
name|back_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|back
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|back_color
operator|=
literal|"white"
expr_stmt|;
name|back
operator|=
name|WhitePixel
expr_stmt|;
block|}
if|if
condition|(
name|curs_color
operator|&&
name|XParseColor
argument_list|(
name|curs_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|curs
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|curs_color
operator|=
literal|"black"
expr_stmt|;
name|curs
operator|=
name|BlackPixel
expr_stmt|;
block|}
if|if
condition|(
name|mous_color
operator|&&
name|XParseColor
argument_list|(
name|mous_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|mous
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|mous_color
operator|=
literal|"black"
expr_stmt|;
name|mous
operator|=
name|BlackPixel
expr_stmt|;
block|}
if|if
condition|(
name|brdr_color
operator|&&
name|XParseColor
argument_list|(
name|brdr_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|brdr
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|brdr_color
operator|=
literal|"black"
expr_stmt|;
name|brdr
operator|=
name|BlackPixel
expr_stmt|;
block|}
block|}
else|else
block|{
name|fore_color
operator|=
name|curs_color
operator|=
name|mous_color
operator|=
name|brdr_color
operator|=
literal|"black"
expr_stmt|;
name|fore
operator|=
name|curs
operator|=
name|mous
operator|=
name|brdr
operator|=
name|BlackPixel
expr_stmt|;
name|back_color
operator|=
literal|"white"
expr_stmt|;
name|back
operator|=
name|WhitePixel
expr_stmt|;
block|}
end_if

begin_comment
comment|/*   if (fore_color&& DisplayCells ()> 2&&       XParseColor (fore_color,&cdef)&& XGetHardwareColor (&cdef))     fore = cdef.pixel;   else if (fore_color&& strcmp (fore_color, "black") == 0)     fore = BlackPixel;   else if (fore_color&& strcmp (fore_color, "white") == 0)     fore = WhitePixel;   else     {       fore_color = "black";       fore = BlackPixel;     }    if (back_color&& DisplayCells ()> 2&&       XParseColor (back_color,&cdef)&& XGetHardwareColor (&cdef))     back = cdef.pixel;   else if (back_color&& strcmp (back_color, "white") == 0)     back = WhitePixel;   else if (back_color&& strcmp (back_color, "black") == 0)     back = BlackPixel;   else     {       back_color = "white";       back = WhitePixel;     }    if (brdr_color&& DisplayCells ()> 2&&       XParseColor (brdr_color,&cdef)&& XGetHardwareColor (&cdef))     brdr = cdef.pixel;   else if (brdr_color&& (!strcmp (brdr_color, "gray") || 			  !strcmp (brdr_color, "grey") || 			  !strcmp (brdr_color, "Gray") || 			  !strcmp (brdr_color, "Grey")))     brdr = BlackPixel;   else if (brdr_color&& strcmp (brdr_color, "white") == 0)     brdr = WhitePixel;   else     {       brdr_color = "black";       brdr = BlackPixel;     }    if (curs_color&& DisplayCells ()> 2&&       XParseColor (curs_color,&cdef)&& XGetHardwareColor (&cdef))     curs = cdef.pixel;   else if (curs_color&& strcmp (curs_color, "black") == 0)     curs = BlackPixel;   else if (curs_color&& strcmp (curs_color, "white") == 0)     curs = WhitePixel;   else     {       curs_color = "black";       curs = BlackPixel;     }    if (mous_color&& DisplayCells ()> 2&&       XParseColor (mous_color,&cdef)&& XGetHardwareColor (&cdef))     mous = cdef.pixel;   else if (mous_color&& strcmp (mous_color, "black") == 0)     mous = BlackPixel;   else if (mous_color&& strcmp (mous_color, "white") == 0)     mous = WhitePixel;   else     {       mous_color = "black";       mous = BlackPixel;     }     */
end_comment

begin_expr_stmt
name|XXpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XXcurrentfont
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation failure.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|150
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|default_window
operator|=
literal|"=80x24+0+0"
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* RMS: XTread_socket does not have an interface suitable    for being a signal handler.  In any case, the SIGIO handler is    set up in init_keyboard and X uses the same one as usual.  */
end_comment

begin_comment
comment|/*  signal (SIGIO, XTread_socket); */
end_comment

begin_expr_stmt
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|XExitGracefully
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XQueryWindow
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|rootwindowinfo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|strncpy
argument_list|(
name|iconidentity
argument_list|,
name|ICONTAG
argument_list|,
name|MAXICID
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fontinfo
operator|=
name|XOpenFont
argument_list|(
name|XXcurrentfont
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fontinfo
operator|==
operator|(
name|FontInfo
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No font\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|98
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|pixelwidth
operator|=
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pixelheight
operator|=
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXwindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
name|XXxoffset
comment|/* Absolute horizontal offset */
argument_list|,
name|XXyoffset
comment|/* Absolute Vertical offset */
argument_list|,
name|pixelwidth
argument_list|,
name|pixelheight
argument_list|,
name|XXborder
argument_list|,
name|BlackPixmap
argument_list|,
name|WhitePixmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|XXwindow
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to create window.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|97
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XXIconWindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sink_width
argument_list|,
name|sink_height
argument_list|,
literal|2
argument_list|,
name|WhitePixmap
argument_list|,
operator|(
name|Pixmap
operator|)
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|XXIconWindow
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to create icon window.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|97
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XSelectInput
argument_list|(
name|XXIconWindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXIconMask
operator|=
name|XStoreBitmap
argument_list|(
name|sink_mask_width
argument_list|,
name|sink_mask_height
argument_list|,
name|sink_mask_bits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSetResizeHint
argument_list|(
name|XXwindow
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
comment|/* fontinfo->width * 1, fontinfo->height * 1, */
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|HPUX
argument_list|)
operator|||
name|defined
argument_list|(
name|IBMRTAIX
argument_list|)
end_if

begin_if
if|if
condition|(
name|gethostname
argument_list|(
operator|&
name|iconidentity
index|[
sizeof|sizeof
argument_list|(
name|ICONTAG
argument_list|)
operator|-
literal|1
index|]
argument_list|,
operator|(
name|MAXICID
operator|-
literal|1
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|ICONTAG
argument_list|)
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|iconidentity
index|[
sizeof|sizeof
argument_list|(
name|ICONTAG
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XStoreName
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|iconidentity
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EmacsCursor
operator|=
name|XCreateCursor
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|MouseCursor
argument_list|,
name|MouseMask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mous
argument_list|,
name|back
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|EmacsCursor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flexlines
operator|=
name|screen_height
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Do not call XPopUpWindow here!  This is too early.    It is supposed ot be called via the term-setup-hook    and not until after lisp/term/x-win.el has had a chance    to process the user's switches.    I am not sure that there are any circumstances under which    this should be done here  -- RMS.  */
end_comment

begin_comment
unit|XPopUpWindow ();
comment|/* This looks at Vxterm */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_if
if|if
condition|(
name|reversevideo
condition|)
name|XFlipColor
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
unit|}  x_init_1
operator|(
name|unrequest
operator|)
block|{
ifdef|#
directive|ifdef
name|F_SETOWN
specifier|extern
name|int
name|old_fcntl_owner
block|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USG
specifier|extern
name|void
name|init_sigio
argument_list|()
block|,
name|request_sigio
argument_list|()
block|,
name|unrequest_sigio
argument_list|()
block|;
endif|#
directive|endif
name|dup2
argument_list|(
name|dpyno
argument_list|()
argument_list|,
literal|0
argument_list|)
block|;
name|close
argument_list|(
name|dpyno
argument_list|()
argument_list|)
block|;
name|dpyno
argument_list|()
operator|=
literal|0
block|;
comment|/* Looks a little strange? 				   check the def of the macro; 				   it is a genuine lvalue */
ifndef|#
directive|ifndef
name|USG
name|init_sigio
argument_list|()
block|;
name|request_sigio
argument_list|()
block|;
endif|#
directive|endif
comment|/* USG */
ifdef|#
directive|ifdef
name|F_SETOWN
name|old_fcntl_owner
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETOWN
argument_list|,
literal|0
argument_list|)
block|;
ifdef|#
directive|ifdef
name|F_SETOWN_SOCK_NEG
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETOWN
argument_list|,
operator|-
name|getpid
argument_list|()
argument_list|)
block|;
comment|/* stdin is a socket here */
else|#
directive|else
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
block|;
endif|#
directive|endif
comment|/* F_SETOWN_SOCK_NEG */
endif|#
directive|endif
comment|/* F_SETOWN */
ifndef|#
directive|ifndef
name|USG
if|if
condition|(
name|unrequest
condition|)
name|unrequest_sigio
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_comment
comment|/* Process all queued ExposeRegion events. */
end_comment

begin_expr_stmt
specifier|static
name|dumpqueue
argument_list|()
block|{
specifier|register
name|int
name|i
block|;
name|XExposeRegionEvent
name|r
block|;
if|if
condition|(
operator|(
name|XXqueue
operator|.
name|rindex
operator|>
name|XXqueue
operator|.
name|mindex
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|windex
operator|>
name|XXqueue
operator|.
name|mindex
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|rindex
operator|<
literal|0
operator|)
operator|||
operator|(
name|XXqueue
operator|.
name|windex
operator|<
literal|0
operator|)
condition|)
block|{
name|PendingExposure
operator|=
literal|1
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
while|while
condition|(
name|XXqueue
operator|.
name|rindex
operator|!=
name|XXqueue
operator|.
name|windex
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|unloadxrepbuffer
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|XXqueue
argument_list|)
expr_stmt|;
name|dumprectangle
argument_list|(
name|r
operator|.
name|y
operator|-
name|XXInternalBorder
argument_list|,
name|r
operator|.
name|x
operator|-
name|XXInternalBorder
argument_list|,
name|r
operator|.
name|height
argument_list|,
name|r
operator|.
name|width
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}  XSetFlash
operator|(
operator|)
block|{
name|ring_bell_hook
operator|=
name|XTflash
block|; }
name|XSetFeep
argument_list|()
block|{
name|ring_bell_hook
operator|=
name|XTfeep
block|; }
name|XNewFont
argument_list|(
name|newname
argument_list|)
specifier|register
name|char
operator|*
name|newname
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|FontInfo
modifier|*
name|temp
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
if|if
condition|(
name|XXdebug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Request id is %d\n"
argument_list|,
name|XXdisplay
operator|->
name|request
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XOpenFont
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
operator|(
name|FontInfo
operator|*
operator|)
literal|0
condition|)
block|{
name|UNBLOCK_INPUT_RESIGNAL
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|XCloseFont
argument_list|(
name|fontinfo
argument_list|)
expr_stmt|;
name|fontinfo
operator|=
name|temp
expr_stmt|;
name|XSetResizeHint
argument_list|(
name|XXwindow
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
comment|/* fontinfo->width * 1, fontinfo->height * 1, */
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
name|XSetWindowSize
argument_list|(
name|screen_height
argument_list|,
name|screen_width
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT_RESIGNAL
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|XFlipColor
argument_list|()
end_macro

begin_block
block|{
name|Pixmap
name|temp
decl_stmt|;
name|int
name|tempcolor
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|Cursor
name|temp_curs
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|temp
operator|=
name|XMakeTile
argument_list|(
name|fore
argument_list|)
expr_stmt|;
name|XChangeBackground
argument_list|(
name|XXwindow
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XMakeTile
argument_list|(
name|back
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXborder
condition|)
name|XChangeBorder
argument_list|(
name|XXwindow
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|brdr
operator|=
name|back
expr_stmt|;
name|brdr_color
operator|=
name|back_color
expr_stmt|;
name|tempcolor
operator|=
name|fore
expr_stmt|;
name|fore
operator|=
name|back
expr_stmt|;
name|back
operator|=
name|tempcolor
expr_stmt|;
name|tempname
operator|=
name|fore_color
expr_stmt|;
name|fore_color
operator|=
name|back_color
expr_stmt|;
name|back_color
operator|=
name|tempname
expr_stmt|;
comment|/*  XPixFill (XXwindow, 0, 0, screen_width * fontinfo->width, 	    screen_height * fontinfo->height, back, ClipModeClipped, 	    GXcopy, AllPlanes);   dumprectangle (0, 0, screen_height * fontinfo->height + 2 * XXInternalBorder,   screen_width * fontinfo -> width + 2 * XXInternalBorder);*/
name|XRedrawDisplay
argument_list|()
expr_stmt|;
if|if
condition|(
name|curs
operator|==
name|WhitePixel
condition|)
block|{
name|curs
operator|=
name|BlackPixel
expr_stmt|;
name|curs_color
operator|=
literal|"black"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curs
operator|==
name|BlackPixel
condition|)
block|{
name|curs
operator|=
name|WhitePixel
expr_stmt|;
name|curs_color
operator|=
literal|"white"
expr_stmt|;
block|}
if|if
condition|(
name|mous
operator|==
name|WhitePixel
condition|)
block|{
name|mous
operator|=
name|BlackPixel
expr_stmt|;
name|mous_color
operator|=
literal|"black"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mous
operator|==
name|BlackPixel
condition|)
block|{
name|mous
operator|=
name|WhitePixel
expr_stmt|;
name|mous_color
operator|=
literal|"white"
expr_stmt|;
block|}
name|temp_curs
operator|=
name|XCreateCursor
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|MouseCursor
argument_list|,
name|MouseMask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mous
argument_list|,
name|back
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|XUndefineCursor
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|temp_curs
argument_list|)
expr_stmt|;
name|XFreeCursor
argument_list|(
name|EmacsCursor
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|temp_curs
argument_list|,
operator|&
name|EmacsCursor
argument_list|,
sizeof|sizeof
argument_list|(
name|Cursor
argument_list|)
argument_list|)
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|XSetOffset
argument_list|(
name|xoff
argument_list|,
name|yoff
argument_list|)
specifier|register
name|int
name|xoff
operator|,
name|yoff
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|xoff
operator|<
literal|0
condition|)
block|{
name|XXxoffset
operator|=
name|rootwindowinfo
operator|.
name|width
operator|+
operator|(
operator|++
name|xoff
operator|)
operator|-
name|pixelwidth
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|XXxoffset
operator|=
name|xoff
expr_stmt|;
block|}
if|if
condition|(
name|yoff
operator|<
literal|0
condition|)
block|{
name|XXyoffset
operator|=
name|rootwindowinfo
operator|.
name|height
operator|+
operator|(
operator|++
name|yoff
operator|)
operator|-
name|pixelheight
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|XXyoffset
operator|=
name|yoff
expr_stmt|;
block|}
name|XMoveWindow
argument_list|(
name|XXwindow
argument_list|,
name|XXxoffset
argument_list|,
name|XXyoffset
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
comment|/* XWarpMouse (XXwindow, pixelwidth>> 1, pixelheight>> 1); */
block|}
end_block

begin_expr_stmt
name|XSetWindowSize
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|)
specifier|register
name|int
name|rows
operator|,
name|cols
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* if (rows< 3) rows = 24;      if (cols< 1) cols = 80; */
name|pixelwidth
operator|=
name|cols
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|pixelheight
operator|=
name|rows
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|XChangeWindow
argument_list|(
name|XXwindow
argument_list|,
name|pixelwidth
argument_list|,
name|pixelheight
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|change_screen_size
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|PendingExposure
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|XPopUpWindow
argument_list|()
end_macro

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
if|if
condition|(
name|WindowMapped
condition|)
return|return;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|x_edges_specified
condition|)
name|Fx_rubber_band
argument_list|()
expr_stmt|;
name|bitblt
operator|=
literal|0
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|VisibleX
operator|=
literal|0
expr_stmt|;
name|VisibleY
operator|=
literal|0
expr_stmt|;
name|WindowMapped
operator|=
literal|1
expr_stmt|;
name|XMapWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|dumprectangle
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|KeyPressed
operator||
name|ExposeWindow
operator||
name|ButtonPressed
operator||
name|ButtonReleased
operator||
name|ExposeRegion
operator||
name|ExposeCopy
argument_list|)
expr_stmt|;
comment|/*	XWarpMouse (XXwindow, pixelwidth>> 1, pixelheight>> 1);*/
name|XTmove_cursor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IconWindow
condition|)
block|{
name|XSetIconWindow
argument_list|(
name|XXwindow
argument_list|,
name|XXIconWindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXIconWindow
argument_list|,
name|ExposeWindow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XClearIconWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXIconWindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
block|}
comment|/*  XRedrawDisplay ();*/
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|spacecheck
argument_list|(
name|mindex
argument_list|,
name|rindex
argument_list|,
name|windex
argument_list|,
name|minfreespace
argument_list|)
specifier|register
name|int
name|mindex
operator|,
name|rindex
operator|,
name|windex
operator|,
name|minfreespace
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|rindex
operator|>
name|mindex
operator|)
operator|||
operator|(
name|windex
operator|>
name|mindex
operator|)
condition|)
block|{
comment|/* fprintf (stderr, "Fatal Mouse Buffer Error.\n"); 	 fprintf (stderr, "%d = mindex, %d = rindex, %d = windex\n", 	 mindex, rindex, windex); */
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|windex
operator|>=
name|rindex
condition|)
block|{
if|if
condition|(
operator|(
name|mindex
operator|-
operator|(
name|windex
operator|-
name|rindex
operator|)
operator|)
operator|>
name|minfreespace
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|rindex
operator|-
name|windex
operator|)
operator|-
literal|1
operator|)
operator|>
name|minfreespace
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_expr_stmt
name|loadxrepbuffer
argument_list|(
name|p_xrep
argument_list|,
name|p_buffer
argument_list|)
specifier|register
name|XEvent
operator|*
name|p_xrep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XREPBUFFER
modifier|*
name|p_buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p_buffer
operator|->
name|xrep
index|[
name|p_buffer
operator|->
name|windex
index|]
operator|=
operator|*
name|p_xrep
expr_stmt|;
if|if
condition|(
name|p_buffer
operator|->
name|windex
operator|==
name|p_buffer
operator|->
name|mindex
condition|)
name|p_buffer
operator|->
name|windex
operator|=
literal|0
expr_stmt|;
else|else
name|p_buffer
operator|->
name|windex
operator|++
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|unloadxrepbuffer
argument_list|(
name|p_xrep
argument_list|,
name|p_buffer
argument_list|)
specifier|register
name|XEvent
operator|*
name|p_xrep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XREPBUFFER
modifier|*
name|p_buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p_buffer
operator|->
name|windex
operator|==
name|p_buffer
operator|->
name|rindex
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|p_xrep
operator|=
name|p_buffer
operator|->
name|xrep
index|[
name|p_buffer
operator|->
name|rindex
index|]
expr_stmt|;
if|if
condition|(
name|p_buffer
operator|->
name|rindex
operator|==
name|p_buffer
operator|->
name|mindex
condition|)
name|p_buffer
operator|->
name|rindex
operator|=
literal|0
expr_stmt|;
else|else
name|p_buffer
operator|->
name|rindex
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|fixxrepbuffer
argument_list|()
end_macro

begin_block
block|{
name|Xxrepbuffer
operator|.
name|mindex
operator|=
name|XREPBUFSIZE
operator|-
literal|1
expr_stmt|;
name|Xxrepbuffer
operator|.
name|windex
operator|=
literal|0
expr_stmt|;
name|Xxrepbuffer
operator|.
name|rindex
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_X_WINDOWS */
end_comment

end_unit

