begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for the X window system.    Copyright (C) 1988, 1990 Free Software Foundation.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Yakim Martillo; rearranged by Richard Stallman.  */
end_comment

begin_comment
comment|/* Color and other features added by Robert Krawitz*/
end_comment

begin_comment
comment|/* Converted to X11 by Robert French */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NULL
end_ifdef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* Get FIONREAD, if it is available.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_comment
comment|/* Allow m- file to inhibit use of interrupt-driven input.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_FIONREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FIONREAD
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We are unable to use interrupts if FIONREAD is not available,    so flush SIGIO so we won't try.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FIONREAD
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_undef
undef|#
directive|undef
name|SIGIO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"x11term.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|((x< 0) ? ((x)) : (x))
end_define

begin_define
define|#
directive|define
name|sgn
parameter_list|(
name|x
parameter_list|)
value|((x< 0) ? (-1) : (1))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* Non-nil if Emacs is running with an X window for display.    Nil if Emacs is run on an ordinary terminal.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vxterm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vx_mouse_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vx_mouse_abs_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vx_mouse_item
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Lisp_Object
name|MouseMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Lisp_Object
name|minibuf_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|minibuf_prompt_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|XEvent
modifier|*
name|XXm_queue
index|[
name|XMOUSEBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXm_queue_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXm_queue_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXm_queue_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|fore_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|back_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|brdr_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mous_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|curs_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|fore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|back
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|brdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|curs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXborder
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXInternalBorder
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|XFontStruct
modifier|*
name|fontinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Font
name|XXfid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|GC
name|XXgc_norm
decl_stmt|,
name|XXgc_rev
decl_stmt|,
name|XXgc_curs
decl_stmt|,
name|XXgc_temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|XGCValues
name|XXgcv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXfontw
decl_stmt|,
name|XXfonth
decl_stmt|,
name|XXbase
decl_stmt|,
name|XXisColor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Colormap
name|XXColorMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|PendingExposure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|default_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|desiredwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXscreen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Window
name|XXwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Cursor
name|EmacsCursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|MouseCursor
index|[]
decl_stmt|,
name|MouseMask
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|XXcurrentfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|informflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|WindowMapped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|CurHL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pixelwidth
decl_stmt|,
name|pixelheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|XXidentity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Display
modifier|*
name|XXdisplay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bitblt
decl_stmt|,
name|CursorExists
decl_stmt|,
name|VisibleX
decl_stmt|,
name|VisibleY
decl_stmt|;
end_decl_stmt

begin_macro
name|check_xterm
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|Vxterm
argument_list|)
condition|)
name|error
argument_list|(
literal|"Terminal does not understand X protocol."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-bell"
argument_list|,
argument|Fx_set_bell
argument_list|,
argument|Sx_set_bell
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"For X window system, set audible vs visible bell.\n\ With non-nil argument (prefix arg), use visible bell; otherwise, audible bell."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|XSetFlash
argument_list|()
expr_stmt|;
else|else
name|XSetFeep
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-flip-color"
argument_list|,
argument|Fx_flip_color
argument_list|,
argument|Sx_flip_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Toggle the background and foreground colors"
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|check_xterm
argument_list|()
block|;
name|XFlipColor
argument_list|()
block|;
return|return
name|Qt
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-foreground-color"
argument_list|,
argument|Fx_set_foreground_color
argument_list|,
argument|Sx_set_foreground_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet foregroud color:  "
argument_list|,
literal|"Set foreground (text) color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|XColor
name|cdef
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|char
modifier|*
name|save_color
decl_stmt|;
name|save_color
operator|=
name|fore_color
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fore_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|fore_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|fore_color
operator|&&
name|XXisColor
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|fore_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
name|fore
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
elseif|else
if|if
condition|(
name|fore_color
operator|&&
operator|!
name|strcmp
argument_list|(
name|fore_color
argument_list|,
literal|"black"
argument_list|)
condition|)
name|fore
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fore_color
operator|&&
operator|!
name|strcmp
argument_list|(
name|fore_color
argument_list|,
literal|"white"
argument_list|)
condition|)
name|fore
operator|=
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
else|else
name|fore_color
operator|=
name|save_color
expr_stmt|;
name|XSetForeground
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_norm
argument_list|,
name|fore
argument_list|)
expr_stmt|;
name|XSetBackground
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_rev
argument_list|,
name|fore
argument_list|)
expr_stmt|;
name|Fredraw_display
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-background-color"
argument_list|,
argument|Fx_set_background_color
argument_list|,
argument|Sx_set_background_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet background color: "
argument_list|,
literal|"Set background color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|XColor
name|cdef
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|char
modifier|*
name|save_color
decl_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_color
operator|=
name|back_color
expr_stmt|;
name|back_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|back_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|back_color
operator|&&
name|XXisColor
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|back_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
name|back
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
elseif|else
if|if
condition|(
name|back_color
operator|&&
operator|!
name|strcmp
argument_list|(
name|back_color
argument_list|,
literal|"white"
argument_list|)
condition|)
name|back
operator|=
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|back_color
operator|&&
operator|!
name|strcmp
argument_list|(
name|back_color
argument_list|,
literal|"black"
argument_list|)
condition|)
name|back
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
else|else
name|back_color
operator|=
name|save_color
expr_stmt|;
name|XSetBackground
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_norm
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|XSetForeground
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_rev
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|XSetForeground
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_curs
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|XSetWindowBackground
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
operator|*
name|XXfontw
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|screen_height
operator|*
name|XXfonth
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|Fredraw_display
argument_list|()
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-border-color"
argument_list|,
argument|Fx_set_border_color
argument_list|,
argument|Sx_set_border_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet border color: "
argument_list|,
literal|"Set border color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|XColor
name|cdef
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brdr_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|brdr_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|brdr_color
operator|&&
name|XXisColor
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|brdr_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
name|brdr
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
elseif|else
if|if
condition|(
name|brdr_color
operator|&&
operator|!
name|strcmp
argument_list|(
name|brdr_color
argument_list|,
literal|"black"
argument_list|)
condition|)
name|brdr
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|brdr_color
operator|&&
operator|!
name|strcmp
argument_list|(
name|brdr_color
argument_list|,
literal|"white"
argument_list|)
condition|)
name|brdr
operator|=
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
else|else
block|{
name|brdr_color
operator|=
literal|"black"
expr_stmt|;
name|brdr
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XXborder
condition|)
block|{
name|XSetWindowBorder
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|brdr
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
block|}
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-cursor-color"
argument_list|,
argument|Fx_set_cursor_color
argument_list|,
argument|Sx_set_cursor_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet text cursor color: "
argument_list|,
literal|"Set text cursor color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|XColor
name|cdef
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|char
modifier|*
name|save_color
decl_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_color
operator|=
name|curs_color
expr_stmt|;
name|curs_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|curs_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|curs_color
operator|&&
name|XXisColor
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|curs_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
name|curs
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
elseif|else
if|if
condition|(
name|curs_color
operator|&&
operator|!
name|strcmp
argument_list|(
name|curs_color
argument_list|,
literal|"black"
argument_list|)
condition|)
name|curs
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|curs_color
operator|&&
operator|!
name|strcmp
argument_list|(
name|curs_color
argument_list|,
literal|"white"
argument_list|)
condition|)
name|curs
operator|=
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
else|else
name|curs_color
operator|=
name|save_color
expr_stmt|;
name|XSetBackground
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_curs
argument_list|,
name|curs
argument_list|)
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-mouse-color"
argument_list|,
argument|Fx_set_mouse_color
argument_list|,
argument|Sx_set_mouse_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet mouse cursor color: "
argument_list|,
literal|"Set mouse cursor color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|char
modifier|*
name|save_color
decl_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_color
operator|=
name|mous_color
expr_stmt|;
name|mous_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|mous_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|x_set_cursor_colors
argument_list|()
condition|)
name|mous_color
operator|=
name|save_color
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_comment
comment|/* Set the actual X cursor colors from `mous_color' and `back_color'.  */
end_comment

begin_function
name|int
name|x_set_cursor_colors
parameter_list|()
block|{
name|XColor
name|forec
decl_stmt|,
name|backc
decl_stmt|;
name|char
modifier|*
name|useback
decl_stmt|;
comment|/* USEBACK is the background color, but on monochrome screens      changed if necessary not to match the mouse.  */
name|useback
operator|=
name|back_color
expr_stmt|;
if|if
condition|(
operator|!
name|XXisColor
operator|&&
operator|!
name|strcmp
argument_list|(
name|mous_color
argument_list|,
name|back_color
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|back_color
argument_list|,
literal|"white"
argument_list|)
condition|)
name|useback
operator|=
literal|"white"
expr_stmt|;
else|else
name|useback
operator|=
literal|"black"
expr_stmt|;
block|}
if|if
condition|(
name|XXisColor
operator|&&
name|mous_color
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|mous_color
argument_list|,
operator|&
name|forec
argument_list|)
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|useback
argument_list|,
operator|&
name|backc
argument_list|)
condition|)
block|{
name|XRecolorCursor
argument_list|(
name|XXdisplay
argument_list|,
name|EmacsCursor
argument_list|,
operator|&
name|forec
argument_list|,
operator|&
name|backc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"x-color-p"
argument_list|,
argument|Fx_color_p
argument_list|,
argument|Sx_color_p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns t if the display is a color X terminal."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|check_xterm
argument_list|()
block|;
if|if
condition|(
name|XXisColor
condition|)
return|return
name|Qt
return|;
else|else
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-foreground-color"
argument_list|,
argument|Fx_get_foreground_color
argument_list|,
argument|Sx_get_foreground_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the foreground, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|check_xterm
argument_list|()
block|;
name|string
operator|=
name|build_string
argument_list|(
name|fore_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-background-color"
argument_list|,
argument|Fx_get_background_color
argument_list|,
argument|Sx_get_background_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the background, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|check_xterm
argument_list|()
block|;
name|string
operator|=
name|build_string
argument_list|(
name|back_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-border-color"
argument_list|,
argument|Fx_get_border_color
argument_list|,
argument|Sx_get_border_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the border, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|check_xterm
argument_list|()
block|;
name|string
operator|=
name|build_string
argument_list|(
name|brdr_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-cursor-color"
argument_list|,
argument|Fx_get_cursor_color
argument_list|,
argument|Sx_get_cursor_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the cursor, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|check_xterm
argument_list|()
block|;
name|string
operator|=
name|build_string
argument_list|(
name|curs_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-mouse-color"
argument_list|,
argument|Fx_get_mouse_color
argument_list|,
argument|Sx_get_mouse_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the mouse cursor, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|check_xterm
argument_list|()
block|;
name|string
operator|=
name|build_string
argument_list|(
name|mous_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-default"
argument_list|,
argument|Fx_get_default
argument_list|,
argument|Sx_get_default
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Get default for X-window attribute ATTRIBUTE from the system.\n\ ATTRIBUTE must be a string.\n\ Returns nil if attribute default isn't specified."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|default_name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|default_name
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|XBACKWARDS
comment|/* Some versions of X11R4, at least, have the args backwards.  */
if|if
condition|(
name|XXidentity
operator|&&
operator|*
name|XXidentity
condition|)
name|value
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|default_name
argument_list|,
name|XXidentity
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|default_name
argument_list|,
name|CLASS
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|XXidentity
operator|&&
operator|*
name|XXidentity
condition|)
name|value
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|XXidentity
argument_list|,
name|default_name
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|CLASS
argument_list|,
name|default_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|value
condition|)
return|return
name|build_string
argument_list|(
name|value
argument_list|)
return|;
return|return
operator|(
name|Qnil
operator|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-font"
argument_list|,
argument|Fx_set_font
argument_list|,
argument|Sx_set_font
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sFont Name: "
argument_list|,
literal|"Sets the font to be used for the X window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|newfontname
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|newfontname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|newfontname
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
goto|goto
name|badfont
goto|;
if|if
condition|(
operator|!
name|XNewFont
argument_list|(
name|newfontname
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|XXcurrentfont
argument_list|)
expr_stmt|;
name|XXcurrentfont
operator|=
name|newfontname
expr_stmt|;
return|return
name|Qt
return|;
block|}
name|badfont
label|:
name|error
argument_list|(
literal|"Font \"%s\" is not defined"
argument_list|,
name|newfontname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfontname
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"coordinates-in-window-p"
argument_list|,
name|Fcoordinates_in_window_p
argument_list|,
name|Scoordinates_in_window_p
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return non-nil if POSITIONS (a list, (SCREEN-X SCREEN-Y)) is in WINDOW.\n\ Returned value is list of positions expressed\n\ relative to window upper left corner."
argument_list|)
argument_list|(
name|coordinate
argument_list|,
name|window
argument_list|)
specifier|register
name|Lisp_Object
name|coordinate
operator|,
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|xcoord
decl_stmt|,
name|ycoord
decl_stmt|;
name|int
name|height
decl_stmt|;
if|if
condition|(
operator|!
name|CONSP
argument_list|(
name|coordinate
argument_list|)
condition|)
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|coordinate
argument_list|)
expr_stmt|;
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xcoord
operator|=
name|Fcar
argument_list|(
name|coordinate
argument_list|)
expr_stmt|;
name|ycoord
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|coordinate
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|xcoord
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|ycoord
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XINT
argument_list|(
name|xcoord
argument_list|)
operator|<
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|left
argument_list|)
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|xcoord
argument_list|)
operator|>=
operator|(
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|left
argument_list|)
operator|+
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|width
argument_list|)
operator|)
operator|)
condition|)
return|return
name|Qnil
return|;
name|XFASTINT
argument_list|(
name|xcoord
argument_list|)
operator|-=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|left
argument_list|)
expr_stmt|;
name|height
operator|=
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|==
name|minibuf_window
condition|)
block|{
name|XFASTINT
argument_list|(
name|xcoord
argument_list|)
operator|-=
name|minibuf_prompt_width
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|xcoord
argument_list|)
operator|<
literal|0
condition|)
name|XFASTINT
argument_list|(
name|xcoord
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|height
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|XINT
argument_list|(
name|ycoord
argument_list|)
operator|<
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|top
argument_list|)
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|ycoord
argument_list|)
operator|>=
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|top
argument_list|)
operator|+
name|height
operator|)
condition|)
return|return
name|Qnil
return|;
name|XFASTINT
argument_list|(
name|ycoord
argument_list|)
operator|-=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|top
argument_list|)
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|xcoord
argument_list|,
name|Fcons
argument_list|(
name|ycoord
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-mouse-events"
argument_list|,
argument|Fx_mouse_events
argument_list|,
argument|Sx_mouse_events
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return number of pending mouse events from X window system."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|tem
block|;
name|check_xterm
argument_list|()
block|;
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_Int
argument_list|,
name|XXm_queue_num
argument_list|)
block|;
return|return
name|tem
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-proc-mouse-event"
argument_list|,
argument|Fx_proc_mouse_event
argument_list|,
argument|Sx_proc_mouse_event
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Pulls a mouse event out of the mouse event buffer and dispatches\n\ the appropriate function to act upon this event."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|XEvent
name|event
block|;
specifier|register
name|Lisp_Object
name|mouse_cmd
block|;
specifier|register
name|char
name|com_letter
block|;
specifier|register
name|char
name|key_mask
block|;
specifier|register
name|Lisp_Object
name|tempx
block|;
specifier|register
name|Lisp_Object
name|tempy
block|;
specifier|extern
name|Lisp_Object
name|get_keyelt
argument_list|()
block|;
specifier|extern
name|int
name|meta_prefix_char
block|;
name|check_xterm
argument_list|()
block|;
if|if
condition|(
name|XXm_queue_num
condition|)
block|{
name|event
operator|=
operator|*
name|XXm_queue
index|[
name|XXm_queue_out
index|]
expr_stmt|;
name|free
argument_list|(
name|XXm_queue
index|[
name|XXm_queue_out
index|]
argument_list|)
expr_stmt|;
name|XXm_queue_out
operator|=
operator|(
name|XXm_queue_out
operator|+
literal|1
operator|)
operator|%
name|XMOUSEBUFSIZE
expr_stmt|;
name|XXm_queue_num
operator|--
expr_stmt|;
name|com_letter
operator|=
literal|3
operator|-
operator|(
name|event
operator|.
name|xbutton
operator|.
name|button
operator|&
literal|3
operator|)
expr_stmt|;
name|key_mask
operator|=
operator|(
name|event
operator|.
name|xbutton
operator|.
name|state
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
comment|/* Report meta in 2 bit, not in 8 bit.  */
if|if
condition|(
name|key_mask
operator|&
literal|0x80
condition|)
block|{
name|key_mask
operator||=
literal|0x20
expr_stmt|;
name|key_mask
operator|&=
operator|~
literal|0x80
expr_stmt|;
block|}
name|com_letter
operator||=
name|key_mask
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|event
operator|.
name|type
operator|==
name|ButtonRelease
condition|)
name|com_letter
operator||=
literal|0x04
expr_stmt|;
end_if

begin_expr_stmt
name|XSET
argument_list|(
name|tempx
argument_list|,
name|Lisp_Int
argument_list|,
name|min
argument_list|(
name|screen_width
operator|-
literal|1
argument_list|,
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|event
operator|.
name|xbutton
operator|.
name|x
operator|-
name|XXInternalBorder
operator|)
operator|/
name|XXfontw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSET
argument_list|(
name|tempy
argument_list|,
name|Lisp_Int
argument_list|,
name|min
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|,
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|event
operator|.
name|xbutton
operator|.
name|y
operator|-
name|XXInternalBorder
operator|)
operator|/
name|XXfonth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Vx_mouse_pos
operator|=
name|Fcons
argument_list|(
name|tempx
argument_list|,
name|Fcons
argument_list|(
name|tempy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSET
argument_list|(
name|tempx
argument_list|,
name|Lisp_Int
argument_list|,
name|event
operator|.
name|xbutton
operator|.
name|x_root
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSET
argument_list|(
name|tempy
argument_list|,
name|Lisp_Int
argument_list|,
name|event
operator|.
name|xbutton
operator|.
name|y_root
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Vx_mouse_abs_pos
operator|=
name|Fcons
argument_list|(
name|tempx
argument_list|,
name|Fcons
argument_list|(
name|tempy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Vx_mouse_item
operator|=
name|make_number
argument_list|(
name|com_letter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mouse_cmd
operator|=
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|MouseMap
argument_list|,
name|com_letter
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|NULL
argument_list|(
name|mouse_cmd
argument_list|)
condition|)
block|{
if|if
condition|(
name|event
operator|.
name|type
operator|!=
name|ButtonRelease
condition|)
name|bell
argument_list|()
expr_stmt|;
name|Vx_mouse_pos
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
return|return
name|call1
argument_list|(
name|mouse_cmd
argument_list|,
name|Vx_mouse_pos
argument_list|)
return|;
end_if

begin_expr_stmt
unit|} 	return
name|Qnil
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"x-get-mouse-event"
operator|,
name|Fx_get_mouse_event
operator|,
name|Sx_get_mouse_event
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"Get next mouse event out of mouse event buffer (com-letter (x y)).\n\ ARG non-nil means return nil immediately if no pending event;\n\ otherwise, wait for an event."
operator|)
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|XEvent
name|event
decl_stmt|;
specifier|register
name|char
name|com_letter
decl_stmt|;
specifier|register
name|char
name|key_mask
decl_stmt|;
specifier|register
name|Lisp_Object
name|tempx
decl_stmt|;
specifier|register
name|Lisp_Object
name|tempy
decl_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
while|while
condition|(
operator|!
name|XXm_queue_num
condition|)
block|{
name|consume_available_input
argument_list|()
expr_stmt|;
name|Fsleep_for
argument_list|(
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*** ??? Surely you don't mean to busy wait??? */
if|if
condition|(
name|XXm_queue_num
condition|)
block|{
name|event
operator|=
operator|*
name|XXm_queue
index|[
name|XXm_queue_out
index|]
expr_stmt|;
name|free
argument_list|(
name|XXm_queue
index|[
name|XXm_queue_out
index|]
argument_list|)
expr_stmt|;
name|XXm_queue_out
operator|=
operator|(
name|XXm_queue_out
operator|+
literal|1
operator|)
operator|%
name|XMOUSEBUFSIZE
expr_stmt|;
name|XXm_queue_num
operator|--
expr_stmt|;
name|com_letter
operator|=
literal|3
operator|-
operator|(
name|event
operator|.
name|xbutton
operator|.
name|button
operator|&
literal|3
operator|)
expr_stmt|;
name|key_mask
operator|=
operator|(
name|event
operator|.
name|xbutton
operator|.
name|state
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
comment|/* Report meta in 2 bit, not in 8 bit.  */
if|if
condition|(
name|key_mask
operator|&
literal|0x80
condition|)
block|{
name|key_mask
operator||=
literal|0x20
expr_stmt|;
name|key_mask
operator|&=
operator|~
literal|0x80
expr_stmt|;
block|}
name|com_letter
operator||=
name|key_mask
expr_stmt|;
if|if
condition|(
name|event
operator|.
name|type
operator|==
name|ButtonRelease
condition|)
name|com_letter
operator||=
literal|0x04
expr_stmt|;
name|XSET
argument_list|(
name|tempx
argument_list|,
name|Lisp_Int
argument_list|,
name|min
argument_list|(
name|screen_width
operator|-
literal|1
argument_list|,
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|event
operator|.
name|xbutton
operator|.
name|x
operator|-
name|XXInternalBorder
operator|)
operator|/
name|XXfontw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempy
argument_list|,
name|Lisp_Int
argument_list|,
name|min
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|,
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|event
operator|.
name|xbutton
operator|.
name|y
operator|-
name|XXInternalBorder
operator|)
operator|/
name|XXfonth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Vx_mouse_pos
operator|=
name|Fcons
argument_list|(
name|tempx
argument_list|,
name|Fcons
argument_list|(
name|tempy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempx
argument_list|,
name|Lisp_Int
argument_list|,
name|event
operator|.
name|xbutton
operator|.
name|x_root
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempy
argument_list|,
name|Lisp_Int
argument_list|,
name|event
operator|.
name|xbutton
operator|.
name|y_root
argument_list|)
expr_stmt|;
name|Vx_mouse_abs_pos
operator|=
name|Fcons
argument_list|(
name|tempx
argument_list|,
name|Fcons
argument_list|(
name|tempy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|Vx_mouse_item
operator|=
name|make_number
argument_list|(
name|com_letter
argument_list|)
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|com_letter
argument_list|,
name|Fcons
argument_list|(
name|Vx_mouse_pos
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-store-cut-buffer"
argument_list|,
name|Fx_store_cut_buffer
argument_list|,
name|Sx_store_cut_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSend string to X:"
argument_list|,
literal|"Store contents of STRING into the cut buffer of the X window system."
argument_list|)
argument_list|(
name|string
argument_list|)
specifier|register
name|Lisp_Object
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XStoreBytes
argument_list|(
name|XXdisplay
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Clear the selection owner, so that other applications 	   will use the cut buffer rather than a selection.  */
name|XSetSelectionOwner
argument_list|(
name|XXdisplay
argument_list|,
name|XA_PRIMARY
argument_list|,
name|None
argument_list|,
name|CurrentTime
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-cut-buffer"
argument_list|,
argument|Fx_get_cut_buffer
argument_list|,
argument|Sx_get_cut_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return contents of cut buffer of the X window system, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|int
name|len
block|;
specifier|register
name|Lisp_Object
name|string
block|;
name|BLOCK_INPUT_DECLARE
argument_list|()
block|;
specifier|register
name|char
operator|*
name|d
block|;
name|check_xterm
argument_list|()
block|;
name|BLOCK_INPUT
argument_list|()
block|;
name|d
operator|=
name|XFetchBytes
argument_list|(
name|XXdisplay
argument_list|,
operator|&
name|len
argument_list|)
block|;
name|string
operator|=
name|make_string
argument_list|(
name|d
argument_list|,
name|len
argument_list|)
block|;
name|UNBLOCK_INPUT
argument_list|()
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-set-border-width"
argument_list|,
name|Fx_set_border_width
argument_list|,
name|Sx_set_border_width
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"nBorder width: "
argument_list|,
literal|"Set width of border to WIDTH, in the X window system."
argument_list|)
argument_list|(
name|borderwidth
argument_list|)
specifier|register
name|Lisp_Object
name|borderwidth
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|borderwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|borderwidth
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|borderwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XSetWindowBorderWidth
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XINT
argument_list|(
name|borderwidth
argument_list|)
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-set-internal-border-width"
argument_list|,
name|Fx_set_internal_border_width
argument_list|,
name|Sx_set_internal_border_width
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"nInternal border width: "
argument_list|,
literal|"Set width of internal border to WIDTH, in the X window system."
argument_list|)
argument_list|(
name|internalborderwidth
argument_list|)
specifier|register
name|Lisp_Object
name|internalborderwidth
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|internalborderwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|internalborderwidth
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|internalborderwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XXInternalBorder
operator|=
name|XINT
argument_list|(
name|internalborderwidth
argument_list|)
expr_stmt|;
name|XSetWindowSize
argument_list|(
name|screen_height
argument_list|,
name|screen_width
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|foobar
end_ifdef

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-rebind-key"
argument_list|,
name|Fx_rebind_key
argument_list|,
name|Sx_rebind_key
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Rebind KEYCODE, with shift bits SHIFT-MASK, to new string NEWSTRING.\n\ KEYCODE and SHIFT-MASK should be numbers representing the X keyboard code\n\ and shift mask respectively.  NEWSTRING is an arbitrary string of keystrokes.\n\ If SHIFT-MASK is nil, then KEYCODE's key will be bound to NEWSTRING for\n\ all shift combinations.\n\ Shift Lock  1	   Shift    2\n\ Meta	    4	   Control  8\n\ \n\ For values of KEYCODE, see /usr/lib/Xkeymap.txt (remember that the codes\n\ in that file are in octal!)\n"
argument_list|)
argument_list|(
name|keycode
argument_list|,
name|shift_mask
argument_list|,
name|newstring
argument_list|)
specifier|register
name|Lisp_Object
name|keycode
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|shift_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|newstring
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|notdef
name|char
modifier|*
name|rawstring
decl_stmt|;
name|int
name|rawkey
decl_stmt|,
name|rawshift
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|strsize
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|keycode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|shift_mask
argument_list|)
condition|)
name|CHECK_NUMBER
argument_list|(
name|shift_mask
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newstring
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|strsize
operator|=
name|XSTRING
argument_list|(
name|newstring
argument_list|)
operator|->
name|size
expr_stmt|;
name|rawstring
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|newstring
argument_list|)
operator|->
name|data
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
name|rawkey
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|XINT
argument_list|(
name|keycode
argument_list|)
argument_list|)
operator|)
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|shift_mask
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|15
condition|;
name|i
operator|++
control|)
name|XRebindCode
argument_list|(
name|rawkey
argument_list|,
name|i
operator|<<
literal|11
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
else|else
block|{
name|rawshift
operator|=
operator|(
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|XINT
argument_list|(
name|shift_mask
argument_list|)
argument_list|)
operator|)
operator|&
literal|15
operator|)
operator|<<
literal|11
expr_stmt|;
name|XRebindCode
argument_list|(
name|rawkey
argument_list|,
name|rawshift
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|notdef
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-rebind-keys"
argument_list|,
name|Fx_rebind_keys
argument_list|,
name|Sx_rebind_keys
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Rebind KEYCODE to list of strings STRINGS.\n\ STRINGS should be a list of 16 elements, one for each all shift combination.\n\ nil as element means don't change.\n\ See the documentation of x-rebind-key for more information."
argument_list|)
argument_list|(
name|keycode
argument_list|,
name|strings
argument_list|)
specifier|register
name|Lisp_Object
name|keycode
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|strings
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|notdef
specifier|register
name|Lisp_Object
name|item
decl_stmt|;
specifier|register
name|char
modifier|*
name|rawstring
decl_stmt|;
name|int
name|rawkey
decl_stmt|,
name|strsize
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|keycode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_CONS
argument_list|(
name|strings
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|rawkey
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|XINT
argument_list|(
name|keycode
argument_list|)
argument_list|)
operator|)
operator|&
literal|255
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|15
condition|;
name|strings
operator|=
name|Fcdr
argument_list|(
name|strings
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|item
operator|=
name|Fcar
argument_list|(
name|strings
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|CHECK_STRING
argument_list|(
name|item
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|strsize
operator|=
name|XSTRING
argument_list|(
name|item
argument_list|)
operator|->
name|size
expr_stmt|;
name|rawstring
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|item
argument_list|)
operator|->
name|data
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
name|XRebindCode
argument_list|(
name|rawkey
argument_list|,
name|i
operator|<<
literal|11
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|notdef
return|return
name|Qnil
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|foobar
end_endif

begin_macro
name|XExitWithCoreDump
argument_list|()
end_macro

begin_block
block|{
name|XCleanUp
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-debug"
argument_list|,
name|Fx_debug
argument_list|,
name|Sx_debug
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"ARG non-nil means that X errors should generate a coredump."
argument_list|)
argument_list|(
name|arg
argument_list|)
specifier|register
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
name|check_xterm
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|handler
operator|=
name|XExitWithCoreDump
expr_stmt|;
else|else
block|{
specifier|extern
name|int
name|XIgnoreError
parameter_list|()
function_decl|;
name|handler
operator|=
name|XIgnoreError
expr_stmt|;
block|}
name|XSetErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|XSetIOErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
return|return
operator|(
name|Qnil
operator|)
return|;
block|}
end_block

begin_macro
name|XRedrawDisplay
argument_list|()
end_macro

begin_block
block|{
name|Fredraw_display
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|XCleanUp
argument_list|()
end_macro

begin_block
block|{
name|Fdo_auto_save
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|subprocesses
name|kill_buffer_processes
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* subprocesses */
block|}
end_block

begin_macro
name|syms_of_xfns
argument_list|()
end_macro

begin_block
block|{
comment|/* If not dumping, init_display ran before us, so don't override it.  */
ifdef|#
directive|ifdef
name|CANNOT_DUMP
if|if
condition|(
name|noninteractive
condition|)
endif|#
directive|endif
name|Vxterm
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"x-mouse-item"
argument_list|,
operator|&
name|Vx_mouse_item
argument_list|,
literal|"Encoded representation of last mouse click, corresponding to\n\ numerical entries in x-mouse-map."
argument_list|)
expr_stmt|;
name|Vx_mouse_item
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"x-mouse-pos"
argument_list|,
operator|&
name|Vx_mouse_pos
argument_list|,
literal|"Current x-y position of mouse by row, column as specified by font."
argument_list|)
expr_stmt|;
name|Vx_mouse_pos
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"x-mouse-abs-pos"
argument_list|,
operator|&
name|Vx_mouse_abs_pos
argument_list|,
literal|"Current x-y position of mouse relative to root window."
argument_list|)
expr_stmt|;
name|Vx_mouse_abs_pos
operator|=
name|Qnil
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_bell
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_flip_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_font
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|defsubr
argument_list|(
operator|&
name|Sx_set_icon
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
name|defsubr
argument_list|(
operator|&
name|Scoordinates_in_window_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_mouse_events
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_proc_mouse_event
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_mouse_event
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_store_cut_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_cut_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_border_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_internal_border_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_foreground_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_background_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_border_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_cursor_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_mouse_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_foreground_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_background_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_border_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_cursor_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_mouse_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_color_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_default
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|defsubr
argument_list|(
operator|&
name|Sx_rebind_key
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_rebind_keys
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
name|defsubr
argument_list|(
operator|&
name|Sx_debug
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_X_WINDOWS */
end_comment

end_unit

