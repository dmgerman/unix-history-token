begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Work-alike for termcap, plus extra features.    Copyright (C) 1985, 1986 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/* BUFSIZE is the initial size allocated for the buffer    for reading the termcap file.    It is not a limit.    Make it large normally for speed.    Make it variable when debugging, so can exercise    increasing the space dynamically.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BUFSIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|BUFSIZE
value|bufsize
end_define

begin_decl_stmt
name|int
name|bufsize
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUFSIZE
value|2048
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_expr_stmt
specifier|static
name|memory_out
argument_list|()
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Virtual memory exhausted\n"
argument_list|,
literal|25
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; }
specifier|static
name|int
name|xmalloc
argument_list|(
argument|size
argument_list|)
name|int
name|size
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|tem
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|memory_out
argument_list|()
expr_stmt|;
return|return
name|tem
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|int
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|tem
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|memory_out
argument_list|()
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Looking up capabilities in the entry already found */
end_comment

begin_comment
comment|/* The pointer to the data made by tgetent is left here    for tgetnum, tgetflag and tgetstr to find.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_entry
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|tgetst1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This is the main subroutine that is used to search    an entry for a particular capability */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_capability
parameter_list|(
name|bp
parameter_list|,
name|cap
parameter_list|)
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
decl|*
name|cap
decl_stmt|;
end_function

begin_block
block|{
for|for
control|(
init|;
operator|*
name|bp
condition|;
name|bp
operator|++
control|)
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
name|cap
index|[
literal|0
index|]
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
name|cap
index|[
literal|1
index|]
condition|)
return|return
operator|&
name|bp
index|[
literal|4
index|]
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|tgetnum
parameter_list|(
name|cap
parameter_list|)
name|char
modifier|*
name|cap
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|find_capability
argument_list|(
name|term_entry
argument_list|,
name|cap
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'#'
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|atoi
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|tgetflag
parameter_list|(
name|cap
parameter_list|)
name|char
modifier|*
name|cap
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|find_capability
argument_list|(
name|term_entry
argument_list|,
name|cap
argument_list|)
decl_stmt|;
return|return
literal|0
operator|!=
name|ptr
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
return|;
block|}
end_function

begin_comment
comment|/* Look up a string-valued capability `cap'.    If `area' is nonzero, it points to a pointer to a block in which    to store the string.  That pointer is advanced over the space used.    If `area' is zero, space is allocated with `malloc'.  */
end_comment

begin_function
name|char
modifier|*
name|tgetstr
parameter_list|(
name|cap
parameter_list|,
name|area
parameter_list|)
name|char
modifier|*
name|cap
decl_stmt|;
name|char
modifier|*
modifier|*
name|area
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|find_capability
argument_list|(
name|term_entry
argument_list|,
name|cap
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
operator|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'='
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'~'
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|tgetst1
argument_list|(
name|ptr
argument_list|,
name|area
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Table, indexed by a character in range 0100 to 0140 with 0100 subtracted,    gives meaning of character following \, or a space if no special meaning.    Eight characters per line within the string.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|esctab
index|[]
init|=
literal|" \007\010  \033\014 \       \012 \   \015 \011 \013 \         "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a pointer to a string value inside a termcap entry (`ptr'),    copy the value and process \ and ^ abbreviations.    Copy into block that *area points to,    or to newly allocated storage if area is 0.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|tgetst1
parameter_list|(
name|ptr
parameter_list|,
name|area
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|area
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
specifier|register
name|int
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
literal|0
return|;
comment|/* `ret' gets address of where to store the string */
if|if
condition|(
operator|!
name|area
condition|)
block|{
comment|/* Compute size of block needed (may overestimate) */
name|p
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|p
operator|-
name|ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
operator|*
name|area
expr_stmt|;
comment|/* Copy the string value, stopping at null or colon.  */
comment|/* Also process ^ and \ abbreviations.  */
name|p
operator|=
name|ptr
expr_stmt|;
name|r
operator|=
name|ret
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
name|c
operator|=
operator|*
name|p
operator|++
operator|&
literal|037
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|++
name|size
operator|<
literal|3
operator|&&
operator|(
name|c1
operator|=
operator|*
name|p
operator|)
operator|>=
literal|'0'
operator|&&
name|c1
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|*=
literal|8
expr_stmt|;
name|c
operator|+=
name|c1
operator|-
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|0100
operator|&&
name|c
operator|<
literal|0200
condition|)
block|{
name|c1
operator|=
name|esctab
index|[
operator|(
name|c
operator|&
operator|~
literal|040
operator|)
operator|-
literal|0100
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|' '
condition|)
name|c
operator|=
name|c1
expr_stmt|;
block|}
block|}
operator|*
name|r
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|r
operator|=
literal|0
expr_stmt|;
comment|/* Update *area */
if|if
condition|(
name|area
condition|)
operator|*
name|area
operator|=
name|r
operator|+
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Outputting a string with padding */
end_comment

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Actual baud rate if positive;    - baud rate / 100 if negative.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|speeds
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|VMS
literal|0
block|,
literal|50
block|,
literal|75
block|,
literal|110
block|,
literal|134
block|,
literal|150
block|,
operator|-
literal|3
block|,
operator|-
literal|6
block|,
operator|-
literal|12
block|,
operator|-
literal|18
block|,
operator|-
literal|20
block|,
operator|-
literal|24
block|,
operator|-
literal|36
block|,
operator|-
literal|48
block|,
operator|-
literal|72
block|,
operator|-
literal|96
block|,
operator|-
literal|192
else|#
directive|else
comment|/* not VMS */
literal|0
block|,
literal|50
block|,
literal|75
block|,
literal|110
block|,
literal|135
block|,
literal|150
block|,
operator|-
literal|2
block|,
operator|-
literal|3
block|,
operator|-
literal|6
block|,
operator|-
literal|12
block|,
operator|-
literal|18
block|,
operator|-
literal|24
block|,
operator|-
literal|48
block|,
operator|-
literal|96
block|,
operator|-
literal|192
block|,
operator|-
literal|384
endif|#
directive|endif
comment|/* not VMS */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|tputs
argument_list|(
name|string
argument_list|,
name|nlines
argument_list|,
name|outfun
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nlines
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|register
name|int
function_decl|(
modifier|*
name|outfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|int
name|padcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return;
while|while
condition|(
operator|*
name|string
operator|>=
literal|'0'
operator|&&
operator|*
name|string
operator|<=
literal|'9'
condition|)
block|{
name|padcount
operator|+=
operator|*
name|string
operator|++
operator|-
literal|'0'
expr_stmt|;
name|padcount
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string
operator|==
literal|'.'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|padcount
operator|+=
operator|*
name|string
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string
operator|==
literal|'*'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|padcount
operator|*=
name|nlines
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|string
condition|)
call|(
modifier|*
name|outfun
call|)
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
comment|/* padcount is now in units of tenths of msec.  */
name|padcount
operator|*=
name|speeds
index|[
name|ospeed
index|]
expr_stmt|;
name|padcount
operator|+=
literal|500
expr_stmt|;
name|padcount
operator|/=
literal|1000
expr_stmt|;
if|if
condition|(
name|speeds
index|[
name|ospeed
index|]
operator|<
literal|0
condition|)
name|padcount
operator|=
operator|-
name|padcount
expr_stmt|;
else|else
block|{
name|padcount
operator|+=
literal|50
expr_stmt|;
name|padcount
operator|/=
literal|100
expr_stmt|;
block|}
while|while
condition|(
name|padcount
operator|--
operator|>
literal|0
condition|)
call|(
modifier|*
name|outfun
call|)
argument_list|(
name|PC
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Finding the termcap entry in the termcap data base */
end_comment

begin_struct
struct|struct
name|buffer
block|{
name|char
modifier|*
name|beg
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|ateof
decl_stmt|;
name|int
name|full
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations of static functions */
end_comment

begin_function_decl
specifier|static
name|int
name|scan_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gobble_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_contin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|name_match
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<rmsdef.h>
end_include

begin_include
include|#
directive|include
file|<fab.h>
end_include

begin_include
include|#
directive|include
file|<nam.h>
end_include

begin_function
specifier|static
name|int
name|legal_filename_p
parameter_list|(
name|fn
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
block|{
name|struct
name|FAB
name|fab
init|=
name|cc$rms_fab
decl_stmt|;
name|struct
name|NAM
name|nam
init|=
name|cc$rms_nam
decl_stmt|;
name|char
name|esa
index|[
name|NAM$C_MAXRSS
index|]
decl_stmt|;
name|fab
operator|.
name|fab$l_fna
operator|=
name|fn
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fab
operator|.
name|fab$l_nam
operator|=
operator|&
name|nam
expr_stmt|;
name|fab
operator|.
name|fab$l_fop
operator|=
name|FAB$M_NAM
expr_stmt|;
name|nam
operator|.
name|nam$l_esa
operator|=
name|esa
expr_stmt|;
name|nam
operator|.
name|nam$b_ess
operator|=
sizeof|sizeof
name|esa
expr_stmt|;
return|return
name|SYS$PARSE
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|RMS$_NORMAL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/* Find the termcap entry data for terminal type `name'    and store it in the block that `bp' points to.    Record its address for future use.     If `bp' is zero, space is dynamically allocated.  */
end_comment

begin_function
name|int
name|tgetent
parameter_list|(
name|bp
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|bp
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|tem
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|struct
name|buffer
name|buf
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp1
decl_stmt|;
name|char
modifier|*
name|bp2
decl_stmt|;
name|char
modifier|*
name|term
decl_stmt|;
name|int
name|malloc_size
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|tcenv
decl_stmt|;
comment|/* TERMCAP value, if it contais :tc=.  */
name|char
modifier|*
name|indirect
init|=
literal|0
decl_stmt|;
comment|/* Terminal type in :tc= in TERMCAP value.  */
name|int
name|filep
decl_stmt|;
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TERMCAP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
operator|*
name|tem
operator|==
literal|0
condition|)
name|tem
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|filep
operator|=
name|tem
operator|&&
name|legal_filename_p
argument_list|(
name|tem
argument_list|)
expr_stmt|;
else|#
directive|else
name|filep
operator|=
name|tem
operator|&&
operator|(
operator|*
name|tem
operator|==
literal|'/'
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
comment|/* If tem is non-null and starts with / (in the un*x case, that is),      it is a file name to use instead of /etc/termcap.      If it is non-null and does not start with /,      it is the entry itself, but only if      the name the caller requested matches the TERM variable.  */
if|if
condition|(
name|tem
operator|&&
operator|!
name|filep
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
condition|)
block|{
name|indirect
operator|=
name|tgetst1
argument_list|(
name|find_capability
argument_list|(
name|tem
argument_list|,
literal|"tc"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indirect
condition|)
block|{
if|if
condition|(
operator|!
name|bp
condition|)
name|bp
operator|=
name|tem
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|bp
argument_list|,
name|tem
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
comment|/* we will need to read /etc/termcap */
name|tcenv
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|indirect
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
ifdef|#
directive|ifdef
name|VMS
name|tem
operator|=
literal|"emacs_library:[etc]termcap.dat"
expr_stmt|;
else|#
directive|else
name|tem
operator|=
literal|"/etc/termcap"
expr_stmt|;
endif|#
directive|endif
comment|/* Here we know we must search a file and tem has its name.  */
name|fd
operator|=
name|open
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|buf
operator|.
name|size
operator|=
name|BUFSIZE
expr_stmt|;
comment|/* Add 1 to size to ensure room for terminating null.  */
name|buf
operator|.
name|beg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buf
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|term
operator|=
name|indirect
condition|?
name|indirect
else|:
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
name|malloc_size
operator|=
name|indirect
condition|?
name|strlen
argument_list|(
name|tcenv
argument_list|)
operator|+
literal|1
else|:
name|buf
operator|.
name|size
expr_stmt|;
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|malloc_size
argument_list|)
expr_stmt|;
block|}
name|bp1
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
comment|/* copy the data from the environment variable */
block|{
name|strcpy
argument_list|(
name|bp
argument_list|,
name|tcenv
argument_list|)
expr_stmt|;
name|bp1
operator|+=
name|strlen
argument_list|(
name|tcenv
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|term
condition|)
block|{
comment|/* Scan file, reading it via buf, till find start of main entry */
if|if
condition|(
name|scan_file
argument_list|(
name|term
argument_list|,
name|fd
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Free old `term' if appropriate.  */
if|if
condition|(
name|term
operator|!=
name|name
condition|)
name|free
argument_list|(
name|term
argument_list|)
expr_stmt|;
comment|/* If `bp' is malloc'd by us, make sure it is big enough.  */
if|if
condition|(
name|malloc_size
condition|)
block|{
name|malloc_size
operator|=
name|bp1
operator|-
name|bp
operator|+
name|buf
operator|.
name|size
expr_stmt|;
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|bp
argument_list|,
name|malloc_size
argument_list|)
expr_stmt|;
name|bp1
operator|+=
name|tem
operator|-
name|bp
expr_stmt|;
name|bp
operator|=
name|tem
expr_stmt|;
block|}
name|bp2
operator|=
name|bp1
expr_stmt|;
comment|/* Copy the line of the entry from buf into bp.  */
name|tem
operator|=
name|buf
operator|.
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|bp1
operator|++
operator|=
name|c
operator|=
operator|*
name|tem
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
comment|/* Drop out any \ newline sequence. */
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|*
name|tem
operator|==
literal|'\n'
condition|)
block|{
name|bp1
operator|--
expr_stmt|;
name|tem
operator|++
expr_stmt|;
block|}
operator|*
name|bp1
operator|=
literal|0
expr_stmt|;
comment|/* Does this entry refer to another terminal type's entry?  */
comment|/* If something is found, copy it into heap and null-terminate it */
name|term
operator|=
name|tgetst1
argument_list|(
name|find_capability
argument_list|(
name|bp2
argument_list|,
literal|"tc"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_size
condition|)
block|{
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|bp
argument_list|,
name|bp1
operator|-
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
label|:
name|term_entry
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|malloc_size
condition|)
return|return
operator|(
name|int
operator|)
name|bp
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Given file open on `fd' and buffer `bufp',    scan the file from the beginning until a line is found    that starts the entry for terminal type `string'.    Returns 1 if successful, with that line in `bufp',    or returns 0 if no entry found in the file.  */
end_comment

begin_function
specifier|static
name|int
name|scan_file
parameter_list|(
name|string
parameter_list|,
name|fd
parameter_list|,
name|bufp
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|bufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|tem
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
name|bufp
operator|->
name|ptr
operator|=
name|bufp
operator|->
name|beg
expr_stmt|;
name|bufp
operator|->
name|full
operator|=
literal|0
expr_stmt|;
name|bufp
operator|->
name|ateof
operator|=
literal|0
expr_stmt|;
operator|*
name|bufp
operator|->
name|ptr
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|bufp
operator|->
name|ateof
condition|)
block|{
comment|/* Read a line into the buffer */
name|end
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* if it is continued, append another line to it, 	     until a non-continued line ends */
name|end
operator|=
name|gobble_line
argument_list|(
name|fd
argument_list|,
name|bufp
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|bufp
operator|->
name|ateof
operator|&&
name|end
index|[
operator|-
literal|2
index|]
operator|==
literal|'\\'
condition|)
do|;
if|if
condition|(
operator|*
name|bufp
operator|->
name|ptr
operator|!=
literal|'#'
operator|&&
name|name_match
argument_list|(
name|bufp
operator|->
name|ptr
argument_list|,
name|string
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Discard the line just processed */
name|bufp
operator|->
name|ptr
operator|=
name|end
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if NAME is one of the names specified    by termcap entry LINE.  */
end_comment

begin_function
specifier|static
name|int
name|name_match
parameter_list|(
name|line
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
operator|!
name|compare_contin
argument_list|(
name|line
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* This line starts an entry.  Is it the right one?  */
for|for
control|(
name|tem
operator|=
name|line
init|;
operator|*
name|tem
operator|&&
operator|*
name|tem
operator|!=
literal|'\n'
operator|&&
operator|*
name|tem
operator|!=
literal|':'
condition|;
name|tem
operator|++
control|)
if|if
condition|(
operator|*
name|tem
operator|==
literal|'|'
operator|&&
operator|!
name|compare_contin
argument_list|(
name|tem
operator|+
literal|1
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|compare_contin
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
specifier|register
name|char
modifier|*
name|str1
decl_stmt|,
decl|*
name|str2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c1
operator|=
operator|*
name|str1
operator|++
expr_stmt|;
name|c2
operator|=
operator|*
name|str2
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|==
literal|'\\'
operator|&&
operator|*
name|str1
operator|==
literal|'\n'
condition|)
block|{
name|str1
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c1
operator|=
operator|*
name|str1
operator|++
operator|)
operator|==
literal|' '
operator|||
name|c1
operator|==
literal|'\t'
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|c2
operator|==
literal|'\0'
condition|)
comment|/* end of type being looked up */
block|{
if|if
condition|(
name|c1
operator|==
literal|'|'
operator|||
name|c1
operator|==
literal|':'
condition|)
comment|/* If end of name in data base, */
return|return
literal|0
return|;
comment|/* we win. */
else|else
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
literal|1
return|;
block|}
block|}
end_block

begin_comment
comment|/* Make sure that the buffer<- `bufp' contains a full line    of the file open on `fd', starting at the place `bufp->ptr'    points to.  Can read more of the file, discard stuff before    `bufp->ptr', or make the buffer bigger.     Returns the pointer to after the newline ending the line,    or to the end of the file, if there is no newline to end it.     Can also merge on continuation lines.  If `append_end' is    nonzero, it points past the newline of a line that is    continued; we add another line onto it and regard the whole    thing as one line.  The caller decides when a line is continued.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gobble_line
parameter_list|(
name|fd
parameter_list|,
name|bufp
parameter_list|,
name|append_end
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|bufp
decl_stmt|;
name|char
modifier|*
name|append_end
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|nread
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
init|=
name|bufp
operator|->
name|beg
decl_stmt|;
specifier|register
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|append_end
operator|==
literal|0
condition|)
name|append_end
operator|=
name|bufp
operator|->
name|ptr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|end
operator|=
name|append_end
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|&&
operator|*
name|end
operator|!=
literal|'\n'
condition|)
name|end
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
break|break;
if|if
condition|(
name|bufp
operator|->
name|ateof
condition|)
return|return
name|buf
operator|+
name|bufp
operator|->
name|full
return|;
if|if
condition|(
name|bufp
operator|->
name|ptr
operator|==
name|buf
condition|)
block|{
if|if
condition|(
name|bufp
operator|->
name|full
operator|==
name|bufp
operator|->
name|size
condition|)
block|{
name|bufp
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
comment|/* Add 1 to size to ensure room for terminating null.  */
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bufp
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufp
operator|->
name|ptr
operator|=
operator|(
name|bufp
operator|->
name|ptr
operator|-
name|buf
operator|)
operator|+
name|tem
expr_stmt|;
name|append_end
operator|=
operator|(
name|append_end
operator|-
name|buf
operator|)
operator|+
name|tem
expr_stmt|;
name|bufp
operator|->
name|beg
operator|=
name|buf
operator|=
name|tem
expr_stmt|;
block|}
block|}
else|else
block|{
name|append_end
operator|-=
name|bufp
operator|->
name|ptr
operator|-
name|buf
expr_stmt|;
name|bcopy
argument_list|(
name|bufp
operator|->
name|ptr
argument_list|,
name|buf
argument_list|,
name|bufp
operator|->
name|full
operator|-=
name|bufp
operator|->
name|ptr
operator|-
name|buf
argument_list|)
expr_stmt|;
name|bufp
operator|->
name|ptr
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
operator|+
name|bufp
operator|->
name|full
argument_list|,
name|bufp
operator|->
name|size
operator|-
name|bufp
operator|->
name|full
argument_list|)
operator|)
condition|)
name|bufp
operator|->
name|ateof
operator|=
literal|1
expr_stmt|;
name|bufp
operator|->
name|full
operator|+=
name|nread
expr_stmt|;
name|buf
index|[
name|bufp
operator|->
name|full
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|end
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|term
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|term
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"TERM: %s\n"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|tgetent
argument_list|(
literal|0
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|buf
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No entry.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"Entry: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
literal|"cm"
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
literal|"AL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"co: %d\n"
argument_list|,
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"am: %d\n"
argument_list|,
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|tprint
argument_list|(
argument|cap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|x
init|=
name|tgetstr
argument_list|(
name|cap
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|y
decl_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
for|for
control|(
name|y
operator|=
name|x
init|;
operator|*
name|y
condition|;
name|y
operator|++
control|)
if|if
condition|(
operator|*
name|y
operator|<=
literal|' '
operator|||
operator|*
name|y
operator|==
literal|0177
condition|)
name|printf
argument_list|(
literal|"\\%0o"
argument_list|,
operator|*
name|y
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|y
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

