begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Buffer insertion/deletion and gap motion for GNU Emacs.    Copyright (C) 1985, 1986, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_comment
comment|/* Move gap to position `pos'.    Note that this can quit!  */
end_comment

begin_macro
name|move_gap
argument_list|(
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pos
operator|<
name|GPT
condition|)
name|gap_left
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pos
operator|>
name|GPT
condition|)
name|gap_right
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move the gap to POS, which is less than the current GPT.    If NEWGAP is nonzero, then don't update beg_unchanged and end_unchanged.  */
end_comment

begin_expr_stmt
name|gap_left
argument_list|(
name|pos
argument_list|,
name|newgap
argument_list|)
specifier|register
name|int
name|pos
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|newgap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|new_s1
decl_stmt|;
name|pos
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|newgap
condition|)
block|{
if|if
condition|(
name|unchanged_modified
operator|==
name|MODIFF
condition|)
block|{
name|beg_unchanged
operator|=
name|pos
expr_stmt|;
name|end_unchanged
operator|=
name|Z
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Z
operator|-
name|GPT
operator|<
name|end_unchanged
condition|)
name|end_unchanged
operator|=
name|Z
operator|-
name|GPT
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|beg_unchanged
condition|)
name|beg_unchanged
operator|=
name|pos
expr_stmt|;
block|}
block|}
name|i
operator|=
name|GPT
expr_stmt|;
name|to
operator|=
name|GAP_END_ADDR
expr_stmt|;
name|from
operator|=
name|GPT_ADDR
expr_stmt|;
name|new_s1
operator|=
name|GPT
operator|-
name|BEG
expr_stmt|;
comment|/* Now copy the characters.  To move the gap down,      copy characters up.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* I gets number of characters left to copy.  */
name|i
operator|=
name|new_s1
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
comment|/* If a quit is requested, stop copying now. 	 Change POS to be where we have actually moved the gap to.  */
if|if
condition|(
name|QUITP
condition|)
block|{
name|pos
operator|=
name|new_s1
expr_stmt|;
break|break;
block|}
comment|/* Move at most 32000 chars before checking again for a quit.  */
if|if
condition|(
name|i
operator|>
literal|32000
condition|)
name|i
operator|=
literal|32000
expr_stmt|;
name|new_s1
operator|-=
name|i
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
operator|--
name|to
operator|=
operator|*
operator|--
name|from
expr_stmt|;
block|}
comment|/* Adjust markers, and buffer data structure, to put the gap at POS.      POS is where the loop above stopped, which may be what was specified      or may be where a quit was detected.  */
name|adjust_markers
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
name|GPT
argument_list|,
name|GAP_SIZE
argument_list|)
expr_stmt|;
name|GPT
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|gap_right
argument_list|(
name|pos
argument_list|)
specifier|register
name|int
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|new_s1
decl_stmt|;
name|pos
operator|--
expr_stmt|;
if|if
condition|(
name|unchanged_modified
operator|==
name|MODIFF
condition|)
block|{
name|beg_unchanged
operator|=
name|pos
expr_stmt|;
name|end_unchanged
operator|=
name|Z
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Z
operator|-
name|pos
operator|-
literal|1
operator|<
name|end_unchanged
condition|)
name|end_unchanged
operator|=
name|Z
operator|-
name|pos
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|GPT
operator|-
name|BEG
operator|<
name|beg_unchanged
condition|)
name|beg_unchanged
operator|=
name|GPT
operator|-
name|BEG
expr_stmt|;
block|}
name|i
operator|=
name|GPT
expr_stmt|;
name|from
operator|=
name|GAP_END_ADDR
expr_stmt|;
name|to
operator|=
name|GPT_ADDR
expr_stmt|;
name|new_s1
operator|=
name|GPT
operator|-
literal|1
expr_stmt|;
comment|/* Now copy the characters.  To move the gap up,      copy characters down.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* I gets number of characters left to copy.  */
name|i
operator|=
name|pos
operator|-
name|new_s1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
comment|/* If a quit is requested, stop copying now. 	 Change POS to be where we have actually moved the gap to.  */
if|if
condition|(
name|QUITP
condition|)
block|{
name|pos
operator|=
name|new_s1
expr_stmt|;
break|break;
block|}
comment|/* Move at most 32000 chars before checking again for a quit.  */
if|if
condition|(
name|i
operator|>
literal|32000
condition|)
name|i
operator|=
literal|32000
expr_stmt|;
name|new_s1
operator|+=
name|i
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
name|adjust_markers
argument_list|(
name|GPT
operator|+
name|GAP_SIZE
argument_list|,
name|pos
operator|+
literal|1
operator|+
name|GAP_SIZE
argument_list|,
operator|-
name|GAP_SIZE
argument_list|)
expr_stmt|;
name|GPT
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add `amount' to the position of every marker in the current buffer    whose current position is between `from' (exclusive) and `to' (inclusive).    Also, any markers past the outside of that interval, in the direction    of adjustment, are first moved back to the near end of the interval    and then adjusted by `amount'.  */
end_comment

begin_expr_stmt
name|adjust_markers
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|amount
argument_list|)
specifier|register
name|int
name|from
operator|,
name|to
operator|,
name|amount
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|marker
decl_stmt|;
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|mpos
decl_stmt|;
name|marker
operator|=
name|current_buffer
operator|->
name|markers
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|marker
argument_list|)
condition|)
block|{
name|m
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|mpos
operator|=
name|m
operator|->
name|bufpos
expr_stmt|;
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mpos
operator|>
name|to
operator|&&
name|mpos
operator|<
name|to
operator|+
name|amount
condition|)
name|mpos
operator|=
name|to
operator|+
name|amount
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mpos
operator|>
name|from
operator|+
name|amount
operator|&&
name|mpos
operator|<=
name|from
condition|)
name|mpos
operator|=
name|from
operator|+
name|amount
expr_stmt|;
block|}
if|if
condition|(
name|mpos
operator|>
name|from
operator|&&
name|mpos
operator|<=
name|to
condition|)
name|mpos
operator|+=
name|amount
expr_stmt|;
name|m
operator|->
name|bufpos
operator|=
name|mpos
expr_stmt|;
name|marker
operator|=
name|m
operator|->
name|chain
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make the gap INCREMENT characters longer.  */
end_comment

begin_macro
name|make_gap
argument_list|(
argument|increment
argument_list|)
end_macro

begin_decl_stmt
name|int
name|increment
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|memory
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|int
name|real_gap_loc
decl_stmt|;
name|int
name|old_gap_size
decl_stmt|;
comment|/* If we have to get more space, get enough to last a while.  */
name|increment
operator|+=
literal|2000
expr_stmt|;
name|memory
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|BEG_ADDR
argument_list|,
name|Z
operator|-
name|BEG
operator|+
name|GAP_SIZE
operator|+
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory
operator|==
literal|0
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|BEG_ADDR
operator|=
name|memory
expr_stmt|;
comment|/* Prevent quitting in move_gap.  */
name|tem
operator|=
name|Vinhibit_quit
expr_stmt|;
name|Vinhibit_quit
operator|=
name|Qt
expr_stmt|;
name|real_gap_loc
operator|=
name|GPT
expr_stmt|;
name|old_gap_size
operator|=
name|GAP_SIZE
expr_stmt|;
comment|/* Call the newly allocated space a gap at the end of the whole space.  */
name|GPT
operator|=
name|Z
operator|+
name|GAP_SIZE
expr_stmt|;
name|GAP_SIZE
operator|=
name|increment
expr_stmt|;
comment|/* Move the new gap down to be consecutive with the end of the old one.      This adjusts the markers properly too.  */
name|gap_left
argument_list|(
name|real_gap_loc
operator|+
name|old_gap_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now combine the two into one large gap.  */
name|GAP_SIZE
operator|+=
name|old_gap_size
expr_stmt|;
name|GPT
operator|=
name|real_gap_loc
expr_stmt|;
name|Vinhibit_quit
operator|=
name|tem
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Insert the character c before point */
end_comment

begin_macro
name|insert_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|insert
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert the null-terminated string s before point */
end_comment

begin_macro
name|InsStr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|insert
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert a string of specified length before point */
end_comment

begin_expr_stmt
name|insert
argument_list|(
name|string
argument_list|,
name|length
argument_list|)
specifier|register
name|unsigned
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|length
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|temp
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
return|return;
comment|/* Make sure point-max won't overflow after this insertion.  */
name|XSET
argument_list|(
name|temp
argument_list|,
name|Lisp_Int
argument_list|,
name|length
operator|+
name|Z
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|+
name|Z
operator|!=
name|XINT
argument_list|(
name|temp
argument_list|)
condition|)
name|error
argument_list|(
literal|"maximum buffer size exceeded"
argument_list|)
expr_stmt|;
name|prepare_to_modify_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|point
operator|!=
name|GPT
condition|)
name|move_gap
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|GAP_SIZE
operator|<
name|length
condition|)
name|make_gap
argument_list|(
name|length
operator|-
name|GAP_SIZE
argument_list|)
expr_stmt|;
name|record_insert
argument_list|(
name|point
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|MODIFF
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
name|GPT_ADDR
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|GAP_SIZE
operator|-=
name|length
expr_stmt|;
name|GPT
operator|+=
name|length
expr_stmt|;
name|ZV
operator|+=
name|length
expr_stmt|;
name|Z
operator|+=
name|length
expr_stmt|;
name|point
operator|+=
name|length
expr_stmt|;
block|}
end_block

begin_comment
comment|/* like insert except that all markers pointing at the place where    the insertion happens are adjusted to point after it.  */
end_comment

begin_macro
name|insert_before_markers
argument_list|(
argument|string
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|opoint
init|=
name|point
decl_stmt|;
name|insert
argument_list|(
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|adjust_markers
argument_list|(
name|opoint
operator|-
literal|1
argument_list|,
name|opoint
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Delete characters in current buffer   from `from' up to (but not incl) `to' */
end_comment

begin_expr_stmt
name|del_range
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|int
name|from
operator|,
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|numdel
decl_stmt|;
comment|/* Make args be valid */
if|if
condition|(
name|from
operator|<
name|BEGV
condition|)
name|from
operator|=
name|BEGV
expr_stmt|;
if|if
condition|(
name|to
operator|>
name|ZV
condition|)
name|to
operator|=
name|ZV
expr_stmt|;
if|if
condition|(
operator|(
name|numdel
operator|=
name|to
operator|-
name|from
operator|)
operator|<=
literal|0
condition|)
return|return;
comment|/* Make sure the gap is somewhere in or next to what we are deleting */
if|if
condition|(
name|from
operator|>
name|GPT
condition|)
name|gap_right
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|<
name|GPT
condition|)
name|gap_left
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prepare_to_modify_buffer
argument_list|()
expr_stmt|;
name|record_delete
argument_list|(
name|from
argument_list|,
name|numdel
argument_list|)
expr_stmt|;
name|MODIFF
operator|++
expr_stmt|;
comment|/* Relocate point as if it were a marker.  */
if|if
condition|(
name|from
operator|<
name|point
condition|)
block|{
if|if
condition|(
name|point
operator|<
name|to
condition|)
name|point
operator|=
name|from
expr_stmt|;
else|else
name|point
operator|-=
name|numdel
expr_stmt|;
block|}
comment|/* Relocate all markers pointing into the new, larger gap      to point at the end of the text before the gap.  */
name|adjust_markers
argument_list|(
name|to
operator|+
name|GAP_SIZE
argument_list|,
name|to
operator|+
name|GAP_SIZE
argument_list|,
operator|-
name|numdel
operator|-
name|GAP_SIZE
argument_list|)
expr_stmt|;
name|GAP_SIZE
operator|+=
name|numdel
expr_stmt|;
name|ZV
operator|-=
name|numdel
expr_stmt|;
name|Z
operator|-=
name|numdel
expr_stmt|;
name|GPT
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|GPT
operator|-
name|BEG
operator|<
name|beg_unchanged
condition|)
name|beg_unchanged
operator|=
name|GPT
operator|-
name|BEG
expr_stmt|;
if|if
condition|(
name|Z
operator|-
name|GPT
operator|<
name|end_unchanged
condition|)
name|end_unchanged
operator|=
name|Z
operator|-
name|GPT
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|modify_region
argument_list|(
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prepare_to_modify_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
operator|-
literal|1
operator|<
name|beg_unchanged
operator|||
name|unchanged_modified
operator|==
name|MODIFF
condition|)
name|beg_unchanged
operator|=
name|start
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|Z
operator|-
name|end
operator|<
name|end_unchanged
operator|||
name|unchanged_modified
operator|==
name|MODIFF
condition|)
name|end_unchanged
operator|=
name|Z
operator|-
name|end
expr_stmt|;
name|MODIFF
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|prepare_to_modify_buffer
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|read_only
argument_list|)
condition|)
name|Fbarf_if_buffer_read_only
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
operator|&&
name|current_buffer
operator|->
name|save_modified
operator|>=
name|MODIFF
condition|)
name|lock_file
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* At least warn if this file has changed on disk since it was visited.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
operator|&&
name|current_buffer
operator|->
name|save_modified
operator|>=
name|MODIFF
operator|&&
name|NULL
argument_list|(
name|Fverify_visited_file_modtime
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|Ffile_exists_p
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
argument_list|)
condition|)
name|call1
argument_list|(
name|intern
argument_list|(
literal|"ask-user-about-supersession-threat"
argument_list|)
argument_list|,
name|current_buffer
operator|->
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not CLASH_DETECTION */
block|}
end_block

end_unit

