begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Record indices of function doc strings stored in a file.    Copyright (C) 1985, 1986 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* Must be after sys/types.h for USG and BSD4_1*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Lisp_Object
name|Vdoc_file_name
decl_stmt|;
end_decl_stmt

begin_function
name|Lisp_Object
name|get_doc_string
parameter_list|(
name|filepos
parameter_list|)
name|long
name|filepos
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|512
operator|*
literal|32
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
name|XTYPE
argument_list|(
name|Vexec_directory
argument_list|)
operator|!=
name|Lisp_String
operator|||
name|XTYPE
argument_list|(
name|Vdoc_file_name
argument_list|)
operator|!=
name|Lisp_String
condition|)
return|return
name|Qnil
return|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|Vexec_directory
argument_list|)
operator|->
name|size
operator|+
name|XSTRING
argument_list|(
name|Vdoc_file_name
argument_list|)
operator|->
name|size
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|XSTRING
argument_list|(
name|Vexec_directory
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|XSTRING
argument_list|(
name|Vdoc_file_name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
ifndef|#
directive|ifndef
name|VMS4_4
comment|/* For VMS versions with limited file name syntax,      convert the name to something VMS will allow.  */
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not VMS4_4 */
ifdef|#
directive|ifdef
name|VMS4_4
name|strcpy
argument_list|(
name|name
argument_list|,
name|sys_translate_unix
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS4_4 */
endif|#
directive|endif
comment|/* VMS */
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot open doc string file \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|lseek
argument_list|(
name|fd
argument_list|,
name|filepos
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Position %ld out of range in doc string file \"%s\""
argument_list|,
name|filepos
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
literal|1
condition|)
block|{
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|p
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
break|break;
name|p1
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\037'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
block|{
operator|*
name|p1
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|count
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|make_string
argument_list|(
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"documentation"
argument_list|,
argument|Fdocumentation
argument_list|,
argument|Sdocumentation
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the documentation string of FUNCTION."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|fun1
operator|)
name|Lisp_Object
name|fun1
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|fun
decl_stmt|;
name|Lisp_Object
name|funcar
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|fun
operator|=
name|fun1
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|fun
operator|=
name|Fsymbol_function
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
block|{
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
operator|==
literal|0
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
operator|>=
literal|0
condition|)
return|return
name|Fsubstitute_command_keys
argument_list|(
name|build_string
argument_list|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
argument_list|)
argument_list|)
return|;
return|return
name|Fsubstitute_command_keys
argument_list|(
name|get_doc_string
argument_list|(
operator|-
operator|(
name|int
operator|)
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Vector
condition|)
return|return
name|build_string
argument_list|(
literal|"Prefix command (definition is a Lisp vector of subcommands)."
argument_list|)
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|build_string
argument_list|(
literal|"Keyboard macro."
argument_list|)
return|;
if|if
condition|(
operator|!
name|CONSP
argument_list|(
name|fun
argument_list|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|funcar
operator|=
name|Fcar
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|funcar
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qkeymap
argument_list|)
condition|)
return|return
name|build_string
argument_list|(
literal|"Prefix command (definition is a list whose cdr is an alist of subcommands.)"
argument_list|)
return|;
if|if
condition|(
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qlambda
argument_list|)
operator|||
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qautoload
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Fsubstitute_command_keys
argument_list|(
name|tem
argument_list|)
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Int
operator|&&
name|XINT
argument_list|(
name|tem
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|Fsubstitute_command_keys
argument_list|(
name|get_doc_string
argument_list|(
name|XFASTINT
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|Qnil
return|;
block|}
if|if
condition|(
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qmocklisp
argument_list|)
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qmacro
argument_list|)
condition|)
return|return
name|Fdocumentation
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
return|;
else|else
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"documentation-property"
argument_list|,
argument|Fdocumentation_property
argument_list|,
argument|Sdocumentation_property
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the documentation string that is SYMBOL's PROP property.\n\ This differs from using `get' only in that it can refer to strings\n\ stored in the etc/DOC file."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|sym
operator|,
name|prop
operator|)
name|Lisp_Object
name|sym
operator|,
name|prop
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fget
argument_list|(
name|sym
argument_list|,
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|tem
operator|=
name|get_doc_string
argument_list|(
name|XINT
argument_list|(
name|tem
argument_list|)
operator|>
literal|0
condition|?
name|XINT
argument_list|(
name|tem
argument_list|)
else|:
operator|-
name|XINT
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Fsubstitute_command_keys
argument_list|(
name|tem
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"Snarf-documentation"
argument_list|,
argument|Fsnarf_documentation
argument_list|,
argument|Ssnarf_documentation
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Used during Emacs initialization, before dumping runnable Emacs,\n\ to find pointers to doc strings stored in etc/DOC... and\n\ record them in function definitions.\n\ One arg, FILENAME, a string which does not include a directory.\n\ The file is found in ../etc now; found in the exec-directory\n\ when doc strings are referred to later in the dumped Emacs."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|char
name|buf
index|[
literal|1024
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|filled
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|Lisp_Object
name|sym
decl_stmt|,
name|fun
decl_stmt|,
name|tem
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CANNOT_DUMP
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|size
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"../etc/"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CANNOT_DUMP */
name|CHECK_STRING
argument_list|(
name|Vexec_directory
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|size
operator|+
name|XSTRING
argument_list|(
name|Vexec_directory
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|XSTRING
argument_list|(
name|Vexec_directory
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CANNOT_DUMP */
name|strcat
argument_list|(
name|name
argument_list|,
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/*** Add this line ***/
ifdef|#
directive|ifdef
name|VMS
ifndef|#
directive|ifndef
name|VMS4_4
comment|/* For VMS versions with limited file name syntax,      convert the name to something VMS will allow.  */
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not VMS4_4 */
ifdef|#
directive|ifdef
name|VMS4_4
name|strcpy
argument_list|(
name|name
argument_list|,
name|sys_translate_unix
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS4_4 */
endif|#
directive|endif
comment|/* VMS */
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening doc string file"
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|name
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|Vdoc_file_name
operator|=
name|filename
expr_stmt|;
name|filled
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|filled
operator|<
literal|512
condition|)
name|filled
operator|+=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
index|[
name|filled
index|]
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
operator|-
name|filled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filled
condition|)
break|break;
name|buf
index|[
name|filled
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
operator|(
name|filled
operator|<
literal|512
condition|?
name|filled
else|:
name|filled
operator|-
literal|128
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
operator|*
name|p
operator|!=
literal|'\037'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* p points to ^_Ffunctionname\n or ^_Vvarname\n.  */
if|if
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|end
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|sym
operator|=
name|oblookup
argument_list|(
name|Vobarray
argument_list|,
name|p
operator|+
literal|2
argument_list|,
name|end
operator|-
name|p
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'V'
condition|)
block|{
comment|/* Install file-position as variable-documentation property 		     and make it negative for a user-variable 		     (doc starts with a `*').  */
name|Fput
argument_list|(
name|sym
argument_list|,
name|Qvariable_documentation
argument_list|,
name|make_number
argument_list|(
operator|(
name|pos
operator|+
name|end
operator|+
literal|1
operator|-
name|buf
operator|)
operator|*
operator|(
name|end
index|[
literal|1
index|]
operator|==
literal|'*'
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'F'
condition|)
block|{
name|fun
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
operator|(
name|pos
operator|+
name|end
operator|+
literal|1
operator|-
name|buf
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSP
argument_list|(
name|fun
argument_list|)
condition|)
block|{
name|tem
operator|=
name|XCONS
argument_list|(
name|fun
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qlambda
argument_list|)
operator|||
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qautoload
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSP
argument_list|(
name|tem
argument_list|)
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|XFASTINT
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|=
operator|(
name|pos
operator|+
name|end
operator|+
literal|1
operator|-
name|buf
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|error
argument_list|(
literal|"DOC file invalid at position %d"
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
name|pos
operator|+=
name|end
operator|-
name|buf
expr_stmt|;
name|filled
operator|-=
name|end
operator|-
name|buf
expr_stmt|;
name|bcopy
argument_list|(
name|end
argument_list|,
name|buf
argument_list|,
name|filled
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"substitute-command-keys"
argument_list|,
argument|Fsubstitute_command_keys
argument_list|,
argument|Ssubstitute_command_keys
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the STRING with substrings of the form \\=\\[COMMAND]\n\ replaced by either:  a keystroke sequence that will invoke COMMAND,\n\ or \"M-x COMMAND\" if COMMAND is not on any keys.\n\ Substrings of the form \\=\\{MAPVAR} are replaced by summaries\n\ \(made by describe-bindings) of the value of MAPVAR, taken as a keymap.\n\ Substrings of the form \\=\\<MAPVAR> specify to use the value of MAPVAR\n\ as the keymap for future \\=\\[COMMAND] substrings.\n\ \\=\\= quotes the following character and is discarded;\n\ thus, \\=\\=\\=\\= puts \\=\\= into the output, and \\=\\=\\=\\[ puts \\=\\[ into the output."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|strp
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|new
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|keymap
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|str
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GCPRO1
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|keymap
operator|=
name|current_buffer
operator|->
name|keymap
expr_stmt|;
name|bsize
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
expr_stmt|;
name|bufp
operator|=
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|strp
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
operator|<
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|strp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|strp
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* \= quotes the next character; 	     thus, to put in \[ without its special meaning, use \=\[.  */
name|changed
operator|=
literal|1
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|strp
index|[
literal|2
index|]
expr_stmt|;
name|strp
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|strp
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|strp
operator|+=
literal|2
expr_stmt|;
comment|/* skip \[ */
name|start
operator|=
name|strp
expr_stmt|;
while|while
condition|(
name|strp
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
operator|<
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
operator|&&
operator|*
name|strp
operator|!=
literal|']'
condition|)
name|strp
operator|++
expr_stmt|;
name|length
operator|=
name|strp
operator|-
name|start
expr_stmt|;
name|strp
operator|++
expr_stmt|;
comment|/* skip ] */
comment|/* Save STRP in IDX.  */
name|idx
operator|=
name|strp
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
expr_stmt|;
name|tem
operator|=
name|Fintern
argument_list|(
name|make_string
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fwhere_is_internal
argument_list|(
name|tem
argument_list|,
name|keymap
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
comment|/* but not on any keys */
block|{
name|new
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bsize
operator|+=
literal|4
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|new
operator|-
name|buf
expr_stmt|;
name|buf
operator|=
name|new
expr_stmt|;
name|bcopy
argument_list|(
literal|"M-x "
argument_list|,
name|bufp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bufp
operator|+=
literal|4
expr_stmt|;
goto|goto
name|subst
goto|;
block|}
else|else
block|{
comment|/* function is on a key */
name|tem
operator|=
name|Fkey_description
argument_list|(
name|tem
argument_list|)
expr_stmt|;
goto|goto
name|subst_string
goto|;
block|}
block|}
comment|/* \{foo} is replaced with a summary of the keymap (symeval foo). 	 \<foo> just sets the keymap used for \[cmd].  */
elseif|else
if|if
condition|(
name|strp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|strp
index|[
literal|1
index|]
operator|==
literal|'{'
operator|||
name|strp
index|[
literal|1
index|]
operator|==
literal|'<'
operator|)
condition|)
block|{
name|struct
name|buffer
modifier|*
name|oldbuf
decl_stmt|;
name|Lisp_Object
name|name
decl_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|strp
operator|+=
literal|2
expr_stmt|;
comment|/* skip \{ or \< */
name|start
operator|=
name|strp
expr_stmt|;
while|while
condition|(
name|strp
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
operator|<
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
operator|&&
operator|*
name|strp
operator|!=
literal|'}'
operator|&&
operator|*
name|strp
operator|!=
literal|'>'
condition|)
name|strp
operator|++
expr_stmt|;
name|length
operator|=
name|strp
operator|-
name|start
expr_stmt|;
name|strp
operator|++
expr_stmt|;
comment|/* skip } or> */
comment|/* Save STRP in IDX.  */
name|idx
operator|=
name|strp
operator|-
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
expr_stmt|;
name|oldbuf
operator|=
name|current_buffer
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|XBUFFER
argument_list|(
name|Vprin1_to_string_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|Fintern
argument_list|(
name|make_string
argument_list|(
name|start
argument_list|,
name|length
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tem
operator|=
operator|(
name|Fboundp
argument_list|(
name|name
argument_list|)
operator|)
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|||
operator|(
name|tem
operator|=
operator|(
name|Fsymbol_value
argument_list|(
name|name
argument_list|)
operator|)
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|||
operator|(
name|tem
operator|=
operator|(
name|get_keymap_1
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|)
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
block|{
name|name
operator|=
name|Fsymbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\nUses keymap \""
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\", which is not currently defined.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
index|[
operator|-
literal|1
index|]
operator|==
literal|'<'
condition|)
name|keymap
operator|=
name|Qnil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
index|[
operator|-
literal|1
index|]
operator|==
literal|'<'
condition|)
name|keymap
operator|=
name|tem
expr_stmt|;
else|else
name|describe_map_tree
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fbuffer_string
argument_list|()
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|oldbuf
argument_list|)
expr_stmt|;
name|subst_string
label|:
name|start
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
expr_stmt|;
name|length
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
expr_stmt|;
name|subst
label|:
name|new
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bsize
operator|+=
name|length
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|new
operator|-
name|buf
expr_stmt|;
name|buf
operator|=
name|new
expr_stmt|;
name|bcopy
argument_list|(
name|start
argument_list|,
name|bufp
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|length
expr_stmt|;
comment|/* Check STR again in case gc relocated it.  */
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
operator|+
name|idx
expr_stmt|;
block|}
else|else
comment|/* just copy other chars */
operator|*
name|bufp
operator|++
operator|=
operator|*
name|strp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
comment|/* don't bother if nothing substituted */
name|tem
operator|=
name|make_string
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|str
expr_stmt|;
name|UNGCPRO
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_doc
argument_list|()
end_macro

begin_block
block|{
name|staticpro
argument_list|(
operator|&
name|Vdoc_file_name
argument_list|)
expr_stmt|;
name|Vdoc_file_name
operator|=
name|Qnil
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdocumentation
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdocumentation_property
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssnarf_documentation
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssubstitute_command_keys
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

