begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for the X window system.    Copyright (C) 1985, 1986, 1987 Free Software Foundation.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Yakim Martillo; rearranged by Richard Stallman.  */
end_comment

begin_comment
comment|/* Color and other features added by Robert Krawitz*/
end_comment

begin_comment
comment|/*#include<stdio.h>*/
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"xterm.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|((x< 0) ? ((x)) : (x))
end_define

begin_define
define|#
directive|define
name|sgn
parameter_list|(
name|x
parameter_list|)
value|((x< 0) ? (-1) : (1))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|CROSS_WIDTH
value|16
end_define

begin_define
define|#
directive|define
name|CROSS_HEIGHT
value|16
end_define

begin_decl_stmt
specifier|static
name|short
name|cross_bits
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x7ffe
block|,
literal|0x7ffe
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0180
block|,
literal|0x0000
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|gray_bits
index|[]
init|=
block|{
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CROSS_MASK_WIDTH
value|16
end_define

begin_define
define|#
directive|define
name|CROSS_MASK_HEIGHT
value|16
end_define

begin_decl_stmt
specifier|static
name|short
name|cross_mask_bits
index|[]
init|=
block|{
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,
literal|0x03c0
block|,   }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|sink_bits
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|sink_mask_bits
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sink_width
value|48
end_define

begin_define
define|#
directive|define
name|sink_height
value|48
end_define

begin_define
define|#
directive|define
name|sink_mask_width
value|48
end_define

begin_define
define|#
directive|define
name|sink_mask_height
value|48
end_define

begin_decl_stmt
specifier|extern
name|XREPBUFFER
name|Xxrepbuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-nil if Emacs is running with an X window for display.    Nil if Emacs is run on an ordinary terminal.    Initialized in dispnew.c.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vxterm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vx_mouse_pos
decl_stmt|,
name|Vx_mouse_abs_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vx_mouse_item
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|Lisp_Vector
modifier|*
name|MouseMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|fore_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|back_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|brdr_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mous_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|curs_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|back
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|brdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mous
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|curs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXborder
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXInternalBorder
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|FontInfo
modifier|*
name|fontinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|PendingExposure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|default_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Window
name|XXwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Cursor
name|EmacsCursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|MouseCursor
index|[]
decl_stmt|,
name|MouseMask
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|XXcurrentfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|informflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|WindowMapped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|iconidentity
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|CurHL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pixelwidth
decl_stmt|,
name|pixelheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXxoffset
decl_stmt|,
name|XXyoffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Display
modifier|*
name|XXdisplay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Window
name|XXIconWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|IconWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Bitmap
name|XXIconMask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bitblt
decl_stmt|,
name|CursorExists
decl_stmt|,
name|VisibleX
decl_stmt|,
name|VisibleY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|WindowInfo
name|rootwindowinfo
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|x_init_1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero if x-set-window-edges has been called    or x-rubber-band has been called.    If it is zero when x-pop-up-window is called,    x-rubber-band is called at that point.  */
end_comment

begin_decl_stmt
name|int
name|x_edges_specified
decl_stmt|;
end_decl_stmt

begin_macro
name|check_xterm
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|Vxterm
argument_list|)
condition|)
name|error
argument_list|(
literal|"Terminal does not understand X protocol."
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"x-pop-up-window"
argument_list|,
argument|Fx_pop_up_window
argument_list|,
argument|Sx_pop_up_window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Make the X window appear on the screen."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|check_xterm
argument_list|()
block|;
name|XPopUpWindow
argument_list|()
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-bell"
argument_list|,
argument|Fx_set_bell
argument_list|,
argument|Sx_set_bell
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"For X window system, set audible vs visible bell.\n\ With non-nil argument (prefix arg), use visible bell; otherwise, audible bell."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|check_xterm
argument_list|()
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|XSetFlash
argument_list|()
expr_stmt|;
else|else
name|XSetFeep
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-flip-color"
argument_list|,
argument|Fx_flip_color
argument_list|,
argument|Sx_flip_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Toggle the background and foreground colors"
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|check_xterm
argument_list|()
block|;
name|XFlipColor
argument_list|()
block|;
return|return
name|Qt
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-foreground-color"
argument_list|,
argument|Fx_set_foreground_color
argument_list|,
argument|Sx_set_foreground_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet foregroud color:  "
argument_list|,
literal|"Set foreground (text) color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Color
name|cdef
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|char
modifier|*
name|save_color
decl_stmt|;
name|save_color
operator|=
name|fore_color
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fore_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|fore_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fore_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|fore_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
block|{
name|fore
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fore_color
operator|&&
name|strcmp
argument_list|(
name|fore_color
argument_list|,
literal|"black"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fore
operator|=
name|BlackPixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fore_color
operator|&&
name|strcmp
argument_list|(
name|fore_color
argument_list|,
literal|"white"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fore
operator|=
name|WhitePixel
expr_stmt|;
block|}
else|else
block|{
name|fore_color
operator|=
name|save_color
expr_stmt|;
block|}
comment|/*    XPixFill (XXwindow, 0, 0, screen_width * fontinfo->width, 	screen_height * fontinfo->height, back, ClipModeClipped, 	GXcopy, AllPlanes);*/
name|Fredraw_display
argument_list|()
expr_stmt|;
comment|/*    dumprectangle (0, 0, screen_height * fontinfo->height, 	screen_width * fontinfo -> width);*/
comment|/*    PendingExposure = 1; 	xfixscreen ();*/
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-background-color"
argument_list|,
argument|Fx_set_background_color
argument_list|,
argument|Sx_set_background_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet background color: "
argument_list|,
literal|"Set background color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Color
name|cdef
decl_stmt|;
name|Pixmap
name|temp
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|char
modifier|*
name|save_color
decl_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_color
operator|=
name|back_color
expr_stmt|;
name|back_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|back_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|back_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|back_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
block|{
name|back
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|back_color
operator|&&
name|strcmp
argument_list|(
name|back_color
argument_list|,
literal|"white"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|back
operator|=
name|WhitePixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|back_color
operator|&&
name|strcmp
argument_list|(
name|back_color
argument_list|,
literal|"black"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|back
operator|=
name|BlackPixel
expr_stmt|;
block|}
else|else
block|{
name|back_color
operator|=
name|save_color
expr_stmt|;
block|}
name|temp
operator|=
name|XMakeTile
argument_list|(
name|back
argument_list|)
expr_stmt|;
name|XChangeBackground
argument_list|(
name|XXwindow
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/*    XPixFill (XXwindow, 0, 0, screen_width * fontinfo->width, 	screen_height * fontinfo->height, back, ClipModeClipped, 	GXcopy, AllPlanes);*/
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|Fredraw_display
argument_list|()
expr_stmt|;
comment|/*    dumprectangle (0, 0, screen_height * fontinfo->height, 	screen_width * fontinfo -> width);*/
comment|/*    PendingExposure = 1; 	xfixscreen ();*/
name|XFlush
argument_list|()
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-border-color"
argument_list|,
argument|Fx_set_border_color
argument_list|,
argument|Sx_set_border_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet border color: "
argument_list|,
literal|"Set border color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Color
name|cdef
decl_stmt|;
name|Pixmap
name|temp
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|brdr_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|brdr_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|brdr_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|brdr_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
block|{
name|temp
operator|=
name|XMakeTile
argument_list|(
name|cdef
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|brdr
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|brdr_color
operator|&&
name|strcmp
argument_list|(
name|brdr_color
argument_list|,
literal|"black"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|BlackPixmap
expr_stmt|;
name|brdr
operator|=
name|BlackPixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|brdr_color
operator|&&
name|strcmp
argument_list|(
name|brdr_color
argument_list|,
literal|"white"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|WhitePixmap
expr_stmt|;
name|brdr
operator|=
name|WhitePixel
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|XMakePixmap
argument_list|(
operator|(
name|Bitmap
operator|)
name|XStoreBitmap
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|gray_bits
argument_list|)
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|)
expr_stmt|;
name|brdr
operator|=
name|BlackPixel
expr_stmt|;
name|brdr_color
operator|=
literal|"gray"
expr_stmt|;
block|}
if|if
condition|(
name|XXborder
condition|)
name|XChangeBorder
argument_list|(
name|XXwindow
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-cursor-color"
argument_list|,
argument|Fx_set_cursor_color
argument_list|,
argument|Sx_set_cursor_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet text cursor color: "
argument_list|,
literal|"Set text cursor color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Color
name|cdef
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|char
modifier|*
name|save_color
decl_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_color
operator|=
name|curs_color
expr_stmt|;
name|curs_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|curs_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|curs_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|curs_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
block|{
name|curs
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curs_color
operator|&&
name|strcmp
argument_list|(
name|curs_color
argument_list|,
literal|"black"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|curs
operator|=
name|BlackPixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curs_color
operator|&&
name|strcmp
argument_list|(
name|curs_color
argument_list|,
literal|"white"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|curs
operator|=
name|WhitePixel
expr_stmt|;
block|}
else|else
block|{
name|curs_color
operator|=
name|save_color
expr_stmt|;
block|}
name|CursorToggle
argument_list|()
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-mouse-color"
argument_list|,
argument|Fx_set_mouse_color
argument_list|,
argument|Sx_set_mouse_color
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSet mouse cursor color: "
argument_list|,
literal|"Set mouse cursor color to COLOR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Cursor
name|temp
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|Color
name|cdef
decl_stmt|;
name|char
modifier|*
name|save_color
decl_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_color
operator|=
name|mous_color
expr_stmt|;
name|mous_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|mous_color
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mous_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|mous_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
block|{
name|mous
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mous_color
operator|&&
name|strcmp
argument_list|(
name|mous_color
argument_list|,
literal|"black"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mous
operator|=
name|BlackPixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mous_color
operator|&&
name|strcmp
argument_list|(
name|mous_color
argument_list|,
literal|"white"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mous
operator|=
name|WhitePixel
expr_stmt|;
block|}
else|else
block|{
name|mous_color
operator|=
name|save_color
expr_stmt|;
block|}
name|temp
operator|=
name|XCreateCursor
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|MouseCursor
argument_list|,
name|MouseMask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mous
argument_list|,
name|back
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|XFreeCursor
argument_list|(
name|EmacsCursor
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|EmacsCursor
argument_list|,
sizeof|sizeof
argument_list|(
name|Cursor
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-color-p"
argument_list|,
argument|Fx_color_p
argument_list|,
argument|Sx_color_p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns t if the display is a color X terminal."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|check_xterm
argument_list|()
block|;
if|if
condition|(
name|DisplayCells
argument_list|()
operator|>
literal|2
condition|)
return|return
name|Qt
return|;
else|else
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-foreground-color"
argument_list|,
argument|Fx_get_foreground_color
argument_list|,
argument|Sx_get_foreground_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the foreground, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|string
operator|=
name|build_string
argument_list|(
name|fore_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-background-color"
argument_list|,
argument|Fx_get_background_color
argument_list|,
argument|Sx_get_background_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the background, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|string
operator|=
name|build_string
argument_list|(
name|back_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-border-color"
argument_list|,
argument|Fx_get_border_color
argument_list|,
argument|Sx_get_border_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the border, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|string
operator|=
name|build_string
argument_list|(
name|brdr_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-cursor-color"
argument_list|,
argument|Fx_get_cursor_color
argument_list|,
argument|Sx_get_cursor_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the cursor, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|string
operator|=
name|build_string
argument_list|(
name|curs_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-mouse-color"
argument_list|,
argument|Fx_get_mouse_color
argument_list|,
argument|Sx_get_mouse_color
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Returns the color of the mouse cursor, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|string
block|;
name|string
operator|=
name|build_string
argument_list|(
name|mous_color
argument_list|)
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-default"
argument_list|,
argument|Fx_get_default
argument_list|,
argument|Sx_get_default
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Get X default ATTRIBUTE from the system.  Returns nil if\n\ attribute does not exist."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|default_name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|default_name
operator|=
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
expr_stmt|;
name|value
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XGetDefault
argument_list|(
literal|"emacs"
argument_list|,
name|default_name
argument_list|)
expr_stmt|;
comment|/* if (value == 0)      value = XGetDefault ("", default_name); */
if|if
condition|(
name|value
condition|)
return|return
name|build_string
argument_list|(
name|value
argument_list|)
return|;
else|else
return|return
operator|(
name|Qnil
operator|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-icon"
argument_list|,
argument|Fx_set_icon
argument_list|,
argument|Sx_set_icon
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Set type of icon used by X for Emacs's window.\n\ ARG non-nil means use kitchen-sink icon;\n\ nil means use generic window manager icon."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|check_xterm
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|XTextIcon
argument_list|()
expr_stmt|;
else|else
name|XBitmapIcon
argument_list|()
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-font"
argument_list|,
argument|Fx_set_font
argument_list|,
argument|Sx_set_font
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sFont Name: "
argument_list|,
literal|"At initialization sets the font to be used for the X window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|newfontname
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|newfontname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|newfontname
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
comment|/* XOpenFont ("") gets a badarg error rather than a badfont error.        I believe this is an X bug.        In emacs, badarg errors cause emacs to die, whilst badfont errors        are caught.  This kludge prevents us from dying.      */
goto|goto
name|badfont
goto|;
if|if
condition|(
operator|!
name|XNewFont
argument_list|(
name|newfontname
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|XXcurrentfont
argument_list|)
expr_stmt|;
name|XXcurrentfont
operator|=
name|newfontname
expr_stmt|;
return|return
name|Qt
return|;
block|}
else|else
block|{
name|badfont
label|:
name|error
argument_list|(
literal|"Font \"%s\" is not defined"
argument_list|,
name|newfontname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfontname
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-window-edges"
argument_list|,
argument|Fx_set_window_edges
argument_list|,
argument|Sx_set_window_edges
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|"nNumber of Columns: \nnNumber of Rows: \nnX Offset in Pixels: \n\ nY Offset in Pixels: "
argument_list|,
literal|"Sets X window size/position: size COLS by ROWS, positions XOFF and YOFF.\n\ To get \"minus zero\" for XOFF or YOFF, supply -1."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|cols
operator|,
name|rows
operator|,
name|xoffset
operator|,
name|yoffset
operator|)
name|Lisp_Object
name|rows
operator|,
name|cols
operator|,
name|xoffset
operator|,
name|yoffset
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|CHECK_NUMBER
argument_list|(
name|rows
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|cols
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|xoffset
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|yoffset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|x_edges_specified
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|rows
argument_list|)
operator|!=
name|screen_width
operator|||
name|XINT
argument_list|(
name|cols
argument_list|)
operator|!=
name|screen_height
condition|)
block|{
name|XSetWindowSize
argument_list|(
name|XINT
argument_list|(
name|rows
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|cols
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|XSetOffset
argument_list|(
name|XINT
argument_list|(
name|xoffset
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|yoffset
argument_list|)
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"coordinates-in-window-p"
argument_list|,
name|Fcoordinates_in_window_p
argument_list|,
name|Scoordinates_in_window_p
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return non-nil if POSITIONS (a list, (SCREEN-X SCREEN-Y)) is in WINDOW.\n\ Returned value is list of positions expressed\n\ relative to window upper left corner."
argument_list|)
argument_list|(
name|coordinate
argument_list|,
name|window
argument_list|)
specifier|register
name|Lisp_Object
name|coordinate
operator|,
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|xcoord
decl_stmt|,
name|ycoord
decl_stmt|;
if|if
condition|(
operator|!
name|CONSP
argument_list|(
name|coordinate
argument_list|)
condition|)
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|coordinate
argument_list|)
expr_stmt|;
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xcoord
operator|=
name|Fcar
argument_list|(
name|coordinate
argument_list|)
expr_stmt|;
name|ycoord
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|coordinate
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|xcoord
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|ycoord
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XINT
argument_list|(
name|xcoord
argument_list|)
operator|<
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|left
argument_list|)
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|xcoord
argument_list|)
operator|>=
operator|(
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|left
argument_list|)
operator|+
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|width
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
name|Qnil
return|;
block|}
name|XFASTINT
argument_list|(
name|xcoord
argument_list|)
operator|-=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|ycoord
argument_list|)
operator|==
operator|(
name|screen_height
operator|-
literal|1
operator|)
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
operator|(
name|XINT
argument_list|(
name|ycoord
argument_list|)
operator|<
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|top
argument_list|)
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|ycoord
argument_list|)
operator|>=
operator|(
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|top
argument_list|)
operator|+
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|height
argument_list|)
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
return|return
name|Qnil
return|;
block|}
name|XFASTINT
argument_list|(
name|ycoord
argument_list|)
operator|-=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|top
argument_list|)
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|xcoord
argument_list|,
name|Fcons
argument_list|(
name|ycoord
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-mouse-events"
argument_list|,
argument|Fx_mouse_events
argument_list|,
argument|Sx_mouse_events
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return number of pending mouse events from X window system."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|tem
block|;
specifier|register
name|int
name|windex
block|,
name|rindex
block|,
name|mindex
block|;
name|check_xterm
argument_list|()
block|;
name|windex
operator|=
name|Xxrepbuffer
operator|.
name|windex
block|;
name|rindex
operator|=
name|Xxrepbuffer
operator|.
name|rindex
block|;
name|mindex
operator|=
name|Xxrepbuffer
operator|.
name|mindex
block|;
if|if
condition|(
name|windex
operator|>=
name|rindex
condition|)
block|{
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_Int
argument_list|,
name|windex
operator|-
name|rindex
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_Int
argument_list|,
name|mindex
operator|+
literal|1
operator|-
operator|(
name|rindex
operator|-
name|windex
operator|)
argument_list|)
expr_stmt|;
block|}
end_else

begin_return
return|return
name|tem
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"x-proc-mouse-event"
operator|,
name|Fx_proc_mouse_event
operator|,
name|Sx_proc_mouse_event
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Pulls a mouse event out of the mouse event buffer and dispatches\n\ the appropriate function to act upon this event."
operator|)
operator|(
operator|)
block|{
name|XButtonEvent
name|xrep
block|;
specifier|register
name|Lisp_Object
name|Mouse_Cmd
block|;
specifier|register
name|char
name|com_letter
block|;
specifier|register
name|char
name|key_mask
block|;
specifier|register
name|Lisp_Object
name|tempx
block|;
specifier|register
name|Lisp_Object
name|tempy
block|;
specifier|extern
name|Lisp_Object
name|get_keyelt
argument_list|()
block|;
name|check_xterm
argument_list|()
block|;
if|if
condition|(
name|unloadxrepbuffer
argument_list|(
operator|&
name|xrep
argument_list|,
operator|&
name|Xxrepbuffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|com_letter
operator|=
name|xrep
operator|.
name|detail
operator|&
literal|3
expr_stmt|;
name|key_mask
operator|=
operator|(
name|xrep
operator|.
name|detail
operator|>>
literal|8
operator|)
operator|&
literal|0xf0
expr_stmt|;
name|com_letter
operator||=
name|key_mask
expr_stmt|;
ifndef|#
directive|ifndef
name|HPUX
if|if
condition|(
name|xrep
operator|.
name|type
operator|==
name|ButtonReleased
condition|)
name|com_letter
operator||=
literal|0x04
expr_stmt|;
endif|#
directive|endif
name|XSET
argument_list|(
name|tempx
argument_list|,
name|Lisp_Int
argument_list|,
name|min
argument_list|(
name|screen_width
operator|-
literal|1
argument_list|,
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|xrep
operator|.
name|x
operator|-
name|XXInternalBorder
operator|)
operator|/
name|fontinfo
operator|->
name|width
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempy
argument_list|,
name|Lisp_Int
argument_list|,
name|min
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|,
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|xrep
operator|.
name|y
operator|-
name|XXInternalBorder
operator|)
operator|/
name|fontinfo
operator|->
name|height
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Vx_mouse_pos
operator|=
name|Fcons
argument_list|(
name|tempx
argument_list|,
name|Fcons
argument_list|(
name|tempy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempx
argument_list|,
name|Lisp_Int
argument_list|,
name|xrep
operator|.
name|x
operator|+
name|XXxoffset
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempy
argument_list|,
name|Lisp_Int
argument_list|,
name|xrep
operator|.
name|y
operator|+
name|XXyoffset
argument_list|)
expr_stmt|;
name|Vx_mouse_abs_pos
operator|=
name|Fcons
argument_list|(
name|tempx
argument_list|,
name|Fcons
argument_list|(
name|tempy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|Vx_mouse_item
operator|=
name|make_number
argument_list|(
name|com_letter
argument_list|)
expr_stmt|;
name|Mouse_Cmd
operator|=
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|MouseMap
argument_list|,
name|com_letter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|Mouse_Cmd
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|HPUX
if|if
condition|(
name|xrep
operator|.
name|type
operator|!=
name|ButtonReleased
condition|)
name|bell
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Vx_mouse_pos
operator|=
name|Qnil
expr_stmt|;
name|Vx_mouse_abs_pos
operator|=
name|Qnil
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
name|call1
argument_list|(
name|Mouse_Cmd
argument_list|,
name|Vx_mouse_pos
argument_list|)
return|;
block|}
end_else

begin_expr_stmt
unit|}   return
name|Qnil
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"x-get-mouse-event"
operator|,
name|Fx_get_mouse_event
operator|,
name|Sx_get_mouse_event
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"Get next mouse event out of mouse event buffer (com-letter (x y)).\n\ ARG non-nil means return nil immediately if no pending event;\n\ otherwise, wait for an event."
operator|)
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|XButtonEvent
name|xrep
decl_stmt|;
specifier|register
name|Lisp_Object
name|Mouse_Cmd
decl_stmt|;
specifier|register
name|char
name|com_letter
decl_stmt|;
specifier|register
name|char
name|key_mask
decl_stmt|;
specifier|register
name|Lisp_Object
name|tempx
decl_stmt|;
specifier|register
name|Lisp_Object
name|tempy
decl_stmt|;
specifier|extern
name|Lisp_Object
name|get_keyelt
parameter_list|()
function_decl|;
name|check_xterm
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
while|while
condition|(
name|Xxrepbuffer
operator|.
name|windex
operator|==
name|Xxrepbuffer
operator|.
name|rindex
condition|)
empty_stmt|;
comment|/*** ??? Surely you don't mean to busy wait??? */
if|if
condition|(
name|unloadxrepbuffer
argument_list|(
operator|&
name|xrep
argument_list|,
operator|&
name|Xxrepbuffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|com_letter
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xrep
operator|.
name|detail
operator|)
expr_stmt|;
name|com_letter
operator|&=
literal|3
expr_stmt|;
name|key_mask
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xrep
operator|.
name|detail
operator|+
literal|1
operator|)
expr_stmt|;
name|key_mask
operator|&=
literal|0xf0
expr_stmt|;
name|com_letter
operator||=
name|key_mask
expr_stmt|;
ifndef|#
directive|ifndef
name|HPUX
if|if
condition|(
name|xrep
operator|.
name|type
operator|==
name|ButtonReleased
condition|)
name|com_letter
operator||=
literal|0x04
expr_stmt|;
endif|#
directive|endif
name|XSET
argument_list|(
name|tempx
argument_list|,
name|Lisp_Int
argument_list|,
name|min
argument_list|(
name|screen_width
argument_list|,
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|xrep
operator|.
name|x
operator|-
name|XXInternalBorder
operator|)
operator|/
name|fontinfo
operator|->
name|width
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempy
argument_list|,
name|Lisp_Int
argument_list|,
name|min
argument_list|(
name|screen_height
argument_list|,
name|max
argument_list|(
literal|0
argument_list|,
operator|(
name|xrep
operator|.
name|y
operator|-
name|XXInternalBorder
operator|)
operator|/
name|fontinfo
operator|->
name|height
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Vx_mouse_pos
operator|=
name|Fcons
argument_list|(
name|tempx
argument_list|,
name|Fcons
argument_list|(
name|tempy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempx
argument_list|,
name|Lisp_Int
argument_list|,
name|xrep
operator|.
name|x
operator|+
name|XXxoffset
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tempy
argument_list|,
name|Lisp_Int
argument_list|,
name|xrep
operator|.
name|y
operator|+
name|XXyoffset
argument_list|)
expr_stmt|;
name|Vx_mouse_abs_pos
operator|=
name|Fcons
argument_list|(
name|tempx
argument_list|,
name|Fcons
argument_list|(
name|tempy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|com_letter
argument_list|,
name|Fcons
argument_list|(
name|Vx_mouse_pos
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-keyboard-enable"
argument_list|,
argument|Fx_set_keyboard_enable
argument_list|,
argument|Sx_set_keyboard_enable
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"In the X window system, set the flag that permite keyboard input.\n\ Permit input if ARG is non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|check_xterm
argument_list|()
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|ExposeWindow
operator||
name|ButtonPressed
ifndef|#
directive|ifndef
name|HPUX
operator||
name|ButtonReleased
endif|#
directive|endif
operator||
name|ExposeRegion
operator||
name|ExposeCopy
operator||
operator|(
operator|!
name|NULL
argument_list|(
name|arg
argument_list|)
condition|?
name|KeyPressed
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-set-mouse-inform-flag"
argument_list|,
argument|Fx_set_mouse_inform_flag
argument_list|,
argument|Sx_set_mouse_inform_flag
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Set inform-of-mouse-events flag in X window system on if ARG is non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|informflag
operator|=
operator|!
name|NULL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-store-cut-buffer"
argument_list|,
name|Fx_store_cut_buffer
argument_list|,
name|Sx_store_cut_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sSend string to X:"
argument_list|,
literal|"Store contents of STRING into the cut buffer of the X window system."
argument_list|)
argument_list|(
name|string
argument_list|)
specifier|register
name|Lisp_Object
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XStoreBytes
argument_list|(
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-get-cut-buffer"
argument_list|,
argument|Fx_get_cut_buffer
argument_list|,
argument|Sx_get_cut_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return contents of cut buffer of the X window system, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|int
name|len
block|;
specifier|register
name|Lisp_Object
name|string
block|;
name|BLOCK_INPUT_DECLARE
argument_list|()
specifier|register
name|char
operator|*
name|d
block|;
name|BLOCK_INPUT
argument_list|()
block|;
name|d
operator|=
name|XFetchBytes
argument_list|(
operator|&
name|len
argument_list|)
block|;
name|string
operator|=
name|make_string
argument_list|(
name|d
argument_list|,
name|len
argument_list|)
block|;
name|UNBLOCK_INPUT
argument_list|()
block|;
return|return
name|string
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-rubber-band"
argument_list|,
argument|Fx_rubber_band
argument_list|,
argument|Sx_rubber_band
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Ask user to specify Emacs window position and size with mouse.\n\ This is done automatically if the data has not been specified\n\ when Emacs needs the window to be displayed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|int
name|x
block|,
name|y
block|,
name|width
block|,
name|height
block|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|x_edges_specified
operator|=
literal|1
block|;
name|check_xterm
argument_list|()
block|;
name|BLOCK_INPUT
argument_list|()
block|;
name|window_fetch
argument_list|(
name|fontinfo
operator|->
name|id
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
literal|""
argument_list|,
name|default_window
argument_list|,
name|XXborder
argument_list|,
literal|"GNU Emacs"
argument_list|)
block|;
name|XSetWindowSize
argument_list|(
name|height
argument_list|,
name|width
argument_list|)
block|;
name|XSetOffset
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
block|;
name|XFlush
argument_list|()
block|;
operator|++
name|screen_garbaged
block|;
name|UNBLOCK_INPUT
argument_list|()
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"x-create-x-window"
argument_list|,
argument|Fx_create_x_window
argument_list|,
argument|Sx_create_x_window
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Create window for GNU Emacs from a valid GEOMETRY specification."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|char
modifier|*
name|geometry
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|x_edges_specified
operator|=
literal|1
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|geometry
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|data
argument_list|,
name|geometry
argument_list|,
name|XSTRING
argument_list|(
name|arg
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|window_fetch
argument_list|(
name|fontinfo
operator|->
name|id
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
name|geometry
argument_list|,
name|default_window
argument_list|,
name|XXborder
argument_list|,
literal|"GNU Emacs"
argument_list|)
expr_stmt|;
name|XSetWindowSize
argument_list|(
name|height
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/*  XSetWindowSize ((height - (2 * XXborder))/fontinfo -> height,     (width - (2 * XXborder))/fontinfo -> width);*/
name|XSetOffset
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|XMapWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|int
name|grey_p
parameter_list|(
name|colour
parameter_list|)
name|char
modifier|*
name|colour
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|strcmp
argument_list|(
name|colour
argument_list|,
literal|"grey"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|colour
argument_list|,
literal|"Grey"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|colour
argument_list|,
literal|"gray"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|colour
argument_list|,
literal|"Gray"
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-set-border-width"
argument_list|,
name|Fx_set_border_width
argument_list|,
name|Sx_set_border_width
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"NSet border width: "
argument_list|,
literal|"Set width of border to WIDTH, in the X window system."
argument_list|)
argument_list|(
name|borderwidth
argument_list|)
specifier|register
name|Lisp_Object
name|borderwidth
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|WindowInfo
name|WinInfo
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|Window
name|tempwindow
decl_stmt|;
specifier|register
name|int
name|temppixelwidth
decl_stmt|;
specifier|register
name|int
name|temppixelheight
decl_stmt|;
specifier|register
name|int
name|tempx
decl_stmt|;
specifier|register
name|int
name|tempy
decl_stmt|;
name|Pixmap
name|temp_brdr
decl_stmt|,
name|temp_back
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|borderwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|borderwidth
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|borderwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temppixelwidth
operator|=
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|temppixelheight
operator|=
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XQueryWindow
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|WinInfo
argument_list|)
expr_stmt|;
name|tempx
operator|=
name|WinInfo
operator|.
name|x
expr_stmt|;
name|tempy
operator|=
name|WinInfo
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|grey_p
argument_list|(
name|brdr_color
argument_list|)
condition|)
name|temp_brdr
operator|=
name|XMakePixmap
argument_list|(
operator|(
name|Bitmap
operator|)
name|XStoreBitmap
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|gray_bits
argument_list|)
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|)
expr_stmt|;
else|else
name|temp_brdr
operator|=
name|XMakeTile
argument_list|(
name|brdr
argument_list|)
expr_stmt|;
name|temp_back
operator|=
name|XMakeTile
argument_list|(
name|back
argument_list|)
expr_stmt|;
name|tempwindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
name|tempx
comment|/* Absolute horizontal offset */
argument_list|,
name|tempy
comment|/* Absolute Vertical offset */
argument_list|,
name|temppixelwidth
argument_list|,
name|temppixelheight
argument_list|,
name|XINT
argument_list|(
name|borderwidth
argument_list|)
argument_list|,
name|temp_brdr
argument_list|,
name|temp_back
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempwindow
condition|)
block|{
name|XDestroyWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XXwindow
operator|=
name|tempwindow
expr_stmt|;
name|pixelwidth
operator|=
name|temppixelwidth
expr_stmt|;
name|pixelheight
operator|=
name|temppixelheight
expr_stmt|;
name|XXborder
operator|=
name|XINT
argument_list|(
name|borderwidth
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
name|XSetResizeHint
argument_list|(
name|XXwindow
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
comment|/* fontinfo->width * 1, fontinfo->height * 1, */
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
name|XStoreName
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|iconidentity
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|EmacsCursor
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp_brdr
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp_back
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT_RESIGNAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|WindowMapped
condition|)
block|{
name|XMapWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|KeyPressed
operator||
name|ExposeWindow
operator||
name|ButtonPressed
ifndef|#
directive|ifndef
name|HPUX
operator||
name|ButtonReleased
endif|#
directive|endif
operator||
name|ExposeRegion
operator||
name|ExposeCopy
argument_list|)
expr_stmt|;
operator|++
name|screen_garbaged
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
return|return
name|Qt
return|;
block|}
else|else
block|{
name|UNBLOCK_INPUT_RESIGNAL
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Could not recreate window."
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-set-internal-border-width"
argument_list|,
name|Fx_set_internal_border_width
argument_list|,
name|Sx_set_internal_border_width
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"NSet internal border width: "
argument_list|,
literal|"Set width of internal border to WIDTH, in the X window system."
argument_list|)
argument_list|(
name|internalborderwidth
argument_list|)
specifier|register
name|Lisp_Object
name|internalborderwidth
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|WindowInfo
name|WinInfo
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
name|Window
name|tempwindow
decl_stmt|;
specifier|register
name|int
name|temppixelwidth
decl_stmt|;
specifier|register
name|int
name|temppixelheight
decl_stmt|;
specifier|register
name|int
name|tempx
decl_stmt|;
specifier|register
name|int
name|tempy
decl_stmt|;
specifier|register
name|int
name|intbord
decl_stmt|;
name|Pixmap
name|temp_brdr
decl_stmt|,
name|temp_back
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|internalborderwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|internalborderwidth
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|internalborderwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intbord
operator|=
name|XINT
argument_list|(
name|internalborderwidth
argument_list|)
expr_stmt|;
name|temppixelwidth
operator|=
name|screen_width
operator|*
name|fontinfo
operator|->
name|width
operator|+
literal|2
operator|*
name|intbord
expr_stmt|;
name|temppixelheight
operator|=
name|screen_height
operator|*
name|fontinfo
operator|->
name|height
operator|+
literal|2
operator|*
name|intbord
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XQueryWindow
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|WinInfo
argument_list|)
expr_stmt|;
name|tempx
operator|=
name|WinInfo
operator|.
name|x
expr_stmt|;
name|tempy
operator|=
name|WinInfo
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|grey_p
argument_list|(
name|brdr_color
argument_list|)
condition|)
name|temp_brdr
operator|=
name|XMakePixmap
argument_list|(
operator|(
name|Bitmap
operator|)
name|XStoreBitmap
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|gray_bits
argument_list|)
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|)
expr_stmt|;
else|else
name|temp_brdr
operator|=
name|XMakeTile
argument_list|(
name|brdr
argument_list|)
expr_stmt|;
name|temp_back
operator|=
name|XMakeTile
argument_list|(
name|back
argument_list|)
expr_stmt|;
name|tempwindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
name|tempx
comment|/* Absolute horizontal offset */
argument_list|,
name|tempy
comment|/* Absolute Vertical offset */
argument_list|,
name|temppixelwidth
argument_list|,
name|temppixelheight
argument_list|,
name|XXborder
argument_list|,
name|temp_brdr
argument_list|,
name|temp_back
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempwindow
condition|)
block|{
name|XDestroyWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XXwindow
operator|=
name|tempwindow
expr_stmt|;
name|pixelwidth
operator|=
name|temppixelwidth
expr_stmt|;
name|pixelheight
operator|=
name|temppixelheight
expr_stmt|;
name|XXInternalBorder
operator|=
name|intbord
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
name|XSetResizeHint
argument_list|(
name|XXwindow
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
comment|/* fontinfo->width * 1, fontinfo->height * 1, */
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
name|XStoreName
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|iconidentity
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|EmacsCursor
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp_brdr
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp_back
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT_RESIGNAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|WindowMapped
condition|)
block|{
name|XMapWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|KeyPressed
operator||
name|ExposeWindow
operator||
name|ButtonPressed
ifndef|#
directive|ifndef
name|HPUX
operator||
name|ButtonReleased
endif|#
directive|endif
operator||
name|ExposeRegion
operator||
name|ExposeCopy
argument_list|)
expr_stmt|;
operator|++
name|screen_garbaged
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
return|return
name|Qt
return|;
block|}
else|else
block|{
name|UNBLOCK_INPUT_RESIGNAL
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Could not recreate window."
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
block|}
end_block

begin_decl_stmt
name|jmp_buf
name|dispenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Display
modifier|*
name|OldDisplay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FontInfo
modifier|*
name|OldFontInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
name|OldWindow
decl_stmt|;
end_decl_stmt

begin_macro
name|XRestoreDisplay
argument_list|()
end_macro

begin_block
block|{
name|longjmp
argument_list|(
name|dispenv
argument_list|,
literal|"Unable to access display (probably)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-change-display"
argument_list|,
name|Fx_change_display
argument_list|,
name|Sx_change_display
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sNew display name: "
argument_list|,
literal|"This function takes one argument, the display where you wish to\n\ continue your editing session.  Your current window will be unmapped and\n\ the current display will be closed.  The new X display will be opened and\n\ the rubber-band outline of the new window will appear on the new X display.\n\ This function does not look at your .Xdefaults file, so you should use the\n\ function x-new-display instead."
argument_list|)
argument_list|(
name|new_display
argument_list|)
specifier|register
name|Lisp_Object
name|new_display
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Cursor
name|OldEmacsCursor
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
specifier|register
name|int
argument_list|(
operator|*
name|pipefunc
argument_list|)
argument_list|()
expr_stmt|;
specifier|register
name|char
modifier|*
name|newdisplayname
init|=
literal|0
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|temp_icon
decl_stmt|;
name|int
name|XRestoreDisplay
parameter_list|()
function_decl|;
name|Pixmap
name|temp_brdr
decl_stmt|,
name|temp_back
decl_stmt|;
specifier|register
name|char
modifier|*
name|XXerrorcode
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|new_display
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
comment|/*  newdisplayname = xmalloc (XSTRING (new_display)->size + 1); */
comment|/*  bcopy (XSTRING (new_display)->data, newdisplayname, */
comment|/*	 XSTRING (new_display)->size + 1);  */
comment|/* Since this was freed at the end, why not just use the original? */
name|newdisplayname
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|new_display
argument_list|)
operator|->
name|data
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XIOErrorHandler
argument_list|(
name|XRestoreDisplay
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXerrorcode
operator|=
operator|(
name|char
operator|*
operator|)
name|setjmp
argument_list|(
name|dispenv
argument_list|)
condition|)
block|{
comment|/*       free (&newdisplayname[0]); */
if|if
condition|(
name|fontinfo
condition|)
name|XCloseFont
argument_list|(
name|fontinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXwindow
condition|)
name|XDestroyWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXdisplay
condition|)
name|XCloseDisplay
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|XXdisplay
operator|=
name|OldDisplay
expr_stmt|;
name|fontinfo
operator|=
name|OldFontInfo
expr_stmt|;
name|XXwindow
operator|=
name|OldWindow
expr_stmt|;
name|EmacsCursor
operator|=
name|OldEmacsCursor
expr_stmt|;
name|XIOErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|XSetDisplay
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT_RESIGNAL
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Display change problem: %s"
argument_list|,
name|XXerrorcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OldEmacsCursor
operator|=
name|EmacsCursor
expr_stmt|;
name|OldDisplay
operator|=
name|XXdisplay
expr_stmt|;
name|OldFontInfo
operator|=
name|fontinfo
expr_stmt|;
name|OldWindow
operator|=
name|XXwindow
expr_stmt|;
name|XXwindow
operator|=
literal|0
expr_stmt|;
name|fontinfo
operator|=
literal|0
expr_stmt|;
name|XXdisplay
operator|=
literal|0
expr_stmt|;
block|}
name|XXdisplay
operator|=
name|XOpenDisplay
argument_list|(
name|newdisplayname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XXdisplay
condition|)
block|{
name|longjmp
argument_list|(
name|dispenv
argument_list|,
literal|"Probably nonexistant display"
argument_list|)
expr_stmt|;
block|}
name|XQueryWindow
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|rootwindowinfo
argument_list|)
expr_stmt|;
name|fontinfo
operator|=
name|XOpenFont
argument_list|(
name|XXcurrentfont
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fontinfo
condition|)
block|{
name|longjmp
argument_list|(
name|dispenv
argument_list|,
literal|"Bad font"
argument_list|)
expr_stmt|;
block|}
comment|/* pixelwidth and pixelheight are correct*/
name|XXwindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
name|XXxoffset
argument_list|,
name|XXyoffset
argument_list|,
name|pixelwidth
argument_list|,
name|pixelheight
argument_list|,
name|XXborder
argument_list|,
name|BlackPixmap
argument_list|,
name|WhitePixmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XXwindow
condition|)
block|{
name|longjmp
argument_list|(
name|dispenv
argument_list|,
literal|"Could not create window"
argument_list|)
expr_stmt|;
block|}
name|fore
operator|=
name|BlackPixel
expr_stmt|;
name|back
operator|=
name|WhitePixel
expr_stmt|;
name|brdr
operator|=
name|BlackPixel
expr_stmt|;
name|mous
operator|=
name|BlackPixel
expr_stmt|;
name|curs
operator|=
name|BlackPixel
expr_stmt|;
name|fore_color
operator|=
literal|"black"
expr_stmt|;
name|back_color
operator|=
literal|"white"
expr_stmt|;
name|brdr_color
operator|=
literal|"black"
expr_stmt|;
name|mous_color
operator|=
literal|"black"
expr_stmt|;
name|curs_color
operator|=
literal|"black"
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
name|EmacsCursor
operator|=
name|XCreateCursor
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|MouseCursor
argument_list|,
name|MouseMask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mous
argument_list|,
name|back
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|EmacsCursor
argument_list|)
expr_stmt|;
name|XSetResizeHint
argument_list|(
name|XXwindow
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
comment|/* fontinfo->width * 1, fontinfo->height * 1, */
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
name|XStoreName
argument_list|(
name|XXwindow
argument_list|,
name|iconidentity
argument_list|)
expr_stmt|;
comment|/*  WindowMapped = 0;*/
name|x_edges_specified
operator|=
literal|0
expr_stmt|;
name|bitblt
operator|=
literal|0
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|VisibleX
operator|=
literal|0
expr_stmt|;
name|VisibleY
operator|=
literal|0
expr_stmt|;
name|XSetDisplay
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
comment|/*  XQueryWindow (RootWindow,&rootwindowinfo);*/
comment|/*  if (WindowMapped)     {*/
name|XXIconWindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sink_width
argument_list|,
name|sink_height
argument_list|,
literal|2
argument_list|,
name|WhitePixmap
argument_list|,
name|BlackPixmap
argument_list|)
expr_stmt|;
name|XXIconMask
operator|=
name|XStoreBitmap
argument_list|(
name|sink_mask_width
argument_list|,
name|sink_mask_height
argument_list|,
name|sink_mask_bits
argument_list|)
expr_stmt|;
name|WindowMapped
operator|=
literal|0
expr_stmt|;
name|XPopUpWindow
argument_list|()
expr_stmt|;
comment|/*  }*/
name|WindowMapped
operator|=
literal|1
expr_stmt|;
name|XSetDisplay
argument_list|(
name|OldDisplay
argument_list|)
expr_stmt|;
name|XCloseFont
argument_list|(
name|OldFontInfo
argument_list|)
expr_stmt|;
name|XFreeCursor
argument_list|(
name|OldEmacsCursor
argument_list|)
expr_stmt|;
name|XDestroyWindow
argument_list|(
name|OldWindow
argument_list|)
expr_stmt|;
name|XSetDisplay
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|XCloseDisplay
argument_list|(
name|OldDisplay
argument_list|)
expr_stmt|;
name|x_init_1
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT_RESIGNAL
argument_list|()
expr_stmt|;
comment|/*  free (newdisplayname); */
comment|/*  x_edges_specified = 0;*/
operator|++
name|screen_garbaged
expr_stmt|;
name|Fredraw_display
argument_list|()
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*    Grabs mouse, outlines a window, etc.    if left button pressed, sizes a wd x hd window (in characters)    if right button pressed, sizes wd x what will fit window (in characters)    if middle button pressed, allows user to size window in font increments    	(+ border * 2 for inner border);    While sizing, dimensions of window are displayed in upper left of root.    str is also displayed there.    In all cases, x and y are the desired coordinates for the upper lefthand    	corner, *width = width desired, *height = height desired 	(min for both is 1 font char).  	*/
end_comment

begin_comment
comment|/*   This routine is a total crock.  It makes a window using XCreateTerm   purely for return value, destroying the temporary window created in   the process.  If XCreateTerm were broken into smaller, more easily   digestible pieces, it would be useful.  As such, the constraints of   time, emacs, and X conventions force me into this crock. --rlk   */
end_comment

begin_macro
name|window_fetch
argument_list|(
argument|font
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|width
argument_list|,
argument|height
argument_list|,
argument|geo
argument_list|,
argument|deflt
argument_list|,
argument|border
argument_list|,
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|Font
name|font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|width
decl_stmt|,
modifier|*
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|geo
decl_stmt|,
modifier|*
name|deflt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|border
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|OpaqueFrame
name|frame
decl_stmt|;
name|Window
name|tempwindow
decl_stmt|;
name|WindowInfo
name|WinInfo
decl_stmt|;
specifier|register
name|int
name|temppixelwidth
decl_stmt|;
specifier|register
name|int
name|temppixelheight
decl_stmt|;
name|Pixmap
name|temp_brdr
decl_stmt|,
name|temp_back
decl_stmt|;
name|temp_brdr
operator|=
name|XMakeTile
argument_list|(
name|brdr
argument_list|)
expr_stmt|;
name|temp_back
operator|=
name|XMakeTile
argument_list|(
name|back
argument_list|)
expr_stmt|;
name|frame
operator|.
name|bdrwidth
operator|=
name|border
expr_stmt|;
if|if
condition|(
name|grey_p
argument_list|(
name|brdr_color
argument_list|)
condition|)
name|frame
operator|.
name|border
operator|=
name|XMakePixmap
argument_list|(
operator|(
name|Bitmap
operator|)
name|XStoreBitmap
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|gray_bits
argument_list|)
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|)
expr_stmt|;
else|else
name|frame
operator|.
name|border
operator|=
name|XMakeTile
argument_list|(
name|brdr
argument_list|)
expr_stmt|;
name|frame
operator|.
name|background
operator|=
name|XMakeTile
argument_list|(
name|back
argument_list|)
expr_stmt|;
name|tempwindow
operator|=
name|XCreateTerm
argument_list|(
name|str
argument_list|,
literal|"emacs"
argument_list|,
name|geo
argument_list|,
name|deflt
argument_list|,
operator|&
name|frame
argument_list|,
literal|10
argument_list|,
literal|5
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|fontinfo
argument_list|,
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempwindow
condition|)
block|{
name|XDestroyWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XXwindow
operator|=
name|tempwindow
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|NoEvent
argument_list|)
expr_stmt|;
name|XSetResizeHint
argument_list|(
name|XXwindow
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|2
operator|*
name|XXInternalBorder
argument_list|,
comment|/* fontinfo->width * 1, fontinfo->height * 1, */
name|fontinfo
operator|->
name|width
argument_list|,
name|fontinfo
operator|->
name|height
argument_list|)
expr_stmt|;
name|XStoreName
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|iconidentity
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|XXwindow
argument_list|,
name|EmacsCursor
argument_list|)
expr_stmt|;
name|XQueryWindow
argument_list|(
name|XXwindow
argument_list|,
operator|&
name|WinInfo
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|WinInfo
operator|.
name|x
expr_stmt|;
operator|*
name|y
operator|=
name|WinInfo
operator|.
name|y
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp_brdr
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|temp_back
argument_list|)
expr_stmt|;
name|RESIGNAL_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|WindowMapped
condition|)
block|{
name|XMapWindow
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXwindow
argument_list|,
name|KeyPressed
operator||
name|ExposeWindow
operator||
name|ButtonPressed
ifndef|#
directive|ifndef
name|HPUX
operator||
name|ButtonReleased
endif|#
directive|endif
operator||
name|ExposeRegion
operator||
name|ExposeCopy
argument_list|)
expr_stmt|;
operator|++
name|screen_garbaged
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
block|}
return|return
name|Qt
return|;
block|}
else|else
block|{
name|RESIGNAL_INPUT
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Could not recreate window."
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-rebind-key"
argument_list|,
name|Fx_rebind_key
argument_list|,
name|Sx_rebind_key
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Rebind KEYCODE, with shift bits SHIFT-MASK, to new string NEWSTRING.\n\ KEYCODE and SHIFT-MASK should be numbers representing the X keyboard code\n\ and shift mask respectively.  NEWSTRING is an arbitrary string of keystrokes.\n\ If SHIFT-MASK is nil, then KEYCODE's key will be bound to NEWSTRING for\n\ all shift combinations.\n\ Shift Lock  1	   Shift    2\n\ Meta	    4	   Control  8\n\ \n\ For values of KEYCODE, see /usr/lib/Xkeymap.txt (remember that the codes\n\ in that file are in octal!)\n\ \n\ NOTE: due to an X bug, this function will not take effect unless one has\n\ a ~/.Xkeymap file.  (See the documentation for the \"keycomp\" program.)\n\ This problem will be fixed in X version 11."
argument_list|)
argument_list|(
name|keycode
argument_list|,
name|shift_mask
argument_list|,
name|newstring
argument_list|)
specifier|register
name|Lisp_Object
name|keycode
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|shift_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|newstring
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|rawstring
decl_stmt|;
name|int
name|rawkey
decl_stmt|,
name|rawshift
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|strsize
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|keycode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|shift_mask
argument_list|)
condition|)
name|CHECK_NUMBER
argument_list|(
name|shift_mask
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newstring
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|strsize
operator|=
name|XSTRING
argument_list|(
name|newstring
argument_list|)
operator|->
name|size
expr_stmt|;
name|rawstring
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|newstring
argument_list|)
operator|->
name|data
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
name|rawkey
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|XINT
argument_list|(
name|keycode
argument_list|)
argument_list|)
operator|)
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|shift_mask
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|15
condition|;
name|i
operator|++
control|)
name|XRebindCode
argument_list|(
name|rawkey
argument_list|,
name|i
operator|<<
literal|11
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
else|else
block|{
name|rawshift
operator|=
operator|(
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|XINT
argument_list|(
name|shift_mask
argument_list|)
argument_list|)
operator|)
operator|&
literal|15
operator|)
operator|<<
literal|11
expr_stmt|;
name|XRebindCode
argument_list|(
name|rawkey
argument_list|,
name|rawshift
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-rebind-keys"
argument_list|,
name|Fx_rebind_keys
argument_list|,
name|Sx_rebind_keys
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Rebind KEYCODE to list of strings STRINGS.\n\ STRINGS should be a list of 16 elements, one for each all shift combination.\n\ nil as element means don't change.\n\ See the documentation of x-rebind-key for more information."
argument_list|)
argument_list|(
name|keycode
argument_list|,
name|strings
argument_list|)
specifier|register
name|Lisp_Object
name|keycode
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|strings
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|item
decl_stmt|;
specifier|register
name|char
modifier|*
name|rawstring
decl_stmt|;
name|int
name|rawkey
decl_stmt|,
name|strsize
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|keycode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_CONS
argument_list|(
name|strings
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|rawkey
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|XINT
argument_list|(
name|keycode
argument_list|)
argument_list|)
operator|)
operator|&
literal|255
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|15
condition|;
name|strings
operator|=
name|Fcdr
argument_list|(
name|strings
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|item
operator|=
name|Fcar
argument_list|(
name|strings
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|CHECK_STRING
argument_list|(
name|item
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|strsize
operator|=
name|XSTRING
argument_list|(
name|item
argument_list|)
operator|->
name|size
expr_stmt|;
name|rawstring
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|item
argument_list|)
operator|->
name|data
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
name|XRebindCode
argument_list|(
name|rawkey
argument_list|,
name|i
operator|<<
literal|11
argument_list|,
name|rawstring
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|XExitWithCoreDump
argument_list|(
argument|Disp
argument_list|,
argument|Event
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|Disp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XErrorEvent
modifier|*
name|Event
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XCleanUp
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"x-debug"
argument_list|,
name|Fx_debug
argument_list|,
name|Sx_debug
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"ARG non-nil means that X errors should generate a coredump."
argument_list|)
argument_list|(
name|arg
argument_list|)
specifier|register
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|handler
operator|=
name|XExitWithCoreDump
expr_stmt|;
else|else
block|{
specifier|extern
name|int
name|XExitGracefully
parameter_list|()
function_decl|;
name|handler
operator|=
name|XExitGracefully
expr_stmt|;
block|}
name|XErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|XIOErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
return|return
operator|(
name|Qnil
operator|)
return|;
block|}
end_block

begin_macro
name|XRedrawDisplay
argument_list|()
end_macro

begin_block
block|{
name|Fredraw_display
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|XCleanUp
argument_list|()
end_macro

begin_block
block|{
name|Fdo_auto_save
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|subprocesses
name|kill_buffer_processes
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* subprocesses */
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_xfns
argument_list|()
end_macro

begin_block
block|{
name|x_edges_specified
operator|=
literal|0
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"x-mouse-item"
argument_list|,
operator|&
name|Vx_mouse_item
argument_list|,
literal|"Encoded representation of last mouse click, corresponding to\n\ numerical entries in x-mouse-map."
argument_list|)
expr_stmt|;
name|Vx_mouse_item
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"x-mouse-pos"
argument_list|,
operator|&
name|Vx_mouse_pos
argument_list|,
literal|"Current x-y position of mouse by row, column as specified by font."
argument_list|)
expr_stmt|;
name|Vx_mouse_pos
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"x-mouse-abs-pos"
argument_list|,
operator|&
name|Vx_mouse_abs_pos
argument_list|,
literal|"Current x-y position of mouse by row, column in pixels, wrt root window."
argument_list|)
expr_stmt|;
name|Vx_mouse_abs_pos
operator|=
name|Qnil
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_pop_up_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_bell
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_flip_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_icon
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_font
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_window_edges
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scoordinates_in_window_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_mouse_events
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_proc_mouse_event
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_mouse_event
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_keyboard_enable
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_mouse_inform_flag
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_store_cut_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_cut_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_rubber_band
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_create_x_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_border_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_internal_border_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_change_display
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_foreground_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_background_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_border_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_cursor_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_set_mouse_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_foreground_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_background_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_border_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_cursor_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_mouse_color
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_color_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_get_default
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_rebind_key
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_rebind_keys
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sx_debug
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_X_WINDOWS */
end_comment

end_unit

