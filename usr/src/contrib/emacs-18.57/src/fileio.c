begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File IO for GNU Emacs.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_comment
comment|/* needed by<pwd.h> */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|err_str
parameter_list|(
name|a
parameter_list|)
value|((a)< sys_nerr ? sys_errlist[a] : "unknown error")
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|APOLLO
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NULL
end_ifdef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<perror.h>
end_include

begin_include
include|#
directive|include
file|<file.h>
end_include

begin_include
include|#
directive|include
file|<rmsdef.h>
end_include

begin_include
include|#
directive|include
file|<fab.h>
end_include

begin_include
include|#
directive|include
file|<nam.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_include
include|#
directive|include
file|<netio.h>
end_include

begin_include
include|#
directive|include
file|<errnet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_WRONLY
end_ifndef

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* Nonzero during writing of auto-save files */
end_comment

begin_decl_stmt
name|int
name|auto_saving
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means, when reading a filename in the minibuffer,  start out by inserting the default directory into the minibuffer. */
end_comment

begin_decl_stmt
name|int
name|insert_default_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On VMS, nonzero means write new files with record format stmlf.    Zero means use var format.  */
end_comment

begin_decl_stmt
name|int
name|vms_stmlf_recfm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qfile_error
decl_stmt|,
name|Qfile_already_exists
decl_stmt|;
end_decl_stmt

begin_macro
name|report_file_error
argument_list|(
argument|string
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|errstring
decl_stmt|;
if|if
condition|(
name|errno
operator|>=
literal|0
operator|&&
name|errno
operator|<
name|sys_nerr
condition|)
name|errstring
operator|=
name|build_string
argument_list|(
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|else
name|errstring
operator|=
name|build_string
argument_list|(
literal|"undocumented error code"
argument_list|)
expr_stmt|;
comment|/* System error messages are capitalized.  Downcase the initial. */
name|XSTRING
argument_list|(
name|errstring
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|DOWNCASE
argument_list|(
name|XSTRING
argument_list|(
name|errstring
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qfile_error
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|string
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|errstring
argument_list|,
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-directory"
argument_list|,
argument|Ffile_name_directory
argument_list|,
argument|Sfile_name_directory
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the directory component in file name NAME.\n\ Return nil if NAME does not include a directory.\n\ Otherwise returns a directory spec.\n\ Given a Unix syntax file name, returns a string ending in slash;\n\ on VMS, perhaps instead a string ending in :, ] or>."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|beg
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|beg
operator|=
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
expr_stmt|;
name|p
operator|=
name|beg
operator|+
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|beg
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
ifdef|#
directive|ifdef
name|VMS
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|']'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'>'
endif|#
directive|endif
comment|/* VMS */
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|beg
condition|)
return|return
name|Qnil
return|;
return|return
name|make_string
argument_list|(
name|beg
argument_list|,
name|p
operator|-
name|beg
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-nondirectory"
argument_list|,
argument|Ffile_name_nondirectory
argument_list|,
argument|Sfile_name_nondirectory
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return file name NAME sans its directory.\n\ For example, in a Unix-syntax file name,\n\ this is everything after the last slash,\n\ or the entire name if it contains no slash."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|beg
operator|=
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
expr_stmt|;
name|end
operator|=
name|p
operator|=
name|beg
operator|+
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|beg
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
ifdef|#
directive|ifdef
name|VMS
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|']'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'>'
endif|#
directive|endif
comment|/* VMS */
condition|)
name|p
operator|--
expr_stmt|;
return|return
name|make_string
argument_list|(
name|p
argument_list|,
name|end
operator|-
name|p
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|char
modifier|*
name|file_name_as_directory
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|)
name|char
modifier|*
name|out
decl_stmt|,
decl|*
name|in
decl_stmt|;
end_function

begin_block
block|{
name|int
name|size
init|=
name|strlen
argument_list|(
name|in
argument_list|)
operator|-
literal|1
decl_stmt|;
name|strcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Is it already a directory string? */
if|if
condition|(
name|in
index|[
name|size
index|]
operator|==
literal|':'
operator|||
name|in
index|[
name|size
index|]
operator|==
literal|']'
operator|||
name|in
index|[
name|size
index|]
operator|==
literal|'>'
condition|)
return|return
name|out
return|;
comment|/* Is it a VMS directory file name?  If so, hack VMS syntax.  */
elseif|else
if|if
condition|(
operator|!
name|index
argument_list|(
name|in
argument_list|,
literal|'/'
argument_list|)
operator|&&
operator|(
operator|(
name|size
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|in
index|[
name|size
operator|-
literal|3
index|]
argument_list|,
literal|".DIR"
argument_list|)
operator|)
operator|||
operator|(
name|size
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
operator|&
name|in
index|[
name|size
operator|-
literal|3
index|]
argument_list|,
literal|".dir"
argument_list|)
operator|)
operator|||
operator|(
name|size
operator|>
literal|5
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
operator|&
name|in
index|[
name|size
operator|-
literal|5
index|]
argument_list|,
literal|".DIR"
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
operator|&
name|in
index|[
name|size
operator|-
literal|5
index|]
argument_list|,
literal|".dir"
argument_list|,
literal|4
argument_list|)
operator|)
operator|&&
operator|(
name|in
index|[
name|size
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|||
name|in
index|[
name|size
operator|-
literal|1
index|]
operator|==
literal|';'
operator|)
operator|&&
name|in
index|[
name|size
index|]
operator|==
literal|'1'
operator|)
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dot
decl_stmt|;
name|char
name|brack
decl_stmt|;
comment|/* x.dir -> [.x] 	 dir:x.dir --> dir:[x] 	 dir:[x]y.dir --> dir:[x.y] */
name|p
operator|=
name|in
operator|+
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|in
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'>'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|in
condition|)
block|{
name|strncpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|p
operator|-
name|in
argument_list|)
expr_stmt|;
name|out
index|[
name|p
operator|-
name|in
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|brack
operator|=
literal|']'
expr_stmt|;
name|strcat
argument_list|(
name|out
argument_list|,
literal|":["
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|brack
operator|=
operator|*
name|p
expr_stmt|;
name|strcat
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|brack
operator|=
literal|']'
expr_stmt|;
name|strcpy
argument_list|(
name|out
argument_list|,
literal|"[."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dot
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
comment|/* blindly remove any extension */
name|size
operator|=
name|strlen
argument_list|(
name|out
argument_list|)
operator|+
operator|(
name|dot
operator|-
name|p
operator|)
expr_stmt|;
name|strncat
argument_list|(
name|out
argument_list|,
name|p
argument_list|,
name|dot
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|out
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|out
index|[
name|size
operator|++
index|]
operator|=
name|brack
expr_stmt|;
name|out
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|#
directive|else
comment|/* not VMS */
comment|/* For Unix syntax, Append a slash if necessary */
if|if
condition|(
name|out
index|[
name|size
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|out
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
return|return
name|out
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-as-directory"
argument_list|,
argument|Ffile_name_as_directory
argument_list|,
argument|Sfile_name_as_directory
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a string representing file FILENAME interpreted as a directory.\n\ This string can be used as the value of default-directory\n\ or passed as second argument to expand-file-name.\n\ For a Unix-syntax file name, just appends a slash.\n\ On VMS, converts \"[X]FOO.DIR\" to \"[X.FOO]\", etc."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
operator|+
literal|10
argument_list|)
expr_stmt|;
return|return
name|build_string
argument_list|(
name|file_name_as_directory
argument_list|(
name|buf
argument_list|,
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Convert from directory name to filename.  * On VMS:  *       xyzzy:[mukesh.emacs] => xyzzy:[mukesh]emacs.dir.1  *       xyzzy:[mukesh] => xyzzy:[000000]mukesh.dir.1  * On UNIX, it's simple: just make sure there is a terminating /   * Value is nonzero if the string output is different from the input.  */
end_comment

begin_macro
name|directory_file_name
argument_list|(
argument|src
argument_list|,
argument|dst
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|slen
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|long
name|rlen
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|rptr
decl_stmt|;
name|char
name|bracket
decl_stmt|;
name|struct
name|FAB
name|fab
init|=
name|cc$rms_fab
decl_stmt|;
name|struct
name|NAM
name|nam
init|=
name|cc$rms_nam
decl_stmt|;
name|char
name|esa
index|[
name|NAM$C_MAXRSS
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|slen
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|index
argument_list|(
name|src
argument_list|,
literal|'/'
argument_list|)
operator|&&
operator|(
name|src
index|[
name|slen
index|]
operator|==
literal|']'
operator|||
name|src
index|[
name|slen
index|]
operator|==
literal|':'
operator|||
name|src
index|[
name|slen
index|]
operator|==
literal|'>'
operator|)
condition|)
block|{
comment|/* VMS style - convert [x.y.z] to [x.y]z, [x] to [000000]x */
name|fab
operator|.
name|fab$l_fna
operator|=
name|src
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
name|slen
operator|+
literal|1
expr_stmt|;
name|fab
operator|.
name|fab$l_nam
operator|=
operator|&
name|nam
expr_stmt|;
name|fab
operator|.
name|fab$l_fop
operator|=
name|FAB$M_NAM
expr_stmt|;
name|nam
operator|.
name|nam$l_esa
operator|=
name|esa
expr_stmt|;
name|nam
operator|.
name|nam$b_ess
operator|=
sizeof|sizeof
name|esa
expr_stmt|;
name|nam
operator|.
name|nam$b_nop
operator||=
name|NAM$M_SYNCHK
expr_stmt|;
comment|/* We call SYS$PARSE to handle such things as [--] for us. */
if|if
condition|(
name|SYS$PARSE
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|RMS$_NORMAL
condition|)
block|{
name|slen
operator|=
name|nam
operator|.
name|nam$b_esl
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|esa
index|[
name|slen
index|]
operator|==
literal|';'
operator|&&
name|esa
index|[
name|slen
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|slen
operator|-=
literal|2
expr_stmt|;
name|esa
index|[
name|slen
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|src
operator|=
name|esa
expr_stmt|;
block|}
if|if
condition|(
name|src
index|[
name|slen
index|]
operator|!=
literal|']'
operator|&&
name|src
index|[
name|slen
index|]
operator|!=
literal|'>'
condition|)
block|{
comment|/* what about when we have logical_name:???? */
if|if
condition|(
name|src
index|[
name|slen
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Xlate logical name and see what we get */
name|ptr
operator|=
name|strcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* upper case for getenv */
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
literal|'a'
operator|<=
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|<=
literal|'z'
condition|)
operator|*
name|ptr
operator|-=
literal|040
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|dst
index|[
name|slen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove colon */
if|if
condition|(
operator|!
operator|(
name|src
operator|=
name|egetenv
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* should we jump to the beginning of this procedure? 		 Good points: allows us to use logical names that xlate 		 to Unix names, 		 Bad points: can be a problem if we just translated to a device 		 name... 		 For now, I'll punt and always expect VMS names, and hope for 		 the best! */
name|slen
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|src
index|[
name|slen
index|]
operator|!=
literal|']'
operator|&&
name|src
index|[
name|slen
index|]
operator|!=
literal|'>'
condition|)
block|{
comment|/* no recursion here! */
name|strcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* not a directory spec */
name|strcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|bracket
operator|=
name|src
index|[
name|slen
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|src
argument_list|,
name|bracket
operator|-
literal|2
argument_list|)
operator|)
condition|)
block|{
comment|/* no opening bracket */
name|strcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rptr
operator|=
name|rindex
argument_list|(
name|src
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
name|rptr
operator|=
name|ptr
expr_stmt|;
name|slen
operator|=
name|rptr
operator|-
name|src
expr_stmt|;
name|strncpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|dst
index|[
name|slen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|rptr
operator|==
literal|'.'
condition|)
block|{
name|dst
index|[
name|slen
operator|++
index|]
operator|=
name|bracket
expr_stmt|;
name|dst
index|[
name|slen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* If we have the top-level of a rooted directory (i.e. xx:[000000]), 	     then translate the device and recurse. */
if|if
condition|(
name|dst
index|[
name|slen
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
name|dst
index|[
name|slen
operator|-
literal|2
index|]
operator|!=
literal|':'
comment|/* skip decnet nodes */
operator|&&
name|strcmp
argument_list|(
name|src
operator|+
name|slen
argument_list|,
literal|"[000000]"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dst
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|egetenv
argument_list|(
name|dst
argument_list|)
operator|)
operator|&&
operator|(
name|rlen
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|-
literal|1
operator|)
operator|>
literal|0
operator|&&
operator|(
name|ptr
index|[
name|rlen
index|]
operator|==
literal|']'
operator|||
name|ptr
index|[
name|rlen
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|ptr
index|[
name|rlen
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|ptr
index|[
name|rlen
operator|-
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
name|ptr
index|[
name|rlen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|directory_file_name
argument_list|(
name|ptr
argument_list|,
name|dst
argument_list|)
return|;
block|}
else|else
name|dst
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
block|}
name|strcat
argument_list|(
name|dst
argument_list|,
literal|"[000000]"
argument_list|)
expr_stmt|;
name|slen
operator|+=
literal|8
expr_stmt|;
block|}
name|rptr
operator|++
expr_stmt|;
name|rlen
operator|=
name|strlen
argument_list|(
name|rptr
argument_list|)
operator|-
literal|1
expr_stmt|;
name|strncat
argument_list|(
name|dst
argument_list|,
name|rptr
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|dst
index|[
name|slen
operator|+
name|rlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|dst
argument_list|,
literal|".DIR.1"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* VMS */
comment|/* Process as Unix format: just remove any final slash.      But leave "/" unchanged; do not change it to "".  */
name|strcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
index|[
name|slen
index|]
operator|==
literal|'/'
operator|&&
name|slen
operator|>
literal|1
condition|)
name|dst
index|[
name|slen
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"directory-file-name"
argument_list|,
argument|Fdirectory_file_name
argument_list|,
argument|Sdirectory_file_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Returns the file name of the directory named DIR.\n\ This is the name of the file that holds the data for the directory DIR.\n\ In Unix-syntax, this just removes the final slash.\n\ On VMS, given a VMS-syntax directory name such as \"[X.Y]\",\n\ returns a file name such as \"[X]Y.DIR.1\"."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|directory
operator|)
name|Lisp_Object
name|directory
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|directory
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|directory
argument_list|)
condition|)
return|return
name|Qnil
return|;
ifdef|#
directive|ifdef
name|VMS
comment|/* 20 extra chars is insufficient for VMS, since we might perform a      logical name translation. an equivalence string can be up to 255      chars long, so grab that much extra space...  - sss */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|directory
argument_list|)
operator|->
name|size
operator|+
literal|20
operator|+
literal|255
argument_list|)
expr_stmt|;
else|#
directive|else
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|directory
argument_list|)
operator|->
name|size
operator|+
literal|20
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|directory_file_name
argument_list|(
name|XSTRING
argument_list|(
name|directory
argument_list|)
operator|->
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|build_string
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"make-temp-name"
argument_list|,
argument|Fmake_temp_name
argument_list|,
argument|Smake_temp_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Generate temporary name (string) starting with PREFIX (a string)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prefix
operator|)
name|Lisp_Object
name|prefix
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|val
operator|=
name|concat2
argument_list|(
name|prefix
argument_list|,
name|build_string
argument_list|(
literal|"XXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"expand-file-name"
argument_list|,
argument|Fexpand_file_name
argument_list|,
argument|Sexpand_file_name
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Convert FILENAME to absolute, and canonicalize it.\n\ Second arg DEFAULT is directory to start with if FILENAME is relative\n\  (does not start with slash); if DEFAULT is nil or missing,\n\ the current buffer's value of default-directory is used.\n\ Filenames containing . or .. as components are simplified;\n\ initial ~ is expanded.  See also the function  substitute-in-file-name."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|defalt
operator|)
name|Lisp_Object
name|name
operator|,
name|defalt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|nm
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|newdir
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|target
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|lose
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|unsigned
name|char
modifier|*
name|colon
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|close
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|slash
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|brack
init|=
literal|0
decl_stmt|;
name|int
name|lbrack
init|=
literal|0
decl_stmt|,
name|rbrack
init|=
literal|0
decl_stmt|;
name|int
name|dots
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Filenames on VMS are always upper case.  */
name|name
operator|=
name|Fupcase
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nm
operator|=
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
expr_stmt|;
comment|/* If nm is absolute, flush ...// and detect /./ and /../.      If no /./ or /../ we can return right away. */
if|if
condition|(
name|nm
index|[
literal|0
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|VMS
operator|||
name|index
argument_list|(
name|nm
argument_list|,
literal|':'
argument_list|)
endif|#
directive|endif
comment|/* VMS */
condition|)
block|{
name|p
operator|=
name|nm
expr_stmt|;
name|lose
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|APOLLO
comment|/* // at start of filename is meaningful on Apollo system */
operator|&&
name|nm
operator|!=
name|p
endif|#
directive|endif
comment|/* APOLLO */
condition|)
name|nm
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
name|nm
operator|=
name|p
operator|+
literal|1
operator|,
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* if dev:[dir]/, move nm to / */
if|if
condition|(
operator|!
name|slash
operator|&&
name|p
operator|>
name|nm
operator|&&
operator|(
name|brack
operator|||
name|colon
operator|)
condition|)
block|{
name|nm
operator|=
operator|(
name|brack
condition|?
name|brack
operator|+
literal|1
else|:
name|colon
operator|+
literal|1
operator|)
expr_stmt|;
name|lbrack
operator|=
name|rbrack
operator|=
literal|0
expr_stmt|;
name|brack
operator|=
literal|0
expr_stmt|;
name|colon
operator|=
literal|0
expr_stmt|;
block|}
name|slash
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
ifndef|#
directive|ifndef
name|VMS4_4
comment|/* VMS pre V4.4,convert '-'s in filenames. */
if|if
condition|(
name|lbrack
operator|==
name|rbrack
condition|)
block|{
if|if
condition|(
name|dots
operator|<
literal|2
condition|)
comment|/* this is to allow negative version numbers */
name|p
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* VMS4_4 */
if|if
condition|(
name|lbrack
operator|>
name|rbrack
operator|&&
operator|(
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'['
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'<'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|']'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS4_4
else|else
name|p
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
endif|#
directive|endif
comment|/* VMS4_4 */
comment|/* count open brackets, reset close bracket pointer */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'['
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
name|lbrack
operator|++
operator|,
name|brack
operator|=
literal|0
expr_stmt|;
comment|/* count close brackets, set close bracket pointer */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|']'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'>'
condition|)
name|rbrack
operator|++
operator|,
name|brack
operator|=
name|p
expr_stmt|;
comment|/* detect ][ or>< */
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|']'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'>'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'['
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'<'
operator|)
condition|)
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|']'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
name|nm
operator|=
name|p
operator|+
literal|1
operator|,
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
operator|(
name|colon
operator|||
name|slash
operator|)
condition|)
comment|/* if dev1:[dir]dev2:, move nm to dev2: */
if|if
condition|(
name|brack
condition|)
block|{
name|nm
operator|=
name|brack
operator|+
literal|1
expr_stmt|;
name|brack
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if /pathname/dev:, move nm to dev: */
elseif|else
if|if
condition|(
name|slash
condition|)
name|nm
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
comment|/* if node::dev:, move colon following dev */
elseif|else
if|if
condition|(
name|colon
operator|&&
name|colon
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
name|colon
operator|=
name|p
expr_stmt|;
comment|/* if dev1:dev2:, move nm to dev2: */
elseif|else
if|if
condition|(
name|colon
operator|&&
name|colon
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
name|nm
operator|=
name|colon
operator|+
literal|1
expr_stmt|;
name|colon
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
operator|!
name|colon
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|colon
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|lbrack
operator|==
name|rbrack
condition|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|';'
condition|)
name|dots
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|dots
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lose
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|index
argument_list|(
name|nm
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
name|build_string
argument_list|(
name|sys_translate_unix
argument_list|(
name|nm
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|nm
operator|==
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
condition|)
return|return
name|name
return|;
return|return
name|build_string
argument_list|(
name|nm
argument_list|)
return|;
block|}
block|}
comment|/* Now determine directory to start with and put it in NEWDIR.  */
name|newdir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nm
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
if|if
condition|(
name|nm
index|[
literal|1
index|]
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|VMS
operator|||
name|nm
index|[
literal|1
index|]
operator|==
literal|':'
endif|#
directive|endif
comment|/* VMS */
operator|||
name|nm
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Handle ~ on its own.  */
name|newdir
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|egetenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Handle ~ followed by user name.  */
name|unsigned
name|char
modifier|*
name|user
init|=
name|nm
operator|+
literal|1
decl_stmt|;
comment|/* Find end of name.  */
name|unsigned
name|char
modifier|*
name|ptr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
name|user
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|ptr
condition|?
name|ptr
operator|-
name|user
else|:
name|strlen
argument_list|(
name|user
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|unsigned
name|char
modifier|*
name|ptr1
init|=
name|index
argument_list|(
name|user
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr1
operator|!=
literal|0
operator|&&
name|ptr1
operator|-
name|user
operator|<
name|len
condition|)
name|len
operator|=
name|ptr1
operator|-
name|user
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
comment|/* Copy the user name into temp storage.  */
name|o
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|user
argument_list|,
name|o
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|o
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Look up the user name.  */
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
name|error
argument_list|(
literal|"User \"%s\" is not known"
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|newdir
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pw
operator|->
name|pw_dir
expr_stmt|;
comment|/* Discard the user name from NM.  */
name|nm
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Discard the ~ from NM.  */
name|nm
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|*
name|nm
operator|!=
literal|0
condition|)
name|nm
operator|++
expr_stmt|;
comment|/* Don't leave the slash in nm.  */
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|newdir
operator|==
literal|0
condition|)
name|newdir
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|nm
index|[
literal|0
index|]
operator|!=
literal|'/'
ifdef|#
directive|ifdef
name|VMS
operator|&&
operator|!
name|index
argument_list|(
name|nm
argument_list|,
literal|':'
argument_list|)
endif|#
directive|endif
comment|/* not VMS */
operator|&&
operator|!
name|newdir
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|defalt
argument_list|)
condition|)
name|defalt
operator|=
name|current_buffer
operator|->
name|directory
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|defalt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newdir
operator|=
name|XSTRING
argument_list|(
name|defalt
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
comment|/* Now concatenate the directory and name to new space in the stack frame */
name|tlen
operator|=
operator|(
name|newdir
condition|?
name|strlen
argument_list|(
name|newdir
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|nm
argument_list|)
operator|+
literal|1
expr_stmt|;
name|target
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newdir
condition|)
block|{
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|nm
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|nm
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|target
argument_list|,
name|newdir
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|file_name_as_directory
argument_list|(
name|target
argument_list|,
name|newdir
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|target
argument_list|,
name|nm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|index
argument_list|(
name|target
argument_list|,
literal|'/'
argument_list|)
condition|)
name|strcpy
argument_list|(
name|target
argument_list|,
name|sys_translate_unix
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
comment|/* Now canonicalize by removing /. and /foo/.. if they appear */
name|p
operator|=
name|target
expr_stmt|;
name|o
operator|=
name|target
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|*
name|p
operator|!=
literal|']'
operator|&&
operator|*
name|p
operator|!=
literal|'>'
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|']'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|p
index|[
literal|0
index|]
operator|==
name|p
index|[
literal|1
index|]
operator|+
literal|2
condition|)
comment|/* brackets are offset from each other by 2 */
block|{
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|'-'
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
comment|/* convert [foo][bar] to [bar] */
while|while
condition|(
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'['
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'<'
condition|)
name|o
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
operator|*
name|o
operator|!=
literal|'.'
condition|)
operator|*
operator|--
name|p
operator|=
literal|'.'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|']'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
comment|/* flush .foo.- ; leave - if stopped by '[' or '<' */
block|{
do|do
name|o
operator|--
expr_stmt|;
do|while
condition|(
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'['
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'<'
condition|)
do|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
comment|/* foo.-.bar ==> bar*/
name|p
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|o
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
comment|/* '.foo.-]' ==> ']' */
name|p
operator|++
operator|,
name|o
operator|--
expr_stmt|;
comment|/* else [foo.-] ==> [-] */
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|VMS4_4
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'['
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'<'
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'>'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
endif|#
directive|endif
comment|/* VMS4_4 */
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|#
directive|else
comment|/* not VMS */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
block|{
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"//"
argument_list|,
literal|2
argument_list|)
ifdef|#
directive|ifdef
name|APOLLO
comment|/* // at start of filename is meaningful in Apollo system */
operator|&&
name|o
operator|!=
name|target
endif|#
directive|endif
comment|/* APOLLO */
condition|)
block|{
name|o
operator|=
name|target
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"/.."
argument_list|,
literal|3
argument_list|)
comment|/* `/../' is the "superroot" on certain file systems.  */
operator|&&
name|o
operator|!=
name|target
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|)
condition|)
block|{
while|while
condition|(
name|o
operator|!=
name|target
operator|&&
operator|*
operator|--
name|o
operator|!=
literal|'/'
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|APOLLO
if|if
condition|(
name|o
operator|==
name|target
operator|+
literal|1
operator|&&
name|o
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|o
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|++
name|o
expr_stmt|;
elseif|else
endif|#
directive|endif
endif|APOLLO
if|if
condition|(
name|o
operator|==
name|target
operator|&&
operator|*
name|o
operator|==
literal|'/'
condition|)
operator|++
name|o
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not VMS */
block|}
return|return
name|make_string
argument_list|(
name|target
argument_list|,
name|o
operator|-
name|target
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"substitute-in-file-name"
argument_list|,
argument|Fsubstitute_in_file_name
argument_list|,
argument|Ssubstitute_in_file_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Substitute environment variables referred to in STRING.\n\ A $ begins a request to substitute; the env variable name is the alphanumeric\n\ characters and underscores after the $, or is surrounded by braces.\n\ If a ~ appears following a /, everything through that / is discarded.\n\ On VMS, $ substitution is not done; this function does little and only\n\ duplicates what expand-file-name does."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|)
name|Lisp_Object
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|nm
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|o
decl_stmt|,
modifier|*
name|x
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
name|int
name|substituted
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|xnm
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
expr_stmt|;
name|endp
operator|=
name|nm
operator|+
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
expr_stmt|;
comment|/* If /~ or // appears, discard everything through first slash. */
for|for
control|(
name|p
operator|=
name|nm
init|;
name|p
operator|!=
name|endp
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'~'
operator|||
ifdef|#
directive|ifdef
name|APOLLO
comment|/* // at start of file name is meaningful in Apollo system */
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
operator|-
literal|1
operator|!=
name|nm
operator|)
else|#
directive|else
comment|/* not APOLLO */
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
endif|#
directive|endif
comment|/* not APOLLO */
operator|)
operator|&&
name|p
operator|!=
name|nm
operator|&&
ifdef|#
directive|ifdef
name|VMS
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|']'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
operator|||
endif|#
directive|endif
comment|/* VMS */
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
ifdef|#
directive|ifdef
name|VMS
condition|)
endif|#
directive|endif
comment|/* VMS */
block|{
name|nm
operator|=
name|p
expr_stmt|;
name|substituted
operator|=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|VMS
return|return
name|build_string
argument_list|(
name|nm
argument_list|)
return|;
else|#
directive|else
comment|/* See if any variables are substituted into the string      and find the total length of their values in `total' */
for|for
control|(
name|p
operator|=
name|nm
init|;
name|p
operator|!=
name|endp
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'$'
condition|)
name|p
operator|++
expr_stmt|;
else|else
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|endp
condition|)
goto|goto
name|badsubst
goto|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
comment|/* "$$" means a single "$" */
name|p
operator|++
expr_stmt|;
name|total
operator|-=
literal|1
expr_stmt|;
name|substituted
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|o
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endp
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'}'
condition|)
goto|goto
name|missingclose
goto|;
name|s
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|o
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endp
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
block|}
comment|/* Copy out the variable name */
name|target
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|s
operator|-
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|target
argument_list|,
name|o
argument_list|,
name|s
operator|-
name|o
argument_list|)
expr_stmt|;
name|target
index|[
name|s
operator|-
name|o
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Get variable value */
name|o
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|egetenv
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* The presence of this code makes vax 5.0 crash, for reasons yet unknown */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|USG
block|if (!o&& !strcmp (target, "USER")) 	  o = egetenv ("LOGNAME");
endif|#
directive|endif
comment|/* USG */
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
operator|!
name|o
condition|)
goto|goto
name|badvar
goto|;
name|total
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|substituted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|substituted
condition|)
return|return
name|string
return|;
comment|/* If substitution required, recopy the string and do it */
comment|/* Make space in stack frame for the new copy */
name|xnm
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|+
name|total
operator|+
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
name|xnm
expr_stmt|;
comment|/* Copy the rest of the name through, replacing $ constructs with values */
for|for
control|(
name|p
operator|=
name|nm
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'$'
condition|)
operator|*
name|x
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|endp
condition|)
goto|goto
name|badsubst
goto|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
operator|*
name|x
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|o
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endp
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'}'
condition|)
goto|goto
name|missingclose
goto|;
name|s
operator|=
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|o
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endp
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
block|}
comment|/* Copy out the variable name */
name|target
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|s
operator|-
name|o
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|target
argument_list|,
name|o
argument_list|,
name|s
operator|-
name|o
argument_list|)
expr_stmt|;
name|target
index|[
name|s
operator|-
name|o
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Get variable value */
name|o
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|egetenv
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* The presence of this code makes vax 5.0 crash, for reasons yet unknown */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|USG
block|if (!o&& !strcmp (target, "USER")) 	  o = egetenv ("LOGNAME");
endif|#
directive|endif
comment|/* USG */
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
operator|!
name|o
condition|)
goto|goto
name|badvar
goto|;
name|strcpy
argument_list|(
name|x
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|x
operator|+=
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
comment|/* If /~ or // appears, discard everything through first slash. */
for|for
control|(
name|p
operator|=
name|xnm
init|;
name|p
operator|!=
name|x
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'~'
operator|||
ifdef|#
directive|ifdef
name|APOLLO
comment|/* // at start of file name is meaningful in Apollo system */
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
operator|-
literal|1
operator|!=
name|xnm
operator|)
else|#
directive|else
comment|/* not APOLLO */
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
endif|#
directive|endif
comment|/* not APOLLO */
operator|)
operator|&&
name|p
operator|!=
name|nm
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|xnm
operator|=
name|p
expr_stmt|;
return|return
name|make_string
argument_list|(
name|xnm
argument_list|,
name|x
operator|-
name|xnm
argument_list|)
return|;
name|badsubst
label|:
name|error
argument_list|(
literal|"Bad format environment-variable substitution"
argument_list|)
expr_stmt|;
name|missingclose
label|:
name|error
argument_list|(
literal|"Missing \"}\" in environment-variable substitution"
argument_list|)
expr_stmt|;
name|badvar
label|:
name|error
argument_list|(
literal|"Substituting nonexistent environment variable \"%s\""
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
endif|#
directive|endif
comment|/* not VMS */
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|expand_and_dir_to_file
parameter_list|(
name|filename
parameter_list|,
name|defdir
parameter_list|)
name|Lisp_Object
name|filename
decl_stmt|,
name|defdir
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|abspath
decl_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|defdir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
block|{
specifier|register
name|int
name|c
init|=
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
index|[
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'>'
condition|)
name|abspath
operator|=
name|Fdirectory_file_name
argument_list|(
name|abspath
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Remove final slash, if any (unless path is root).      stat behaves differently depending!  */
if|if
condition|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|>
literal|1
operator|&&
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
index|[
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|abspath
argument_list|,
name|filename
argument_list|)
condition|)
name|abspath
operator|=
name|Fcopy_sequence
argument_list|(
name|abspath
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
index|[
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|abspath
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|barf_or_query_if_file_exists
argument_list|(
argument|absname
argument_list|,
argument|querystring
argument_list|,
argument|interactive
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|absname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|querystring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interactive
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|absname
argument_list|)
operator|->
name|data
argument_list|,
literal|4
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|interactive
condition|)
name|Fsignal
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
literal|"File already exists"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|absname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GCPRO1
argument_list|(
name|absname
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fyes_or_no_p
argument_list|(
name|format1
argument_list|(
literal|"File %s already exists; %s anyway? "
argument_list|,
name|XSTRING
argument_list|(
name|absname
argument_list|)
operator|->
name|data
argument_list|,
name|querystring
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|Fsignal
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
literal|"File already exists"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|absname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"copy-file"
argument_list|,
argument|Fcopy_file
argument_list|,
argument|Scopy_file
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
literal|"fCopy file: \nFCopy %s to file: \np"
argument_list|,
literal|"Copy FILE to NEWNAME.  Both args strings.\n\ Signals a  file-already-exists  error if NEWNAME already exists,\n\ unless a third argument OK-IF-ALREADY-EXISTS is supplied and non-nil.\n\ A number as third arg means request confirmation if NEWNAME already exists.\n\ This is what happens in interactive use with M-x.\n\ Fourth arg non-nil means give the new file the same last-modified time\n\ that the old one has.  (This works on only some systems.)"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|,
name|keep_date
operator|)
name|Lisp_Object
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|,
name|keep_date
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ifd
decl_stmt|,
name|ofd
decl_stmt|,
name|n
decl_stmt|;
name|char
name|buf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|GCPRO2
argument_list|(
name|filename
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|newname
operator|=
name|Fexpand_file_name
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|barf_or_query_if_file_exists
argument_list|(
name|newname
argument_list|,
literal|"copy to it"
argument_list|,
name|XTYPE
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|==
name|Lisp_Int
argument_list|)
expr_stmt|;
name|ifd
operator|=
name|open
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening input file"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Create the copy file with the same record format as the input file */
name|ofd
operator|=
name|sys_creat
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|,
literal|0666
argument_list|,
name|ifd
argument_list|)
expr_stmt|;
else|#
directive|else
name|ofd
operator|=
name|creat
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|ofd
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Opening output file"
argument_list|,
name|Fcons
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|ofd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"I/O error"
argument_list|,
name|Fcons
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|ifd
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|keep_date
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_UTIME
comment|/* AIX has utimes() in compatibility package, but it dies.  So use good old    utime interface instead. */
struct|struct
block|{
name|time_t
name|atime
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
block|}
name|tv
struct|;
name|tv
operator|.
name|atime
operator|=
name|st
operator|.
name|st_atime
expr_stmt|;
name|tv
operator|.
name|mtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|utime
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not USE_UTIME */
name|struct
name|timeval
name|timevals
index|[
literal|2
index|]
decl_stmt|;
name|timevals
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|.
name|st_atime
expr_stmt|;
name|timevals
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|timevals
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|timevals
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|utimes
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|,
name|timevals
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not USE_UTIME */
block|}
endif|#
directive|endif
comment|/* HAVE_TIMEVALS */
ifdef|#
directive|ifdef
name|APOLLO
if|if
condition|(
operator|!
name|egetenv
argument_list|(
literal|"USE_DOMAIN_ACLS"
argument_list|)
condition|)
endif|#
directive|endif
name|chmod
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|,
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|ofd
argument_list|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"I/O error"
argument_list|,
name|Fcons
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"delete-file"
argument_list|,
argument|Fdelete_file
argument_list|,
argument|Sdelete_file
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"fDelete file: "
argument_list|,
literal|"Delete specified file.  One argument, a file name string.\n\ If file has multiple names, it continues to exist with the other names."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|unlink
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|)
condition|)
name|report_file_error
argument_list|(
literal|"Removing old name"
argument_list|,
name|Flist
argument_list|(
literal|1
argument_list|,
operator|&
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"rename-file"
argument_list|,
argument|Frename_file
argument_list|,
argument|Srename_file
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|"fRename file: \nFRename %s to file: \np"
argument_list|,
literal|"Rename FILE as NEWNAME.  Both args strings.\n\ If file has names other than FILE, it continues to have those names.\n\ Signals a  file-already-exists  error if NEWNAME already exists\n\ unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.\n\ A number as third arg means request confirmation if NEWNAME already exists.\n\ This is what happens in interactive use with M-x."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|)
name|Lisp_Object
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|GCPRO2
argument_list|(
name|filename
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|newname
operator|=
name|Fexpand_file_name
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|barf_or_query_if_file_exists
argument_list|(
name|newname
argument_list|,
literal|"rename to it"
argument_list|,
name|XTYPE
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|==
name|Lisp_Int
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD4_1
if|if
condition|(
literal|0
operator|>
name|rename
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
literal|0
operator|>
name|link
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
operator|||
literal|0
operator|>
name|unlink
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|)
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|errno
operator|==
name|EXDEV
condition|)
block|{
name|Fcopy_file
argument_list|(
name|filename
argument_list|,
name|newname
argument_list|,
name|ok_if_already_exists
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
name|Fdelete_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
block|{
name|args
index|[
literal|0
index|]
operator|=
name|filename
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|newname
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Renaming"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|report_file_error
argument_list|(
literal|"Renaming"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
operator|&
name|filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|UNGCPRO
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"add-name-to-file"
argument_list|,
argument|Fadd_name_to_file
argument_list|,
argument|Sadd_name_to_file
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|"fAdd name to file: \nFName to add to %s: \np"
argument_list|,
literal|"Give FILE additional name NEWNAME.  Both args strings.\n\ Signals a  file-already-exists  error if NEWNAME already exists\n\ unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.\n\ A number as third arg means request confirmation if NEWNAME already exists.\n\ This is what happens in interactive use with M-x."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|)
name|Lisp_Object
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|GCPRO2
argument_list|(
name|filename
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|newname
operator|=
name|Fexpand_file_name
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|barf_or_query_if_file_exists
argument_list|(
name|newname
argument_list|,
literal|"make it a new name"
argument_list|,
name|XTYPE
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|==
name|Lisp_Int
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|link
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|args
index|[
literal|0
index|]
operator|=
name|filename
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|newname
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Adding new name"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|report_file_error
argument_list|(
literal|"Adding new name"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
operator|&
name|filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|UNGCPRO
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|S_IFLNK
end_ifdef

begin_macro
name|DEFUN
argument_list|(
literal|"make-symbolic-link"
argument_list|,
argument|Fmake_symbolic_link
argument_list|,
argument|Smake_symbolic_link
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|"FMake symbolic link to file: \nFMake symbolic link to file %s: \np"
argument_list|,
literal|"Make a symbolic link to FILENAME, named LINKNAME.  Both args strings.\n\ Signals a  file-already-exists  error if NEWNAME already exists\n\ unless optional third argument OK-IF-ALREADY-EXISTS is non-nil.\n\ A number as third arg means request confirmation if NEWNAME already exists.\n\ This happens for interactive use with M-x."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
operator|)
name|Lisp_Object
name|filename
operator|,
name|newname
operator|,
name|ok_if_already_exists
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|GCPRO2
argument_list|(
name|filename
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|newname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|newname
operator|=
name|Fexpand_file_name
argument_list|(
name|newname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|barf_or_query_if_file_exists
argument_list|(
name|newname
argument_list|,
literal|"make it a link"
argument_list|,
name|XTYPE
argument_list|(
name|ok_if_already_exists
argument_list|)
operator|==
name|Lisp_Int
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|symlink
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|newname
argument_list|)
operator|->
name|data
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|args
index|[
literal|0
index|]
operator|=
name|filename
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|newname
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Making symbolic link"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|report_file_error
argument_list|(
literal|"Making symbolic link"
argument_list|,
name|Flist
argument_list|(
literal|2
argument_list|,
operator|&
name|filename
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|UNGCPRO
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* S_IFLNK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_macro
name|DEFUN
argument_list|(
literal|"define-logical-name"
argument_list|,
argument|Fdefine_logical_name
argument_list|,
argument|Sdefine_logical_name
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"sDefine logical name: \nsDefine logical name %s as: "
argument_list|,
literal|"Define the job-wide logical name NAME to have the value STRING.\n\ If STRING is nil or a null string, the logical name NAME is deleted."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|varname
operator|,
name|string
operator|)
name|Lisp_Object
name|varname
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|varname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|string
argument_list|)
condition|)
name|delete_logical_name
argument_list|(
name|XSTRING
argument_list|(
name|varname
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|delete_logical_name
argument_list|(
name|XSTRING
argument_list|(
name|varname
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
name|define_logical_name
argument_list|(
name|XSTRING
argument_list|(
name|varname
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX_NET
end_ifdef

begin_macro
name|DEFUN
argument_list|(
literal|"sysnetunam"
argument_list|,
argument|Fsysnetunam
argument_list|,
argument|Ssysnetunam
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Open a network connection to PATH using LOGIN as the login string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|path
operator|,
name|login
operator|)
name|Lisp_Object
name|path
operator|,
name|login
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|netresult
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|login
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|netresult
operator|=
name|netunam
argument_list|(
name|XSTRING
argument_list|(
name|path
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|login
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|netresult
operator|==
operator|-
literal|1
condition|)
return|return
name|Qnil
return|;
else|else
return|return
name|Qt
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HPUX_NET */
end_comment

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-absolute-p"
argument_list|,
argument|Ffile_name_absolute_p
argument_list|,
argument|Sfile_name_absolute_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILENAME specifies an absolute path name."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
operator|||
operator|*
name|ptr
operator|==
literal|'~'
ifdef|#
directive|ifdef
name|VMS
comment|/* ??? This criterion is probably wrong for '<'.  */
operator|||
name|index
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
operator|||
name|index
argument_list|(
name|ptr
argument_list|,
literal|'<'
argument_list|)
operator|||
operator|(
operator|*
name|ptr
operator|==
literal|'['
operator|&&
operator|(
name|ptr
index|[
literal|1
index|]
operator|!=
literal|'-'
operator|||
operator|(
name|ptr
index|[
literal|2
index|]
operator|!=
literal|'.'
operator|&&
name|ptr
index|[
literal|2
index|]
operator|!=
literal|']'
operator|)
operator|)
operator|&&
name|ptr
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|)
endif|#
directive|endif
comment|/* VMS */
condition|)
return|return
name|Qt
return|;
else|else
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-exists-p"
argument_list|,
argument|Ffile_exists_p
argument_list|,
argument|Sfile_exists_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILENAME exists.  (This does not mean you can read it.)\n\ See also file-readable-p and file-attributes."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
operator|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|)
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-readable-p"
argument_list|,
argument|Ffile_readable_p
argument_list|,
argument|Sfile_readable_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILENAME exists and you can read it.\n\ See also file-exists-p and file-attributes."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
operator|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
literal|4
argument_list|)
operator|>=
literal|0
operator|)
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-symlink-p"
argument_list|,
argument|Ffile_symlink_p
argument_list|,
argument|Sfile_symlink_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"If file FILENAME is the name of a symbolic link\n\ returns the name of the file to which it is linked.\n\ Otherwise returns NIL."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|int
name|valsize
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|100
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|valsize
operator|=
name|readlink
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|valsize
operator|<
name|bufsize
condition|)
break|break;
comment|/* Buffer was not long enough */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bufsize
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|valsize
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
name|val
operator|=
name|make_string
argument_list|(
name|buf
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|val
return|;
else|#
directive|else
comment|/* not S_IFLNK */
return|return
name|Qnil
return|;
endif|#
directive|endif
comment|/* not S_IFLNK */
block|}
end_block

begin_comment
comment|/* Having this before file-symlink-p mysteriously caused it to be forgotten    on the RT/PC.  */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"file-writable-p"
argument_list|,
argument|Ffile_writable_p
argument_list|,
argument|Sfile_writable_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILENAME can be written or created by you."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|,
name|dir
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
literal|2
argument_list|)
operator|>=
literal|0
operator|)
condition|?
name|Qt
else|:
name|Qnil
return|;
name|dir
operator|=
name|Ffile_name_directory
argument_list|(
name|abspath
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|dir
argument_list|)
condition|)
name|dir
operator|=
name|Fdirectory_file_name
argument_list|(
name|dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
return|return
operator|(
name|access
argument_list|(
operator|!
name|NULL
argument_list|(
name|dir
argument_list|)
condition|?
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
else|:
literal|""
argument_list|,
literal|2
argument_list|)
operator|>=
literal|0
condition|?
name|Qt
else|:
name|Qnil
operator|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-directory-p"
argument_list|,
argument|Ffile_directory_p
argument_list|,
argument|Sfile_directory_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILENAME is the name of a directory as a file.\n\ A directory name spec may be given instead; then the value is t\n\ if the directory so specified exists and really is a directory."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|abspath
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|abspath
operator|=
name|expand_and_dir_to_file
argument_list|(
name|filename
argument_list|,
name|current_buffer
operator|->
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
return|return
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-modes"
argument_list|,
argument|Ffile_modes
argument_list|,
argument|Sfile_modes
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return mode bits of FILE, as an integer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|abspath
operator|=
name|expand_and_dir_to_file
argument_list|(
name|filename
argument_list|,
name|current_buffer
operator|->
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
return|return
name|make_number
argument_list|(
name|st
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-file-modes"
argument_list|,
argument|Fset_file_modes
argument_list|,
argument|Sset_file_modes
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set mode bits of FILE to MODE (an integer).\n\ Only the 12 low bits of MODE are used."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|mode
operator|)
name|Lisp_Object
name|filename
operator|,
name|mode
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|;
name|abspath
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|current_buffer
operator|->
name|directory
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|APOLLO
if|if
condition|(
name|chmod
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
name|XINT
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Doing chmod"
argument_list|,
name|Fcons
argument_list|(
name|abspath
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* APOLLO */
if|if
condition|(
operator|!
name|egetenv
argument_list|(
literal|"USE_DOMAIN_ACLS"
argument_list|)
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|timeval
name|tvp
index|[
literal|2
index|]
decl_stmt|;
comment|/* chmod on apollo also change the file's modtime; need to save the 	 modtime and then restore it. */
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report_file_error
argument_list|(
literal|"Doing chmod"
argument_list|,
name|Fcons
argument_list|(
name|abspath
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Qnil
operator|)
return|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
name|XINT
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Doing chmod"
argument_list|,
name|Fcons
argument_list|(
name|abspath
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset the old accessed and modified times.  */
name|tvp
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|.
name|st_atime
operator|+
literal|1
expr_stmt|;
comment|/* +1 due to an Apollo roundoff bug */
name|tvp
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tvp
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|.
name|st_mtime
operator|+
literal|1
expr_stmt|;
comment|/* +1 due to an Apollo roundoff bug */
name|tvp
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|utimes
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
name|tvp
argument_list|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Doing utimes"
argument_list|,
name|Fcons
argument_list|(
name|abspath
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* APOLLO */
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-newer-than-file-p"
argument_list|,
argument|Ffile_newer_than_file_p
argument_list|,
argument|Sfile_newer_than_file_p
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return t if file FILE1 is newer than file FILE2.\n\ If FILE1 does not exist, the answer is nil;\n\ otherwise, if FILE2 does not exist, the answer is t."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file1
operator|,
name|file2
operator|)
name|Lisp_Object
name|file1
operator|,
name|file2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|abspath
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|mtime1
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|file1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|file2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|abspath
operator|=
name|expand_and_dir_to_file
argument_list|(
name|file1
argument_list|,
name|current_buffer
operator|->
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
name|mtime1
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|abspath
operator|=
name|expand_and_dir_to_file
argument_list|(
name|file2
argument_list|,
name|current_buffer
operator|->
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|abspath
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qt
return|;
return|return
operator|(
name|mtime1
operator|>
name|st
operator|.
name|st_mtime
operator|)
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|close_file_unwind
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|close
argument_list|(
name|XFASTINT
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"insert-file-contents"
argument_list|,
argument|Finsert_file_contents
argument_list|,
argument|Sinsert_file_contents
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Insert contents of file FILENAME after point.\n\ Returns list of absolute pathname and length of data inserted.\n\ If second argument VISIT is non-nil, the buffer's visited filename\n\ and last save file modtime are set, and it is marked unmodified.\n\ If visiting and the file does not exist, visiting is completed\n\ before the error is signaled."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|,
name|visit
operator|)
name|Lisp_Object
name|filename
operator|,
name|visit
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|inserted
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|GCPRO1
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|read_only
argument_list|)
condition|)
name|Fbarf_if_buffer_read_only
argument_list|()
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|APOLLO
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* not APOLLO */
block|{
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|visit
argument_list|)
condition|)
name|report_file_error
argument_list|(
literal|"Opening input file"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|.
name|st_mtime
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|notfound
goto|;
block|}
name|record_unwind_protect
argument_list|(
name|close_file_unwind
argument_list|,
name|make_number
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Supposedly happens on VMS.  */
if|if
condition|(
name|st
operator|.
name|st_size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"File size is negative"
argument_list|)
expr_stmt|;
block|{
specifier|register
name|Lisp_Object
name|temp
decl_stmt|;
comment|/* Make sure point-max won't overflow after this insertion.  */
name|XSET
argument_list|(
name|temp
argument_list|,
name|Lisp_Int
argument_list|,
name|st
operator|.
name|st_size
operator|+
name|Z
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_size
operator|+
name|Z
operator|!=
name|XINT
argument_list|(
name|temp
argument_list|)
condition|)
name|error
argument_list|(
literal|"maximum buffer size exceeded"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|visit
argument_list|)
condition|)
name|prepare_to_modify_buffer
argument_list|()
expr_stmt|;
name|move_gap
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|GAP_SIZE
operator|<
name|st
operator|.
name|st_size
condition|)
name|make_gap
argument_list|(
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
operator|-
name|GAP_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|try
init|=
name|min
argument_list|(
name|st
operator|.
name|st_size
operator|-
name|inserted
argument_list|,
literal|64
operator|<<
literal|10
argument_list|)
decl_stmt|;
name|int
name|this
init|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|FETCH_CHAR
argument_list|(
name|point
operator|+
name|inserted
operator|-
literal|1
argument_list|)
operator|+
literal|1
argument_list|,
name|try
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|<=
literal|0
condition|)
block|{
name|i
operator|=
name|this
expr_stmt|;
break|break;
block|}
name|GPT
operator|+=
name|this
expr_stmt|;
name|GAP_SIZE
operator|-=
name|this
expr_stmt|;
name|ZV
operator|+=
name|this
expr_stmt|;
name|Z
operator|+=
name|this
expr_stmt|;
name|inserted
operator|+=
name|this
expr_stmt|;
block|}
if|if
condition|(
name|inserted
operator|>
literal|0
condition|)
name|MODIFF
operator|++
expr_stmt|;
name|record_insert
argument_list|(
name|point
argument_list|,
name|inserted
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Discard the unwind protect */
name|specpdl_ptr
operator|=
name|specpdl
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"IO error reading %s: %s"
argument_list|,
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
name|err_str
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|notfound
label|:
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|visit
argument_list|)
condition|)
block|{
name|current_buffer
operator|->
name|undo_list
operator|=
name|Qnil
expr_stmt|;
ifdef|#
directive|ifdef
name|APOLLO
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_buffer
operator|->
name|modtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|current_buffer
operator|->
name|save_modified
operator|=
name|MODIFF
expr_stmt|;
name|current_buffer
operator|->
name|auto_save_modified
operator|=
name|MODIFF
expr_stmt|;
name|XFASTINT
argument_list|(
name|current_buffer
operator|->
name|save_length
argument_list|)
operator|=
name|Z
operator|-
name|BEG
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
condition|)
name|unlock_file
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
expr_stmt|;
name|unlock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|current_buffer
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
comment|/* If visiting nonexistent file, return nil.  */
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|==
operator|-
literal|1
condition|)
name|report_file_error
argument_list|(
literal|"Opening input file"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|inserted
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"write-region"
argument_list|,
argument|Fwrite_region
argument_list|,
argument|Swrite_region
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|"r\nFWrite region to file: "
argument_list|,
literal|"Write current region into specified file.\n\ When called from a program, takes three arguments:\n\ START, END and FILENAME.  START and END are buffer positions.\n\ Optional fourth argument APPEND if non-nil means\n\   append to existing file contents (if any).\n\ Optional fifth argument VISIT if t means\n\   set last-save-file-modtime of buffer to this file's modtime\n\   and mark buffer not modified.\n\ If VISIT is neither t nor nil, it means do not print\n\   the \"Wrote file\" message."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|start
operator|,
name|end
operator|,
name|filename
operator|,
name|append
operator|,
name|visit
operator|)
name|Lisp_Object
name|start
operator|,
name|end
operator|,
name|filename
operator|,
name|append
operator|,
name|visit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|desc
decl_stmt|;
name|int
name|failure
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|unsigned
name|char
modifier|*
name|fn
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|unsigned
name|char
modifier|*
name|fname
init|=
literal|0
decl_stmt|;
comment|/* If non-0, original filename (must rename) */
endif|#
directive|endif
comment|/* VMS */
comment|/* Special kludge to simplify auto-saving */
if|if
condition|(
name|NULL
argument_list|(
name|start
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|start
argument_list|)
operator|=
name|BEG
expr_stmt|;
name|XFASTINT
argument_list|(
name|end
argument_list|)
operator|=
name|Z
expr_stmt|;
block|}
else|else
name|validate_region
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|fn
operator|=
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|lock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|desc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|append
argument_list|)
condition|)
name|desc
operator|=
name|open
argument_list|(
name|fn
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|auto_saving
condition|)
comment|/* Overwrite any previous version of autosave file */
block|{
name|vms_truncate
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* if fn exists, truncate to zero length */
name|desc
operator|=
name|open
argument_list|(
name|fn
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|desc
operator|=
name|creat_copy_attrs
argument_list|(
name|XTYPE
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
operator|==
name|Lisp_String
condition|?
name|XSTRING
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
operator|->
name|data
else|:
literal|0
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Write to temporary name and rename if no errors */
block|{
name|Lisp_Object
name|temp_name
decl_stmt|;
name|temp_name
operator|=
name|Ffile_name_directory
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|temp_name
argument_list|)
condition|)
block|{
name|temp_name
operator|=
name|Fmake_temp_name
argument_list|(
name|concat2
argument_list|(
name|temp_name
argument_list|,
name|build_string
argument_list|(
literal|"$$SAVE$$"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fname
operator|=
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
expr_stmt|;
name|fn
operator|=
name|XSTRING
argument_list|(
name|temp_name
argument_list|)
operator|->
name|data
expr_stmt|;
name|desc
operator|=
name|creat_copy_attrs
argument_list|(
name|fname
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
comment|/* If we can't open the temporary file, try creating a new 		   version of the original file.  VMS "creat" creates a 		   new version rather than truncating an existing file. */
name|fn
operator|=
name|fname
expr_stmt|;
name|fname
operator|=
literal|0
expr_stmt|;
name|desc
operator|=
name|creat
argument_list|(
name|fn
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
comment|/* We can't make a new version; 		       try to truncate and rewrite existing version if any.  */
name|vms_truncate
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|desc
operator|=
name|open
argument_list|(
name|fn
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|desc
operator|=
name|creat
argument_list|(
name|fn
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not VMS */
name|desc
operator|=
name|creat
argument_list|(
name|fn
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|unlock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|report_file_error
argument_list|(
literal|"Opening output file"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|record_unwind_protect
argument_list|(
name|close_file_unwind
argument_list|,
name|make_number
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|append
argument_list|)
condition|)
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|unlock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|report_file_error
argument_list|(
literal|"Lseek error"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS
comment|/*  * Kludge Warning: The VMS C RTL likes to insert carriage returns  * if we do writes that don't end with a carriage return. Furthermore  * it cannot handle writes of more then 16K. The modified  * version of "sys_write" in SYSDEP.C (see comment there) copes with  * this EXCEPT for the last record (iff it doesn't end with a carriage  * return). This implies that if your buffer doesn't end with a carriage  * return, you get one free... tough. However it also means that if  * we make two calls to sys_write (a la the following code) you can  * get one at the gap as well. The easiest way to fix this (honest)  * is to move the gap to the next newline (or the end of the buffer).  * Thus this change.  *  * Yech!  */
if|if
condition|(
name|GPT
operator|>
name|BEG
operator|&&
name|GPT_ADDR
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|move_gap
argument_list|(
name|find_next_newline
argument_list|(
name|GPT
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|failure
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|start
argument_list|)
operator|!=
name|XINT
argument_list|(
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|XINT
argument_list|(
name|start
argument_list|)
operator|<
name|GPT
condition|)
block|{
specifier|register
name|int
name|end1
init|=
name|XINT
argument_list|(
name|end
argument_list|)
decl_stmt|;
name|tem
operator|=
name|XINT
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|0
operator|>
name|e_write
argument_list|(
name|desc
argument_list|,
operator|&
name|FETCH_CHAR
argument_list|(
name|tem
argument_list|)
argument_list|,
name|min
argument_list|(
name|GPT
argument_list|,
name|end1
argument_list|)
operator|-
name|tem
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
block|}
if|if
condition|(
name|XINT
argument_list|(
name|end
argument_list|)
operator|>
name|GPT
operator|&&
operator|!
name|failure
condition|)
block|{
name|tem
operator|=
name|XINT
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|tem
operator|=
name|max
argument_list|(
name|tem
argument_list|,
name|GPT
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|0
operator|>
name|e_write
argument_list|(
name|desc
argument_list|,
operator|&
name|FETCH_CHAR
argument_list|(
name|tem
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|end
argument_list|)
operator|-
name|tem
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|USG
ifndef|#
directive|ifndef
name|VMS
ifndef|#
directive|ifndef
name|BSD4_1
ifndef|#
directive|ifndef
name|alliant
comment|/* trinkle@cs.purdue.edu says fsync can return EBUSY 		   on alliant, for no visible reason.  */
comment|/* Note fsync appears to change the modtime on BSD4.2 (both vax and sun).      Disk full in NFS may be reported here.  */
if|if
condition|(
name|fsync
argument_list|(
name|desc
argument_list|)
operator|<
literal|0
condition|)
name|failure
operator|=
literal|1
operator|,
name|save_errno
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Spurious "file has changed on disk" warnings have been       observed on Sun 3 as well.  Maybe close changes the modtime      with nfs as well.  */
comment|/* On VMS and APOLLO, must do the stat after the close      since closing changes the modtime.  */
ifndef|#
directive|ifndef
name|VMS
ifndef|#
directive|ifndef
name|APOLLO
comment|/* Recall that #if defined does not work on VMS.  */
define|#
directive|define
name|FOO
block|fstat (desc,&st);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
comment|/* NFS can report a write failure now.  */
if|if
condition|(
name|close
argument_list|(
name|desc
argument_list|)
operator|<
literal|0
condition|)
name|failure
operator|=
literal|1
operator|,
name|save_errno
operator|=
name|errno
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* If we wrote to a temporary name and had no errors, rename to real name. */
if|if
condition|(
name|fname
condition|)
block|{
if|if
condition|(
operator|!
name|failure
condition|)
name|failure
operator|=
operator|(
name|rename
argument_list|(
name|fn
argument_list|,
name|fname
argument_list|)
operator|!=
literal|0
operator|)
operator|,
name|save_errno
operator|=
name|errno
expr_stmt|;
name|fn
operator|=
name|fname
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VMS */
ifndef|#
directive|ifndef
name|FOO
name|stat
argument_list|(
name|fn
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Discard the unwind protect */
name|specpdl_ptr
operator|=
name|specpdl
operator|+
name|count
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|unlock_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
comment|/* Do this before reporting IO error      to avoid a "file has changed on disk" warning on      next attempt to save.  */
if|if
condition|(
name|EQ
argument_list|(
name|visit
argument_list|,
name|Qt
argument_list|)
condition|)
name|current_buffer
operator|->
name|modtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|failure
condition|)
name|error
argument_list|(
literal|"IO error writing %s: %s"
argument_list|,
name|fn
argument_list|,
name|err_str
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|visit
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
name|current_buffer
operator|->
name|save_modified
operator|=
name|MODIFF
expr_stmt|;
name|XFASTINT
argument_list|(
name|current_buffer
operator|->
name|save_length
argument_list|)
operator|=
name|Z
operator|-
name|BEG
expr_stmt|;
name|current_buffer
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|visit
argument_list|)
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
operator|!
name|auto_saving
condition|)
name|message
argument_list|(
literal|"Wrote %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|int
name|e_write
parameter_list|(
name|desc
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|write
argument_list|(
name|desc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
operator|-
name|len
return|;
else|else
block|{
name|p
operator|=
name|buf
expr_stmt|;
name|end
operator|=
name|p
operator|+
sizeof|sizeof
name|buf
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|desc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|!=
sizeof|sizeof
name|buf
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|=
name|buf
expr_stmt|;
block|}
operator|*
name|p
operator|=
operator|*
name|addr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\015'
condition|)
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|buf
condition|)
if|if
condition|(
name|write
argument_list|(
name|desc
argument_list|,
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
operator|!=
name|p
operator|-
name|buf
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"verify-visited-file-modtime"
argument_list|,
argument|Fverify_visited_file_modtime
argument_list|,
argument|Sverify_visited_file_modtime
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if last mod time of BUF's visited file matches what BUF records.\n\ This means that the file has not been changed since it was visited or saved."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buf
operator|)
name|Lisp_Object
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|CHECK_BUFFER
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|b
operator|->
name|filename
argument_list|)
operator|!=
name|Lisp_String
condition|)
return|return
name|Qt
return|;
if|if
condition|(
name|b
operator|->
name|modtime
operator|==
literal|0
condition|)
return|return
name|Qt
return|;
if|if
condition|(
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|b
operator|->
name|filename
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* If the file doesn't exist now and didn't exist before, 	 we say that it isn't modified, provided the error is a tame one.  */
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|||
name|errno
operator|==
name|EACCES
operator|||
name|errno
operator|==
name|ENOTDIR
condition|)
name|st
operator|.
name|st_mtime
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|st
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|==
name|b
operator|->
name|modtime
comment|/* If both are positive, accept them if they are off by one second.  */
operator|||
operator|(
name|st
operator|.
name|st_mtime
operator|>
literal|0
operator|&&
name|b
operator|->
name|modtime
operator|>
literal|0
operator|&&
operator|(
name|st
operator|.
name|st_mtime
operator|==
name|b
operator|->
name|modtime
operator|+
literal|1
operator|||
name|st
operator|.
name|st_mtime
operator|==
name|b
operator|->
name|modtime
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"clear-visited-file-modtime"
argument_list|,
argument|Fclear_visited_file_modtime
argument_list|,
argument|Sclear_visited_file_modtime
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Clear out records of last mod time of visited file.\n\ Next attempt to save will certainly not complain of a discrepancy."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|current_buffer
operator|->
name|modtime
operator|=
literal|0
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_function
name|Lisp_Object
name|auto_save_error
parameter_list|()
block|{
name|unsigned
name|char
modifier|*
name|name
init|=
name|XSTRING
argument_list|(
name|current_buffer
operator|->
name|name
argument_list|)
operator|->
name|data
decl_stmt|;
name|bell
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Autosaving...error for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Fsleep_for
argument_list|(
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"Autosaving...error!for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Fsleep_for
argument_list|(
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"Autosaving...error for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Fsleep_for
argument_list|(
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|auto_save_1
parameter_list|()
block|{
return|return
name|Fwrite_region
argument_list|(
name|Qnil
argument_list|,
name|Qnil
argument_list|,
name|current_buffer
operator|->
name|auto_save_file_name
argument_list|,
name|Qnil
argument_list|,
name|Qlambda
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"do-auto-save"
argument_list|,
argument|Fdo_auto_save
argument_list|,
argument|Sdo_auto_save
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Auto-save all buffers that need it.\n\ This is all buffers that have auto-saving enabled\n\ and are changed since last auto-saved.\n\ Auto-saving writes the buffer into a file\n\ so that your editing is not lost if the system crashes.\n\ This file is not the file you visited; that changes only when you save.\n\n\ Non-nil argument means do not print any message if successful."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nomsg
operator|)
name|Lisp_Object
name|nomsg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|Lisp_Object
name|tail
decl_stmt|,
name|buf
decl_stmt|;
name|int
name|auto_saved
init|=
literal|0
decl_stmt|;
name|int
name|tried
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|omessage
init|=
name|echo_area_contents
decl_stmt|;
comment|/* No GCPRO needed, because (when it matters) all Lisp_Object variables      point to non-strings reached from Vbuffer_alist.  */
name|auto_saving
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|minibuf_level
condition|)
name|nomsg
operator|=
name|Qt
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
name|XGCTYPE
argument_list|(
name|tail
argument_list|)
operator|==
name|Lisp_Cons
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|buf
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Check for auto save enabled 	 and file changed since last auto save 	 and file changed since last real save.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|b
operator|->
name|auto_save_file_name
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|b
operator|->
name|save_modified
operator|<
name|BUF_MODIFF
argument_list|(
name|b
argument_list|)
operator|&&
name|b
operator|->
name|auto_save_modified
operator|<
name|BUF_MODIFF
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* If we at least consider a buffer for auto-saving, 	     don't try again for a suitable time.  */
name|tried
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|XFASTINT
argument_list|(
name|b
operator|->
name|save_length
argument_list|)
operator|*
literal|10
operator|>
operator|(
name|BUF_Z
argument_list|(
name|b
argument_list|)
operator|-
name|BUF_BEG
argument_list|(
name|b
argument_list|)
operator|)
operator|*
literal|13
operator|)
comment|/* A short file is likely to change a large fraction; 		 spare the user annoying messages.  */
operator|&&
name|XFASTINT
argument_list|(
name|b
operator|->
name|save_length
argument_list|)
operator|>
literal|5000
comment|/* These messages are frequent and annoying for `*mail*'.  */
operator|&&
operator|!
name|EQ
argument_list|(
name|b
operator|->
name|filename
argument_list|,
name|Qnil
argument_list|)
condition|)
block|{
comment|/* It has shrunk too much; don't checkpoint. */
name|message
argument_list|(
literal|"Buffer %s has shrunk a lot; not autosaving it"
argument_list|,
name|XSTRING
argument_list|(
name|b
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|Fsleep_for
argument_list|(
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|set_buffer_internal
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auto_saved
operator|&&
name|NULL
argument_list|(
name|nomsg
argument_list|)
condition|)
name|message1
argument_list|(
literal|"Auto-saving..."
argument_list|)
expr_stmt|;
name|internal_condition_case
argument_list|(
name|auto_save_1
argument_list|,
name|Qt
argument_list|,
name|auto_save_error
argument_list|)
expr_stmt|;
name|auto_saved
operator|++
expr_stmt|;
name|b
operator|->
name|auto_save_modified
operator|=
name|BUF_MODIFF
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|current_buffer
operator|->
name|save_length
argument_list|)
operator|=
name|Z
operator|-
name|BEG
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tried
condition|)
name|record_auto_save
argument_list|()
expr_stmt|;
if|if
condition|(
name|auto_saved
operator|&&
name|NULL
argument_list|(
name|nomsg
argument_list|)
condition|)
name|message1
argument_list|(
name|omessage
condition|?
name|omessage
else|:
literal|"Auto-saving...done"
argument_list|)
expr_stmt|;
name|auto_saving
operator|=
literal|0
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-buffer-auto-saved"
argument_list|,
argument|Fset_buffer_auto_saved
argument_list|,
argument|Sset_buffer_auto_saved
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Mark current buffer as auto-saved with its current text.\n\ No auto-save file will be written until the buffer changes again."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|current_buffer
operator|->
name|auto_save_modified
operator|=
name|MODIFF
block|;
name|XFASTINT
argument_list|(
name|current_buffer
operator|->
name|save_length
argument_list|)
operator|=
name|Z
operator|-
name|BEG
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"recent-auto-save-p"
argument_list|,
argument|Frecent_auto_save_p
argument_list|,
argument|Srecent_auto_save_p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return t if buffer has been auto-saved since last read in or saved."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
operator|(
name|current_buffer
operator|->
name|save_modified
operator|<
name|current_buffer
operator|->
name|auto_save_modified
operator|)
operator|?
name|Qt
operator|:
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Reading and completing file names */
end_comment

begin_decl_stmt
specifier|extern
name|Lisp_Object
name|Ffile_name_completion
argument_list|()
decl_stmt|,
name|Ffile_name_all_completions
argument_list|()
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"read-file-name-internal"
argument_list|,
argument|Fread_file_name_internal
argument_list|,
argument|Sread_file_name_internal
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Internal subroutine for read-file-name.  Do not call this."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|dir
operator|,
name|action
operator|)
name|Lisp_Object
name|string
operator|,
name|dir
operator|,
name|action
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* action is nil for complete, t for return list of completions,      lambda for verify final value */
end_comment

begin_block
block|{
name|Lisp_Object
name|name
decl_stmt|,
name|specdir
decl_stmt|,
name|realdir
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|string
expr_stmt|;
name|realdir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|action
argument_list|,
name|Qlambda
argument_list|)
condition|)
return|return
name|Qnil
return|;
block|}
else|else
block|{
name|string
operator|=
name|Fsubstitute_in_file_name
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|name
operator|=
name|Ffile_name_nondirectory
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|realdir
operator|=
name|Ffile_name_directory
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|realdir
argument_list|)
condition|)
name|realdir
operator|=
name|dir
expr_stmt|;
else|else
name|realdir
operator|=
name|Fexpand_file_name
argument_list|(
name|realdir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|action
argument_list|)
condition|)
block|{
name|specdir
operator|=
name|Ffile_name_directory
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|val
operator|=
name|Ffile_name_completion
argument_list|(
name|name
argument_list|,
name|realdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|val
argument_list|)
operator|!=
name|Lisp_String
condition|)
return|return
operator|(
name|val
operator|)
return|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|specdir
argument_list|)
condition|)
name|val
operator|=
name|concat2
argument_list|(
name|specdir
argument_list|,
name|val
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|osize
decl_stmt|,
name|count
decl_stmt|;
name|osize
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
expr_stmt|;
comment|/* Quote "$" as "$$" to get it past substitute-in-file-name */
for|for
control|(
name|n
operator|=
name|osize
operator|,
name|count
operator|=
literal|0
operator|,
name|old
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
operator|*
name|old
operator|++
operator|==
literal|'$'
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|old
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
expr_stmt|;
name|val
operator|=
name|Fmake_string
argument_list|(
name|make_number
argument_list|(
name|osize
operator|+
name|count
argument_list|)
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
expr_stmt|;
for|for
control|(
name|n
operator|=
name|osize
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
if|if
condition|(
operator|*
name|old
operator|!=
literal|'$'
condition|)
operator|*
name|new
operator|++
operator|=
operator|*
name|old
operator|++
expr_stmt|;
else|else
block|{
operator|*
name|new
operator|++
operator|=
literal|'$'
expr_stmt|;
operator|*
name|new
operator|++
operator|=
literal|'$'
expr_stmt|;
name|old
operator|++
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Not VMS */
return|return
operator|(
name|val
operator|)
return|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|action
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|Ffile_name_all_completions
argument_list|(
name|name
argument_list|,
name|realdir
argument_list|)
return|;
comment|/* Only other case actually used is ACTION = lambda */
ifdef|#
directive|ifdef
name|VMS
comment|/* Supposedly this helps commands such as `cd' that read directory names,      but can someone explain how it helps them? -- RMS */
if|if
condition|(
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|Qt
return|;
endif|#
directive|endif
comment|/* VMS */
return|return
name|Ffile_exists_p
argument_list|(
name|string
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-file-name"
argument_list|,
argument|Fread_file_name
argument_list|,
argument|Sread_file_name
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Read file name, prompting with PROMPT and completing in directory DIR.\n\ Value is not expanded!  You must call expand-file-name yourself.\n\ Default name to DEFAULT if user enters a null string.\n\ Fourth arg MUSTMATCH non-nil means require existing file's name.\n\  Non-nil and non-t means also require confirmation after completion.\n\ DIR defaults to current buffer's directory default."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|dir
operator|,
name|defalt
operator|,
name|mustmatch
operator|)
name|Lisp_Object
name|prompt
operator|,
name|dir
operator|,
name|defalt
operator|,
name|mustmatch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|,
name|insdef
decl_stmt|,
name|tem
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
specifier|register
name|char
modifier|*
name|homedir
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|dir
argument_list|)
condition|)
name|dir
operator|=
name|current_buffer
operator|->
name|directory
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|defalt
argument_list|)
condition|)
name|defalt
operator|=
name|current_buffer
operator|->
name|filename
expr_stmt|;
comment|/* If dir starts with user's homedir, change that to ~. */
name|homedir
operator|=
operator|(
name|char
operator|*
operator|)
name|egetenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
operator|!=
literal|0
operator|&&
name|XTYPE
argument_list|(
name|dir
argument_list|)
operator|==
name|Lisp_String
operator|&&
operator|!
name|strncmp
argument_list|(
name|homedir
argument_list|,
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
argument_list|,
name|strlen
argument_list|(
name|homedir
argument_list|)
argument_list|)
operator|&&
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
index|[
name|strlen
argument_list|(
name|homedir
argument_list|)
index|]
operator|==
literal|'/'
condition|)
block|{
name|dir
operator|=
name|make_string
argument_list|(
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
operator|+
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|-
literal|1
argument_list|,
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|size
operator|-
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|'~'
expr_stmt|;
block|}
if|if
condition|(
name|insert_default_directory
condition|)
name|insdef
operator|=
name|dir
expr_stmt|;
else|else
name|insdef
operator|=
name|build_string
argument_list|(
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|count
operator|=
name|specpdl_ptr
operator|-
name|specpdl
expr_stmt|;
name|specbind
argument_list|(
name|intern
argument_list|(
literal|"completion-ignore-case"
argument_list|)
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GCPRO2
argument_list|(
name|insdef
argument_list|,
name|defalt
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|intern
argument_list|(
literal|"read-file-name-internal"
argument_list|)
argument_list|,
name|dir
argument_list|,
name|mustmatch
argument_list|,
name|insert_default_directory
condition|?
name|insdef
else|:
name|Qnil
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"No file name specified"
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|val
argument_list|,
name|insdef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|defalt
argument_list|)
condition|)
return|return
name|defalt
return|;
return|return
name|Fsubstitute_in_file_name
argument_list|(
name|val
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_fileio
argument_list|()
end_macro

begin_block
block|{
name|Qfile_error
operator|=
name|intern
argument_list|(
literal|"file-error"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qfile_error
argument_list|)
expr_stmt|;
name|Qfile_already_exists
operator|=
name|intern
argument_list|(
literal|"file-already-exists"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qfile_already_exists
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qfile_error
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qfile_error
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qfile_error
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"File error"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Fcons
argument_list|(
name|Qfile_error
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qfile_already_exists
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"File already exists"
argument_list|)
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"insert-default-directory"
argument_list|,
operator|&
name|insert_default_directory
argument_list|,
literal|"*Non-nil means when reading a filename start with default dir in minibuffer."
argument_list|)
expr_stmt|;
name|insert_default_directory
operator|=
literal|1
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"vms-stmlf-recfm"
argument_list|,
operator|&
name|vms_stmlf_recfm
argument_list|,
literal|"*Non-nil means write new files with record format `stmlf'.\n\ nil means use format `var'.  This variable is meaningful only on VMS."
argument_list|)
expr_stmt|;
name|vms_stmlf_recfm
operator|=
literal|0
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_name_directory
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_name_nondirectory
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_name_as_directory
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdirectory_file_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_temp_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexpand_file_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssubstitute_in_file_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scopy_file
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_file
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srename_file
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sadd_name_to_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|S_IFLNK
name|defsubr
argument_list|(
operator|&
name|Smake_symbolic_link
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* S_IFLNK */
ifdef|#
directive|ifdef
name|VMS
name|defsubr
argument_list|(
operator|&
name|Sdefine_logical_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|HPUX_NET
name|defsubr
argument_list|(
operator|&
name|Ssysnetunam
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HPUX_NET */
name|defsubr
argument_list|(
operator|&
name|Sfile_name_absolute_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_exists_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_readable_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_writable_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_symlink_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_directory_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_modes
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_file_modes
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_newer_than_file_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_file_contents
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swrite_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sverify_visited_file_modtime
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sclear_visited_file_modtime
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdo_auto_save
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_buffer_auto_saved
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecent_auto_save_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_file_name_internal
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_file_name
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

