begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Calculate what ins/del line to do, and do it, for Emacs redisplay.    Copyright (C) 1985, 1986, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_struct
struct|struct
name|matrix_elt
block|{
comment|/* Cost of outputting through this line        if no insert/delete is done just above it.  */
name|int
name|writecost
decl_stmt|;
comment|/* Cost of outputting through this line        if an insert is done just above it.  */
name|int
name|insertcost
decl_stmt|;
comment|/* Cost of outputting through this line        if a delete is done just above it.  */
name|int
name|deletecost
decl_stmt|;
comment|/* Number of inserts so far in this run of inserts,        for the cost in insertcost.  */
name|char
name|insertcount
decl_stmt|;
comment|/* Number of deletes so far in this run of deletes,        for the cost in deletecost.  */
name|char
name|deletecount
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This exceeds the sum of any reasonable number of INFINITY's.  */
end_comment

begin_define
define|#
directive|define
name|SUPER_INFINITY
value|(1000 * INFINITY)
end_define

begin_comment
comment|/* See CalcIDCosts for on the arrays below */
end_comment

begin_decl_stmt
name|int
modifier|*
name|ILcost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|DLcost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ILncost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|DLncost
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|scrolling_1
argument_list|(
argument|window_size
argument_list|,
argument|unchanged_at_top
argument_list|,
argument|unchanged_at_bottom
argument_list|,
argument|draw_cost
argument_list|,
argument|old_hash
argument_list|,
argument|new_hash
argument_list|,
argument|free_at_end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|window_size
decl_stmt|,
name|unchanged_at_top
decl_stmt|,
name|unchanged_at_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|draw_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|old_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|new_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_at_end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|matrix_elt
modifier|*
name|matrix
decl_stmt|;
name|matrix
operator|=
operator|(
operator|(
expr|struct
name|matrix_elt
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|*
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|matrix
argument_list|)
operator|)
expr_stmt|;
name|calculate_scrolling
argument_list|(
name|matrix
argument_list|,
name|window_size
argument_list|,
name|unchanged_at_bottom
argument_list|,
name|draw_cost
argument_list|,
name|old_hash
argument_list|,
name|new_hash
argument_list|,
name|free_at_end
argument_list|)
expr_stmt|;
name|do_scrolling
argument_list|(
name|matrix
argument_list|,
name|window_size
argument_list|,
name|unchanged_at_top
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Determine, in matrix[i,j], the cost of updating the first j old lines    into the first i new lines.    This involves using insert or delete somewhere if i != j.    For each matrix elements, three kinds of costs are recorded:    the smallest cost that ends with an insert, the smallest    cost that ends with a delete, and the smallest cost that    ends with neither one.  These are kept separate because    on some terminals the cost of doing an insert varies    depending on whether one was just done, etc.  */
end_comment

begin_comment
comment|/* draw_cost[VPOS] is the cost of outputting new line at VPOS.    old_hash[VPOS] is the hash code of the old line at VPOS.    new_hash[VPOS] is the hash code of the new line at VPOS.    Note that these are not true screen vpos's, but relative    to the place at which the first mismatch between old and    new contents appears.  */
end_comment

begin_macro
name|calculate_scrolling
argument_list|(
argument|matrix
argument_list|,
argument|window_size
argument_list|,
argument|lines_below
argument_list|,
argument|draw_cost
argument_list|,
argument|old_hash
argument_list|,
argument|new_hash
argument_list|,
argument|free_at_end
argument_list|)
end_macro

begin_comment
comment|/* matrix is of size window_size + 1 on each side.  */
end_comment

begin_decl_stmt
name|struct
name|matrix_elt
modifier|*
name|matrix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|window_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|draw_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|old_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|new_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_at_end
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|matrix_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|cost
decl_stmt|,
name|cost1
decl_stmt|;
name|int
name|lines_moved
init|=
name|window_size
operator|+
operator|(
name|scroll_region_ok
condition|?
literal|0
else|:
name|lines_below
operator|)
decl_stmt|;
comment|/* We subtract 1 to compensate for the fact that i and j have values      starting with 1.  */
name|int
modifier|*
name|first_insert_cost
init|=
operator|&
name|ILcost
index|[
name|screen_height
operator|-
name|lines_moved
operator|-
literal|1
index|]
decl_stmt|;
name|int
modifier|*
name|first_delete_cost
init|=
operator|&
name|DLcost
index|[
name|screen_height
operator|-
name|lines_moved
operator|-
literal|1
index|]
decl_stmt|;
name|int
modifier|*
name|next_insert_cost
init|=
operator|&
name|ILncost
index|[
name|screen_height
operator|-
name|lines_moved
operator|-
literal|1
index|]
decl_stmt|;
name|int
modifier|*
name|next_delete_cost
init|=
operator|&
name|DLncost
index|[
name|screen_height
operator|-
name|lines_moved
operator|-
literal|1
index|]
decl_stmt|;
comment|/* initialize the top left corner of the matrix */
name|matrix
operator|->
name|writecost
operator|=
literal|0
expr_stmt|;
name|matrix
operator|->
name|insertcost
operator|=
name|SUPER_INFINITY
expr_stmt|;
name|matrix
operator|->
name|deletecost
operator|=
name|SUPER_INFINITY
expr_stmt|;
name|matrix
operator|->
name|insertcount
operator|=
literal|0
expr_stmt|;
name|matrix
operator|->
name|deletecount
operator|=
literal|0
expr_stmt|;
comment|/* initialize the left edge of the matrix */
name|cost
operator|=
name|first_insert_cost
index|[
literal|1
index|]
operator|-
name|next_insert_cost
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|window_size
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|matrix
operator|+
name|i
operator|*
operator|(
name|window_size
operator|+
literal|1
operator|)
expr_stmt|;
name|cost
operator|+=
name|draw_cost
index|[
name|i
index|]
operator|+
name|next_insert_cost
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|insertcost
operator|=
name|cost
expr_stmt|;
name|p
operator|->
name|writecost
operator|=
name|SUPER_INFINITY
expr_stmt|;
name|p
operator|->
name|deletecost
operator|=
name|SUPER_INFINITY
expr_stmt|;
name|p
operator|->
name|insertcount
operator|=
name|i
expr_stmt|;
name|p
operator|->
name|deletecount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* initialize the top edge of the matrix */
name|cost
operator|=
name|first_delete_cost
index|[
literal|1
index|]
operator|-
name|next_delete_cost
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|window_size
condition|;
name|j
operator|++
control|)
block|{
name|cost
operator|+=
name|next_delete_cost
index|[
name|j
index|]
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|deletecost
operator|=
name|cost
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|writecost
operator|=
name|SUPER_INFINITY
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|insertcost
operator|=
name|SUPER_INFINITY
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|deletecount
operator|=
name|j
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|insertcount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* `i' represents the vpos among new screen contents.      `j' represents the vpos among the old screen contents.  */
name|p
operator|=
name|matrix
operator|+
name|window_size
operator|+
literal|2
expr_stmt|;
comment|/* matrix [1, 1] */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|window_size
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|window_size
condition|;
name|j
operator|++
operator|,
name|p
operator|++
control|)
block|{
comment|/* p contains the address of matrix [i, j] */
comment|/* First calculate the cost assuming we do 	   not insert or delete above this line. 	   That is, if we update through line i-1 	   based on old lines through j-1, 	   and then just change old line j to new line i.  */
name|p1
operator|=
name|p
operator|-
name|window_size
operator|-
literal|2
expr_stmt|;
comment|/* matrix [i-1, j-1] */
name|cost
operator|=
name|p1
operator|->
name|writecost
expr_stmt|;
if|if
condition|(
name|cost
operator|>
name|p1
operator|->
name|insertcost
condition|)
name|cost
operator|=
name|p1
operator|->
name|insertcost
expr_stmt|;
if|if
condition|(
name|cost
operator|>
name|p1
operator|->
name|deletecost
condition|)
name|cost
operator|=
name|p1
operator|->
name|deletecost
expr_stmt|;
if|if
condition|(
name|old_hash
index|[
name|j
index|]
operator|!=
name|new_hash
index|[
name|i
index|]
condition|)
name|cost
operator|+=
name|draw_cost
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|writecost
operator|=
name|cost
expr_stmt|;
comment|/* Calculate the cost if we do an insert-line 	   before outputting this line. 	   That is, we update through line i-1 	   based on old lines through j, 	   do an insert-line on line i, 	   and then output line i from scratch, 	   leaving old lines starting from j for reuse below.  */
name|p1
operator|=
name|p
operator|-
name|window_size
operator|-
literal|1
expr_stmt|;
comment|/* matrix [i-1, j] */
comment|/* No need to think about doing a delete followed 	   immediately by an insert.  It cannot be as good 	   as not doing either of them.  */
if|if
condition|(
name|free_at_end
operator|==
name|i
condition|)
block|{
name|cost
operator|=
name|p1
operator|->
name|writecost
expr_stmt|;
name|cost1
operator|=
name|p1
operator|->
name|insertcost
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|=
name|p1
operator|->
name|writecost
operator|+
name|first_insert_cost
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|insertcount
operator|>
name|i
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cost1
operator|=
name|p1
operator|->
name|insertcost
operator|+
name|next_insert_cost
index|[
name|i
operator|-
name|p1
operator|->
name|insertcount
index|]
expr_stmt|;
block|}
name|p
operator|->
name|insertcost
operator|=
name|min
argument_list|(
name|cost
argument_list|,
name|cost1
argument_list|)
operator|+
name|draw_cost
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|insertcount
operator|=
operator|(
name|cost
operator|<
name|cost1
operator|)
condition|?
literal|1
else|:
name|p1
operator|->
name|insertcount
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|insertcount
operator|>
name|i
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Calculate the cost if we do a delete line after 	   outputting this line. 	   That is, we update through line i 	   based on old lines through j-1, 	   and throw away old line j.  */
name|p1
operator|=
name|p
operator|-
literal|1
expr_stmt|;
comment|/* matrix [i, j-1] */
comment|/* No need to think about doing an insert followed 	   immediately by a delete.  */
if|if
condition|(
name|free_at_end
operator|==
name|i
condition|)
block|{
name|cost
operator|=
name|p1
operator|->
name|writecost
expr_stmt|;
name|cost1
operator|=
name|p1
operator|->
name|deletecost
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|=
name|p1
operator|->
name|writecost
operator|+
name|first_delete_cost
index|[
name|i
index|]
expr_stmt|;
name|cost1
operator|=
name|p1
operator|->
name|deletecost
operator|+
name|next_delete_cost
index|[
name|i
index|]
expr_stmt|;
block|}
name|p
operator|->
name|deletecost
operator|=
name|min
argument_list|(
name|cost
argument_list|,
name|cost1
argument_list|)
expr_stmt|;
name|p
operator|->
name|deletecount
operator|=
operator|(
name|cost
operator|<
name|cost1
operator|)
condition|?
literal|1
else|:
name|p1
operator|->
name|deletecount
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Perform insert-lines and delete-lines operations  according to the costs in the matrix.  Updates the contents of current_screen to record what was done. */
end_comment

begin_macro
name|do_scrolling
argument_list|(
argument|matrix
argument_list|,
argument|window_size
argument_list|,
argument|unchanged_at_top
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|matrix_elt
modifier|*
name|matrix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|window_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unchanged_at_top
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|matrix_elt
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
struct|struct
name|queue
block|{
name|int
name|count
decl_stmt|,
name|pos
decl_stmt|;
block|}
modifier|*
name|queue
struct|;
name|int
name|offset
init|=
name|unchanged_at_top
decl_stmt|;
name|int
name|qi
init|=
literal|0
decl_stmt|;
name|int
name|window
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|;
name|int
name|next
decl_stmt|;
name|queue
operator|=
operator|(
expr|struct
name|queue
operator|*
operator|)
name|alloca
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|queue
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|current_screen
operator|->
name|contents
argument_list|,
name|temp_screen
operator|->
name|contents
argument_list|,
name|current_screen
operator|->
name|height
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|current_screen
operator|->
name|used
argument_list|,
name|temp_screen
operator|->
name|used
argument_list|,
name|current_screen
operator|->
name|height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|current_screen
operator|->
name|highlight
argument_list|,
name|temp_screen
operator|->
name|highlight
argument_list|,
name|current_screen
operator|->
name|height
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|temp_screen
operator|->
name|enable
argument_list|,
name|temp_screen
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* First do all deletions of lines; queue up insertions.    Also move lines to correct slots in current_screen.  */
name|i
operator|=
name|j
operator|=
name|window_size
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|||
name|j
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|matrix
operator|+
name|i
operator|*
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|+
name|j
expr_stmt|;
name|tem
operator|=
name|p
operator|->
name|insertcost
expr_stmt|;
if|if
condition|(
name|tem
operator|<
name|p
operator|->
name|writecost
operator|&&
name|tem
operator|<
name|p
operator|->
name|deletecost
condition|)
block|{
comment|/* Insert should be done at vpos i-1, plus maybe some before */
name|queue
index|[
name|qi
index|]
operator|.
name|count
operator|=
name|p
operator|->
name|insertcount
expr_stmt|;
name|i
operator|-=
name|p
operator|->
name|insertcount
expr_stmt|;
name|queue
index|[
name|qi
operator|++
index|]
operator|.
name|pos
operator|=
name|i
operator|+
name|unchanged_at_top
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|deletecost
operator|<
name|p
operator|->
name|writecost
condition|)
block|{
comment|/* Old line at vpos j-1, and maybe some before it, 	     should be deleted */
name|j
operator|-=
name|p
operator|->
name|deletecount
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
block|{
name|set_terminal_window
argument_list|(
name|window_size
operator|+
name|unchanged_at_top
argument_list|)
expr_stmt|;
name|window
operator|=
literal|1
expr_stmt|;
block|}
name|ins_del_lines
argument_list|(
name|j
operator|+
name|unchanged_at_top
argument_list|,
operator|-
name|p
operator|->
name|deletecount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Best thing done here is no insert or delete */
comment|/* Old line at vpos j-1 ends up at vpos i-1 */
name|current_screen
operator|->
name|contents
index|[
name|i
operator|+
name|offset
operator|-
literal|1
index|]
operator|=
name|temp_screen
operator|->
name|contents
index|[
name|j
operator|+
name|offset
operator|-
literal|1
index|]
expr_stmt|;
name|current_screen
operator|->
name|used
index|[
name|i
operator|+
name|offset
operator|-
literal|1
index|]
operator|=
name|temp_screen
operator|->
name|used
index|[
name|j
operator|+
name|offset
operator|-
literal|1
index|]
expr_stmt|;
name|current_screen
operator|->
name|highlight
index|[
name|i
operator|+
name|offset
operator|-
literal|1
index|]
operator|=
name|temp_screen
operator|->
name|highlight
index|[
name|j
operator|+
name|offset
operator|-
literal|1
index|]
expr_stmt|;
name|temp_screen
operator|->
name|enable
index|[
name|j
operator|+
name|offset
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|window
operator|&&
name|qi
condition|)
block|{
name|set_terminal_window
argument_list|(
name|window_size
operator|+
name|unchanged_at_top
argument_list|)
expr_stmt|;
name|window
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now do all insertions */
name|next
operator|=
name|unchanged_at_top
expr_stmt|;
for|for
control|(
name|i
operator|=
name|qi
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ins_del_lines
argument_list|(
name|queue
index|[
name|i
index|]
operator|.
name|pos
argument_list|,
name|queue
index|[
name|i
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* Mark the inserted lines as clear, 	 and put into them the line-contents strings 	 that were discarded during the deletions. 	 Those are the ones for which temp_screen->enable was not set.  */
name|tem
operator|=
name|queue
index|[
name|i
index|]
operator|.
name|pos
expr_stmt|;
for|for
control|(
name|j
operator|=
name|tem
operator|+
name|queue
index|[
name|i
index|]
operator|.
name|count
operator|-
literal|1
init|;
name|j
operator|>=
name|tem
condition|;
name|j
operator|--
control|)
block|{
name|current_screen
operator|->
name|enable
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp_screen
operator|->
name|enable
index|[
name|next
index|]
condition|)
name|next
operator|++
expr_stmt|;
name|current_screen
operator|->
name|contents
index|[
name|j
index|]
operator|=
name|temp_screen
operator|->
name|contents
index|[
name|next
operator|++
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|window
condition|)
name|set_terminal_window
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return number of lines in common between current screen contents    and the text to be displayed,    considering only vpos range START to END (not including END).    Ignores short lines (length< 20) on the assumption that    avoiding redrawing such a line will have little weight.  */
end_comment

begin_function
name|int
name|scrolling_max_lines_saved
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|oldhash
parameter_list|,
name|newhash
parameter_list|,
name|cost
parameter_list|)
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
modifier|*
name|oldhash
decl_stmt|,
decl|*
name|newhash
decl_stmt|,
modifier|*
name|cost
decl_stmt|;
end_function

begin_block
block|{
struct|struct
block|{
name|int
name|hash
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
name|lines
index|[
literal|01000
index|]
struct|;
specifier|register
name|int
name|i
decl_stmt|,
name|h
decl_stmt|;
specifier|register
name|int
name|matchcount
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|lines
argument_list|,
sizeof|sizeof
name|lines
argument_list|)
expr_stmt|;
comment|/* Put new lines' hash codes in hash table.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cost
index|[
name|i
index|]
operator|>
literal|20
condition|)
block|{
name|h
operator|=
name|newhash
index|[
name|i
index|]
operator|&
literal|0777
expr_stmt|;
name|lines
index|[
name|h
index|]
operator|.
name|hash
operator|=
name|newhash
index|[
name|i
index|]
expr_stmt|;
name|lines
index|[
name|h
index|]
operator|.
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Look up old line hash codes in the hash table.      Count number of matches between old lines and new.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|oldhash
index|[
name|i
index|]
operator|&
literal|0777
expr_stmt|;
if|if
condition|(
name|oldhash
index|[
name|i
index|]
operator|==
name|lines
index|[
name|h
index|]
operator|.
name|hash
condition|)
block|{
name|matchcount
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|lines
index|[
name|h
index|]
operator|.
name|count
operator|==
literal|0
condition|)
name|lines
index|[
name|h
index|]
operator|.
name|hash
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|matchcount
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return a measure of the cost of moving the lines    starting with vpos FROM, up to but not including vpos TO,    down by AMOUNT lines (AMOUNT may be negative).    These are the same arguments that might be given to    scroll_screen_lines to perform this scrolling.  */
end_comment

begin_macro
name|scroll_cost
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|amount
argument_list|)
end_macro

begin_decl_stmt
name|int
name|from
decl_stmt|,
name|to
decl_stmt|,
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Compute how many lines, at bottom of screen,      will not be involved in actual motion.  */
name|int
name|ok_below
init|=
name|screen_height
operator|-
name|to
decl_stmt|;
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
name|ok_below
operator|-=
name|amount
expr_stmt|;
if|if
condition|(
operator|!
name|scroll_region_ok
condition|)
name|ok_below
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
name|int
name|temp
init|=
name|to
decl_stmt|;
name|to
operator|=
name|from
operator|+
name|amount
expr_stmt|;
name|from
operator|=
name|temp
operator|+
name|amount
expr_stmt|;
name|amount
operator|=
operator|-
name|amount
expr_stmt|;
block|}
name|from
operator|+=
name|ok_below
expr_stmt|;
name|to
operator|+=
name|ok_below
expr_stmt|;
return|return
operator|(
name|ILcost
index|[
name|from
index|]
operator|+
operator|(
name|amount
operator|-
literal|1
operator|)
operator|*
name|ILncost
index|[
name|from
index|]
operator|+
name|DLcost
index|[
name|to
index|]
operator|+
operator|(
name|amount
operator|-
literal|1
operator|)
operator|*
name|DLncost
index|[
name|to
index|]
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Calculate the insert and delete line costs.     We keep the ID costs in a precomputed array based on the position    at which the I or D is performed.  Also, there are two kinds of ID    costs: the "once-only" and the "repeated".  This is to handle both    those terminals that are able to insert N lines at a time (once-    only) and those that must repeatedly insert one line.     The cost to insert N lines at line L is    	    [tt.t_ILov  + (screen_height + 1 - L) * tt.t_ILpf] + 	N * [tt.t_ILnov + (screen_height + 1 - L) * tt.t_ILnpf]     ILov represents the basic insert line overhead.  ILpf is the padding    required to allow the terminal time to move a line: insertion at line    L changes (screen_height + 1 - L) lines.     The first bracketed expression above is the overhead; the second is    the multiply factor.  Both are dependent only on the position at    which the insert is performed.  We store the overhead in ILcost and    the multiply factor in ILncost.  Note however that any insertion    must include at least one multiply factor.  Rather than compute this    as ILcost[line]+ILncost[line], we add ILncost into ILcost.  This is    reasonable because of the particular algorithm used in calcM.     Deletion is essentially the same as insertion.  */
end_comment

begin_macro
name|CalcIDCosts
argument_list|(
argument|ins_line_string
argument_list|,
argument|multi_ins_string
argument_list|,
argument|del_line_string
argument_list|,
argument|multi_del_string
argument_list|,
argument|setup_string
argument_list|,
argument|cleanup_string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ins_line_string
decl_stmt|,
modifier|*
name|multi_ins_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|del_line_string
decl_stmt|,
modifier|*
name|multi_del_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|setup_string
decl_stmt|,
modifier|*
name|cleanup_string
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Discourage long scrolls slightly on fast lines.      This says that scrolling nearly the full length of the screen      is not worth it if reprinting takes less than 1/4 second.  */
name|int
name|extra
init|=
name|baud_rate
operator|/
operator|(
literal|10
operator|*
literal|4
operator|*
name|screen_height
operator|)
decl_stmt|;
if|if
condition|(
name|ILcost
operator|!=
literal|0
condition|)
block|{
name|ILcost
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|ILcost
argument_list|,
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|DLcost
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|DLcost
argument_list|,
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ILncost
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|ILncost
argument_list|,
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|DLncost
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|DLncost
argument_list|,
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ILcost
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|DLcost
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ILncost
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|DLncost
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CalcIDCosts1
argument_list|(
name|ins_line_string
argument_list|,
name|multi_ins_string
argument_list|,
name|setup_string
argument_list|,
name|cleanup_string
argument_list|,
name|ILcost
argument_list|,
name|ILncost
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|CalcIDCosts1
argument_list|(
name|del_line_string
argument_list|,
name|multi_del_string
argument_list|,
name|setup_string
argument_list|,
name|cleanup_string
argument_list|,
name|DLcost
argument_list|,
name|DLncost
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|CalcIDCosts1
argument_list|(
argument|one_line_string
argument_list|,
argument|multi_string
argument_list|,
argument|setup_string
argument_list|,
argument|cleanup_string
argument_list|,
argument|costvec
argument_list|,
argument|ncostvec
argument_list|,
argument|extra
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|one_line_string
decl_stmt|,
modifier|*
name|multi_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|setup_string
decl_stmt|,
modifier|*
name|cleanup_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|costvec
decl_stmt|,
modifier|*
name|ncostvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|calculate_costs_hook
condition|)
call|(
modifier|*
name|calculate_costs_hook
call|)
argument_list|(
name|extra
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dont_calculate_costs
condition|)
name|CalcLID
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|multi_string
condition|)
name|CalcLID
argument_list|(
name|string_cost
argument_list|(
name|multi_string
argument_list|)
argument_list|,
name|per_line_cost
argument_list|(
name|multi_string
argument_list|)
argument_list|,
name|extra
argument_list|,
literal|0
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|one_line_string
condition|)
name|CalcLID
argument_list|(
name|string_cost
argument_list|(
name|setup_string
argument_list|)
operator|+
name|string_cost
argument_list|(
name|cleanup_string
argument_list|)
argument_list|,
literal|0
argument_list|,
name|string_cost
argument_list|(
name|one_line_string
argument_list|)
operator|+
name|extra
argument_list|,
name|per_line_cost
argument_list|(
name|one_line_string
argument_list|)
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
else|else
name|CalcLID
argument_list|(
literal|9999
argument_list|,
literal|0
argument_list|,
literal|9999
argument_list|,
literal|0
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Calculate the line ID overhead and multiply factor values */
end_comment

begin_macro
name|CalcLID
argument_list|(
argument|ov1
argument_list|,
argument|pf1
argument_list|,
argument|ovn
argument_list|,
argument|pfn
argument_list|,
argument|ov
argument_list|,
argument|mf
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ov1
decl_stmt|,
name|ovn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pf1
decl_stmt|,
name|pfn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|ov
decl_stmt|,
modifier|*
name|mf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|insert_overhead
init|=
name|ov1
operator|*
literal|10
operator|+
name|screen_height
operator|*
name|pf1
decl_stmt|;
specifier|register
name|int
name|next_insert_cost
init|=
name|ovn
operator|*
literal|10
operator|+
name|screen_height
operator|*
name|pfn
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_height
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|mf
operator|++
operator|=
name|next_insert_cost
operator|/
literal|10
expr_stmt|;
name|next_insert_cost
operator|-=
name|pfn
expr_stmt|;
operator|*
name|ov
operator|++
operator|=
operator|(
name|insert_overhead
operator|+
name|next_insert_cost
operator|)
operator|/
literal|10
expr_stmt|;
name|insert_overhead
operator|-=
name|pf1
expr_stmt|;
block|}
block|}
end_block

end_unit

