begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Buffer manipulation primitives for GNU Emacs.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_comment
comment|/* in 4.1, param.h fails to define this. */
end_comment

begin_define
define|#
directive|define
name|MAXPATHLEN
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MAXPATHLEN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NULL
end_ifdef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_decl_stmt
name|struct
name|buffer
modifier|*
name|current_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current buffer */
end_comment

begin_comment
comment|/* First buffer in chain of all buffers (in reverse order of creation).    Threaded through ->next.  */
end_comment

begin_decl_stmt
name|struct
name|buffer
modifier|*
name|all_buffers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure holds the default values of the buffer-local variables    defined with DEFVAR_PER_BUFFER, that have special slots in each buffer.    The default value occupies the same slot in this structure    as an individual buffer's value occupies in that buffer.    Setting the default value also goes through the alist of buffers    and stores into each buffer that does not say it has a local value.  */
end_comment

begin_decl_stmt
name|struct
name|buffer
name|buffer_defaults
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A Lisp_Object pointer to the above, used for staticpro */
end_comment

begin_decl_stmt
specifier|static
name|Lisp_Object
name|Vbuffer_defaults
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure marks which slots in a buffer have corresponding    default values in buffer_defaults.    Each such slot has a nonzero value in this structure.    The value has only one nonzero bit.     When a buffer has its own local value for a slot,    the bit for that slot (found in the same slot in this structure)    is turned on in the buffer's local_var_flags slot.     If a slot in this structure is -1, then even though there may    be a DEFVAR_PER_BUFFER for the slot, there is no default value for it;    and the corresponding slot in buffer_defaults is not used.     If a slot is -2, then there is no DEFVAR_PER_BUFFER for it,    but there is a default value which is copied into each buffer.     If a slot in this structure corresponding to a DEFVAR_PER_BUFFER is    zero, that is a bug */
end_comment

begin_decl_stmt
name|struct
name|buffer
name|buffer_local_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure holds the names of symbols whose values may be    buffer-local.  It is indexed and accessed in the same way as the above. */
end_comment

begin_decl_stmt
name|struct
name|buffer
name|buffer_local_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A Lisp_Object pointer to the above, used for staticpro */
end_comment

begin_decl_stmt
specifier|static
name|Lisp_Object
name|Vbuffer_local_symbols
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
name|Fset_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Alist of all buffer names vs the buffers. */
end_comment

begin_comment
comment|/* This used to be a variable, but is no longer,  to prevent lossage due to user rplac'ing this alist or its elements.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vbuffer_alist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qfundamental_mode
decl_stmt|,
name|Qmode_class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|QSFundamental
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A string "Fundamental" */
end_comment

begin_comment
comment|/* For debugging; temporary.  See set_buffer_internal.  */
end_comment

begin_comment
comment|/* Lisp_Object Qlisp_mode, Vcheck_symbol; */
end_comment

begin_macro
name|nsberror
argument_list|(
argument|spec
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|spec
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|spec
argument_list|)
operator|==
name|Lisp_String
condition|)
name|error
argument_list|(
literal|"No buffer named %s"
argument_list|,
name|XSTRING
argument_list|(
name|spec
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid buffer argument"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-list"
argument_list|,
argument|Fbuffer_list
argument_list|,
argument|Sbuffer_list
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a list of all buffers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Fmapcar
argument_list|(
name|Qcdr
argument_list|,
name|Vbuffer_alist
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"get-buffer"
argument_list|,
name|Fget_buffer
argument_list|,
name|Sget_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer named NAME (a string).\n\ It is found by looking up NAME in  buffer-alist.\n\ If there is no buffer named NAME, nil is returned.\n\ NAME may also be a buffer; it is returned."
argument_list|)
argument_list|(
name|name
argument_list|)
specifier|register
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|name
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
return|return
name|name
return|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|Fcdr
argument_list|(
name|Fassoc
argument_list|(
name|name
argument_list|,
name|Vbuffer_alist
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"get-file-buffer"
argument_list|,
name|Fget_file_buffer
argument_list|,
name|Sget_file_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer visiting file FILENAME (a string).\n\ If there is no such buffer, nil is returned."
argument_list|)
argument_list|(
name|filename
argument_list|)
specifier|register
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|buf
decl_stmt|,
name|tem
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
name|CONSP
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|buf
operator|=
name|Fcdr
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|buf
argument_list|)
operator|!=
name|Lisp_Buffer
condition|)
continue|continue;
if|if
condition|(
name|XTYPE
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|filename
argument_list|)
operator|!=
name|Lisp_String
condition|)
continue|continue;
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|buf
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"get-buffer-create"
argument_list|,
name|Fget_buffer_create
argument_list|,
name|Sget_buffer_create
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Like get-buffer but creates a buffer named NAME and returns it if none already exists."
argument_list|)
argument_list|(
name|name
argument_list|)
specifier|register
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buf
decl_stmt|,
name|function
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
comment|/* register struct buffer *bx; */
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|buf
return|;
name|b
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|BUF_GAP_SIZE
argument_list|(
name|b
argument_list|)
operator|=
literal|20
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|BUF_GAP_SIZE
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|memory_full
argument_list|()
expr_stmt|;
block|}
name|BUF_BEG_ADDR
argument_list|(
name|b
argument_list|)
operator|=
name|data
expr_stmt|;
name|BUF_PT
argument_list|(
name|b
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BUF_GPT
argument_list|(
name|b
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BUF_BEGV
argument_list|(
name|b
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BUF_ZV
argument_list|(
name|b
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BUF_Z
argument_list|(
name|b
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BUF_MODIFF
argument_list|(
name|b
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Put this on the chain of all buffers including killed ones.  */
name|b
operator|->
name|next
operator|=
name|all_buffers
expr_stmt|;
name|all_buffers
operator|=
name|b
expr_stmt|;
comment|/* Put this in the alist of all live buffers.  */
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|XSETTYPE (buf, Lisp_Buffer);   bx = b;
comment|/* Use of bx avoids compiler bug on Sun */
block|XSETBUFFER (buf, bx);
endif|#
directive|endif
name|Vbuffer_alist
operator|=
name|nconc2
argument_list|(
name|Vbuffer_alist
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|mark
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|b
operator|->
name|markers
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|name
operator|=
name|name
expr_stmt|;
comment|/* Enable undo in this buffer unless name starts with a space.  */
if|if
condition|(
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
name|b
operator|->
name|undo_list
operator|=
name|Qnil
expr_stmt|;
else|else
name|b
operator|->
name|undo_list
operator|=
name|Qt
expr_stmt|;
name|reset_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|function
operator|=
name|buffer_defaults
operator|.
name|major_mode
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fget
argument_list|(
name|current_buffer
operator|->
name|major_mode
argument_list|,
name|Qmode_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
condition|)
name|function
operator|=
name|current_buffer
operator|->
name|major_mode
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|function
argument_list|)
operator|||
name|EQ
argument_list|(
name|function
argument_list|,
name|Qfundamental_mode
argument_list|)
condition|)
return|return
name|buf
return|;
comment|/* To select a nonfundamental mode,      select the buffer temporarily and then call the mode function. */
name|record_unwind_protect
argument_list|(
name|save_excursion_restore
argument_list|,
name|save_excursion_save
argument_list|()
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|call0
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_comment
comment|/* Reinitialize everything about a buffer except its name and contents.  */
end_comment

begin_function
name|void
name|reset_buffer
parameter_list|(
name|b
parameter_list|)
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
block|{
name|b
operator|->
name|filename
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|directory
operator|=
operator|(
name|current_buffer
operator|)
condition|?
name|current_buffer
operator|->
name|directory
else|:
name|Qnil
expr_stmt|;
name|b
operator|->
name|modtime
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|save_modified
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|save_length
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|last_window_start
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|backed_up
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|auto_save_modified
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|auto_save_file_name
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|read_only
operator|=
name|Qnil
expr_stmt|;
name|reset_buffer_local_variables
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|reset_buffer_local_variables
argument_list|(
name|b
argument_list|)
specifier|register
expr|struct
name|buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|offset
decl_stmt|;
comment|/* Reset the major mode to Fundamental, together with all the      things that depend on the major mode.      default-major-mode is handled at a higher level.      We ignore it here.  */
name|b
operator|->
name|major_mode
operator|=
name|Qfundamental_mode
expr_stmt|;
name|b
operator|->
name|keymap
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|abbrev_table
operator|=
name|Vfundamental_mode_abbrev_table
expr_stmt|;
name|b
operator|->
name|mode_name
operator|=
name|QSFundamental
expr_stmt|;
comment|/* Reset all per-buffer variables to their defaults.  */
name|b
operator|->
name|local_var_alist
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|local_var_flags
operator|=
literal|0
expr_stmt|;
comment|/* For each slot that has a default value,      copy that into the slot.  */
for|for
control|(
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
operator|.
name|name
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
init|;
name|offset
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|buffer
argument_list|)
condition|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
control|)
comment|/* sizeof int == sizeof Lisp_Object */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|offset
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
operator|)
operator|>
literal|0
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|offset
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
operator|)
operator|==
operator|-
literal|2
condition|)
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|offset
operator|+
operator|(
name|char
operator|*
operator|)
name|b
operator|)
operator|=
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|offset
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_defaults
operator|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"generate-new-buffer"
argument_list|,
name|Fgenerate_new_buffer
argument_list|,
name|Sgenerate_new_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Creates and returns a buffer named NAME if one does not already exist,\n\ else tries adding successive suffixes to NAME until a new buffer-name is\n\ formed, then creates and returns a new buffer with that new name."
argument_list|)
argument_list|(
name|name
argument_list|)
specifier|register
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|gentemp
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
name|number
index|[
literal|10
index|]
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fget_buffer
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Fget_buffer_create
argument_list|(
name|name
argument_list|)
return|;
name|count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|number
argument_list|,
literal|"<%d>"
argument_list|,
operator|++
name|count
argument_list|)
expr_stmt|;
name|gentemp
operator|=
name|concat2
argument_list|(
name|name
argument_list|,
name|build_string
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fget_buffer
argument_list|(
name|gentemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Fget_buffer_create
argument_list|(
name|gentemp
argument_list|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"buffer-name"
argument_list|,
name|Fbuffer_name
argument_list|,
name|Sbuffer_name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the name of BUFFER, as a string.\n\ No arg means return name of current buffer."
argument_list|)
argument_list|(
name|buffer
argument_list|)
specifier|register
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|current_buffer
operator|->
name|name
return|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|name
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_comment
comment|/* Useless. If you need this, you should be using `eq'   DEFUN ("buffer-number", Fbuffer_number, Sbuffer_number, 0, 1, 0,     "Return the number of BUFFER.\n\   No arg means return number of current buffer.")     (buffer)        Lisp_Object buffer;   {     if (NULL (buffer))       return current_buffer->number;     CHECK_BUFFER (buffer, 0);     return XBUFFER (buffer)->number;   }  */
end_comment

begin_endif
endif|#
directive|endif
endif|NOTDEF
end_endif

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"buffer-file-name"
argument_list|,
name|Fbuffer_file_name
argument_list|,
name|Sbuffer_file_name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return name of file BUFFER is visiting, or NIL if none.\n\ No argument means use current buffer as BUFFER."
argument_list|)
argument_list|(
name|buffer
argument_list|)
specifier|register
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|current_buffer
operator|->
name|filename
return|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|filename
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"buffer-local-variables"
argument_list|,
name|Fbuffer_local_variables
argument_list|,
name|Sbuffer_local_variables
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return alist of variables that are buffer-local in BUFFER.\n\ No argument means use current buffer as BUFFER.\n\ Each element of the value looks like (SYMBOL . VALUE).\n\ Note that storing new VALUEs in these elements\n\ does not change the local values."
argument_list|)
argument_list|(
name|buffer
argument_list|)
specifier|register
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|buf
operator|=
name|current_buffer
expr_stmt|;
else|else
block|{
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* Reference each variable in the alist in our current buffer.        If inquiring about the current buffer, this gets the current values,        so store them into the alist so the alist is up to date.        If inquiring about some other buffer, this swaps out any values        for that buffer, making the alist up to date automatically.  */
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
for|for
control|(
name|tem
operator|=
name|buf
operator|->
name|local_var_alist
init|;
name|CONSP
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
block|{
name|Lisp_Object
name|v1
init|=
name|Fsymbol_value
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|current_buffer
condition|)
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
operator|=
name|v1
expr_stmt|;
block|}
block|}
comment|/* Make a copy of the alist, to return it.  */
name|val
operator|=
name|Fcopy_alist
argument_list|(
name|buf
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
comment|/* Add on all the variables stored in special slots.  */
block|{
specifier|register
name|int
name|offset
decl_stmt|,
name|mask
decl_stmt|;
for|for
control|(
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_symbols
operator|.
name|name
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_symbols
init|;
name|offset
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|buffer
argument_list|)
condition|;
name|offset
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
control|)
comment|/* sizeof int == sizeof Lisp_Object */
block|{
name|mask
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|offset
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
operator|-
literal|1
operator|||
operator|(
name|buf
operator|->
name|local_var_flags
operator|&
name|mask
operator|)
condition|)
name|val
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|offset
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_symbols
operator|)
argument_list|,
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|offset
operator|+
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"buffer-modified-p"
argument_list|,
name|Fbuffer_modified_p
argument_list|,
name|Sbuffer_modified_p
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if BUFFER is modified since file last read in or saved.\n\ No argument means use current buffer as BUFFER."
argument_list|)
argument_list|(
name|buffer
argument_list|)
specifier|register
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|buf
operator|=
name|current_buffer
expr_stmt|;
else|else
block|{
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|->
name|save_modified
operator|<
name|BUF_MODIFF
argument_list|(
name|buf
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"set-buffer-modified-p"
argument_list|,
name|Fset_buffer_modified_p
argument_list|,
name|Sset_buffer_modified_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Mark current buffer as modified or unmodified according to FLAG."
argument_list|)
argument_list|(
name|flag
argument_list|)
specifier|register
name|Lisp_Object
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|already
decl_stmt|;
specifier|register
name|Lisp_Object
name|fn
decl_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
comment|/* If buffer becoming modified, lock the file.      If buffer becoming unmodified, unlock the file.  */
name|fn
operator|=
name|current_buffer
operator|->
name|filename
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|already
operator|=
name|current_buffer
operator|->
name|save_modified
operator|<
name|MODIFF
expr_stmt|;
if|if
condition|(
operator|!
name|already
operator|&&
operator|!
name|NULL
argument_list|(
name|flag
argument_list|)
condition|)
name|lock_file
argument_list|(
name|fn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|already
operator|&&
name|NULL
argument_list|(
name|flag
argument_list|)
condition|)
name|unlock_file
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|current_buffer
operator|->
name|save_modified
operator|=
name|NULL
argument_list|(
name|flag
argument_list|)
condition|?
name|MODIFF
else|:
literal|0
expr_stmt|;
name|update_mode_lines
operator|++
expr_stmt|;
return|return
name|flag
return|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"rename-buffer"
argument_list|,
name|Frename_buffer
argument_list|,
name|Srename_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sRename buffer (to new name): "
argument_list|,
literal|"Change current buffer's name to NEWNAME (a string)."
argument_list|)
argument_list|(
name|name
argument_list|)
specifier|register
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|,
name|buf
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fget_buffer
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|error
argument_list|(
literal|"Buffer name \"%s\" is in use"
argument_list|,
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|current_buffer
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
expr_stmt|;
name|Fsetcar
argument_list|(
name|Frassq
argument_list|(
name|buf
argument_list|,
name|Vbuffer_alist
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|current_buffer
operator|->
name|filename
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|auto_save_file_name
argument_list|)
condition|)
name|call0
argument_list|(
name|intern
argument_list|(
literal|"rename-auto-save-file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"other-buffer"
argument_list|,
name|Fother_buffer
argument_list|,
name|Sother_buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return most recently selected buffer other than BUFFER.\n\ Buffers not visible in windows are preferred to visible buffers.\n\ If no other exists, the buffer *scratch* is returned.\n\ If BUFFER is omitted or nil, some interesting buffer is returned."
argument_list|)
argument_list|(
name|buffer
argument_list|)
specifier|register
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|buf
decl_stmt|,
name|notsogood
decl_stmt|,
name|tem
decl_stmt|;
name|notsogood
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|buf
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|buf
argument_list|,
name|buffer
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|XSTRING
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
continue|continue;
name|tem
operator|=
name|Fget_buffer_window
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|NULL
argument_list|(
name|notsogood
argument_list|)
condition|)
name|notsogood
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|notsogood
argument_list|)
condition|)
return|return
name|notsogood
return|;
return|return
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"buffer-flush-undo"
argument_list|,
name|Fbuffer_flush_undo
argument_list|,
name|Sbuffer_flush_undo
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Make BUFFER stop keeping undo information."
argument_list|)
argument_list|(
name|buf
argument_list|)
specifier|register
name|Lisp_Object
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_BUFFER
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|undo_list
operator|=
name|Qt
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"buffer-enable-undo"
argument_list|,
name|Fbuffer_enable_undo
argument_list|,
name|Sbuffer_enable_undo
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Start keeping undo information for buffer BUFFER (default is current buffer)."
argument_list|)
argument_list|(
name|buf
argument_list|)
specifier|register
name|Lisp_Object
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|current_buffer
operator|->
name|undo_list
argument_list|,
name|Qt
argument_list|)
condition|)
name|current_buffer
operator|->
name|undo_list
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
block|{
name|CHECK_BUFFER
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|undo_list
argument_list|,
name|Qt
argument_list|)
condition|)
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|undo_list
operator|=
name|Qnil
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"kill-buffer"
argument_list|,
argument|Fkill_buffer
argument_list|,
argument|Skill_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"bKill buffer: "
argument_list|,
literal|"One arg, a string or a buffer.  Get rid of the specified buffer.\n\ Any processes that have this buffer as the `process-buffer' are killed\n\ with `delete-process'."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|bufname
operator|)
name|Lisp_Object
name|bufname
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|buf
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bufname
argument_list|)
condition|)
name|buf
operator|=
name|Fcurrent_buffer
argument_list|()
expr_stmt|;
else|else
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buf
argument_list|)
condition|)
name|nsberror
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|FROM_KBD
operator|&&
operator|!
name|NULL
argument_list|(
name|b
operator|->
name|filename
argument_list|)
operator|&&
name|BUF_MODIFF
argument_list|(
name|b
argument_list|)
operator|>
name|b
operator|->
name|save_modified
condition|)
block|{
name|GCPRO2
argument_list|(
name|buf
argument_list|,
name|bufname
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fyes_or_no_p
argument_list|(
name|format1
argument_list|(
literal|"Buffer %s modified; kill anyway? "
argument_list|,
name|XSTRING
argument_list|(
name|b
operator|->
name|name
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Qnil
return|;
block|}
comment|/* We have no more questions to ask.  Verify that it is valid      to kill the buffer.  This must be done after the questions      since anything can happen within Fyes_or_no_p.  */
comment|/* Don't kill the minibuffer now current.  */
if|if
condition|(
name|EQ
argument_list|(
name|buf
argument_list|,
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|buffer
argument_list|)
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|NULL
argument_list|(
name|b
operator|->
name|name
argument_list|)
condition|)
return|return
name|Qnil
return|;
comment|/* Make this buffer not be current.      In the process, notice if this is the sole visible buffer      and give up if so.  */
if|if
condition|(
name|b
operator|==
name|current_buffer
condition|)
block|{
name|tem
operator|=
name|Fother_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|current_buffer
condition|)
return|return
name|Qnil
return|;
block|}
comment|/* Now there is no question: we can kill the buffer.  */
ifdef|#
directive|ifdef
name|CLASH_DETECTION
comment|/* Unlock this buffer's file, if it is locked.  */
name|unlock_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
ifdef|#
directive|ifdef
name|subprocesses
name|kill_buffer_processes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|subprocesses
name|tem
operator|=
name|Vinhibit_quit
expr_stmt|;
name|Vinhibit_quit
operator|=
name|Qt
expr_stmt|;
name|Vbuffer_alist
operator|=
name|Fdelq
argument_list|(
name|Frassq
argument_list|(
name|buf
argument_list|,
name|Vbuffer_alist
argument_list|)
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|Freplace_buffer_in_windows
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Vinhibit_quit
operator|=
name|tem
expr_stmt|;
comment|/* Unchain all markers of this buffer      and leave them pointing nowhere.  */
for|for
control|(
name|tem
operator|=
name|b
operator|->
name|markers
init|;
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
condition|;
control|)
block|{
name|m
operator|=
name|XMARKER
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|m
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|m
operator|->
name|chain
expr_stmt|;
name|m
operator|->
name|chain
operator|=
name|Qnil
expr_stmt|;
block|}
name|b
operator|->
name|markers
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|name
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|undo_list
operator|=
name|Qnil
expr_stmt|;
name|free
argument_list|(
name|BUF_BEG_ADDR
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Put the element for buffer `buf' at the front of buffer-alist.  This is done when a buffer is selected "visibly".  It keeps buffer-alist in the order of recency of selection  so that other_buffer will return something nice.  */
end_comment

begin_macro
name|record_buffer
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|link
decl_stmt|,
name|prev
decl_stmt|;
name|prev
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|link
operator|=
name|Vbuffer_alist
init|;
name|CONSP
argument_list|(
name|link
argument_list|)
condition|;
name|link
operator|=
name|XCONS
argument_list|(
name|link
argument_list|)
operator|->
name|cdr
control|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|link
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
argument_list|,
name|buf
argument_list|)
condition|)
break|break;
name|prev
operator|=
name|link
expr_stmt|;
block|}
comment|/* Effectively do Vbuffer_alist = Fdelq (link, Vbuffer_alist)      but cannot use Fdelq here it that allows quitting.  */
if|if
condition|(
name|NULL
argument_list|(
name|prev
argument_list|)
condition|)
name|Vbuffer_alist
operator|=
name|XCONS
argument_list|(
name|Vbuffer_alist
argument_list|)
operator|->
name|cdr
expr_stmt|;
else|else
name|XCONS
argument_list|(
name|prev
argument_list|)
operator|->
name|cdr
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|prev
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|XCONS
argument_list|(
name|link
argument_list|)
operator|->
name|cdr
operator|=
name|Vbuffer_alist
expr_stmt|;
name|Vbuffer_alist
operator|=
name|link
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"switch-to-buffer"
argument_list|,
argument|Fswitch_to_buffer
argument_list|,
argument|Sswitch_to_buffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"BSwitch to buffer: "
argument_list|,
literal|"Select buffer BUFFER in the current window.\n\ BUFFER may be a buffer or a buffer name.\n\ Optional second arg NORECORD non-nil means\n\ do not put this buffer at the front of the list of recently selected ones.\n\ \n\ WARNING: This is NOT the way to work on another buffer temporarily\n\ within a Lisp program!  Use `set-buffer' instead.  That avoids messing with\n\ the window-buffer correspondances."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|bufname
operator|,
name|norecord
operator|)
name|Lisp_Object
name|bufname
operator|,
name|norecord
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buf
decl_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|error
argument_list|(
literal|"Cannot switch buffers in minibuffer window"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bufname
argument_list|)
condition|)
name|buf
operator|=
name|Fother_buffer
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|Fget_buffer_create
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|norecord
argument_list|)
condition|)
name|record_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Fset_window_buffer
argument_list|(
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
condition|?
name|Fnext_window
argument_list|(
name|minibuf_window
argument_list|,
name|Qnil
argument_list|)
else|:
name|selected_window
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"pop-to-buffer"
argument_list|,
argument|Fpop_to_buffer
argument_list|,
argument|Spop_to_buffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Select buffer BUFFER in some window, preferably a different one.\n\ If  pop-up-windows  is non-nil, windows can be split to do this.\n\ If second arg  OTHER-WINDOW is non-nil, insist on finding another\n\ window even if BUFFER is already visible in the selected window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|bufname
operator|,
name|other
operator|)
name|Lisp_Object
name|bufname
operator|,
name|other
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buf
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bufname
argument_list|)
condition|)
name|buf
operator|=
name|Fother_buffer
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|Fget_buffer_create
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|record_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Fselect_window
argument_list|(
name|Fdisplay_buffer
argument_list|(
name|buf
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"current-buffer"
argument_list|,
argument|Fcurrent_buffer
argument_list|,
argument|Scurrent_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the current buffer as a Lisp buffer object."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|buf
block|;
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
block|;
return|return
name|buf
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"set-buffer"
argument_list|,
name|Fset_buffer
argument_list|,
name|Sset_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Set the current buffer to the buffer or buffer name supplied as argument.\n\ That buffer will then be the default for editing operations and printing.\n\ This function's effect can't last past end of current command\n\ because returning to command level\n\ selects the chosen buffer of the current window,\n\ and this function has no effect on what buffer that is.\n\ See also `save-excursion' when you want to select a buffer temporarily.\n\ Use `switch-to-buffer' or `pop-to-buffer' for interactive buffer selection."
argument_list|)
argument_list|(
name|bufname
argument_list|)
specifier|register
name|Lisp_Object
name|bufname
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buffer
decl_stmt|;
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|nsberror
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Selecting deleted buffer"
argument_list|)
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"barf-if-buffer-read-only"
argument_list|,
argument|Fbarf_if_buffer_read_only
argument_list|,
argument|Sbarf_if_buffer_read_only
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Signal a  buffer-read-only  error if the current buffer is read-only."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|read_only
argument_list|)
condition|)
name|Fsignal
argument_list|(
name|Qbuffer_read_only
argument_list|,
operator|(
name|Fcons
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
name|Qnil
argument_list|)
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"bury-buffer"
operator|,
name|Fbury_buffer
operator|,
name|Sbury_buffer
operator|,
literal|0
operator|,
literal|1
operator|,
literal|""
operator|,
literal|"Put BUFFER at the end of the list of all buffers.\n\ There it is the least likely candidate for other-buffer to return;\n\ thus, the least likely buffer for \\[switch-to-buffer] to select by default."
operator|)
operator|(
name|buf
operator|)
specifier|register
name|Lisp_Object
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|aelt
decl_stmt|,
name|link
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
expr_stmt|;
name|Fswitch_to_buffer
argument_list|(
name|Fother_buffer
argument_list|(
name|buf
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Lisp_Object
name|buf1
decl_stmt|;
name|buf1
operator|=
name|Fget_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buf1
argument_list|)
condition|)
name|nsberror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|buf1
expr_stmt|;
block|}
name|aelt
operator|=
name|Frassq
argument_list|(
name|buf
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|link
operator|=
name|Fmemq
argument_list|(
name|aelt
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|Vbuffer_alist
operator|=
name|Fdelq
argument_list|(
name|aelt
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|link
argument_list|)
operator|->
name|cdr
operator|=
name|Qnil
expr_stmt|;
name|Vbuffer_alist
operator|=
name|nconc2
argument_list|(
name|Vbuffer_alist
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|last_known_column_point
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|set_buffer_internal
argument_list|(
name|b
argument_list|)
specifier|register
expr|struct
name|buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|swb
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|old_buf
decl_stmt|;
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|valcontents
decl_stmt|;
name|enum
name|Lisp_Type
name|tem
decl_stmt|;
if|if
condition|(
name|current_buffer
operator|==
name|b
condition|)
return|return;
if|#
directive|if
literal|0
block|if (XWINDOW (selected_window) != 0)     swb = NULL (selected_window) ? 0 : XBUFFER (XWINDOW (selected_window)->buffer);
endif|#
directive|endif
name|windows_or_buffers_changed
operator|=
literal|1
expr_stmt|;
comment|/* Vcheck_symbol is set up to the symbol paragraph-start      in order to check for the bug that clobbers it.  */
comment|/* if (current_buffer&& EQ (current_buffer->major_mode, Qlisp_mode)&& XFASTINT (Vcheck_symbol) != 0&& !NULL (Vcheck_symbol))     {       valcontents = XSYMBOL (Vcheck_symbol)->value;       if (XTYPE (valcontents) != Lisp_Some_Buffer_Local_Value) 	abort ();       if (current_buffer == XBUFFER (XCONS (XCONS (valcontents)->cdr)->car)&& (XTYPE (XCONS (valcontents)->car) != Lisp_String 	      || XSTRING (XCONS (valcontents)->car)->size != 6)) 	abort ();     } */
if|#
directive|if
literal|0
block|if (current_buffer == swb&& !NULL (selected_window))     Fset_marker (XWINDOW (selected_window)->pointm, make_number (point), 		 XWINDOW (selected_window)->buffer);
endif|#
directive|endif
name|old_buf
operator|=
name|current_buffer
expr_stmt|;
name|current_buffer
operator|=
name|b
expr_stmt|;
if|#
directive|if
literal|0
block|if (b == swb)     {       SET_PT (marker_position (XWINDOW (selected_window)->pointm));       if (point< BEGV) 	point = BEGV;       if (point> ZV) 	point = ZV;     }
endif|#
directive|endif
name|last_known_column_point
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* invalidate indentation cache */
comment|/* Look down buffer's list of local Lisp variables      to find and update any that forward into C variables. */
for|for
control|(
name|tail
operator|=
name|b
operator|->
name|local_var_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|||
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
operator|)
operator|&&
operator|(
name|tem
operator|=
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|,
operator|(
name|tem
operator|==
name|Lisp_Boolfwd
operator|||
name|tem
operator|==
name|Lisp_Intfwd
operator|||
name|tem
operator|==
name|Lisp_Objfwd
operator|)
operator|)
condition|)
comment|/* Just reference the variable 	     to cause it to become set for this buffer.  */
name|Fsymbol_value
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
comment|/* Do the same with any others that were local to the previous buffer */
if|if
condition|(
name|old_buf
condition|)
for|for
control|(
name|tail
operator|=
name|old_buf
operator|->
name|local_var_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|||
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
operator|)
operator|&&
operator|(
name|tem
operator|=
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|,
operator|(
name|tem
operator|==
name|Lisp_Boolfwd
operator|||
name|tem
operator|==
name|Lisp_Intfwd
operator|||
name|tem
operator|==
name|Lisp_Objfwd
operator|)
operator|)
condition|)
comment|/* Just reference the variable                to cause it to become set for this buffer.  */
name|Fsymbol_value
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
comment|/* Vcheck_symbol is set up to the symbol paragraph-start      in order to check for the bug that clobbers it.  */
comment|/*if (EQ (b->major_mode, Qlisp_mode)&& Vcheck_symbol&& !NULL (Vcheck_symbol))     {       valcontents = XSYMBOL (Vcheck_symbol)->value;       if (XTYPE (valcontents) != Lisp_Some_Buffer_Local_Value) 	abort ();       if (b == XBUFFER (XCONS (XCONS (valcontents)->cdr)->car)&& (XTYPE (XCONS (valcontents)->car) != Lisp_String 	      || XSTRING (XCONS (valcontents)->car)->size != 6)) 	abort ();       Fsymbol_value (Vcheck_symbol);       valcontents = XSYMBOL (Vcheck_symbol)->value;       if (b != XBUFFER (XCONS (XCONS (valcontents)->cdr)->car) 	  || XTYPE (XCONS (valcontents)->car) != Lisp_String 	  || XSTRING (XCONS (valcontents)->car)->size != 6) 	abort ();     }  */
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"erase-buffer"
argument_list|,
argument|Ferase_buffer
argument_list|,
argument|Serase_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Delete the entire contents of the current buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Fwiden
argument_list|()
block|;
name|del_range
argument_list|(
name|BEG
argument_list|,
name|Z
argument_list|)
block|;
name|current_buffer
operator|->
name|last_window_start
operator|=
literal|1
block|;
comment|/* Prevent warnings, or suspension of auto saving, that would happen      if future size is less than past size.  Use of erase-buffer      implies that the future text is not really related to the past text.  */
name|XFASTINT
argument_list|(
name|current_buffer
operator|->
name|save_length
argument_list|)
operator|=
literal|0
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|validate_region
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
specifier|register
name|Lisp_Object
operator|*
name|b
operator|,
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
operator|*
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
operator|*
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
operator|*
name|b
argument_list|)
operator|>
name|XINT
argument_list|(
operator|*
name|e
argument_list|)
condition|)
block|{
name|i
operator|=
name|XFASTINT
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
comment|/* This is legit even if *b is< 0 */
operator|*
name|b
operator|=
operator|*
name|e
expr_stmt|;
name|XFASTINT
argument_list|(
operator|*
name|e
argument_list|)
operator|=
name|i
expr_stmt|;
comment|/* because this is all we do with i.  */
block|}
if|if
condition|(
operator|!
operator|(
name|BEGV
operator|<=
name|XINT
argument_list|(
operator|*
name|b
argument_list|)
operator|&&
name|XINT
argument_list|(
operator|*
name|b
argument_list|)
operator|<=
name|XINT
argument_list|(
operator|*
name|e
argument_list|)
operator|&&
name|XINT
argument_list|(
operator|*
name|e
argument_list|)
operator|<=
name|ZV
operator|)
condition|)
name|args_out_of_range
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|list_buffers_1
parameter_list|(
name|files
parameter_list|)
name|Lisp_Object
name|files
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|tem
decl_stmt|,
name|buf
decl_stmt|;
name|Lisp_Object
name|col1
decl_stmt|,
name|col2
decl_stmt|,
name|col3
decl_stmt|,
name|minspace
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|desired_point
init|=
literal|0
decl_stmt|;
name|XFASTINT
argument_list|(
name|col1
argument_list|)
operator|=
literal|19
expr_stmt|;
name|XFASTINT
argument_list|(
name|col2
argument_list|)
operator|=
literal|25
expr_stmt|;
name|XFASTINT
argument_list|(
name|col3
argument_list|)
operator|=
literal|40
expr_stmt|;
name|XFASTINT
argument_list|(
name|minspace
argument_list|)
operator|=
literal|1
expr_stmt|;
name|Fset_buffer
argument_list|(
name|Vstandard_output
argument_list|)
expr_stmt|;
name|tail
operator|=
name|intern
argument_list|(
literal|"Buffer-menu-mode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|tail
argument_list|,
name|current_buffer
operator|->
name|major_mode
argument_list|)
operator|&&
operator|(
name|tem
operator|=
name|Ffboundp
argument_list|(
name|tail
argument_list|)
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
name|call0
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|Fbuffer_flush_undo
argument_list|(
name|Vstandard_output
argument_list|)
expr_stmt|;
name|current_buffer
operator|->
name|read_only
operator|=
name|Qnil
expr_stmt|;
name|write_string
argument_list|(
literal|"\  MR Buffer         Size  Mode           File\n\  -- ------         ----  ----           ----\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|buf
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Don't mention the minibuffers. */
if|if
condition|(
name|XSTRING
argument_list|(
name|b
operator|->
name|name
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
continue|continue;
comment|/* Optionally don't mention buffers that lack files. */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|files
argument_list|)
operator|&&
name|NULL
argument_list|(
name|b
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
comment|/* Identify the current buffer. */
if|if
condition|(
name|b
operator|==
name|old
condition|)
name|desired_point
operator|=
name|point
expr_stmt|;
name|write_string
argument_list|(
name|b
operator|==
name|old
condition|?
literal|"."
else|:
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Identify modified buffers */
name|write_string
argument_list|(
name|BUF_MODIFF
argument_list|(
name|b
argument_list|)
operator|>
name|b
operator|->
name|save_modified
condition|?
literal|"*"
else|:
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|NULL
argument_list|(
name|b
operator|->
name|read_only
argument_list|)
condition|?
literal|"  "
else|:
literal|"% "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Fprinc
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|col1
argument_list|,
name|make_number
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|tem
argument_list|)
operator|=
name|BUF_Z
argument_list|(
name|b
argument_list|)
operator|-
name|BUF_BEG
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|col2
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
name|Fprinc
argument_list|(
name|b
operator|->
name|mode_name
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|col3
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|b
operator|->
name|filename
argument_list|)
condition|)
name|Fprinc
argument_list|(
name|b
operator|->
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|current_buffer
operator|->
name|read_only
operator|=
name|Qt
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|old
argument_list|)
expr_stmt|;
comment|/* Foo.  This doesn't work since temp_output_buffer_show sets point to 1   if (desired_point)     BUF_PT (XBUFFER (Vstandard_output)) = desired_point;  */
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"list-buffers"
argument_list|,
argument|Flist_buffers
argument_list|,
argument|Slist_buffers
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Display a list of names of existing buffers.\n\ Inserts it in buffer *Buffer List* and displays that.\n\ Note that buffers with names starting with spaces are omitted.\n\ Non-null optional arg FILES-ONLY means mention only file buffers.\n\ \n\ The M column contains a * for buffers that are modified.\n\ The R column contains a % for buffers that are read-only."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|files
operator|)
name|Lisp_Object
name|files
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Buffer List*"
argument_list|,
name|list_buffers_1
argument_list|,
name|files
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"kill-all-local-variables"
argument_list|,
argument|Fkill_all_local_variables
argument_list|,
argument|Skill_all_local_variables
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Eliminate all the buffer-local variable values of the current buffer.\n\ This buffer will then see the default values of all variables."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|alist
block|,
name|sym
block|,
name|tem
block|;
for|for
control|(
name|alist
operator|=
name|current_buffer
operator|->
name|local_var_alist
init|;
operator|!
name|NULL
argument_list|(
name|alist
argument_list|)
condition|;
name|alist
operator|=
name|XCONS
argument_list|(
name|alist
argument_list|)
operator|->
name|cdr
control|)
block|{
name|sym
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|alist
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
expr_stmt|;
comment|/* Need not do anything if some other buffer's binding is now encached.  */
name|tem
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|XBUFFER
argument_list|(
name|tem
argument_list|)
operator|==
name|current_buffer
condition|)
block|{
comment|/* Symbol is set up for this buffer's old local value. 	     Set it up for the current buffer with the default value.  */
name|tem
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
operator|=
name|tem
expr_stmt|;
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
operator|=
name|Fcurrent_buffer
argument_list|()
expr_stmt|;
name|store_symval_forwarding
argument_list|(
name|sym
argument_list|,
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|car
argument_list|,
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    reset_buffer_local_variables
operator|(
name|current_buffer
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_escape
unit|}
end_escape

begin_decl_stmt
unit|extern
name|Lisp_Object
name|Vprin1_to_string_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in print.c */
end_comment

begin_macro
name|init_buffer_once
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
comment|/* Make sure all markable slots in buffer_defaults      are initialized reasonably, so mark_buffer won't choke.  */
name|reset_buffer
argument_list|(
operator|&
name|buffer_defaults
argument_list|)
expr_stmt|;
name|reset_buffer
argument_list|(
operator|&
name|buffer_local_symbols
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|Vbuffer_defaults
argument_list|,
name|Lisp_Buffer
argument_list|,
operator|&
name|buffer_defaults
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|Vbuffer_local_symbols
argument_list|,
name|Lisp_Buffer
argument_list|,
operator|&
name|buffer_local_symbols
argument_list|)
expr_stmt|;
comment|/* Set up the default values of various buffer slots.  */
comment|/* Must do these before making the first buffer! */
comment|/* real setup is done in loaddefs.el */
name|buffer_defaults
operator|.
name|mode_line_format
operator|=
name|build_string
argument_list|(
literal|"%-"
argument_list|)
expr_stmt|;
name|buffer_defaults
operator|.
name|abbrev_mode
operator|=
name|Qnil
expr_stmt|;
name|buffer_defaults
operator|.
name|overwrite_mode
operator|=
name|Qnil
expr_stmt|;
name|buffer_defaults
operator|.
name|case_fold_search
operator|=
name|Qt
expr_stmt|;
name|buffer_defaults
operator|.
name|auto_fill_hook
operator|=
name|Qnil
expr_stmt|;
name|buffer_defaults
operator|.
name|selective_display
operator|=
name|Qnil
expr_stmt|;
name|buffer_defaults
operator|.
name|selective_display_ellipses
operator|=
name|Qt
expr_stmt|;
name|buffer_defaults
operator|.
name|abbrev_table
operator|=
name|Qnil
expr_stmt|;
name|buffer_defaults
operator|.
name|undo_list
operator|=
name|Qnil
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_defaults
operator|.
name|tab_width
argument_list|)
operator|=
literal|8
expr_stmt|;
name|buffer_defaults
operator|.
name|truncate_lines
operator|=
name|Qnil
expr_stmt|;
name|buffer_defaults
operator|.
name|ctl_arrow
operator|=
name|Qt
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_defaults
operator|.
name|fill_column
argument_list|)
operator|=
literal|70
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_defaults
operator|.
name|left_margin
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Assign the local-flags to the slots that have default values.      The local flag is a bit that is used in the buffer      to say that it has its own local value for the slot.      The local flag bits are in the local_var_flags slot of the buffer.  */
comment|/* Nothing can work if this isn't true */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* 0 means not a lisp var, -1 means always local, else mask */
name|bzero
argument_list|(
operator|&
name|buffer_local_flags
argument_list|,
sizeof|sizeof
name|buffer_local_flags
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|filename
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|directory
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|backed_up
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|save_length
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|auto_save_file_name
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|read_only
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|major_mode
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|mode_name
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|undo_list
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|mode_line_format
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|abbrev_mode
argument_list|)
operator|=
literal|2
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|overwrite_mode
argument_list|)
operator|=
literal|4
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|case_fold_search
argument_list|)
operator|=
literal|8
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|auto_fill_hook
argument_list|)
operator|=
literal|0x10
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|selective_display
argument_list|)
operator|=
literal|0x20
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|selective_display_ellipses
argument_list|)
operator|=
literal|0x40
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|tab_width
argument_list|)
operator|=
literal|0x80
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|truncate_lines
argument_list|)
operator|=
literal|0x100
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|ctl_arrow
argument_list|)
operator|=
literal|0x200
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|fill_column
argument_list|)
operator|=
literal|0x400
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|left_margin
argument_list|)
operator|=
literal|0x800
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|abbrev_table
argument_list|)
operator|=
literal|0x1000
expr_stmt|;
name|XFASTINT
argument_list|(
name|buffer_local_flags
operator|.
name|syntax_table
argument_list|)
operator|=
literal|0x2000
expr_stmt|;
name|Vbuffer_alist
operator|=
name|Qnil
expr_stmt|;
name|current_buffer
operator|=
literal|0
expr_stmt|;
name|all_buffers
operator|=
literal|0
expr_stmt|;
name|QSFundamental
operator|=
name|build_string
argument_list|(
literal|"Fundamental"
argument_list|)
expr_stmt|;
name|Qfundamental_mode
operator|=
name|intern
argument_list|(
literal|"fundamental-mode"
argument_list|)
expr_stmt|;
name|buffer_defaults
operator|.
name|major_mode
operator|=
name|Qfundamental_mode
expr_stmt|;
name|Qmode_class
operator|=
name|intern
argument_list|(
literal|"mode-class"
argument_list|)
expr_stmt|;
name|Vprin1_to_string_buffer
operator|=
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|" prin1"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* super-magic invisible buffer */
name|Vbuffer_alist
operator|=
name|Qnil
expr_stmt|;
name|tem
operator|=
name|Fset_buffer
argument_list|(
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Want no undo records for *scratch*      until after Emacs is dumped */
name|Fbuffer_flush_undo
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|init_buffer
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|Fset_buffer
argument_list|(
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getwd
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"`getwd' failed: %s.\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/* Maybe this should really use some standard subroutine      whose definition is filename syntax dependent.  */
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
name|current_buffer
operator|->
name|directory
operator|=
name|build_string
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* initialize the buffer routines */
end_comment

begin_macro
name|syms_of_buffer
argument_list|()
end_macro

begin_block
block|{
name|staticpro
argument_list|(
operator|&
name|Vbuffer_defaults
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vbuffer_local_symbols
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qfundamental_mode
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qmode_class
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|QSFundamental
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vbuffer_alist
argument_list|)
expr_stmt|;
comment|/*staticpro (&Qlisp_mode);   Qlisp_mode = intern ("lisp-mode"); */
comment|/* All these use DEFVAR_LISP_NOPRO because the slots in      buffer_defaults will all be marked via Vbuffer_defaults.  */
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-mode-line-format"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|mode_line_format
argument_list|,
literal|"Default mode-line-format for buffers that do not override it.\n\ This is the same as (default-value 'mode-line-format)."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-abbrev-mode"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|abbrev_mode
argument_list|,
literal|"Default abbrev-mode for buffers that do not override it.\n\ This is the same as (default-value 'abbrev-mode)."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-ctl-arrow"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|ctl_arrow
argument_list|,
literal|"Default ctl-arrow for buffers that do not override it.\n\ This is the same as (default-value 'ctl-arrow)."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-truncate-lines"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|truncate_lines
argument_list|,
literal|"Default truncate-lines for buffers that do not override it.\n\ This is the same as (default-value 'truncate-lines)."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-fill-column"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|fill_column
argument_list|,
literal|"Default fill-column for buffers that do not override it.\n\ This is the same as (default-value 'fill-column)."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-left-margin"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|left_margin
argument_list|,
literal|"Default left-margin for buffers that do not override it.\n\ This is the same as (default-value 'left-margin)."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-tab-width"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|tab_width
argument_list|,
literal|"Default tab-width for buffers that do not override it.\n\ This is the same as (default-value 'tab-width)."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-case-fold-search"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|case_fold_search
argument_list|,
literal|"Default case-fold-search for buffers that do not override it.\n\ This is the same as (default-value 'case-fold-search)."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"mode-line-format"
argument_list|,
operator|&
name|current_buffer
operator|->
name|mode_line_format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This doc string is too long for cpp; cpp dies.   DEFVAR_PER_BUFFER ("mode-line-format",&current_buffer->mode_line_format,     "Template for displaying mode line for current buffer.\n\ Each buffer has its own value of this variable.\n\ Value may be a string, a symbol or a list or cons cell.\n\ For a symbol, its value is used (but it is ignored if t or nil).\n\  A string appearing directly as the value of a symbol is processed verbatim\n\  in that the %-constructs below are not recognized.\n\ For a list whose car is a symbol, the symbol's value is taken,\n\  and if that is non-nil, the cadr of the list is processed recursively.\n\  Otherwise, the caddr of the list (if there is one) is processed.\n\ For a list whose car is a string or list, each element is processed\n\  recursively and the results are effectively concatenated.\n\ For a list whose car is an integer, the cdr of the list is processed\n\   and padded (if the number is positive) or truncated (if negative)\n\   to the width specified by that number.\n\ A string is printed verbatim in the mode line except for %-constructs:\n\   (%-constructs are allowed when the string is the entire mode-line-format\n\    or when it is found in a cons-cell or a list)\n\   %b -- print buffer name.      %f -- print visited file name.\n\   %* -- print *, % or hyphen.   %m -- print value of mode-name (obsolete).\n\   %s -- print process status.   %M -- print value of global-mode-string. (obs)\n\   %p -- print percent of buffer above top of window, or top, bot or all.\n\   %n -- print Narrow if appropriate.\n\   %[ -- print one [ for each recursive editing level.  %] similar.\n\   %% -- print %.   %- -- print infinitely many dashes.\n\ Decimal digits after the % specify field width to which to pad."); */
name|DEFVAR_LISP_NOPRO
argument_list|(
literal|"default-major-mode"
argument_list|,
operator|&
name|buffer_defaults
operator|.
name|major_mode
argument_list|,
literal|"*Major mode for new buffers.  Defaults to fundamental-mode.\n\ nil here means use current buffer's major mode."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"major-mode"
argument_list|,
operator|&
name|current_buffer
operator|->
name|major_mode
argument_list|,
literal|"Symbol for current buffer's major mode."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"abbrev-mode"
argument_list|,
operator|&
name|current_buffer
operator|->
name|abbrev_mode
argument_list|,
literal|"Non-nil turns on automatic expansion of abbrevs when inserted.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"case-fold-search"
argument_list|,
operator|&
name|current_buffer
operator|->
name|case_fold_search
argument_list|,
literal|"*Non-nil if searches should ignore case.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"mode-name"
argument_list|,
operator|&
name|current_buffer
operator|->
name|mode_name
argument_list|,
literal|"Pretty name of current buffer's major mode (a string)."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"fill-column"
argument_list|,
operator|&
name|current_buffer
operator|->
name|fill_column
argument_list|,
literal|"*Column beyond which automatic line-wrapping should happen.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"left-margin"
argument_list|,
operator|&
name|current_buffer
operator|->
name|left_margin
argument_list|,
literal|"*Column for the default indent-line-function to indent to.\n\ Linefeed indents to this column in Fundamental mode.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"tab-width"
argument_list|,
operator|&
name|current_buffer
operator|->
name|tab_width
argument_list|,
literal|"*Distance between tab stops (for display of tab characters), in columns.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"ctl-arrow"
argument_list|,
operator|&
name|current_buffer
operator|->
name|ctl_arrow
argument_list|,
literal|"*Non-nil means display control chars with uparrow.\n\ Nil means use backslash and octal digits.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"truncate-lines"
argument_list|,
operator|&
name|current_buffer
operator|->
name|truncate_lines
argument_list|,
literal|"*Non-nil means do not display continuation lines;\n\ give each line of text one screen line.\n\ Automatically becomes local when set in any fashion.\n\ \n\ Note that this is overridden by the variable\n\ truncate-partial-width-windows if that variable is non-nil\n\ and this buffer is not full-screen width."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"default-directory"
argument_list|,
operator|&
name|current_buffer
operator|->
name|directory
argument_list|,
literal|"Name of default directory of current buffer.  Should end with slash."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"auto-fill-hook"
argument_list|,
operator|&
name|current_buffer
operator|->
name|auto_fill_hook
argument_list|,
literal|"Function called (if non-nil) after self-inserting a space at column beyond fill-column"
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"buffer-file-name"
argument_list|,
operator|&
name|current_buffer
operator|->
name|filename
argument_list|,
literal|"Name of file visited in current buffer, or nil if not visiting a file."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"buffer-auto-save-file-name"
argument_list|,
operator|&
name|current_buffer
operator|->
name|auto_save_file_name
argument_list|,
literal|"Name of file for auto-saving current buffer,\n\ or nil if buffer should not be auto-saved."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"buffer-read-only"
argument_list|,
operator|&
name|current_buffer
operator|->
name|read_only
argument_list|,
literal|"Non-nil if this buffer is read-only."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"buffer-backed-up"
argument_list|,
operator|&
name|current_buffer
operator|->
name|backed_up
argument_list|,
literal|"Non-nil if this buffer's file has been backed up.\n\ Backing up is done before the first time the file is saved."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"buffer-saved-size"
argument_list|,
operator|&
name|current_buffer
operator|->
name|save_length
argument_list|,
literal|"Length of current buffer when last read in, saved or auto-saved.\n\ 0 initially."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"selective-display"
argument_list|,
operator|&
name|current_buffer
operator|->
name|selective_display
argument_list|,
literal|"t enables selective display:\n\  after a ^M, all the rest of the line is invisible.\n\  ^M's in the file are written into files as newlines.\n\ Integer n as value means display only lines\n\  that start with less than n columns of space.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"selective-display-ellipses"
argument_list|,
operator|&
name|current_buffer
operator|->
name|selective_display_ellipses
argument_list|,
literal|"t means display ... on previous line when a line is invisible.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"overwrite-mode"
argument_list|,
operator|&
name|current_buffer
operator|->
name|overwrite_mode
argument_list|,
literal|"Non-nil if self-insertion should replace existing text.\n\ Automatically becomes local when set in any fashion."
argument_list|)
expr_stmt|;
name|DEFVAR_PER_BUFFER
argument_list|(
literal|"buffer-undo-list"
argument_list|,
operator|&
name|current_buffer
operator|->
name|undo_list
argument_list|,
literal|"List of undo entries in current buffer."
argument_list|)
expr_stmt|;
comment|/*DEFVAR_LISP ("debug-check-symbol",&Vcheck_symbol,     "Don't ask."); */
name|defsubr
argument_list|(
operator|&
name|Sbuffer_list
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_file_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_buffer_create
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgenerate_new_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_name
argument_list|)
expr_stmt|;
comment|/*defsubr (&Sbuffer_number);*/
name|defsubr
argument_list|(
operator|&
name|Sbuffer_file_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_local_variables
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_modified_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_buffer_modified_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srename_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sother_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_flush_undo
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_enable_undo
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skill_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Serase_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sswitch_to_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spop_to_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbarf_if_buffer_read_only
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbury_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slist_buffers
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skill_all_local_variables
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_buffer
argument_list|()
end_macro

begin_block
block|{
name|ndefkey
argument_list|(
name|Vctl_x_map
argument_list|,
literal|'b'
argument_list|,
literal|"switch-to-buffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vctl_x_map
argument_list|,
literal|'k'
argument_list|,
literal|"kill-buffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vctl_x_map
argument_list|,
name|Ctl
argument_list|(
literal|'B'
argument_list|)
argument_list|,
literal|"list-buffers"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

