begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Environment-hacking for GNU Emacs subprocess    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAINTAIN_ENVIRONMENT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_expr_stmt
name|you
name|lose
operator|--
name|this
name|is
name|un
operator|*
name|x
operator|-
name|only
endif|#
directive|endif
comment|/* alist of (name-string . value-string) */
name|Lisp_Object
name|Venvironment_alist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_environment_alist
parameter_list|(
name|str
parameter_list|,
name|val
parameter_list|)
specifier|register
name|Lisp_Object
name|str
decl_stmt|,
name|val
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fassoc
argument_list|(
name|str
argument_list|,
name|Venvironment_alist
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
empty_stmt|;
else|else
name|Venvironment_alist
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
argument_list|,
name|Venvironment_alist
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
name|Venvironment_alist
operator|=
name|Fdelq
argument_list|(
name|tem
argument_list|,
name|Venvironment_alist
argument_list|)
expr_stmt|;
else|else
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_environment_alist
parameter_list|()
block|{
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|e
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
for|for
control|(
name|e
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|environ
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
block|{
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
operator|*
name|e
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|set_environment_alist
argument_list|(
name|make_string
argument_list|(
operator|*
name|e
argument_list|,
name|s
operator|-
operator|*
name|e
argument_list|)
argument_list|,
name|build_string
argument_list|(
name|s
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|unsigned
name|char
modifier|*
name|getenv_1
parameter_list|(
name|str
parameter_list|,
name|ephemeral
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|ephemeral
decl_stmt|;
comment|/* if ephmeral, don't need to gc-proof */
block|{
specifier|register
name|Lisp_Object
name|env
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
for|for
control|(
name|env
operator|=
name|Venvironment_alist
init|;
name|CONSP
argument_list|(
name|env
argument_list|)
condition|;
name|env
operator|=
name|XCONS
argument_list|(
name|env
argument_list|)
operator|->
name|cdr
control|)
block|{
specifier|register
name|Lisp_Object
name|car
init|=
name|XCONS
argument_list|(
name|env
argument_list|)
operator|->
name|car
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
init|=
name|XCONS
argument_list|(
name|car
argument_list|)
operator|->
name|car
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
operator|)
operator|&&
operator|(
operator|!
name|bcmp
argument_list|(
name|str
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
comment|/* Found it in the lisp environment */
name|tem
operator|=
name|XCONS
argument_list|(
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|ephemeral
condition|)
comment|/* Caller promises that gc won't make him lose */
return|return
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
return|;
else|else
block|{
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|e
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|ll
init|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
decl_stmt|;
comment|/* Look for element in the original unix environment */
for|for
control|(
name|e
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|environ
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|str
argument_list|,
operator|*
name|e
argument_list|,
name|len
argument_list|)
operator|&&
operator|*
operator|(
operator|*
name|e
operator|+
name|len
operator|)
operator|==
literal|'='
condition|)
block|{
name|s
operator|=
operator|*
name|e
operator|+
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|>=
name|ll
condition|)
comment|/* User hasn't either hasn't munged it or has set it 			 to something shorter -- we don't have to cons */
goto|goto
name|copy
goto|;
else|else
goto|goto
name|cons
goto|;
block|}
empty_stmt|;
name|cons
label|:
comment|/* User has setenv'ed it to a diferent value, and our caller 		 isn't guaranteeing that he won't stash it away somewhere. 		 We can't just return a pointer to the lisp string, as that 		 will be corrupted when gc happens.  So, we cons (in such 		 a way that it can't be freed -- though this isn't such a 		 problem since the only callers of getenv (as opposed to 		 those of egetenv) are very early, before the user -could- 		 have frobbed the environment. */
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|ll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|copy
label|:
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|s
argument_list|,
name|ll
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* unsigned  -- stupid delcaration in lisp.h */
end_comment

begin_function
name|char
modifier|*
name|getenv
parameter_list|(
name|str
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|getenv_1
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|egetenv
parameter_list|(
name|str
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
operator|(
name|getenv_1
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|(
literal|1
operator|==
literal|1
operator|)
end_if

begin_comment
comment|/* use caller-alloca versions, rather than callee-malloc */
end_comment

begin_function
name|int
name|size_of_current_environ
parameter_list|()
block|{
specifier|register
name|int
name|size
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Flength
argument_list|(
name|Venvironment_alist
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|XINT
argument_list|(
name|tem
argument_list|)
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
expr_stmt|;
comment|/* + 1 for environment-terminating 0 */
for|for
control|(
name|tem
operator|=
name|Venvironment_alist
init|;
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
block|{
specifier|register
name|Lisp_Object
name|str
decl_stmt|,
name|val
decl_stmt|;
name|str
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
expr_stmt|;
name|val
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|size
operator|+=
operator|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
operator|+
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* 1 for '=', 1 for '\000' */
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
name|void
name|get_current_environ
parameter_list|(
name|memory_block
parameter_list|)
name|unsigned
name|char
modifier|*
modifier|*
name|memory_block
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|e
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|e
operator|=
name|memory_block
expr_stmt|;
name|tem
operator|=
name|Flength
argument_list|(
name|Venvironment_alist
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|memory_block
operator|+
operator|(
name|XINT
argument_list|(
name|tem
argument_list|)
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|Venvironment_alist
init|;
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
block|{
specifier|register
name|Lisp_Object
name|str
decl_stmt|,
name|val
decl_stmt|;
name|str
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
expr_stmt|;
name|val
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
operator|*
name|e
operator|++
operator|=
name|s
expr_stmt|;
name|len
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'='
expr_stmt|;
name|len
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\000'
expr_stmt|;
block|}
operator|*
name|e
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* dead code (this function mallocs, caller frees) superseded by above (which allows caller to use alloca) */
end_comment

begin_function
name|unsigned
name|char
modifier|*
modifier|*
name|current_environ
parameter_list|()
block|{
name|unsigned
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|e
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|env_len
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|str
decl_stmt|,
name|val
decl_stmt|;
name|tem
operator|=
name|Flength
argument_list|(
name|Venvironment_alist
argument_list|)
expr_stmt|;
name|env_len
operator|=
operator|(
name|XINT
argument_list|(
name|tem
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* + 1 for terminating 0 */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|Venvironment_alist
init|;
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
block|{
name|str
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
expr_stmt|;
name|val
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|len
operator|+=
operator|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
operator|+
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
operator|+
literal|2
operator|)
expr_stmt|;
block|}
name|e
operator|=
name|env
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|env_len
operator|+
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|env
operator|+
name|env_len
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|Venvironment_alist
init|;
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
block|{
name|str
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
expr_stmt|;
name|val
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
expr_stmt|;
operator|*
name|e
operator|++
operator|=
name|s
expr_stmt|;
name|len
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'='
expr_stmt|;
name|len
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\000'
expr_stmt|;
block|}
operator|*
name|e
operator|=
literal|0
expr_stmt|;
return|return
name|env
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* dead code */
end_comment

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"getenv"
argument_list|,
argument|Fgetenv
argument_list|,
argument|Sgetenv
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"sEnvironment variable: \np"
argument_list|,
literal|"Return the value of environment variable VAR, as a string.\n\ When invoked interactively, print the value in the echo area.\n\ VAR is a string, the name of the variable,\n\  or the symbol t, meaning to return an alist representing the\n\  current environment."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|,
name|interactivep
operator|)
name|Lisp_Object
name|str
operator|,
name|interactivep
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|Qt
condition|)
comment|/* If arg is t, return whole environment */
return|return
operator|(
name|Fcopy_alist
argument_list|(
name|Venvironment_alist
argument_list|)
operator|)
return|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fcdr
argument_list|(
name|Fassoc
argument_list|(
name|str
argument_list|,
name|Venvironment_alist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|interactivep
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
name|message
argument_list|(
literal|"%s not defined in environment"
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"\"%s\""
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"setenv"
argument_list|,
argument|Fsetenv
argument_list|,
argument|Ssetenv
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"sEnvironment variable: \nsSet %s to value: "
argument_list|,
literal|"Return the value of environment variable VAR, as a string.\n\ When invoked interactively, print the value in the echo area.\n\ VAR is a string, the name of the variable."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|,
name|val
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_environment_alist
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_environ
argument_list|()
end_macro

begin_block
block|{
name|staticpro
argument_list|(
operator|&
name|Venvironment_alist
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssetenv
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgetenv
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|init_environ
argument_list|()
end_macro

begin_block
block|{
name|Venvironment_alist
operator|=
name|Qnil
expr_stmt|;
name|initialize_environment_alist
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAINTAIN_ENVIRONMENT */
end_comment

end_unit

