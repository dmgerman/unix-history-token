begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* X Communication module for terminals which understand the X protocol.    Copyright (C) 1986, 1988 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.   * X pop-up deck-of-cards menu facility for gnuemacs.  *  * Written by Jon Arnold and Roman Budzianowski  * Mods and rewrite by Robert Krawitz  *  */
end_comment

begin_comment
comment|/* $Source: /u2/third_party/gnuemacs.chow/src/RCS/xmenu.c,v $  * $Author: rlk $  * $Locker:  $  * $Header: xmenu.c,v 1.6 86/08/26 17:23:26 rlk Exp $  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_GXMenu_c
init|=
literal|"$Header: xmenu.c,v 1.6 86/08/26 17:23:26 rlk Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* On 4.3 this loses if it comes after xterm.h.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_comment
comment|/* This may include sys/types.h, and that somehow loses    if this is not done before the other system files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|X11
end_ifdef

begin_include
include|#
directive|include
file|"x11term.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"xterm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Load sys/types.h if not already loaded.    In some systems loading it twice is suicidal.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|makedev
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|X11
end_ifdef

begin_include
include|#
directive|include
file|"../oldXMenu/XMenu.h"
end_include

begin_define
define|#
directive|define
name|X11ONLY
parameter_list|(
name|arg
parameter_list|)
value|arg,
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<X/XMenu.h>
end_include

begin_define
define|#
directive|define
name|X11ONLY
parameter_list|(
name|arg
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)< (y)) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)> (y)) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|NUL
value|0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
endif|TRUE
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|X11
end_ifdef

begin_decl_stmt
specifier|extern
name|XFontStruct
modifier|*
name|fontinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Display
modifier|*
name|XXdisplay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Window
name|XXwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXfontw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|XXfonth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXscreen
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|XXxoffset
decl_stmt|,
name|XXyoffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FontInfo
modifier|*
name|fontinfo
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ButtonReleaseMask
value|ButtonReleased
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not X11 */
end_comment

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*************************************************************/
end_comment

begin_comment
comment|/* Ignoring the args is easiest.  */
end_comment

begin_macro
name|XMenuQuit
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"Unknown XMenu error"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"x-popup-menu"
argument_list|,
argument|Fx_popup_menu
argument_list|,
argument|Sx_popup_menu
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Interface to XMenu library; permits creation and use of\n\ deck-of-cards pop-up menus.\n\ \n\ ARG is a position specification; it is a list of (Xoffset, Yoffset)\n\ from the top-left corner of the editor window.  Note that this offset\n\ is relative to the center of the first line in the first pane of the\n\ menu, not the top left of the menu as a whole.\n\ \n\ MENU is a specifier for a menu.  It is a list of the form\n\ (title pane1 pane2...), and each pane is a list of form\n\ (title (line item)...).  Each line should be a string, and item should\n\ be the return value for that line (i. e. if it is selected."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|,
name|menu
operator|)
name|Lisp_Object
name|arg
operator|,
name|menu
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|number_of_panes
decl_stmt|;
name|Lisp_Object
name|XMenu_return
decl_stmt|;
name|int
name|XMenu_xpos
decl_stmt|,
name|XMenu_ypos
decl_stmt|;
name|char
modifier|*
modifier|*
name|menus
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|names
decl_stmt|;
name|Lisp_Object
modifier|*
modifier|*
name|obj_list
decl_stmt|;
name|int
modifier|*
name|items
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|char
modifier|*
name|error_name
decl_stmt|;
name|Lisp_Object
name|ltitle
decl_stmt|,
name|selection
decl_stmt|;
name|Lisp_Object
name|XEmacsMenu
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|X11
name|Window
name|root_window
decl_stmt|,
name|wjunk
decl_stmt|;
name|int
name|ijunk
decl_stmt|;
specifier|extern
name|Lisp_Object
name|Vx_mouse_abs_pos
decl_stmt|;
endif|#
directive|endif
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|check_xterm
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|X11
if|#
directive|if
literal|0
block|if (interrupt_input)     unrequest_sigio ();
endif|#
directive|endif
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|root_window
operator|=
name|RootWindow
argument_list|(
name|XXdisplay
argument_list|,
name|DefaultScreen
argument_list|(
name|XXdisplay
argument_list|)
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|XMenu_xpos
operator|=
name|Fcar
argument_list|(
name|Vx_mouse_abs_pos
argument_list|)
expr_stmt|;
name|XMenu_ypos
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|Vx_mouse_abs_pos
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (interrupt_input)     request_sigio ();
endif|#
directive|endif
else|#
directive|else
name|XMenu_xpos
operator|=
name|fontinfo
operator|->
name|width
operator|*
name|XINT
argument_list|(
name|Fcar
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|XMenu_ypos
operator|=
name|fontinfo
operator|->
name|height
operator|*
name|XINT
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XMenu_xpos
operator|+=
name|XXxoffset
expr_stmt|;
name|XMenu_ypos
operator|+=
name|XXyoffset
expr_stmt|;
endif|#
directive|endif
name|ltitle
operator|=
name|Fcar
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|ltitle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|title
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|ltitle
argument_list|)
operator|->
name|data
expr_stmt|;
name|number_of_panes
operator|=
name|list_of_panes
argument_list|(
operator|&
name|obj_list
argument_list|,
operator|&
name|menus
argument_list|,
operator|&
name|names
argument_list|,
operator|&
name|items
argument_list|,
name|Fcdr
argument_list|(
name|menu
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Panes= %d\n"
argument_list|,
name|number_of_panes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_panes
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Pane %d lines %d title %s\n"
argument_list|,
name|i
argument_list|,
name|items
index|[
name|i
index|]
argument_list|,
name|menus
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|items
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    Item %d %s\n"
argument_list|,
name|j
argument_list|,
name|names
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|X11
name|XSetErrorHandler
argument_list|(
name|XMenuQuit
argument_list|)
expr_stmt|;
name|selection
operator|=
name|XEmacsMenu
argument_list|(
name|root_window
argument_list|,
name|XMenu_xpos
argument_list|,
name|XMenu_ypos
argument_list|,
name|names
argument_list|,
name|menus
argument_list|,
name|items
argument_list|,
name|number_of_panes
argument_list|,
name|obj_list
argument_list|,
name|title
argument_list|,
operator|&
name|error_name
argument_list|)
expr_stmt|;
name|XSetErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
else|#
directive|else
name|XErrorHandler
argument_list|(
name|XMenuQuit
argument_list|)
expr_stmt|;
name|selection
operator|=
name|XEmacsMenu
argument_list|(
name|RootWindow
argument_list|,
name|XMenu_xpos
argument_list|,
name|XMenu_ypos
argument_list|,
name|names
argument_list|,
name|menus
argument_list|,
name|items
argument_list|,
name|number_of_panes
argument_list|,
name|obj_list
argument_list|,
name|title
argument_list|,
operator|&
name|error_name
argument_list|)
expr_stmt|;
name|XErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|force_input_read
argument_list|()
expr_stmt|;
comment|/** fprintf(stderr,"selection = %x\n",selection);  **/
if|if
condition|(
name|selection
operator|!=
name|NUL
condition|)
block|{
comment|/* selected something */
name|XMenu_return
operator|=
name|selection
expr_stmt|;
block|}
else|else
block|{
comment|/* nothing selected */
name|XMenu_return
operator|=
name|Qnil
expr_stmt|;
block|}
comment|/* now free up the strings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_panes
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|menus
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obj_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|names
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|items
argument_list|)
expr_stmt|;
comment|/*   free(title); */
if|if
condition|(
name|error_name
condition|)
name|error
argument_list|(
name|error_name
argument_list|)
expr_stmt|;
return|return
name|XMenu_return
return|;
block|}
end_block

begin_struct
struct|struct
name|indices
block|{
name|int
name|pane
decl_stmt|;
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|Lisp_Object
name|XEmacsMenu
parameter_list|(
name|parent
parameter_list|,
name|startx
parameter_list|,
name|starty
parameter_list|,
name|line_list
parameter_list|,
name|pane_list
parameter_list|,
name|line_cnt
parameter_list|,
name|pane_cnt
parameter_list|,
name|item_list
parameter_list|,
name|title
parameter_list|,
name|error
parameter_list|)
name|Window
name|parent
decl_stmt|;
name|int
name|startx
decl_stmt|,
name|starty
decl_stmt|;
comment|/* upper left corner position BROKEN */
name|char
modifier|*
modifier|*
name|line_list
index|[]
decl_stmt|;
comment|/* list of strings for items */
name|char
modifier|*
name|pane_list
index|[]
decl_stmt|;
comment|/* list of pane titles */
name|char
modifier|*
name|title
decl_stmt|;
name|int
name|pane_cnt
decl_stmt|;
comment|/* total number of panes */
name|Lisp_Object
modifier|*
name|item_list
index|[]
decl_stmt|;
comment|/* All items */
name|int
name|line_cnt
index|[]
decl_stmt|;
comment|/* Lines in each pane */
name|char
modifier|*
modifier|*
name|error
decl_stmt|;
comment|/* Error returned */
block|{
name|XMenu
modifier|*
name|GXMenu
decl_stmt|;
name|int
name|last
decl_stmt|,
name|panes
decl_stmt|,
name|selidx
decl_stmt|,
name|lpane
decl_stmt|,
name|status
decl_stmt|;
name|int
name|lines
decl_stmt|,
name|sofar
decl_stmt|;
name|Lisp_Object
name|entry
decl_stmt|;
comment|/* struct indices *datap, *datap_save; */
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|ulx
init|=
literal|0
decl_stmt|,
name|uly
init|=
literal|0
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|dispwidth
decl_stmt|,
name|dispheight
decl_stmt|;
operator|*
name|error
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Initialize error pointer to null */
if|if
condition|(
operator|(
name|GXMenu
operator|=
name|XMenuCreate
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|parent
argument_list|,
literal|"emacs"
argument_list|)
operator|)
operator|==
name|NUL
condition|)
block|{
operator|*
name|error
operator|=
literal|"Can't create menu"
expr_stmt|;
comment|/* error("Can't create menu"); */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|panes
operator|=
literal|0
operator|,
name|lines
operator|=
literal|0
init|;
name|panes
operator|<
name|pane_cnt
condition|;
name|lines
operator|+=
name|line_cnt
index|[
name|panes
index|]
operator|,
name|panes
operator|++
control|)
empty_stmt|;
comment|/* datap = (struct indices *) xmalloc (lines * sizeof(struct indices)); */
comment|/*datap = (char *) xmalloc(lines * sizeof(char));     datap_save = datap;*/
for|for
control|(
name|panes
operator|=
literal|0
operator|,
name|sofar
operator|=
literal|0
init|;
name|panes
operator|<
name|pane_cnt
condition|;
name|sofar
operator|+=
name|line_cnt
index|[
name|panes
index|]
operator|,
name|panes
operator|++
control|)
block|{
comment|/* create all the necessary panes */
if|if
condition|(
operator|(
name|lpane
operator|=
name|XMenuAddPane
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|,
name|pane_list
index|[
name|panes
index|]
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|XM_FAILURE
condition|)
block|{
name|XMenuDestroy
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
literal|"Can't create pane"
expr_stmt|;
comment|/* error("Can't create pane"); */
comment|/* free(datap); */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|selidx
operator|=
literal|0
init|;
name|selidx
operator|<
name|line_cnt
index|[
name|panes
index|]
condition|;
name|selidx
operator|++
control|)
block|{
comment|/* add the selection stuff to the menus */
comment|/* datap[selidx+sofar].pane = panes; 	     datap[selidx+sofar].line = selidx; */
if|if
condition|(
name|XMenuAddSelection
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|,
name|lpane
argument_list|,
literal|0
argument_list|,
name|line_list
index|[
name|panes
index|]
index|[
name|selidx
index|]
argument_list|,
name|TRUE
argument_list|)
operator|==
name|XM_FAILURE
condition|)
block|{
name|XMenuDestroy
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|)
expr_stmt|;
comment|/* free(datap); */
operator|*
name|error
operator|=
literal|"Can't add selection to menu"
expr_stmt|;
comment|/* error ("Can't add selection to menu"); */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* all set and ready to fly */
name|XMenuRecompute
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|X11
name|XXscreen
operator|=
name|DefaultScreen
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|dispwidth
operator|=
name|DisplayWidth
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
name|dispheight
operator|=
name|DisplayHeight
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
else|#
directive|else
name|dispwidth
operator|=
name|DisplayWidth
argument_list|()
expr_stmt|;
name|dispheight
operator|=
name|DisplayHeight
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|startx
operator|=
name|min
argument_list|(
name|startx
argument_list|,
name|dispwidth
argument_list|)
expr_stmt|;
name|starty
operator|=
name|min
argument_list|(
name|starty
argument_list|,
name|dispheight
argument_list|)
expr_stmt|;
name|startx
operator|=
name|max
argument_list|(
name|startx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|starty
operator|=
name|max
argument_list|(
name|starty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XMenuLocate
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|startx
argument_list|,
name|starty
argument_list|,
operator|&
name|ulx
argument_list|,
operator|&
name|uly
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulx
operator|+
name|width
operator|>
name|dispwidth
condition|)
block|{
name|startx
operator|-=
operator|(
name|ulx
operator|+
name|width
operator|)
operator|-
name|dispwidth
expr_stmt|;
name|ulx
operator|=
name|dispwidth
operator|-
name|width
expr_stmt|;
block|}
if|if
condition|(
name|uly
operator|+
name|height
operator|>
name|dispheight
condition|)
block|{
name|starty
operator|-=
operator|(
name|uly
operator|+
name|height
operator|)
operator|-
name|dispheight
expr_stmt|;
name|uly
operator|=
name|dispheight
operator|-
name|height
expr_stmt|;
block|}
if|if
condition|(
name|ulx
operator|<
literal|0
condition|)
name|startx
operator|-=
name|ulx
expr_stmt|;
if|if
condition|(
name|uly
operator|<
literal|0
condition|)
name|starty
operator|-=
name|uly
expr_stmt|;
name|XMenuSetFreeze
argument_list|(
name|GXMenu
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|panes
operator|=
name|selidx
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|XMenuActivate
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|,
operator|&
name|panes
argument_list|,
operator|&
name|selidx
argument_list|,
name|startx
argument_list|,
name|starty
argument_list|,
name|ButtonReleaseMask
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|XM_SUCCESS
case|:
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pane= %d line = %d\n"
argument_list|,
name|panes
argument_list|,
name|selidx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|entry
operator|=
name|item_list
index|[
name|panes
index|]
index|[
name|selidx
index|]
expr_stmt|;
break|break;
case|case
name|XM_FAILURE
case|:
comment|/*free (datap_save); */
name|XMenuDestroy
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
literal|"Can't activate menu"
expr_stmt|;
comment|/* error("Can't activate menu"); */
case|case
name|XM_IA_SELECT
case|:
case|case
name|XM_NO_SELECT
case|:
name|entry
operator|=
name|Qnil
expr_stmt|;
break|break;
block|}
name|XMenuDestroy
argument_list|(
name|X11ONLY
argument_list|(
argument|XXdisplay
argument_list|)
name|GXMenu
argument_list|)
expr_stmt|;
comment|/*free(datap_save);*/
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_macro
name|syms_of_xmenu
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Sx_popup_menu
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|list_of_panes
argument_list|(
argument|vector
argument_list|,
argument|panes
argument_list|,
argument|names
argument_list|,
argument|items
argument_list|,
argument|menu
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
modifier|*
modifier|*
modifier|*
name|vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN all menu objects */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
name|panes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN pane names */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
modifier|*
name|names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN all line names */
end_comment

begin_decl_stmt
name|int
modifier|*
modifier|*
name|items
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN number of items per pane */
end_comment

begin_decl_stmt
name|Lisp_Object
name|menu
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|item
decl_stmt|,
name|item1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|menu
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
name|menu
operator|=
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|menu
argument_list|)
expr_stmt|;
name|i
operator|=
name|XFASTINT
argument_list|(
name|Flength
argument_list|(
name|menu
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vector
operator|=
operator|(
name|Lisp_Object
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|panes
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|items
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|names
operator|=
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|menu
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|item
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|item
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
operator|(
name|void
operator|)
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|item
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"list_of_panes check tail, i=%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|item1
operator|=
name|Fcar
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|item1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"list_of_panes check pane, i=%d%s\n"
argument_list|,
name|i
argument_list|,
name|XSTRING
argument_list|(
name|item1
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|panes
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|item1
argument_list|)
operator|->
name|data
expr_stmt|;
operator|(
operator|*
name|items
operator|)
index|[
name|i
index|]
operator|=
name|list_of_items
argument_list|(
operator|(
operator|*
name|vector
operator|)
operator|+
name|i
argument_list|,
operator|(
operator|*
name|names
operator|)
operator|+
name|i
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* (*panes)[i] = (char *) xmalloc((XSTRING(item1)->size)+1); 	  bcopy (XSTRING (item1)->data, (*panes)[i], XSTRING(item1)->size + 1) 	  ; */
block|}
return|return
name|i
return|;
block|}
end_block

begin_macro
name|list_of_items
argument_list|(
argument|vector
argument_list|,
argument|names
argument_list|,
argument|pane
argument_list|)
end_macro

begin_comment
comment|/* get list from emacs and put to vector */
end_comment

begin_decl_stmt
name|Lisp_Object
modifier|*
modifier|*
name|vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN menu "objects" */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
name|names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN line names */
end_comment

begin_decl_stmt
name|Lisp_Object
name|pane
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|item
decl_stmt|,
name|item1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|pane
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
name|pane
operator|=
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|pane
argument_list|)
expr_stmt|;
name|i
operator|=
name|XFASTINT
argument_list|(
name|Flength
argument_list|(
name|pane
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vector
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|names
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|pane
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|item
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|item
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
operator|(
name|void
operator|)
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|item
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"list_of_items check tail, i=%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|vector
operator|)
index|[
name|i
index|]
operator|=
name|Fcdr
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item1
operator|=
name|Fcar
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|item1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"list_of_items check item, i=%d%s\n"
argument_list|,
name|i
argument_list|,
name|XSTRING
argument_list|(
name|item1
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|names
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|item1
argument_list|)
operator|->
name|data
expr_stmt|;
comment|/* (*names)[i] = (char *) xmalloc((XSTRING(item1)->size)+1);        bcopy (XSTRING (item1)->data, (*names)[i], XSTRING(item1)->size + 1); */
block|}
return|return
name|i
return|;
block|}
end_block

end_unit

