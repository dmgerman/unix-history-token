begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Indentation functions.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"indent.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_define
define|#
directive|define
name|CR
value|'\015'
end_define

begin_comment
comment|/* Indentation can insert tabs if this is non-zero;    otherwise always uses spaces */
end_comment

begin_decl_stmt
name|int
name|indent_tabs_mode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* These three values memoize the current column to avoid recalculation */
end_comment

begin_comment
comment|/* Some things in set last_known_column_point to -1   to mark the memoized value as invalid */
end_comment

begin_comment
comment|/* Last value returned by current_column */
end_comment

begin_decl_stmt
name|int
name|last_known_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of point when current_column was called */
end_comment

begin_decl_stmt
name|int
name|last_known_column_point
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of MODIFF when current_column was called */
end_comment

begin_decl_stmt
name|int
name|last_known_column_modified
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|minibuf_prompt_width
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"current-column"
argument_list|,
argument|Fcurrent_column
argument_list|,
argument|Scurrent_column
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the horizontal position of point.  Beginning of line is column 0.\n\ This is calculated by adding together the widths of all the displayed\n\ representations of the character between the start of the previous line\n\ and point.  (eg control characters will have a width of 2 or 4, tabs\n\ will have a variable width)\n\ Ignores finite width of screen, which means that this function may return\n\ values greater than (screen-width).\n\ Whether the line is visible (if `selective-display' is t) has no effect."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
name|current_column
argument_list|()
block|;
return|return
name|temp
return|;
block|}
end_expr_stmt

begin_function
name|int
name|current_column
parameter_list|()
block|{
specifier|register
name|int
name|col
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|stop
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|tab_seen
decl_stmt|;
specifier|register
name|int
name|post_tab
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|current_buffer
operator|->
name|tab_width
argument_list|)
decl_stmt|;
name|int
name|ctl_arrow
init|=
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|ctl_arrow
argument_list|)
decl_stmt|;
if|if
condition|(
name|point
operator|==
name|last_known_column_point
operator|&&
name|MODIFF
operator|==
name|last_known_column_modified
condition|)
return|return
name|last_known_column
return|;
comment|/* Make a pointer for decrementing through the chars before point.  */
name|ptr
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|point
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Make a pointer to where consecutive chars leave off,      going backwards from point.  */
if|if
condition|(
name|point
operator|==
name|BEGV
condition|)
name|stop
operator|=
name|ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|point
operator|<=
name|GPT
operator|||
name|BEGV
operator|>
name|GPT
condition|)
name|stop
operator|=
name|BEGV_ADDR
expr_stmt|;
else|else
name|stop
operator|=
name|GAP_END_ADDR
expr_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
operator|||
name|tab_width
operator|>
literal|20
condition|)
name|tab_width
operator|=
literal|8
expr_stmt|;
name|col
operator|=
literal|0
operator|,
name|tab_seen
operator|=
literal|0
operator|,
name|post_tab
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|stop
condition|)
block|{
comment|/* We stopped either for the beginning of the buffer 	     or for the gap.  */
if|if
condition|(
name|ptr
operator|==
name|BEGV_ADDR
condition|)
break|break;
comment|/* It was the gap.  Jump back over it.  */
name|stop
operator|=
name|BEGV_ADDR
expr_stmt|;
name|ptr
operator|=
name|GPT_ADDR
expr_stmt|;
comment|/* Check whether that brings us to beginning of buffer.  */
if|if
condition|(
name|BEGV
operator|>=
name|GPT
condition|)
break|break;
block|}
name|c
operator|=
operator|*
operator|--
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
name|col
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
name|EQ
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|,
name|Qt
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|tab_seen
condition|)
name|col
operator|=
operator|(
operator|(
name|col
operator|+
name|tab_width
operator|)
operator|/
name|tab_width
operator|)
operator|*
name|tab_width
expr_stmt|;
name|post_tab
operator|+=
name|col
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
name|tab_seen
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|col
operator|+=
operator|(
name|ctl_arrow
operator|&&
name|c
operator|<
literal|0200
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|tab_seen
condition|)
block|{
name|col
operator|=
operator|(
operator|(
name|col
operator|+
name|tab_width
operator|)
operator|/
name|tab_width
operator|)
operator|*
name|tab_width
expr_stmt|;
name|col
operator|+=
name|post_tab
expr_stmt|;
block|}
name|last_known_column
operator|=
name|col
expr_stmt|;
name|last_known_column_point
operator|=
name|point
expr_stmt|;
name|last_known_column_modified
operator|=
name|MODIFF
expr_stmt|;
return|return
name|col
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|ToCol
argument_list|(
argument|col
argument_list|)
end_macro

begin_decl_stmt
name|int
name|col
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fromcol
init|=
name|current_column
argument_list|()
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|current_buffer
operator|->
name|tab_width
argument_list|)
decl_stmt|;
if|if
condition|(
name|fromcol
operator|>
name|col
condition|)
return|return;
if|if
condition|(
name|tab_width
operator|<=
literal|0
operator|||
name|tab_width
operator|>
literal|20
condition|)
name|tab_width
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|indent_tabs_mode
condition|)
block|{
name|n
operator|=
name|col
operator|/
name|tab_width
operator|-
name|fromcol
operator|/
name|tab_width
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|insert
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fromcol
operator|=
operator|(
name|col
operator|/
name|tab_width
operator|)
operator|*
name|tab_width
expr_stmt|;
block|}
block|}
while|while
condition|(
name|fromcol
operator|<
name|col
condition|)
block|{
name|insert
argument_list|(
literal|"        "
argument_list|,
name|min
argument_list|(
literal|8
argument_list|,
name|col
operator|-
name|fromcol
argument_list|)
argument_list|)
expr_stmt|;
name|fromcol
operator|+=
name|min
argument_list|(
literal|8
argument_list|,
name|col
operator|-
name|fromcol
argument_list|)
expr_stmt|;
block|}
name|last_known_column
operator|=
name|col
expr_stmt|;
name|last_known_column_point
operator|=
name|point
expr_stmt|;
name|last_known_column_modified
operator|=
name|MODIFF
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"indent-to"
argument_list|,
argument|Findent_to
argument_list|,
argument|Sindent_to
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"NIndent to column: "
argument_list|,
literal|"Indent from point with tabs and spaces until COLUMN is reached.\n\ Always do at least MIN spaces even if that goes past COLUMN;\n\ by default, MIN is zero."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|col
operator|,
name|minimum
operator|)
name|Lisp_Object
name|col
operator|,
name|minimum
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|mincol
decl_stmt|;
specifier|register
name|int
name|fromcol
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|current_buffer
operator|->
name|tab_width
argument_list|)
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|minimum
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|minimum
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|minimum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fromcol
operator|=
name|current_column
argument_list|()
expr_stmt|;
name|mincol
operator|=
name|fromcol
operator|+
name|XINT
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mincol
operator|<
name|XINT
argument_list|(
name|col
argument_list|)
condition|)
name|mincol
operator|=
name|XINT
argument_list|(
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromcol
operator|==
name|mincol
condition|)
return|return
name|make_number
argument_list|(
name|fromcol
argument_list|)
return|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
operator|||
name|tab_width
operator|>
literal|20
condition|)
name|tab_width
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|indent_tabs_mode
condition|)
block|{
name|Lisp_Object
name|n
decl_stmt|;
name|XFASTINT
argument_list|(
name|n
argument_list|)
operator|=
name|mincol
operator|/
name|tab_width
operator|-
name|fromcol
operator|/
name|tab_width
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Finsert_char
argument_list|(
name|make_number
argument_list|(
literal|'\t'
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fromcol
operator|=
operator|(
name|mincol
operator|/
name|tab_width
operator|)
operator|*
name|tab_width
expr_stmt|;
block|}
block|}
name|XFASTINT
argument_list|(
name|col
argument_list|)
operator|=
name|mincol
operator|-
name|fromcol
expr_stmt|;
name|Finsert_char
argument_list|(
name|make_number
argument_list|(
literal|' '
argument_list|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|last_known_column
operator|=
name|mincol
expr_stmt|;
name|last_known_column_point
operator|=
name|point
expr_stmt|;
name|last_known_column_modified
operator|=
name|MODIFF
expr_stmt|;
name|XSETINT
argument_list|(
name|col
argument_list|,
name|mincol
argument_list|)
expr_stmt|;
return|return
name|col
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"current-indentation"
argument_list|,
argument|Fcurrent_indentation
argument_list|,
argument|Scurrent_indentation
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the indentation of the current line.\n\ This is the horizontal position of the character\n\ following any initial whitespace."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|val
block|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
name|position_indentation
argument_list|(
name|find_next_newline
argument_list|(
name|point
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
block|;
return|return
name|val
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|position_indentation
argument_list|(
name|pos
argument_list|)
specifier|register
name|int
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|column
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|current_buffer
operator|->
name|tab_width
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|stop
decl_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
operator|||
name|tab_width
operator|>
literal|20
condition|)
name|tab_width
operator|=
literal|8
expr_stmt|;
name|stop
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|BufferSafeCeiling
argument_list|(
name|pos
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|p
operator|==
name|stop
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|ZV
condition|)
return|return
name|column
return|;
name|pos
operator|+=
name|p
operator|-
operator|&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|stop
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|BufferSafeCeiling
argument_list|(
name|pos
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|' '
case|:
name|column
operator|++
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|column
operator|+=
name|tab_width
operator|-
name|column
operator|%
name|tab_width
expr_stmt|;
break|break;
default|default:
return|return
name|column
return|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"move-to-column"
argument_list|,
argument|Fmove_to_column
argument_list|,
argument|Smove_to_column
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Move point to column COLUMN in the current line.\n\ COLUMN is calculated by adding together the widths of all the displayed\n\ representations of the character between the start of the previous line\n\ and point.  (eg control characters will have a width of 2 or 4, tabs\n\ will have a variable width)\n\ Ignores finite width of screen, which means that this function may be\n\ passed values greater than (screen-width)"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|column
operator|)
name|Lisp_Object
name|column
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|pos
init|=
name|point
decl_stmt|;
specifier|register
name|int
name|col
init|=
name|current_column
argument_list|()
decl_stmt|;
specifier|register
name|int
name|goal
decl_stmt|;
specifier|register
name|int
name|end
init|=
name|ZV
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|current_buffer
operator|->
name|tab_width
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ctl_arrow
init|=
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|ctl_arrow
argument_list|)
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
operator|||
name|tab_width
operator|>
literal|20
condition|)
name|tab_width
operator|=
literal|8
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|column
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|goal
operator|=
name|XINT
argument_list|(
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|>
name|goal
condition|)
block|{
name|pos
operator|=
name|find_next_newline
argument_list|(
name|pos
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|col
operator|<
name|goal
operator|&&
name|pos
operator|<
name|end
condition|)
block|{
name|int
name|c
init|=
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
name|EQ
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|,
name|Qt
argument_list|)
condition|)
break|break;
name|pos
operator|++
expr_stmt|;
name|col
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|col
operator|+=
name|tab_width
operator|-
literal|1
expr_stmt|;
name|col
operator|=
name|col
operator|/
name|tab_width
operator|*
name|tab_width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctl_arrow
operator|&&
operator|(
name|c
operator|<
literal|040
operator|||
name|c
operator|==
literal|0177
operator|)
condition|)
name|col
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|040
operator|||
name|c
operator|>=
literal|0177
condition|)
name|col
operator|+=
literal|3
expr_stmt|;
block|}
name|SET_PT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|last_known_column
operator|=
name|col
expr_stmt|;
name|last_known_column_point
operator|=
name|point
expr_stmt|;
name|last_known_column_modified
operator|=
name|MODIFF
expr_stmt|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
name|col
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|struct
name|position
name|val_compute_motion
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|position
modifier|*
name|compute_motion
parameter_list|(
name|from
parameter_list|,
name|fromvpos
parameter_list|,
name|fromhpos
parameter_list|,
name|to
parameter_list|,
name|tovpos
parameter_list|,
name|tohpos
parameter_list|,
name|width
parameter_list|,
name|hscroll
parameter_list|,
name|tab_offset
parameter_list|)
name|int
name|from
decl_stmt|,
name|fromvpos
decl_stmt|,
name|fromhpos
decl_stmt|,
name|to
decl_stmt|,
name|tovpos
decl_stmt|,
name|tohpos
decl_stmt|;
specifier|register
name|int
name|width
decl_stmt|;
name|int
name|hscroll
decl_stmt|,
name|tab_offset
decl_stmt|;
block|{
comment|/* Note that `cpos' is CURRENT_VPOS<< SHORTBITS + CURRENT_HPOS,    and that CURRENT_HPOS may be negative.  Use these macros    to extract the hpos or the vpos from cpos or anything like it.  */
ifndef|#
directive|ifndef
name|SHORT_CAST_BUG
define|#
directive|define
name|HPOS
parameter_list|(
name|VAR
parameter_list|)
value|(short) (VAR)
else|#
directive|else
define|#
directive|define
name|HPOS
parameter_list|(
name|VAR
parameter_list|)
value|(((VAR)& (1<< (SHORTBITS - 1)) \ 		    ? ~((1<< SHORTBITS) - 1) : 0) \ 		   | (VAR)& ((1<< SHORTBITS) - 1))
comment|/* #define HPOS(VAR) (((VAR)& 0x8000 ? 0xffff0000 : 0) | ((VAR)& 0xffff)) */
endif|#
directive|endif
comment|/* SHORT_CAST_BUG */
define|#
directive|define
name|VPOS
parameter_list|(
name|VAR
parameter_list|)
value|(((VAR)>> SHORTBITS) + (HPOS (VAR)< 0))
ifndef|#
directive|ifndef
name|TAHOE_REGISTER_BUG
specifier|register
endif|#
directive|endif
comment|/* TAHOE_REGISTER_BUG */
name|int
name|cpos
init|=
name|fromhpos
operator|+
operator|(
name|fromvpos
operator|<<
name|SHORTBITS
operator|)
decl_stmt|;
specifier|register
name|int
name|target
init|=
name|tohpos
operator|+
operator|(
name|tovpos
operator|<<
name|SHORTBITS
operator|)
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XFASTINT
argument_list|(
name|current_buffer
operator|->
name|tab_width
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ctl_arrow
init|=
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|ctl_arrow
argument_list|)
decl_stmt|;
name|int
name|selective
init|=
name|XTYPE
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
operator|==
name|Lisp_Int
condition|?
name|XINT
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
else|:
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|prevpos
decl_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
operator|||
name|tab_width
operator|>
literal|20
condition|)
name|tab_width
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|from
init|;
name|pos
operator|<
name|to
operator|&&
name|cpos
operator|<
name|target
condition|;
name|pos
operator|++
control|)
block|{
name|prevpos
operator|=
name|cpos
expr_stmt|;
name|c
operator|=
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|cpos
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|cpos
operator|+=
name|tab_width
operator|-
name|HPOS
argument_list|(
name|cpos
operator|+
name|tab_offset
operator|+
name|hscroll
operator|-
operator|(
name|hscroll
operator|>
literal|0
operator|)
comment|/* Add tab_width here to make sure positive. 		       cpos can be negative after continuation 		       but can't be less than -tab_width.  */
operator|+
name|tab_width
argument_list|)
operator|%
name|tab_width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|selective
operator|>
literal|0
operator|&&
name|position_indentation
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|>=
name|selective
condition|)
block|{
comment|/* Skip any number of invisible lines all at once */
do|do
block|{
while|while
condition|(
operator|++
name|pos
operator|<
name|to
operator|&&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
do|while
condition|(
name|selective
operator|>
literal|0
operator|&&
name|position_indentation
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|>=
name|selective
condition|)
do|;
name|pos
operator|--
expr_stmt|;
comment|/* Allow for the " ..." that is displayed for them. */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|selective_display_ellipses
argument_list|)
condition|)
block|{
name|cpos
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|>=
name|width
condition|)
name|cpos
operator|-=
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|-
name|width
expr_stmt|;
block|}
block|}
else|else
name|cpos
operator|+=
operator|(
literal|1
operator|<<
name|SHORTBITS
operator|)
operator|-
name|HPOS
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
name|cpos
operator|-=
name|hscroll
expr_stmt|;
if|if
condition|(
name|hscroll
operator|>
literal|0
condition|)
name|cpos
operator|++
expr_stmt|;
comment|/* Count the ! on column 0 */
name|tab_offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|CR
operator|&&
name|selective
operator|<
literal|0
condition|)
block|{
comment|/* In selective display mode, 	     everything from a ^M to the end of the line is invisible */
while|while
condition|(
name|pos
operator|<
name|to
operator|&&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
name|pos
operator|++
expr_stmt|;
name|pos
operator|--
expr_stmt|;
comment|/* Allow for the " ..." that is displayed for them. */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|selective_display_ellipses
argument_list|)
condition|)
block|{
name|cpos
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|>=
name|width
condition|)
name|cpos
operator|-=
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|-
name|width
expr_stmt|;
block|}
block|}
else|else
name|cpos
operator|+=
operator|(
name|ctl_arrow
operator|&&
name|c
operator|<
literal|0200
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|>=
name|width
operator|&&
operator|(
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|>
name|width
operator|||
operator|(
name|pos
operator|<
name|ZV
operator|-
literal|1
operator|&&
name|FETCH_CHAR
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cpos
operator|>=
name|target
condition|)
break|break;
if|if
condition|(
name|hscroll
operator|||
operator|(
name|truncate_partial_width_windows
operator|&&
name|width
operator|+
literal|1
operator|<
name|screen_width
operator|)
operator|||
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|truncate_lines
argument_list|)
condition|)
block|{
while|while
condition|(
name|pos
operator|<
name|to
operator|&&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
name|pos
operator|++
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
else|else
block|{
name|cpos
operator|+=
operator|(
literal|1
operator|<<
name|SHORTBITS
operator|)
operator|-
name|width
expr_stmt|;
name|tab_offset
operator|+=
name|width
expr_stmt|;
block|}
block|}
block|}
name|val_compute_motion
operator|.
name|bufpos
operator|=
name|pos
expr_stmt|;
name|val_compute_motion
operator|.
name|hpos
operator|=
name|HPOS
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
name|val_compute_motion
operator|.
name|vpos
operator|=
name|VPOS
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
name|val_compute_motion
operator|.
name|prevhpos
operator|=
name|HPOS
argument_list|(
name|prevpos
argument_list|)
expr_stmt|;
comment|/* Nonzero if have just continued a line */
name|val_compute_motion
operator|.
name|contin
operator|=
name|pos
operator|!=
name|from
operator|&&
operator|(
name|val_compute_motion
operator|.
name|vpos
operator|!=
name|VPOS
argument_list|(
name|prevpos
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
expr_stmt|;
return|return
operator|&
name|val_compute_motion
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|HPOS
end_undef

begin_undef
undef|#
directive|undef
name|VPOS
end_undef

begin_escape
end_escape

begin_macro
name|pos_tab_offset
argument_list|(
argument|w
argument_list|,
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|opoint
init|=
name|point
decl_stmt|;
name|int
name|col
decl_stmt|;
if|if
condition|(
name|pos
operator|==
name|BEGV
operator|||
name|FETCH_CHAR
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
name|SET_PT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|col
operator|=
name|current_column
argument_list|()
expr_stmt|;
name|SET_PT
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
return|return
name|col
operator|-
operator|(
name|col
operator|%
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* start_hpos is the hpos of the first character of the buffer:    zero except for the minibuffer window,    where it is the width of the prompt.  */
end_comment

begin_decl_stmt
name|struct
name|position
name|val_vmotion
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|position
modifier|*
name|vmotion
parameter_list|(
name|from
parameter_list|,
name|vtarget
parameter_list|,
name|width
parameter_list|,
name|hscroll
parameter_list|,
name|window
parameter_list|)
specifier|register
name|int
name|from
decl_stmt|,
name|vtarget
decl_stmt|,
name|width
decl_stmt|;
name|int
name|hscroll
decl_stmt|;
name|Lisp_Object
name|window
decl_stmt|;
block|{
name|struct
name|position
name|pos
decl_stmt|;
comment|/* vpos is cumulative vertical position, changed as from is changed */
specifier|register
name|int
name|vpos
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|prevline
decl_stmt|;
specifier|register
name|int
name|first
decl_stmt|;
name|int
name|lmargin
init|=
name|hscroll
operator|>
literal|0
condition|?
literal|1
operator|-
name|hscroll
else|:
literal|0
decl_stmt|;
name|int
name|selective
init|=
name|XTYPE
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
operator|==
name|Lisp_Int
condition|?
name|XINT
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
else|:
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|start_hpos
init|=
operator|(
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
condition|?
name|minibuf_prompt_width
else|:
literal|0
operator|)
decl_stmt|;
name|retry
label|:
if|if
condition|(
name|vtarget
operator|>
name|vpos
condition|)
block|{
comment|/* Moving downward is simple, but must calculate from beg of line  	 to determine hpos of starting point */
if|if
condition|(
name|from
operator|>
name|BEGV
operator|&&
name|FETCH_CHAR
argument_list|(
name|from
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
name|prevline
operator|=
name|find_next_newline
argument_list|(
name|from
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|selective
operator|>
literal|0
operator|&&
name|prevline
operator|>
name|BEGV
operator|&&
name|position_indentation
argument_list|(
name|prevline
argument_list|)
operator|>=
name|selective
condition|)
name|prevline
operator|=
name|find_next_newline
argument_list|(
name|prevline
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|prevline
argument_list|,
literal|0
argument_list|,
name|lmargin
operator|+
operator|(
name|prevline
operator|==
literal|1
condition|?
name|start_hpos
else|:
literal|0
operator|)
argument_list|,
name|from
argument_list|,
literal|10000
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|hpos
operator|=
name|lmargin
operator|+
operator|(
name|from
operator|==
literal|1
condition|?
name|start_hpos
else|:
literal|0
operator|)
expr_stmt|;
name|pos
operator|.
name|vpos
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|compute_motion
argument_list|(
name|from
argument_list|,
name|vpos
argument_list|,
name|pos
operator|.
name|hpos
argument_list|,
name|ZV
argument_list|,
name|vtarget
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos
operator|.
name|vpos
operator|*
name|width
argument_list|)
return|;
block|}
comment|/* To move upward, go a line at a time until      we have gone at least far enough */
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|vpos
operator|>
name|vtarget
operator|||
name|first
operator|)
operator|&&
name|from
operator|>
name|BEGV
condition|)
block|{
name|prevline
operator|=
name|from
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|prevline
operator|=
name|find_next_newline
argument_list|(
name|prevline
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevline
operator|==
name|BEGV
operator|||
name|selective
operator|<=
literal|0
operator|||
name|position_indentation
argument_list|(
name|prevline
argument_list|)
operator|<
name|selective
condition|)
break|break;
block|}
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|prevline
argument_list|,
literal|0
argument_list|,
name|lmargin
operator|+
operator|(
name|prevline
operator|==
literal|1
condition|?
name|start_hpos
else|:
literal|0
operator|)
argument_list|,
name|from
argument_list|,
literal|10000
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vpos
operator|-=
name|pos
operator|.
name|vpos
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|from
operator|=
name|prevline
expr_stmt|;
block|}
comment|/* If we made exactly the desired vertical distance,      or if we hit beginning of buffer,      return point found */
if|if
condition|(
name|vpos
operator|>=
name|vtarget
condition|)
block|{
name|val_vmotion
operator|.
name|bufpos
operator|=
name|from
expr_stmt|;
name|val_vmotion
operator|.
name|vpos
operator|=
name|vpos
expr_stmt|;
name|val_vmotion
operator|.
name|hpos
operator|=
name|lmargin
expr_stmt|;
name|val_vmotion
operator|.
name|contin
operator|=
literal|0
expr_stmt|;
name|val_vmotion
operator|.
name|prevhpos
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|val_vmotion
return|;
block|}
comment|/* Otherwise find the correct spot by moving down */
goto|goto
name|retry
goto|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"vertical-motion"
argument_list|,
argument|Fvertical_motion
argument_list|,
argument|Svertical_motion
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Move to start of screen line LINES lines down.\n\ If LINES is negative, this is moving up.\n\ Sets point to position found; this may be start of line\n\  or just the start of a continuation line.\n\ Returns number of lines moved; may be closer to zero than LINES\n\  if beginning or end of buffer was reached."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|lines
operator|)
name|Lisp_Object
name|lines
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|position
name|pos
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|lines
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|*
name|vmotion
argument_list|(
name|point
argument_list|,
name|XINT
argument_list|(
name|lines
argument_list|)
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|width
argument_list|)
operator|)
argument_list|,
comment|/* Not XFASTINT since perhaps could be negative */
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
argument_list|,
name|selected_window
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|pos
operator|.
name|bufpos
argument_list|)
expr_stmt|;
return|return
name|make_number
argument_list|(
name|pos
operator|.
name|vpos
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_indent
argument_list|()
end_macro

begin_block
block|{
name|DEFVAR_BOOL
argument_list|(
literal|"indent-tabs-mode"
argument_list|,
operator|&
name|indent_tabs_mode
argument_list|,
literal|"*Indentation can insert tabs if this is non-nil.\n\ Setting this variable automatically makes it local to the current buffer."
argument_list|)
expr_stmt|;
name|indent_tabs_mode
operator|=
literal|1
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_indentation
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sindent_to
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_column
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smove_to_column
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Svertical_motion
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

