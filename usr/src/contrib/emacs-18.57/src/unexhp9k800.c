begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Unexec for HP 9000 Series 800 machines.    Bob Desinger<hpsemc!bd@hplabs.hp.com>     Note that the GNU project considers support for HP operation a    peripheral activity which should not be allowed to divert effort    from development of the GNU system.  Changes in this code will be    installed when users send them in, but aside from that we don't    plan to think about it, or about whether other Emacs maintenance    might break it.     Unexec creates a copy of the old a.out file, and replaces the old data   area with the current data area.  When the new file is executed, the   process will see the same data structures and data values that the   original process had when unexec was called.      Unlike other versions of unexec, this one copies symbol table and   debug information to the new a.out file.  Thus, the new a.out file   may be debugged with symbolic debuggers.      If you fix any bugs in this, I'd like to incorporate your fixes.   Send them to uunet!hpda!hpsemc!jmorris or jmorris%hpsemc@hplabs.HP.COM.      CAVEATS:   This routine saves the current value of all static and external   variables.  This means that any data structure that needs to be   initialized must be explicitly reset.  Variables will not have their   expected default values.      Unfortunately, the HP-UX signal handler has internal initialization   flags which are not explicitly reset.  Thus, for signals to work in   conjunction with this routine, the following code must executed when   the new process starts up.      void _sigreturn();   ...   sigsetreturn(_sigreturn); */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_define
define|#
directive|define
name|NBPG
value|2048
end_define

begin_define
define|#
directive|define
name|roundup
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|( ( (x)+(n-1) )& ~(n-1) )
end_define

begin_comment
comment|/* n is power of 2 */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|( ((x)<(y))?(x):(y) )
end_define

begin_comment
comment|/* Create a new a.out file, same as old but with current data space */
end_comment

begin_macro
name|unexec
argument_list|(
argument|new_name
argument_list|,
argument|old_name
argument_list|,
argument|new_end_of_text
argument_list|,
argument|dummy1
argument_list|,
argument|dummy2
argument_list|)
end_macro

begin_decl_stmt
name|char
name|new_name
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the new a.out file to be created */
end_comment

begin_decl_stmt
name|char
name|old_name
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the old a.out file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|new_end_of_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to new edata/etext; NOT USED YET */
end_comment

begin_decl_stmt
name|int
name|dummy1
decl_stmt|,
name|dummy2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not used by emacs */
end_comment

begin_block
block|{
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
name|int
name|old_size
decl_stmt|,
name|new_size
decl_stmt|;
name|struct
name|header
name|hdr
decl_stmt|;
name|struct
name|som_exec_auxhdr
name|auxhdr
decl_stmt|;
comment|/* For the greatest flexibility, should create a temporary file in      the same directory as the new file.  When everything is complete,      rename the temp file to the new name.      This way, a program could update its own a.out file even while      it is still executing.  If problems occur, everything is still      intact.  NOT implemented.  */
comment|/* Open the input and output a.out files */
name|old
operator|=
name|open
argument_list|(
name|old_name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|open
argument_list|(
name|new_name
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
operator||
name|O_TRUNC
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Read the old headers */
name|read_header
argument_list|(
name|old
argument_list|,
operator|&
name|hdr
argument_list|,
operator|&
name|auxhdr
argument_list|)
expr_stmt|;
comment|/* Decide how large the new and old data areas are */
name|old_size
operator|=
name|auxhdr
operator|.
name|exec_dsize
expr_stmt|;
name|new_size
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|-
name|auxhdr
operator|.
name|exec_dmem
expr_stmt|;
comment|/* Copy the old file to the new, up to the data space */
name|lseek
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|auxhdr
operator|.
name|exec_dfile
argument_list|)
expr_stmt|;
comment|/* Skip the old data segment and write a new one */
name|lseek
argument_list|(
name|old
argument_list|,
name|old_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_data_space
argument_list|(
name|new
argument_list|,
operator|&
name|hdr
argument_list|,
operator|&
name|auxhdr
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
comment|/* Copy the rest of the file */
name|copy_rest
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* Update file pointers since we probably changed size of data area */
name|update_file_ptrs
argument_list|(
name|new
argument_list|,
operator|&
name|hdr
argument_list|,
operator|&
name|auxhdr
argument_list|,
name|auxhdr
operator|.
name|exec_dfile
argument_list|,
name|new_size
operator|-
name|old_size
argument_list|)
expr_stmt|;
comment|/* Save the modified header */
name|write_header
argument_list|(
name|new
argument_list|,
operator|&
name|hdr
argument_list|,
operator|&
name|auxhdr
argument_list|)
expr_stmt|;
comment|/* Close the binary file */
name|close
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Save current data space in the file, update header.  */
end_comment

begin_macro
name|save_data_space
argument_list|(
argument|file
argument_list|,
argument|hdr
argument_list|,
argument|auxhdr
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
modifier|*
name|hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|som_exec_auxhdr
modifier|*
name|auxhdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Write the entire data space out to the file */
if|if
condition|(
name|write
argument_list|(
name|file
argument_list|,
name|auxhdr
operator|->
name|exec_dmem
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|perror
argument_list|(
literal|"Can't save new data space"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Update the header to reflect the new data size */
name|auxhdr
operator|->
name|exec_dsize
operator|=
name|size
expr_stmt|;
name|auxhdr
operator|->
name|exec_bsize
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Update the values of file pointers when something is inserted.  */
end_comment

begin_macro
name|update_file_ptrs
argument_list|(
argument|file
argument_list|,
argument|hdr
argument_list|,
argument|auxhdr
argument_list|,
argument|location
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|int
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
modifier|*
name|hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|som_exec_auxhdr
modifier|*
name|auxhdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|location
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|subspace_dictionary_record
name|subspace
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Increase the overall size of the module */
name|hdr
operator|->
name|som_length
operator|+=
name|offset
expr_stmt|;
comment|/* Update the various file pointers in the header */
define|#
directive|define
name|update
parameter_list|(
name|ptr
parameter_list|)
value|if (ptr> location) ptr = ptr + offset
name|update
argument_list|(
name|hdr
operator|->
name|aux_header_location
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|hdr
operator|->
name|space_strings_location
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|hdr
operator|->
name|init_array_location
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|hdr
operator|->
name|compiler_location
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|hdr
operator|->
name|symbol_location
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|hdr
operator|->
name|fixup_request_location
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|hdr
operator|->
name|symbol_strings_location
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|hdr
operator|->
name|unloadable_sp_location
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|auxhdr
operator|->
name|exec_tfile
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|auxhdr
operator|->
name|exec_dfile
argument_list|)
expr_stmt|;
comment|/* Do for each subspace dictionary entry */
name|lseek
argument_list|(
name|file
argument_list|,
name|hdr
operator|->
name|subspace_location
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|subspace_total
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
operator|&
name|subspace
argument_list|,
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Can't read subspace record"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If subspace has a file location, update it */
if|if
condition|(
name|subspace
operator|.
name|initialization_length
operator|>
literal|0
operator|&&
name|subspace
operator|.
name|file_loc_init_value
operator|>
name|location
condition|)
block|{
name|subspace
operator|.
name|file_loc_init_value
operator|+=
name|offset
expr_stmt|;
name|lseek
argument_list|(
name|file
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|file
argument_list|,
operator|&
name|subspace
argument_list|,
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Can't update subspace record"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Do for each initialization pointer record */
comment|/* (I don't think it applies to executable files, only relocatables) */
undef|#
directive|undef
name|update
block|}
end_block

begin_comment
comment|/* Read in the header records from an a.out file.  */
end_comment

begin_macro
name|read_header
argument_list|(
argument|file
argument_list|,
argument|hdr
argument_list|,
argument|auxhdr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
modifier|*
name|hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|som_exec_auxhdr
modifier|*
name|auxhdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Read the header in */
name|lseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Couldn't read header from a.out file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|->
name|a_magic
operator|!=
name|EXEC_MAGIC
operator|&&
name|hdr
operator|->
name|a_magic
operator|!=
name|SHARE_MAGIC
operator|&&
name|hdr
operator|->
name|a_magic
operator|!=
name|DEMAND_MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a.out file doesn't have legal magic number\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|file
argument_list|,
name|hdr
operator|->
name|aux_header_location
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
name|auxhdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|auxhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|auxhdr
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Couldn't read auxiliary header from a.out file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Write out the header records into an a.out file.  */
end_comment

begin_macro
name|write_header
argument_list|(
argument|file
argument_list|,
argument|hdr
argument_list|,
argument|auxhdr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
modifier|*
name|hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|som_exec_auxhdr
modifier|*
name|auxhdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Update the checksum */
name|hdr
operator|->
name|checksum
operator|=
name|calculate_checksum
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
comment|/* Write the header back into the a.out file */
name|lseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|file
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Couldn't write header to a.out file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|file
argument_list|,
name|hdr
operator|->
name|aux_header_location
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|file
argument_list|,
name|auxhdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|auxhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|auxhdr
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Couldn't write auxiliary header to a.out file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Calculate the checksum of a SOM header record. */
end_comment

begin_macro
name|calculate_checksum
argument_list|(
argument|hdr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|header
modifier|*
name|hdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|checksum
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
operator|(
name|int
operator|*
operator|)
name|hdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|checksum
operator|^=
name|ptr
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|checksum
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Copy size bytes from the old file to the new one.  */
end_comment

begin_macro
name|copy_file
argument_list|(
argument|old
argument_list|,
argument|new
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new
decl_stmt|,
name|old
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|int
name|buffer
index|[
literal|8196
index|]
decl_stmt|;
comment|/* word aligned will be faster */
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
name|len
control|)
block|{
name|len
operator|=
name|min
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|old
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|perror
argument_list|(
literal|"Read failure on a.out file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|perror
argument_list|(
literal|"Write failure in a.out file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Copy the rest of the file, up to EOF.  */
end_comment

begin_macro
name|copy_rest
argument_list|(
argument|old
argument_list|,
argument|new
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new
decl_stmt|,
name|old
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Copy bytes until end of file or error */
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|old
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
break|break;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Unable to copy the rest of the file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|display_header
argument_list|(
argument|hdr
argument_list|,
argument|auxhdr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|header
modifier|*
name|hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|som_exec_auxhdr
modifier|*
name|auxhdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Display the header information (debug) */
name|printf
argument_list|(
literal|"\n\nFILE HEADER\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"magic number %d \n"
argument_list|,
name|hdr
operator|->
name|a_magic
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"text loc %.8x   size %d \n"
argument_list|,
name|auxhdr
operator|->
name|exec_tmem
argument_list|,
name|auxhdr
operator|->
name|exec_tsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data loc %.8x   size %d \n"
argument_list|,
name|auxhdr
operator|->
name|exec_dmem
argument_list|,
name|auxhdr
operator|->
name|exec_dsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"entry     %x \n"
argument_list|,
name|auxhdr
operator|->
name|exec_entry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bss  segment size %u\n"
argument_list|,
name|auxhdr
operator|->
name|exec_bsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data file loc %d    size %d\n"
argument_list|,
name|auxhdr
operator|->
name|exec_dfile
argument_list|,
name|auxhdr
operator|->
name|exec_dsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"som_length %d\n"
argument_list|,
name|hdr
operator|->
name|som_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unloadable sploc %d    size %d\n"
argument_list|,
name|hdr
operator|->
name|unloadable_sp_location
argument_list|,
name|hdr
operator|->
name|unloadable_sp_size
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

