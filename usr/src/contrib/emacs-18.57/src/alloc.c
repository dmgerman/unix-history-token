begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Storage allocation and gc for GNU Emacs Lisp interpreter.    Copyright (C) 1985, 1986 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_comment
comment|/* Macro to verify that storage intended for Lisp objects is not    out of range to fit in the space for a pointer.    ADDRESS is the start of the block, and SIZE    is the amount of space within which objects can start.  */
end_comment

begin_define
define|#
directive|define
name|VALIDATE_LISP_STORAGE
parameter_list|(
name|address
parameter_list|,
name|size
parameter_list|)
define|\
value|do								\   {								\     Lisp_Object val;						\     XSET (val, Lisp_Cons, (char *) address + size);		\     if ((char *) XCONS (val) != (char *) address + size)	\       {								\ 	free (address);						\ 	memory_full ();						\       }								\   } while (0)
end_define

begin_comment
comment|/* Number of bytes of consing done since the last gc */
end_comment

begin_decl_stmt
name|int
name|consing_since_gc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes of consing since gc before another gc should be done. */
end_comment

begin_decl_stmt
name|int
name|gc_cons_threshold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value of consing_since_gc when undos were last truncated.  */
end_comment

begin_decl_stmt
name|int
name|consing_at_last_truncate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero during gc */
end_comment

begin_decl_stmt
name|int
name|gc_in_progress
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|VIRT_ADDR_VARIES
end_ifndef

begin_decl_stmt
specifier|extern
endif|#
directive|endif
comment|/* VIRT_ADDR_VARIES */
name|int
name|malloc_sbrk_used
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|VIRT_ADDR_VARIES
end_ifndef

begin_decl_stmt
specifier|extern
endif|#
directive|endif
comment|/* VIRT_ADDR_VARIES */
name|int
name|malloc_sbrk_unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two thresholds controlling how much undo information to keep.  */
end_comment

begin_decl_stmt
name|int
name|undo_threshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|undo_high_threshold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-nil means defun should do purecopy on the function definition */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vpurify_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Argument we give to Fsignal when memory is full.    Preallocated since perhaps we can't allocate it when memory is full.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|memory_exhausted_message
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SHM
end_ifndef

begin_decl_stmt
name|int
name|pure
index|[
name|PURESIZE
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
init|=
block|{
literal|0
block|,}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force it into data space! */
end_comment

begin_define
define|#
directive|define
name|PUREBEG
value|(char *) pure
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|pure
value|PURE_SEG_BITS
end_define

begin_comment
comment|/* Use shared memory segment */
end_comment

begin_define
define|#
directive|define
name|PUREBEG
value|(char *)PURE_SEG_BITS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_SHM */
end_comment

begin_comment
comment|/* Index in pure at which next pure object will be allocated. */
end_comment

begin_decl_stmt
name|int
name|pureptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, this is a warning delivered by malloc and not yet displayed.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pending_malloc_warning
decl_stmt|;
end_decl_stmt

begin_function
name|Lisp_Object
name|malloc_warning_1
parameter_list|(
name|str
parameter_list|)
name|Lisp_Object
name|str
decl_stmt|;
block|{
name|Fprinc
argument_list|(
name|str
argument_list|,
name|Vstandard_output
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\nKilling some buffers may delay running out of memory.\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"However, certainly by the time you receive the 95% warning,\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"you should clean up, kill this Emacs, and start a new one."
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_comment
comment|/* malloc calls this if it finds we are near exhausting storage */
end_comment

begin_macro
name|malloc_warning
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pending_malloc_warning
operator|=
name|str
expr_stmt|;
block|}
end_block

begin_macro
name|display_malloc_warning
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|val
operator|=
name|build_string
argument_list|(
name|pending_malloc_warning
argument_list|)
expr_stmt|;
name|pending_malloc_warning
operator|=
literal|0
expr_stmt|;
name|internal_with_output_to_temp_buffer
argument_list|(
literal|" *Danger*"
argument_list|,
name|malloc_warning_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Called if malloc returns zero */
end_comment

begin_macro
name|memory_full
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qerror
argument_list|,
name|memory_exhausted_message
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* like malloc and realloc but check for no memory left */
end_comment

begin_function
name|long
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|long
modifier|*
name|val
decl_stmt|;
comment|/* Avoid failure if malloc (0) returns 0.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|val
operator|=
operator|(
name|long
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|memory_full
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|long
modifier|*
name|xrealloc
parameter_list|(
name|block
parameter_list|,
name|size
parameter_list|)
name|long
modifier|*
name|block
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|long
modifier|*
name|val
decl_stmt|;
comment|/* Avoid failure if malloc (0) returns 0.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|val
operator|=
operator|(
name|long
operator|*
operator|)
name|realloc
argument_list|(
name|block
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|memory_full
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocation of cons cells */
end_comment

begin_comment
comment|/* We store cons cells inside of cons_blocks, allocating a new  cons_block with malloc whenever necessary.  Cons cells reclaimed by  GC are put on a free list to be reallocated before allocating  any new cons cells from the latest cons_block.   Each cons_block is just under 1016 bytes long,  since malloc really allocates in units of powers of two  and uses 8 bytes for its own overhead. */
end_comment

begin_define
define|#
directive|define
name|CONS_BLOCK_SIZE
define|\
value|((1016 - sizeof (struct cons_block *)) / sizeof (struct Lisp_Cons))
end_define

begin_struct
struct|struct
name|cons_block
block|{
name|struct
name|cons_block
modifier|*
name|next
decl_stmt|;
name|struct
name|Lisp_Cons
name|conses
index|[
name|CONS_BLOCK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|cons_block
modifier|*
name|cons_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cons_block_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Lisp_Cons
modifier|*
name|cons_free_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_cons
parameter_list|()
block|{
name|cons_block
operator|=
operator|(
expr|struct
name|cons_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cons_block
argument_list|)
argument_list|)
expr_stmt|;
name|cons_block
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|cons_block
operator|->
name|conses
argument_list|,
sizeof|sizeof
name|cons_block
operator|->
name|conses
argument_list|)
expr_stmt|;
name|cons_block_index
operator|=
literal|0
expr_stmt|;
name|cons_free_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Explicitly free a cons cell.  */
end_comment

begin_macro
name|free_cons
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Lisp_Cons
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XFASTINT
argument_list|(
name|ptr
operator|->
name|car
argument_list|)
operator|=
operator|(
name|int
operator|)
name|cons_free_list
expr_stmt|;
name|cons_free_list
operator|=
name|ptr
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"cons"
argument_list|,
argument|Fcons
argument_list|,
argument|Scons
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Create a new cons, give it CAR and CDR as components, and return it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|car
operator|,
name|cdr
operator|)
name|Lisp_Object
name|car
operator|,
name|cdr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|cons_free_list
condition|)
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Cons
argument_list|,
name|cons_free_list
argument_list|)
expr_stmt|;
name|cons_free_list
operator|=
operator|(
expr|struct
name|Lisp_Cons
operator|*
operator|)
name|XFASTINT
argument_list|(
name|cons_free_list
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cons_block_index
operator|==
name|CONS_BLOCK_SIZE
condition|)
block|{
specifier|register
name|struct
name|cons_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|cons_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cons_block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|VALIDATE_LISP_STORAGE
argument_list|(
name|new
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|cons_block
expr_stmt|;
name|cons_block
operator|=
name|new
expr_stmt|;
name|cons_block_index
operator|=
literal|0
expr_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Cons
argument_list|,
operator|&
name|cons_block
operator|->
name|conses
index|[
name|CONS_BLOCK_SIZE
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Cons
argument_list|,
operator|&
name|cons_block
operator|->
name|conses
index|[
name|cons_block_index
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|XCONS
argument_list|(
name|val
argument_list|)
operator|->
name|car
operator|=
name|car
expr_stmt|;
name|XCONS
argument_list|(
name|val
argument_list|)
operator|->
name|cdr
operator|=
name|cdr
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Cons
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"list"
argument_list|,
argument|Flist
argument_list|,
argument|Slist
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created list whose elements are the arguments (any number)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|len
decl_stmt|,
name|val
decl_stmt|,
name|val_tail
decl_stmt|;
name|XFASTINT
argument_list|(
name|len
argument_list|)
operator|=
name|nargs
expr_stmt|;
name|val
operator|=
name|Fmake_list
argument_list|(
name|len
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|val_tail
operator|=
name|val
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|val_tail
argument_list|)
condition|)
block|{
name|XCONS
argument_list|(
name|val_tail
argument_list|)
operator|->
name|car
operator|=
operator|*
name|args
operator|++
expr_stmt|;
name|val_tail
operator|=
name|XCONS
argument_list|(
name|val_tail
argument_list|)
operator|->
name|cdr
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"make-list"
argument_list|,
name|Fmake_list
argument_list|,
name|Smake_list
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created list of length LENGTH, with each element being INIT."
argument_list|)
argument_list|(
name|length
argument_list|,
name|init
argument_list|)
specifier|register
name|Lisp_Object
name|length
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|length
argument_list|)
operator|!=
name|Lisp_Int
operator|||
name|XINT
argument_list|(
name|length
argument_list|)
operator|<
literal|0
condition|)
name|length
operator|=
name|wrong_type_argument
argument_list|(
name|Qnatnump
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|size
operator|=
name|XINT
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|val
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
name|val
operator|=
name|Fcons
argument_list|(
name|init
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Allocation of vectors */
end_comment

begin_decl_stmt
name|struct
name|Lisp_Vector
modifier|*
name|all_vectors
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"make-vector"
argument_list|,
name|Fmake_vector
argument_list|,
name|Smake_vector
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created vector of length LENGTH, with each element being INIT."
argument_list|)
argument_list|(
name|length
argument_list|,
name|init
argument_list|)
specifier|register
name|Lisp_Object
name|length
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|sizei
decl_stmt|,
name|index
decl_stmt|;
specifier|register
name|Lisp_Object
name|vector
decl_stmt|;
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|length
argument_list|)
operator|!=
name|Lisp_Int
operator|||
name|XINT
argument_list|(
name|length
argument_list|)
operator|<
literal|0
condition|)
name|length
operator|=
name|wrong_type_argument
argument_list|(
name|Qnatnump
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sizei
operator|=
name|XINT
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|Lisp_Vector
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
argument_list|)
operator|+
operator|(
name|sizei
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|VALIDATE_LISP_STORAGE
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|vector
argument_list|,
name|Lisp_Vector
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
argument_list|)
operator|+
operator|(
name|sizei
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|sizei
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|all_vectors
expr_stmt|;
name|all_vectors
operator|=
name|p
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|sizei
condition|;
name|index
operator|++
control|)
name|p
operator|->
name|contents
index|[
name|index
index|]
operator|=
name|init
expr_stmt|;
return|return
name|vector
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"vector"
argument_list|,
name|Fvector
argument_list|,
name|Svector
argument_list|,
literal|0
argument_list|,
name|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created vector with our arguments (any number) as its elements."
argument_list|)
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|)
specifier|register
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|len
decl_stmt|,
name|val
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|p
decl_stmt|;
name|XFASTINT
argument_list|(
name|len
argument_list|)
operator|=
name|nargs
expr_stmt|;
name|val
operator|=
name|Fmake_vector
argument_list|(
name|len
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|p
operator|=
name|XVECTOR
argument_list|(
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nargs
condition|;
name|index
operator|++
control|)
name|p
operator|->
name|contents
index|[
name|index
index|]
operator|=
name|args
index|[
name|index
index|]
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Allocation of symbols.  Just like allocation of conses!   Each symbol_block is just under 1016 bytes long,  since malloc really allocates in units of powers of two  and uses 8 bytes for its own overhead. */
end_comment

begin_define
define|#
directive|define
name|SYMBOL_BLOCK_SIZE
define|\
value|((1016 - sizeof (struct symbol_block *)) / sizeof (struct Lisp_Symbol))
end_define

begin_struct
struct|struct
name|symbol_block
block|{
name|struct
name|symbol_block
modifier|*
name|next
decl_stmt|;
name|struct
name|Lisp_Symbol
name|symbols
index|[
name|SYMBOL_BLOCK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|symbol_block
modifier|*
name|symbol_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symbol_block_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Lisp_Symbol
modifier|*
name|symbol_free_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_symbol
parameter_list|()
block|{
name|symbol_block
operator|=
operator|(
expr|struct
name|symbol_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_block
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_block
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|symbol_block
operator|->
name|symbols
argument_list|,
sizeof|sizeof
name|symbol_block
operator|->
name|symbols
argument_list|)
expr_stmt|;
name|symbol_block_index
operator|=
literal|0
expr_stmt|;
name|symbol_free_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"make-symbol"
argument_list|,
argument|Fmake_symbol
argument_list|,
argument|Smake_symbol
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a newly allocated uninterned symbol whose name is NAME.\n\ Its value and function definition are void, and its property list is NIL."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|struct
name|Lisp_Symbol
modifier|*
name|p
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_free_list
condition|)
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Symbol
argument_list|,
name|symbol_free_list
argument_list|)
expr_stmt|;
name|symbol_free_list
operator|=
operator|(
expr|struct
name|Lisp_Symbol
operator|*
operator|)
name|XFASTINT
argument_list|(
name|symbol_free_list
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|symbol_block_index
operator|==
name|SYMBOL_BLOCK_SIZE
condition|)
block|{
name|struct
name|symbol_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|symbol_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|VALIDATE_LISP_STORAGE
argument_list|(
name|new
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|symbol_block
expr_stmt|;
name|symbol_block
operator|=
name|new
expr_stmt|;
name|symbol_block_index
operator|=
literal|0
expr_stmt|;
block|}
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Symbol
argument_list|,
operator|&
name|symbol_block
operator|->
name|symbols
index|[
name|symbol_block_index
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|XSYMBOL
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|p
operator|->
name|plist
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|Qunbound
expr_stmt|;
name|p
operator|->
name|function
operator|=
name|Qunbound
expr_stmt|;
name|p
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Symbol
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Allocation of markers.  Works like allocation of conses. */
end_comment

begin_define
define|#
directive|define
name|MARKER_BLOCK_SIZE
define|\
value|((1016 - sizeof (struct marker_block *)) / sizeof (struct Lisp_Marker))
end_define

begin_struct
struct|struct
name|marker_block
block|{
name|struct
name|marker_block
modifier|*
name|next
decl_stmt|;
name|struct
name|Lisp_Marker
name|markers
index|[
name|MARKER_BLOCK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|marker_block
modifier|*
name|marker_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|marker_block_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Lisp_Marker
modifier|*
name|marker_free_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_marker
parameter_list|()
block|{
name|marker_block
operator|=
operator|(
expr|struct
name|marker_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|marker_block
argument_list|)
argument_list|)
expr_stmt|;
name|marker_block
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|marker_block
operator|->
name|markers
argument_list|,
sizeof|sizeof
name|marker_block
operator|->
name|markers
argument_list|)
expr_stmt|;
name|marker_block_index
operator|=
literal|0
expr_stmt|;
name|marker_free_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"make-marker"
argument_list|,
argument|Fmake_marker
argument_list|,
argument|Smake_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a newly allocated marker which does not point at any place."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|val
block|;
specifier|register
expr|struct
name|Lisp_Marker
operator|*
name|p
block|;
if|if
condition|(
name|marker_free_list
condition|)
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Marker
argument_list|,
name|marker_free_list
argument_list|)
expr_stmt|;
name|marker_free_list
operator|=
operator|(
expr|struct
name|Lisp_Marker
operator|*
operator|)
name|XFASTINT
argument_list|(
name|marker_free_list
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
if|if
condition|(
name|marker_block_index
operator|==
name|MARKER_BLOCK_SIZE
condition|)
block|{
name|struct
name|marker_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|marker_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|marker_block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|VALIDATE_LISP_STORAGE
argument_list|(
name|new
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|marker_block
expr_stmt|;
name|marker_block
operator|=
name|new
expr_stmt|;
name|marker_block_index
operator|=
literal|0
expr_stmt|;
block|}
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Marker
argument_list|,
operator|&
name|marker_block
operator|->
name|markers
index|[
name|marker_block_index
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|p
operator|=
name|XMARKER
argument_list|(
name|val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|->
name|bufpos
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|->
name|chain
operator|=
name|Qnil
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Marker
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|val
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* Allocation of strings */
end_comment

begin_comment
comment|/* Strings reside inside of string_blocks.  The entire data of the string,  both the size and the contents, live in part of the `chars' component of a string_block.  The `pos' component is the index within `chars' of the first free byte.   first_string_block points to the first string_block ever allocated.  Each block points to the next one with its `next' field.  The `prev' fields chain in reverse order.  The last one allocated is the one currently being filled.  current_string_block points to it.   The string_blocks that hold individual large strings  go in a separate chain, started by large_string_blocks.  */
end_comment

begin_comment
comment|/* String blocks contain this many useful bytes.    8184 is power of 2, minus 8 for malloc overhead. */
end_comment

begin_define
define|#
directive|define
name|STRING_BLOCK_SIZE
value|(8184 - sizeof (struct string_block_head))
end_define

begin_comment
comment|/* A string bigger than this gets its own specially-made string block  if it doesn't fit in the current one. */
end_comment

begin_define
define|#
directive|define
name|STRING_BLOCK_OUTSIZE
value|1024
end_define

begin_macro
unit|struct
name|string_block_head
end_macro

begin_block
block|{
name|struct
name|string_block
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|pos
decl_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|string_block
block|{
name|struct
name|string_block
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|char
name|chars
index|[
name|STRING_BLOCK_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This points to the string block we are now allocating strings.  */
end_comment

begin_decl_stmt
name|struct
name|string_block
modifier|*
name|current_string_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to the oldest string block, the one that starts the chain.  */
end_comment

begin_decl_stmt
name|struct
name|string_block
modifier|*
name|first_string_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last string block in chain of those made for individual large strings.  */
end_comment

begin_decl_stmt
name|struct
name|string_block
modifier|*
name|large_string_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If SIZE is the length of a string, this returns how many bytes    the string occupies in a string_block (including padding).  */
end_comment

begin_define
define|#
directive|define
name|STRING_FULLSIZE
parameter_list|(
name|SIZE
parameter_list|)
define|\
value|(((SIZE) + 2 * sizeof (int))& ~(sizeof (int) - 1))
end_define

begin_function
name|void
name|init_strings
parameter_list|()
block|{
name|current_string_block
operator|=
operator|(
expr|struct
name|string_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_block
argument_list|)
argument_list|)
expr_stmt|;
name|first_string_block
operator|=
name|current_string_block
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|string_block
argument_list|)
expr_stmt|;
name|current_string_block
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|current_string_block
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|current_string_block
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|large_string_blocks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|Lisp_Object
name|make_uninit_string
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"make-string"
argument_list|,
argument|Fmake_string
argument_list|,
argument|Smake_string
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a newly created string of length LENGTH, with each element being INIT.\n\ Both LENGTH and INIT must be numbers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|length
operator|,
name|init
operator|)
name|Lisp_Object
name|length
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|length
argument_list|)
operator|!=
name|Lisp_Int
operator|||
name|XINT
argument_list|(
name|length
argument_list|)
operator|<
literal|0
condition|)
name|length
operator|=
name|wrong_type_argument
argument_list|(
name|Qnatnump
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|make_uninit_string
argument_list|(
name|XINT
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|XINT
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|make_string
parameter_list|(
name|contents
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|val
operator|=
name|make_uninit_string
argument_list|(
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|contents
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|build_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|make_string
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Lisp_Object
name|make_uninit_string
parameter_list|(
name|length
parameter_list|)
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|int
name|fullsize
init|=
name|STRING_FULLSIZE
argument_list|(
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fullsize
operator|<=
name|STRING_BLOCK_SIZE
operator|-
name|current_string_block
operator|->
name|pos
condition|)
comment|/* This string can fit in the current string block */
block|{
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_String
argument_list|,
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
name|current_string_block
operator|->
name|chars
operator|+
name|current_string_block
operator|->
name|pos
operator|)
argument_list|)
expr_stmt|;
name|current_string_block
operator|->
name|pos
operator|+=
name|fullsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullsize
operator|>
name|STRING_BLOCK_OUTSIZE
condition|)
comment|/* This string gets its own string block */
block|{
specifier|register
name|struct
name|string_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|string_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_block_head
argument_list|)
operator|+
name|fullsize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|VALIDATE_LISP_STORAGE
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|string_block_head
argument_list|)
operator|+
name|fullsize
expr_stmt|;
name|new
operator|->
name|pos
operator|=
name|fullsize
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|large_string_blocks
expr_stmt|;
name|large_string_blocks
operator|=
name|new
expr_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_String
argument_list|,
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
operator|(
expr|struct
name|string_block_head
operator|*
operator|)
name|new
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Make a new current string block and start it off with this string */
block|{
specifier|register
name|struct
name|string_block
modifier|*
name|new
init|=
operator|(
expr|struct
name|string_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_block
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|VALIDATE_LISP_STORAGE
argument_list|(
name|new
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|consing_since_gc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|string_block
argument_list|)
expr_stmt|;
name|current_string_block
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|current_string_block
expr_stmt|;
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|current_string_block
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|pos
operator|=
name|fullsize
expr_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_String
argument_list|,
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
name|current_string_block
operator|->
name|chars
argument_list|)
expr_stmt|;
block|}
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|size
operator|=
name|length
expr_stmt|;
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Must get an error if pure storage is full,  since if it cannot hold a large string  it may be able to hold conses that point to that string;  then the string is not protected from gc. */
end_comment

begin_function
name|Lisp_Object
name|make_pure_string
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|new
decl_stmt|;
specifier|register
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|length
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|pureptr
operator|+
name|size
operator|>
name|PURESIZE
condition|)
name|error
argument_list|(
literal|"Pure Lisp storage exhausted"
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|new
argument_list|,
name|Lisp_String
argument_list|,
name|PUREBEG
operator|+
name|pureptr
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|new
argument_list|)
operator|->
name|size
operator|=
name|length
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|XSTRING
argument_list|(
name|new
argument_list|)
operator|->
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|new
argument_list|)
operator|->
name|data
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|pureptr
operator|+=
operator|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|pure_cons
parameter_list|(
name|car
parameter_list|,
name|cdr
parameter_list|)
name|Lisp_Object
name|car
decl_stmt|,
name|cdr
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|new
decl_stmt|;
if|if
condition|(
name|pureptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Cons
argument_list|)
operator|>
name|PURESIZE
condition|)
name|error
argument_list|(
literal|"Pure Lisp storage exhausted"
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|new
argument_list|,
name|Lisp_Cons
argument_list|,
name|PUREBEG
operator|+
name|pureptr
argument_list|)
expr_stmt|;
name|pureptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Cons
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|new
argument_list|)
operator|->
name|car
operator|=
name|Fpurecopy
argument_list|(
name|car
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|new
argument_list|)
operator|->
name|cdr
operator|=
name|Fpurecopy
argument_list|(
name|cdr
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|make_pure_vector
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|new
decl_stmt|;
specifier|register
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
argument_list|)
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
decl_stmt|;
if|if
condition|(
name|pureptr
operator|+
name|size
operator|>
name|PURESIZE
condition|)
name|error
argument_list|(
literal|"Pure Lisp storage exhausted"
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|new
argument_list|,
name|Lisp_Vector
argument_list|,
name|PUREBEG
operator|+
name|pureptr
argument_list|)
expr_stmt|;
name|pureptr
operator|+=
name|size
expr_stmt|;
name|XVECTOR
argument_list|(
name|new
argument_list|)
operator|->
name|size
operator|=
name|len
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"purecopy"
argument_list|,
name|Fpurecopy
argument_list|,
name|Spurecopy
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Make a copy of OBJECT in pure storage.\n\ Recursively copies contents of vectors and cons cells.\n\ Does not copy symbols."
argument_list|)
argument_list|(
name|obj
argument_list|)
specifier|register
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|new
decl_stmt|,
name|tem
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
return|return
name|obj
return|;
if|if
condition|(
operator|(
name|PNTR_COMPARISON_TYPE
operator|)
name|XPNTR
argument_list|(
name|obj
argument_list|)
operator|<
call|(
name|PNTR_COMPARISON_TYPE
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pure
operator|+
name|PURESIZE
argument_list|)
operator|&&
operator|(
name|PNTR_COMPARISON_TYPE
operator|)
name|XPNTR
argument_list|(
name|obj
argument_list|)
operator|>=
operator|(
name|PNTR_COMPARISON_TYPE
operator|)
name|pure
condition|)
return|return
name|obj
return|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|obj
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_Marker
case|:
name|error
argument_list|(
literal|"Attempt to copy a marker to pure storage"
argument_list|)
expr_stmt|;
case|case
name|Lisp_Cons
case|:
return|return
name|pure_cons
argument_list|(
name|XCONS
argument_list|(
name|obj
argument_list|)
operator|->
name|car
argument_list|,
name|XCONS
argument_list|(
name|obj
argument_list|)
operator|->
name|cdr
argument_list|)
return|;
case|case
name|Lisp_String
case|:
return|return
name|make_pure_string
argument_list|(
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|size
argument_list|)
return|;
case|case
name|Lisp_Vector
case|:
name|new
operator|=
name|make_pure_vector
argument_list|(
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|XVECTOR
argument_list|(
name|obj
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|XVECTOR
argument_list|(
name|new
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|Fpurecopy
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
default|default:
return|return
name|obj
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Recording what needs to be marked for gc.  */
end_comment

begin_decl_stmt
name|struct
name|gcpro
modifier|*
name|gcprolist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSTATICS
value|200
end_define

begin_decl_stmt
name|int
name|staticidx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_decl_stmt
name|Lisp_Object
modifier|*
name|staticvec
index|[
name|NSTATICS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|staticvec1
index|[
name|NSTATICS
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
operator|*
argument_list|)
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|staticvec
value|((Lisp_Object **) staticvec1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Put an entry in staticvec, pointing at the variable whose address is given */
end_comment

begin_function
name|void
name|staticpro
parameter_list|(
name|varaddress
parameter_list|)
name|Lisp_Object
modifier|*
name|varaddress
decl_stmt|;
block|{
name|staticvec
index|[
name|staticidx
operator|++
index|]
operator|=
name|varaddress
expr_stmt|;
if|if
condition|(
name|staticidx
operator|>=
name|NSTATICS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|catchtag
block|{
name|Lisp_Object
name|tag
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|struct
name|catchtag
modifier|*
name|next
decl_stmt|;
comment|/*    jmp_buf jmp;  /* We don't need this for GC purposes */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|catchtag
modifier|*
name|catchlist
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|backtrace
block|{
name|struct
name|backtrace
modifier|*
name|next
decl_stmt|;
name|Lisp_Object
modifier|*
name|function
decl_stmt|;
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
comment|/* Points to vector of args. */
name|int
name|nargs
decl_stmt|;
comment|/* length of vector */
comment|/* if nargs is UNEVALLED, args points to slot holding list of unevalled args */
name|char
name|evalargs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|backtrace
modifier|*
name|backtrace_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two flags that are set during GC in the `size' component    of a string or vector.  On some machines, these flags    are defined by the m- file to be different bits.  */
end_comment

begin_comment
comment|/* On vector, means it has been marked.    On string size field or a reference to a string,    means not the last reference in the chain.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARRAY_MARK_FLAG
end_ifndef

begin_define
define|#
directive|define
name|ARRAY_MARK_FLAG
value|((MARKBIT>> 1)& ~MARKBIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no ARRAY_MARK_FLAG */
end_comment

begin_comment
comment|/* Any slot that is a Lisp_Object can point to a string    and thus can be put on a string's reference-chain    and thus may need to have its ARRAY_MARK_FLAG set.    This includes the slots whose markbits are used to mark    the containing objects.  */
end_comment

begin_if
if|#
directive|if
name|ARRAY_MARK_FLAG
operator|==
name|MARKBIT
end_if

begin_decl_stmt
name|you
name|lose
endif|#
directive|endif
name|int
name|total_conses
decl_stmt|,
name|total_markers
decl_stmt|,
name|total_symbols
decl_stmt|,
name|total_string_size
decl_stmt|,
name|total_vector_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|total_free_conses
decl_stmt|,
name|total_free_markers
decl_stmt|,
name|total_free_symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_object
argument_list|()
decl_stmt|,
name|mark_buffer
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_marks
argument_list|()
decl_stmt|,
name|gc_sweep
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|compact_strings
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"garbage-collect"
argument_list|,
argument|Fgarbage_collect
argument_list|,
argument|Sgarbage_collect
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Reclaim storage for Lisp objects no longer needed.\n\ Returns info on amount of space in use:\n\  ((USED-CONSES . FREE-CONSES) (USED-SYMS . FREE-SYMS)\n\   (USED-MARKERS . FREE-MARKERS) USED-STRING-CHARS USED-VECTOR-SLOTS)\n\ Garbage collection happens automatically if you cons more than\n\ gc-cons-threshold  bytes of Lisp data since previous garbage collection."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
expr|struct
name|gcpro
operator|*
name|tail
block|;
specifier|register
expr|struct
name|specbinding
operator|*
name|bind
block|;   struct
name|catchtag
operator|*
name|catch
block|;   struct
name|handler
operator|*
name|handler
block|;
specifier|register
expr|struct
name|backtrace
operator|*
name|backlist
block|;
specifier|register
name|Lisp_Object
name|tem
block|;
name|char
operator|*
name|omessage
operator|=
name|echo_area_contents
block|;
specifier|register
name|int
name|i
block|;
if|if
condition|(
operator|!
name|noninteractive
condition|)
name|message1
argument_list|(
literal|"Garbage collecting..."
argument_list|)
expr_stmt|;
comment|/* Don't keep command history around forever */
name|tem
operator|=
name|Fnthcdr
argument_list|(
name|make_number
argument_list|(
literal|30
argument_list|)
argument_list|,
name|Vcommand_history
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|CONSP
argument_list|(
name|tem
argument_list|)
condition|)
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
operator|=
name|Qnil
expr_stmt|;
end_if

begin_comment
comment|/* Likewise for undo information.  */
end_comment

begin_expr_stmt
name|truncate_all_undos
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|gc_in_progress
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  clear_marks ();  */
end_comment

begin_comment
comment|/* In each "large string", set the MARKBIT of the size field.      That enables mark_object to recognize them.  */
end_comment

begin_block
block|{
specifier|register
name|struct
name|string_block
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|large_string_blocks
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
operator|(
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
operator|&
name|b
operator|->
name|chars
index|[
literal|0
index|]
operator|)
operator|)
operator|->
name|size
operator||=
name|MARKBIT
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Mark all the special slots that serve as the roots of accessibility.       Usually the special slots to mark are contained in particular structures.      Then we know no slot is marked twice because the structures don't overlap.      In some cases, the structures point to the slots to be marked.      For these, we use MARKBIT to avoid double marking of the slot.  */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|staticidx
condition|;
name|i
operator|++
control|)
name|mark_object
argument_list|(
name|staticvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_for
for|for
control|(
name|tail
operator|=
name|gcprolist
init|;
name|tail
condition|;
name|tail
operator|=
name|tail
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tail
operator|->
name|nvars
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|tail
operator|->
name|var
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|mark_object
argument_list|(
operator|&
name|tail
operator|->
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XMARK
argument_list|(
name|tail
operator|->
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|bind
operator|=
name|specpdl
init|;
name|bind
operator|!=
name|specpdl_ptr
condition|;
name|bind
operator|++
control|)
block|{
name|mark_object
argument_list|(
operator|&
name|bind
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|mark_object
argument_list|(
operator|&
name|bind
operator|->
name|old_value
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|catch
operator|=
name|catchlist
init|;
name|catch
condition|;
name|catch
operator|=
name|catch
operator|->
name|next
control|)
block|{
name|mark_object
argument_list|(
operator|&
name|catch
operator|->
name|tag
argument_list|)
expr_stmt|;
name|mark_object
argument_list|(
operator|&
name|catch
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|handler
operator|=
name|handlerlist
init|;
name|handler
condition|;
name|handler
operator|=
name|handler
operator|->
name|next
control|)
block|{
name|mark_object
argument_list|(
operator|&
name|handler
operator|->
name|handler
argument_list|)
expr_stmt|;
name|mark_object
argument_list|(
operator|&
name|handler
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|backlist
operator|=
name|backtrace_list
init|;
name|backlist
condition|;
name|backlist
operator|=
name|backlist
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
operator|*
name|backlist
operator|->
name|function
argument_list|)
condition|)
block|{
name|mark_object
argument_list|(
name|backlist
operator|->
name|function
argument_list|)
expr_stmt|;
name|XMARK
argument_list|(
operator|*
name|backlist
operator|->
name|function
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backlist
operator|->
name|nargs
operator|==
name|UNEVALLED
operator|||
name|backlist
operator|->
name|nargs
operator|==
name|MANY
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|=
name|backlist
operator|->
name|nargs
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|backlist
operator|->
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|mark_object
argument_list|(
operator|&
name|backlist
operator|->
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XMARK
argument_list|(
name|backlist
operator|->
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_expr_stmt
name|gc_sweep
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Clear the mark bits that we set in certain root slots.  */
end_comment

begin_for
for|for
control|(
name|tail
operator|=
name|gcprolist
init|;
name|tail
condition|;
name|tail
operator|=
name|tail
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tail
operator|->
name|nvars
condition|;
name|i
operator|++
control|)
name|XUNMARK
argument_list|(
name|tail
operator|->
name|var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_for
for|for
control|(
name|backlist
operator|=
name|backtrace_list
init|;
name|backlist
condition|;
name|backlist
operator|=
name|backlist
operator|->
name|next
control|)
block|{
name|XUNMARK
argument_list|(
operator|*
name|backlist
operator|->
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|backlist
operator|->
name|nargs
operator|==
name|UNEVALLED
operator|||
name|backlist
operator|->
name|nargs
operator|==
name|MANY
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|=
name|backlist
operator|->
name|nargs
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|XUNMARK
argument_list|(
name|backlist
operator|->
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|XUNMARK
argument_list|(
name|buffer_defaults
operator|.
name|name
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XUNMARK
argument_list|(
name|buffer_local_symbols
operator|.
name|name
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  clear_marks (); */
end_comment

begin_expr_stmt
name|gc_in_progress
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|consing_since_gc
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|consing_at_last_truncate
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|gc_cons_threshold
operator|<
literal|10000
condition|)
name|gc_cons_threshold
operator|=
literal|10000
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|omessage
condition|)
name|message1
argument_list|(
name|omessage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noninteractive
condition|)
name|message1
argument_list|(
literal|"Garbage collecting...done"
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_conses
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|total_free_conses
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_symbols
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|total_free_symbols
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_markers
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|total_free_markers
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_string_size
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|total_vector_size
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void clear_marks () {
comment|/* Clear marks on all conses */
end_comment

begin_comment
unit|{     register struct cons_block *cblk;     register int lim = cons_block_index;        for (cblk = cons_block; cblk; cblk = cblk->next)       { 	register int i; 	for (i = 0; i< lim; i++) 	  XUNMARK (cblk->conses[i].car); 	lim = CONS_BLOCK_SIZE;       }   }
comment|/* Clear marks on all symbols */
end_comment

begin_comment
unit|{     register struct symbol_block *sblk;     register int lim = symbol_block_index;        for (sblk = symbol_block; sblk; sblk = sblk->next)       { 	register int i; 	for (i = 0; i< lim; i++) 	  { 	    XUNMARK (sblk->symbols[i].plist); 	  } 	lim = SYMBOL_BLOCK_SIZE;       }   }
comment|/* Clear marks on all markers */
end_comment

begin_comment
unit|{     register struct marker_block *sblk;     register int lim = marker_block_index;        for (sblk = marker_block; sblk; sblk = sblk->next)       { 	register int i; 	for (i = 0; i< lim; i++) 	  XUNMARK (sblk->markers[i].chain); 	lim = MARKER_BLOCK_SIZE;       }   }
comment|/* Clear mark bits on all buffers */
end_comment

begin_endif
unit|{     register struct buffer *nextb = all_buffers;      while (nextb)       { 	XUNMARK (nextb->name); 	nextb = nextb->next;       }   } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Mark reference to a Lisp_Object.  If the object referred to    has not been seen yet, recursively mark all the references contained in it.     If the object referenced is a short string, the referrencing slot    is threaded into a chain of such slots, pointed to from    the `size' field of the string.  The actual string size    lives in the last slot in the chain.  We recognize the end    because it is< (unsigned) STRING_BLOCK_SIZE.  */
end_comment

begin_function
unit|static
name|void
name|mark_object
parameter_list|(
name|objptr
parameter_list|)
name|Lisp_Object
modifier|*
name|objptr
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|obj
decl_stmt|;
name|obj
operator|=
operator|*
name|objptr
expr_stmt|;
name|XUNMARK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|loop
label|:
if|if
condition|(
operator|(
name|PNTR_COMPARISON_TYPE
operator|)
name|XPNTR
argument_list|(
name|obj
argument_list|)
operator|<
call|(
name|PNTR_COMPARISON_TYPE
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pure
operator|+
name|PURESIZE
argument_list|)
operator|&&
operator|(
name|PNTR_COMPARISON_TYPE
operator|)
name|XPNTR
argument_list|(
name|obj
argument_list|)
operator|>=
operator|(
name|PNTR_COMPARISON_TYPE
operator|)
name|pure
condition|)
return|return;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XGCTYPE
argument_list|(
name|obj
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XGCTYPE
argument_list|(
name|obj
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_String
case|:
block|{
specifier|register
name|struct
name|Lisp_String
modifier|*
name|ptr
init|=
name|XSTRING
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|size
operator|&
name|MARKBIT
condition|)
comment|/* A large string.  Just set ARRAY_MARK_FLAG.  */
name|ptr
operator|->
name|size
operator||=
name|ARRAY_MARK_FLAG
expr_stmt|;
else|else
block|{
comment|/* A small string.  Put this reference 	       into the chain of references to it. 	       The address OBJPTR is even, so if the address 	       includes MARKBIT, put it in the low bit 	       when we store OBJPTR into the size field.  */
if|if
condition|(
name|XMARKBIT
argument_list|(
operator|*
name|objptr
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
operator|*
name|objptr
argument_list|)
operator|=
name|ptr
operator|->
name|size
expr_stmt|;
name|XMARK
argument_list|(
operator|*
name|objptr
argument_list|)
expr_stmt|;
block|}
else|else
name|XFASTINT
argument_list|(
operator|*
name|objptr
argument_list|)
operator|=
name|ptr
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|objptr
operator|&
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|size
operator|=
operator|(
name|int
operator|)
name|objptr
operator|&
operator|~
name|MARKBIT
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|objptr
operator|&
name|MARKBIT
condition|)
name|ptr
operator|->
name|size
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Lisp_Vector
case|:
case|case
name|Lisp_Window
case|:
case|case
name|Lisp_Process
case|:
case|case
name|Lisp_Window_Configuration
case|:
block|{
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|ptr
init|=
name|XVECTOR
argument_list|(
name|obj
argument_list|)
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|ptr
operator|->
name|size
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|&
name|ARRAY_MARK_FLAG
condition|)
break|break;
comment|/* Already marked */
name|ptr
operator|->
name|size
operator||=
name|ARRAY_MARK_FLAG
expr_stmt|;
comment|/* Else mark it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
comment|/* and then mark its elements */
name|mark_object
argument_list|(
operator|&
name|ptr
operator|->
name|contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case Lisp_Temp_Vector:       { 	register struct Lisp_Vector *ptr = XVECTOR (obj); 	register int size = ptr->size; 	register int i;  	for (i = 0; i< size; i++)
comment|/* and then mark its elements */
block|mark_object (&ptr->contents[i]);       }       break;
endif|#
directive|endif
endif|0
case|case
name|Lisp_Symbol
case|:
block|{
specifier|register
name|struct
name|Lisp_Symbol
modifier|*
name|ptr
init|=
name|XSYMBOL
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|struct
name|Lisp_Symbol
modifier|*
name|ptrx
decl_stmt|;
if|if
condition|(
name|XMARKBIT
argument_list|(
name|ptr
operator|->
name|plist
argument_list|)
condition|)
break|break;
name|XMARK
argument_list|(
name|ptr
operator|->
name|plist
argument_list|)
expr_stmt|;
name|XSETTYPE
argument_list|(
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|&
name|ptr
operator|->
name|name
argument_list|,
name|Lisp_String
argument_list|)
expr_stmt|;
name|mark_object
argument_list|(
operator|&
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|mark_object
argument_list|(
operator|(
name|Lisp_Object
operator|*
operator|)
operator|&
name|ptr
operator|->
name|value
argument_list|)
expr_stmt|;
name|mark_object
argument_list|(
operator|&
name|ptr
operator|->
name|function
argument_list|)
expr_stmt|;
name|mark_object
argument_list|(
operator|&
name|ptr
operator|->
name|plist
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|ptrx
operator|=
name|ptr
expr_stmt|;
comment|/* Use pf ptrx avoids compiler bug on Sun */
name|XSETSYMBOL
argument_list|(
name|obj
argument_list|,
name|ptrx
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
break|break;
case|case
name|Lisp_Marker
case|:
name|XMARK
argument_list|(
name|XMARKER
argument_list|(
name|obj
argument_list|)
operator|->
name|chain
argument_list|)
expr_stmt|;
comment|/* DO NOT mark thru the marker's chain. 	 The buffer's markers chain does not preserve markers from gc; 	 instead, markers are removed from the chain when they are freed by gc. */
break|break;
case|case
name|Lisp_Cons
case|:
case|case
name|Lisp_Buffer_Local_Value
case|:
case|case
name|Lisp_Some_Buffer_Local_Value
case|:
block|{
specifier|register
name|struct
name|Lisp_Cons
modifier|*
name|ptr
init|=
name|XCONS
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|XMARKBIT
argument_list|(
name|ptr
operator|->
name|car
argument_list|)
condition|)
break|break;
name|XMARK
argument_list|(
name|ptr
operator|->
name|car
argument_list|)
expr_stmt|;
name|mark_object
argument_list|(
operator|&
name|ptr
operator|->
name|car
argument_list|)
expr_stmt|;
name|objptr
operator|=
operator|&
name|ptr
operator|->
name|cdr
expr_stmt|;
name|obj
operator|=
name|ptr
operator|->
name|cdr
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
case|case
name|Lisp_Buffer
case|:
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|XBUFFER
argument_list|(
name|obj
argument_list|)
operator|->
name|name
argument_list|)
condition|)
name|mark_buffer
argument_list|(
name|obj
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Int
case|:
case|case
name|Lisp_Void
case|:
case|case
name|Lisp_Subr
case|:
case|case
name|Lisp_Intfwd
case|:
case|case
name|Lisp_Boolfwd
case|:
case|case
name|Lisp_Objfwd
case|:
case|case
name|Lisp_Buffer_Objfwd
case|:
case|case
name|Lisp_Internal_Stream
case|:
comment|/* Don't bother with Lisp_Buffer_Objfwd,        since all markable slots in current buffer marked anyway.  */
comment|/* Don't need to do Lisp_Objfwd, since the places they point        are protected with staticpro.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark the pointers in a buffer structure.  */
end_comment

begin_function
specifier|static
name|void
name|mark_buffer
parameter_list|(
name|buf
parameter_list|)
name|Lisp_Object
name|buf
decl_stmt|;
block|{
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|buffer
init|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|ptr
decl_stmt|;
comment|/* This is the buffer's markbit */
name|mark_object
argument_list|(
operator|&
name|buffer
operator|->
name|name
argument_list|)
expr_stmt|;
name|XMARK
argument_list|(
name|buffer
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|&
name|buffer
operator|->
name|name
operator|+
literal|1
init|;
operator|(
name|char
operator|*
operator|)
name|ptr
operator|<
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|buffer
argument_list|)
condition|;
name|ptr
operator|++
control|)
name|mark_object
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all structures not marked, and free them. */
end_comment

begin_function
specifier|static
name|void
name|gc_sweep
parameter_list|()
block|{
name|total_string_size
operator|=
literal|0
expr_stmt|;
name|compact_strings
argument_list|()
expr_stmt|;
comment|/* Put all unmarked conses on free list */
block|{
specifier|register
name|struct
name|cons_block
modifier|*
name|cblk
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|cons_block_index
decl_stmt|;
specifier|register
name|int
name|num_free
init|=
literal|0
decl_stmt|,
name|num_used
init|=
literal|0
decl_stmt|;
name|cons_free_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cblk
operator|=
name|cons_block
init|;
name|cblk
condition|;
name|cblk
operator|=
name|cblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|cblk
operator|->
name|conses
index|[
name|i
index|]
operator|.
name|car
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|cblk
operator|->
name|conses
index|[
name|i
index|]
operator|.
name|car
argument_list|)
operator|=
operator|(
name|int
operator|)
name|cons_free_list
expr_stmt|;
name|num_free
operator|++
expr_stmt|;
name|cons_free_list
operator|=
operator|&
name|cblk
operator|->
name|conses
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|num_used
operator|++
expr_stmt|;
name|XUNMARK
argument_list|(
name|cblk
operator|->
name|conses
index|[
name|i
index|]
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
name|lim
operator|=
name|CONS_BLOCK_SIZE
expr_stmt|;
block|}
name|total_conses
operator|=
name|num_used
expr_stmt|;
name|total_free_conses
operator|=
name|num_free
expr_stmt|;
block|}
comment|/* Put all unmarked symbols on free list */
block|{
specifier|register
name|struct
name|symbol_block
modifier|*
name|sblk
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|symbol_block_index
decl_stmt|;
specifier|register
name|int
name|num_free
init|=
literal|0
decl_stmt|,
name|num_used
init|=
literal|0
decl_stmt|;
name|symbol_free_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sblk
operator|=
name|symbol_block
init|;
name|sblk
condition|;
name|sblk
operator|=
name|sblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|plist
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|value
argument_list|)
operator|=
operator|(
name|int
operator|)
name|symbol_free_list
expr_stmt|;
name|symbol_free_list
operator|=
operator|&
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
expr_stmt|;
name|num_free
operator|++
expr_stmt|;
block|}
else|else
block|{
name|num_used
operator|++
expr_stmt|;
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|name
operator|=
name|XSTRING
argument_list|(
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|&
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|XUNMARK
argument_list|(
name|sblk
operator|->
name|symbols
index|[
name|i
index|]
operator|.
name|plist
argument_list|)
expr_stmt|;
block|}
name|lim
operator|=
name|SYMBOL_BLOCK_SIZE
expr_stmt|;
block|}
name|total_symbols
operator|=
name|num_used
expr_stmt|;
name|total_free_symbols
operator|=
name|num_free
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|standalone
comment|/* Put all unmarked markers on free list.      Dechain each one first from the buffer it points into. */
block|{
specifier|register
name|struct
name|marker_block
modifier|*
name|mblk
decl_stmt|;
name|struct
name|Lisp_Marker
modifier|*
name|tem1
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|marker_block_index
decl_stmt|;
specifier|register
name|int
name|num_free
init|=
literal|0
decl_stmt|,
name|num_used
init|=
literal|0
decl_stmt|;
name|marker_free_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mblk
operator|=
name|marker_block
init|;
name|mblk
condition|;
name|mblk
operator|=
name|mblk
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|mblk
operator|->
name|markers
index|[
name|i
index|]
operator|.
name|chain
argument_list|)
condition|)
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|tem1
operator|=
operator|&
name|mblk
operator|->
name|markers
index|[
name|i
index|]
expr_stmt|;
comment|/* tem1 avoids Sun compiler bug */
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_Marker
argument_list|,
name|tem1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem1
operator|->
name|buffer
condition|)
name|unchain_marker
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|mblk
operator|->
name|markers
index|[
name|i
index|]
operator|.
name|chain
argument_list|)
operator|=
operator|(
name|int
operator|)
name|marker_free_list
expr_stmt|;
name|marker_free_list
operator|=
operator|&
name|mblk
operator|->
name|markers
index|[
name|i
index|]
expr_stmt|;
name|num_free
operator|++
expr_stmt|;
block|}
else|else
block|{
name|num_used
operator|++
expr_stmt|;
name|XUNMARK
argument_list|(
name|mblk
operator|->
name|markers
index|[
name|i
index|]
operator|.
name|chain
argument_list|)
expr_stmt|;
block|}
name|lim
operator|=
name|MARKER_BLOCK_SIZE
expr_stmt|;
block|}
name|total_markers
operator|=
name|num_used
expr_stmt|;
name|total_free_markers
operator|=
name|num_free
expr_stmt|;
block|}
comment|/* Free all unmarked buffers */
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|buffer
init|=
name|all_buffers
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|buffer
condition|)
if|if
condition|(
operator|!
name|XMARKBIT
argument_list|(
name|buffer
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
else|else
name|all_buffers
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
name|next
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|XUNMARK
argument_list|(
name|buffer
operator|->
name|name
argument_list|)
expr_stmt|;
name|prev
operator|=
name|buffer
operator|,
name|buffer
operator|=
name|buffer
operator|->
name|next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|standalone
comment|/* Free all unmarked vectors */
block|{
specifier|register
name|struct
name|Lisp_Vector
modifier|*
name|vector
init|=
name|all_vectors
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|total_vector_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|vector
condition|)
if|if
condition|(
operator|!
operator|(
name|vector
operator|->
name|size
operator|&
name|ARRAY_MARK_FLAG
operator|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|vector
operator|->
name|next
expr_stmt|;
else|else
name|all_vectors
operator|=
name|vector
operator|->
name|next
expr_stmt|;
name|next
operator|=
name|vector
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|vector
argument_list|)
expr_stmt|;
name|vector
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|vector
operator|->
name|size
operator|&=
operator|~
name|ARRAY_MARK_FLAG
expr_stmt|;
name|total_vector_size
operator|+=
name|vector
operator|->
name|size
expr_stmt|;
name|prev
operator|=
name|vector
operator|,
name|vector
operator|=
name|vector
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Free all "large strings" not marked with ARRAY_MARK_FLAG.  */
block|{
specifier|register
name|struct
name|string_block
modifier|*
name|sb
init|=
name|large_string_blocks
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|sb
condition|)
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
operator|&
name|sb
operator|->
name|chars
index|[
literal|0
index|]
operator|)
operator|)
operator|->
name|size
operator|&
name|ARRAY_MARK_FLAG
operator|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|sb
operator|->
name|next
expr_stmt|;
else|else
name|large_string_blocks
operator|=
name|sb
operator|->
name|next
expr_stmt|;
name|next
operator|=
name|sb
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
operator|&
name|sb
operator|->
name|chars
index|[
literal|0
index|]
operator|)
operator|)
operator|->
name|size
operator|&=
operator|~
name|ARRAY_MARK_FLAG
operator|&
operator|~
name|MARKBIT
expr_stmt|;
name|total_string_size
operator|+=
operator|(
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|(
operator|&
name|sb
operator|->
name|chars
index|[
literal|0
index|]
operator|)
operator|)
operator|->
name|size
expr_stmt|;
name|prev
operator|=
name|sb
operator|,
name|sb
operator|=
name|sb
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compactify strings, relocate references to them, and    free any string blocks that become empty.  */
end_comment

begin_function
specifier|static
name|void
name|compact_strings
parameter_list|()
block|{
comment|/* String block of old strings we are scanning.  */
specifier|register
name|struct
name|string_block
modifier|*
name|from_sb
decl_stmt|;
comment|/* A preceding string block (or maybe the same one)      where we are copying the still-live strings to.  */
specifier|register
name|struct
name|string_block
modifier|*
name|to_sb
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|to_pos
decl_stmt|;
name|to_sb
operator|=
name|first_string_block
expr_stmt|;
name|to_pos
operator|=
literal|0
expr_stmt|;
comment|/* Scan each existing string block sequentially, string by string.  */
for|for
control|(
name|from_sb
operator|=
name|first_string_block
init|;
name|from_sb
condition|;
name|from_sb
operator|=
name|from_sb
operator|->
name|next
control|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
comment|/* POS is the index of the next string in the block.  */
while|while
condition|(
name|pos
operator|<
name|from_sb
operator|->
name|pos
condition|)
block|{
specifier|register
name|struct
name|Lisp_String
modifier|*
name|nextstr
init|=
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|&
name|from_sb
operator|->
name|chars
index|[
name|pos
index|]
decl_stmt|;
specifier|register
name|struct
name|Lisp_String
modifier|*
name|newaddr
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|nextstr
operator|->
name|size
decl_stmt|;
comment|/* NEXTSTR is the old address of the next string. 	     Just skip it if it isn't marked.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|size
operator|>
name|STRING_BLOCK_SIZE
condition|)
block|{
comment|/* It is marked, so its size field is really a chain of refs. 		 Find the end of the chain, where the actual size lives.  */
while|while
condition|(
operator|(
name|unsigned
operator|)
name|size
operator|>
name|STRING_BLOCK_SIZE
condition|)
block|{
if|if
condition|(
name|size
operator|&
literal|1
condition|)
name|size
operator|^=
name|MARKBIT
operator||
literal|1
expr_stmt|;
name|size
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|size
operator|&
operator|~
name|MARKBIT
expr_stmt|;
block|}
name|total_string_size
operator|+=
name|size
expr_stmt|;
comment|/* If it won't fit in TO_SB, close it out, 		 and move to the next sb.  Keep doing so until 		 TO_SB reaches a large enough, empty enough string block. 		 We know that TO_SB cannot advance past FROM_SB here 		 since FROM_SB is large enough to contain this string. 		 Any string blocks skipped here 		 will be patched out and freed later.  */
while|while
condition|(
name|to_pos
operator|+
name|STRING_FULLSIZE
argument_list|(
name|size
argument_list|)
operator|>
name|max
argument_list|(
name|to_sb
operator|->
name|pos
argument_list|,
name|STRING_BLOCK_SIZE
argument_list|)
condition|)
block|{
name|to_sb
operator|->
name|pos
operator|=
name|to_pos
expr_stmt|;
name|to_sb
operator|=
name|to_sb
operator|->
name|next
expr_stmt|;
name|to_pos
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Compute new address of this string 		 and update TO_POS for the space being used.  */
name|newaddr
operator|=
operator|(
expr|struct
name|Lisp_String
operator|*
operator|)
operator|&
name|to_sb
operator|->
name|chars
index|[
name|to_pos
index|]
expr_stmt|;
name|to_pos
operator|+=
name|STRING_FULLSIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Copy the string itself to the new place.  */
if|if
condition|(
name|nextstr
operator|!=
name|newaddr
condition|)
name|bcopy
argument_list|(
name|nextstr
argument_list|,
name|newaddr
argument_list|,
name|size
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go through NEXTSTR's chain of references 		 and make each slot in the chain point to 		 the new address of this string.  */
name|size
operator|=
name|newaddr
operator|->
name|size
expr_stmt|;
while|while
condition|(
operator|(
name|unsigned
operator|)
name|size
operator|>
name|STRING_BLOCK_SIZE
condition|)
block|{
specifier|register
name|Lisp_Object
modifier|*
name|objptr
decl_stmt|;
if|if
condition|(
name|size
operator|&
literal|1
condition|)
name|size
operator|^=
name|MARKBIT
operator||
literal|1
expr_stmt|;
name|objptr
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|size
expr_stmt|;
name|size
operator|=
name|XFASTINT
argument_list|(
operator|*
name|objptr
argument_list|)
operator|&
operator|~
name|MARKBIT
expr_stmt|;
if|if
condition|(
name|XMARKBIT
argument_list|(
operator|*
name|objptr
argument_list|)
condition|)
block|{
name|XSET
argument_list|(
operator|*
name|objptr
argument_list|,
name|Lisp_String
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
name|XMARK
argument_list|(
operator|*
name|objptr
argument_list|)
expr_stmt|;
block|}
else|else
name|XSET
argument_list|(
operator|*
name|objptr
argument_list|,
name|Lisp_String
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
block|}
comment|/* Store the actual size in the size field.  */
name|newaddr
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
name|pos
operator|+=
name|STRING_FULLSIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Close out the last string block still used and free any that follow.  */
name|to_sb
operator|->
name|pos
operator|=
name|to_pos
expr_stmt|;
name|current_string_block
operator|=
name|to_sb
expr_stmt|;
name|from_sb
operator|=
name|to_sb
operator|->
name|next
expr_stmt|;
name|to_sb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|from_sb
condition|)
block|{
name|to_sb
operator|=
name|from_sb
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|from_sb
argument_list|)
expr_stmt|;
name|from_sb
operator|=
name|to_sb
expr_stmt|;
block|}
comment|/* Free any empty string blocks further back in the chain.      This loop will never free first_string_block, but it is very      unlikely that that one will become empty, so why bother checking?  */
name|from_sb
operator|=
name|first_string_block
expr_stmt|;
while|while
condition|(
name|to_sb
operator|=
name|from_sb
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|to_sb
operator|->
name|pos
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|from_sb
operator|->
name|next
operator|=
name|to_sb
operator|->
name|next
condition|)
name|from_sb
operator|->
name|next
operator|->
name|prev
operator|=
name|from_sb
expr_stmt|;
name|free
argument_list|(
name|to_sb
argument_list|)
expr_stmt|;
block|}
else|else
name|from_sb
operator|=
name|to_sb
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|truncate_all_undos
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|nextb
init|=
name|all_buffers
decl_stmt|;
name|consing_at_last_truncate
operator|=
name|consing_since_gc
expr_stmt|;
while|while
condition|(
name|nextb
condition|)
block|{
name|nextb
operator|->
name|undo_list
operator|=
name|truncate_undo_list
argument_list|(
name|nextb
operator|->
name|undo_list
argument_list|,
name|undo_threshold
argument_list|,
name|undo_high_threshold
argument_list|)
expr_stmt|;
name|nextb
operator|=
name|nextb
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Initialization */
end_comment

begin_macro
name|init_alloc_once
argument_list|()
end_macro

begin_block
block|{
comment|/* Used to do Vpurify_flag = Qt here, but Qt isn't set up yet!  */
name|pureptr
operator|=
literal|0
expr_stmt|;
name|all_vectors
operator|=
literal|0
expr_stmt|;
name|init_strings
argument_list|()
expr_stmt|;
name|init_cons
argument_list|()
expr_stmt|;
name|init_symbol
argument_list|()
expr_stmt|;
name|init_marker
argument_list|()
expr_stmt|;
name|gcprolist
operator|=
literal|0
expr_stmt|;
name|staticidx
operator|=
literal|0
expr_stmt|;
name|consing_since_gc
operator|=
literal|0
expr_stmt|;
name|gc_cons_threshold
operator|=
literal|100000
expr_stmt|;
ifdef|#
directive|ifdef
name|VIRT_ADDR_VARIES
name|malloc_sbrk_unused
operator|=
literal|1
operator|<<
literal|22
expr_stmt|;
comment|/* A large number */
name|malloc_sbrk_used
operator|=
literal|100000
expr_stmt|;
comment|/* as reasonable as any number */
endif|#
directive|endif
comment|/* VIRT_ADDR_VARIES */
block|}
end_block

begin_macro
name|init_alloc
argument_list|()
end_macro

begin_block
block|{
name|gcprolist
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|void
name|syms_of_alloc
parameter_list|()
block|{
name|memory_exhausted_message
operator|=
name|Fcons
argument_list|(
name|build_string
argument_list|(
literal|"Memory exhausted"
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|memory_exhausted_message
argument_list|)
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"gc-cons-threshold"
argument_list|,
operator|&
name|gc_cons_threshold
argument_list|,
literal|"*Number of bytes of consing between garbage collections."
argument_list|)
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"pure-bytes-used"
argument_list|,
operator|&
name|pureptr
argument_list|,
literal|"Number of bytes of sharable Lisp data allocated so far."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|DEFVAR_INT ("data-bytes-used",&malloc_sbrk_used,     "Number of bytes of unshared memory allocated in this session.");    DEFVAR_INT ("data-bytes-free",&malloc_sbrk_unused,     "Number of bytes of unshared memory remaining available in this session.");
endif|#
directive|endif
name|DEFVAR_LISP
argument_list|(
literal|"purify-flag"
argument_list|,
operator|&
name|Vpurify_flag
argument_list|,
literal|"Non-nil means loading Lisp code in order to dump an executable."
argument_list|)
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"undo-threshold"
argument_list|,
operator|&
name|undo_threshold
argument_list|,
literal|"Keep no more undo information once it exceeds this size.\n\ This threshold is applied when garbage collection happens.\n\ The size is counted as the number of bytes occupied,\n\ which includes both saved text and other data."
argument_list|)
expr_stmt|;
name|undo_threshold
operator|=
literal|15000
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"undo-high-threshold"
argument_list|,
operator|&
name|undo_high_threshold
argument_list|,
literal|"Don't keep more than this much size of undo information.\n\ A command which pushes past this size is itself forgotten.\n\ This threshold is applied when garbage collection happens.\n\ The size is counted as the number of bytes occupied,\n\ which includes both saved text and other data."
argument_list|)
expr_stmt|;
name|undo_high_threshold
operator|=
literal|20000
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scons
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slist
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Svector
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_list
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_vector
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_symbol
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spurecopy
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgarbage_collect
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

