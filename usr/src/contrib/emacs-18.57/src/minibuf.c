begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Minibuffer input and completion.    Copyright (C) 1985, 1986, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* List of buffers for use as minibuffers.   The first element of the list is used for the outermost minibuffer invocation,   the next element is used for a recursive minibuffer invocation, etc.   The list is extended at the end as deeped minibuffer recursions are encountered. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_list
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|minibuf_save_data
block|{
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|prompt_width
decl_stmt|;
name|Lisp_Object
name|help_form
decl_stmt|;
name|Lisp_Object
name|current_prefix_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|minibuf_save_vector_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|minibuf_save_data
modifier|*
name|minibuf_save_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth in minibuffer invocations.  */
end_comment

begin_decl_stmt
name|int
name|minibuf_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means display completion help for invalid input.  */
end_comment

begin_decl_stmt
name|int
name|completion_auto_help
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fread_minibuffer leaves the input, as a string, here.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|last_minibuf_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means let functions called when within a minibuffer     invoke recursive minibuffers (to read arguments, or whatever).  */
end_comment

begin_decl_stmt
name|int
name|enable_recursive_minibuffers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* help-form is bound to this while in the minibuffer.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_help_form
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means completion ignores case.  */
end_comment

begin_decl_stmt
name|int
name|completion_ignore_case
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Quser_variable_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Width in columns of current minibuffer prompt.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|minibuf_prompt_width
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Actual minibuffer invocation. */
end_comment

begin_function_decl
name|void
name|read_minibuf_unwind
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|get_minibuffer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|read_minibuf
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Lisp_Object
name|read_minibuf
parameter_list|(
name|map
parameter_list|,
name|initial
parameter_list|,
name|prompt
parameter_list|,
name|expflag
parameter_list|)
name|Lisp_Object
name|map
decl_stmt|;
name|Lisp_Object
name|initial
decl_stmt|;
name|Lisp_Object
name|prompt
decl_stmt|;
name|int
name|expflag
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|prompt
argument_list|)
operator|!=
name|Lisp_String
condition|)
name|prompt
operator|=
name|build_string
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Emacs in -batch mode calls minibuffer: print the prompt.  */
if|if
condition|(
name|noninteractive
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable_recursive_minibuffers
operator|&&
operator|(
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Command attempted to use minibuffer while in minibuffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|minibuf_level
operator|==
name|minibuf_save_vector_size
condition|)
name|minibuf_save_vector
operator|=
operator|(
expr|struct
name|minibuf_save_data
operator|*
operator|)
name|xrealloc
argument_list|(
name|minibuf_save_vector
argument_list|,
operator|(
name|minibuf_save_vector_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minibuf_save_data
argument_list|)
argument_list|)
expr_stmt|;
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|prompt
operator|=
name|minibuf_prompt
expr_stmt|;
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|prompt_width
operator|=
name|minibuf_prompt_width
expr_stmt|;
name|minibuf_prompt_width
operator|=
literal|0
expr_stmt|;
comment|/*>> Why is this done this way rather than binding these variables? */
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|help_form
operator|=
name|Vhelp_form
expr_stmt|;
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|current_prefix_arg
operator|=
name|Vcurrent_prefix_arg
expr_stmt|;
name|GCPRO2
argument_list|(
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|help_form
argument_list|,
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|current_prefix_arg
argument_list|)
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|Fset_window_configuration
argument_list|,
name|Fcurrent_window_configuration
argument_list|()
argument_list|)
expr_stmt|;
name|val
operator|=
name|current_buffer
operator|->
name|directory
expr_stmt|;
name|Fset_buffer
argument_list|(
name|get_minibuffer
argument_list|(
name|minibuf_level
argument_list|)
argument_list|)
expr_stmt|;
name|current_buffer
operator|->
name|directory
operator|=
name|val
expr_stmt|;
name|Fset_window_buffer
argument_list|(
name|minibuf_window
argument_list|,
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
name|Fselect_window
argument_list|(
name|minibuf_window
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|hscroll
argument_list|)
operator|=
literal|0
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
name|minibuf_level
operator|++
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|read_minibuf_unwind
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Vminibuf_scroll_window
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|initial
argument_list|)
condition|)
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|initial
argument_list|)
expr_stmt|;
name|minibuf_prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|data
argument_list|,
name|minibuf_prompt
argument_list|,
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|echo_area_contents
operator|=
literal|0
expr_stmt|;
name|Vhelp_form
operator|=
name|Vminibuffer_help_form
expr_stmt|;
name|current_buffer
operator|->
name|keymap
operator|=
name|map
expr_stmt|;
name|recursive_edit_1
argument_list|()
expr_stmt|;
comment|/* If cursor is on the minibuffer line,      show the user we have exited by putting it in column 0.  */
if|if
condition|(
name|cursor_vpos
operator|>=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|top
argument_list|)
operator|&&
operator|!
name|noninteractive
condition|)
block|{
name|cursor_hpos
operator|=
literal|0
expr_stmt|;
name|update_screen
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make minibuffer contents into a string */
name|val
operator|=
name|make_string
argument_list|(
name|BEG_ADDR
argument_list|,
name|Z
operator|-
name|BEG
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|GAP_END_ADDR
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
operator|+
name|GPT
operator|-
name|BEG
argument_list|,
name|Z
operator|-
name|GPT
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
comment|/* VAL is the string of minibuffer text.  */
name|last_minibuf_string
operator|=
name|val
expr_stmt|;
comment|/* If Lisp form desired instead of string, parse it */
if|if
condition|(
name|expflag
condition|)
name|val
operator|=
name|Fread
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a buffer to be used as the minibuffer at depth `depth'.  depth = 0 is the lowest allowed argument, and that is the value  used for nonrecursive minibuffer invocations */
end_comment

begin_function
name|Lisp_Object
name|get_minibuffer
parameter_list|(
name|depth
parameter_list|)
name|int
name|depth
decl_stmt|;
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|num
decl_stmt|,
name|buf
decl_stmt|;
name|char
name|name
index|[
literal|14
index|]
decl_stmt|;
specifier|extern
name|Lisp_Object
name|nconc2
parameter_list|()
function_decl|;
name|XFASTINT
argument_list|(
name|num
argument_list|)
operator|=
name|depth
expr_stmt|;
name|tail
operator|=
name|Fnthcdr
argument_list|(
name|num
argument_list|,
name|Vminibuffer_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|tail
operator|=
name|Fcons
argument_list|(
name|Qnil
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Vminibuffer_list
operator|=
name|nconc2
argument_list|(
name|Vminibuffer_list
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buf
argument_list|)
operator|||
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|name
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|" *Minibuf-%d*"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
operator|=
name|buf
expr_stmt|;
block|}
else|else
name|reset_buffer
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* This function is called on exiting minibuffer, whether normally or not,  and it restores the current window, buffer, etc. */
end_comment

begin_function
name|void
name|read_minibuf_unwind
parameter_list|()
block|{
comment|/* Erase the minibuffer we were using at this level.  */
name|Fset_buffer
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
comment|/* If this was a recursive minibuffer,      tie the minibuffer window back to the outer level minibuffer buffer */
name|minibuf_level
operator|--
expr_stmt|;
comment|/* Make sure minibuffer window is erased, not ignored */
name|windows_or_buffers_changed
operator|++
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Restore prompt from outer minibuffer */
name|minibuf_prompt
operator|=
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|prompt
expr_stmt|;
name|minibuf_prompt_width
operator|=
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|prompt_width
expr_stmt|;
name|Vhelp_form
operator|=
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|help_form
expr_stmt|;
name|Vcurrent_prefix_arg
operator|=
name|minibuf_save_vector
index|[
name|minibuf_level
index|]
operator|.
name|current_prefix_arg
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"read-from-minibuffer"
argument_list|,
argument|Fread_from_minibuffer
argument_list|,
argument|Sread_from_minibuffer
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Read a string from the minibuffer, prompting with string PROMPT.\n\ If optional second arg INITIAL-CONTENTS is non-nil, it is a string\n\   to be inserted into the minibuffer before reading input.\n\ Third arg KEYMAP is a keymap to use whilst reading; the default is\n\   minibuffer-local-map.\n\ If fourth arg READ is non-nil, then interpret the result as a lisp object\n\   and return that object  (ie  (car (read-from-string<input-string>)))"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|initial_input
operator|,
name|keymap
operator|,
name|read
operator|)
name|Lisp_Object
name|prompt
operator|,
name|initial_input
operator|,
name|keymap
operator|,
name|read
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|initial_input
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
name|initial_input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|keymap
argument_list|)
condition|)
name|keymap
operator|=
name|Vminibuffer_local_map
expr_stmt|;
else|else
name|keymap
operator|=
name|get_keymap
argument_list|(
name|keymap
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|read_minibuf
argument_list|(
name|keymap
argument_list|,
name|initial_input
argument_list|,
name|prompt
argument_list|,
operator|!
name|NULL
argument_list|(
name|read
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-minibuffer"
argument_list|,
argument|Fread_minibuffer
argument_list|,
argument|Sread_minibuffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a Lisp object read using the minibuffer.\n\ Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS\n\ is a string to insert in the minibuffer before reading."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|initial_contents
operator|)
name|Lisp_Object
name|prompt
operator|,
name|initial_contents
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|initial_contents
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
argument|initial_contents
argument_list|,
literal|1
argument_list|)
return|return
name|read_minibuf
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|initial_contents
argument_list|,
name|prompt
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"eval-minibuffer"
argument_list|,
argument|Feval_minibuffer
argument_list|,
argument|Seval_minibuffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return value of Lisp expression read using the minibuffer.\n\ Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS\n\ is a string to insert in the minibuffer before reading."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|initial_contents
operator|)
name|Lisp_Object
name|prompt
operator|,
name|initial_contents
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Feval
argument_list|(
name|Fread_minibuffer
argument_list|(
name|prompt
argument_list|,
name|initial_contents
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Functions that use the minibuffer to read various things. */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"read-string"
argument_list|,
argument|Fread_string
argument_list|,
argument|Sread_string
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Read a string from the minibuffer, prompting with string PROMPT.\n\ If non-nil second arg INITIAL-INPUT is a string to insert before reading."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|initial_input
operator|)
name|Lisp_Object
name|prompt
operator|,
name|initial_input
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fread_from_minibuffer
argument_list|(
name|prompt
argument_list|,
name|initial_input
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-no-blanks-input"
argument_list|,
argument|Fread_no_blanks_input
argument_list|,
argument|Sread_no_blanks_input
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Args PROMPT and INIT, strings.  Read a string from the terminal, not allowing blanks.\n\ Prompt with PROMPT, and provide INIT as an initial value of the input string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|init
operator|)
name|Lisp_Object
name|prompt
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|read_minibuf
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|init
argument_list|,
name|prompt
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-command"
argument_list|,
argument|Fread_command
argument_list|,
argument|Sread_command
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg PROMPT, a string.  Read the name of a command and return as a symbol.\n\ Prompts with PROMPT."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fintern
argument_list|(
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|Vobarray
argument_list|,
name|Qcommandp
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_macro
name|DEFUN
argument_list|(
literal|"read-function"
argument_list|,
argument|Fread_function
argument_list|,
argument|Sread_function
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg PROMPT, a string.  Read the name of a function and return as a symbol.\n\ Prompts with PROMPT."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fintern
argument_list|(
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|Vobarray
argument_list|,
name|Qfboundp
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTDEF */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"read-variable"
argument_list|,
argument|Fread_variable
argument_list|,
argument|Sread_variable
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg PROMPT, a string.  Read the name of a user variable and return\n\ it as a symbol.  Prompts with PROMPT.\n\ A user variable is one whose documentation starts with a \"*\" character."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fintern
argument_list|(
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|Vobarray
argument_list|,
name|Quser_variable_p
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-buffer"
argument_list|,
argument|Fread_buffer
argument_list|,
argument|Sread_buffer
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"One arg PROMPT, a string.  Read the name of a buffer and return as a string.\n\ Prompts with PROMPT.\n\ Optional second arg is value to return if user enters an empty line.\n\ If optional third arg REQUIRE-MATCH is non-nil, only existing buffer names are allowed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|def
operator|,
name|require_match
operator|)
name|Lisp_Object
name|prompt
operator|,
name|def
operator|,
name|require_match
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|args
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|def
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
name|def
operator|=
name|XBUFFER
argument_list|(
name|def
argument_list|)
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|def
argument_list|)
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|build_string
argument_list|(
literal|"%s(default %s) "
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|prompt
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|def
expr_stmt|;
name|prompt
operator|=
name|Fformat
argument_list|(
literal|3
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|GCPRO1
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|Vbuffer_alist
argument_list|,
name|Qnil
argument_list|,
name|require_match
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
condition|)
return|return
name|tem
return|;
return|return
name|def
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"try-completion"
argument_list|,
argument|Ftry_completion
argument_list|,
argument|Stry_completion
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Return common substring of all completions of STRING in ALIST.\n\ Each car of each element of ALIST is tested to see if it begins with STRING.\n\ All that match are compared together; the longest initial sequence\n\ common to all matches is returned as a string.\n\ If there is no match at all, nil is returned.\n\ For an exact match, t is returned.\n\ \n\ ALIST can be an obarray instead of an alist.\n\ Then the print names of all symbols in the obarray are the possible matches.\n\ \n\ If optional third argument PREDICATE is non-nil,\n\ it is used to test each possible match.\n\ The match is a candidate only if PREDICATE returns non-nil.\n\ The argument given to PREDICATE is the alist element or the symbol from the obarray."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|alist
operator|,
name|pred
operator|)
name|Lisp_Object
name|string
operator|,
name|alist
operator|,
name|pred
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|bestmatch
decl_stmt|,
name|tail
decl_stmt|,
name|elt
decl_stmt|,
name|eltstring
decl_stmt|;
name|int
name|bestmatchsize
decl_stmt|;
name|int
name|compare
decl_stmt|,
name|matchsize
decl_stmt|;
name|int
name|list
init|=
name|CONSP
argument_list|(
name|alist
argument_list|)
operator|||
name|NULL
argument_list|(
name|alist
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|,
name|obsize
decl_stmt|;
name|int
name|matchcount
init|=
literal|0
decl_stmt|;
name|Lisp_Object
name|bucket
decl_stmt|,
name|zero
decl_stmt|,
name|end
decl_stmt|,
name|tem
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
operator|&&
name|XTYPE
argument_list|(
name|alist
argument_list|)
operator|!=
name|Lisp_Vector
condition|)
return|return
name|call3
argument_list|(
name|alist
argument_list|,
name|string
argument_list|,
name|pred
argument_list|,
name|Qnil
argument_list|)
return|;
name|bestmatch
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|tail
operator|=
name|alist
expr_stmt|;
else|else
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|obsize
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|size
expr_stmt|;
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get the next element of the alist or obarray. */
comment|/* Exit the loop if the elements are all used up. */
comment|/* elt gets the alist element or symbol. 	 eltstring gets the name to check as a completion. */
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
break|break;
name|elt
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|eltstring
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|XFASTINT
argument_list|(
name|bucket
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|elt
operator|=
name|bucket
expr_stmt|;
name|eltstring
operator|=
name|Fsymbol_name
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSYMBOL
argument_list|(
name|bucket
argument_list|)
operator|->
name|next
condition|)
name|XSETSYMBOL
argument_list|(
name|bucket
argument_list|,
name|XSYMBOL
argument_list|(
name|bucket
argument_list|)
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|bucket
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|index
operator|>=
name|obsize
condition|)
break|break;
else|else
block|{
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Is this element a possible completion? */
if|if
condition|(
name|XTYPE
argument_list|(
name|eltstring
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|<=
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|size
operator|&&
literal|0
operator|>
name|scmp
argument_list|(
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
condition|)
block|{
comment|/* Yes. */
comment|/* Ignore this element if there is a predicate 	     and the predicate doesn't like it. */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|pred
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|pred
argument_list|,
name|Qcommandp
argument_list|)
condition|)
name|tem
operator|=
name|Fcommandp
argument_list|(
name|elt
argument_list|)
expr_stmt|;
else|else
block|{
name|GCPRO3
argument_list|(
name|string
argument_list|,
name|eltstring
argument_list|,
name|bestmatch
argument_list|)
expr_stmt|;
name|tem
operator|=
name|call1
argument_list|(
name|pred
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
continue|continue;
block|}
comment|/* Update computation of how much all possible completions match */
name|matchcount
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bestmatch
argument_list|)
condition|)
name|bestmatch
operator|=
name|eltstring
operator|,
name|bestmatchsize
operator|=
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|size
expr_stmt|;
else|else
block|{
name|compare
operator|=
name|min
argument_list|(
name|bestmatchsize
argument_list|,
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|matchsize
operator|=
name|scmp
argument_list|(
name|XSTRING
argument_list|(
name|bestmatch
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|data
argument_list|,
name|compare
argument_list|)
expr_stmt|;
name|bestmatchsize
operator|=
operator|(
name|matchsize
operator|>=
literal|0
operator|)
condition|?
name|matchsize
else|:
name|compare
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|NULL
argument_list|(
name|bestmatch
argument_list|)
condition|)
return|return
name|Qnil
return|;
comment|/* No completions found */
if|if
condition|(
name|matchcount
operator|==
literal|1
operator|&&
name|bestmatchsize
operator|==
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
condition|)
return|return
name|Qt
return|;
name|XFASTINT
argument_list|(
name|zero
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Else extract the part in which */
name|XFASTINT
argument_list|(
name|end
argument_list|)
operator|=
name|bestmatchsize
expr_stmt|;
comment|/* all completions agree */
return|return
name|Fsubstring
argument_list|(
name|bestmatch
argument_list|,
name|zero
argument_list|,
name|end
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Compare exactly LEN chars of strings at S1 and S2,    ignoring case if appropriate.    Return -1 if strings match,    else number of chars that match at the beginning.  */
end_comment

begin_expr_stmt
name|scmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
init|=
name|len
decl_stmt|;
if|if
condition|(
name|completion_ignore_case
condition|)
block|{
while|while
condition|(
name|l
operator|&&
name|downcase_table
index|[
operator|*
name|s1
operator|++
index|]
operator|==
name|downcase_table
index|[
operator|*
name|s2
operator|++
index|]
condition|)
name|l
operator|--
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|l
operator|&&
operator|*
name|s1
operator|++
operator|==
operator|*
name|s2
operator|++
condition|)
name|l
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|len
operator|-
name|l
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"all-completions"
argument_list|,
argument|Fall_completions
argument_list|,
argument|Sall_completions
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Search for partial matches to STRING in ALIST.\n\ Each car of each element of ALIST is tested to see if it begins with STRING.\n\ The value is a list of all the strings from ALIST that match.\n\ ALIST can be an obarray instead of an alist.\n\ Then the print names of all symbols in the obarray are the possible matches.\n\ \n\ If optional third argument PREDICATE is non-nil,\n\ it is used to test each possible match.\n\ The match is a candidate only if PREDICATE returns non-nil.\n\ The argument given to PREDICATE is the alist element or the symbol from the obarray."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|alist
operator|,
name|pred
operator|)
name|Lisp_Object
name|string
operator|,
name|alist
operator|,
name|pred
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|elt
decl_stmt|,
name|eltstring
decl_stmt|;
name|Lisp_Object
name|allmatches
decl_stmt|;
name|int
name|list
init|=
name|CONSP
argument_list|(
name|alist
argument_list|)
operator|||
name|NULL
argument_list|(
name|alist
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|,
name|obsize
decl_stmt|;
name|Lisp_Object
name|bucket
decl_stmt|,
name|tem
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|,
name|gcpro4
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
operator|&&
name|XTYPE
argument_list|(
name|alist
argument_list|)
operator|!=
name|Lisp_Vector
condition|)
block|{
return|return
name|call3
argument_list|(
name|alist
argument_list|,
name|string
argument_list|,
name|pred
argument_list|,
name|Qt
argument_list|)
return|;
block|}
name|allmatches
operator|=
name|Qnil
expr_stmt|;
comment|/* If ALIST is not a list, set TAIL just for gc pro.  */
name|tail
operator|=
name|alist
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|obsize
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|size
expr_stmt|;
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get the next element of the alist or obarray. */
comment|/* Exit the loop if the elements are all used up. */
comment|/* elt gets the alist element or symbol. 	 eltstring gets the name to check as a completion. */
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
break|break;
name|elt
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|eltstring
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|XFASTINT
argument_list|(
name|bucket
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|elt
operator|=
name|bucket
expr_stmt|;
name|eltstring
operator|=
name|Fsymbol_name
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSYMBOL
argument_list|(
name|bucket
argument_list|)
operator|->
name|next
condition|)
name|XSETSYMBOL
argument_list|(
name|bucket
argument_list|,
name|XSYMBOL
argument_list|(
name|bucket
argument_list|)
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|bucket
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|index
operator|>=
name|obsize
condition|)
break|break;
else|else
block|{
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Is this element a possible completion? */
if|if
condition|(
name|XTYPE
argument_list|(
name|eltstring
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|<=
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|size
operator|&&
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|!=
literal|' '
operator|&&
literal|0
operator|>
name|scmp
argument_list|(
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
condition|)
block|{
comment|/* Yes. */
comment|/* Ignore this element if there is a predicate 	     and the predicate doesn't like it. */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|pred
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|pred
argument_list|,
name|Qcommandp
argument_list|)
condition|)
name|tem
operator|=
name|Fcommandp
argument_list|(
name|elt
argument_list|)
expr_stmt|;
else|else
block|{
name|GCPRO4
argument_list|(
name|tail
argument_list|,
name|eltstring
argument_list|,
name|allmatches
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|tem
operator|=
name|call1
argument_list|(
name|pred
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
continue|continue;
block|}
comment|/* Ok => put it on the list. */
name|allmatches
operator|=
name|Fcons
argument_list|(
name|eltstring
argument_list|,
name|allmatches
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Fnreverse
argument_list|(
name|allmatches
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_completion_table
decl_stmt|,
name|Qminibuffer_completion_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_completion_predicate
decl_stmt|,
name|Qminibuffer_completion_predicate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_completion_confirm
decl_stmt|,
name|Qminibuffer_completion_confirm
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"completing-read"
argument_list|,
argument|Fcompleting_read
argument_list|,
argument|Scompleting_read
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Read a string in the minibuffer, with completion.\n\ Args are PROMPT, TABLE, PREDICATE, REQUIRE-MATCH and INITIAL-INPUT.\n\ PROMPT is a string to prompt with; normally it ends in a colon and a space.\n\ TABLE is an alist whose elements' cars are strings, or an obarray (see try-completion).\n\ PREDICATE limits completion to a subset of TABLE; see try-completion for details.\n\ If REQUIRE-MATCH is non-nil, the user is not allowed to exit unless\n\  the input is (or completes to) an element of TABLE.\n\  If it is also not t, Return does not exit if it does non-null completion.\n\ If INITIAL-INPUT is non-nil, insert it in the minibuffer initially.\n\ Case is ignored if ambient value of  completion-ignore-case  is non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|table
operator|,
name|pred
operator|,
name|require_match
operator|,
name|init
operator|)
name|Lisp_Object
name|prompt
operator|,
name|table
operator|,
name|pred
operator|,
name|require_match
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|specbind
argument_list|(
name|Qminibuffer_completion_table
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|specbind
argument_list|(
name|Qminibuffer_completion_predicate
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|specbind
argument_list|(
name|Qminibuffer_completion_confirm
argument_list|,
name|EQ
argument_list|(
name|require_match
argument_list|,
name|Qt
argument_list|)
condition|?
name|Qnil
else|:
name|Qt
argument_list|)
expr_stmt|;
name|val
operator|=
name|read_minibuf
argument_list|(
name|NULL
argument_list|(
name|require_match
argument_list|)
condition|?
name|Vminibuffer_local_completion_map
else|:
name|Vminibuffer_local_must_match_map
argument_list|,
name|init
argument_list|,
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|temp_echo_area_contents
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|osize
init|=
name|ZV
decl_stmt|;
name|Lisp_Object
name|oinhibit
decl_stmt|;
name|oinhibit
operator|=
name|Vinhibit_quit
expr_stmt|;
name|SET_PT
argument_list|(
name|osize
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|osize
argument_list|)
expr_stmt|;
name|Vinhibit_quit
operator|=
name|Qt
expr_stmt|;
name|Fsit_for
argument_list|(
name|make_number
argument_list|(
literal|2
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|del_range
argument_list|(
name|point
argument_list|,
name|ZV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
block|{
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|unread_command_char
operator|=
name|Ctl
argument_list|(
literal|'g'
argument_list|)
expr_stmt|;
block|}
name|Vinhibit_quit
operator|=
name|oinhibit
expr_stmt|;
block|}
end_block

begin_function_decl
name|Lisp_Object
name|Fminibuffer_completion_help
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* returns:  * 0 no possible completion  * 1 was already an exact and unique completion  * 3 was already an exact completion  * 4 completed to an exact completion  * 5 some completion happened  * 6 no completion happened  */
end_comment

begin_function
name|int
name|do_completion
parameter_list|()
block|{
name|Lisp_Object
name|completion
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|completedp
decl_stmt|;
name|completion
operator|=
name|Ftry_completion
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|completion
argument_list|)
condition|)
block|{
name|bell
argument_list|()
expr_stmt|;
name|temp_echo_area_contents
argument_list|(
literal|" [No match]"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|completion
argument_list|,
name|Qt
argument_list|)
condition|)
comment|/* exact and unique match */
return|return
literal|1
return|;
comment|/* compiler bug */
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|completion
argument_list|,
name|Fbuffer_string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|completedp
operator|=
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|Ferase_buffer
argument_list|()
expr_stmt|;
comment|/* Some completion happened */
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|completion
argument_list|)
expr_stmt|;
block|}
comment|/* It did find a match.  Do we match some possibility exactly now? */
if|if
condition|(
name|CONSP
argument_list|(
name|Vminibuffer_completion_table
argument_list|)
operator|||
name|NULL
argument_list|(
name|Vminibuffer_completion_table
argument_list|)
condition|)
name|tem
operator|=
name|Fassoc
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_table
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|Vminibuffer_completion_table
argument_list|)
operator|==
name|Lisp_Vector
condition|)
block|{
comment|/* the primitive used by Fintern_soft */
specifier|extern
name|Lisp_Object
name|oblookup
parameter_list|()
function_decl|;
name|tem
operator|=
name|Fbuffer_string
argument_list|()
expr_stmt|;
comment|/* Bypass intern-soft as that loses for nil */
name|tem
operator|=
name|oblookup
argument_list|(
name|Vminibuffer_completion_table
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
name|tem
operator|=
name|Qnil
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vminibuffer_completion_predicate
argument_list|)
condition|)
name|tem
operator|=
name|call1
argument_list|(
name|Vminibuffer_completion_predicate
argument_list|,
name|tem
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|Qt
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|call3
argument_list|(
name|Vminibuffer_completion_table
argument_list|,
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|,
name|Qlambda
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
comment|/* not an exact match */
if|if
condition|(
name|completedp
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|completion_auto_help
condition|)
name|Fminibuffer_completion_help
argument_list|()
expr_stmt|;
else|else
name|temp_echo_area_contents
argument_list|(
literal|" [Next char not unique]"
argument_list|)
expr_stmt|;
return|return
literal|6
return|;
block|}
else|else
return|return
operator|(
name|completedp
condition|?
literal|4
else|:
literal|3
operator|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"minibuffer-complete"
argument_list|,
argument|Fminibuffer_complete
argument_list|,
argument|Sminibuffer_complete
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Complete the minibuffer contents as far as possible."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|int
name|i
operator|=
name|do_completion
argument_list|()
block|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
return|return
name|Qnil
return|;
case|case
literal|1
case|:
name|temp_echo_area_contents
argument_list|(
literal|" [Sole completion]"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|temp_echo_area_contents
argument_list|(
literal|" [Complete, but not unique]"
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_return
return|return
name|Qt
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"minibuffer-complete-and-exit"
operator|,
name|Fminibuffer_complete_and_exit
operator|,
name|Sminibuffer_complete_and_exit
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Complete the minibuffer contents, and maybe exit.\n\ Exit if the name is valid with no completion needed.\n\ If name was completed to a valid match,\n\ a repetition of this command will exit."
operator|)
operator|(
operator|)
block|{
specifier|register
name|int
name|i
block|;
comment|/* Allow user to specify null string */
if|if
condition|(
name|BEGV
operator|==
name|ZV
condition|)
goto|goto
name|exit
goto|;
name|i
operator|=
name|do_completion
argument_list|()
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|3
case|:
goto|goto
name|exit
goto|;
case|case
literal|4
case|:
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vminibuffer_completion_confirm
argument_list|)
condition|)
block|{
name|temp_echo_area_contents
argument_list|(
literal|" [Confirm]"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
else|else
goto|goto
name|exit
goto|;
default|default:
return|return
name|Qnil
return|;
block|}
end_switch

begin_label
name|exit
label|:
end_label

begin_expr_stmt
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* NOTREACHED */
end_comment

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"minibuffer-complete-word"
operator|,
name|Fminibuffer_complete_word
operator|,
name|Sminibuffer_complete_word
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Complete the minibuffer contents at most a single word."
operator|)
operator|(
operator|)
block|{
name|Lisp_Object
name|completion
block|,
name|tem
block|;
specifier|register
name|int
name|i
block|;
specifier|register
name|unsigned
name|char
operator|*
name|completion_string
block|;
comment|/* We keep calling Fbuffer_string      rather than arrange for GC to hold onto a pointer to      one of the strings thus made.  */
name|completion
operator|=
name|Ftry_completion
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
block|;
if|if
condition|(
name|NULL
argument_list|(
name|completion
argument_list|)
condition|)
block|{
name|bell
argument_list|()
expr_stmt|;
name|temp_echo_area_contents
argument_list|(
literal|" [No match]"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|EQ
argument_list|(
name|completion
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|Qnil
return|;
end_if

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* How the below code used to look, for reference */
end_comment

begin_comment
unit|tem = Fbuffer_string ();   b = XSTRING (tem)->data;   i = ZV - 1 - XSTRING (completion)->size;   p = XSTRING (completion)->data;   if (i> 0 ||       0<= scmp (b, p, ZV - 1))     {       i = 1;
comment|/* Set buffer to longest match of buffer tail and completion head. */
end_comment

begin_else
unit|while (0<= scmp (b + i, p, ZV - 1 - i)) 	i++;       del_range (1, i + 1);       SET_PT (ZV);     }
else|#
directive|else
end_else

begin_comment
comment|/* Rewritten code */
end_comment

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|buffer_string
decl_stmt|;
name|int
name|buffer_length
decl_stmt|,
name|completion_length
decl_stmt|;
name|tem
operator|=
name|Fbuffer_string
argument_list|()
expr_stmt|;
name|buffer_string
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
expr_stmt|;
name|completion_string
operator|=
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|data
expr_stmt|;
name|buffer_length
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
expr_stmt|;
comment|/* ie ZV - BEGV */
name|completion_length
operator|=
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|size
expr_stmt|;
name|i
operator|=
name|buffer_length
operator|-
name|completion_length
expr_stmt|;
comment|/* Mly: I don't understand what this is supposed to do AT ALL */
if|if
condition|(
name|i
operator|>
literal|0
operator|||
literal|0
operator|<=
name|scmp
argument_list|(
name|buffer_string
argument_list|,
name|completion_string
argument_list|,
name|buffer_length
argument_list|)
condition|)
block|{
comment|/* Set buffer to longest match of buffer tail and completion head. */
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
name|buffer_string
operator|+=
name|i
expr_stmt|;
name|buffer_length
operator|-=
name|i
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
name|scmp
argument_list|(
name|buffer_string
operator|++
argument_list|,
name|completion_string
argument_list|,
name|buffer_length
operator|--
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|del_range
argument_list|(
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|ZV
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Rewritten code */
end_comment

begin_expr_stmt
name|i
operator|=
name|ZV
operator|-
name|BEGV
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If completion finds next char not unique,      consider adding a space or a hyphen */
end_comment

begin_if
if|if
condition|(
name|i
operator|==
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|size
condition|)
block|{
name|tem
operator|=
name|Ftry_completion
argument_list|(
name|concat2
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|build_string
argument_list|(
literal|" "
argument_list|)
argument_list|)
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|completion
operator|=
name|tem
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|Ftry_completion
argument_list|(
name|concat2
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|build_string
argument_list|(
literal|"-"
argument_list|)
argument_list|)
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|completion
operator|=
name|tem
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* Now find first word-break in the stuff found by completion.      i gets index in string of where to stop completing.  */
end_comment

begin_expr_stmt
name|completion_string
operator|=
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|data
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
name|i
operator|<
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|completion_string
index|[
name|i
index|]
argument_list|)
operator|!=
name|Sword
condition|)
break|break;
end_for

begin_if
if|if
condition|(
name|i
operator|<
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|size
condition|)
name|i
operator|=
name|i
operator|+
literal|1
expr_stmt|;
end_if

begin_comment
comment|/* If got no characters, print help for user.  */
end_comment

begin_if
if|if
condition|(
name|i
operator|==
name|ZV
operator|-
name|BEGV
condition|)
block|{
if|if
condition|(
name|completion_auto_help
condition|)
name|Fminibuffer_completion_help
argument_list|()
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_if

begin_comment
comment|/* Otherwise insert in minibuffer the chars we got */
end_comment

begin_expr_stmt
name|Ferase_buffer
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|insert
argument_list|(
name|completion_string
argument_list|,
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qt
return|;
end_return

begin_escape
unit|}
end_escape

begin_expr_stmt
unit|DEFUN
operator|(
literal|"display-completion-list"
operator|,
name|Fdisplay_completion_list
operator|,
name|Sdisplay_completion_list
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"Display in a buffer the list of completions, COMPLETIONS.\n\ Each element may be just a symbol or string\n\ or may be a list of two strings to be printed as if concatenated."
operator|)
operator|(
name|completions
operator|)
name|Lisp_Object
name|completions
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|elt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
comment|/* No GCPRO needed, since (when it matters) every variable      points to a non-string that is pointed to by COMPLETIONS.  */
name|set_buffer_internal
argument_list|(
name|XBUFFER
argument_list|(
name|Vstandard_output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|completions
argument_list|)
condition|)
name|InsStr
argument_list|(
literal|"There are no possible completions of what you have typed."
argument_list|)
expr_stmt|;
else|else
block|{
name|InsStr
argument_list|(
literal|"Possible completions are:"
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|completions
operator|,
name|i
operator|=
literal|0
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* this needs fixing for the case of long completions 	     and/or narrow windows */
comment|/* Sadly, the window it will appear in is not known 	     until after the text has been made. */
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|35
argument_list|)
argument_list|,
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Fterpri
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
name|elt
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSP
argument_list|(
name|elt
argument_list|)
condition|)
block|{
name|Fprinc
argument_list|(
name|Fcar
argument_list|(
name|elt
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Fprinc
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
else|else
name|Fprinc
argument_list|(
name|elt
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
block|}
name|set_buffer_internal
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"minibuffer-completion-help"
argument_list|,
argument|Fminibuffer_completion_help
argument_list|,
argument|Sminibuffer_completion_help
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Display a list of possible completions of the current minibuffer contents."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|completions
block|;
name|message
argument_list|(
literal|"Making completion list..."
argument_list|)
block|;
name|completions
operator|=
name|Fall_completions
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
block|;
name|echo_area_contents
operator|=
literal|0
block|;
if|if
condition|(
name|NULL
argument_list|(
name|completions
argument_list|)
condition|)
block|{
name|bell
argument_list|()
expr_stmt|;
name|temp_echo_area_contents
argument_list|(
literal|" [No completions]"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|internal_with_output_to_temp_buffer
argument_list|(
literal|" *Completions*"
argument_list|,
name|Fdisplay_completion_list
argument_list|,
name|Fsort
argument_list|(
name|completions
argument_list|,
name|Qstring_lessp
argument_list|)
argument_list|)
expr_stmt|;
end_else

begin_return
return|return
name|Qnil
return|;
end_return

begin_escape
unit|}
end_escape

begin_expr_stmt
unit|DEFUN
operator|(
literal|"self-insert-and-exit"
operator|,
name|Fself_insert_and_exit
operator|,
name|Sself_insert_and_exit
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Terminate minibuffer input."
operator|)
operator|(
operator|)
block|{
name|self_insert_internal
argument_list|(
name|last_command_char
argument_list|,
literal|0
argument_list|)
block|;
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qnil
argument_list|)
block|; }
name|DEFUN
argument_list|(
literal|"exit-minibuffer"
argument_list|,
argument|Fexit_minibuffer
argument_list|,
argument|Sexit_minibuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Terminate this minibuffer argument."
argument_list|)
operator|(
operator|)
block|{
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qnil
argument_list|)
block|; }
name|DEFUN
argument_list|(
literal|"minibuffer-depth"
argument_list|,
argument|Fminibuffer_depth
argument_list|,
argument|Sminibuffer_depth
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return current depth of activations of minibuffer, a nonnegative integer."
argument_list|)
operator|(
operator|)
block|{
return|return
name|make_number
argument_list|(
name|minibuf_level
argument_list|)
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|init_minibuf_once
argument_list|()
end_macro

begin_block
block|{
name|Vminibuffer_list
operator|=
name|Qnil
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vminibuffer_list
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|syms_of_minibuf
argument_list|()
end_macro

begin_block
block|{
name|minibuf_level
operator|=
literal|0
expr_stmt|;
name|minibuf_prompt
operator|=
literal|0
expr_stmt|;
name|minibuf_save_vector_size
operator|=
literal|5
expr_stmt|;
name|minibuf_save_vector
operator|=
operator|(
expr|struct
name|minibuf_save_data
operator|*
operator|)
name|malloc
argument_list|(
literal|5
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minibuf_save_data
argument_list|)
argument_list|)
expr_stmt|;
name|Qminibuffer_completion_table
operator|=
name|intern
argument_list|(
literal|"minibuffer-completion-table"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qminibuffer_completion_table
argument_list|)
expr_stmt|;
name|Qminibuffer_completion_confirm
operator|=
name|intern
argument_list|(
literal|"minibuffer-completion-confirm"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qminibuffer_completion_confirm
argument_list|)
expr_stmt|;
name|Qminibuffer_completion_predicate
operator|=
name|intern
argument_list|(
literal|"minibuffer-completion-predicate"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qminibuffer_completion_predicate
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|last_minibuf_string
argument_list|)
expr_stmt|;
name|last_minibuf_string
operator|=
name|Qnil
expr_stmt|;
name|Quser_variable_p
operator|=
name|intern
argument_list|(
literal|"user-variable-p"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Quser_variable_p
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"completion-auto-help"
argument_list|,
operator|&
name|completion_auto_help
argument_list|,
literal|"*Non-nil means automatically provide help for invalid completion input."
argument_list|)
expr_stmt|;
name|completion_auto_help
operator|=
literal|1
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"completion-ignore-case"
argument_list|,
operator|&
name|completion_ignore_case
argument_list|,
literal|"Non-nil means don't consider case significant in completion."
argument_list|)
expr_stmt|;
name|completion_ignore_case
operator|=
literal|0
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"enable-recursive-minibuffers"
argument_list|,
operator|&
name|enable_recursive_minibuffers
argument_list|,
literal|"*Non-nil means to allow minibuffers to invoke commands which use\n\ recursive minibuffers."
argument_list|)
expr_stmt|;
name|enable_recursive_minibuffers
operator|=
literal|0
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"minibuffer-completion-table"
argument_list|,
operator|&
name|Vminibuffer_completion_table
argument_list|,
literal|"Alist or obarray used for completion in the minibuffer."
argument_list|)
expr_stmt|;
name|Vminibuffer_completion_table
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"minibuffer-completion-predicate"
argument_list|,
operator|&
name|Vminibuffer_completion_predicate
argument_list|,
literal|"Holds PREDICATE argument to completing-read."
argument_list|)
expr_stmt|;
name|Vminibuffer_completion_predicate
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"minibuffer-completion-confirm"
argument_list|,
operator|&
name|Vminibuffer_completion_confirm
argument_list|,
literal|"Non-nil => demand confirmation of completion before exiting minibuffer."
argument_list|)
expr_stmt|;
name|Vminibuffer_completion_confirm
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"minibuffer-help-form"
argument_list|,
operator|&
name|Vminibuffer_help_form
argument_list|,
literal|"Value that help-form takes on inside the minibuffer."
argument_list|)
expr_stmt|;
name|Vminibuffer_help_form
operator|=
name|Qnil
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_from_minibuffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seval_minibuffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_minibuffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_command
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_variable
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_no_blanks_input
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_depth
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Stry_completion
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sall_completions
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scompleting_read
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_complete
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_complete_word
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_complete_and_exit
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdisplay_completion_list
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_completion_help
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sself_insert_and_exit
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexit_minibuffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_minibuf
argument_list|()
end_macro

begin_block
block|{
name|ndefkey
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|Ctl
argument_list|(
literal|'g'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|Ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|Ctl
argument_list|(
literal|'j'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|Ctl
argument_list|(
literal|'g'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|Ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|Ctl
argument_list|(
literal|'j'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
literal|' '
argument_list|,
literal|"exit-minibuffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
literal|'\t'
argument_list|,
literal|"exit-minibuffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
literal|'?'
argument_list|,
literal|"self-insert-and-exit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
name|Ctl
argument_list|(
literal|'g'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
name|Ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
name|Ctl
argument_list|(
literal|'j'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
literal|'\t'
argument_list|,
literal|"minibuffer-complete"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
literal|' '
argument_list|,
literal|"minibuffer-complete-word"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
literal|'?'
argument_list|,
literal|"minibuffer-completion-help"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
name|Ctl
argument_list|(
literal|'g'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
name|Ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|,
literal|"minibuffer-complete-and-exit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
name|Ctl
argument_list|(
literal|'j'
argument_list|)
argument_list|,
literal|"minibuffer-complete-and-exit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
literal|'\t'
argument_list|,
literal|"minibuffer-complete"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
literal|' '
argument_list|,
literal|"minibuffer-complete-word"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
literal|'?'
argument_list|,
literal|"minibuffer-completion-help"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

