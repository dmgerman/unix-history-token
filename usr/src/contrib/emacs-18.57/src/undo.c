begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* undo handling for GNU Emacs.    Copyright (C) 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_comment
comment|/* Last buffer for which undo information was recorded.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|last_undo_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record an insertion that just happened or is about to happen,    for LENGTH characters at position BEG.    (It is possible to record an insertion before or after the fact    because we don't need to record the contents.)  */
end_comment

begin_macro
name|record_insert
argument_list|(
argument|beg
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|beg
decl_stmt|,
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|lbeg
decl_stmt|,
name|lend
decl_stmt|;
if|if
condition|(
name|current_buffer
operator|!=
name|XBUFFER
argument_list|(
name|last_undo_buffer
argument_list|)
condition|)
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|XSET
argument_list|(
name|last_undo_buffer
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|current_buffer
operator|->
name|undo_list
argument_list|,
name|Qt
argument_list|)
condition|)
return|return;
if|if
condition|(
name|MODIFF
operator|<=
name|current_buffer
operator|->
name|save_modified
condition|)
name|record_first_change
argument_list|()
expr_stmt|;
comment|/* If this is following another insertion and consecutive with it      in the buffer, combine the two.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|current_buffer
operator|->
name|undo_list
argument_list|)
operator|==
name|Lisp_Cons
condition|)
block|{
name|Lisp_Object
name|elt
decl_stmt|;
name|elt
operator|=
name|XCONS
argument_list|(
name|current_buffer
operator|->
name|undo_list
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|==
name|Lisp_Cons
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|car
argument_list|)
operator|==
name|Lisp_Int
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|cdr
argument_list|)
operator|==
name|Lisp_Int
operator|&&
name|XINT
argument_list|(
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|cdr
argument_list|)
operator|==
name|beg
condition|)
block|{
name|XSETINT
argument_list|(
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|cdr
argument_list|,
name|beg
operator|+
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|XFASTINT
argument_list|(
name|lbeg
argument_list|)
operator|=
name|beg
expr_stmt|;
name|XFASTINT
argument_list|(
name|lend
argument_list|)
operator|=
name|beg
operator|+
name|length
expr_stmt|;
name|current_buffer
operator|->
name|undo_list
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|lbeg
argument_list|,
name|lend
argument_list|)
argument_list|,
name|current_buffer
operator|->
name|undo_list
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Record that a deletion is about to take place,    for LENGTH characters at location BEG.  */
end_comment

begin_macro
name|record_delete
argument_list|(
argument|beg
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|int
name|beg
decl_stmt|,
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|lbeg
decl_stmt|,
name|llength
decl_stmt|,
name|lend
decl_stmt|,
name|sbeg
decl_stmt|;
if|if
condition|(
name|current_buffer
operator|!=
name|XBUFFER
argument_list|(
name|last_undo_buffer
argument_list|)
condition|)
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|XSET
argument_list|(
name|last_undo_buffer
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|current_buffer
operator|->
name|undo_list
argument_list|,
name|Qt
argument_list|)
condition|)
return|return;
if|if
condition|(
name|MODIFF
operator|<=
name|current_buffer
operator|->
name|save_modified
condition|)
name|record_first_change
argument_list|()
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|beg
operator|+
name|length
condition|)
name|XSET
argument_list|(
name|sbeg
argument_list|,
name|Lisp_Int
argument_list|,
operator|-
name|beg
argument_list|)
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|sbeg
argument_list|)
operator|=
name|beg
expr_stmt|;
name|XFASTINT
argument_list|(
name|lbeg
argument_list|)
operator|=
name|beg
expr_stmt|;
name|XFASTINT
argument_list|(
name|llength
argument_list|)
operator|=
name|length
expr_stmt|;
name|XFASTINT
argument_list|(
name|lend
argument_list|)
operator|=
name|beg
operator|+
name|length
expr_stmt|;
name|current_buffer
operator|->
name|undo_list
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|Fbuffer_substring
argument_list|(
name|lbeg
argument_list|,
name|lend
argument_list|)
argument_list|,
name|sbeg
argument_list|)
argument_list|,
name|current_buffer
operator|->
name|undo_list
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Record that a replacement is about to take place,    for LENGTH characters at location BEG.    The replacement does not change the number of characters.  */
end_comment

begin_macro
name|record_change
argument_list|(
argument|beg
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|int
name|beg
decl_stmt|,
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|record_delete
argument_list|(
name|beg
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|record_insert
argument_list|(
name|beg
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Record that an unmodified buffer is about to be changed.    Record the file modification date so that when undoing this entry    we can tell whether it is obsolete because the file was saved again.  */
end_comment

begin_macro
name|record_first_change
argument_list|()
end_macro

begin_block
block|{
name|Lisp_Object
name|high
decl_stmt|,
name|low
decl_stmt|;
name|XFASTINT
argument_list|(
name|high
argument_list|)
operator|=
operator|(
name|current_buffer
operator|->
name|modtime
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|XFASTINT
argument_list|(
name|low
argument_list|)
operator|=
name|current_buffer
operator|->
name|modtime
operator|&
literal|0xffff
expr_stmt|;
name|current_buffer
operator|->
name|undo_list
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|Qt
argument_list|,
name|Fcons
argument_list|(
name|high
argument_list|,
name|low
argument_list|)
argument_list|)
argument_list|,
name|current_buffer
operator|->
name|undo_list
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"undo-boundary"
argument_list|,
argument|Fundo_boundary
argument_list|,
argument|Sundo_boundary
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Mark a boundary between units of undo.\n\ An undo command will stop at this point,\n\ but another undo command will undo to the previous boundary."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|tem
block|;
if|if
condition|(
name|EQ
argument_list|(
name|current_buffer
operator|->
name|undo_list
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|tem
operator|=
name|Fcar
argument_list|(
name|current_buffer
operator|->
name|undo_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|current_buffer
operator|->
name|undo_list
operator|=
name|Fcons
argument_list|(
name|Qnil
argument_list|,
name|current_buffer
operator|->
name|undo_list
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|Qnil
return|;
end_return

begin_comment
unit|}
comment|/* At garbage collection time, make an undo list shorter at the end,    returning the truncated list.    MINSIZE and MAXSIZE are the limits on size allowed, as described below.    In practice, these are the values of undo-threshold and    undo-high-threshold.  */
end_comment

begin_macro
unit|Lisp_Object
name|truncate_undo_list
argument_list|(
argument|list
argument_list|,
argument|minsize
argument_list|,
argument|maxsize
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minsize
decl_stmt|,
name|maxsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|prev
decl_stmt|,
name|next
decl_stmt|,
name|save_prev
decl_stmt|;
name|int
name|size_so_far
init|=
literal|0
decl_stmt|;
name|prev
operator|=
name|Qnil
expr_stmt|;
name|next
operator|=
name|list
expr_stmt|;
name|save_prev
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|next
argument_list|)
operator|==
name|Lisp_Cons
condition|)
block|{
name|Lisp_Object
name|elt
decl_stmt|;
name|elt
operator|=
name|XCONS
argument_list|(
name|next
argument_list|)
operator|->
name|car
expr_stmt|;
comment|/* When we get to a boundary, decide whether to truncate 	 either before or after it.  The lower threshold, MINSIZE, 	 tells us to truncate after it.  If its size pushes past 	 the higher threshold MAXSIZE as well, we truncate before it.  */
if|if
condition|(
name|NULL
argument_list|(
name|elt
argument_list|)
condition|)
block|{
if|if
condition|(
name|size_so_far
operator|>
name|maxsize
condition|)
break|break;
name|save_prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|size_so_far
operator|>
name|minsize
condition|)
break|break;
block|}
comment|/* Add in the space occupied by this element and its chain link.  */
name|size_so_far
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|==
name|Lisp_Cons
condition|)
block|{
name|size_so_far
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|car
argument_list|)
operator|==
name|Lisp_String
condition|)
name|size_so_far
operator|+=
literal|6
operator|+
name|XSTRING
argument_list|(
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|size
expr_stmt|;
block|}
comment|/* Advance to next element.  */
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|XCONS
argument_list|(
name|next
argument_list|)
operator|->
name|cdr
expr_stmt|;
block|}
comment|/* If we scanned the whole list, it is short enough; don't change it.  */
if|if
condition|(
name|NULL
argument_list|(
name|next
argument_list|)
condition|)
return|return
name|list
return|;
comment|/* Truncate at the boundary where we decided to truncate.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|save_prev
argument_list|)
condition|)
block|{
name|XCONS
argument_list|(
name|save_prev
argument_list|)
operator|->
name|cdr
operator|=
name|Qnil
expr_stmt|;
return|return
name|list
return|;
block|}
else|else
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"primitive-undo"
argument_list|,
argument|Fprimitive_undo
argument_list|,
argument|Sprimitive_undo
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Undo N records from the front of the list LIST.\n\ Return what remains of the list."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|count
operator|,
name|list
operator|)
name|Lisp_Object
name|count
operator|,
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|arg
init|=
name|XINT
argument_list|(
name|count
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This is a good feature, but would make undo-start 	  unable to do what is expected.  */
block|Lisp_Object tem;
comment|/* If the head of the list is a boundary, it is the boundary      preceding this command.  Get rid of it and don't count it.  */
block|tem = Fcar (list);   if (NULL (tem))     list = Fcdr (list);
endif|#
directive|endif
while|while
condition|(
name|arg
operator|>
literal|0
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|Lisp_Object
name|next
decl_stmt|,
name|car
decl_stmt|,
name|cdr
decl_stmt|;
name|next
operator|=
name|Fcar
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|next
argument_list|)
condition|)
break|break;
name|car
operator|=
name|Fcar
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|cdr
operator|=
name|Fcdr
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|car
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
name|Lisp_Object
name|high
decl_stmt|,
name|low
decl_stmt|;
name|int
name|mod_time
decl_stmt|;
name|high
operator|=
name|Fcar
argument_list|(
name|cdr
argument_list|)
expr_stmt|;
name|low
operator|=
name|Fcdr
argument_list|(
name|cdr
argument_list|)
expr_stmt|;
name|mod_time
operator|=
operator|(
name|high
operator|<<
literal|16
operator|)
operator|+
name|low
expr_stmt|;
comment|/* If this records an obsolete save 		 (not matching the actual disk file) 		 then don't mark unmodified.  */
if|if
condition|(
name|mod_time
operator|!=
name|current_buffer
operator|->
name|modtime
condition|)
break|break;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|Funlock_buffer
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|Fset_buffer_modified_p
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|car
argument_list|)
operator|==
name|Lisp_Int
operator|&&
name|XTYPE
argument_list|(
name|cdr
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|Lisp_Object
name|end
decl_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|car
argument_list|)
operator|<
name|BEGV
operator|||
name|XINT
argument_list|(
name|cdr
argument_list|)
operator|>
name|ZV
condition|)
name|error
argument_list|(
literal|"Changes to be undone are outside visible portion of buffer"
argument_list|)
expr_stmt|;
name|Fdelete_region
argument_list|(
name|car
argument_list|,
name|cdr
argument_list|)
expr_stmt|;
name|Fgoto_char
argument_list|(
name|car
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|car
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XTYPE
argument_list|(
name|cdr
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|Lisp_Object
name|membuf
decl_stmt|;
name|int
name|pos
init|=
name|XINT
argument_list|(
name|cdr
argument_list|)
decl_stmt|;
name|membuf
operator|=
name|car
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|-
name|pos
operator|<
name|BEGV
operator|||
operator|-
name|pos
operator|>
name|ZV
condition|)
name|error
argument_list|(
literal|"Changes to be undone are outside visible portion of buffer"
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
operator|-
name|pos
argument_list|)
expr_stmt|;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|membuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pos
operator|<
name|BEGV
operator|||
name|pos
operator|>
name|ZV
condition|)
name|error
argument_list|(
literal|"Changes to be undone are outside visible portion of buffer"
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|membuf
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|arg
operator|--
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_block

begin_macro
name|syms_of_undo
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Sprimitive_undo
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sundo_boundary
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

