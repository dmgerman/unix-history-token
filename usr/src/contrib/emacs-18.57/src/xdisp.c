begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Display generation from window structure and buffer text.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*#include<ctype.h>*/
end_comment

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"indent.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|interrupt_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|command_loop_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print newline before next minibuffer message.  */
end_comment

begin_decl_stmt
name|int
name|noninteractive_need_newline
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* The buffer position of the first character appearing  entirely or partially on the current screen line.  Or zero, which disables the optimization for the current screen line. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_line_bufpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters past the end of this line,    including the terminating newline */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_line_endpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The vertical position of this screen line. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_line_vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hpos value for start of display on this screen line.    Usually zero, but negative if first character really began    on previous line */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_line_start_hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer that this_line variables are describing. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|this_line_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of echo_area_contents when it was last acted on.   If this is nonzero, there is a message on the screen   in the minibuffer and it should be erased as soon   as it is no longer requested to appear. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prev_echo_area_contents
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means truncate lines in all windows less wide than the screen */
end_comment

begin_decl_stmt
name|int
name|truncate_partial_width_windows
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vglobal_mode_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Marker for where to display an arrow on top of the buffer text.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Voverlay_arrow_position
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to display for the arrow.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Voverlay_arrow_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values of those variables at last redisplay.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|last_arrow_position
decl_stmt|,
name|last_arrow_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If cursor motion alone moves point off screen,    Try scrolling this many lines up or down if that will bring it back.  */
end_comment

begin_decl_stmt
name|int
name|scroll_step
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means send various TERMCAP strings when screen is cleared.  */
end_comment

begin_decl_stmt
name|int
name|reset_terminal_on_clear
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if try_window_id has made blank lines at window bottom  since the last redisplay that paused */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blank_end_of_window
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of windows showing the buffer of the selected window.    keyboard.c refers to this.  */
end_comment

begin_decl_stmt
name|int
name|buffer_shared
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display_text_line sets these to the screen position (origin 0) of point,   whether the window is selected or not.  Set one to -1 first to determine whether point was found afterwards.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|point_vpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|point_hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug_end_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means display mode line highlighted */
end_comment

begin_decl_stmt
name|int
name|mode_line_inverse_video
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|position
modifier|*
name|display_text_line
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Prompt to display in front of the minibuffer contents */
end_comment

begin_decl_stmt
name|char
modifier|*
name|minibuf_prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Width in columns of current minibuffer prompt.  */
end_comment

begin_decl_stmt
name|int
name|minibuf_prompt_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message to display instead of minibuffer contents    This is what the functions error and message make,    and command echoing uses it as well.    It overrides the minibuf_prompt as well as the buffer.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|echo_area_contents
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True iff we should redraw the mode lines on the next redisplay */
end_comment

begin_decl_stmt
name|int
name|update_mode_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Smallest number of characters before the gap    at any time since last redisplay that finished.    Valid for current buffer when try_window_id can be called.  */
end_comment

begin_decl_stmt
name|int
name|beg_unchanged
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Smallest number of characters after the gap    at any time since last redisplay that finished.    Valid for current buffer when try_window_id can be called.  */
end_comment

begin_decl_stmt
name|int
name|end_unchanged
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MODIFF as of last redisplay that finished;  if it matches MODIFF, beg_unchanged and end_unchanged  contain no useful information */
end_comment

begin_decl_stmt
name|int
name|unchanged_modified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if head_clip or tail_clip of current buffer has changed  since last redisplay that finished */
end_comment

begin_decl_stmt
name|int
name|clip_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if window sizes or contents have changed  since last redisplay that finished */
end_comment

begin_decl_stmt
name|int
name|windows_or_buffers_changed
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|decode_mode_spec
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"redraw-display"
argument_list|,
argument|Fredraw_display
argument_list|,
argument|Sredraw_display
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Clear the screen and output again what is supposed to appear on it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Some bug zeros some core */
end_comment

begin_if
if|if
condition|(
name|reset_terminal_on_clear
condition|)
name|set_terminal_modes
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|clear_screen
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_screen_records
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_comment
comment|/* Some bug zeros some core */
end_comment

begin_expr_stmt
name|windows_or_buffers_changed
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Mark all windows as INaccurate,      so that every window will have its redisplay done.  */
end_comment

begin_expr_stmt
name|mark_window_display_accurate
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
end_if

begin_comment
comment|/* Some bug zeros some core */
end_comment

begin_return
return|return
name|Qnil
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* Buffer used for messages formatted by `message'.  */
end_comment

begin_expr_stmt
unit|char
operator|*
name|message_buf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* dump an informative message to the minibuf */
end_comment

begin_comment
comment|/* VARARGS 1 */
end_comment

begin_macro
name|message
argument_list|(
argument|m
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
block|{
if|if
condition|(
name|noninteractive_need_newline
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|noninteractive_need_newline
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
name|m
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FROM_KBD
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|int
name|a
index|[
literal|3
index|]
decl_stmt|;
name|a
index|[
literal|0
index|]
operator|=
name|a1
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
name|a2
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|=
name|a3
expr_stmt|;
name|doprnt
argument_list|(
name|message_buf
argument_list|,
name|screen_width
argument_list|,
name|m
argument_list|,
literal|3
argument_list|,
name|a
argument_list|)
expr_stmt|;
else|#
directive|else
name|doprnt
argument_list|(
name|message_buf
argument_list|,
name|screen_width
argument_list|,
name|m
argument_list|,
literal|3
argument_list|,
operator|&
name|a1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NO_ARG_ARRAY */
name|echo_area_contents
operator|=
name|message_buf
expr_stmt|;
do|do
block|{
name|do_pending_window_change
argument_list|()
expr_stmt|;
name|display_echo_area_contents
argument_list|()
expr_stmt|;
name|update_screen
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_window_change
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|screen_garbaged
condition|)
do|;
block|}
block|}
end_block

begin_comment
comment|/* Specify m, a string, as a message in the minibuf.  */
end_comment

begin_macro
name|message1
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
block|{
if|if
condition|(
name|noninteractive_need_newline
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|noninteractive_need_newline
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FROM_KBD
condition|)
block|{
name|echo_area_contents
operator|=
name|m
expr_stmt|;
do|do
block|{
name|do_pending_window_change
argument_list|()
expr_stmt|;
name|display_echo_area_contents
argument_list|()
expr_stmt|;
name|update_screen
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_pending_window_change
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|screen_garbaged
condition|)
do|;
block|}
block|}
end_block

begin_macro
name|display_echo_area_contents
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|vpos
decl_stmt|;
if|if
condition|(
name|screen_garbaged
condition|)
block|{
name|Fredraw_display
argument_list|()
expr_stmt|;
name|screen_garbaged
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|echo_area_contents
operator|||
name|minibuf_level
operator|==
literal|0
condition|)
block|{
name|vpos
operator|=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|top
argument_list|)
expr_stmt|;
name|get_display_line
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|display_string
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
argument_list|,
name|vpos
argument_list|,
name|echo_area_contents
condition|?
name|echo_area_contents
else|:
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
argument_list|)
expr_stmt|;
comment|/* If desired cursor location is on this line, put it at end of text */
if|if
condition|(
name|cursor_vpos
operator|==
name|vpos
condition|)
name|cursor_hpos
operator|=
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|windows_or_buffers_changed
operator|++
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
name|prev_echo_area_contents
operator|=
name|echo_area_contents
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Do a screen update, taking possible shortcuts into account.    This is the main external entry point for redisplay.     If the last redisplay displayed an echo area message and that    message is no longer requested, we clear the echo area    or bring back the minibuffer if that is in use.     Everyone would like to have a hook here to call eval,    but that cannot be done safely without a lot of changes elsewhere.    This can be called from signal handlers; with alarms set up;    or with synchronous processes running.    See the function `echo' in keyboard.c.    See Fcall_process; if you called it from here, it could be    entered recursively.  */
end_comment

begin_macro
name|redisplay
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|pause
decl_stmt|;
name|int
name|inhibit_hairy_id
init|=
literal|0
decl_stmt|;
name|int
name|must_finish
init|=
literal|0
decl_stmt|;
name|int
name|all_windows
decl_stmt|;
specifier|register
name|int
name|tlbufpos
decl_stmt|,
name|tlendpos
decl_stmt|;
name|struct
name|position
name|pos
decl_stmt|;
specifier|extern
name|int
name|input_pending
decl_stmt|;
if|if
condition|(
name|noninteractive
condition|)
return|return;
comment|/* Notice any pending interrupt request to change screen size.  */
name|do_pending_window_change
argument_list|()
expr_stmt|;
if|if
condition|(
name|screen_garbaged
condition|)
block|{
name|Fredraw_display
argument_list|()
expr_stmt|;
name|screen_garbaged
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initially we have nothing to update on the screen.  */
name|bzero
argument_list|(
name|new_screen
operator|->
name|enable
argument_list|,
name|new_screen
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo_area_contents
operator|!=
literal|0
operator|||
name|prev_echo_area_contents
operator|!=
literal|0
condition|)
block|{
name|display_echo_area_contents
argument_list|()
expr_stmt|;
name|must_finish
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|clip_changed
operator|||
name|windows_or_buffers_changed
condition|)
name|update_mode_lines
operator|++
expr_stmt|;
comment|/* Detect case that we need to write a star in the mode line.  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|<
name|MODIFF
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|<=
name|current_buffer
operator|->
name|save_modified
condition|)
block|{
name|w
operator|->
name|update_mode_line
operator|=
name|Qt
expr_stmt|;
if|if
condition|(
name|buffer_shared
operator|>
literal|1
condition|)
name|update_mode_lines
operator|++
expr_stmt|;
block|}
name|all_windows
operator|=
name|update_mode_lines
operator|||
name|buffer_shared
operator|>
literal|1
expr_stmt|;
comment|/* If specs for an arrow have changed, do thorough redisplay      to ensure we remove any arrow that should no longer exist.  */
if|if
condition|(
name|Voverlay_arrow_position
operator|!=
name|last_arrow_position
operator|||
name|Voverlay_arrow_string
operator|!=
name|last_arrow_string
condition|)
name|all_windows
operator|=
literal|1
operator|,
name|clip_changed
operator|=
literal|1
expr_stmt|;
name|tlbufpos
operator|=
name|this_line_bufpos
expr_stmt|;
name|tlendpos
operator|=
name|this_line_endpos
expr_stmt|;
if|if
condition|(
operator|!
name|all_windows
operator|&&
name|tlbufpos
operator|>
literal|0
operator|&&
name|NULL
argument_list|(
name|w
operator|->
name|update_mode_line
argument_list|)
comment|/* Make sure recorded data applies to current buffer, etc */
operator|&&
name|this_line_buffer
operator|==
name|current_buffer
operator|&&
name|current_buffer
operator|==
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|&&
name|NULL
argument_list|(
name|w
operator|->
name|force_start
argument_list|)
comment|/* Point must be on the line that we have info recorded about */
operator|&&
name|point
operator|>=
name|tlbufpos
operator|&&
name|point
operator|<=
name|Z
operator|-
name|tlendpos
comment|/* All text outside that line, including its final newline, 	 must be unchanged */
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|>=
name|MODIFF
operator|||
operator|(
name|beg_unchanged
operator|>=
name|tlbufpos
operator|-
literal|1
operator|&&
name|GPT
operator|>=
name|tlbufpos
operator|&&
name|end_unchanged
operator|>=
name|tlendpos
operator|&&
name|Z
operator|-
name|GPT
operator|>=
name|tlendpos
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tlbufpos
operator|>
name|BEGV
operator|&&
name|FETCH_CHAR
argument_list|(
name|tlbufpos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|&&
operator|(
name|tlbufpos
operator|==
name|ZV
operator|||
name|FETCH_CHAR
argument_list|(
name|tlbufpos
argument_list|)
operator|==
literal|'\n'
operator|)
condition|)
comment|/* Former continuation line has disappeared by becoming empty */
goto|goto
name|cancel
goto|;
elseif|else
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|<
name|MODIFF
operator|||
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
block|{
name|point_vpos
operator|=
operator|-
literal|1
expr_stmt|;
name|display_text_line
argument_list|(
name|w
argument_list|,
name|tlbufpos
argument_list|,
name|this_line_vpos
argument_list|,
name|this_line_start_hpos
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|tlbufpos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If line contains point, is not continued, 		 and ends at same distance from eob as before, we win */
if|if
condition|(
name|point_vpos
operator|>=
literal|0
operator|&&
name|this_line_bufpos
operator|&&
name|this_line_endpos
operator|==
name|tlendpos
condition|)
block|{
comment|/* Done by display_text_line 		 cursor_hpos = point_hpos; 	         cursor_vpos = this_line_vpos; 	       */
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|!=
name|screen_width
condition|)
name|preserve_other_columns
argument_list|(
name|w
argument_list|)
expr_stmt|;
goto|goto
name|update
goto|;
block|}
else|else
goto|goto
name|cancel
goto|;
block|}
elseif|else
if|if
condition|(
name|point
operator|==
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|must_finish
condition|)
return|return;
goto|goto
name|update
goto|;
block|}
else|else
block|{
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|tlbufpos
argument_list|,
literal|0
argument_list|,
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
argument_list|,
name|point
argument_list|,
literal|2
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
argument_list|,
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|vpos
operator|<
literal|1
condition|)
block|{
name|cursor_hpos
operator|=
name|max
argument_list|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
argument_list|,
name|pos
operator|.
name|hpos
argument_list|)
expr_stmt|;
name|cursor_vpos
operator|=
name|this_line_vpos
expr_stmt|;
goto|goto
name|update
goto|;
block|}
else|else
goto|goto
name|cancel
goto|;
block|}
name|cancel
label|:
comment|/* Text changed drastically or point moved off of line */
name|cancel_line
argument_list|(
name|this_line_vpos
argument_list|)
expr_stmt|;
block|}
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|all_windows
condition|)
name|redisplay_all_windows
argument_list|()
expr_stmt|;
else|else
block|{
name|redisplay_window
argument_list|(
name|selected_window
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|!=
name|screen_width
condition|)
name|preserve_other_columns
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|update
label|:
comment|/* Prevent various kinds of signals during display update.      stdio is not robust about handling signals,      which can cause an apparent I/O error.  */
if|if
condition|(
name|interrupt_input
condition|)
name|unrequest_sigio
argument_list|()
expr_stmt|;
name|stop_polling
argument_list|()
expr_stmt|;
name|pause
operator|=
name|update_screen
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If screen does not match, prevent doing single-line-update next time.      Also, don't forget to check every line to update the arrow.  */
if|if
condition|(
name|pause
condition|)
block|{
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|last_arrow_position
argument_list|)
condition|)
block|{
name|last_arrow_position
operator|=
name|Qt
expr_stmt|;
name|last_arrow_string
operator|=
name|Qt
expr_stmt|;
block|}
comment|/* If we pause after scrolling, some lines in PhysScreen may be null 	 and then preserve_other_columns won't be able to preserve all 	 the vertical-bar separators.  So avoid using it in that case.  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|!=
name|screen_width
condition|)
name|update_mode_lines
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now text on screen agrees with windows, so      put info into the windows for partial redisplay to follow */
if|if
condition|(
operator|!
name|pause
condition|)
block|{
name|struct
name|buffer
modifier|*
name|b
init|=
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
decl_stmt|;
name|blank_end_of_window
operator|=
literal|0
expr_stmt|;
name|clip_changed
operator|=
literal|0
expr_stmt|;
name|unchanged_modified
operator|=
name|BUF_MODIFF
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|beg_unchanged
operator|=
name|BUF_GPT
argument_list|(
name|b
argument_list|)
operator|-
name|BUF_BEG
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|end_unchanged
operator|=
name|BUF_Z
argument_list|(
name|b
argument_list|)
operator|-
name|BUF_GPT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point
argument_list|)
operator|=
name|BUF_PT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point_x
argument_list|)
operator|=
name|cursor_hpos
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point_y
argument_list|)
operator|=
name|cursor_vpos
expr_stmt|;
if|if
condition|(
name|all_windows
condition|)
name|mark_window_display_accurate
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|w
operator|->
name|update_mode_line
operator|=
name|Qnil
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
name|BUF_MODIFF
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|w
operator|->
name|window_end_valid
operator|=
name|Qt
expr_stmt|;
name|last_arrow_position
operator|=
name|Voverlay_arrow_position
expr_stmt|;
name|last_arrow_string
operator|=
name|Voverlay_arrow_string
expr_stmt|;
block|}
name|update_mode_lines
operator|=
literal|0
expr_stmt|;
name|windows_or_buffers_changed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start SIGIO interrupts coming again.      Having them off during the code above      makes it less likely one will discard output,      but not impossible, since there might be stuff      in the system buffer here.      But it is much hairier to try to do anything about that.  */
if|if
condition|(
name|interrupt_input
condition|)
name|request_sigio
argument_list|()
expr_stmt|;
name|start_polling
argument_list|()
expr_stmt|;
name|do_pending_window_change
argument_list|()
expr_stmt|;
if|if
condition|(
name|screen_garbaged
condition|)
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Redisplay, but leave alone any recent echo area message    unless another message has been requested in its place.  */
end_comment

begin_macro
name|redisplay_preserve_echo_area
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|echo_area_contents
operator|==
literal|0
operator|&&
name|prev_echo_area_contents
operator|!=
literal|0
condition|)
block|{
name|echo_area_contents
operator|=
name|prev_echo_area_contents
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
name|echo_area_contents
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|mark_window_display_accurate
argument_list|(
argument|window
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
decl_stmt|;
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|window
argument_list|)
condition|;
name|window
operator|=
name|w
operator|->
name|next
control|)
block|{
name|w
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
operator|!
name|flag
condition|?
literal|0
else|:
name|BUF_MODIFF
argument_list|(
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|window_end_valid
operator|=
name|Qt
expr_stmt|;
name|w
operator|->
name|update_mode_line
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
condition|)
name|mark_window_display_accurate
argument_list|(
name|w
operator|->
name|vchild
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
condition|)
name|mark_window_display_accurate
argument_list|(
name|w
operator|->
name|hchild
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
block|{
name|last_arrow_position
operator|=
name|Voverlay_arrow_position
expr_stmt|;
name|last_arrow_string
operator|=
name|Voverlay_arrow_string
expr_stmt|;
block|}
else|else
block|{
comment|/* t is unequal to any useful value of Voverlay_arrow_... */
name|last_arrow_position
operator|=
name|Qt
expr_stmt|;
name|last_arrow_string
operator|=
name|Qt
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|int
name|do_id
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do full redisplay of one or all windows.   This does not include updating the screen;   just generating lines to pass to update_screen.  */
end_comment

begin_comment
comment|/* Entry point to redisplay all windows */
end_comment

begin_macro
name|redisplay_all_windows
argument_list|()
end_macro

begin_block
block|{
name|buffer_shared
operator|=
literal|0
expr_stmt|;
name|redisplay_windows
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|redisplay_windows
argument_list|(
argument|window
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|window
argument_list|)
condition|;
name|window
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|next
control|)
name|redisplay_window
argument_list|(
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|redisplay_window
argument_list|(
argument|window
argument_list|,
argument|just_this_one
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|just_this_one
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|int
name|height
decl_stmt|;
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
specifier|register
name|int
name|width
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
decl_stmt|;
specifier|register
name|int
name|startp
decl_stmt|;
specifier|register
name|int
name|hscroll
init|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
decl_stmt|;
name|struct
name|position
name|pos
decl_stmt|;
name|int
name|opoint
decl_stmt|;
name|int
name|tem
decl_stmt|;
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Some bug zeros some core */
comment|/* If this is a combination window, do its children; that's all.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
condition|)
block|{
name|redisplay_windows
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
condition|)
block|{
name|redisplay_windows
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|update_mode_lines
condition|)
name|w
operator|->
name|update_mode_line
operator|=
name|Qt
expr_stmt|;
comment|/* Otherwise set up data on this window; select its buffer and point value */
name|height
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
condition|)
name|height
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|echo_area_contents
condition|)
return|return
literal|0
return|;
name|current_buffer
operator|=
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|just_this_one
operator|&&
name|current_buffer
operator|==
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
condition|)
name|buffer_shared
operator|++
expr_stmt|;
comment|/* Go temporarily to where point is in the window being displayed.      We will restore point at the end.  */
name|opoint
operator|=
name|point
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
condition|)
block|{
name|SET_PT
argument_list|(
name|marker_position
argument_list|(
name|w
operator|->
name|pointm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<
name|BEGV
condition|)
name|point
operator|=
name|BEGV
expr_stmt|;
elseif|else
if|if
condition|(
name|point
operator|>
name|ZV
condition|)
name|point
operator|=
name|ZV
expr_stmt|;
block|}
comment|/* If window-start is screwed up, choose a new one.  */
if|if
condition|(
name|XMARKER
argument_list|(
name|w
operator|->
name|start
argument_list|)
operator|->
name|buffer
operator|!=
name|current_buffer
condition|)
goto|goto
name|recenter
goto|;
name|startp
operator|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* Handle case where place to start displaying has been specified */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|force_start
argument_list|)
condition|)
block|{
name|w
operator|->
name|update_mode_line
operator|=
name|Qt
expr_stmt|;
name|w
operator|->
name|force_start
operator|=
name|Qnil
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
name|try_window
argument_list|(
name|window
argument_list|,
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_vpos
operator|<
literal|0
condition|)
block|{
comment|/* If point does not appear, move point so it does appear */
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|startp
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
name|startp
operator|==
literal|1
operator|)
condition|?
name|minibuf_prompt_width
else|:
literal|0
operator|)
operator|+
operator|(
name|hscroll
condition|?
literal|1
operator|-
name|hscroll
else|:
literal|0
operator|)
argument_list|,
name|ZV
argument_list|,
name|height
operator|/
literal|2
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|startp
argument_list|)
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|pos
operator|.
name|bufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
condition|)
name|Fset_marker
argument_list|(
name|w
operator|->
name|pointm
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
comment|/* We want to change point permanently, 	       so don't restore the old value.  */
name|opoint
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
condition|)
block|{
name|cursor_hpos
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|pos
operator|.
name|hpos
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|cursor_vpos
operator|=
name|pos
operator|.
name|vpos
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
comment|/* Handle case where text has not changed, only point,      and it has not moved off the screen */
comment|/* This code is not used for minibuffer for the sake of      the case of redisplaying to replace an echo area message;      since in that case the minibuffer contents per se are usually unchanged.      This code is of no real use in the minibuffer since      the handling of this_line_bufpos, etc.,      in redisplay handles the same cases.  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|>=
name|MODIFF
operator|&&
name|point
operator|>=
name|startp
operator|&&
operator|!
name|clip_changed
operator|&&
operator|(
name|just_this_one
operator|||
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|==
name|screen_width
operator|)
operator|&&
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
block|{
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|startp
argument_list|,
literal|0
argument_list|,
operator|(
name|hscroll
condition|?
literal|1
operator|-
name|hscroll
else|:
literal|0
operator|)
argument_list|,
name|point
argument_list|,
name|height
operator|+
literal|1
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|startp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|vpos
operator|<
name|height
condition|)
block|{
comment|/* Ok, point is still on screen */
if|if
condition|(
name|w
operator|==
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
condition|)
block|{
comment|/* These variables are supposed to be origin 1 */
name|cursor_hpos
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|pos
operator|.
name|hpos
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|cursor_vpos
operator|=
name|pos
operator|.
name|vpos
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
comment|/* This doesn't do the trick, because if a window to the right of  this one must be redisplayed, this does nothing because there  is nothing in DesiredScreen yet, and then the other window is  redisplayed, making likes that are empty in this window's columns. 	  if (XFASTINT (w->width) != screen_width) 	    preserve_my_columns (w); */
goto|goto
name|done
goto|;
block|}
comment|/* Don't bother trying redisplay with same start; 	we already know it will lose */
block|}
comment|/* If current starting point was originally the beginning of a line      but no longer is, find a new starting point.  */
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|start_at_line_beg
argument_list|)
operator|&&
operator|!
operator|(
name|startp
operator|==
name|BEGV
operator|||
name|FETCH_CHAR
argument_list|(
name|startp
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
operator|)
condition|)
block|{
goto|goto
name|recenter
goto|;
block|}
elseif|else
if|if
condition|(
name|just_this_one
operator|&&
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
name|point
operator|>=
name|startp
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|w
operator|->
name|window_end_valid
argument_list|,
name|Qnil
argument_list|)
operator|&&
name|do_id
operator|&&
operator|!
name|clip_changed
operator|&&
operator|!
name|blank_end_of_window
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|==
name|screen_width
operator|&&
name|EQ
argument_list|(
name|last_arrow_position
argument_list|,
name|Voverlay_arrow_position
argument_list|)
operator|&&
name|EQ
argument_list|(
name|last_arrow_string
argument_list|,
name|Voverlay_arrow_string
argument_list|)
operator|&&
operator|(
name|tem
operator|=
name|try_window_id
argument_list|(
name|selected_window
argument_list|)
operator|)
operator|&&
name|tem
operator|!=
operator|-
literal|2
condition|)
block|{
comment|/* tem> 0 means success.  tem == -1 means choose new start. 	 tem == -2 means try again with same start, 	  and nothing but whitespace follows the changed stuff. 	 tem == 0 means try again with same start.  */
if|if
condition|(
name|tem
operator|>
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|startp
operator|>=
name|BEGV
operator|&&
name|startp
operator|<=
name|ZV
comment|/* Avoid starting display at end of buffer! */
operator|&&
operator|(
name|startp
operator|<
name|ZV
operator|||
name|startp
operator|==
name|BEGV
operator|||
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|>=
name|MODIFF
operator|)
operator|)
condition|)
block|{
comment|/* Try to redisplay starting at same place as before */
comment|/* If point has not moved off screen, accept the results */
name|try_window
argument_list|(
name|window
argument_list|,
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_vpos
operator|>=
literal|0
condition|)
goto|goto
name|done
goto|;
else|else
name|cancel_my_columns
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|update_mode_line
operator|=
name|Qt
expr_stmt|;
comment|/* Try to scroll by specified few lines */
if|if
condition|(
name|scroll_step
operator|&&
operator|!
name|clip_changed
condition|)
block|{
if|if
condition|(
name|point
operator|>
name|startp
condition|)
block|{
name|pos
operator|=
operator|*
name|vmotion
argument_list|(
name|Z
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
argument_list|,
name|scroll_step
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|vpos
operator|>=
name|height
condition|)
goto|goto
name|scroll_fail
goto|;
block|}
name|pos
operator|=
operator|*
name|vmotion
argument_list|(
name|startp
argument_list|,
name|point
operator|<
name|startp
condition|?
operator|-
name|scroll_step
else|:
name|scroll_step
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|>=
name|pos
operator|.
name|bufpos
condition|)
block|{
name|try_window
argument_list|(
name|window
argument_list|,
name|pos
operator|.
name|bufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_vpos
operator|>=
literal|0
condition|)
goto|goto
name|done
goto|;
else|else
name|cancel_my_columns
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|scroll_fail
label|:
empty_stmt|;
block|}
comment|/* Finally, just choose place to start which centers point */
name|recenter
label|:
name|pos
operator|=
operator|*
name|vmotion
argument_list|(
name|point
argument_list|,
operator|-
name|height
operator|/
literal|2
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
name|try_window
argument_list|(
name|window
argument_list|,
name|pos
operator|.
name|bufpos
argument_list|)
expr_stmt|;
name|startp
operator|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
expr_stmt|;
name|w
operator|->
name|start_at_line_beg
operator|=
operator|(
name|startp
operator|==
name|BEGV
operator|||
name|FETCH_CHAR
argument_list|(
name|startp
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
operator|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
name|done
label|:
comment|/* If window not full width, must redo its mode line      if the window to its side is being redone */
if|if
condition|(
operator|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|update_mode_line
argument_list|)
operator|||
operator|(
operator|!
name|just_this_one
operator|&&
name|width
operator|<
name|screen_width
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
name|display_mode_line
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
name|current_buffer
operator|=
name|old
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Do full redisplay on one window,    starting at position `pos'.  */
end_comment

begin_macro
name|try_window
argument_list|(
argument|window
argument_list|,
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|height
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|-
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|vpos
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
decl_stmt|;
specifier|register
name|int
name|last_text_vpos
init|=
name|vpos
decl_stmt|;
name|int
name|tab_offset
init|=
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|struct
name|position
name|val
decl_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
name|pos
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|point_vpos
operator|=
operator|-
literal|1
expr_stmt|;
name|val
operator|.
name|hpos
operator|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|height
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
operator|*
name|display_text_line
argument_list|(
name|w
argument_list|,
name|pos
argument_list|,
name|vpos
argument_list|,
name|val
operator|.
name|hpos
argument_list|,
name|tab_offset
argument_list|)
expr_stmt|;
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|vpos
condition|)
name|tab_offset
operator|=
literal|0
expr_stmt|;
name|vpos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|val
operator|.
name|bufpos
condition|)
name|last_text_vpos
comment|/* Next line, unless prev line ended in end of buffer with no cr */
operator|=
name|vpos
operator|-
operator|(
name|val
operator|.
name|vpos
operator|&&
name|FETCH_CHAR
argument_list|(
name|val
operator|.
name|bufpos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|)
expr_stmt|;
name|pos
operator|=
name|val
operator|.
name|bufpos
expr_stmt|;
block|}
comment|/* If last line is continued in middle of character,      include the split character in the text considered on the screen */
if|if
condition|(
name|val
operator|.
name|hpos
operator|<
operator|(
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
operator|)
condition|)
name|pos
operator|++
expr_stmt|;
comment|/* Say where last char on screen will be, once redisplay is finished.  */
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|=
name|Z
operator|-
name|pos
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|=
name|last_text_vpos
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
expr_stmt|;
comment|/* But that is not valid info until redisplay finishes.  */
name|w
operator|->
name|window_end_valid
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Try to redisplay when buffer is modified locally,  computing insert/delete line to preserve text outside  the bounds of the changes.  Return 1 if successful, 0 if if cannot tell what to do,  or -1 to tell caller to find a new window start,  or -2 to tell caller to do normal redisplay with same window start.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|position
name|debug_bp
decl_stmt|,
name|debug_ep
decl_stmt|,
name|debug_xp
decl_stmt|,
name|debug_pp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_start_vpos
decl_stmt|,
name|debug_stop_vpos
decl_stmt|,
name|debug_scroll_amount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_dont_scroll
decl_stmt|;
end_decl_stmt

begin_macro
name|try_window_id
argument_list|(
argument|window
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pos
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|height
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|-
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
decl_stmt|;
name|int
name|top
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
decl_stmt|;
name|int
name|start
init|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
decl_stmt|;
name|int
name|hscroll
init|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
decl_stmt|;
name|int
name|lmargin
init|=
name|hscroll
operator|>
literal|0
condition|?
literal|1
operator|-
name|hscroll
else|:
literal|0
decl_stmt|;
specifier|register
name|int
name|vpos
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|last_text_vpos
init|=
literal|0
decl_stmt|;
name|int
name|stop_vpos
decl_stmt|;
name|struct
name|position
name|val
decl_stmt|,
name|bp
decl_stmt|,
name|ep
decl_stmt|,
name|xp
decl_stmt|,
name|pp
decl_stmt|;
name|int
name|scroll_amount
init|=
literal|0
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|int
name|tab_offset
decl_stmt|,
name|epto
decl_stmt|;
if|if
condition|(
name|GPT
operator|-
name|BEG
operator|<
name|beg_unchanged
condition|)
name|beg_unchanged
operator|=
name|GPT
operator|-
name|BEG
expr_stmt|;
if|if
condition|(
name|Z
operator|-
name|GPT
operator|<
name|end_unchanged
condition|)
name|end_unchanged
operator|=
name|Z
operator|-
name|GPT
expr_stmt|;
if|if
condition|(
name|beg_unchanged
operator|+
literal|1
operator|<
name|start
condition|)
return|return
literal|0
return|;
comment|/* Give up if changes go above top of window */
comment|/* Find position before which nothing is changed.  */
name|bp
operator|=
operator|*
name|compute_motion
argument_list|(
name|start
argument_list|,
literal|0
argument_list|,
name|lmargin
argument_list|,
name|beg_unchanged
operator|+
literal|1
argument_list|,
literal|10000
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|.
name|vpos
operator|>=
name|height
condition|)
return|return
name|point
operator|<
name|bp
operator|.
name|bufpos
operator|&&
operator|!
name|bp
operator|.
name|contin
return|;
name|vpos
operator|=
name|bp
operator|.
name|vpos
expr_stmt|;
comment|/* Find beginning of that screen line.  Must display from there.  */
name|bp
operator|=
operator|*
name|vmotion
argument_list|(
name|bp
operator|.
name|bufpos
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
name|pos
operator|=
name|bp
operator|.
name|bufpos
expr_stmt|;
name|val
operator|.
name|hpos
operator|=
name|lmargin
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|start
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If about to start displaying at the beginning of a continuation line,      really start with previous screen line, in case it was not      continued when last redisplayed */
if|if
condition|(
name|bp
operator|.
name|contin
operator|&&
name|bp
operator|.
name|bufpos
operator|-
literal|1
operator|==
name|beg_unchanged
operator|&&
name|vpos
operator|>
literal|0
condition|)
block|{
name|bp
operator|=
operator|*
name|vmotion
argument_list|(
name|bp
operator|.
name|bufpos
argument_list|,
operator|-
literal|1
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
operator|--
name|vpos
expr_stmt|;
name|pos
operator|=
name|bp
operator|.
name|bufpos
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|.
name|contin
operator|&&
name|bp
operator|.
name|hpos
operator|!=
name|lmargin
condition|)
block|{
name|val
operator|.
name|hpos
operator|=
name|bp
operator|.
name|prevhpos
operator|-
name|width
operator|+
name|lmargin
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
name|bp
operator|.
name|vpos
operator|=
name|vpos
expr_stmt|;
comment|/* Find first visible newline after which no more is changed.  */
name|tem
operator|=
name|find_next_newline
argument_list|(
name|Z
operator|-
name|max
argument_list|(
name|end_unchanged
argument_list|,
name|Z
operator|-
name|ZV
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
operator|==
name|Lisp_Int
operator|&&
name|XINT
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
operator|>
literal|0
condition|)
while|while
condition|(
name|tem
operator|<
name|ZV
operator|-
literal|1
operator|&&
operator|(
name|position_indentation
argument_list|(
name|tem
argument_list|)
operator|>=
name|XINT
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
operator|)
condition|)
name|tem
operator|=
name|find_next_newline
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the cursor position after that newline.  */
name|ep
operator|=
operator|*
name|compute_motion
argument_list|(
name|pos
argument_list|,
name|vpos
argument_list|,
name|val
operator|.
name|hpos
argument_list|,
name|tem
argument_list|,
name|height
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|bp
operator|.
name|bufpos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If changes reach past the text available on the screen,      just display rest of screen.  */
if|if
condition|(
name|ep
operator|.
name|bufpos
operator|>
name|Z
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
condition|)
name|stop_vpos
operator|=
name|height
expr_stmt|;
else|else
name|stop_vpos
operator|=
name|ep
operator|.
name|vpos
expr_stmt|;
comment|/* If no newline before ep, the line ep is on includes some changes      that must be displayed.  Make sure we don't stop before it.  */
comment|/* Also, if changes reach all the way until ep.bufpos,      it is possible that something was deleted after the      newline before it, so the following line must be redrawn. */
if|if
condition|(
name|stop_vpos
operator|==
name|ep
operator|.
name|vpos
operator|&&
operator|(
name|ep
operator|.
name|bufpos
operator|==
name|BEGV
operator|||
name|FETCH_CHAR
argument_list|(
name|ep
operator|.
name|bufpos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|||
name|ep
operator|.
name|bufpos
operator|==
name|Z
operator|-
name|end_unchanged
operator|)
condition|)
name|stop_vpos
operator|=
name|ep
operator|.
name|vpos
operator|+
literal|1
expr_stmt|;
name|point_vpos
operator|=
operator|-
literal|1
expr_stmt|;
name|debug_dont_scroll
operator|=
literal|0
expr_stmt|;
comment|/* If changes do not reach to bottom of window,      figure out how much to scroll the rest of the window */
if|if
condition|(
name|stop_vpos
operator|<
name|height
condition|)
block|{
comment|/* Now determine how far up or down the rest of the window has moved */
name|epto
operator|=
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|ep
operator|.
name|bufpos
argument_list|)
expr_stmt|;
name|xp
operator|=
operator|*
name|compute_motion
argument_list|(
name|ep
operator|.
name|bufpos
argument_list|,
name|ep
operator|.
name|vpos
argument_list|,
name|ep
operator|.
name|hpos
argument_list|,
name|Z
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
argument_list|,
literal|10000
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|epto
argument_list|)
expr_stmt|;
name|scroll_amount
operator|=
name|xp
operator|.
name|vpos
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
expr_stmt|;
comment|/* Is everything on screen below the changes whitespace? 	 If so, no scrolling is really necessary.  */
for|for
control|(
name|i
operator|=
name|ep
operator|.
name|bufpos
init|;
name|i
operator|<
name|xp
operator|.
name|bufpos
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|FETCH_CHAR
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|' '
operator|&&
name|tem
operator|!=
literal|'\n'
operator|&&
name|tem
operator|!=
literal|'\t'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|xp
operator|.
name|bufpos
condition|)
return|return
operator|-
literal|2
return|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|+=
name|scroll_amount
expr_stmt|;
comment|/* Before doing any scrolling, verify that point will be on screen. */
if|if
condition|(
name|point
operator|>
name|ep
operator|.
name|bufpos
operator|&&
operator|!
operator|(
name|point
operator|<=
name|xp
operator|.
name|bufpos
operator|&&
name|xp
operator|.
name|bufpos
operator|<
name|height
operator|)
condition|)
block|{
if|if
condition|(
name|point
operator|<=
name|xp
operator|.
name|bufpos
condition|)
block|{
name|pp
operator|=
operator|*
name|compute_motion
argument_list|(
name|ep
operator|.
name|bufpos
argument_list|,
name|ep
operator|.
name|vpos
argument_list|,
name|ep
operator|.
name|hpos
argument_list|,
name|point
argument_list|,
name|height
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|epto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|=
operator|*
name|compute_motion
argument_list|(
name|xp
operator|.
name|bufpos
argument_list|,
name|xp
operator|.
name|vpos
argument_list|,
name|xp
operator|.
name|hpos
argument_list|,
name|point
argument_list|,
name|height
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|xp
operator|.
name|bufpos
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|.
name|bufpos
operator|<
name|point
operator|||
name|pp
operator|.
name|vpos
operator|==
name|height
condition|)
return|return
literal|0
return|;
name|point_vpos
operator|=
name|pp
operator|.
name|vpos
operator|+
name|top
expr_stmt|;
name|point_hpos
operator|=
name|pp
operator|.
name|hpos
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop_vpos
operator|-
name|scroll_amount
operator|>=
name|height
operator|||
name|ep
operator|.
name|bufpos
operator|==
name|xp
operator|.
name|bufpos
condition|)
block|{
if|if
condition|(
name|scroll_amount
operator|<
literal|0
condition|)
name|stop_vpos
operator|-=
name|scroll_amount
expr_stmt|;
name|scroll_amount
operator|=
literal|0
expr_stmt|;
name|debug_dont_scroll
operator|=
literal|1
expr_stmt|;
comment|/* In this path, we have altered window_end_vpos 	     and not left it negative. 	     We must make sure that, in case display is preempted 	     before the screen changes to reflect what we do here, 	     further updates will not come to try_window_id 	     and assume the screen and window_end_vpos match.  */
name|blank_end_of_window
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|scroll_amount
condition|)
block|{}
elseif|else
if|if
condition|(
name|bp
operator|.
name|bufpos
operator|==
name|Z
operator|-
name|end_unchanged
condition|)
block|{
comment|/* If reprinting everything is nearly as fast as scrolling, 	     don't bother scrolling.  Can happen if lines are short.  */
if|if
condition|(
name|scroll_cost
argument_list|(
name|bp
operator|.
name|vpos
operator|+
name|top
operator|-
name|scroll_amount
argument_list|,
name|top
operator|+
name|height
operator|-
name|max
argument_list|(
literal|0
argument_list|,
name|scroll_amount
argument_list|)
argument_list|,
name|scroll_amount
argument_list|)
operator|>
name|xp
operator|.
name|bufpos
operator|-
name|bp
operator|.
name|bufpos
operator|-
literal|20
condition|)
comment|/* Return "try normal display with same window-start." 	       Too bad we can't prevent further scroll-thinking.  */
return|return
operator|-
literal|2
return|;
comment|/* If pure deletion, scroll up as many lines as possible. 	     In common case of killing a line, this can save the 	     following line from being overwritten by scrolling 	     and therefore having to be redrawn.  */
name|tem
operator|=
name|scroll_screen_lines
argument_list|(
name|bp
operator|.
name|vpos
operator|+
name|top
operator|-
name|scroll_amount
argument_list|,
name|top
operator|+
name|height
operator|-
name|max
argument_list|(
literal|0
argument_list|,
name|scroll_amount
argument_list|)
argument_list|,
name|scroll_amount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|stop_vpos
operator|=
name|height
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scroll_amount
condition|)
block|{
comment|/* If reprinting everything is nearly as fast as scrolling, 	     don't bother scrolling.  Can happen if lines are short.  */
comment|/* Note that if scroll_amount> 0, xp.bufpos - bp.bufpos is an 	     overestimate of cost of reprinting, since xp.bufpos 	     would end up below the bottom of the window.  */
if|if
condition|(
name|scroll_cost
argument_list|(
name|ep
operator|.
name|vpos
operator|+
name|top
operator|-
name|scroll_amount
argument_list|,
name|top
operator|+
name|height
operator|-
name|max
argument_list|(
literal|0
argument_list|,
name|scroll_amount
argument_list|)
argument_list|,
name|scroll_amount
argument_list|)
operator|>
name|xp
operator|.
name|bufpos
operator|-
name|ep
operator|.
name|bufpos
operator|-
literal|20
condition|)
comment|/* Return "try normal display with same window-start." 	       Too bad we can't prevent further scroll-thinking.  */
return|return
operator|-
literal|2
return|;
name|tem
operator|=
name|scroll_screen_lines
argument_list|(
name|ep
operator|.
name|vpos
operator|+
name|top
operator|-
name|scroll_amount
argument_list|,
name|top
operator|+
name|height
operator|-
name|max
argument_list|(
literal|0
argument_list|,
name|scroll_amount
argument_list|)
argument_list|,
name|scroll_amount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|stop_vpos
operator|=
name|height
expr_stmt|;
block|}
block|}
name|debug_scroll_amount
operator|=
name|scroll_amount
expr_stmt|;
name|debug_bp
operator|=
name|bp
expr_stmt|;
name|debug_ep
operator|=
name|ep
expr_stmt|;
name|debug_xp
operator|=
name|xp
expr_stmt|;
name|debug_pp
operator|=
name|pp
expr_stmt|;
comment|/* In any case, do not display past bottom of window */
if|if
condition|(
name|stop_vpos
operator|>=
name|height
condition|)
block|{
name|stop_vpos
operator|=
name|height
expr_stmt|;
name|scroll_amount
operator|=
literal|0
expr_stmt|;
block|}
name|debug_stop_vpos
operator|=
name|stop_vpos
expr_stmt|;
name|debug_start_vpos
operator|=
name|vpos
expr_stmt|;
comment|/* Handle case where pos is before w->start --      can happen if part of line had been clipped and is not clipped now */
if|if
condition|(
name|vpos
operator|==
literal|0
operator|&&
name|pos
operator|<
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
condition|)
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
name|pos
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
comment|/* Redisplay the lines where the text was changed */
name|last_text_vpos
operator|=
name|vpos
expr_stmt|;
name|tab_offset
operator|=
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|hpos
operator|+
name|hscroll
operator|-
operator|(
name|hscroll
operator|>
literal|0
operator|)
operator|<
literal|0
condition|)
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|vpos
operator|<
name|stop_vpos
condition|)
block|{
name|val
operator|=
operator|*
name|display_text_line
argument_list|(
name|w
argument_list|,
name|pos
argument_list|,
name|top
operator|+
name|vpos
operator|++
argument_list|,
name|val
operator|.
name|hpos
argument_list|,
name|tab_offset
argument_list|)
expr_stmt|;
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|vpos
condition|)
name|tab_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|val
operator|.
name|bufpos
condition|)
name|last_text_vpos
comment|/* Next line, unless prev line ended in end of buffer with no cr */
operator|=
name|vpos
operator|-
operator|(
name|val
operator|.
name|vpos
operator|&&
name|FETCH_CHAR
argument_list|(
name|val
operator|.
name|bufpos
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|)
expr_stmt|;
name|pos
operator|=
name|val
operator|.
name|bufpos
expr_stmt|;
block|}
comment|/* There are two cases:      1) we have displayed down to the bottom of the window      2) we have scrolled lines below stop_vpos by scroll_amount  */
if|if
condition|(
name|vpos
operator|==
name|height
condition|)
block|{
comment|/* If last line is continued in middle of character, 	 include the split character in the text considered on the screen */
if|if
condition|(
name|val
operator|.
name|hpos
operator|<
name|lmargin
condition|)
name|val
operator|.
name|bufpos
operator|++
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|=
name|last_text_vpos
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|=
name|Z
operator|-
name|val
operator|.
name|bufpos
expr_stmt|;
block|}
comment|/* If scrolling made blank lines at window bottom,      redisplay to fill those lines */
if|if
condition|(
name|scroll_amount
operator|<
literal|0
condition|)
block|{
name|vpos
operator|=
name|xp
operator|.
name|vpos
expr_stmt|;
name|pos
operator|=
name|xp
operator|.
name|bufpos
expr_stmt|;
name|val
operator|.
name|hpos
operator|=
name|lmargin
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|ZV
condition|)
name|vpos
operator|=
name|height
operator|+
name|scroll_amount
expr_stmt|;
elseif|else
if|if
condition|(
name|xp
operator|.
name|contin
operator|&&
name|xp
operator|.
name|hpos
operator|!=
name|lmargin
condition|)
block|{
name|val
operator|.
name|hpos
operator|=
name|xp
operator|.
name|prevhpos
operator|-
name|width
operator|+
name|lmargin
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
name|blank_end_of_window
operator|=
literal|1
expr_stmt|;
name|tab_offset
operator|=
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|hpos
operator|<
literal|0
condition|)
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|vpos
operator|<
name|height
condition|)
block|{
name|val
operator|=
operator|*
name|display_text_line
argument_list|(
name|w
argument_list|,
name|pos
argument_list|,
name|top
operator|+
name|vpos
operator|++
argument_list|,
name|val
operator|.
name|hpos
argument_list|,
name|tab_offset
argument_list|)
expr_stmt|;
name|tab_offset
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|vpos
condition|)
name|tab_offset
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|val
operator|.
name|bufpos
expr_stmt|;
block|}
comment|/* Here is a case where display_text_line sets point_vpos wrong. 	 Make it be fixed up, below.  */
if|if
condition|(
name|xp
operator|.
name|bufpos
operator|==
name|ZV
operator|&&
name|xp
operator|.
name|bufpos
operator|==
name|point
condition|)
name|point_vpos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Attempt to adjust end-of-text positions to new bottom line */
if|if
condition|(
name|scroll_amount
condition|)
block|{
name|delta
operator|=
name|height
operator|-
name|xp
operator|.
name|vpos
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
operator|||
operator|(
name|delta
operator|>
literal|0
operator|&&
name|xp
operator|.
name|bufpos
operator|<
name|ZV
operator|)
operator|||
operator|(
name|delta
operator|==
literal|0
operator|&&
name|xp
operator|.
name|hpos
operator|)
condition|)
block|{
name|val
operator|=
operator|*
name|vmotion
argument_list|(
name|Z
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
argument_list|,
name|delta
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|window
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|=
name|Z
operator|-
name|val
operator|.
name|bufpos
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|+=
name|val
operator|.
name|vpos
expr_stmt|;
block|}
block|}
name|w
operator|->
name|window_end_valid
operator|=
name|Qnil
expr_stmt|;
comment|/* If point was not in a line that was displayed, find it */
if|if
condition|(
name|point_vpos
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|*
name|compute_motion
argument_list|(
name|start
argument_list|,
literal|0
argument_list|,
name|lmargin
argument_list|,
name|point
argument_list|,
literal|10000
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Admit failure if point is off screen now */
if|if
condition|(
name|val
operator|.
name|vpos
operator|>=
name|height
condition|)
block|{
for|for
control|(
name|vpos
operator|=
literal|0
init|;
name|vpos
operator|<
name|height
condition|;
name|vpos
operator|++
control|)
name|cancel_line
argument_list|(
name|vpos
operator|+
name|top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|point_vpos
operator|=
name|val
operator|.
name|vpos
operator|+
name|top
expr_stmt|;
name|point_hpos
operator|=
name|val
operator|.
name|hpos
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
name|cursor_hpos
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|point_hpos
argument_list|)
expr_stmt|;
name|cursor_vpos
operator|=
name|point_vpos
expr_stmt|;
if|if
condition|(
name|debug_end_pos
condition|)
block|{
name|val
operator|=
operator|*
name|compute_motion
argument_list|(
name|start
argument_list|,
literal|0
argument_list|,
name|lmargin
argument_list|,
name|ZV
argument_list|,
name|height
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos_tab_offset
argument_list|(
name|w
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|vpos
operator|!=
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|!=
name|Z
operator|-
name|val
operator|.
name|bufpos
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Display one line of window w, starting at position `start' in w's buffer.  Display starting at horizontal position `hpos',   which is normally zero or negative.   A negative value causes output up to hpos = 0 to be discarded.   This is done for negative hscroll, or when this is a continuation line   and the continuation occurred in the middle of a multi-column character.   `taboffset' is an offset for ostensible hpos, used in tab stop calculations.   Display on position `vpos' on the screen.  (origin 0).   Returns a `struct position' giving character to start next line with  and where to display it, including a zero or negative hpos.  The vpos field is not really a vpos; it is 1 unless the line is continued */
end_comment

begin_decl_stmt
name|struct
name|position
name|val_display_text_line
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|position
modifier|*
name|display_text_line
parameter_list|(
name|w
parameter_list|,
name|start
parameter_list|,
name|vpos
parameter_list|,
name|hpos
parameter_list|,
name|taboffset
parameter_list|)
name|struct
name|window
modifier|*
name|w
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|vpos
decl_stmt|;
name|int
name|hpos
decl_stmt|;
name|int
name|taboffset
decl_stmt|;
block|{
specifier|register
name|int
name|pos
init|=
name|start
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|end
decl_stmt|;
specifier|register
name|int
name|pause
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endp
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|startp
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1prev
decl_stmt|;
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|current_buffer
operator|->
name|tab_width
argument_list|)
decl_stmt|;
name|int
name|ctl_arrow
init|=
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|ctl_arrow
argument_list|)
decl_stmt|;
name|int
name|width
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
operator|)
decl_stmt|;
name|struct
name|position
name|val
decl_stmt|;
name|int
name|lastpos
decl_stmt|;
name|int
name|invis
decl_stmt|;
name|int
name|hscroll
init|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
decl_stmt|;
name|int
name|truncate
init|=
name|hscroll
operator|||
operator|(
name|truncate_partial_width_windows
operator|&&
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|<
name|screen_width
operator|)
operator|||
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|truncate_lines
argument_list|)
decl_stmt|;
name|int
name|selective
init|=
name|XTYPE
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
operator|==
name|Lisp_Int
condition|?
name|XINT
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
else|:
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|selective_e
init|=
name|selective
operator|&&
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|selective_display_ellipses
argument_list|)
decl_stmt|;
name|hpos
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|get_display_line
argument_list|(
name|vpos
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
operator|||
name|tab_width
operator|>
literal|20
condition|)
name|tab_width
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|&&
name|start
operator|==
literal|1
operator|&&
name|vpos
operator|==
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
condition|)
block|{
if|if
condition|(
name|minibuf_prompt
condition|)
name|hpos
operator|=
name|display_string
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
name|minibuf_prompt
argument_list|,
name|hpos
argument_list|,
operator|!
name|truncate
condition|?
literal|'\\'
else|:
literal|'$'
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|minibuf_prompt_width
operator|=
name|hpos
expr_stmt|;
block|}
name|p1
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|hpos
expr_stmt|;
name|end
operator|=
name|ZV
expr_stmt|;
name|startp
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|endp
operator|=
name|startp
operator|+
name|width
expr_stmt|;
comment|/* Loop generating characters.    Stop at end of buffer, before newline,    or if reach or pass continuation column.  */
name|pause
operator|=
name|pos
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|endp
condition|)
block|{
name|p1prev
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|pause
condition|)
block|{
if|if
condition|(
name|pos
operator|==
name|end
condition|)
break|break;
if|if
condition|(
name|pos
operator|==
name|point
operator|&&
name|point_vpos
operator|<
literal|0
condition|)
block|{
name|point_vpos
operator|=
name|vpos
expr_stmt|;
name|point_hpos
operator|=
name|p1
operator|-
name|startp
expr_stmt|;
block|}
name|pause
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|point
operator|&&
name|point
operator|<
name|pause
condition|)
name|pause
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|GPT
operator|&&
name|GPT
operator|<
name|pause
condition|)
name|pause
operator|=
name|GPT
expr_stmt|;
name|p
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
name|c
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|invis
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
operator|&&
name|selective
operator|>
literal|0
operator|&&
name|position_indentation
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|>=
name|selective
condition|)
block|{
name|invis
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|find_next_newline
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FETCH_CHAR
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
name|pos
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|invis
operator|&&
name|selective_e
condition|)
block|{
name|p1
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|p1
operator|-
name|startp
operator|>
name|width
condition|)
name|p1
operator|=
name|endp
expr_stmt|;
if|if
condition|(
name|p1prev
operator|>=
name|startp
condition|)
name|strncpy
argument_list|(
name|p1prev
argument_list|,
literal|" ..."
argument_list|,
name|p1
operator|-
name|p1prev
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
do|do
block|{
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
literal|' '
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|p1
operator|-
name|startp
operator|+
name|taboffset
operator|+
name|hscroll
operator|-
operator|(
name|hscroll
operator|>
literal|0
operator|)
operator|)
operator|%
name|tab_width
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|Ctl
argument_list|(
literal|'M'
argument_list|)
operator|&&
name|selective
operator|==
operator|-
literal|1
condition|)
block|{
name|pos
operator|=
name|find_next_newline
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FETCH_CHAR
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
name|pos
operator|--
expr_stmt|;
if|if
condition|(
name|selective_e
condition|)
block|{
name|p1
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|p1
operator|-
name|startp
operator|>
name|width
condition|)
name|p1
operator|=
name|endp
expr_stmt|;
if|if
condition|(
name|p1prev
operator|>=
name|startp
condition|)
name|strncpy
argument_list|(
name|p1prev
argument_list|,
literal|" ..."
argument_list|,
name|p1
operator|-
name|p1prev
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0200
operator|&&
name|ctl_arrow
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
literal|'^'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
name|c
operator|^
literal|0100
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
literal|'\\'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
operator|(
literal|7
operator|&
operator|(
name|c
operator|>>
literal|3
operator|)
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|startp
condition|)
operator|*
name|p1
operator|=
operator|(
literal|7
operator|&
name|c
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
name|val
operator|.
name|hpos
operator|=
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|hpos
condition|)
name|val
operator|.
name|hpos
operator|++
expr_stmt|;
name|val
operator|.
name|vpos
operator|=
literal|1
expr_stmt|;
name|lastpos
operator|=
name|pos
expr_stmt|;
comment|/* Handle continuation in middle of a character */
comment|/* by backing up over it */
if|if
condition|(
name|p1
operator|>
name|endp
condition|)
block|{
comment|/* Start the next line with that same character */
name|pos
operator|--
expr_stmt|;
comment|/* but at a negative hpos, to skip the columns output on this line.  */
name|val
operator|.
name|hpos
operator|+=
name|p1prev
operator|-
name|endp
expr_stmt|;
comment|/* Keep in this line everything up to the continuation column.  */
name|p1
operator|=
name|endp
expr_stmt|;
block|}
comment|/* Finish deciding which character to start the next line on,      and what hpos to start it at.      Also set `lastpos' to the last position which counts as "on this line"      for cursor-positioning.  */
if|if
condition|(
name|pos
operator|<
name|ZV
condition|)
block|{
if|if
condition|(
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|==
literal|'\n'
condition|)
comment|/* If stopped due to a newline, start next line after it */
name|pos
operator|++
expr_stmt|;
else|else
comment|/* Stopped due to right margin of window */
block|{
if|if
condition|(
name|truncate
condition|)
block|{
operator|*
name|p1
operator|++
operator|=
literal|'$'
expr_stmt|;
comment|/* Truncating => start next line after next newline, 		 and point is on this line if it is before the newline, 		 and skip none of first char of next line */
name|pos
operator|=
name|find_next_newline
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|.
name|hpos
operator|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
expr_stmt|;
name|lastpos
operator|=
name|pos
operator|-
operator|(
name|FETCH_CHAR
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p1
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|val
operator|.
name|vpos
operator|=
literal|0
expr_stmt|;
name|lastpos
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* If point is at eol or in invisible text at eol,      record its screen location now.  */
if|if
condition|(
name|start
operator|<=
name|point
operator|&&
name|point
operator|<=
name|lastpos
operator|&&
name|point_vpos
operator|<
literal|0
condition|)
block|{
name|point_vpos
operator|=
name|vpos
expr_stmt|;
name|point_hpos
operator|=
name|p1
operator|-
name|startp
expr_stmt|;
block|}
if|if
condition|(
name|point_vpos
operator|==
name|vpos
condition|)
block|{
if|if
condition|(
name|point_hpos
operator|<
literal|0
condition|)
name|point_hpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|point_hpos
operator|>
name|width
condition|)
name|point_hpos
operator|=
name|width
expr_stmt|;
name|point_hpos
operator|+=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
condition|)
block|{
name|cursor_vpos
operator|=
name|point_vpos
expr_stmt|;
name|cursor_hpos
operator|=
name|point_hpos
expr_stmt|;
comment|/* Line is not continued and did not start in middle of character */
if|if
condition|(
name|hpos
operator|==
operator|(
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
condition|?
literal|1
operator|-
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
else|:
literal|0
operator|)
operator|&&
name|val
operator|.
name|vpos
condition|)
block|{
name|this_line_bufpos
operator|=
name|start
expr_stmt|;
name|this_line_buffer
operator|=
name|current_buffer
expr_stmt|;
name|this_line_vpos
operator|=
name|point_vpos
expr_stmt|;
name|this_line_start_hpos
operator|=
name|hpos
expr_stmt|;
name|this_line_endpos
operator|=
name|Z
operator|-
name|lastpos
expr_stmt|;
block|}
else|else
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If hscroll and line not empty, insert truncation-at-left marker */
if|if
condition|(
name|hscroll
operator|&&
name|lastpos
operator|!=
name|start
condition|)
block|{
operator|*
name|startp
operator|=
literal|'$'
expr_stmt|;
if|if
condition|(
name|p1
operator|<=
name|startp
condition|)
name|p1
operator|=
name|startp
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|screen_width
condition|)
block|{
name|endp
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|<
name|startp
condition|)
name|p1
operator|=
name|startp
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|endp
condition|)
operator|*
name|p1
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|p1
operator|++
operator|=
literal|'|'
expr_stmt|;
block|}
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|max
argument_list|(
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
argument_list|,
name|p1
operator|-
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
argument_list|)
expr_stmt|;
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
index|[
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If the start of this line is the overlay arrow-position,      then put the arrow string into the display-line.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|Voverlay_arrow_position
argument_list|)
operator|==
name|Lisp_Marker
operator|&&
name|current_buffer
operator|==
name|XMARKER
argument_list|(
name|Voverlay_arrow_position
argument_list|)
operator|->
name|buffer
operator|&&
name|start
operator|==
name|marker_position
argument_list|(
name|Voverlay_arrow_position
argument_list|)
operator|&&
name|XTYPE
argument_list|(
name|Voverlay_arrow_string
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|XSTRING
argument_list|(
name|Voverlay_arrow_string
argument_list|)
operator|->
name|data
decl_stmt|;
name|int
name|len
init|=
name|XSTRING
argument_list|(
name|Voverlay_arrow_string
argument_list|)
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
condition|)
name|len
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|startp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|<
name|len
operator|+
name|startp
operator|-
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
condition|)
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|len
operator|+
name|startp
operator|-
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
block|}
name|val
operator|.
name|bufpos
operator|=
name|pos
expr_stmt|;
name|val_display_text_line
operator|=
name|val
expr_stmt|;
return|return
operator|&
name|val_display_text_line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Display the mode line for window w */
end_comment

begin_macro
name|display_mode_line
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|vpos
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|left
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
decl_stmt|;
specifier|register
name|int
name|right
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|left
decl_stmt|;
name|get_display_line
argument_list|(
name|vpos
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|display_mode_element
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
name|left
argument_list|,
literal|0
argument_list|,
name|right
argument_list|,
name|right
argument_list|,
name|current_buffer
operator|->
name|mode_line_format
argument_list|)
expr_stmt|;
comment|/* Make the mode line inverse video if the entire line      is made of mode lines.      I.e. if this window is full width,      or if it is the child of a full width window      (which implies that that window is split side-by-side      and the rest of this line is mode lines of the sibling windows).  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|==
name|screen_width
operator|||
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|w
operator|->
name|parent
argument_list|)
operator|->
name|width
argument_list|)
operator|==
name|screen_width
condition|)
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
operator|=
name|mode_line_inverse_video
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Contribute ELT to the mode line for window W.    How it translates into text depends on its data type.     LINE is the display-line that the mode line is being displayed in.     HPOS is the position (absolute on screen) where this element's text    should start.  The output is truncated automatically at the right    edge of window W.     DEPTH is the depth in recursion.  It is used to prevent    infinite recursion here.     MINENDCOL is the hpos before which the element may not end.    The element is padded at the right with spaces if nec    to reach this column.     MAXENDCOL is the hpos past which this element may not extend.    If MINENDCOL is> MAXENDCOL, MINENDCOL takes priority.    (This is necessary to make nested padding and truncation work.)     Returns the hpos of the end of the text generated by ELT.    The next element will receive that value as its HPOS arg,    so as to concatenate the elements.  */
end_comment

begin_function
name|int
name|display_mode_element
parameter_list|(
name|w
parameter_list|,
name|vpos
parameter_list|,
name|hpos
parameter_list|,
name|depth
parameter_list|,
name|minendcol
parameter_list|,
name|maxendcol
parameter_list|,
name|elt
parameter_list|)
name|struct
name|window
modifier|*
name|w
decl_stmt|;
name|int
name|vpos
decl_stmt|;
specifier|register
name|int
name|hpos
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|minendcol
decl_stmt|;
specifier|register
name|int
name|maxendcol
decl_stmt|;
specifier|register
name|Lisp_Object
name|elt
decl_stmt|;
block|{
name|tail_recurse
label|:
if|if
condition|(
name|depth
operator|>
literal|10
condition|)
goto|goto
name|invalid
goto|;
name|depth
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|elt
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_String
case|:
block|{
comment|/* A string: output it and check for %-constructs within it.  */
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|this
init|=
name|XSTRING
argument_list|(
name|elt
argument_list|)
operator|->
name|data
decl_stmt|;
while|while
condition|(
name|hpos
operator|<
name|maxendcol
operator|&&
operator|*
name|this
condition|)
block|{
name|unsigned
name|char
modifier|*
name|last
init|=
name|this
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|this
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'%'
condition|)
empty_stmt|;
if|if
condition|(
name|this
operator|-
literal|1
operator|!=
name|last
condition|)
block|{
specifier|register
name|int
name|lim
init|=
operator|--
name|this
operator|-
name|last
operator|+
name|hpos
decl_stmt|;
name|hpos
operator|=
name|display_string
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
name|last
argument_list|,
name|hpos
argument_list|,
literal|0
argument_list|,
name|hpos
argument_list|,
name|min
argument_list|(
name|lim
argument_list|,
name|maxendcol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* c == '%' */
block|{
specifier|register
name|int
name|spec_width
init|=
literal|0
decl_stmt|;
comment|/* We can't allow -ve args due to the "%-" construct */
comment|/* Argument specifies minwidth but not maxwidth 		   (maxwidth can be specified by 		     (<negative-number> .<stuff>) mode-line elements) */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|this
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|spec_width
operator|=
name|spec_width
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
name|spec_width
operator|+=
name|hpos
expr_stmt|;
if|if
condition|(
name|spec_width
operator|>
name|maxendcol
condition|)
name|spec_width
operator|=
name|maxendcol
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'M'
condition|)
name|hpos
operator|=
name|display_mode_element
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
name|hpos
argument_list|,
name|depth
argument_list|,
name|spec_width
argument_list|,
name|maxendcol
argument_list|,
name|Vglobal_mode_string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|hpos
operator|=
name|display_string
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
name|decode_mode_spec
argument_list|(
name|w
argument_list|,
name|c
argument_list|,
name|spec_width
operator|-
name|hpos
argument_list|)
argument_list|,
name|hpos
argument_list|,
literal|0
argument_list|,
name|spec_width
argument_list|,
name|maxendcol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|Lisp_Symbol
case|:
comment|/* A symbol: process the value of the symbol recursively 	 as if it appeared here directly.  Avoid error if symbol void. 	 Special case: if value of symbol is a string, output the string 	 literally.  */
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fboundp
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fsymbol_value
argument_list|(
name|elt
argument_list|)
expr_stmt|;
comment|/* If value is a string, output that string literally: 	       don't check for % within it.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|hpos
operator|=
name|display_string
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|hpos
argument_list|,
literal|0
argument_list|,
name|minendcol
argument_list|,
name|maxendcol
argument_list|)
expr_stmt|;
comment|/* Give up right away for nil or t.  */
elseif|else
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|elt
argument_list|)
condition|)
block|{
name|elt
operator|=
name|tem
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
block|}
block|}
block|}
break|break;
case|case
name|Lisp_Cons
case|:
block|{
specifier|register
name|Lisp_Object
name|car
decl_stmt|,
name|tem
decl_stmt|;
comment|/* A cons cell: three distinct cases. 	   If first element is a string or a cons, process all the elements 	   and effectively concatenate them. 	   If first element is a negative number, truncate displaying cdr to 	   at most that many characters.  If positive, pad (with spaces) 	   to at least that many characters. 	   If first element is a symbol, process the cadr or caddr recursively 	   according to whether the symbol's value is non-nil or nil.  */
name|car
operator|=
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|car
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|tem
operator|=
name|Fboundp
argument_list|(
name|car
argument_list|)
expr_stmt|;
name|elt
operator|=
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
goto|goto
name|invalid
goto|;
comment|/* elt is now the cdr, and we know it is a cons cell. 	       Use its car if CAR has a non-nil value.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fsymbol_value
argument_list|(
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|elt
operator|=
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|car
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
block|}
block|}
comment|/* Symbol's value is nil (or symbol is unbound) 	       Get the cddr of the original list 	       and if possible find the caddr and use that.  */
name|elt
operator|=
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|elt
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
goto|goto
name|invalid
goto|;
name|elt
operator|=
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|car
expr_stmt|;
goto|goto
name|tail_recurse
goto|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|car
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
specifier|register
name|int
name|lim
init|=
name|XINT
argument_list|(
name|car
argument_list|)
decl_stmt|;
name|elt
operator|=
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|lim
operator|<
literal|0
condition|)
comment|/* Negative int means reduce maximum width. 		 DO NOT change MINENDCOL here! 		 (20 -10 . foo) should truncate foo to 10 col 		 and then pad to 20.  */
name|maxendcol
operator|=
name|min
argument_list|(
name|maxendcol
argument_list|,
name|hpos
operator|-
name|lim
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lim
operator|>
literal|0
condition|)
block|{
comment|/* Padding specified.  Don't let it be more than 		   current maximum.  */
name|lim
operator|+=
name|hpos
expr_stmt|;
if|if
condition|(
name|lim
operator|>
name|maxendcol
condition|)
name|lim
operator|=
name|maxendcol
expr_stmt|;
comment|/* If that's more padding than already wanted, queue it. 		   But don't reduce padding already specified even if 		   that is beyond the current truncation point.  */
if|if
condition|(
name|lim
operator|>
name|minendcol
condition|)
name|minendcol
operator|=
name|lim
expr_stmt|;
block|}
goto|goto
name|tail_recurse
goto|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|car
argument_list|)
operator|==
name|Lisp_String
operator|||
name|XTYPE
argument_list|(
name|car
argument_list|)
operator|==
name|Lisp_Cons
condition|)
block|{
specifier|register
name|int
name|limit
init|=
literal|50
decl_stmt|;
comment|/* LIMIT is to protect against circular lists.  */
while|while
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|==
name|Lisp_Cons
operator|&&
operator|--
name|limit
operator|>
literal|0
operator|&&
name|hpos
operator|<
name|maxendcol
condition|)
block|{
name|hpos
operator|=
name|display_mode_element
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
name|hpos
argument_list|,
name|depth
argument_list|,
name|hpos
argument_list|,
name|maxendcol
argument_list|,
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
name|elt
operator|=
name|XCONS
argument_list|(
name|elt
argument_list|)
operator|->
name|cdr
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
name|invalid
label|:
return|return
operator|(
name|display_string
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
literal|"*invalid*"
argument_list|,
name|hpos
argument_list|,
literal|0
argument_list|,
name|minendcol
argument_list|,
name|maxendcol
argument_list|)
operator|)
return|;
block|}
name|end
label|:
if|if
condition|(
name|minendcol
operator|>
name|hpos
condition|)
name|hpos
operator|=
name|display_string
argument_list|(
name|w
argument_list|,
name|vpos
argument_list|,
literal|""
argument_list|,
name|hpos
argument_list|,
literal|0
argument_list|,
name|minendcol
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|hpos
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a string for the output of a mode line %-spec    for window W, generated by character C and width MAXWIDTH.  */
end_comment

begin_function
name|char
modifier|*
name|decode_mode_spec
parameter_list|(
name|w
parameter_list|,
name|c
parameter_list|,
name|maxwidth
parameter_list|)
name|struct
name|window
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|maxwidth
decl_stmt|;
block|{
name|Lisp_Object
name|obj
init|=
name|Qnil
decl_stmt|;
name|char
modifier|*
name|decode_mode_spec_buf
init|=
operator|(
name|char
operator|*
operator|)
name|temp_screen
operator|->
name|total_contents
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|obj
operator|=
name|current_buffer
operator|->
name|name
expr_stmt|;
if|#
directive|if
literal|0
block|if (maxwidth>= 3&& XSTRING (obj)->size> maxwidth) 	{ 	  bcopy (XSTRING (obj)->data, decode_mode_spec_buf, maxwidth - 1); 	  decode_mode_spec_buf[maxwidth - 1] = '\\'; 	  decode_mode_spec_buf[maxwidth] = '\0'; 	  return decode_mode_spec_buf; 	}
endif|#
directive|endif
break|break;
case|case
literal|'f'
case|:
name|obj
operator|=
name|current_buffer
operator|->
name|filename
expr_stmt|;
if|#
directive|if
literal|0
block|if (XTYPE (obj) == Lisp_String&& XSTRING (obj)->size> maxwidth) 	{ 	  bcopy ("...", decode_mode_spec_buf, 3); 	  bcopy (XSTRING (obj)->data + XSTRING (obj)->size - maxwidth + 3, 		 decode_mode_spec_buf + 3, maxwidth - 3); 	  return decode_mode_spec_buf; 	}
endif|#
directive|endif
break|break;
case|case
literal|'m'
case|:
name|obj
operator|=
name|current_buffer
operator|->
name|mode_name
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|BEGV
operator|>
name|BEG
operator|||
name|ZV
operator|<
name|Z
condition|)
return|return
literal|" Narrow"
return|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|read_only
argument_list|)
condition|)
return|return
literal|"%"
return|;
if|if
condition|(
name|MODIFF
operator|>
name|current_buffer
operator|->
name|save_modified
condition|)
return|return
literal|"*"
return|;
return|return
literal|"-"
return|;
case|case
literal|'s'
case|:
comment|/* status of process */
ifdef|#
directive|ifdef
name|subprocesses
name|obj
operator|=
name|Fget_buffer_process
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|obj
argument_list|)
condition|)
return|return
literal|"no process"
return|;
name|obj
operator|=
name|Fsymbol_name
argument_list|(
name|Fprocess_status
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
return|return
literal|"no processes"
return|;
endif|#
directive|endif
comment|/* subprocesses */
case|case
literal|'p'
case|:
block|{
name|int
name|pos
init|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
decl_stmt|;
name|int
name|total
init|=
name|ZV
operator|-
name|BEGV
decl_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|<=
name|Z
operator|-
name|ZV
condition|)
block|{
if|if
condition|(
name|pos
operator|<=
name|BEGV
condition|)
return|return
literal|"All"
return|;
else|else
return|return
literal|"Bottom"
return|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|<=
name|BEGV
condition|)
return|return
literal|"Top"
return|;
else|else
block|{
name|total
operator|=
operator|(
operator|(
name|pos
operator|-
name|BEGV
operator|)
operator|*
literal|100
operator|+
name|total
operator|-
literal|1
operator|)
operator|/
name|total
expr_stmt|;
comment|/* We can't normally display a 3-digit number, 	       so get us a 2-digit number that is close.  */
if|if
condition|(
name|total
operator|==
literal|100
condition|)
name|total
operator|=
literal|99
expr_stmt|;
name|sprintf
argument_list|(
name|decode_mode_spec_buf
argument_list|,
literal|"%2d%%"
argument_list|,
name|total
argument_list|)
expr_stmt|;
return|return
name|decode_mode_spec_buf
return|;
block|}
block|}
case|case
literal|'['
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|command_loop_level
operator|>
literal|5
condition|)
return|return
literal|"[[[... "
return|;
name|p
operator|=
name|decode_mode_spec_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|command_loop_level
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|decode_mode_spec_buf
return|;
block|}
case|case
literal|'%'
case|:
return|return
literal|"%"
return|;
case|case
literal|']'
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|command_loop_level
operator|>
literal|5
condition|)
return|return
literal|" ...]]]"
return|;
name|p
operator|=
name|decode_mode_spec_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|command_loop_level
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|']'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|decode_mode_spec_buf
return|;
block|}
case|case
literal|'-'
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|maxwidth
operator|<
literal|140
condition|)
return|return
literal|"--------------------------------------------------------------------------------------------------------------------------------------------"
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxwidth
condition|;
name|i
operator|++
control|)
name|decode_mode_spec_buf
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
return|return
name|decode_mode_spec_buf
return|;
block|}
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
return|;
else|else
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Display STRING on one line of window W, starting at HPOS.    Display at position VPOS.  Caller should do get_display_line first.    TRUNCATE is character to display at end if truncated.  Zero for none.    MINCOL is the first column ok to end at.  (Pad with spaces to this col.)   MAXCOL is the last column ok to end at.  Truncate here.     -1 for MINCOL or MAXCOL means no explicit minimum or maximum.   Both count from the left edge of the screen, as does HPOS.   The right edge of W is an implicit maximum.   If TRUNCATE is nonzero, the implicit maximum is one column before the edge.    Returns ending hpos */
end_comment

begin_macro
name|display_string
argument_list|(
argument|w
argument_list|,
argument|vpos
argument_list|,
argument|string
argument_list|,
argument|hpos
argument_list|,
argument|truncate
argument_list|,
argument|mincol
argument_list|,
argument|maxcol
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|truncate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mincol
decl_stmt|,
name|maxcol
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|hscroll
init|=
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
decl_stmt|;
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|current_buffer
operator|->
name|tab_width
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1start
init|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|hpos
decl_stmt|;
name|int
name|window_width
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
operator|||
name|tab_width
operator|>
literal|20
condition|)
name|tab_width
operator|=
literal|8
expr_stmt|;
name|p1
operator|=
name|p1start
expr_stmt|;
name|start
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|window_width
operator|-
operator|(
name|truncate
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|window_width
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|)
operator|!=
name|screen_width
condition|)
operator|*
name|end
operator|--
operator|=
literal|'|'
expr_stmt|;
if|if
condition|(
name|maxcol
operator|>=
literal|0
operator|&&
name|end
operator|-
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|>
name|maxcol
condition|)
name|end
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|maxcol
expr_stmt|;
if|if
condition|(
name|maxcol
operator|>=
literal|0
operator|&&
name|mincol
operator|>
name|maxcol
condition|)
name|mincol
operator|=
name|maxcol
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
break|break;
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
name|c
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
do|do
block|{
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
literal|' '
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|p1
operator|-
name|start
operator|+
name|hscroll
operator|-
operator|(
name|hscroll
operator|>
literal|0
operator|)
operator|)
operator|%
name|tab_width
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0200
operator|&&
name|buffer_defaults
operator|.
name|ctl_arrow
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
literal|'^'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
name|c
operator|^
literal|0100
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
literal|'\\'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
operator|(
literal|7
operator|&
operator|(
name|c
operator|>>
literal|3
operator|)
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|start
condition|)
operator|*
name|p1
operator|=
operator|(
literal|7
operator|&
name|c
operator|)
operator|+
literal|'0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
condition|)
block|{
name|p1
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|truncate
condition|)
operator|*
name|p1
operator|++
operator|=
name|truncate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mincol
operator|>=
literal|0
condition|)
block|{
name|end
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|mincol
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|end
condition|)
operator|*
name|p1
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|{
specifier|register
name|int
name|len
init|=
name|p1
operator|-
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
condition|)
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|len
expr_stmt|;
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
index|[
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|len
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_xdisp
argument_list|()
end_macro

begin_block
block|{
name|staticpro
argument_list|(
operator|&
name|last_arrow_position
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|last_arrow_string
argument_list|)
expr_stmt|;
name|last_arrow_position
operator|=
name|Qnil
expr_stmt|;
name|last_arrow_string
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"global-mode-string"
argument_list|,
operator|&
name|Vglobal_mode_string
argument_list|,
literal|"String displayed by mode-line-format's \"%m\" specifiation."
argument_list|)
expr_stmt|;
name|Vglobal_mode_string
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"overlay-arrow-position"
argument_list|,
operator|&
name|Voverlay_arrow_position
argument_list|,
literal|"Marker for where to display an arrow on top of the buffer text.\n\ This must be the beginning of a line in order to work.\n\ See also overlay-arrow-string."
argument_list|)
expr_stmt|;
name|Voverlay_arrow_position
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"overlay-arrow-string"
argument_list|,
operator|&
name|Voverlay_arrow_string
argument_list|,
literal|"String to display as an arrow.  See also overlay-arrow-position."
argument_list|)
expr_stmt|;
name|Voverlay_arrow_string
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"scroll-step"
argument_list|,
operator|&
name|scroll_step
argument_list|,
literal|"*The number of lines to try scrolling a window by when point moves out.\n\ If that fails to bring point back on screen, point is centered instead.\n\ If this is zero, point is always centered after it moves off screen."
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"reset-terminal-on-clear"
argument_list|,
operator|&
name|reset_terminal_on_clear
argument_list|,
literal|"Non-nil means re-init terminal modes for clear screen as on entry to Emacs."
argument_list|)
expr_stmt|;
name|reset_terminal_on_clear
operator|=
literal|1
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"debug-end-pos"
argument_list|,
operator|&
name|debug_end_pos
argument_list|,
literal|"Don't ask"
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"truncate-partial-width-windows"
argument_list|,
operator|&
name|truncate_partial_width_windows
argument_list|,
literal|"*Non-nil means truncate lines in all windows less than full screen wide."
argument_list|)
expr_stmt|;
name|truncate_partial_width_windows
operator|=
literal|1
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"mode-line-inverse-video"
argument_list|,
operator|&
name|mode_line_inverse_video
argument_list|,
literal|"*Non-nil means use inverse video, or other suitable display mode, for the mode line."
argument_list|)
expr_stmt|;
name|mode_line_inverse_video
operator|=
literal|1
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sredraw_display
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* initialize the window system */
end_comment

begin_macro
name|init_xdisp
argument_list|()
end_macro

begin_block
block|{
name|Lisp_Object
name|root_window
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILER_REGISTER_BUG
specifier|register
endif|#
directive|endif
endif|COMPILER_REGISTER_BUG
name|struct
name|window
modifier|*
name|mini_w
decl_stmt|;
name|this_line_bufpos
operator|=
literal|0
expr_stmt|;
name|mini_w
operator|=
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
expr_stmt|;
name|root_window
operator|=
name|mini_w
operator|->
name|prev
expr_stmt|;
name|echo_area_contents
operator|=
literal|0
expr_stmt|;
name|prev_echo_area_contents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|noninteractive
condition|)
block|{
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|root_window
argument_list|)
operator|->
name|top
argument_list|)
operator|=
literal|0
expr_stmt|;
name|set_window_height
argument_list|(
name|root_window
argument_list|,
name|screen_height
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|mini_w
operator|->
name|top
argument_list|)
operator|=
name|screen_height
operator|-
literal|1
expr_stmt|;
name|set_window_height
argument_list|(
name|minibuf_window
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|root_window
argument_list|)
operator|->
name|width
argument_list|)
operator|=
name|screen_width
expr_stmt|;
name|XFASTINT
argument_list|(
name|mini_w
operator|->
name|width
argument_list|)
operator|=
name|screen_width
expr_stmt|;
block|}
block|}
end_block

end_unit

