begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Modified by Andrew.Vignaux@comp.vuw.ac.nz to get it to work :-) */
end_comment

begin_comment
comment|/* Copyright (C) 1985, 1986, 1987, 1988 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/*  * unexec.c - Convert a running program into an a.out file.  *  * Author:	Spencer W. Thomas  * 		Computer Science Dept.  * 		University of Utah  * Date:	Tue Mar  2 1982  * Modified heavily since then.  *  * Synopsis:  *	unexec (new_name, a_name, data_start, bss_start, entry_address)  *	char *new_name, *a_name;  *	unsigned data_start, bss_start, entry_address;  *  * Takes a snapshot of the program and makes an a.out format file in the  * file named by the string argument new_name.  * If a_name is non-NULL, the symbol table will be taken from the given file.  * On some machines, an existing a_name file is required.  *  * The boundaries within the a.out file may be adjusted with the data_start  * and bss_start arguments.  Either or both may be given as 0 for defaults.  *  * Data_start gives the boundary between the text segment and the data  * segment of the program.  The text segment can contain shared, read-only  * program code and literal data, while the data segment is always unshared  * and unprotected.  Data_start gives the lowest unprotected address.  * The value you specify may be rounded down to a suitable boundary  * as required by the machine you are using.  *  * Specifying zero for data_start means the boundary between text and data  * should not be the same as when the program was loaded.  * If NO_REMAP is defined, the argument data_start is ignored and the  * segment boundaries are never changed.  *  * Bss_start indicates how much of the data segment is to be saved in the  * a.out file and restored when the program is executed.  It gives the lowest  * unsaved address, and is rounded up to a page boundary.  The default when 0  * is given assumes that the entire data segment is to be stored, including  * the previous data and bss as well as any additional storage allocated with  * break (2).  *  * The new file is set up to start at entry_address.  *  * If you make improvements I'd like to get them too.  * harpo!utah-cs!thomas, thomas@Utah-20  *  */
end_comment

begin_comment
comment|/* There are several compilation parameters affecting unexec:  * COFF  Define this if your system uses COFF for executables. Otherwise we assume you use Berkeley format.  * NO_REMAP  Define this if you do not want to try to save Emacs's pure data areas as part of the text segment.  Saving them as text is good because it allows users to share more.  However, on machines that locate the text area far from the data area, the boundary cannot feasibly be moved.  Such machines require NO_REMAP.  Also, remapping can cause trouble with the built-in startup routine /lib/crt0.o, which defines `environ' as an initialized variable. Dumping `environ' as pure does not work!  So, to use remapping, you must write a startup routine for your machine in Emacs's crt0.c. If NO_REMAP is defined, Emacs uses the system's crt0.o.  * SECTION_ALIGNMENT  Some machines that use COFF executables require that each section start on a certain boundary *in the COFF file*.  Such machines should define SECTION_ALIGNMENT to a mask of the low-order bits that must be zero on such a boundary.  This mask is used to control padding between segments in the COFF file.  If SECTION_ALIGNMENT is not defined, the segments are written consecutively with no attempt at alignment.  This is right for unmodified system V.  * SEGMENT_MASK  Some machines require that the beginnings and ends of segments *in core* be on certain boundaries.  For most machines, a page boundary is sufficient.  That is the default.  When a larger boundary is needed, define SEGMENT_MASK to a mask of the bits that must be zero on such a boundary.  * A_TEXT_OFFSET(HDR)  Some machines count the a.out header as part of the size of the text segment (a_text); they may actually load the header into core as the first data in the text segment.  Some have additional padding between the header and the real text of the program that is counted in a_text.  For these machines, define A_TEXT_OFFSET(HDR) to examine the header structure HDR and return the number of bytes to add to `a_text' before writing it (above and beyond the number of bytes of actual program text).  HDR's standard fields are already correct, except that this adjustment to the `a_text' field has not yet been made; thus, the amount of offset can depend on the data in the file.    * A_TEXT_SEEK(HDR)  If defined, this macro specifies the number of bytes to seek into the a.out file before starting to write the text segment.a  * EXEC_MAGIC  For machines using COFF, this macro, if defined, is a value stored into the magic number field of the output file.  * ADJUST_EXEC_HEADER  This macro can be used to generate statements to adjust or initialize nonstandard fields in the file header  * ADDR_CORRECT(ADDR)  Macro to correct an int which is the bit pattern of a pointer to a byte into an int which is the number of a byte.  This macro has a default definition which is usually right. This default definition is a no-op on most machines (where a pointer looks like an int) but not on all machines.  */
end_comment

begin_define
define|#
directive|define
name|XCOFF
end_define

begin_define
define|#
directive|define
name|COFF
end_define

begin_define
define|#
directive|define
name|NO_REMAP
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|arg
parameter_list|)
value|perror (arg); return -1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|file
parameter_list|)
value|report_error (file, new)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_DUMP
end_ifndef

begin_comment
comment|/* all rest of file!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_UNEXEC
end_ifndef

begin_comment
comment|/* most of rest of file */
end_comment

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_comment
comment|/* Define getpagesize () if the system does not.    Note that this may depend on symbols defined in a.out.h  */
end_comment

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|makedev
end_ifndef

begin_comment
comment|/* Try to detect types.h already loaded */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_text
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start of text */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_data
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start of initialized data */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_edata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_etext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_end
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COFF
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|STRIDE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|UMAX
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|sun386
end_ifndef

begin_comment
comment|/* I have a suspicion that these are turned off on all systems    and can be deleted.  Try it in version 19.  */
end_comment

begin_include
include|#
directive|include
file|<filehdr.h>
end_include

begin_include
include|#
directive|include
file|<aouthdr.h>
end_include

begin_include
include|#
directive|include
file|<scnhdr.h>
end_include

begin_include
include|#
directive|include
file|<syms.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not sun386 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not UMAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not STRIDE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_decl_stmt
specifier|static
name|long
name|block_copy_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Old executable start point */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filehdr
name|f_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File header */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|aouthdr
name|f_ohdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Optional file header (a.out) */
end_comment

begin_decl_stmt
name|long
name|bias
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bias to add for growth */
end_comment

begin_decl_stmt
name|long
name|lnnoptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to line-number info within file */
end_comment

begin_define
define|#
directive|define
name|SYMS_START
value|block_copy_start
end_define

begin_decl_stmt
specifier|static
name|long
name|text_scnptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|data_scnptr
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|load_scnptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|orig_load_scnptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|orig_data_scnptr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|long
name|data_st
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_SECTIONS
end_ifndef

begin_define
define|#
directive|define
name|MAX_SECTIONS
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pagemask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Correct an int which is the bit pattern of a pointer to a byte    into an int which is the number of a byte.    This is a no-op on ordinary machines, but not on all.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ADDR_CORRECT
end_ifndef

begin_comment
comment|/* Let m-*.h files override this definition */
end_comment

begin_define
define|#
directive|define
name|ADDR_CORRECT
parameter_list|(
name|x
parameter_list|)
value|((char *)(x) - (char*)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_expr_stmt
specifier|static
name|report_error
argument_list|(
argument|file
argument_list|,
argument|fd
argument_list|)
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Failure operating on %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emacs */
end_comment

begin_define
define|#
directive|define
name|ERROR0
parameter_list|(
name|msg
parameter_list|)
value|report_error_1 (new, msg, 0, 0); return -1
end_define

begin_define
define|#
directive|define
name|ERROR1
parameter_list|(
name|msg
parameter_list|,
name|x
parameter_list|)
value|report_error_1 (new, msg, x, 0); return -1
end_define

begin_define
define|#
directive|define
name|ERROR2
parameter_list|(
name|msg
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|report_error_1 (new, msg, x, y); return -1
end_define

begin_expr_stmt
specifier|static
name|report_error_1
argument_list|(
argument|fd
argument_list|,
argument|msg
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|emacs
name|error
argument_list|(
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * unexec  *  * driving logic.  */
end_comment

begin_macro
name|unexec
argument_list|(
argument|new_name
argument_list|,
argument|a_name
argument_list|,
argument|data_start
argument_list|,
argument|bss_start
argument_list|,
argument|entry_address
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|new_name
decl_stmt|,
modifier|*
name|a_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|new
decl_stmt|,
name|a_out
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|a_name
operator|&&
operator|(
name|a_out
operator|=
name|open
argument_list|(
name|a_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new
operator|=
name|creat
argument_list|(
name|new_name
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|make_hdr
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|data_start
argument_list|,
name|bss_start
argument_list|,
name|entry_address
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
operator|||
name|copy_text_and_data
argument_list|(
name|new
argument_list|)
operator|<
literal|0
operator|||
name|copy_sym
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
ifdef|#
directive|ifdef
name|COFF
name|;
operator|||
name|adjust_lnnoptrs
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF
name|;
operator|||
name|unrelocate_symbols
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
endif|#
directive|endif
condition|)
block|{
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* unlink (new_name);	    	/* Failed, unlink new a.out */
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|a_out
argument_list|)
expr_stmt|;
name|mark_x
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ****************************************************************  * make_hdr  *  * Make the header in the new a.out from the header in core.  * Modify the text and data sizes.  */
end_comment

begin_function
specifier|static
name|int
name|make_hdr
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|,
name|data_start
parameter_list|,
name|bss_start
parameter_list|,
name|entry_address
parameter_list|,
name|a_name
parameter_list|,
name|new_name
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
name|char
modifier|*
name|a_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
block|{
specifier|register
name|int
name|scns
decl_stmt|;
name|unsigned
name|int
name|bss_end
decl_stmt|;
name|struct
name|scnhdr
name|section
index|[
name|MAX_SECTIONS
index|]
decl_stmt|;
name|struct
name|scnhdr
modifier|*
name|f_thdr
decl_stmt|;
comment|/* Text section header */
name|struct
name|scnhdr
modifier|*
name|f_dhdr
decl_stmt|;
comment|/* Data section header */
name|struct
name|scnhdr
modifier|*
name|f_bhdr
decl_stmt|;
comment|/* Bss section header */
name|struct
name|scnhdr
modifier|*
name|f_lhdr
decl_stmt|;
comment|/* Loader section header */
name|struct
name|scnhdr
modifier|*
name|f_tchdr
decl_stmt|;
comment|/* Typechk section header */
name|struct
name|scnhdr
modifier|*
name|f_dbhdr
decl_stmt|;
comment|/* Debug section header */
name|struct
name|scnhdr
modifier|*
name|f_xhdr
decl_stmt|;
comment|/* Except section header */
name|load_scnptr
operator|=
name|orig_load_scnptr
operator|=
name|lnnoptr
operator|=
literal|0
expr_stmt|;
name|pagemask
operator|=
name|getpagesize
argument_list|()
operator|-
literal|1
expr_stmt|;
comment|/* Adjust text/data boundary. */
ifdef|#
directive|ifdef
name|NO_REMAP
name|data_start
operator|=
operator|(
name|long
operator|)
name|start_of_data
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*  NO_REMAP */
name|data_start
operator|=
name|ADDR_CORRECT
argument_list|(
name|data_start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEGMENT_MASK
name|data_start
operator|=
name|data_start
operator|&
operator|~
name|SEGMENT_MASK
expr_stmt|;
comment|/* (Down) to segment boundary. */
else|#
directive|else
name|data_start
operator|=
name|data_start
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* (Down) to page boundary. */
endif|#
directive|endif
name|bss_end
operator|=
name|ADDR_CORRECT
argument_list|(
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|pagemask
expr_stmt|;
name|bss_end
operator|&=
operator|~
name|pagemask
expr_stmt|;
comment|/* Adjust data/bss boundary. */
if|if
condition|(
name|bss_start
operator|!=
literal|0
condition|)
block|{
name|bss_start
operator|=
operator|(
name|ADDR_CORRECT
argument_list|(
name|bss_start
argument_list|)
operator|+
name|pagemask
operator|)
expr_stmt|;
comment|/* (Up) to page bdry. */
name|bss_start
operator|&=
operator|~
name|pagemask
expr_stmt|;
if|if
condition|(
name|bss_start
operator|>
name|bss_end
condition|)
block|{
name|ERROR1
argument_list|(
literal|"unexec: Specified bss_start (%u) is past end of program"
argument_list|,
name|bss_start
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bss_start
operator|=
name|bss_end
expr_stmt|;
if|if
condition|(
name|data_start
operator|>
name|bss_start
condition|)
comment|/* Can't have negative data size. */
block|{
name|ERROR2
argument_list|(
literal|"unexec: data_start (%u) can't be greater than bss_start (%u)"
argument_list|,
name|data_start
argument_list|,
name|bss_start
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COFF
comment|/* Salvage as much info from the existing file as possible */
name|block_copy_start
operator|=
literal|0
expr_stmt|;
name|f_thdr
operator|=
name|NULL
expr_stmt|;
name|f_dhdr
operator|=
name|NULL
expr_stmt|;
name|f_bhdr
operator|=
name|NULL
expr_stmt|;
name|f_lhdr
operator|=
name|NULL
expr_stmt|;
name|f_tchdr
operator|=
name|NULL
expr_stmt|;
name|f_dbhdr
operator|=
name|NULL
expr_stmt|;
name|f_xhdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|f_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_hdr
operator|.
name|f_opthdr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|f_ohdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_hdr
operator|.
name|f_nscns
operator|>
name|MAX_SECTIONS
condition|)
block|{
name|ERROR0
argument_list|(
literal|"unexec: too many section headers -- increase MAX_SECTIONS"
argument_list|)
expr_stmt|;
block|}
comment|/* Loop through section headers */
for|for
control|(
name|scns
operator|=
literal|0
init|;
name|scns
operator|<
name|f_hdr
operator|.
name|f_nscns
condition|;
name|scns
operator|++
control|)
block|{
name|struct
name|scnhdr
modifier|*
name|s
init|=
operator|&
name|section
index|[
name|scns
index|]
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s_scnptr
operator|>
literal|0L
condition|)
block|{
if|if
condition|(
name|block_copy_start
operator|<
name|s
operator|->
name|s_scnptr
operator|+
name|s
operator|->
name|s_size
condition|)
name|block_copy_start
operator|=
name|s
operator|->
name|s_scnptr
operator|+
name|s
operator|->
name|s_size
expr_stmt|;
block|}
define|#
directive|define
name|CHECK_SCNHDR
parameter_list|(
name|ptr
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|)
define|\
value|if (strcmp(s->s_name, name) == 0) { \     if (s->s_flags != flags) { \       fprintf(stderr, "unexec: %x flags where %x expected in %s section.\n", \ 	      s->s_flags, flags, name); \     } \     if (ptr) { \       fprintf(stderr, "unexec: duplicate section header for section %s.\n", \ 	      name); \     } \     ptr = s; \   }
name|CHECK_SCNHDR
argument_list|(
name|f_thdr
argument_list|,
name|_TEXT
argument_list|,
name|STYP_TEXT
argument_list|)
expr_stmt|;
name|CHECK_SCNHDR
argument_list|(
name|f_dhdr
argument_list|,
name|_DATA
argument_list|,
name|STYP_DATA
argument_list|)
expr_stmt|;
name|CHECK_SCNHDR
argument_list|(
name|f_bhdr
argument_list|,
name|_BSS
argument_list|,
name|STYP_BSS
argument_list|)
expr_stmt|;
name|CHECK_SCNHDR
argument_list|(
name|f_lhdr
argument_list|,
name|_LOADER
argument_list|,
name|STYP_LOADER
argument_list|)
expr_stmt|;
name|CHECK_SCNHDR
argument_list|(
name|f_dbhdr
argument_list|,
name|_DEBUG
argument_list|,
name|STYP_DEBUG
argument_list|)
expr_stmt|;
name|CHECK_SCNHDR
argument_list|(
name|f_tchdr
argument_list|,
name|_TYPCHK
argument_list|,
name|STYP_TYPCHK
argument_list|)
expr_stmt|;
name|CHECK_SCNHDR
argument_list|(
name|f_xhdr
argument_list|,
name|_EXCEPT
argument_list|,
name|STYP_EXCEPT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_thdr
operator|==
literal|0
condition|)
block|{
name|ERROR1
argument_list|(
literal|"unexec: couldn't find \"%s\" section"
argument_list|,
name|_TEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_dhdr
operator|==
literal|0
condition|)
block|{
name|ERROR1
argument_list|(
literal|"unexec: couldn't find \"%s\" section"
argument_list|,
name|_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_bhdr
operator|==
literal|0
condition|)
block|{
name|ERROR1
argument_list|(
literal|"unexec: couldn't find \"%s\" section"
argument_list|,
name|_BSS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ERROR0
argument_list|(
literal|"can't build a COFF file from scratch yet"
argument_list|)
expr_stmt|;
block|}
name|orig_data_scnptr
operator|=
name|f_dhdr
operator|->
name|s_scnptr
expr_stmt|;
name|orig_load_scnptr
operator|=
name|f_lhdr
condition|?
name|f_lhdr
operator|->
name|s_scnptr
else|:
literal|0
expr_stmt|;
comment|/* Now we alter the contents of all the f_*hdr variables      to correspond to what we want to dump.  */
name|f_hdr
operator|.
name|f_flags
operator||=
operator|(
name|F_RELFLG
operator||
name|F_EXEC
operator|)
expr_stmt|;
comment|/* Why? */
ifdef|#
directive|ifdef
name|EXEC_MAGIC
name|f_ohdr
operator|.
name|magic
operator|=
name|EXEC_MAGIC
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_REMAP
name|f_ohdr
operator|.
name|tsize
operator|=
name|data_start
operator|-
name|f_ohdr
operator|.
name|text_start
expr_stmt|;
name|f_ohdr
operator|.
name|text_start
operator|=
operator|(
name|long
operator|)
name|start_of_text
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|f_ohdr
operator|.
name|dsize
operator|=
name|bss_start
operator|-
operator|(
operator|(
name|unsigned
operator|)
operator|&
name|_data
operator|)
expr_stmt|;
name|f_ohdr
operator|.
name|bsize
operator|=
name|bss_end
operator|-
name|bss_start
expr_stmt|;
name|f_dhdr
operator|->
name|s_size
operator|=
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|f_bhdr
operator|->
name|s_size
operator|=
name|f_ohdr
operator|.
name|bsize
expr_stmt|;
name|f_bhdr
operator|->
name|s_paddr
operator|=
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|f_bhdr
operator|->
name|s_vaddr
operator|=
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
comment|/* fix scnptr's */
block|{
name|long
name|ptr
decl_stmt|;
for|for
control|(
name|scns
operator|=
literal|0
init|;
name|scns
operator|<
name|f_hdr
operator|.
name|f_nscns
condition|;
name|scns
operator|++
control|)
block|{
name|struct
name|scnhdr
modifier|*
name|s
init|=
operator|&
name|section
index|[
name|scns
index|]
decl_stmt|;
if|if
condition|(
name|scns
operator|==
literal|0
condition|)
name|ptr
operator|=
name|s
operator|->
name|s_scnptr
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_scnptr
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|s_scnptr
operator|=
name|ptr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|s_flags
operator|&
literal|0xffff
operator|)
operator|==
name|STYP_PAD
condition|)
block|{
comment|/* 	   * the text_start should probably be o_algntext but that doesn't 	   * seem to change 	   */
if|if
condition|(
name|f_ohdr
operator|.
name|text_start
operator|!=
literal|0
condition|)
comment|/*&& scns != 0 */
block|{
name|s
operator|->
name|s_size
operator|=
literal|512
operator|-
operator|(
name|s
operator|->
name|s_scnptr
operator|%
literal|512
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_size
operator|==
literal|512
condition|)
name|s
operator|->
name|s_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ptr
operator|=
name|ptr
operator|+
name|s
operator|->
name|s_size
expr_stmt|;
block|}
name|bias
operator|=
name|ptr
operator|-
name|block_copy_start
expr_stmt|;
block|}
comment|/* fix other pointers */
for|for
control|(
name|scns
operator|=
literal|0
init|;
name|scns
operator|<
name|f_hdr
operator|.
name|f_nscns
condition|;
name|scns
operator|++
control|)
block|{
name|struct
name|scnhdr
modifier|*
name|s
init|=
operator|&
name|section
index|[
name|scns
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|s_relptr
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|s_relptr
operator|+=
name|bias
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s_lnnoptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lnnoptr
operator|==
literal|0
condition|)
name|lnnoptr
operator|=
name|s
operator|->
name|s_lnnoptr
expr_stmt|;
name|s
operator|->
name|s_lnnoptr
operator|+=
name|bias
expr_stmt|;
block|}
block|}
if|if
condition|(
name|f_hdr
operator|.
name|f_symptr
operator|>
literal|0L
condition|)
block|{
name|f_hdr
operator|.
name|f_symptr
operator|+=
name|bias
expr_stmt|;
block|}
name|data_st
operator|=
name|data_start
expr_stmt|;
name|text_scnptr
operator|=
name|f_thdr
operator|->
name|s_scnptr
expr_stmt|;
name|data_scnptr
operator|=
name|f_dhdr
operator|->
name|s_scnptr
expr_stmt|;
name|load_scnptr
operator|=
name|f_lhdr
condition|?
name|f_lhdr
operator|->
name|s_scnptr
else|:
literal|0
expr_stmt|;
name|block_copy_start
operator|=
name|orig_load_scnptr
expr_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_EXEC_HEADER
name|ADJUST_EXEC_HEADER
endif|#
directive|endif
comment|/* ADJUST_EXEC_HEADER */
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_hdr
operator|.
name|f_opthdr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_ohdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|scns
operator|=
literal|0
init|;
name|scns
operator|<
name|f_hdr
operator|.
name|f_nscns
condition|;
name|scns
operator|++
control|)
block|{
name|struct
name|scnhdr
modifier|*
name|s
init|=
operator|&
name|section
index|[
name|scns
index|]
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* COFF */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************    *  * Copy the text and data segments from memory to the new a.out  */
end_comment

begin_function
specifier|static
name|int
name|copy_text_and_data
parameter_list|(
name|new
parameter_list|)
name|int
name|new
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|long
operator|)
name|text_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|start_of_text
argument_list|()
operator|+
name|text_scnptr
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|f_ohdr
operator|.
name|tsize
expr_stmt|;
name|write_segment
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|long
operator|)
name|data_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|_data
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|f_ohdr
operator|.
name|dsize
expr_stmt|;
name|write_segment
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|write_segment
argument_list|(
argument|new
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|nwrite
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|char
name|zeros
index|[
literal|128
index|]
decl_stmt|;
name|bzero
argument_list|(
name|zeros
argument_list|,
sizeof|sizeof
name|zeros
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
operator|<
name|end
condition|;
control|)
block|{
comment|/* distance to next multiple of 128.  */
name|nwrite
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|+
literal|128
operator|)
operator|&
operator|-
literal|128
operator|)
operator|-
operator|(
name|int
operator|)
name|ptr
expr_stmt|;
comment|/* But not beyond specified end.  */
if|if
condition|(
name|nwrite
operator|>
name|end
operator|-
name|ptr
condition|)
name|nwrite
operator|=
name|end
operator|-
name|ptr
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
comment|/* If write gets a page fault, it means we reached 	 a gap between the old text segment and the old data segment. 	 This gap has probably been remapped into part of the text segment. 	 So write zeros for it.  */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EFAULT
condition|)
block|{
name|write
argument_list|(
name|new
argument_list|,
name|zeros
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nwrite
operator|!=
name|ret
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unexec write failure: addr 0x%x, fileno %d, size 0x%x, wrote 0x%x, errno %d"
argument_list|,
name|ptr
argument_list|,
name|new
argument_list|,
name|nwrite
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|PERROR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|nwrite
expr_stmt|;
name|ptr
operator|+=
name|nwrite
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * copy_sym  *  * Copy the relocation information and symbol table from the a.out to the new  */
end_comment

begin_function
specifier|static
name|int
name|copy_sym
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|,
name|a_name
parameter_list|,
name|new_name
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
name|char
modifier|*
name|a_name
decl_stmt|,
decl|*
name|new_name
decl_stmt|;
end_function

begin_block
block|{
name|char
name|page
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|a_out
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SYMS_START
operator|==
literal|0L
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lnnoptr
operator|&&
name|lnnoptr
operator|<
name|SYMS_START
condition|)
comment|/* if there is line number info */
name|lseek
argument_list|(
name|a_out
argument_list|,
name|lnnoptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start copying from there */
else|else
name|lseek
argument_list|(
name|a_out
argument_list|,
name|SYMS_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Position a.out to symtab. */
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|a_out
argument_list|,
name|page
argument_list|,
sizeof|sizeof
name|page
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
name|page
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * mark_x  *  * After succesfully building the new a.out, mark it executable  */
end_comment

begin_expr_stmt
specifier|static
name|mark_x
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|um
decl_stmt|;
name|int
name|new
init|=
literal|0
decl_stmt|;
comment|/* for PERROR */
name|um
operator|=
name|umask
argument_list|(
literal|777
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PERROR
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|sbuf
operator|.
name|st_mode
operator||=
literal|0111
operator|&
operator|~
name|um
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|name
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PERROR
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	If the COFF file contains a symbol table and a line number section,  *	then any auxiliary entries that have values for x_lnnoptr must  *	be adjusted by the amount that the line number section has moved  *	in the file (bias computed in make_hdr).  The #@$%&* designers of  *	the auxiliary entry structures used the absolute file offsets for  *	the line number entry rather than an offset from the start of the  *	line number section!  *  *	When I figure out how to scan through the symbol table and pick out  *	the auxiliary entries that need adjustment, this routine will  *	be fixed.  As it is now, all such entries are wrong and sdb  *	will complain.   Fred Fish, UniSoft Systems Inc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COFF
end_ifdef

begin_comment
comment|/* This function is probably very slow.  Instead of reopening the new    file for input and output it should copy from the old to the new    using the two descriptors already open (WRITEDESC and READDESC).    Instead of reading one small structure at a time it should use    a reasonable size buffer.  But I don't have time to work on such    things, so I am installing it as submitted to me.  -- RMS.  */
end_comment

begin_macro
name|adjust_lnnoptrs
argument_list|(
argument|writedesc
argument_list|,
argument|readdesc
argument_list|,
argument|new_name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|writedesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|readdesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|new_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
ifdef|#
directive|ifdef
name|amdahl_uts
name|SYMENT
name|symentry
decl_stmt|;
name|AUXENT
name|auxentry
decl_stmt|;
else|#
directive|else
name|struct
name|syment
name|symentry
decl_stmt|;
name|union
name|auxent
name|auxentry
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|lnnoptr
operator|||
operator|!
name|f_hdr
operator|.
name|f_symptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|open
argument_list|(
name|new_name
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|lseek
argument_list|(
name|new
argument_list|,
name|f_hdr
operator|.
name|f_symptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|nsyms
operator|=
literal|0
init|;
name|nsyms
operator|<
name|f_hdr
operator|.
name|f_nsyms
condition|;
name|nsyms
operator|++
control|)
block|{
name|read
argument_list|(
name|new
argument_list|,
operator|&
name|symentry
argument_list|,
name|SYMESZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|symentry
operator|.
name|n_numaux
condition|)
block|{
name|read
argument_list|(
name|new
argument_list|,
operator|&
name|auxentry
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|symentry
operator|.
name|n_type
argument_list|)
condition|)
block|{
name|auxentry
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|+=
name|bias
expr_stmt|;
name|lseek
argument_list|(
name|new
argument_list|,
operator|-
name|AUXESZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|auxentry
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF
end_ifdef

begin_comment
comment|/* It is probably a false economy to optimise this routine (it used to    read one LDREL and do do two lseeks per iteration) but the wrath of    RMS (see above :-) would be too much to bear */
end_comment

begin_macro
name|unrelocate_symbols
argument_list|(
argument|new
argument_list|,
argument|a_out
argument_list|,
argument|a_name
argument_list|,
argument|new_name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|a_name
decl_stmt|,
modifier|*
name|new_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
specifier|register
name|LDREL
modifier|*
name|ldrel
decl_stmt|;
name|LDHDR
name|ldhdr
decl_stmt|;
name|LDREL
name|ldrel_buf
index|[
literal|20
index|]
decl_stmt|;
name|ulong
name|t_start
init|=
operator|&
name|_text
decl_stmt|;
name|ulong
name|d_start
init|=
operator|&
name|_data
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
name|int
name|dirty
decl_stmt|;
if|if
condition|(
name|load_scnptr
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|lseek
argument_list|(
name|a_out
argument_list|,
name|orig_load_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|ldhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|ldhdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|ldhdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|SYMNDX_TEXT
value|0
define|#
directive|define
name|SYMNDX_DATA
value|1
define|#
directive|define
name|SYMNDX_BSS
value|2
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldhdr
operator|.
name|l_nreloc
condition|;
name|i
operator|++
operator|,
name|l
operator|--
operator|,
name|ldrel
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|a_out
argument_list|,
name|orig_load_scnptr
operator|+
name|LDHDRSZ
operator|+
name|LDSYMSZ
operator|*
name|ldhdr
operator|.
name|l_nsyms
operator|+
name|LDRELSZ
operator|*
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|l
operator|=
name|ldhdr
operator|.
name|l_nreloc
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|ldrel_buf
argument_list|)
operator|/
name|LDRELSZ
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|ldrel_buf
argument_list|)
operator|/
name|LDRELSZ
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
name|ldrel_buf
argument_list|,
name|l
operator|*
name|LDRELSZ
argument_list|)
operator|!=
name|l
operator|*
name|LDRELSZ
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|ldrel
operator|=
name|ldrel_buf
expr_stmt|;
block|}
name|dirty
operator|=
literal|0
expr_stmt|;
comment|/* this code may not be necessary */
comment|/* I originally had == in the "assignment" and it still unrelocated */
comment|/* move the BSS loader symbols to the DATA segment */
if|if
condition|(
name|ldrel
operator|->
name|l_rsecnm
operator|==
name|f_ohdr
operator|.
name|o_snbss
condition|)
name|ldrel
operator|->
name|l_rsecnm
operator|=
name|f_ohdr
operator|.
name|o_sndata
operator|,
name|dirty
operator|++
expr_stmt|;
if|if
condition|(
name|ldrel
operator|->
name|l_symndx
operator|==
name|SYMNDX_BSS
condition|)
name|ldrel
operator|->
name|l_symndx
operator|=
name|SYMNDX_DATA
operator|,
name|dirty
operator|++
expr_stmt|;
if|if
condition|(
name|dirty
condition|)
block|{
name|lseek
argument_list|(
name|new
argument_list|,
name|load_scnptr
operator|+
name|LDHDRSZ
operator|+
name|LDSYMSZ
operator|*
name|ldhdr
operator|.
name|l_nsyms
operator|+
name|LDRELSZ
operator|*
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
name|ldrel
argument_list|,
name|LDRELSZ
argument_list|)
operator|!=
name|LDRELSZ
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ldrel
operator|->
name|l_rsecnm
operator|==
name|f_ohdr
operator|.
name|o_sndata
condition|)
block|{
name|int
name|orig_int
decl_stmt|;
name|lseek
argument_list|(
name|a_out
argument_list|,
name|orig_data_scnptr
operator|+
name|ldrel
operator|->
name|l_vaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|orig_int
argument_list|,
sizeof|sizeof
argument_list|(
name|orig_int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|orig_int
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ldrel
operator|->
name|l_symndx
condition|)
block|{
case|case
name|SYMNDX_TEXT
case|:
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|d_start
operator|+
name|ldrel
operator|->
name|l_vaddr
operator|)
expr_stmt|;
name|orig_int
operator|=
operator|*
name|p
operator|-
operator|(
name|t_start
operator|-
name|f_ohdr
operator|.
name|text_start
operator|)
expr_stmt|;
break|break;
case|case
name|SYMNDX_DATA
case|:
case|case
name|SYMNDX_BSS
case|:
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|d_start
operator|+
name|ldrel
operator|->
name|l_vaddr
operator|)
expr_stmt|;
name|orig_int
operator|=
operator|*
name|p
operator|-
operator|(
name|d_start
operator|-
name|f_ohdr
operator|.
name|data_start
operator|)
expr_stmt|;
break|break;
block|}
name|lseek
argument_list|(
name|new
argument_list|,
name|data_scnptr
operator|+
name|ldrel
operator|->
name|l_vaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|orig_int
argument_list|,
sizeof|sizeof
argument_list|(
name|orig_int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|orig_int
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XCOFF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_UNEXEC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_DUMP */
end_comment

end_unit

