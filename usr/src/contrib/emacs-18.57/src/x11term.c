begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* X Communication module for terminals which understand the X protocol.    Copyright (C) 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Yakim Martillo, mods and things by Robert Krawitz  */
end_comment

begin_comment
comment|/* Redone for X11 by Robert French */
end_comment

begin_comment
comment|/* Thanks to Mark Biggers for all of the Window Manager support */
end_comment

begin_comment
comment|/*  *	$Source: /mit/emacs/src/RCS/11xterm.c,v $  *	$Author: rfrench $  *	$Locker:  $  *	$Header: x11term.c,v 1.12 88/02/29 14:11:07 rfrench Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_xterm_c
init|=
literal|"$Header: x11term.c,v 1.12 88/02/29 14:11:07 rfrench Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* On 4.3 this loses if it comes after x11term.h.    On hp-ux it loses if it comes after config.h.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/* Load sys/types.h if not already loaded.    In some systems loading it twice is suicidal.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|makedev
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_comment
comment|/* Get FIONREAD, if it is available.    It would be logical to include<sys/ioctl.h> here,    but it was moved up above to avoid problems.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* Allow m- file to inhibit use of interrupt-driven input.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_FIONREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FIONREAD
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We are unable to use interrupts if FIONREAD is not available,    so flush SIGIO so we won't try.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FIONREAD
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_undef
undef|#
directive|undef
name|SIGIO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This may include sys/types.h, and that somehow loses    if this is not done before the other system files.    However, perhaps the problem has been avoided by loading types.h above.  */
end_comment

begin_include
include|#
directive|include
file|"x11term.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IRIS
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_comment
comment|/* for "minor" */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|UNIPLUS
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not IRIS, not UNIPLUS */
end_comment

begin_comment
comment|/* Use socket.h just to control whether to use time.h or sys/time.h.    This works like the code in process.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_comment
comment|/* _h_BSDTYPES is checked because on ISC unix, socket.h includes    both time.h and sys/time.h, and the latter file is protected    from repeated inclusion.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_h_BSDTYPES
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _h_BSDTYPES or not USG */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _h_BSDTYPES or not USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TIMEVAL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not UNIPLUS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not IRIS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BAT68K
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* In addition to time.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* In addition to time.h.  */
end_comment

begin_decl_stmt
specifier|static
name|KeySym
name|XMOD_Alt
index|[]
init|=
block|{
name|XK_Alt_L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KeySym
name|XMOD_Shift
index|[]
init|=
block|{
name|XK_Shift_L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KeySym
name|XMOD_ShiftAlt
index|[]
init|=
block|{
name|XK_Alt_L
block|,
name|XK_Shift_L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KeySym
name|XMOD_CtrlAlt
index|[]
init|=
block|{
name|XK_Control_L
block|,
name|XK_Alt_L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KeySym
name|XMOD_Ctrl
index|[]
init|=
block|{
name|XK_Control_L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KeySym
name|XMOD_CtrlShift
index|[]
init|=
block|{
name|XK_Control_L
block|,
name|XK_Shift_L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KeySym
name|XMOD_ShiftCtrlAlt
index|[]
init|=
block|{
name|XK_Control_L
block|,
name|XK_Alt_L
block|,
name|XK_Shift_L
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"sink11.h"
end_include

begin_include
include|#
directive|include
file|"sink11mask.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b) ? (a) : (b))
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sigunblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (0)
end_define

begin_define
define|#
directive|define
name|sigblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (1<< ((sig) - 1))
end_define

begin_define
define|#
directive|define
name|METABIT
value|0200
end_define

begin_define
define|#
directive|define
name|MINWIDTH
value|12
end_define

begin_comment
comment|/* In pixels */
end_comment

begin_define
define|#
directive|define
name|MINHEIGHT
value|5
end_define

begin_comment
comment|/* In pixels */
end_comment

begin_define
define|#
directive|define
name|MAXHEIGHT
value|300
end_define

begin_comment
comment|/* In lines */
end_comment

begin_decl_stmt
name|int
name|pixelwidth
decl_stmt|,
name|pixelheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XEvent
modifier|*
name|XXm_queue
index|[
name|XMOUSEBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXm_queue_num
decl_stmt|,
name|XXm_queue_in
decl_stmt|,
name|XXm_queue_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|XXcurrentfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XFontStruct
modifier|*
name|fontinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Font
name|XXfid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXfontw
decl_stmt|,
name|XXfonth
decl_stmt|,
name|XXbase
decl_stmt|,
name|XXisColor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means Emacs has explicit keyboard focus.  */
end_comment

begin_decl_stmt
name|int
name|x_focus_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Colormap
name|XXColorMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|default_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|configure_pending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_width
decl_stmt|,
name|screen_height
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function for init_keyboard to call with no args (if nonzero).  */
end_comment

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|keyboard_init_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|alternate_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|xargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|xargv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXdebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|WindowMapped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|XXidentity
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Resource name of this invocation of Emacs */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|XXicon_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user-supplied icon info */
end_comment

begin_decl_stmt
specifier|static
name|int
name|XXicon_usebitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use bitmap or not */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|XXheader
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user-supplied window header info */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flexlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last line affected by dellines or 				 * inslines functions */
end_comment

begin_decl_stmt
name|int
name|VisibleX
decl_stmt|,
name|VisibleY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* genuine location of cursor on screen 				 * if it is there */
end_comment

begin_comment
comment|/* Last cursor position specified by move_cursor.    During an update, this does not display a cursor on the screen;    But it controls the position that is output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local_cursor_hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_cursor_vpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SavedX
decl_stmt|,
name|SavedY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where the cursor was before update 				 * started */
end_comment

begin_decl_stmt
name|int
name|CursorExists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* during updates cursor is turned off */
end_comment

begin_decl_stmt
name|int
name|CursorOutline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when the pointer is not in the Emacs     	    	    	    	 * widow the cursor should be drawn in     	    	    	         * outline form a la xterm */
end_comment

begin_decl_stmt
specifier|static
name|int
name|InUpdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* many of functions here may be invoked 				 * even if no update in progress; when 				 * no update is in progress the action 				 * can be slightly different */
end_comment

begin_decl_stmt
name|Display
modifier|*
name|XXdisplay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|XXscreen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
name|XXwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GC
name|XXgc_norm
decl_stmt|,
name|XXgc_rev
decl_stmt|,
name|XXgc_curs
decl_stmt|,
name|XXgc_temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XGCValues
name|XXgcv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cursor
name|EmacsCursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Pixmap
name|SinkPixmap
decl_stmt|,
name|SinkMaskPixmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fore_color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables to store color names */
end_comment

begin_decl_stmt
name|char
modifier|*
name|back_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|brdr_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|curs_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mous_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|fore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables to store pixel values */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|back
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|brdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|curs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|desiredwindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CurHL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current Highlighting (ala mode line) */
end_comment

begin_decl_stmt
name|int
name|XXborder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Window border width */
end_comment

begin_decl_stmt
name|int
name|XXInternalBorder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal border width */
end_comment

begin_decl_stmt
name|int
name|updated
index|[
name|MAXHEIGHT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_font
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needed because of loading hacks */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_reverseVideo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_borderWidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_internalBorder
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_useBitmap
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|_xdeftab
block|{
name|char
modifier|*
name|iname
decl_stmt|;
comment|/* instance name */
name|char
modifier|*
name|cname
decl_stmt|;
comment|/* class name (fake it) */
name|char
modifier|*
modifier|*
name|varp
decl_stmt|;
comment|/* variable to set */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|_xdeftab
name|xDefaultsValueTable
index|[]
init|=
block|{
block|{
literal|"reverseVideo"
block|,
literal|"ReverseVideo"
block|,
operator|&
name|temp_reverseVideo
block|}
block|,
block|{
literal|"borderWidth"
block|,
literal|"BorderWidth"
block|,
operator|&
name|temp_borderWidth
block|}
block|,
block|{
literal|"internalBorder"
block|,
literal|"BorderWidth"
block|,
operator|&
name|temp_internalBorder
block|}
block|,
block|{
literal|"bitmapIcon"
block|,
literal|"BitmapIcon"
block|,
operator|&
name|temp_useBitmap
block|}
block|,
block|{
literal|"borderColor"
block|,
literal|"BorderColor"
block|,
operator|&
name|brdr_color
block|}
block|,
block|{
literal|"background"
block|,
literal|"Background"
block|,
operator|&
name|back_color
block|}
block|,
block|{
literal|"foreground"
block|,
literal|"Foreground"
block|,
operator|&
name|fore_color
block|}
block|,
block|{
literal|"pointerColor"
block|,
literal|"Foreground"
block|,
operator|&
name|mous_color
block|}
block|,
block|{
literal|"cursorColor"
block|,
literal|"Foreground"
block|,
operator|&
name|curs_color
block|}
block|,
block|{
literal|"font"
block|,
literal|"Font"
block|,
operator|&
name|temp_font
block|}
block|,
block|{
literal|"geometry"
block|,
literal|"Geometry"
block|,
operator|&
name|desiredwindow
block|}
block|,
block|{
literal|"title"
block|,
literal|"Title"
block|,
operator|&
name|XXheader
block|}
block|,
block|{
literal|"iconName"
block|,
literal|"Title"
block|,
operator|&
name|XXicon_name
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|x_init_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* HLmode -- Changes the GX function for output strings.  Could be used to  * change font.  Check an XText library function call.  */
end_comment

begin_macro
name|HLmode
argument_list|(
argument|new
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|Lisp_Object
name|inverse_video
decl_stmt|;
name|CurHL
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_comment
comment|/* External interface to control of standout mode.    Call this when about to modify line at position VPOS    and not change whether it is highlighted.  */
end_comment

begin_macro
name|XTreassert_line_highlight
argument_list|(
argument|highlight
argument_list|,
argument|vpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|highlight
decl_stmt|,
name|vpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HLmode
argument_list|(
name|highlight
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Call this when about to modify line at position VPOS    and change whether it is highlighted.  */
end_comment

begin_macro
name|XTchange_line_highlight
argument_list|(
argument|new_highlight
argument_list|,
argument|vpos
argument_list|,
argument|first_unused_hpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new_highlight
decl_stmt|,
name|vpos
decl_stmt|,
name|first_unused_hpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HLmode
argument_list|(
name|new_highlight
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x_clear_end_of_line
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Used for starting or restarting (after suspension) the X window.  Puts the  * cursor in a known place, update does not begin with this routine but only  * with a call to redisplay.  */
end_comment

begin_macro
name|XTset_terminal_modes
argument_list|()
end_macro

begin_block
block|{
name|int
name|stuffpending
decl_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTset_terminal_modes\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|InUpdate
operator|=
literal|0
expr_stmt|;
name|stuffpending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|CursorOutline
operator|=
literal|1
expr_stmt|;
name|VisibleX
operator|=
literal|0
expr_stmt|;
name|VisibleY
operator|=
literal|0
expr_stmt|;
block|}
name|XTclear_screen
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* XTmove_cursor moves the cursor to the correct location and checks whether an  * update is in progress in order to toggle it on.  */
end_comment

begin_expr_stmt
name|XTmove_cursor
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
specifier|register
name|int
name|row
operator|,
name|col
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTmove_cursor (X %d, Y %d)\n"
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|local_cursor_hpos
operator|=
name|col
expr_stmt|;
name|local_cursor_vpos
operator|=
name|row
expr_stmt|;
if|if
condition|(
name|InUpdate
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
comment|/* Generally, XTmove_cursor will be invoked */
comment|/* when InUpdate with !CursorExists */
comment|/* so that wasteful XFlush is not called */
block|}
if|if
condition|(
operator|(
name|row
operator|==
name|VisibleY
operator|)
operator|&&
operator|(
name|col
operator|==
name|VisibleX
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|VisibleX
operator|=
name|col
expr_stmt|;
name|VisibleY
operator|=
name|row
expr_stmt|;
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Used to get the terminal back to a known state after resets.  Usually  * used when restarting suspended or waiting emacs  */
end_comment

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
name|inverse_video
operator|=
literal|0
expr_stmt|;
name|HLmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Erase current line from current column to column END.    Leave cursor at END.  */
end_comment

begin_expr_stmt
name|XTclear_end_of_line
argument_list|(
name|end
argument_list|)
specifier|register
name|int
name|end
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|numcols
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTclear_end_of_line (to %d)\n"
argument_list|,
name|end
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|local_cursor_vpos
operator|<
literal|0
operator|||
name|local_cursor_vpos
operator|>=
name|screen_height
condition|)
return|return;
if|if
condition|(
name|end
operator|<=
name|local_cursor_hpos
condition|)
return|return;
if|if
condition|(
name|end
operator|>=
name|screen_width
condition|)
name|end
operator|=
name|screen_width
expr_stmt|;
name|numcols
operator|=
name|end
operator|-
name|local_cursor_hpos
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_cursor_vpos
operator|==
name|VisibleY
operator|&&
name|VisibleX
operator|>=
name|local_cursor_hpos
operator|&&
name|VisibleX
operator|<
name|end
condition|)
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
if|if
condition|(
name|CurHL
condition|)
name|XFillRectangle
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_norm
argument_list|,
name|local_cursor_hpos
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|local_cursor_vpos
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|XXfontw
operator|*
name|numcols
argument_list|,
name|XXfonth
argument_list|)
expr_stmt|;
else|else
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|local_cursor_hpos
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|local_cursor_vpos
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|XXfontw
operator|*
name|numcols
argument_list|,
name|XXfonth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|local_cursor_vpos
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Erase current line from column START to right margin.    Leave cursor at START.  */
end_comment

begin_expr_stmt
name|x_clear_end_of_line
argument_list|(
name|start
argument_list|)
specifier|register
name|int
name|start
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|numcols
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"x_clear_end_of_line (start %d)\n"
argument_list|,
name|start
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|local_cursor_vpos
operator|<
literal|0
operator|||
name|local_cursor_vpos
operator|>=
name|screen_height
condition|)
return|return;
if|if
condition|(
name|start
operator|>=
name|screen_width
condition|)
return|return;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
name|numcols
operator|=
name|screen_width
operator|-
name|start
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_cursor_vpos
operator|==
name|VisibleY
operator|&&
name|VisibleX
operator|>=
name|start
condition|)
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
if|if
condition|(
name|CurHL
condition|)
name|XFillRectangle
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_norm
argument_list|,
name|start
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|local_cursor_vpos
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|XXfontw
operator|*
name|numcols
argument_list|,
name|XXfonth
argument_list|)
expr_stmt|;
else|else
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|start
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|local_cursor_vpos
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|XXfontw
operator|*
name|numcols
argument_list|,
name|XXfonth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|local_cursor_vpos
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|XTreset_terminal_modes
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTreset_terminal_modes\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XTclear_screen
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|XTclear_screen
argument_list|()
end_macro

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTclear_screen\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|HLmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|local_cursor_hpos
operator|=
literal|0
expr_stmt|;
name|local_cursor_vpos
operator|=
literal|0
expr_stmt|;
name|SavedX
operator|=
literal|0
expr_stmt|;
name|SavedY
operator|=
literal|0
expr_stmt|;
name|VisibleX
operator|=
literal|0
expr_stmt|;
name|VisibleY
operator|=
literal|0
expr_stmt|;
name|XClearWindow
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|)
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|InUpdate
condition|)
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* used by dumprectangle which is usually invoked upon Expose  * events which come from bit blt's or moving an obscuring opaque window  */
end_comment

begin_expr_stmt
name|dumpchars
argument_list|(
name|active_screen
argument_list|,
name|numcols
argument_list|,
name|tempX
argument_list|,
name|tempY
argument_list|,
name|tempHL
argument_list|)
specifier|register
expr|struct
name|matrix
operator|*
name|active_screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|numcols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|tempX
decl_stmt|,
name|tempY
decl_stmt|,
name|tempHL
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|numcols
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|numcols
operator|-
literal|1
operator|+
name|tempX
operator|>
name|screen_width
condition|)
name|numcols
operator|=
name|screen_width
operator|-
name|tempX
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tempX
operator|<
literal|0
operator|||
name|tempX
operator|>=
name|screen_width
operator|||
name|tempY
operator|<
literal|0
operator|||
name|tempY
operator|>=
name|screen_height
condition|)
return|return;
name|XDrawImageString
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|tempHL
condition|?
name|XXgc_rev
else|:
name|XXgc_norm
argument_list|,
name|tempX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|tempY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
operator|+
name|XXbase
argument_list|,
operator|&
name|active_screen
operator|->
name|contents
index|[
name|tempY
index|]
index|[
name|tempX
index|]
argument_list|,
name|numcols
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* When a line has been changed this function is called.  Due to various  * bits of braindamage on the parts of both X11 and Emacs, the new  * version of the line is simply output if this function is invoked while  * in UpDate.  Sometimes writechars can be invoked when not in update if  * text is to be output at the end of the line.  In this case the whole  * line is not output.  Simply the new text at the current cursor  * position given by VisibleX,Y.  The cursor is moved to the end of the  * new text.  */
end_comment

begin_macro
name|updateline
argument_list|(
argument|first
argument_list|)
end_macro

begin_decl_stmt
name|int
name|first
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|temp_length
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"updateline\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|XDEBUG
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|local_cursor_vpos
operator|<
literal|0
operator|)
operator|||
operator|(
name|local_cursor_vpos
operator|>=
name|screen_height
operator|)
operator|||
name|updated
index|[
name|local_cursor_vpos
index|]
condition|)
block|{
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|updated
index|[
name|local_cursor_vpos
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_screen
operator|->
name|enable
index|[
name|local_cursor_vpos
index|]
condition|)
name|temp_length
operator|=
name|new_screen
operator|->
name|used
index|[
name|local_cursor_vpos
index|]
operator|-
name|first
expr_stmt|;
else|else
name|temp_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp_length
operator|>
literal|0
condition|)
block|{
name|XDrawImageString
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|CurHL
condition|?
name|XXgc_rev
else|:
name|XXgc_norm
argument_list|,
name|first
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|local_cursor_vpos
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
operator|+
name|XXbase
argument_list|,
operator|&
name|new_screen
operator|->
name|contents
index|[
name|local_cursor_vpos
index|]
index|[
name|first
index|]
argument_list|,
name|temp_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_length
operator|<
name|screen_width
condition|)
name|x_clear_end_of_line
argument_list|(
name|temp_length
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|local_cursor_vpos
argument_list|,
name|temp_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x_clear_end_of_line
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|local_cursor_vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|writechars
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
specifier|register
name|char
operator|*
name|start
operator|,
operator|*
name|end
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"writechars (local_cursor_hpos %d temp_len %d InUpd %d)\n"
argument_list|,
name|local_cursor_hpos
argument_list|,
name|end
operator|-
name|start
operator|+
literal|1
argument_list|,
name|InUpdate
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|XDEBUG
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|local_cursor_vpos
operator|<
literal|0
operator|)
operator|||
operator|(
name|local_cursor_vpos
operator|>=
name|screen_height
operator|)
condition|)
block|{
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
if|if
condition|(
name|InUpdate
condition|)
block|{
name|XDrawImageString
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|CurHL
condition|?
name|XXgc_rev
else|:
name|XXgc_norm
argument_list|,
name|local_cursor_hpos
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|local_cursor_vpos
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
operator|+
name|XXbase
argument_list|,
name|start
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XTmove_cursor
argument_list|(
name|local_cursor_vpos
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|VisibleX
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleX
operator|>=
name|screen_width
operator|)
condition|)
block|{
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|VisibleY
operator|<
literal|0
operator|)
operator|||
operator|(
name|VisibleY
operator|>=
name|screen_height
operator|)
condition|)
block|{
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
name|VisibleX
operator|)
operator|>=
name|screen_width
condition|)
name|end
operator|=
name|start
operator|+
operator|(
name|screen_width
operator|-
operator|(
name|VisibleX
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|end
operator|>=
name|start
condition|)
block|{
name|XDrawImageString
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|CurHL
condition|?
name|XXgc_rev
else|:
name|XXgc_norm
argument_list|,
operator|(
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
operator|)
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
operator|+
name|XXbase
argument_list|,
name|start
argument_list|,
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|VisibleX
operator|=
name|VisibleX
operator|+
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XToutput_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|start
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XToutput_chars (len %d)\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|writechars
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|XTflash
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
ifdef|#
directive|ifdef
name|HAVE_SELECT
name|XGCValues
name|gcv_temp
decl_stmt|;
name|struct
name|timeval
name|to
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTflash\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XXgc_temp
operator|=
name|XCreateGC
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
literal|0
argument_list|,
operator|&
name|gcv_temp
argument_list|)
expr_stmt|;
name|XSetState
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_temp
argument_list|,
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
argument_list|,
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
argument_list|,
name|GXinvert
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XFillRectangle
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_temp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
operator|*
name|XXfontw
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|screen_height
operator|*
name|XXfonth
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
name|to
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|to
operator|.
name|tv_usec
operator|=
literal|250000
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XFillRectangle
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_temp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
operator|*
name|XXfontw
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|screen_height
operator|*
name|XXfonth
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|)
expr_stmt|;
name|XFreeGC
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_temp
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_macro
name|XTfeep
argument_list|()
end_macro

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTfeep\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XBell
argument_list|(
name|XXdisplay
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Artificially creating a cursor is hard, the actual position on the  * screen (either where it is or last was) is tracked with VisibleX,Y.  * Gnu Emacs code tends to assume a cursor exists in hardward at local_cursor_hpos,Y  * and that output text will appear there.  During updates, the cursor is  * supposed to be blinked out and will only reappear after the update  * finishes.  */
end_comment

begin_macro
name|CursorToggle
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|matrix
modifier|*
name|active_screen
decl_stmt|;
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|CursorOutline
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/* Currently the return values are not */
comment|/* used, but I could anticipate using */
comment|/* them in the future. */
block|}
if|if
condition|(
name|VisibleX
operator|<
literal|0
operator|||
name|VisibleX
operator|>=
name|screen_width
operator|||
name|VisibleY
operator|<
literal|0
operator|||
name|VisibleY
operator|>=
name|screen_height
condition|)
block|{
comment|/* Not much can be done */
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|active_screen
operator|=
name|current_screen
expr_stmt|;
if|if
condition|(
name|active_screen
operator|->
name|highlight
index|[
name|VisibleY
index|]
condition|)
comment|/* If the cursor is in the modeline, it means display was preempted. 	     Don't actually display the cursor there, just say we did. 	     The code below doesn't display it right, and nobody wants 	     to see it anyway.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|active_screen
operator|->
name|enable
index|[
name|VisibleY
index|]
operator|&&
name|VisibleX
operator|<
name|active_screen
operator|->
name|used
index|[
name|VisibleY
index|]
condition|)
block|{
if|if
condition|(
name|CursorExists
condition|)
name|XDrawImageString
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_norm
argument_list|,
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
operator|+
name|XXbase
argument_list|,
operator|&
name|active_screen
operator|->
name|contents
index|[
name|VisibleY
index|]
index|[
name|VisibleX
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CursorOutline
condition|)
block|{
name|XDrawImageString
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_norm
argument_list|,
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
operator|+
name|XXbase
argument_list|,
operator|&
name|active_screen
operator|->
name|contents
index|[
name|VisibleY
index|]
index|[
name|VisibleX
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XDrawRectangle
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_norm
argument_list|,
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|XXfontw
operator|-
literal|1
argument_list|,
name|XXfonth
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|XDrawImageString
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_curs
argument_list|,
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
operator|+
name|XXbase
argument_list|,
operator|&
name|active_screen
operator|->
name|contents
index|[
name|VisibleY
index|]
index|[
name|VisibleX
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CursorExists
condition|)
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|XXfontw
argument_list|,
name|XXfonth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CursorOutline
condition|)
name|XDrawRectangle
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_norm
argument_list|,
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|XXfontw
operator|-
literal|1
argument_list|,
name|XXfonth
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|XDrawImageString
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_curs
argument_list|,
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
operator|+
name|XXbase
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|CursorExists
operator|=
operator|!
name|CursorExists
expr_stmt|;
if|if
condition|(
operator|!
name|InUpdate
condition|)
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* This routine is used by routines which are called to paint regions */
end_comment

begin_comment
comment|/* designated by Expose events.  If the cursor may be in the exposed */
end_comment

begin_comment
comment|/* region, this routine makes sure it is gone so that dumprectangle can */
end_comment

begin_comment
comment|/* toggle it back into existance if dumprectangle is invoked when not in */
end_comment

begin_comment
comment|/* the midst of a screen update. */
end_comment

begin_expr_stmt
specifier|static
name|ClearCursor
argument_list|()
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
block|;
name|BLOCK_INPUT
argument_list|()
block|;
if|if
condition|(
operator|!
name|WindowMapped
condition|)
block|{
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|CursorOutline
operator|=
literal|1
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|VisibleX
operator|<
literal|0
operator|||
name|VisibleX
operator|>=
name|screen_width
operator|||
name|VisibleY
operator|<
literal|0
operator|||
name|VisibleY
operator|>=
name|screen_height
condition|)
block|{
comment|/* Not much can be done */
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return;
block|}
end_if

begin_expr_stmt
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|VisibleX
operator|*
name|XXfontw
operator|+
name|XXInternalBorder
argument_list|,
name|VisibleY
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|XXfontw
argument_list|,
name|XXfonth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CursorExists
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  XTupdate_begin
operator|(
operator|)
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
block|;
specifier|register
name|int
name|i
block|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTupdate_begin\n"
argument_list|)
block|;
endif|#
directive|endif
name|BLOCK_INPUT
argument_list|()
block|;
name|InUpdate
operator|=
literal|1
block|;
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXHEIGHT
condition|;
name|i
operator|++
control|)
name|updated
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
end_for

begin_expr_stmt
name|SavedX
operator|=
name|local_cursor_hpos
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SavedY
operator|=
name|local_cursor_vpos
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Thw initial "hardware" cursor position is */
end_comment

begin_comment
comment|/* saved because that is where gnu emacs */
end_comment

begin_comment
comment|/* expects the cursor to be at the end of */
end_comment

begin_comment
comment|/* the update */
end_comment

begin_expr_stmt
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  XTupdate_end
operator|(
operator|)
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
block|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTupdate_end\n"
argument_list|)
block|;
endif|#
directive|endif
name|BLOCK_INPUT
argument_list|()
block|;
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|InUpdate
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Display cursor at last place requested.  */
end_comment

begin_expr_stmt
name|XTmove_cursor
argument_list|(
name|local_cursor_vpos
argument_list|,
name|local_cursor_hpos
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Used for Expose events.  Have to get the text  * back into the newly blank areas.  */
end_comment

begin_expr_stmt
unit|dumprectangle
operator|(
name|top
operator|,
name|left
operator|,
name|rows
operator|,
name|cols
operator|)
specifier|register
name|int
name|top
operator|,
name|left
operator|,
name|rows
operator|,
name|cols
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|matrix
modifier|*
name|active_screen
decl_stmt|;
specifier|register
name|int
name|ourindex
decl_stmt|;
name|int
name|localX
decl_stmt|,
name|localY
decl_stmt|,
name|localHL
decl_stmt|;
if|if
condition|(
name|top
operator|<
literal|0
condition|)
name|top
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
condition|)
name|left
operator|=
literal|0
expr_stmt|;
name|rows
operator|+=
name|top
expr_stmt|;
name|cols
operator|+=
name|left
expr_stmt|;
name|top
operator|/=
name|XXfonth
expr_stmt|;
comment|/* Get row and col containing up and */
comment|/* left borders of exposed region -- */
comment|/* round down here*/
name|left
operator|/=
name|XXfontw
expr_stmt|;
name|rows
operator|+=
name|XXfonth
operator|-
literal|1
expr_stmt|;
name|cols
operator|+=
name|XXfontw
operator|-
literal|1
expr_stmt|;
name|rows
operator|/=
name|XXfonth
expr_stmt|;
comment|/* Get row and col containing bottom and */
comment|/* right borders -- round up here */
name|rows
operator|-=
name|top
expr_stmt|;
name|cols
operator|/=
name|XXfontw
expr_stmt|;
name|cols
operator|-=
name|left
expr_stmt|;
if|if
condition|(
name|rows
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|cols
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|top
operator|>
name|screen_height
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|left
operator|>
name|screen_width
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|VisibleX
operator|>=
name|left
operator|&&
name|VisibleX
operator|<
name|left
operator|+
name|cols
operator|&&
name|VisibleY
operator|>=
name|top
operator|&&
name|VisibleY
operator|<
name|top
operator|+
name|rows
condition|)
name|ClearCursor
argument_list|()
expr_stmt|;
if|if
condition|(
name|InUpdate
condition|)
name|active_screen
operator|=
name|new_screen
expr_stmt|;
else|else
comment|/* When queue is dumped in update this */
name|active_screen
operator|=
name|current_screen
expr_stmt|;
for|for
control|(
name|localY
operator|=
name|top
operator|,
name|ourindex
operator|=
literal|0
init|;
name|ourindex
operator|<
name|rows
operator|&&
name|localY
operator|<
name|screen_height
condition|;
operator|++
name|ourindex
operator|,
operator|++
name|localY
control|)
block|{
if|if
condition|(
name|localY
operator|<
literal|0
operator|||
name|localY
operator|>=
name|screen_height
operator|||
operator|!
name|active_screen
operator|->
name|enable
index|[
name|localY
index|]
operator|||
name|left
operator|+
literal|1
operator|>
name|active_screen
operator|->
name|used
index|[
name|localY
index|]
condition|)
continue|continue;
name|localX
operator|=
name|left
expr_stmt|;
name|localHL
operator|=
name|active_screen
operator|->
name|highlight
index|[
name|localY
index|]
expr_stmt|;
name|dumpchars
argument_list|(
name|active_screen
argument_list|,
name|min
argument_list|(
name|cols
argument_list|,
name|active_screen
operator|->
name|used
index|[
name|localY
index|]
operator|-
name|localX
argument_list|)
argument_list|,
name|localX
argument_list|,
name|localY
argument_list|,
name|localHL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|InUpdate
operator|&&
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
comment|/* Routine usually called */
comment|/* when not in update */
block|}
end_block

begin_comment
comment|/* What sections of the window will be modified from the UpdateDisplay  * routine is totally under software control.  Any line with Y coordinate  * greater than flexlines will not change during an update.  This is really  * used only during dellines and inslines routines (scraplines and stufflines)  */
end_comment

begin_expr_stmt
name|XTset_terminal_window
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTset_terminal_window\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|n
operator|>
name|screen_height
condition|)
name|flexlines
operator|=
name|screen_height
expr_stmt|;
else|else
name|flexlines
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|XTins_del_lines
argument_list|(
argument|vpos
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vpos
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTins_del_lines\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XTmove_cursor
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|stufflines
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|scraplines
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Estimate the cost of scrolling as equal to drawing one fifth    of the character cells copied if black and white,    or half of those characters if color.  */
end_comment

begin_expr_stmt
specifier|static
name|XTcalculate_costs
argument_list|(
argument|extra
argument_list|,
argument|costvec
argument_list|,
argument|ncostvec
argument_list|)
name|int
name|extra
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|costvec
decl_stmt|,
modifier|*
name|ncostvec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|color_p
init|=
name|DisplayCells
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
operator|>
literal|2
decl_stmt|;
name|CalcLID
argument_list|(
literal|0
argument_list|,
name|screen_width
operator|/
operator|(
name|color_p
condition|?
literal|2
else|:
literal|5
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTinsert_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|start
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTinsert_chars\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|updateline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|XTdelete_chars
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|msg
init|=
literal|"Major foobars!  This shouldn't show up!"
decl_stmt|;
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTdelete_chars (num %d local_cursor_hpos %d)\n"
argument_list|,
name|n
argument_list|,
name|local_cursor_hpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|updateline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|stufflines
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|topregion
decl_stmt|,
name|bottomregion
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|,
name|newtop
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_cursor_vpos
operator|>=
name|flexlines
condition|)
return|return;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|topregion
operator|=
name|local_cursor_vpos
expr_stmt|;
name|bottomregion
operator|=
name|flexlines
operator|-
operator|(
name|n
operator|+
literal|1
operator|)
expr_stmt|;
name|newtop
operator|=
name|local_cursor_vpos
operator|+
name|n
expr_stmt|;
name|length
operator|=
name|bottomregion
operator|-
name|topregion
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|newtop
operator|<=
name|flexlines
condition|)
block|{
name|XCopyArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_norm
argument_list|,
name|XXInternalBorder
argument_list|,
name|topregion
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|XXfontw
argument_list|,
name|length
operator|*
name|XXfonth
argument_list|,
name|XXInternalBorder
argument_list|,
name|newtop
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|)
expr_stmt|;
block|}
name|newtop
operator|=
name|min
argument_list|(
name|newtop
argument_list|,
name|flexlines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|length
operator|=
name|newtop
operator|-
name|topregion
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXInternalBorder
argument_list|,
name|topregion
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|XXfontw
argument_list|,
name|n
operator|*
name|XXfonth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|scraplines
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_cursor_vpos
operator|>=
name|flexlines
condition|)
return|return;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
if|if
condition|(
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_cursor_vpos
operator|+
name|n
operator|>=
name|flexlines
condition|)
block|{
if|if
condition|(
name|flexlines
operator|>=
operator|(
name|local_cursor_vpos
operator|+
literal|1
operator|)
condition|)
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXInternalBorder
argument_list|,
name|local_cursor_vpos
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|XXfontw
argument_list|,
operator|(
name|flexlines
operator|-
name|local_cursor_vpos
operator|)
operator|*
name|XXfonth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|XCopyArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXwindow
argument_list|,
name|XXgc_norm
argument_list|,
name|XXInternalBorder
argument_list|,
operator|(
name|local_cursor_vpos
operator|+
name|n
operator|)
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|XXfontw
argument_list|,
operator|(
name|flexlines
operator|-
name|local_cursor_vpos
operator|-
name|n
operator|)
operator|*
name|XXfonth
argument_list|,
name|XXInternalBorder
argument_list|,
name|local_cursor_vpos
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|)
expr_stmt|;
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|XXInternalBorder
argument_list|,
operator|(
name|flexlines
operator|-
name|n
operator|)
operator|*
name|XXfonth
operator|+
name|XXInternalBorder
argument_list|,
name|screen_width
operator|*
name|XXfontw
argument_list|,
name|n
operator|*
name|XXfonth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Substitutes for standard read routine.  Under X not interested in individual  * bytes but rather individual packets.  */
end_comment

begin_expr_stmt
name|XTread_socket
argument_list|(
name|sd
argument_list|,
name|bufp
argument_list|,
name|numchars
argument_list|)
specifier|register
name|int
name|sd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|numchars
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XTread_socket\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|internal_socket_read
argument_list|(
name|bufp
argument_list|,
name|numchars
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interpreting incoming keycodes. Should have table modifiable as needed  * from elisp.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_function
name|char
modifier|*
name|stringFuncVal
parameter_list|(
name|keycode
parameter_list|)
name|KeySym
name|keycode
decl_stmt|;
block|{
switch|switch
condition|(
name|keycode
condition|)
block|{
case|case
name|XK_L1
case|:
return|return
operator|(
literal|"192"
operator|)
return|;
case|case
name|XK_L2
case|:
return|return
operator|(
literal|"193"
operator|)
return|;
case|case
name|XK_L3
case|:
return|return
operator|(
literal|"194"
operator|)
return|;
case|case
name|XK_L4
case|:
return|return
operator|(
literal|"195"
operator|)
return|;
case|case
name|XK_L5
case|:
return|return
operator|(
literal|"196"
operator|)
return|;
case|case
name|XK_L6
case|:
return|return
operator|(
literal|"197"
operator|)
return|;
case|case
name|XK_L7
case|:
return|return
operator|(
literal|"198"
operator|)
return|;
case|case
name|XK_L8
case|:
return|return
operator|(
literal|"199"
operator|)
return|;
case|case
name|XK_L9
case|:
return|return
operator|(
literal|"200"
operator|)
return|;
case|case
name|XK_L10
case|:
return|return
operator|(
literal|"201"
operator|)
return|;
case|case
name|XK_R1
case|:
return|return
operator|(
literal|"208"
operator|)
return|;
case|case
name|XK_R2
case|:
return|return
operator|(
literal|"209"
operator|)
return|;
case|case
name|XK_R3
case|:
return|return
operator|(
literal|"210"
operator|)
return|;
case|case
name|XK_R4
case|:
return|return
operator|(
literal|"211"
operator|)
return|;
case|case
name|XK_R5
case|:
return|return
operator|(
literal|"212"
operator|)
return|;
case|case
name|XK_R6
case|:
return|return
operator|(
literal|"213"
operator|)
return|;
case|case
name|XK_R7
case|:
return|return
operator|(
literal|"214"
operator|)
return|;
case|case
name|XK_R8
case|:
return|return
operator|(
literal|"215"
operator|)
return|;
case|case
name|XK_R9
case|:
return|return
operator|(
literal|"216"
operator|)
return|;
case|case
name|XK_R10
case|:
return|return
operator|(
literal|"217"
operator|)
return|;
case|case
name|XK_R11
case|:
return|return
operator|(
literal|"218"
operator|)
return|;
case|case
name|XK_R12
case|:
return|return
operator|(
literal|"219"
operator|)
return|;
case|case
name|XK_R13
case|:
return|return
operator|(
literal|"220"
operator|)
return|;
case|case
name|XK_R14
case|:
return|return
operator|(
literal|"221"
operator|)
return|;
case|case
name|XK_R15
case|:
return|return
operator|(
literal|"222"
operator|)
return|;
case|case
name|XK_Break
case|:
comment|/* Sun3 "Alternate" key */
return|return
operator|(
literal|"223"
operator|)
return|;
case|case
name|XK_F1
case|:
return|return
operator|(
literal|"224"
operator|)
return|;
case|case
name|XK_F2
case|:
return|return
operator|(
literal|"225"
operator|)
return|;
case|case
name|XK_F3
case|:
return|return
operator|(
literal|"226"
operator|)
return|;
case|case
name|XK_F4
case|:
return|return
operator|(
literal|"227"
operator|)
return|;
case|case
name|XK_F5
case|:
return|return
operator|(
literal|"228"
operator|)
return|;
case|case
name|XK_F6
case|:
return|return
operator|(
literal|"229"
operator|)
return|;
case|case
name|XK_F7
case|:
return|return
operator|(
literal|"230"
operator|)
return|;
case|case
name|XK_F8
case|:
return|return
operator|(
literal|"231"
operator|)
return|;
case|case
name|XK_F9
case|:
return|return
operator|(
literal|"232"
operator|)
return|;
default|default:
return|return
operator|(
literal|"-1"
operator|)
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|AIX
end_ifndef

begin_function
name|char
modifier|*
name|stringFuncVal
parameter_list|(
name|keycode
parameter_list|)
name|KeySym
name|keycode
decl_stmt|;
block|{
switch|switch
condition|(
name|keycode
condition|)
block|{
case|case
name|XK_F1
case|:
return|return
operator|(
literal|"11"
operator|)
return|;
case|case
name|XK_F2
case|:
return|return
operator|(
literal|"12"
operator|)
return|;
case|case
name|XK_F3
case|:
return|return
operator|(
literal|"13"
operator|)
return|;
case|case
name|XK_F4
case|:
return|return
operator|(
literal|"14"
operator|)
return|;
case|case
name|XK_F5
case|:
return|return
operator|(
literal|"15"
operator|)
return|;
case|case
name|XK_F6
case|:
return|return
operator|(
literal|"17"
operator|)
return|;
case|case
name|XK_F7
case|:
return|return
operator|(
literal|"18"
operator|)
return|;
case|case
name|XK_F8
case|:
return|return
operator|(
literal|"19"
operator|)
return|;
case|case
name|XK_F9
case|:
return|return
operator|(
literal|"20"
operator|)
return|;
case|case
name|XK_F10
case|:
return|return
operator|(
literal|"21"
operator|)
return|;
case|case
name|XK_F11
case|:
return|return
operator|(
literal|"23"
operator|)
return|;
case|case
name|XK_F12
case|:
return|return
operator|(
literal|"24"
operator|)
return|;
case|case
name|XK_F13
case|:
return|return
operator|(
literal|"25"
operator|)
return|;
case|case
name|XK_F14
case|:
return|return
operator|(
literal|"26"
operator|)
return|;
case|case
name|XK_F15
case|:
return|return
operator|(
literal|"28"
operator|)
return|;
case|case
name|XK_Help
case|:
return|return
operator|(
literal|"28"
operator|)
return|;
case|case
name|XK_F16
case|:
return|return
operator|(
literal|"29"
operator|)
return|;
case|case
name|XK_Menu
case|:
return|return
operator|(
literal|"29"
operator|)
return|;
case|case
name|XK_F17
case|:
return|return
operator|(
literal|"31"
operator|)
return|;
case|case
name|XK_F18
case|:
return|return
operator|(
literal|"32"
operator|)
return|;
case|case
name|XK_F19
case|:
return|return
operator|(
literal|"33"
operator|)
return|;
case|case
name|XK_F20
case|:
return|return
operator|(
literal|"34"
operator|)
return|;
case|case
name|XK_Find
case|:
return|return
operator|(
literal|"1"
operator|)
return|;
case|case
name|XK_Insert
case|:
return|return
operator|(
literal|"2"
operator|)
return|;
case|case
name|XK_Delete
case|:
return|return
operator|(
literal|"3"
operator|)
return|;
case|case
name|XK_Select
case|:
return|return
operator|(
literal|"4"
operator|)
return|;
case|case
name|XK_Prior
case|:
return|return
operator|(
literal|"5"
operator|)
return|;
case|case
name|XK_Next
case|:
return|return
operator|(
literal|"6"
operator|)
return|;
default|default:
return|return
operator|(
literal|"-1"
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not sun */
end_comment

begin_expr_stmt
name|internal_socket_read
argument_list|(
name|bufp
argument_list|,
name|numchars
argument_list|)
specifier|register
name|unsigned
name|char
operator|*
name|bufp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|numchars
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Number of keyboard chars we have produced so far.  */
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|char
name|mapping_buf
index|[
literal|20
index|]
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|XEvent
name|event
decl_stmt|;
comment|/* Must be static since data is saved between calls.  */
specifier|static
name|XComposeStatus
name|status
decl_stmt|;
name|KeySym
name|keysym
decl_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FIOSNBIO
comment|/* If available, Xlib uses FIOSNBIO to make the socket      non-blocking, and then looks for EWOULDBLOCK.  If O_NDELAY is set, FIOSNBIO is      ignored, and instead of signalling EWOULDBLOCK, a read returns      0, which Xlib interprets as equivalent to EPIPE. */
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|HAVE_SELECT
if|if
condition|(
operator|!
operator|(
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|&
name|O_NDELAY
operator|)
condition|)
block|{
specifier|extern
name|int
name|read_alarm_should_throw
decl_stmt|;
name|read_alarm_should_throw
operator|=
literal|1
expr_stmt|;
name|XPeekEvent
argument_list|(
name|XXdisplay
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|read_alarm_should_throw
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|XPending
argument_list|(
name|XXdisplay
argument_list|)
condition|)
block|{
name|XNextEvent
argument_list|(
name|XXdisplay
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|event
operator|.
name|type
operator|&=
literal|0177
expr_stmt|;
comment|/* Mask out XSendEvent indication */
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|MappingNotify
case|:
name|XRefreshKeyboardMapping
argument_list|(
operator|&
name|event
operator|.
name|xmapping
argument_list|)
expr_stmt|;
break|break;
case|case
name|MapNotify
case|:
name|WindowMapped
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UnmapNotify
case|:
name|WindowMapped
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ConfigureNotify
case|:
if|if
condition|(
name|abs
argument_list|(
name|pixelheight
operator|-
name|event
operator|.
name|xconfigure
operator|.
name|height
argument_list|)
operator|<
name|XXfonth
operator|&&
name|abs
argument_list|(
name|pixelwidth
operator|-
name|event
operator|.
name|xconfigure
operator|.
name|width
argument_list|)
operator|<
name|XXfontw
condition|)
break|break;
name|configure_pending
operator|=
literal|1
expr_stmt|;
name|rows
operator|=
operator|(
name|event
operator|.
name|xconfigure
operator|.
name|height
operator|-
literal|2
operator|*
name|XXInternalBorder
operator|)
operator|/
name|XXfonth
expr_stmt|;
name|cols
operator|=
operator|(
name|event
operator|.
name|xconfigure
operator|.
name|width
operator|-
literal|2
operator|*
name|XXInternalBorder
operator|)
operator|/
name|XXfontw
expr_stmt|;
name|pixelwidth
operator|=
name|cols
operator|*
name|XXfontw
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|pixelheight
operator|=
name|rows
operator|*
name|XXfonth
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
break|break;
case|case
name|Expose
case|:
if|if
condition|(
name|configure_pending
condition|)
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
if|if
condition|(
name|event
operator|.
name|xexpose
operator|.
name|count
condition|)
break|break;
comment|/* This is absolutely, amazingly gross. 	 * However, without it, emacs will core 	 * dump if the window gets too small.  And 	 * uwm is too brain-damaged to handle 	 * large minimum size windows. */
name|width
operator|=
operator|(
name|pixelwidth
operator|-
literal|2
operator|*
name|XXInternalBorder
operator|)
operator|/
name|XXfontw
expr_stmt|;
name|height
operator|=
operator|(
name|pixelheight
operator|-
literal|2
operator|*
name|XXInternalBorder
operator|)
operator|/
name|XXfonth
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|11
operator|&&
name|height
operator|>
literal|4
condition|)
name|change_screen_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dumprectangle
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|pixelheight
argument_list|,
name|pixelwidth
argument_list|)
expr_stmt|;
name|configure_pending
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dumprectangle
argument_list|(
name|event
operator|.
name|xexpose
operator|.
name|y
operator|-
name|XXInternalBorder
argument_list|,
name|event
operator|.
name|xexpose
operator|.
name|x
operator|-
name|XXInternalBorder
argument_list|,
name|event
operator|.
name|xexpose
operator|.
name|height
argument_list|,
name|event
operator|.
name|xexpose
operator|.
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
name|GraphicsExpose
case|:
name|dumprectangle
argument_list|(
name|event
operator|.
name|xgraphicsexpose
operator|.
name|y
operator|-
name|XXInternalBorder
argument_list|,
name|event
operator|.
name|xgraphicsexpose
operator|.
name|x
operator|-
name|XXInternalBorder
argument_list|,
name|event
operator|.
name|xgraphicsexpose
operator|.
name|height
argument_list|,
name|event
operator|.
name|xgraphicsexpose
operator|.
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
name|NoExpose
case|:
break|break;
case|case
name|FocusIn
case|:
name|x_focus_flag
operator|=
literal|1
expr_stmt|;
case|case
name|EnterNotify
case|:
if|if
condition|(
name|event
operator|.
name|type
operator|==
name|FocusIn
operator|||
operator|(
operator|!
name|x_focus_flag
operator|&&
name|event
operator|.
name|xcrossing
operator|.
name|focus
operator|)
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
name|CursorOutline
operator|=
literal|0
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FocusOut
case|:
name|x_focus_flag
operator|=
literal|0
expr_stmt|;
case|case
name|LeaveNotify
case|:
if|if
condition|(
name|event
operator|.
name|type
operator|==
name|FocusOut
operator|||
operator|(
operator|!
name|x_focus_flag
operator|&&
name|event
operator|.
name|xcrossing
operator|.
name|focus
operator|)
condition|)
block|{
name|CursorToggle
argument_list|()
expr_stmt|;
name|CursorOutline
operator|=
literal|1
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|KeyPress
case|:
name|nbytes
operator|=
name|XLookupString
argument_list|(
operator|&
name|event
operator|.
name|xkey
argument_list|,
name|mapping_buf
argument_list|,
literal|20
argument_list|,
operator|&
name|keysym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AIX
comment|/* Someday this will be unnecessary as we will 	 be able to use XRebindKeysym so XLookupString 	 will have already given us the string we want. */
if|if
condition|(
name|IsFunctionKey
argument_list|(
name|keysym
argument_list|)
operator|||
name|IsMiscFunctionKey
argument_list|(
name|keysym
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|mapping_buf
argument_list|,
literal|"
literal|["
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mapping_buf
argument_list|,
name|stringFuncVal
argument_list|(
name|keysym
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
name|strcat
argument_list|(
name|mapping_buf
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcat
argument_list|(
name|mapping_buf
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sun */
name|nbytes
operator|=
name|strlen
argument_list|(
name|mapping_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|keysym
condition|)
block|{
case|case
name|XK_Left
case|:
name|strcpy
argument_list|(
name|mapping_buf
argument_list|,
literal|"\002"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XK_Right
case|:
name|strcpy
argument_list|(
name|mapping_buf
argument_list|,
literal|"\006"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XK_Up
case|:
name|strcpy
argument_list|(
name|mapping_buf
argument_list|,
literal|"\020"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XK_Down
case|:
name|strcpy
argument_list|(
name|mapping_buf
argument_list|,
literal|"\016"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* not AIX */
if|if
condition|(
name|nbytes
condition|)
block|{
if|if
condition|(
operator|(
name|nbytes
operator|==
literal|1
operator|)
operator|&&
operator|(
name|event
operator|.
name|xkey
operator|.
name|state
operator|&
name|Mod1Mask
operator|)
condition|)
operator|*
name|mapping_buf
operator||=
name|METABIT
expr_stmt|;
if|if
condition|(
operator|(
name|nbytes
operator|==
literal|1
operator|)
operator|&&
operator|(
name|event
operator|.
name|xkey
operator|.
name|state
operator|&
name|ControlMask
operator|)
condition|)
operator|*
name|mapping_buf
operator|&=
literal|0x9F
expr_stmt|;
comment|/* mask off bits 1 and 2 */
if|if
condition|(
name|numchars
operator|-
name|nbytes
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|mapping_buf
argument_list|,
name|bufp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|nbytes
expr_stmt|;
name|count
operator|+=
name|nbytes
expr_stmt|;
name|numchars
operator|-=
name|nbytes
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ButtonPress
case|:
case|case
name|ButtonRelease
case|:
operator|*
name|bufp
operator|++
operator|=
operator|(
name|char
operator|)
literal|'X'
operator|&
literal|037
expr_stmt|;
operator|++
name|count
expr_stmt|;
operator|--
name|numchars
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
operator|(
name|char
operator|)
literal|'@'
operator|&
literal|037
expr_stmt|;
operator|++
name|count
expr_stmt|;
operator|--
name|numchars
expr_stmt|;
if|if
condition|(
name|XXm_queue_num
operator|==
name|XMOUSEBUFSIZE
condition|)
break|break;
name|XXm_queue
index|[
name|XXm_queue_in
index|]
operator|=
operator|(
name|XEvent
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XEvent
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|XXm_queue
index|[
name|XXm_queue_in
index|]
operator|=
name|event
expr_stmt|;
name|XXm_queue_num
operator|++
expr_stmt|;
name|XXm_queue_in
operator|=
operator|(
name|XXm_queue_in
operator|+
literal|1
operator|)
operator|%
name|XMOUSEBUFSIZE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|CursorExists
condition|)
name|xfixscreen
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_comment
comment|/* Exit gracefully from gnuemacs, doing an autosave and giving a status.  */
end_comment

begin_macro
name|XExitGracefully
argument_list|()
end_macro

begin_block
block|{
name|XCleanUp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|70
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|XIgnoreError
argument_list|()
end_macro

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|xfixscreen
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|server_ping_timer
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
if|if
condition|(
name|server_ping_timer
operator|>
literal|0
condition|)
name|server_ping_timer
operator|--
expr_stmt|;
else|else
block|{
name|server_ping_timer
operator|=
literal|100
expr_stmt|;
comment|/* Yes, this is really what I mean -- Check to see if we've 	     * lost our connection */
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XSetErrorHandler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XSetIOErrorHandler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|XNoOp
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|XSetErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|XSetIOErrorHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|InUpdate
operator|&&
operator|!
name|CursorExists
condition|)
name|CursorToggle
argument_list|()
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reversevideo
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|XT_GetDefaults
parameter_list|(
name|class
parameter_list|)
name|char
modifier|*
name|class
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|option
decl_stmt|;
specifier|register
name|struct
name|_xdeftab
modifier|*
name|entry
decl_stmt|;
comment|/*    * Walk the table reading in the resources.  Instance names supersede    * class names.    */
for|for
control|(
name|entry
operator|=
name|xDefaultsValueTable
init|;
name|entry
operator|->
name|iname
condition|;
name|entry
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|XBACKWARDS
if|if
condition|(
operator|!
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|entry
operator|->
name|iname
argument_list|,
name|class
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|entry
operator|->
name|iname
argument_list|,
name|CLASS
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|entry
operator|->
name|cname
argument_list|,
name|class
argument_list|)
operator|)
condition|)
name|option
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|entry
operator|->
name|cname
argument_list|,
name|CLASS
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|class
argument_list|,
name|entry
operator|->
name|iname
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|CLASS
argument_list|,
name|entry
operator|->
name|iname
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|class
argument_list|,
name|entry
operator|->
name|cname
argument_list|)
operator|)
condition|)
name|option
operator|=
name|XGetDefault
argument_list|(
name|XXdisplay
argument_list|,
name|CLASS
argument_list|,
name|entry
operator|->
name|cname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|option
operator|&&
name|entry
operator|->
name|varp
condition|)
operator|*
name|entry
operator|->
name|varp
operator|=
name|option
expr_stmt|;
block|}
comment|/*    * Now set global variables that aren't character strings; yes it would    * be nice to do this automatically as part of the scanning step, but this    * is less likely to screw up.  The real answer is to use the resource    * manager.    */
if|if
condition|(
name|temp_reverseVideo
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp_reverseVideo
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|reversevideo
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|temp_reverseVideo
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|reversevideo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|temp_borderWidth
condition|)
name|XXborder
operator|=
name|atoi
argument_list|(
name|temp_borderWidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_internalBorder
condition|)
name|XXInternalBorder
operator|=
name|atoi
argument_list|(
name|temp_internalBorder
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_useBitmap
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp_useBitmap
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|XXicon_usebitmap
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|temp_useBitmap
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|XXicon_usebitmap
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|x_error_handler
argument_list|(
argument|disp
argument_list|,
argument|event
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|disp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XErrorEvent
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|msg
index|[
literal|200
index|]
decl_stmt|;
name|XGetErrorText
argument_list|(
name|disp
argument_list|,
name|event
operator|->
name|error_code
argument_list|,
name|msg
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal X-windows error: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|Fkill_emacs
argument_list|(
name|make_number
argument_list|(
literal|70
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|x_io_error_handler
argument_list|()
end_macro

begin_block
block|{
name|Fdo_auto_save
argument_list|()
expr_stmt|;
name|perror
argument_list|(
literal|"Fatal X-windows I/O error"
argument_list|)
expr_stmt|;
name|Fkill_emacs
argument_list|(
name|make_number
argument_list|(
literal|70
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|x_term_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|vardisplay
decl_stmt|;
specifier|register
name|int
name|xxargc
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|xxargv
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|XColor
name|cdef
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
extern|extern XTinterrupt_signal (
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|Lisp_Object
name|Vxterm
decl_stmt|,
name|Vxterm1
decl_stmt|,
name|Qt
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|XIgnoreError
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ix
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|vardisplay
operator|=
operator|(
name|alternate_display
condition|?
name|alternate_display
else|:
literal|""
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|vardisplay
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DISPLAY environment variable must be set\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|200
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XXdisplay
operator|=
name|XOpenDisplay
argument_list|(
name|vardisplay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XXdisplay
operator|==
operator|(
name|Display
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"X server not responding.  Check your DISPLAY environment variable.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|99
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|XXscreen
operator|=
name|DefaultScreen
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXisColor
operator|=
name|DisplayCells
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
operator|>
literal|2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXColorMap
operator|=
name|DefaultColormap
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSetErrorHandler
argument_list|(
name|x_error_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XSetIOErrorHandler
argument_list|(
name|x_io_error_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|x_io_error_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|WindowMapped
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|baud_rate
operator|=
literal|9600
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|min_padding_speed
operator|=
literal|10000
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|must_write_spaces
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|meta_key
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|visible_bell
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|inverse_video
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|configure_pending
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fix_screen_hook
operator|=
name|xfixscreen
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_screen_hook
operator|=
name|XTclear_screen
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clear_end_of_line_hook
operator|=
name|XTclear_end_of_line
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ins_del_lines_hook
operator|=
name|XTins_del_lines
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|change_line_highlight_hook
operator|=
name|XTchange_line_highlight
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|insert_chars_hook
operator|=
name|XTinsert_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|output_chars_hook
operator|=
name|XToutput_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|delete_chars_hook
operator|=
name|XTdelete_chars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ring_bell_hook
operator|=
name|XTfeep
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reset_terminal_modes_hook
operator|=
name|XTreset_terminal_modes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|set_terminal_modes_hook
operator|=
name|XTset_terminal_modes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|update_begin_hook
operator|=
name|XTupdate_begin
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|update_end_hook
operator|=
name|XTupdate_end
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|set_terminal_window_hook
operator|=
name|XTset_terminal_window
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|read_socket_hook
operator|=
name|XTread_socket
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|move_cursor_hook
operator|=
name|XTmove_cursor
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reassert_line_highlight_hook
operator|=
name|XTreassert_line_highlight
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|scroll_region_ok
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we'll scroll partial screens */
end_comment

begin_expr_stmt
name|char_ins_del_ok
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|line_ins_del_ok
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we'll just blt 'em */
end_comment

begin_expr_stmt
name|fast_clear_end_of_line
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* X does this well */
end_comment

begin_expr_stmt
name|memory_below_screen
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we don't remember what scrolls 				  * 		off the bottom */
end_comment

begin_expr_stmt
name|dont_calculate_costs
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|calculate_costs_hook
operator|=
name|XTcalculate_costs
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* New options section */
end_comment

begin_expr_stmt
name|XXborder
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXInternalBorder
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|screen_width
operator|=
literal|80
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|screen_height
operator|=
literal|66
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reversevideo
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXdebug
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXm_queue_num
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXm_queue_in
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXm_queue_out
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|handler = XIgnoreError; 	XSetErrorHandler (handler); 	XSetIOErrorHandler (handler);
endif|#
directive|endif
end_endif

begin_expr_stmt
name|desiredwindow
operator|=
name|XXcurrentfont
operator|=
name|XXidentity
operator|=
name|XXicon_name
operator|=
name|XXheader
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XXicon_usebitmap
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|temp_font
operator|=
literal|"fixed"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|progname
operator|=
name|xargv
index|[
literal|0
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ptr
operator|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|'/'
argument_list|)
condition|)
name|progname
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
end_if

begin_expr_stmt
name|XXpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|default_window
operator|=
literal|"=80x24+0+0"
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|handler = XIgnoreError; 	XSetErrorHandler (handler); 	XSetIOErrorHandler (handler);
endif|#
directive|endif
end_endif

begin_comment
comment|/*  Get resource name and its defaults, it it exists... 	 */
end_comment

begin_for
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<
name|xargc
operator|&&
name|xargv
index|[
name|ix
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|;
name|ix
operator|++
control|)
block|{
name|int
name|valx
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|xargv
index|[
name|ix
index|]
argument_list|,
literal|"-rn"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|valx
operator|=
name|ix
operator|+
literal|1
operator|)
operator|<
name|xargc
condition|)
block|{
name|XXidentity
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|xargv
index|[
name|valx
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|XXidentity
argument_list|,
name|xargv
index|[
name|valx
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|XXidentity
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|getenv
argument_list|(
literal|"WM_RES_NAME"
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|XXidentity
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|XXidentity
condition|)
block|{
name|XXidentity
operator|=
name|progname
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|XXidentity
condition|)
name|XT_GetDefaults
argument_list|(
name|XXidentity
argument_list|)
expr_stmt|;
else|else
name|XT_GetDefaults
argument_list|(
name|CLASS
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|XXpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|default_window
operator|=
literal|"=80x24+0+0"
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Process X command line args...*/
end_comment

begin_expr_stmt
name|xxargc
operator|=
name|xargc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xxargv
operator|=
name|xargv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xxargv
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xxargc
operator|--
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|xxargc
condition|)
block|{
name|int
name|sargc
decl_stmt|;
name|sargc
operator|=
name|xxargc
expr_stmt|;
if|if
condition|(
name|xxargc
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-r"
argument_list|)
condition|)
block|{
name|reversevideo
operator|=
operator|!
name|reversevideo
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-font"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-fn"
argument_list|)
operator|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
if|if
condition|(
name|XXcurrentfont
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|XXcurrentfont
argument_list|)
expr_stmt|;
name|XXcurrentfont
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|XXcurrentfont
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-wn"
argument_list|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|XXheader
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|XXheader
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-in"
argument_list|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|XXicon_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|XXicon_name
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|xxargc
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-i"
argument_list|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|XXicon_usebitmap
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-b"
argument_list|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|XXborder
operator|=
name|atoi
argument_list|(
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-ib"
argument_list|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|XXInternalBorder
operator|=
name|atoi
argument_list|(
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-w"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-geometry"
argument_list|)
operator|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|desiredwindow
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|desiredwindow
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|XXisColor
condition|)
block|{
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-fg"
argument_list|)
operator|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|fore_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fore_color
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-bg"
argument_list|)
operator|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|back_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|back_color
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-bd"
argument_list|)
operator|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|brdr_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|brdr_color
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-cr"
argument_list|)
operator|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|curs_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|curs_color
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xxargc
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|xxargv
argument_list|,
literal|"-ms"
argument_list|)
operator|)
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
name|mous_color
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|xxargv
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mous_color
argument_list|,
operator|*
name|xxargv
argument_list|)
expr_stmt|;
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sargc
operator|==
name|xxargc
condition|)
block|{
name|xxargc
operator|--
expr_stmt|;
name|xxargv
operator|++
expr_stmt|;
block|}
block|}
end_while

begin_comment
comment|/*  Now, actually Parse and Set colors... 	 */
end_comment

begin_if
if|if
condition|(
name|XXisColor
condition|)
block|{
if|if
condition|(
name|fore_color
operator|||
name|back_color
condition|)
name|reversevideo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fore_color
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|fore_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
name|fore
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|fore_color
operator|=
literal|"black"
expr_stmt|;
name|fore
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|back_color
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|back_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
name|back
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|back_color
operator|=
literal|"white"
expr_stmt|;
name|back
operator|=
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curs_color
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|curs_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
name|curs
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|curs_color
operator|=
literal|"black"
expr_stmt|;
name|curs
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mous_color
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|mous_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
empty_stmt|;
else|else
name|mous_color
operator|=
literal|"black"
expr_stmt|;
if|if
condition|(
name|brdr_color
operator|&&
name|XParseColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
name|brdr_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XAllocColor
argument_list|(
name|XXdisplay
argument_list|,
name|XXColorMap
argument_list|,
operator|&
name|cdef
argument_list|)
condition|)
name|brdr
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
else|else
block|{
name|brdr_color
operator|=
literal|"black"
expr_stmt|;
name|brdr
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fore_color
operator|=
name|curs_color
operator|=
name|mous_color
operator|=
name|brdr_color
operator|=
literal|"black"
expr_stmt|;
name|fore
operator|=
name|curs
operator|=
name|brdr
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
name|back_color
operator|=
literal|"white"
expr_stmt|;
name|back
operator|=
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|reversevideo
condition|)
block|{
name|int
name|tempcolor
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|brdr
operator|=
name|back
expr_stmt|;
name|brdr_color
operator|=
name|back_color
expr_stmt|;
name|tempcolor
operator|=
name|fore
expr_stmt|;
name|fore
operator|=
name|back
expr_stmt|;
name|back
operator|=
name|tempcolor
expr_stmt|;
name|tempname
operator|=
name|fore_color
expr_stmt|;
name|fore_color
operator|=
name|back_color
expr_stmt|;
name|back_color
operator|=
name|tempname
expr_stmt|;
if|if
condition|(
name|curs
operator|==
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
condition|)
block|{
name|curs
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
name|curs_color
operator|=
literal|"black"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curs
operator|==
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
condition|)
block|{
name|curs
operator|=
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
name|curs_color
operator|=
literal|"white"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mous_color
argument_list|,
literal|"white"
argument_list|)
condition|)
name|mous_color
operator|=
literal|"black"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mous_color
argument_list|,
literal|"black"
argument_list|)
condition|)
name|mous_color
operator|=
literal|"white"
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|XXcurrentfont
condition|)
block|{
name|XXcurrentfont
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|temp_font
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XXcurrentfont
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation failure.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|150
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|XXcurrentfont
argument_list|,
name|temp_font
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|XExitGracefully
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_DUMP
end_ifndef

begin_if
if|if
condition|(
name|initialized
condition|)
endif|#
directive|endif
comment|/* CANNOT_DUMP */
name|Vxterm
operator|=
name|Qt
expr_stmt|;
end_if

begin_expr_stmt
name|Fset
argument_list|(
name|intern
argument_list|(
literal|"window-system-version"
argument_list|)
argument_list|,
name|make_number
argument_list|(
literal|11
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|XInitWindow
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|keyboard_init_hook
operator|=
name|x_init_1
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Initialize for keyboard input using X.    This is called by init_keyboard via keyboard_init_hook.  */
end_comment

begin_function
unit|static
name|void
name|x_init_1
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|F_SETOWN
specifier|extern
name|int
name|old_fcntl_owner
decl_stmt|;
endif|#
directive|endif
name|dup2
argument_list|(
name|ConnectionNumber
argument_list|(
name|XXdisplay
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ConnectionNumber
argument_list|(
name|XXdisplay
argument_list|)
argument_list|)
expr_stmt|;
name|ConnectionNumber
argument_list|(
name|XXdisplay
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Looks a little strange? 						 * check the def of the macro; 						 * it is a genuine lvalue */
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_SETOWN
name|old_fcntl_owner
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETOWN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_SETOWN_SOCK_NEG
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETOWN
argument_list|,
operator|-
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* stdin is a socket here */
else|#
directive|else
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* F_SETOWN_SOCK_NEG */
endif|#
directive|endif
comment|/* F_SETOWN */
comment|/* Enable interrupt_input because otherwise we cannot asynchronously 	   detect C-g sent as a keystroke event from the X server.  */
name|Fset_input_mode
argument_list|(
name|Qt
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|XSetFlash
argument_list|()
end_macro

begin_block
block|{
name|ring_bell_hook
operator|=
name|XTflash
expr_stmt|;
block|}
end_block

begin_macro
name|XSetFeep
argument_list|()
end_macro

begin_block
block|{
name|ring_bell_hook
operator|=
name|XTfeep
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------  *  Load a font by name.  Return the font pointer, or NULL if  *  it can't be loaded.  Do all appropriate calculations.  */
end_comment

begin_function
specifier|static
name|XFontStruct
modifier|*
name|XT_CalcForFont
parameter_list|(
name|fontname
parameter_list|)
name|char
modifier|*
name|fontname
decl_stmt|;
block|{
name|XFontStruct
modifier|*
name|fontp
decl_stmt|;
if|if
condition|(
operator|(
name|fontp
operator|=
name|XLoadQueryFont
argument_list|(
name|XXdisplay
argument_list|,
name|fontname
argument_list|)
operator|)
operator|==
operator|(
name|XFontStruct
operator|*
operator|)
literal|0
condition|)
block|{
return|return
operator|(
name|XFontStruct
operator|*
operator|)
name|NULL
return|;
block|}
name|XXfid
operator|=
name|fontp
operator|->
name|fid
expr_stmt|;
name|XXfonth
operator|=
name|fontp
operator|->
name|ascent
operator|+
name|fontp
operator|->
name|descent
expr_stmt|;
name|XXfontw
operator|=
name|fontp
operator|->
name|max_bounds
operator|.
name|width
expr_stmt|;
name|XXbase
operator|=
name|fontp
operator|->
name|ascent
expr_stmt|;
return|return
name|fontp
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------  */
end_comment

begin_expr_stmt
name|XNewFont
argument_list|(
name|newname
argument_list|)
specifier|register
name|char
operator|*
name|newname
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|XFontStruct
modifier|*
name|temp
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|temp
operator|=
name|XT_CalcForFont
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
operator|(
name|XFontStruct
operator|*
operator|)
name|NULL
condition|)
block|{
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|XSetFont
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_norm
argument_list|,
name|XXfid
argument_list|)
expr_stmt|;
name|XSetFont
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_rev
argument_list|,
name|XXfid
argument_list|)
expr_stmt|;
name|XSetFont
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_curs
argument_list|,
name|XXfid
argument_list|)
expr_stmt|;
name|XFreeFont
argument_list|(
name|XXdisplay
argument_list|,
name|fontinfo
argument_list|)
expr_stmt|;
name|fontinfo
operator|=
name|temp
expr_stmt|;
name|XSetWindowSize
argument_list|(
name|screen_height
argument_list|,
name|screen_width
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Flip foreground/background colors */
end_comment

begin_macro
name|XFlipColor
argument_list|()
end_macro

begin_block
block|{
name|int
name|tempcolor
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|XColor
name|forec
decl_stmt|,
name|backc
decl_stmt|;
name|BLOCK_INPUT_DECLARE
argument_list|()
expr_stmt|;
name|BLOCK_INPUT
argument_list|()
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|XSetWindowBackground
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|fore
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXborder
condition|)
name|XSetWindowBorder
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|brdr
operator|=
name|back
expr_stmt|;
name|brdr_color
operator|=
name|back_color
expr_stmt|;
name|tempcolor
operator|=
name|fore
expr_stmt|;
name|fore
operator|=
name|back
expr_stmt|;
name|back
operator|=
name|tempcolor
expr_stmt|;
name|tempname
operator|=
name|fore_color
expr_stmt|;
name|fore_color
operator|=
name|back_color
expr_stmt|;
name|back_color
operator|=
name|tempname
expr_stmt|;
name|XClearArea
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen_width
operator|*
name|XXfontw
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|screen_height
operator|*
name|XXfonth
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XXgc_temp
operator|=
name|XXgc_norm
expr_stmt|;
name|XXgc_norm
operator|=
name|XXgc_rev
expr_stmt|;
name|XXgc_rev
operator|=
name|XXgc_temp
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mous_color
argument_list|,
literal|"white"
argument_list|)
condition|)
name|mous_color
operator|=
literal|"black"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mous_color
argument_list|,
literal|"black"
argument_list|)
condition|)
name|mous_color
operator|=
literal|"white"
expr_stmt|;
name|x_set_cursor_colors
argument_list|()
expr_stmt|;
name|XRedrawDisplay
argument_list|()
expr_stmt|;
if|if
condition|(
name|curs
operator|==
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
condition|)
block|{
name|curs
operator|=
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
name|curs_color
operator|=
literal|"black"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curs
operator|==
name|BlackPixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
condition|)
block|{
name|curs
operator|=
name|WhitePixel
argument_list|(
name|XXdisplay
argument_list|,
name|XXscreen
argument_list|)
expr_stmt|;
name|curs_color
operator|=
literal|"white"
expr_stmt|;
block|}
name|XSetState
argument_list|(
name|XXdisplay
argument_list|,
name|XXgc_curs
argument_list|,
name|back
argument_list|,
name|curs
argument_list|,
name|GXinvert
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|CursorToggle
argument_list|()
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
name|UNBLOCK_INPUT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|NO_MANAGER
value|1
end_define

begin_comment
comment|/* ------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|XClassHint
name|class_hint
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|XT_Set_Class_Hints
parameter_list|(
name|w
parameter_list|)
name|Window
name|w
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
if|if
condition|(
name|XXidentity
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|XXidentity
operator|=
literal|""
expr_stmt|;
comment|/* XSCH() doesn't like NULL pointers! */
name|class_hint
operator|.
name|res_name
operator|=
name|XXidentity
expr_stmt|;
name|class_hint
operator|.
name|res_class
operator|=
name|CLASS
expr_stmt|;
name|XSetClassHint
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
operator|&
name|class_hint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|XT_Set_Command_Line
parameter_list|(
name|w
parameter_list|)
name|Window
name|w
decl_stmt|;
block|{
name|XSetCommand
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
name|xargv
argument_list|,
name|xargc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hostname
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|XT_Set_Host
parameter_list|(
name|w
parameter_list|)
name|Window
name|w
decl_stmt|;
block|{
name|gethostname
argument_list|(
name|hostname
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|hostname
index|[
literal|99
index|]
operator|=
literal|'\0'
expr_stmt|;
name|XChangeProperty
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
name|XA_WM_CLIENT_MACHINE
argument_list|,
name|XA_STRING
argument_list|,
literal|8
argument_list|,
name|PropModeReplace
argument_list|,
name|hostname
argument_list|,
name|strlen
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------  *  Set header title to window-name (from '-wn'), or if none,  *  "optional-id: class-of-appl @ host"  */
end_comment

begin_function
specifier|static
name|int
name|XT_Set_Title
parameter_list|(
name|w
parameter_list|)
name|Window
name|w
decl_stmt|;
block|{
name|char
name|header_info
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|XXheader
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|header_info
argument_list|,
name|XXheader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|header_info
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|class_hint
operator|.
name|res_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|header_info
argument_list|,
literal|"%s: "
argument_list|,
name|class_hint
operator|.
name|res_name
argument_list|)
expr_stmt|;
name|next
operator|+=
name|strlen
argument_list|(
name|header_info
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|next
argument_list|,
literal|"%s @ %s"
argument_list|,
name|class_hint
operator|.
name|res_class
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
name|XStoreName
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
name|header_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------  *  Set icon title to icon-name (from '-in'),  *  or if none, to "invocation-or-class @ host".  *  */
end_comment

begin_function
specifier|static
name|int
name|XT_Set_Icon_Title
parameter_list|(
name|w
parameter_list|)
name|Window
name|w
decl_stmt|;
block|{
name|char
name|title_info
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|XXicon_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|title_info
argument_list|,
name|XXicon_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|class_hint
operator|.
name|res_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|title_info
argument_list|,
literal|"%s@"
argument_list|,
name|class_hint
operator|.
name|res_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|title_info
argument_list|,
literal|"%s@"
argument_list|,
name|class_hint
operator|.
name|res_class
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|title_info
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
name|XChangeProperty
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
name|XA_WM_ICON_NAME
argument_list|,
name|XA_STRING
argument_list|,
literal|8
argument_list|,
name|PropModeReplace
argument_list|,
name|title_info
argument_list|,
name|strlen
argument_list|(
name|title_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Arg PR carries value returned by XGeometry at startup, or 0.  */
end_comment

begin_function
specifier|static
name|int
name|XT_Set_Size_Hints
parameter_list|(
name|w
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|width
parameter_list|,
name|height
parameter_list|,
name|do_resize
parameter_list|,
name|pr
parameter_list|)
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* only used at Startup: do_resize == FALSE */
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|Window
name|w
decl_stmt|;
name|Bool
name|do_resize
decl_stmt|;
name|int
name|pr
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|XICCC
name|XSizeHints
name|sizehints
decl_stmt|;
name|sizehints
operator|.
name|flags
operator|=
operator|(
name|pr
operator|&
operator|(
name|WidthValue
operator||
name|HeightValue
operator|)
operator|)
condition|?
name|USSize
else|:
name|PSize
expr_stmt|;
if|if
condition|(
operator|!
name|do_resize
condition|)
name|sizehints
operator|.
name|flags
operator||=
operator|(
name|pr
operator|&
operator|(
name|XValue
operator||
name|YValue
operator|)
operator|)
condition|?
name|USPosition
else|:
name|PPosition
expr_stmt|;
name|sizehints
operator|.
name|flags
operator||=
name|PResizeInc
operator||
name|PMinSize
expr_stmt|;
name|sizehints
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sizehints
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sizehints
operator|.
name|width
operator|=
name|width
operator|*
name|XXfontw
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|sizehints
operator|.
name|height
operator|=
name|height
operator|*
name|XXfonth
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|pixelwidth
operator|=
name|sizehints
operator|.
name|width
expr_stmt|;
name|pixelheight
operator|=
name|sizehints
operator|.
name|height
expr_stmt|;
name|flexlines
operator|=
name|height
expr_stmt|;
name|change_screen_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
literal|0
operator|-
operator|(
name|do_resize
operator|==
name|False
operator|)
argument_list|)
expr_stmt|;
name|sizehints
operator|.
name|width_inc
operator|=
name|XXfontw
expr_stmt|;
name|sizehints
operator|.
name|height_inc
operator|=
name|XXfonth
expr_stmt|;
name|sizehints
operator|.
name|min_width
operator|=
name|XXfontw
operator|*
name|MINWIDTH
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|sizehints
operator|.
name|min_height
operator|=
name|XXfonth
operator|*
name|MINHEIGHT
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
comment|/* old, broken versions */
name|sizehints
operator|.
name|min_width
operator|=
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|sizehints
operator|.
name|min_height
operator|=
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|XSetNormalHints
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
operator|&
name|sizehints
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_resize
condition|)
block|{
name|XResizeWindow
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|pixelwidth
argument_list|,
name|pixelheight
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|XSizeHints
name|sizehints
decl_stmt|;
name|XWindowChanges
name|changes
decl_stmt|;
name|unsigned
name|int
name|change_mask
init|=
literal|0
decl_stmt|;
name|sizehints
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|do_resize
condition|)
block|{
name|changes
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|changes
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|sizehints
operator|.
name|flags
operator||=
operator|(
name|pr
operator|&
operator|(
name|XValue
operator||
name|YValue
operator|)
operator|)
condition|?
name|USPosition
else|:
name|PPosition
expr_stmt|;
name|change_mask
operator||=
name|CWX
operator||
name|CWY
expr_stmt|;
block|}
name|sizehints
operator|.
name|base_width
operator|=
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|sizehints
operator|.
name|base_height
operator|=
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|changes
operator|.
name|width
operator|=
name|sizehints
operator|.
name|base_width
operator|+
name|width
operator|*
name|XXfontw
expr_stmt|;
name|changes
operator|.
name|height
operator|=
name|sizehints
operator|.
name|base_height
operator|+
name|height
operator|*
name|XXfonth
expr_stmt|;
name|sizehints
operator|.
name|flags
operator||=
operator|(
operator|(
name|pr
operator|&
operator|(
name|WidthValue
operator||
name|HeightValue
operator|)
operator|)
condition|?
name|USSize
else|:
name|PSize
operator|)
operator||
name|PBaseSize
expr_stmt|;
name|change_mask
operator||=
name|CWWidth
operator||
name|CWHeight
expr_stmt|;
comment|/*      * NOTE: The sizehints.x, sizehints.y, sizehints.width and      * sizehints.height fields are OBSOLETE according to the ICCC, and      * no window manager should be considering them, even if USSize/PSize      * and/or USPosition/PPosition are set.  Unfortunately, many      * window managers consider them anyway, and programs like xprop      * display their values when fetching the normal hints property      * from the window.  Therefore, I set them here just to make      * things a little bit more robust.      */
if|if
condition|(
operator|!
name|do_resize
condition|)
block|{
name|sizehints
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|sizehints
operator|.
name|y
operator|=
name|y
expr_stmt|;
block|}
name|sizehints
operator|.
name|width
operator|=
name|changes
operator|.
name|width
expr_stmt|;
name|sizehints
operator|.
name|height
operator|=
name|changes
operator|.
name|height
expr_stmt|;
name|pixelwidth
operator|=
name|sizehints
operator|.
name|base_width
expr_stmt|;
name|pixelheight
operator|=
name|sizehints
operator|.
name|base_height
expr_stmt|;
name|flexlines
operator|=
name|height
expr_stmt|;
name|change_screen_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
literal|0
operator|-
operator|(
name|do_resize
operator|==
name|False
operator|)
argument_list|)
expr_stmt|;
name|sizehints
operator|.
name|min_width
operator|=
name|XXfontw
operator|*
name|MINWIDTH
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|sizehints
operator|.
name|min_height
operator|=
name|XXfonth
operator|*
name|MINHEIGHT
operator|+
literal|2
operator|*
name|XXInternalBorder
expr_stmt|;
name|sizehints
operator|.
name|flags
operator||=
name|PMinSize
expr_stmt|;
name|sizehints
operator|.
name|width_inc
operator|=
name|XXfontw
expr_stmt|;
name|sizehints
operator|.
name|height_inc
operator|=
name|XXfonth
expr_stmt|;
name|sizehints
operator|.
name|flags
operator||=
name|PResizeInc
expr_stmt|;
name|XSetWMNormalHints
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
operator|&
name|sizehints
argument_list|)
expr_stmt|;
name|XConfigureWindow
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
name|change_mask
argument_list|,
operator|&
name|changes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XICCC */
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|XT_Set_Zoom_Sizes
parameter_list|(
name|w
parameter_list|)
name|Window
name|w
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* ------------------------------------------------------------  *  Set our state and icon parameters.  */
end_comment

begin_function
specifier|static
name|int
name|XT_Set_WM_Hints
parameter_list|(
name|w
parameter_list|)
name|Window
name|w
decl_stmt|;
block|{
name|XWMHints
name|wmhints
decl_stmt|;
name|wmhints
operator|.
name|flags
operator|=
name|InputHint
operator||
name|StateHint
expr_stmt|;
if|if
condition|(
name|XXicon_usebitmap
condition|)
name|wmhints
operator|.
name|flags
operator||=
name|IconPixmapHint
operator||
name|IconMaskHint
expr_stmt|;
name|wmhints
operator|.
name|input
operator|=
name|True
expr_stmt|;
name|wmhints
operator|.
name|initial_state
operator|=
name|NormalState
expr_stmt|;
name|SinkPixmap
operator|=
name|XCreateBitmapFromData
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
name|sink_bits
argument_list|,
name|sink_width
argument_list|,
name|sink_height
argument_list|)
expr_stmt|;
name|SinkMaskPixmap
operator|=
name|XCreateBitmapFromData
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
name|sink_mask_bits
argument_list|,
name|sink_mask_width
argument_list|,
name|sink_mask_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXicon_usebitmap
condition|)
block|{
name|wmhints
operator|.
name|icon_pixmap
operator|=
name|SinkPixmap
expr_stmt|;
name|wmhints
operator|.
name|icon_mask
operator|=
name|SinkMaskPixmap
expr_stmt|;
block|}
else|else
block|{
name|wmhints
operator|.
name|icon_pixmap
operator|=
literal|0
expr_stmt|;
name|wmhints
operator|.
name|icon_mask
operator|=
literal|0
expr_stmt|;
block|}
name|XSetWMHints
argument_list|(
name|XXdisplay
argument_list|,
name|w
argument_list|,
operator|&
name|wmhints
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------  *  Change just the size of the window.  */
end_comment

begin_macro
name|XSetWindowSize
argument_list|(
argument|rows
argument_list|,
argument|cols
argument_list|)
end_macro

begin_decl_stmt
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XT_Set_Size_Hints
argument_list|(
name|XXwindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cols
argument_list|,
name|rows
argument_list|,
name|NO_MANAGER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|XInitWindow
parameter_list|()
block|{
specifier|extern
name|int
name|xargc
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|xargv
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|pr
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|Window
name|desktop
decl_stmt|;
name|XColor
name|forec
decl_stmt|,
name|backc
decl_stmt|;
if|if
condition|(
operator|(
name|fontinfo
operator|=
name|XT_CalcForFont
argument_list|(
name|XXcurrentfont
argument_list|)
operator|)
operator|==
operator|(
name|XFontStruct
operator|*
operator|)
name|NULL
condition|)
name|fatal
argument_list|(
literal|"X server unable to find requested font `%s'.\n"
argument_list|,
operator|(
name|XXcurrentfont
operator|==
name|NULL
operator|)
condition|?
literal|"(null)"
else|:
name|XXcurrentfont
argument_list|)
expr_stmt|;
name|pr
operator|=
name|XGeometry
argument_list|(
name|XXdisplay
argument_list|,
literal|0
argument_list|,
name|desiredwindow
argument_list|,
name|default_window
argument_list|,
name|XXborder
argument_list|,
name|XXfontw
argument_list|,
name|XXfonth
argument_list|,
name|XXInternalBorder
operator|*
literal|2
argument_list|,
name|XXInternalBorder
operator|*
literal|2
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
comment|/*  Which desktop do we start up on?      */
if|if
condition|(
operator|(
name|dp
operator|=
name|getenv
argument_list|(
literal|"WM_DESKTOP"
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|desktop
operator|=
name|atoi
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desktop
operator|=
name|RootWindow
argument_list|(
name|XXdisplay
argument_list|,
name|DefaultScreen
argument_list|(
name|XXdisplay
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|XXwindow
operator|=
name|XCreateSimpleWindow
argument_list|(
name|XXdisplay
argument_list|,
name|desktop
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
operator|*
name|XXfontw
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|height
operator|*
name|XXfonth
operator|+
literal|2
operator|*
name|XXInternalBorder
argument_list|,
name|XXborder
argument_list|,
name|brdr
argument_list|,
name|back
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XXwindow
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not create X window!\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|97
argument_list|)
expr_stmt|;
block|}
name|XXgcv
operator|.
name|font
operator|=
name|XXfid
expr_stmt|;
name|XXgcv
operator|.
name|foreground
operator|=
name|fore
expr_stmt|;
name|XXgcv
operator|.
name|background
operator|=
name|back
expr_stmt|;
name|XXgc_norm
operator|=
name|XCreateGC
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|GCFont
operator||
name|GCForeground
operator||
name|GCBackground
argument_list|,
operator|&
name|XXgcv
argument_list|)
expr_stmt|;
name|XXgcv
operator|.
name|foreground
operator|=
name|back
expr_stmt|;
name|XXgcv
operator|.
name|background
operator|=
name|fore
expr_stmt|;
name|XXgc_rev
operator|=
name|XCreateGC
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|GCFont
operator||
name|GCForeground
operator||
name|GCBackground
argument_list|,
operator|&
name|XXgcv
argument_list|)
expr_stmt|;
name|XXgcv
operator|.
name|foreground
operator|=
name|back
expr_stmt|;
name|XXgcv
operator|.
name|background
operator|=
name|curs
expr_stmt|;
name|XXgc_curs
operator|=
name|XCreateGC
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|GCFont
operator||
name|GCForeground
operator||
name|GCBackground
argument_list|,
operator|&
name|XXgcv
argument_list|)
expr_stmt|;
name|EmacsCursor
operator|=
name|XCreateFontCursor
argument_list|(
name|XXdisplay
argument_list|,
name|XC_left_ptr
argument_list|)
expr_stmt|;
name|x_set_cursor_colors
argument_list|()
expr_stmt|;
name|XDefineCursor
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|EmacsCursor
argument_list|)
expr_stmt|;
name|CursorExists
operator|=
literal|0
expr_stmt|;
name|CursorOutline
operator|=
literal|1
expr_stmt|;
name|VisibleX
operator|=
literal|0
expr_stmt|;
name|VisibleY
operator|=
literal|0
expr_stmt|;
name|XT_Set_Class_Hints
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XT_Set_Command_Line
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XT_Set_Host
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XT_Set_Title
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XT_Set_Icon_Title
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XT_Set_Size_Hints
argument_list|(
name|XXwindow
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|False
argument_list|,
name|pr
argument_list|)
expr_stmt|;
name|XT_Set_Zoom_Sizes
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XT_Set_WM_Hints
argument_list|(
name|XXwindow
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|,
name|KeyPressMask
operator||
name|ExposureMask
operator||
name|ButtonPressMask
operator||
name|ButtonReleaseMask
operator||
name|EnterWindowMask
operator||
name|LeaveWindowMask
operator||
name|FocusChangeMask
operator||
name|StructureNotifyMask
argument_list|)
expr_stmt|;
name|XMapWindow
argument_list|(
name|XXdisplay
argument_list|,
name|XXwindow
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|XXdisplay
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AIX
include|#
directive|include
file|"xkeys-aix.h"
endif|#
directive|endif
comment|/* AIX */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_X_WINDOWS */
end_comment

begin_comment
comment|/*#include "xundebug.h"*/
end_comment

end_unit

