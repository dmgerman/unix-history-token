begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Unexec for Xenix.    Copyright (C) 1988 Free Software Foundation, Inc.     Note that the GNU project considers support for Xenix operation    a peripheral activity which should not be allowed to divert effort    from development of the GNU system.  Changes in this code will be    installed when Xenix users send them in, but aside from that    we don't plan to think about it, or about whether other Emacs    maintenance might break it.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*   On 80386 Xenix, segmentation screws prevent us from modifying the text   segment at all.  We basically just plug a new value for "data segment   size" into the countless headers and copy the other records straight   through.  The data segment is ORG'ed at the xs_rbase value of the data   segment's xseg record (always @ 0x1880000, thanks to the "sophisticated   memory management hardware" of the chip) and extends to sbrk(0), exactly.   This code is afraid to malloc (should it be?), and alloca has to be the   wimpy, malloc-based version; consequently, data is usually copied in   smallish chunks.    gb@entity.com */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_function_decl
specifier|static
name|void
name|fatal_unexec
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|READ
parameter_list|(
name|_fd
parameter_list|,
name|_buffer
parameter_list|,
name|_size
parameter_list|,
name|_error_message
parameter_list|,
name|_error_arg
parameter_list|)
define|\
value|errno = EEOF; \ 	if (read(_fd, _buffer, _size) != _size) \ 	  fatal_unexec(_error_message, _error_arg);
end_define

begin_define
define|#
directive|define
name|WRITE
parameter_list|(
name|_fd
parameter_list|,
name|_buffer
parameter_list|,
name|_size
parameter_list|,
name|_error_message
parameter_list|,
name|_error_arg
parameter_list|)
define|\
value|if (write(_fd, _buffer, _size) != _size) \ 	  fatal_unexec(_error_message, _error_arg);
end_define

begin_define
define|#
directive|define
name|SEEK
parameter_list|(
name|_fd
parameter_list|,
name|_position
parameter_list|,
name|_error_message
parameter_list|,
name|_error_arg
parameter_list|)
define|\
value|errno = EEOF; \ 	if (lseek(_fd, _position, L_SET) != _position) \ 	  fatal_unexec(_error_message, _error_arg);
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EEOF
value|-1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|L_SET
end_ifndef

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Should check the magic number of the old executable;    not yet written.  */
end_comment

begin_macro
name|check_exec
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|xexec
modifier|*
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_macro
name|unexec
argument_list|(
argument|new_name
argument_list|,
argument|a_name
argument_list|,
argument|data_start
argument_list|,
argument|bss_start
argument_list|,
argument|entry_address
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|new_name
decl_stmt|,
modifier|*
name|a_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|sbrk
argument_list|()
decl_stmt|,
modifier|*
name|datalim
init|=
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|,
modifier|*
name|data_org
decl_stmt|;
name|long
name|segpos
decl_stmt|,
name|textseen
decl_stmt|,
name|textpos
decl_stmt|,
name|textlen
decl_stmt|,
name|datapos
decl_stmt|,
name|datadiff
decl_stmt|,
name|datalen
decl_stmt|;
name|struct
name|xexec
name|u_xexec
decl_stmt|,
comment|/*  a.out header */
modifier|*
name|u_xexecp
init|=
operator|&
name|u_xexec
decl_stmt|;
name|struct
name|xext
name|u_xext
decl_stmt|,
comment|/*  extended header */
modifier|*
name|u_xextp
init|=
operator|&
name|u_xext
decl_stmt|;
name|struct
name|xseg
name|u_xseg
decl_stmt|,
comment|/*  segment table entry */
modifier|*
name|u_xsegp
init|=
operator|&
name|u_xseg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsegs
decl_stmt|,
name|isdata
init|=
literal|0
decl_stmt|,
name|infd
decl_stmt|,
name|outfd
decl_stmt|;
name|infd
operator|=
name|open
argument_list|(
name|a_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|infd
operator|<
literal|0
condition|)
name|fatal_unexec
argument_list|(
literal|"opening %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|outfd
operator|=
name|creat
argument_list|(
name|new_name
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfd
operator|<
literal|0
condition|)
name|fatal_unexec
argument_list|(
literal|"creating %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|infd
argument_list|,
name|u_xexecp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xexec
argument_list|)
argument_list|,
literal|"error reading %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|check_exec
argument_list|(
name|u_xexecp
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|infd
argument_list|,
name|u_xextp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xext
argument_list|)
argument_list|,
literal|"error reading %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|segpos
operator|=
name|u_xextp
operator|->
name|xe_segpos
expr_stmt|;
name|nsegs
operator|=
name|u_xextp
operator|->
name|xe_segsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
expr_stmt|;
name|SEEK
argument_list|(
name|infd
argument_list|,
name|segpos
argument_list|,
literal|"seek error on %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|READ
argument_list|(
name|infd
argument_list|,
name|u_xsegp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
argument_list|,
literal|"error reading %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|u_xsegp
operator|->
name|xs_type
condition|)
block|{
case|case
name|XS_TTEXT
case|:
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|textpos
operator|=
name|u_xsegp
operator|->
name|xs_filpos
expr_stmt|;
name|textlen
operator|=
name|u_xsegp
operator|->
name|xs_psize
expr_stmt|;
break|break;
block|}
name|fatal_unexec
argument_list|(
literal|"invalid text segment in %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
block|}
case|case
name|XS_TDATA
case|:
block|{
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|datapos
operator|=
name|u_xsegp
operator|->
name|xs_filpos
expr_stmt|;
name|datalen
operator|=
name|datalim
operator|-
operator|(
name|data_org
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|u_xsegp
operator|->
name|xs_rbase
operator|)
operator|)
expr_stmt|;
name|datadiff
operator|=
name|datalen
operator|-
name|u_xsegp
operator|->
name|xs_psize
expr_stmt|;
break|break;
block|}
name|fatal_unexec
argument_list|(
literal|"invalid data segment in %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
block|}
default|default:
block|{
if|if
condition|(
name|i
operator|>
literal|1
condition|)
break|break;
name|fatal_unexec
argument_list|(
literal|"invalid segment record in %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|u_xexecp
operator|->
name|x_data
operator|=
name|datalen
expr_stmt|;
name|u_xexecp
operator|->
name|x_bss
operator|=
literal|0
expr_stmt|;
name|WRITE
argument_list|(
name|outfd
argument_list|,
name|u_xexecp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xexec
argument_list|)
argument_list|,
literal|"error writing %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|outfd
argument_list|,
name|u_xextp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xext
argument_list|)
argument_list|,
literal|"error writing %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|SEEK
argument_list|(
name|infd
argument_list|,
name|segpos
argument_list|,
literal|"seek error on %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|SEEK
argument_list|(
name|outfd
argument_list|,
name|segpos
argument_list|,
literal|"seek error on %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
comment|/* Copy the text segment record verbatim. */
name|copyrec
argument_list|(
name|infd
argument_list|,
name|outfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
comment|/* Read, modify, write the data segment record. */
name|READ
argument_list|(
name|infd
argument_list|,
name|u_xsegp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
argument_list|,
literal|"error reading %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|u_xsegp
operator|->
name|xs_psize
operator|=
name|u_xsegp
operator|->
name|xs_vsize
operator|=
name|datalen
expr_stmt|;
name|u_xsegp
operator|->
name|xs_attr
operator|&=
operator|(
operator|~
name|XS_AITER
operator|&
operator|~
name|XS_ABSS
operator|)
expr_stmt|;
name|WRITE
argument_list|(
name|outfd
argument_list|,
name|u_xsegp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
argument_list|,
literal|"error writing %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
comment|/* Now copy any additional segment records, adjusting their      file position field */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|READ
argument_list|(
name|infd
argument_list|,
name|u_xsegp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
argument_list|,
literal|"error reading %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|u_xsegp
operator|->
name|xs_filpos
operator|+=
name|datadiff
expr_stmt|;
name|WRITE
argument_list|(
name|outfd
argument_list|,
name|u_xsegp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
argument_list|,
literal|"error writing %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
name|SEEK
argument_list|(
name|infd
argument_list|,
name|textpos
argument_list|,
literal|"seek error on %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|SEEK
argument_list|(
name|outfd
argument_list|,
name|textpos
argument_list|,
literal|"seek error on %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|copyrec
argument_list|(
name|infd
argument_list|,
name|outfd
argument_list|,
name|textlen
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|SEEK
argument_list|(
name|outfd
argument_list|,
name|datapos
argument_list|,
literal|"seek error on %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|outfd
argument_list|,
name|data_org
argument_list|,
name|datalen
argument_list|,
literal|"write error on %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|,
name|segpos
operator|+=
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
operator|)
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
operator|,
name|segpos
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
control|)
block|{
name|SEEK
argument_list|(
name|infd
argument_list|,
name|segpos
argument_list|,
literal|"seek error on %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|infd
argument_list|,
name|u_xsegp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xseg
argument_list|)
argument_list|,
literal|"read error on %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
name|SEEK
argument_list|(
name|infd
argument_list|,
name|u_xsegp
operator|->
name|xs_filpos
argument_list|,
literal|"seek error on %s"
argument_list|,
name|a_name
argument_list|)
expr_stmt|;
comment|/* We should be at eof in the output file here, but we must seek          because the xs_filpos and xs_psize fields in symbol table 	 segments are inconsistent. */
name|SEEK
argument_list|(
name|outfd
argument_list|,
name|u_xsegp
operator|->
name|xs_filpos
operator|+
name|datadiff
argument_list|,
literal|"seek error on %s"
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|copyrec
argument_list|(
name|infd
argument_list|,
name|outfd
argument_list|,
name|u_xsegp
operator|->
name|xs_psize
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|infd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|outfd
argument_list|)
expr_stmt|;
name|mark_x
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|copyrec
argument_list|(
argument|infd
argument_list|,
argument|outfd
argument_list|,
argument|len
argument_list|,
argument|in_name
argument_list|,
argument|out_name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|infd
decl_stmt|,
name|outfd
decl_stmt|,
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|in_name
decl_stmt|,
modifier|*
name|out_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|chunk
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|chunk
operator|=
name|BUFSIZ
expr_stmt|;
if|if
condition|(
name|chunk
operator|>
name|len
condition|)
name|chunk
operator|=
name|len
expr_stmt|;
name|READ
argument_list|(
name|infd
argument_list|,
name|buf
argument_list|,
name|chunk
argument_list|,
literal|"error reading %s"
argument_list|,
name|in_name
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|outfd
argument_list|,
name|buf
argument_list|,
name|chunk
argument_list|,
literal|"error writing %s"
argument_list|,
name|out_name
argument_list|)
expr_stmt|;
name|len
operator|-=
name|chunk
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * mark_x  *  * After succesfully building the new a.out, mark it executable  */
end_comment

begin_expr_stmt
specifier|static
name|mark_x
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|um
init|=
name|umask
argument_list|(
literal|777
argument_list|)
decl_stmt|;
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
name|fatal_unexec
argument_list|(
literal|"getting protection on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sbuf
operator|.
name|st_mode
operator||=
literal|0111
operator|&
operator|~
name|um
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|name
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
name|fatal_unexec
argument_list|(
literal|"setting protection on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|fatal_unexec
parameter_list|(
name|s
parameter_list|,
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|EEOF
condition|)
name|fputs
argument_list|(
literal|"unexec: unexpected end of file, "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexec: %s, "
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexec: error code %d, "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_doprnt
argument_list|(
name|s
argument_list|,
name|ap
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|".\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

