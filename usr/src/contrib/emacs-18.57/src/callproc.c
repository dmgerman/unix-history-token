begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Synchronous subprocess invocation for GNU Emacs.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_define
define|#
directive|define
name|PRIO_PROCESS
value|0
end_define

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_WRONLY
end_ifndef

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_decl_stmt
name|Lisp_Object
name|Vexec_path
decl_stmt|,
name|Vexec_directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vshell_file_name
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAINTAIN_ENVIRONMENT
end_ifndef

begin_comment
comment|/* List of strings to append to front of environment of    all subprocesses when they are started.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vprocess_environment
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_comment
comment|/* Set nonzero when a synchronous subprocess is made,    and set to zero again when it is observed to die.    We wait for this to be zero in order to wait for termination.  */
end_comment

begin_decl_stmt
name|int
name|synch_process_pid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_1 */
end_comment

begin_escape
end_escape

begin_function
name|Lisp_Object
name|call_process_cleanup
parameter_list|(
name|fdpid
parameter_list|)
name|Lisp_Object
name|fdpid
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|fd
decl_stmt|,
name|pid
decl_stmt|;
name|fd
operator|=
name|Fcar
argument_list|(
name|fdpid
argument_list|)
expr_stmt|;
name|pid
operator|=
name|Fcdr
argument_list|(
name|fdpid
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|XFASTINT
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|XFASTINT
argument_list|(
name|pid
argument_list|)
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
specifier|extern
name|noshare
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|DEFUN
argument_list|(
literal|"call-process"
argument_list|,
argument|Fcall_process
argument_list|,
argument|Scall_process
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Call PROGRAM in separate process.\n\ Program's input comes from file INFILE (nil means /dev/null).\n\ Insert output in BUFFER before point; t means current buffer;\n\  nil for BUFFER means discard it; 0 means discard and don't wait.\n\ Fourth arg DISPLAY non-nil means redisplay buffer as output is inserted.\n\ Remaining arguments are strings passed as command arguments to PROGRAM.\n\ This function waits for PROGRAM to terminate;\n\ if you quit, the process is killed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|display
decl_stmt|,
name|buffer
decl_stmt|,
name|path
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
name|int
name|filefd
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|new_argv
init|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max
argument_list|(
literal|2
argument_list|,
name|nargs
operator|-
literal|2
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|buffer
modifier|*
name|old
init|=
name|current_buffer
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|<=
literal|1
operator|||
name|NULL
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|VMS
name|args
index|[
literal|1
index|]
operator|=
name|build_string
argument_list|(
literal|"NLA0:"
argument_list|)
expr_stmt|;
else|#
directive|else
name|args
index|[
literal|1
index|]
operator|=
name|build_string
argument_list|(
literal|"/dev/null"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
else|else
name|args
index|[
literal|1
index|]
operator|=
name|Fexpand_file_name
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|current_buffer
operator|->
name|directory
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|buffer
operator|=
name|tem
operator|=
name|args
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|nargs
operator|<=
literal|2
condition|)
name|buffer
operator|=
name|Qnil
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
operator|||
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qt
argument_list|)
operator|||
name|XFASTINT
argument_list|(
name|tem
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|display
operator|=
name|nargs
operator|>=
literal|3
condition|?
name|args
index|[
literal|3
index|]
else|:
name|Qnil
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|CHECK_STRING
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|new_argv
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|XSTRING
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
comment|/* Program name is first command arg */
name|new_argv
index|[
literal|0
index|]
operator|=
name|XSTRING
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|->
name|data
expr_stmt|;
name|new_argv
index|[
name|i
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|filefd
operator|=
name|open
argument_list|(
name|XSTRING
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
operator|->
name|data
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|filefd
operator|<
literal|0
condition|)
block|{
name|report_file_error
argument_list|(
literal|"Opening process input file"
argument_list|,
name|Fcons
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Search for program; barf if not found.  */
name|openp
argument_list|(
name|Vexec_path
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
literal|""
argument_list|,
operator|&
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|filefd
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Searching for program"
argument_list|,
name|Fcons
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_argv
index|[
literal|0
index|]
operator|=
name|XSTRING
argument_list|(
name|path
argument_list|)
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|buffer
argument_list|)
operator|==
name|Lisp_Int
condition|)
ifdef|#
directive|ifdef
name|VMS
name|fd
index|[
literal|1
index|]
operator|=
name|open
argument_list|(
literal|"NLA0:"
argument_list|,
literal|0
argument_list|)
operator|,
name|fd
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|fd
index|[
literal|1
index|]
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
operator|,
name|fd
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
else|else
block|{
name|pipe
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Replaced by close_process_descs */
block|set_exclusive_use (fd[0]);
endif|#
directive|endif
block|}
block|{
comment|/* child_setup must clobber environ in systems with true vfork.        Protect it from permanent change.  */
specifier|register
name|char
modifier|*
modifier|*
name|save_environ
init|=
name|environ
decl_stmt|;
specifier|register
name|int
name|fd1
init|=
name|fd
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
ifdef|#
directive|ifdef
name|MAINTAIN_ENVIRONMENT
name|env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_current_environ
argument_list|()
argument_list|)
expr_stmt|;
name|get_current_environ
argument_list|(
name|env
argument_list|)
expr_stmt|;
else|#
directive|else
name|env
operator|=
name|environ
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTAIN_ENVIRONMENT */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
comment|/* cause SIGCHLD interrupts to look for this pid. */
name|synch_process_pid
operator|=
name|pid
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fd
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
ifdef|#
directive|ifdef
name|HAVE_PTYS
name|setpgrp
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|child_setup
argument_list|(
name|filefd
argument_list|,
name|fd1
argument_list|,
name|fd1
argument_list|,
name|new_argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
name|environ
operator|=
name|save_environ
expr_stmt|;
name|close
argument_list|(
name|filefd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Doing vfork"
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|buffer
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
ifndef|#
directive|ifndef
name|subprocesses
name|wait_without_blocking
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|subprocesses
return|return
name|Qnil
return|;
block|}
name|record_unwind_protect
argument_list|(
name|call_process_cleanup
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|buffer
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
name|Fset_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
block|{
specifier|register
name|int
name|nread
decl_stmt|;
while|while
condition|(
operator|(
name|nread
operator|=
name|read
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|insert
argument_list|(
name|buf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|display
argument_list|)
operator|&&
name|FROM_KBD
condition|)
name|redisplay_preserve_echo_area
argument_list|()
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
block|}
comment|/* Wait for it to terminate, unless it already has.  */
name|wait_for_termination
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|set_buffer_internal
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"call-process-region"
argument_list|,
argument|Fcall_process_region
argument_list|,
argument|Scall_process_region
argument_list|,
literal|3
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Send text from START to END to a process running PROGRAM.\n\ Delete the text if DELETE is non-nil.\n\ Put output in BUFFER, before point.  nil => discard it, t => current buffer.\n\ Sixth arg DISPLAY non-nil means redisplay buffer as output is inserted.\n\ Remaining args are passed to PROGRAM at startup as command args.\n\ This function normally waits for the process to terminate;\n\ if you quit, the process is killed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|filename_string
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
name|tempfile
index|[
literal|20
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tempfile
argument_list|,
literal|"/tmp/emacsXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|filename_string
operator|=
name|build_string
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|start
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|end
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|Fwrite_region
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|filename_string
argument_list|,
name|Qnil
argument_list|,
name|Qlambda
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|args
index|[
literal|3
index|]
argument_list|)
condition|)
name|Fdelete_region
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|filename_string
expr_stmt|;
name|Fcall_process
argument_list|(
name|nargs
operator|-
literal|2
argument_list|,
name|args
operator|+
literal|2
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This is the last thing run in a newly forked inferior    either synchronous or asynchronous.    Copy descriptors IN, OUT and ERR as descriptors 0, 1 and 2.    Initialize inferior's priority, pgrp, connected dir and environment.    then exec another program based on new_argv.     This function may change environ for the superior process.    Therefore, the superior process must save and restore the value    of environ around the vfork and the call to this function.     ENV is the environment */
end_comment

begin_macro
name|child_setup
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|,
argument|err
argument_list|,
argument|new_argv
argument_list|,
argument|env
argument_list|)
end_macro

begin_decl_stmt
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|subprocesses
comment|/* Close Emacs's descriptors that this process should not have.  */
name|close_process_descs
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Note that use of alloca is always safe here.  It's obvious for systems      that do not have true vfork or that have true (stack) alloca.      If using vfork and C_ALLOCA it is safe because that changes      the superior's static variables as if the superior had done alloca      and will be cleaned up in the usual way.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|current_buffer
operator|->
name|directory
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|XSTRING
argument_list|(
name|current_buffer
operator|->
name|directory
argument_list|)
operator|->
name|size
expr_stmt|;
name|temp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|current_buffer
operator|->
name|directory
argument_list|)
operator|->
name|data
argument_list|,
name|temp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp
index|[
name|i
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|temp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|chdir
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|MAINTAIN_ENVIRONMENT
comment|/* Set `env' to a vector of the strings in Vprocess_environment.  */
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|new_env
decl_stmt|;
specifier|register
name|int
name|new_length
decl_stmt|;
name|new_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|Vprocess_environment
init|;
operator|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Cons
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|==
name|Lisp_String
operator|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
name|new_length
operator|++
expr_stmt|;
comment|/* new_length + 1 to include terminating 0 */
name|env
operator|=
name|new_env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|new_length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the env strings into new_env.  */
for|for
control|(
name|tem
operator|=
name|Vprocess_environment
init|;
operator|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Cons
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|==
name|Lisp_String
operator|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
operator|*
name|new_env
operator|++
operator|=
operator|(
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|data
expr_stmt|;
operator|*
name|new_env
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Not MAINTAIN_ENVIRONMENT */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|err
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|err
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
ifndef|#
directive|ifndef
name|HAVE_PTYS
name|setpgrp
argument_list|()
expr_stmt|;
comment|/* No arguments but equivalent in this case */
endif|#
directive|endif
else|#
directive|else
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
name|setpgrp_of_tty
argument_list|(
name|pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|vipc
name|something
name|missing
name|here
decl_stmt|;
endif|#
directive|endif
endif|vipc
comment|/* execvp does not accept an environment arg so the only way      to pass this environment is to set environ.  Our caller      is responsible for restoring the ambient value of environ.  */
name|environ
operator|=
name|env
expr_stmt|;
name|execvp
argument_list|(
name|new_argv
index|[
literal|0
index|]
argument_list|,
name|new_argv
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
literal|"Couldn't exec the program "
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|new_argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|new_argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|init_callproc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|sh
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|Lisp_Object
name|execdir
decl_stmt|;
comment|/* Turn PATH_EXEC into a path.  `==' is just a string which we know      will not be the name of an environment variable.  */
name|Vexec_path
operator|=
name|decode_env_path
argument_list|(
literal|"=="
argument_list|,
name|PATH_EXEC
argument_list|)
expr_stmt|;
name|Vexec_directory
operator|=
name|Ffile_name_as_directory
argument_list|(
name|Fcar
argument_list|(
name|Vexec_path
argument_list|)
argument_list|)
expr_stmt|;
name|Vexec_path
operator|=
name|nconc2
argument_list|(
name|decode_env_path
argument_list|(
literal|"PATH"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|Vexec_path
argument_list|)
expr_stmt|;
name|execdir
operator|=
name|Fdirectory_file_name
argument_list|(
name|Vexec_directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|XSTRING
argument_list|(
name|execdir
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: executable/documentation dir (%s) does not exist.\n"
argument_list|,
name|XSTRING
argument_list|(
name|Vexec_directory
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|sh
operator|=
operator|(
name|char
operator|*
operator|)
name|egetenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
name|Vshell_file_name
operator|=
name|build_string
argument_list|(
name|sh
condition|?
name|sh
else|:
literal|"/bin/sh"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAINTAIN_ENVIRONMENT
comment|/* The equivalent of this operation was done      in init_environ in environ.c if MAINTAIN_ENVIRONMENT */
name|Vprocess_environment
operator|=
name|Qnil
expr_stmt|;
ifndef|#
directive|ifndef
name|CANNOT_DUMP
if|if
condition|(
name|initialized
condition|)
endif|#
directive|endif
for|for
control|(
name|envp
operator|=
name|environ
init|;
operator|*
name|envp
condition|;
name|envp
operator|++
control|)
name|Vprocess_environment
operator|=
name|Fcons
argument_list|(
name|build_string
argument_list|(
operator|*
name|envp
argument_list|)
argument_list|,
name|Vprocess_environment
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAINTAIN_ENVIRONMENT */
block|}
end_block

begin_macro
name|syms_of_callproc
argument_list|()
end_macro

begin_block
block|{
name|DEFVAR_LISP
argument_list|(
literal|"shell-file-name"
argument_list|,
operator|&
name|Vshell_file_name
argument_list|,
literal|"*File name to load inferior shells from.\n\ Initialized from the SHELL environment variable."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"exec-path"
argument_list|,
operator|&
name|Vexec_path
argument_list|,
literal|"*List of directories to search programs to run in subprocesses.\n\ Each element is a string (directory name) or nil (try default directory)."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"exec-directory"
argument_list|,
operator|&
name|Vexec_directory
argument_list|,
literal|"Directory that holds programs that come with GNU Emacs,\n\ intended for Emacs to invoke."
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAINTAIN_ENVIRONMENT
name|DEFVAR_LISP
argument_list|(
literal|"process-environment"
argument_list|,
operator|&
name|Vprocess_environment
argument_list|,
literal|"List of strings to append to environment of subprocesses that are started.\n\ Each string should have the format ENVVARNAME=VALUE."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|defsubr
argument_list|(
operator|&
name|Scall_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scall_process_region
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

