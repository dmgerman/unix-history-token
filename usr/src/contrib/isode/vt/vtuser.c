begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vtuser.c - VT user routines */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/vt/RCS/vtuser.c,v 7.5 91/02/22 09:48:34 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/vt/RCS/vtuser.c,v 7.5 91/02/22 09:48:34 mrose Interim $  *  *  * $Log:	vtuser.c,v $  * Revision 7.5  91/02/22  09:48:34  mrose  * Interim 6.8  *   * Revision 7.4  90/12/11  10:53:12  mrose  * lock-and-load  *   * Revision 7.3  90/10/23  20:44:48  mrose  * update  *   * Revision 7.2  90/07/09  14:52:10  mrose  * sync  *   * Revision 7.1  89/11/30  23:51:45  mrose  * pa2str  *   * Revision 7.0  89/11/23  22:32:00  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"vtpm.h"
end_include

begin_include
include|#
directive|include
file|"sector1.h"
end_include

begin_include
include|#
directive|include
file|"sector5.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_undef
undef|#
directive|undef
name|PTYBUG
end_undef

begin_comment
comment|/*When testing Break and demon not started from rc.local, 		  this turns off resetting local echo so ioctl to pty 		  will not cause demon to hang up. 		*/
end_comment

begin_undef
undef|#
directive|undef
name|PEPYPARM
end_undef

begin_define
define|#
directive|define
name|PEPYPARM
value|int *
end_define

begin_decl_stmt
specifier|extern
name|char
name|peerhost
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|PSAPaddr
name|ts_bound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myservice
init|=
literal|"terminal"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mycontext
init|=
literal|"iso vt"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mypci
init|=
literal|"iso vt pci"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ascii_go_repertoire
index|[]
init|=
block|{
literal|0x1a
block|,
literal|0x28
block|,
literal|0x42
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ESC 2/8 4/2*/
end_comment

begin_comment
comment|/*should be followed by 3 "voids" whatever that is*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|full_ascii_repertoire
index|[]
init|=
block|{
literal|0x1a
block|,
literal|0x28
block|,
literal|0x42
block|,
comment|/*VOID*/
literal|0x1a
block|,
literal|0x21
block|,
literal|0x40
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Approximation to GO& CO ASCII sets*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|isodeversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|my_displayobj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|G_Func_Units
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Functional Units for this Association*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|vcwa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Collision Winner (TRUE if owned by this peer)*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|vsmd
decl_stmt|,
name|vtok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|transparent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|na_image
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ni_image
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|VT_PROFILE
name|vtp_profile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|telnet_profile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|do_break
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_rep_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/* VASS_REQ - create an ASQ PDU and generate a VASSreq event to 	 */
end_comment

begin_comment
comment|/*			send it.					 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*	PARAMETERS - 							 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*		CLASS - class of VTP service (only BASIC supported)	 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*		ACC_RI - access rights					 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*		PROFILE - designator of the VT profile to request	 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|vass_req
argument_list|(
argument|class
argument_list|,
argument|acc_ri
argument_list|,
argument|profile
argument_list|)
end_macro

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|acc_ri
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VT_PROFILE
modifier|*
name|profile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PE
name|a_req
decl_stmt|;
name|ASQ_MSG
name|ud
decl_stmt|;
name|char
name|my_version
decl_stmt|,
name|my_fu
decl_stmt|;
name|OID
name|p_oid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|my_version
operator|=
literal|0x01
expr_stmt|;
if|if
condition|(
name|do_break
condition|)
name|my_fu
operator|=
name|destBreak
expr_stmt|;
else|else
name|my_fu
operator|=
literal|0x00
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ud
argument_list|,
sizeof|sizeof
name|ud
argument_list|)
expr_stmt|;
name|ud
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|ud
operator|.
name|valid_imp
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|coll_winner
operator|=
name|ACHOICE
expr_stmt|;
name|ud
operator|.
name|valid_coll
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|version
operator|.
name|bitstring
operator|=
name|my_version
expr_stmt|;
name|ud
operator|.
name|version
operator|.
name|bitcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|profile
operator|->
name|profile_name
argument_list|,
literal|"telnet"
argument_list|)
condition|)
block|{
name|ud
operator|.
name|valid_prof
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|oid_true
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p_oid
operator|=
name|ode2oid
argument_list|(
name|profile
operator|->
name|profile_name
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: unknown profile"
argument_list|,
name|profile
operator|->
name|profile_name
argument_list|)
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|prof_oid
operator|=
name|p_oid
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_sp_param
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_cds_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_css_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_dev_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|del_ctrl
operator|.
name|bitcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_cds_objects
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|obj_name
operator|=
literal|"D"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ud
operator|.
name|asq_profile
operator|.
name|num_cds_objects
condition|;
name|i
operator|++
control|)
block|{
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|valid_x_dim
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|valid_y_dim
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|valid_z_dim
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|erasure
operator|.
name|bitcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|valid_emp_list
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|valid_fore_color
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|valid_back_color
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|access_right
operator|.
name|bitcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|i
index|]
operator|.
name|valid_rep_list
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
condition|)
block|{
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|valid_rep_list
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|rep_offer
operator|.
name|valid_cap
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|rep_offer
operator|.
name|capability
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|rep_offer
operator|.
name|capability
operator|.
name|value
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|rep_offer
operator|.
name|num_reps
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|rep_offer
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|rep_type
operator|=
literal|2
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|rep_offer
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|valid_font_cap
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|rep_offer
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|num_fonts
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|rep_offer
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|rep_assign
operator|=
name|ascii_go_repertoire
expr_stmt|;
block|}
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|valid_x_dim
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|bound_type
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|addressing
operator|.
name|bitcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|absolute
operator|.
name|bitcount
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|window_type
operator|=
literal|2
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|window
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|window
operator|.
name|value
operator|=
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
expr_stmt|;
name|vtok
operator|=
literal|1
expr_stmt|;
name|vsmd
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|profile
operator|->
name|profile_name
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
name|ud
operator|.
name|valid_prof
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|oid_true
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_sp_param
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_cds_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_css_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|asq_profile
operator|.
name|num_dev_objects
operator|=
literal|0
expr_stmt|;
name|vtok
operator|=
literal|1
expr_stmt|;
name|vsmd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: unsupported profile"
argument_list|,
name|profile
operator|->
name|profile_name
argument_list|)
expr_stmt|;
name|ud
operator|.
name|func_units
operator|.
name|bitstring
operator|=
name|my_fu
expr_stmt|;
name|ud
operator|.
name|func_units
operator|.
name|bitcount
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|build_ASQPDU_ASQpdu
argument_list|(
operator|&
name|a_req
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|PEPYPARM
operator|)
operator|&
name|ud
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ASQ build failure (%s)"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|do_event
argument_list|(
name|VASSreq
argument_list|,
name|a_req
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*	VASS_RESP - create an ASR PDU and generate a VASSRSP event to send it.*/
end_comment

begin_comment
comment|/*									      */
end_comment

begin_comment
comment|/*	PARAMETERS - 							      */
end_comment

begin_comment
comment|/*									      */
end_comment

begin_comment
comment|/*		RESULT - SUCCESS or FAILURE				      */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_macro
name|vass_resp
argument_list|(
argument|result
argument_list|)
end_macro

begin_decl_stmt
name|int
name|result
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PE
name|a_resp
decl_stmt|;
name|char
name|my_version
decl_stmt|,
name|my_fu
decl_stmt|;
name|ASR_MSG
name|ud
decl_stmt|;
name|int
name|i
decl_stmt|;
name|my_version
operator|=
literal|0x01
expr_stmt|;
if|if
condition|(
name|G_Func_Units
operator|&
name|destBreak
condition|)
name|do_break
operator|=
literal|1
expr_stmt|;
else|else
name|do_break
operator|=
literal|0
expr_stmt|;
name|my_fu
operator|=
name|G_Func_Units
operator|&
name|destBreak
expr_stmt|;
comment|/*VT-Break is only Functional Unit 					    we will accept*/
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ud
argument_list|,
sizeof|sizeof
name|ud
argument_list|)
expr_stmt|;
name|ud
operator|.
name|valid_reason
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|ud
operator|.
name|valid_imp
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|valid_coll
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vcwa
operator|==
name|TRUE
condition|)
name|ud
operator|.
name|coll_winner
operator|=
name|ACCEPTOR
expr_stmt|;
else|else
name|ud
operator|.
name|coll_winner
operator|=
name|INITIATOR
expr_stmt|;
name|ud
operator|.
name|version
operator|.
name|bitstring
operator|=
name|my_version
expr_stmt|;
name|ud
operator|.
name|version
operator|.
name|bitcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vtp_profile
operator|.
name|profile_name
argument_list|,
literal|"telnet"
argument_list|)
condition|)
block|{
name|ud
operator|.
name|valid_arg_list
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|num_css_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|num_dev_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|num_cds_objects
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|obj_name
operator|=
literal|"D"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ud
operator|.
name|arg_list
operator|.
name|num_cds_objects
condition|;
name|i
operator|++
control|)
block|{
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|dimensions
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_x_dim
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_y_dim
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_z_dim
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_erasure
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_emp_list
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_fore_color
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_back_color
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_access_right
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|valid_rep_list
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|rep_value
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|valid_font_cap
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
name|i
index|]
operator|.
name|rep_value
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|num_fonts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|default_rep_flag
condition|)
block|{
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|valid_rep_list
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|rep_value
operator|.
name|valid_cap
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|rep_value
operator|.
name|capability
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|rep_value
operator|.
name|num_reps
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|rep_value
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|rep_type
operator|=
literal|2
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|rep_value
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|rep_assign
operator|=
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
condition|?
name|full_ascii_repertoire
else|:
name|ascii_go_repertoire
expr_stmt|;
block|}
name|ud
operator|.
name|arg_list
operator|.
name|num_sp_param
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|valid_x_dim
operator|=
literal|1
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|bound_type
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|valid_addr
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|valid_abs
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|window_type
operator|=
literal|2
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|x_dim
operator|.
name|window
operator|=
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vtp_profile
operator|.
name|profile_name
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
name|ud
operator|.
name|valid_arg_list
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|num_sp_param
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|num_cds_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|num_css_objects
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|arg_list
operator|.
name|num_dev_objects
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid profile stored"
argument_list|)
expr_stmt|;
name|ud
operator|.
name|func_units
operator|.
name|bitstring
operator|=
name|my_fu
expr_stmt|;
name|ud
operator|.
name|func_units
operator|.
name|bitcount
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|build_ASRPDU_ASRpdu
argument_list|(
operator|(
name|PE
operator|*
operator|)
operator|&
name|a_resp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|PEPYPARM
operator|)
operator|&
name|ud
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR build failure (%s) -- continuing"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_event
argument_list|(
name|VASSrsp
argument_list|,
name|a_resp
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/*	"pe" will be to store NDQ contents that could not be mapped to   */
end_comment

begin_comment
comment|/*	the cbuf because of lack of buffer space.  There is only one,    */
end_comment

begin_comment
comment|/*	because a new NDQ can be combined with "pe" rather than creating */
end_comment

begin_comment
comment|/*	a queue of PEs							 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_decl_stmt
name|PE
name|pe_buf
init|=
name|NULLPE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  VRELREQ - Generate a VRELREQ to VT State Machine		        */
end_comment

begin_comment
comment|/* 									*/
end_comment

begin_comment
comment|/*     PARAMETERS - none						*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_macro
name|vrelreq
argument_list|()
end_macro

begin_block
block|{
name|PE
name|r_req
decl_stmt|;
name|r_req
operator|=
name|NULLPE
expr_stmt|;
operator|(
name|void
operator|)
name|do_event
argument_list|(
name|VRELreq
argument_list|,
name|r_req
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/*  VRELRSP - create an RLR PDU and send it and generate a VRELRSP-S	 */
end_comment

begin_comment
comment|/* 									 */
end_comment

begin_comment
comment|/*     PARAMETERS -							 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*           RESULT - success or failure				 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_macro
name|vrelrsp
argument_list|(
argument|result
argument_list|)
end_macro

begin_decl_stmt
name|int
name|result
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|PE
name|r_rsp
decl_stmt|,
name|r_result
decl_stmt|,
name|r_coll
decl_stmt|;
if|if
condition|(
operator|(
name|r_rsp
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_CONT
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|RLR_PDU
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"RLR build failure (out of memory)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r_result
operator|=
name|num2prim
argument_list|(
operator|(
name|integer
operator|)
name|result
argument_list|,
name|PE_CLASS_CONT
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"RLR build failure (out of memory)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_add
argument_list|(
name|r_rsp
argument_list|,
name|r_result
argument_list|,
name|offset
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"RLR build failure (%s)"
argument_list|,
name|pe_error
argument_list|(
name|r_rsp
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|COLL_DET
condition|)
block|{
if|if
condition|(
operator|(
name|r_coll
operator|=
name|num2prim
argument_list|(
operator|(
name|integer
operator|)
literal|0
argument_list|,
name|PE_CLASS_CONT
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"RLR build failure (out of memory)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_add
argument_list|(
name|r_rsp
argument_list|,
name|r_coll
argument_list|,
operator|++
name|offset
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"RLR build failure (%s)"
argument_list|,
name|pe_error
argument_list|(
name|r_rsp
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seq2prim
argument_list|(
name|r_rsp
argument_list|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"RLR encode error, seq2prim: (%s)"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|do_event
argument_list|(
name|VRELrsp
argument_list|,
name|r_rsp
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|r_coll
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|r_result
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|r_rsp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|vrelcnf
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"Release Confirmed"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|vrelind
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|AcFINISHser
argument_list|(
name|sd
argument_list|,
name|pf
argument_list|,
name|aci
argument_list|)
operator|==
name|NOTOK
condition|)
name|acs_adios
argument_list|(
operator|&
name|aci
operator|->
name|aci_abort
argument_list|,
literal|"A-RELEASE.INDICATION"
argument_list|)
expr_stmt|;
name|vrelrsp
argument_list|(
name|SUCCESS
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|PE
name|p_ondq
init|=
name|NULLPE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current "ndq" being prepared for sending*/
end_comment

begin_decl_stmt
name|PE
name|p_ovtsdi
init|=
name|NULLPE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current "vtsdi"	*/
end_comment

begin_decl_stmt
name|int
name|sdi_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of "vtsdi"s in current NDQ*/
end_comment

begin_decl_stmt
name|PE
name|p_oobjupdt
init|=
name|NULLPE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current "object_update"	*/
end_comment

begin_decl_stmt
name|int
name|obj_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of "object_update"s in current "vtsdi"*/
end_comment

begin_decl_stmt
name|int
name|updt_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of updates in the current "object update"*/
end_comment

begin_decl_stmt
name|int
name|cur_emode
init|=
name|NOT_ECHO_NOW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* echo mode (ECHO_NOW or NOT_ECHO_NOW)*/
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/*	VT_TEXT - Add a text update to the PE that represents 		 */
end_comment

begin_comment
comment|/*	an NDQ of buffered updates awaiting delivery.			 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*	When we do a control object update, the current buffer of	 */
end_comment

begin_comment
comment|/*	display object updates is terminated and a new one will be	 */
end_comment

begin_comment
comment|/*	started next time a display object update is queued.		 */
end_comment

begin_comment
comment|/*	(this is so we can synchronize control updates with		 */
end_comment

begin_comment
comment|/*	display updates.)						 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*	Likewise, whenever we queue a display object update, we		 */
end_comment

begin_comment
comment|/*	terminate the current sequence of control object updates.	 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*	Whenever we change echo mode (ECHO_NOW or NOT_ECHO_NOW)		 */
end_comment

begin_comment
comment|/*	we have to start a new "vtsdi".					 */
end_comment

begin_comment
comment|/*	This requires that we terminate the current buffers of		 */
end_comment

begin_comment
comment|/*	display object and control object updates.			 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*	PARAMETERS - 							 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*		STR - the character string to be added to the NDQ PDU.	 */
end_comment

begin_comment
comment|/*		LEN - Number of characters in the string.		 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_macro
name|vt_text
argument_list|(
argument|str
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TEXT_UPDATE
name|ud
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|6
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|ll_log
argument_list|(
name|vt_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"vt_text sending"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ll_printf
argument_list|(
name|vt_log
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|ll_printf
argument_list|(
name|vt_log
argument_list|,
literal|"%02x "
argument_list|,
operator|*
operator|(
name|str
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ll_printf
argument_list|(
name|vt_log
argument_list|,
literal|">>\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ll_sync
argument_list|(
name|vt_log
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ud
argument_list|,
sizeof|sizeof
name|ud
argument_list|)
expr_stmt|;
name|ud
operator|.
name|echo_sw
operator|=
name|cur_emode
expr_stmt|;
name|ud
operator|.
name|type_sw
operator|=
literal|0
expr_stmt|;
comment|/*Display object*/
name|ud
operator|.
name|updates
operator|.
name|do_list
operator|.
name|do_name
operator|=
name|my_displayobj
expr_stmt|;
name|ud
operator|.
name|updates
operator|.
name|do_list
operator|.
name|do_type
operator|=
name|DO_TEXT
expr_stmt|;
comment|/*Text*/
name|ud
operator|.
name|updates
operator|.
name|do_list
operator|.
name|do_cmd
operator|.
name|text_ud
operator|.
name|text_ptr
operator|=
name|str
expr_stmt|;
name|ud
operator|.
name|updates
operator|.
name|do_list
operator|.
name|do_cmd
operator|.
name|text_ud
operator|.
name|text_count
operator|=
name|len
expr_stmt|;
name|send_queue
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|send_queue
argument_list|(
argument|ud
argument_list|)
end_macro

begin_comment
comment|/*Build NDQ with update supplied in ud structure*/
end_comment

begin_decl_stmt
name|TEXT_UPDATE
name|ud
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PE
name|vtsdip
decl_stmt|;
if|if
condition|(
name|p_ondq
operator|==
name|NULLPE
condition|)
comment|/*Nothing waiting to be sent*/
block|{
if|if
condition|(
name|build_NDQPDU_NDQpdu
argument_list|(
operator|&
name|p_ondq
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|PEPYPARM
operator|)
operator|&
name|ud
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"NDQ build failure (%s)"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|p_ondq
operator|->
name|pe_context
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|build_NDQPDU_VTsdi
argument_list|(
operator|&
name|vtsdip
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|ud
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"VTsdi build failure (%s)"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|vtsdip
operator|->
name|pe_context
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|seq_add
argument_list|(
name|p_ondq
argument_list|,
name|vtsdip
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"NDQ build failure (%s)"
argument_list|,
name|pe_error
argument_list|(
name|p_ondq
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* SETEMODE - set echo mode  	PARAMETERS -   		MODE - ECHO_NOW or NOT_ECHO_NOW  */
end_comment

begin_macro
name|setemode
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|mode
operator|!=
name|ECHO_NOW
operator|&&
name|mode
operator|!=
name|NOT_ECHO_NOW
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
name|cur_emode
operator|!=
name|mode
condition|)
block|{
name|p_ovtsdi
operator|=
name|NULLPE
expr_stmt|;
name|sdi_count
operator|=
literal|0
expr_stmt|;
name|p_oobjupdt
operator|=
name|NULLPE
expr_stmt|;
name|obj_count
operator|=
literal|0
expr_stmt|;
name|cur_emode
operator|=
name|mode
expr_stmt|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* this data structure will buffer character output    that is ready to be read by the application or terminal. */
end_comment

begin_define
define|#
directive|define
name|CBUFSIZE
value|10240
end_define

begin_struct
struct|struct
name|char_buffer
block|{
name|int
name|max_len
decl_stmt|,
name|queued
decl_stmt|;
name|unsigned
name|char
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|CBUFSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|char_buffer
name|cbuf
init|=
block|{
name|CBUFSIZE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* GETCH - get a character from the buffer waiting to 			*/
end_comment

begin_comment
comment|/*			be read by the application			*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*	RETURNS - the character, NOTOK if no data, or an error code (<0)*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
name|int
name|getch
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|data_pending
argument_list|()
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
operator|!
name|connected
condition|)
return|return
operator|(
name|E_EOF
operator|)
return|;
else|else
return|return
operator|(
name|WOULDBLOCK
operator|)
return|;
block|}
name|c
operator|=
operator|*
name|cbuf
operator|.
name|head
expr_stmt|;
if|if
condition|(
operator|++
name|cbuf
operator|.
name|head
operator|>=
name|cbuf
operator|.
name|buf
operator|+
name|CBUFSIZE
condition|)
name|cbuf
operator|.
name|head
operator|=
name|cbuf
operator|.
name|buf
expr_stmt|;
name|cbuf
operator|.
name|queued
operator|--
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"normal return from getch, c is %c,queued is %d"
argument_list|,
name|c
argument_list|,
name|cbuf
operator|.
name|queued
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* at some point we need to use the async. interface to the network    so that at any time when data becomes available, we trap to a vtpm    function to handle it.  This function will examine the type of    network event and act accordingly.  Each time the function is invoked    it should completely process the data received and free the PSAPdata    structure for use in processing the next network event.      If it is an expedited     data request, for instance, it is treated differently from a P-DATA.      If an NDQ is    received all the data should be read from the PSAPread structure and    mapped to the cbuf.    If the cbuf fills up in the process of doing this, the PE containing the    remaining updates should be put in a queue of pending PEs. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This macro does the same thing as PXFREE except it does not free    the PEs in the px_info array.  We will use this instead of PXFREE    because we need to free the data PEs one at a time as they are     processed.      Any unprocessed (pending) PEs are maintained in a queue    by the VTPM. If some of the PEs received from a PDATArequest are in    this queue a call to PXFREE would free the    data and leave dangling references in the queue.     Note that the vtuser may have at most one unprocessed or partially    processed PE.  The VTPM can potentially have any number of unprocessed    PEs in its queue. */
end_comment

begin_define
define|#
directive|define
name|PFIN
parameter_list|(
name|px
parameter_list|)
define|\
value|{ \     register int PXI; \  \     if ((px) -> px_realinfo) \ 		pe_free ((px) -> px_realinfo), (px) -> px_realinfo = NULLPE; \     else { \ 		for (PXI = (px) -> px_ninfo - 1; PXI>= 0; PXI--) \ 			if ((px) -> px_info[PXI]) \ 				(px) -> px_info[PXI] = NULLPE; \ 		(px) -> px_ninfo = 0; \     } \ }
end_define

begin_escape
end_escape

begin_function
name|int
name|data_pending
parameter_list|()
block|{
name|int
name|result
decl_stmt|;
name|PE
modifier|*
name|peptr
init|=
name|NULLPEP
decl_stmt|;
if|if
condition|(
name|queued
argument_list|()
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* something was already in the cbuf 		*/
if|if
condition|(
name|pe_buf
operator|!=
name|NULLPE
condition|)
block|{
comment|/* there seems to be something to map 		*/
name|map
argument_list|(
name|pe_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|queued
argument_list|()
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|result
operator|=
name|get_event
argument_list|(
name|sd
argument_list|,
name|peptr
argument_list|)
expr_stmt|;
comment|/* if there was no network event 	*/
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* get_event may have resulted in data being read and mapped to the 	   cbuf 	*/
if|if
condition|(
name|queued
argument_list|()
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* if there is no data left and get_event resulted in the association 	   being released 	*/
if|if
condition|(
operator|!
name|connected
condition|)
block|{
operator|(
name|void
operator|)
name|putch
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* there's nothing to read right now, but we're still connected 	*/
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|queued
parameter_list|()
block|{
return|return
operator|(
name|cbuf
operator|.
name|queued
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/* 	PUTCH - put a character on the buffer to be read by the		 */
end_comment

begin_comment
comment|/*			application					 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*	RETURNS - OK on success, NOTOK otherwise			 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_function
name|int
name|putch
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"in putch, queued is %d, c is %c"
argument_list|,
name|cbuf
operator|.
name|queued
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"cbuf.buf is %d, cbuf.head is %d, cbuf.tail is %d"
argument_list|,
operator|(
name|int
operator|)
name|cbuf
operator|.
name|buf
argument_list|,
operator|(
name|int
operator|)
name|cbuf
operator|.
name|head
argument_list|,
operator|(
name|int
operator|)
name|cbuf
operator|.
name|tail
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"cbuf.max_len is %d"
argument_list|,
operator|(
name|int
operator|)
name|cbuf
operator|.
name|max_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cbuf
operator|.
name|queued
operator|>=
name|CBUFSIZE
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"***********************\nputch: queued exceeds CBUFSIZE ***************"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|cbuf
operator|.
name|queued
operator|<=
literal|0
condition|)
block|{
name|cbuf
operator|.
name|tail
operator|=
name|cbuf
operator|.
name|head
operator|=
name|cbuf
operator|.
name|buf
expr_stmt|;
name|cbuf
operator|.
name|queued
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"tail and head set to %d"
argument_list|,
operator|(
name|int
operator|)
name|cbuf
operator|.
name|buf
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|cbuf
operator|.
name|tail
operator|)
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|cbuf
operator|.
name|tail
operator|)
operator|>
name|cbuf
operator|.
name|buf
operator|+
name|CBUFSIZE
condition|)
name|cbuf
operator|.
name|tail
operator|=
name|cbuf
operator|.
name|buf
expr_stmt|;
name|cbuf
operator|.
name|queued
operator|++
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/*	VTSEND - send the updates that have been put into the PE	 */
end_comment

begin_comment
comment|/*			called "p_ondq".				 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_macro
name|vtsend
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|p_ondq
operator|==
name|NULLPE
condition|)
return|return;
name|vtdata
argument_list|(
name|p_ondq
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|p_ondq
argument_list|)
expr_stmt|;
name|p_ondq
operator|=
name|NULLPE
expr_stmt|;
name|p_ovtsdi
operator|=
name|NULLPE
expr_stmt|;
name|sdi_count
operator|=
literal|0
expr_stmt|;
name|p_oobjupdt
operator|=
name|NULLPE
expr_stmt|;
name|obj_count
operator|=
literal|0
expr_stmt|;
name|updt_count
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* VTDATA - generate a VDATREQ event to send an NDQ			*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*	PARAMETERS							*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*		NDQ - a presentation element containing an NDQ.		*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_macro
name|vtdata
argument_list|(
argument|ndq
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|ndq
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ndq
operator|==
name|NULLPE
condition|)
return|return;
operator|(
name|void
operator|)
name|do_event
argument_list|(
name|VDATreq_n
argument_list|,
name|ndq
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* MKDELIVER - create a DLQ. Requests for an acknowlegement are not	*/
end_comment

begin_comment
comment|/*		allowed at this time.					*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
name|PE
name|mkdeliver
parameter_list|(
name|ack
parameter_list|)
name|int
name|ack
decl_stmt|;
block|{
name|PE
name|p_dlq
decl_stmt|;
if|if
condition|(
name|ack
operator|!=
name|FALSE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"DLQ PDUs can only be sent without an ACK request"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_dlq
operator|=
name|bool2prim
argument_list|(
name|ack
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"DLQ build failure (out of memory)"
argument_list|)
expr_stmt|;
name|p_dlq
operator|->
name|pe_id
operator|=
name|DLQ_PDU
expr_stmt|;
name|p_dlq
operator|->
name|pe_class
operator|=
name|PE_CLASS_CONT
expr_stmt|;
name|p_dlq
operator|->
name|pe_context
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|p_dlq
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* VDELREQ - create a deliver request PE and generate a VDELreq		  */
end_comment

begin_comment
comment|/*			event to send it.				  */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_macro
name|vdelreq
argument_list|(
argument|ack
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ack
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PE
name|p_dlq
decl_stmt|;
if|if
condition|(
name|ack
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ACK requests in deliver PDUs not supported at this time"
argument_list|)
expr_stmt|;
name|p_dlq
operator|=
name|mkdeliver
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|do_event
argument_list|(
name|VDELreq
argument_list|,
name|p_dlq
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* VDELIND - we queue up data to go to the terminal when the NDQ	  */
end_comment

begin_comment
comment|/*			is received, so there's really nothing		  */
end_comment

begin_comment
comment|/*			to do when we get a VDELIND			  */
end_comment

begin_comment
comment|/*									  */
end_comment

begin_comment
comment|/*	PARAMETERS: 							  */
end_comment

begin_comment
comment|/*			ACK - TRUE or FALSE according to whether 	  */
end_comment

begin_comment
comment|/*			acknowledgement is requested or not.		  */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_macro
name|vdelind
argument_list|(
argument|del_pe
argument_list|,
argument|ack
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|del_pe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ack
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ack
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"vdelind with ack requested not implemented!"
argument_list|)
expr_stmt|;
block|}
name|pe_free
argument_list|(
name|del_pe
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* VDATIND - On receiving a data indication we will go ahead and	*/
end_comment

begin_comment
comment|/* map the contents onto the character buffer to go to the terminal	*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/* PARAMETERS - "type" can be SEQUENCED or NONSEQUENCED			*/
end_comment

begin_comment
comment|/*				only SEQUENCED is implemented now	*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_macro
name|vdatind
argument_list|(
argument|type
argument_list|,
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|type
operator|!=
name|SEQUENCED
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unimplemented NDQ type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|map
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vhdatind
argument_list|(
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"vhdatind(): HDQ's not supported\n"
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vudatind
argument_list|(
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TEXT_UPDATE
name|ud
decl_stmt|;
if|if
condition|(
name|unbuild_UDQPDU_UDQpdu
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|(
name|PEPYPARM
operator|)
operator|&
name|ud
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"UDQ parse failure\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|control_ud
argument_list|(
operator|(
name|CO_UPDATE
operator|*
operator|)
operator|&
operator|(
name|ud
operator|.
name|updates
operator|.
name|co_list
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ud
operator|.
name|updates
operator|.
name|co_list
operator|.
name|co_name
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* Connect_request:							     */
end_comment

begin_comment
comment|/*									     */
end_comment

begin_comment
comment|/*	Sends an ASQ, waits for a confirm.				     */
end_comment

begin_comment
comment|/*									     */
end_comment

begin_comment
comment|/*	Returns the file descriptor that corresponds to the network socket   */
end_comment

begin_comment
comment|/*	for the association, or NOTOK if the association failed.	     */
end_comment

begin_comment
comment|/*									     */
end_comment

begin_comment
comment|/*	The assumption is made that the acs_sd data element of the AcSAPstart*/
end_comment

begin_comment
comment|/*	structure is same as the file descriptor for the network socket used */
end_comment

begin_comment
comment|/*	by the association.						     */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_macro
name|con_req
argument_list|()
end_macro

begin_block
block|{
name|int
name|uevent
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"in con_req"
argument_list|)
expr_stmt|;
name|vass_req
argument_list|(
literal|1
argument_list|,
name|WACI_WACA
argument_list|,
operator|&
name|vtp_profile
argument_list|)
expr_stmt|;
if|if
condition|(
name|acc
operator|->
name|acc_result
operator|!=
name|ACS_ACCEPT
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"association rejected: [%s]"
argument_list|,
name|AcErrString
argument_list|(
name|acc
operator|->
name|acc_result
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|S1_01
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"got associate confirm event, sd is %d"
argument_list|,
name|acc
operator|->
name|acc_sd
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"acc_ninfo is %d"
argument_list|,
name|acc
operator|->
name|acc_ninfo
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"pe_id is %d"
argument_list|,
name|acc
operator|->
name|acc_info
index|[
literal|0
index|]
operator|->
name|pe_id
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"pe_class is %d"
argument_list|,
name|acc
operator|->
name|acc_info
index|[
literal|0
index|]
operator|->
name|pe_class
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"pe_form is %d"
argument_list|,
name|acc
operator|->
name|acc_info
index|[
literal|0
index|]
operator|->
name|pe_form
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acc
operator|->
name|acc_ninfo
operator|<
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no ASQ PDU sent with the associate confirm"
argument_list|)
expr_stmt|;
name|sd
operator|=
name|acc
operator|->
name|acc_sd
expr_stmt|;
name|uevent
operator|=
name|do_event
argument_list|(
name|ASR
argument_list|,
name|acc
operator|->
name|acc_info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"got user event %d"
argument_list|,
name|uevent
argument_list|)
expr_stmt|;
if|if
condition|(
name|uevent
operator|==
name|SUCCESS
condition|)
return|return
operator|(
name|sd
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|read_asq
argument_list|(
argument|pe
argument_list|)
end_macro

begin_comment
comment|/*Unwrap ASQ PDU.  Use information it contains to fill in 		  some global values (profile_id,G_Func_Units,vcwa). 		  Return 0 if ASQ is improperly formatted or missing a 		  required field.  For now, only the more obvious fields are 		  checked  and only transparent and telnet profiles 		  are handled.  Return PROFILE_NG if profile is not 		  supported.  Return 1 if ASQ is valid. 		*/
end_comment

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|D
decl_stmt|;
name|ASQ_MSG
name|ud
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ud
argument_list|,
sizeof|sizeof
name|ud
argument_list|)
expr_stmt|;
if|if
condition|(
name|unbuild_ASQPDU_ASQpdu
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|(
name|PEPYPARM
operator|)
operator|&
name|ud
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"ASQ parse failure (%s)"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ud
operator|.
name|class
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASQ without Class"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ud
operator|.
name|valid_coll
condition|)
block|{
if|if
condition|(
name|ud
operator|.
name|coll_winner
operator|==
name|INITIATOR
condition|)
name|vcwa
operator|=
name|FALSE
expr_stmt|;
else|else
name|vcwa
operator|=
name|TRUE
expr_stmt|;
block|}
name|G_Func_Units
operator|=
name|ud
operator|.
name|func_units
operator|.
name|bitstring
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ud
operator|.
name|valid_prof
operator|)
operator|||
operator|(
operator|!
name|ud
operator|.
name|asq_profile
operator|.
name|oid_true
operator|)
operator|||
operator|!
name|oid_cmp
argument_list|(
name|ud
operator|.
name|asq_profile
operator|.
name|prof_oid
argument_list|,
name|ode2oid
argument_list|(
literal|"default"
argument_list|)
argument_list|)
condition|)
block|{
name|vtp_profile
operator|.
name|profile_name
operator|=
literal|"default"
expr_stmt|;
name|my_displayobj
operator|=
literal|"DISPLAY-OBJECT-1"
expr_stmt|;
name|telnet_profile
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|oid_cmp
argument_list|(
name|ud
operator|.
name|asq_profile
operator|.
name|prof_oid
argument_list|,
name|ode2oid
argument_list|(
literal|"telnet"
argument_list|)
argument_list|)
condition|)
block|{
name|vtp_profile
operator|.
name|profile_name
operator|=
literal|"telnet"
expr_stmt|;
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|=
literal|0xff
expr_stmt|;
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
operator|=
operator|-
literal|1
expr_stmt|;
name|D
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ud
operator|.
name|asq_profile
operator|.
name|num_cds_objects
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|n
index|]
operator|.
name|obj_name
operator|==
literal|'D'
condition|)
block|{
name|D
operator|=
name|n
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|D
operator|<
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASQ with no D Display Object"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|valid_rep_list
condition|)
block|{
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|=
literal|1
expr_stmt|;
name|default_rep_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/*Repertoire specified*/
block|{
if|if
condition|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|rep_offer
operator|.
name|num_reps
operator|>
name|MAXREPS
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASQ with too many repertoires"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|rep_offer
operator|.
name|num_reps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|rep_offer
operator|.
name|repertoire
index|[
name|i
index|]
operator|.
name|rep_type
operator|!=
literal|2
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|rep_offer
operator|.
name|repertoire
index|[
name|i
index|]
operator|.
name|rep_assign
argument_list|,
name|ascii_go_repertoire
argument_list|,
sizeof|sizeof
argument_list|(
name|ascii_go_repertoire
argument_list|)
argument_list|)
condition|)
block|{
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|=
literal|0
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"Using ASCII GO Repertoire."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|rep_offer
operator|.
name|repertoire
index|[
name|i
index|]
operator|.
name|rep_assign
argument_list|,
name|full_ascii_repertoire
argument_list|,
sizeof|sizeof
argument_list|(
name|full_ascii_repertoire
argument_list|)
argument_list|)
condition|)
block|{
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|transparent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|valid_x_dim
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASQ with no X-Window"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|x_dim
operator|.
name|window_type
operator|!=
literal|2
condition|)
comment|/*If not integer type window field*/
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASQ with invalid X-Window"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|x_dim
operator|.
name|window
operator|.
name|type
operator|==
literal|0
condition|)
comment|/*If single value*/
block|{
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
operator|=
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|x_dim
operator|.
name|window
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|x_dim
operator|.
name|window
operator|.
name|type
operator|==
literal|1
condition|)
comment|/*If range*/
block|{
if|if
condition|(
operator|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|x_dim
operator|.
name|window
operator|.
name|min_val
operator|<=
literal|80
operator|)
operator|&&
operator|(
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|x_dim
operator|.
name|window
operator|.
name|max_val
operator|>=
literal|80
operator|)
condition|)
block|{
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
operator|=
literal|80
expr_stmt|;
block|}
else|else
block|{
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
operator|=
name|ud
operator|.
name|asq_profile
operator|.
name|cds_offer_list
index|[
name|D
index|]
operator|.
name|x_dim
operator|.
name|window
operator|.
name|min_val
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
operator|<
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASQ without x-window"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|<
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"Using Default for ASCII repertoire (Full ASCII)"
argument_list|)
expr_stmt|;
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"Unknown Profile Requested"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PROFILE_NG
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|vasscnf
argument_list|(
argument|pe
argument_list|)
end_macro

begin_comment
comment|/*Handle ASR received from Acceptor*/
end_comment

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ASR_MSG
name|udr
decl_stmt|;
name|int
name|rep
decl_stmt|,
name|n
decl_stmt|;
name|int
name|window_flag
init|=
literal|0
decl_stmt|;
name|int
name|rep_flag
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|udr
argument_list|,
sizeof|sizeof
name|udr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unbuild_ASRPDU_ASRpdu
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|(
name|PEPYPARM
operator|)
operator|&
name|udr
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR parse failure (%s)"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|udr
operator|.
name|result
operator|!=
name|SUCCESS
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"Association rejected by Peer VT"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|udr
operator|.
name|valid_coll
condition|)
name|vcwa
operator|=
name|udr
operator|.
name|coll_winner
expr_stmt|;
else|else
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"Received ASR with no collision winner"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vtp_profile
operator|.
name|profile_name
argument_list|,
literal|"transparent"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|udr
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|valid_rep_list
condition|)
comment|/*No repertoires*/
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tr_arg_list
operator|.
name|cur_rep
argument_list|,
name|TRANSPARENT
argument_list|)
condition|)
comment|/*If don't want default for this profile*/
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR with no repertoire"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tr_arg_list
operator|.
name|cur_rep
argument_list|,
name|udr
operator|.
name|arg_list
operator|.
name|cds_val
index|[
literal|0
index|]
operator|.
name|rep_value
operator|.
name|repertoire
index|[
literal|0
index|]
operator|.
name|rep_assign
argument_list|)
condition|)
comment|/*Only support 1 repertoire in transparent*/
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR--Invalid repertoire for transparent profile"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vtp_profile
operator|.
name|profile_name
argument_list|,
literal|"telnet"
argument_list|)
condition|)
block|{
if|if
condition|(
name|udr
operator|.
name|arg_list
operator|.
name|num_sp_param
operator|<
literal|1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR without enough Special Arguments"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|udr
operator|.
name|arg_list
operator|.
name|num_sp_param
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|udr
operator|.
name|arg_list
operator|.
name|sp_val
index|[
name|n
index|]
operator|.
name|param_num
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|udr
operator|.
name|arg_list
operator|.
name|sp_val
index|[
name|n
index|]
operator|.
name|param_type
operator|==
literal|1
condition|)
comment|/*If integer type*/
block|{
if|if
condition|(
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|x_window
operator|!=
name|udr
operator|.
name|arg_list
operator|.
name|sp_val
index|[
name|n
index|]
operator|.
name|args
operator|.
name|int_arg
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR with invalid X-Window"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
else|else
operator|++
name|window_flag
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|udr
operator|.
name|arg_list
operator|.
name|sp_val
index|[
name|n
index|]
operator|.
name|param_num
operator|==
literal|2
condition|)
comment|/*ASCII Repertoire type*/
block|{
if|if
condition|(
name|udr
operator|.
name|arg_list
operator|.
name|sp_val
index|[
name|n
index|]
operator|.
name|param_type
operator|==
literal|0
condition|)
comment|/*If Boolean*/
block|{
if|if
condition|(
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
condition|)
name|rep
operator|=
literal|1
expr_stmt|;
else|else
name|rep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|udr
operator|.
name|arg_list
operator|.
name|sp_val
index|[
name|n
index|]
operator|.
name|args
operator|.
name|bool_arg
operator|!=
name|rep
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR with invalid Repertoire"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
operator|++
name|rep_flag
expr_stmt|;
block|}
block|}
block|}
comment|/*End for loop*/
if|if
condition|(
operator|!
name|window_flag
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR without x-window"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|rep_flag
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ASR with no repertoire"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|asq
argument_list|(
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|srequirements
decl_stmt|;
name|struct
name|PSAPctxlist
name|vclist
decl_stmt|;
name|OID
name|vt_asn
decl_stmt|;
name|struct
name|QOStype
name|qos
decl_stmt|;
name|qos
operator|.
name|qos_reliability
operator|=
name|HIGH_QUALITY
expr_stmt|;
name|qos
operator|.
name|qos_sversion
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"in asq"
argument_list|)
expr_stmt|;
name|acc
operator|=
operator|&
name|accs
expr_stmt|;
name|acr
operator|=
operator|&
name|acrs
expr_stmt|;
name|aci
operator|=
operator|&
name|acis
expr_stmt|;
comment|/*	 I'm relying on "peerhost" being an external char * that 	has the name of the host we want to connect to */
if|if
condition|(
operator|(
name|aei
operator|=
name|_str2aei
argument_list|(
name|peerhost
argument_list|,
name|myservice
argument_list|,
literal|"iso vt"
argument_list|,
literal|1
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
operator|)
operator|==
name|NULLAEI
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to resolve service: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pa
operator|=
name|aei2addr
argument_list|(
name|aei
argument_list|)
operator|)
operator|==
name|NULLPA
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"address translation failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|=
name|ode2oid
argument_list|(
name|mycontext
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: unknown object descriptor"
argument_list|,
name|mycontext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|=
name|oid_cpy
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pci
operator|=
name|ode2oid
argument_list|(
name|mypci
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: unknown object descriptor"
argument_list|,
name|mypci
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pci
operator|=
name|oid_cpy
argument_list|(
name|pci
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sf
operator|=
name|addr2ref
argument_list|(
name|PLocalHostName
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sf
operator|=
operator|&
name|sfs
expr_stmt|;
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sf
argument_list|,
sizeof|sizeof
expr|*
name|sf
argument_list|)
expr_stmt|;
block|}
name|PLOG
argument_list|(
name|vt_log
argument_list|,
name|print_VT_PDUs
argument_list|,
name|data
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aca
operator|=
operator|&
name|aci
operator|->
name|aci_abort
expr_stmt|;
name|srequirements
operator|=
name|SR_DUPLEX
operator||
name|SR_RESYNC
operator||
name|SR_TYPEDATA
expr_stmt|;
name|srequirements
operator|&=
operator|~
name|SR_RLS_EXISTS
expr_stmt|;
if|if
condition|(
operator|(
name|vt_asn
operator|=
name|oid_cpy
argument_list|(
name|pci
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|vclist
operator|.
name|pc_nctx
operator|=
literal|1
expr_stmt|;
name|vclist
operator|.
name|pc_ctx
index|[
literal|0
index|]
operator|.
name|pc_id
operator|=
literal|1
expr_stmt|;
name|vclist
operator|.
name|pc_ctx
index|[
literal|0
index|]
operator|.
name|pc_asn
operator|=
name|vt_asn
expr_stmt|;
name|vclist
operator|.
name|pc_ctx
index|[
literal|0
index|]
operator|.
name|pc_atn
operator|=
name|NULLOID
expr_stmt|;
name|data
operator|->
name|pe_context
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|AcAssocRequest
argument_list|(
name|ctx
argument_list|,
name|NULLAEI
argument_list|,
name|aei
argument_list|,
name|NULLPA
argument_list|,
name|pa
argument_list|,
operator|&
name|vclist
argument_list|,
name|pci
argument_list|,
literal|0
argument_list|,
name|srequirements
argument_list|,
name|SERIAL_MIN
argument_list|,
literal|0
argument_list|,
name|sf
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|,
operator|&
name|qos
argument_list|,
name|acc
argument_list|,
name|aci
argument_list|)
operator|==
name|NOTOK
condition|)
name|acs_adios
argument_list|(
name|aca
argument_list|,
literal|"A-ASSOCIATE.REQUEST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|acc
operator|->
name|acc_result
operator|!=
name|ACS_ACCEPT
condition|)
return|return;
name|sd
operator|=
name|acc
operator|->
name|acc_sd
expr_stmt|;
name|ts_bound
operator|=
name|acc
operator|->
name|acc_connect
operator|.
name|pc_responding
expr_stmt|;
comment|/* struct copy */
ifdef|#
directive|ifdef
name|DEBUG
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|PSAPconnect
modifier|*
name|pc
init|=
operator|&
name|acc
operator|->
name|acc_connect
decl_stmt|;
specifier|register
name|struct
name|PSAPctxlist
modifier|*
name|pl
init|=
operator|&
name|pc
operator|->
name|pc_ctxlist
decl_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"context: %s"
argument_list|,
name|oid2ode
argument_list|(
name|acc
operator|->
name|acc_context
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"responding AE title: %s, responding PSAP address: %s"
argument_list|,
name|sprintaei
argument_list|(
operator|&
name|acc
operator|->
name|acc_respondtitle
argument_list|)
argument_list|,
name|paddr2str
argument_list|(
operator|&
name|pc
operator|->
name|pc_responding
argument_list|,
name|NULLNA
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pl
operator|->
name|pc_nctx
condition|;
name|i
operator|++
control|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"ctx %d: 0x%x 0x%x %d"
argument_list|,
name|pl
operator|->
name|pc_ctx
index|[
name|i
index|]
operator|.
name|pc_id
argument_list|,
name|pl
operator|->
name|pc_ctx
index|[
name|i
index|]
operator|.
name|pc_asn
argument_list|,
name|pl
operator|->
name|pc_ctx
index|[
name|i
index|]
operator|.
name|pc_atn
argument_list|,
name|pl
operator|->
name|pc_ctx
index|[
name|i
index|]
operator|.
name|pc_result
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"default %d"
argument_list|,
name|pc
operator|->
name|pc_defctxresult
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"p/s requirements 0x%x/0x%x"
argument_list|,
name|pc
operator|->
name|pc_prequirements
argument_list|,
name|pc
operator|->
name|pc_srequirements
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_macro
name|vt_disconnect
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|AcRelRequest
argument_list|(
name|sd
argument_list|,
name|ACF_NORMAL
argument_list|,
name|NULLPEP
argument_list|,
literal|0
argument_list|,
name|NOTOK
argument_list|,
name|acr
argument_list|,
name|aci
argument_list|)
operator|==
name|NOTOK
condition|)
name|acs_adios
argument_list|(
name|aca
argument_list|,
literal|"A-RELEASE.REQUEST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|acr
operator|->
name|acr_affirmative
condition|)
block|{
name|connected
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|do_event
argument_list|(
name|RLR
argument_list|,
name|acr
operator|->
name|acr_info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|ACRFREE
argument_list|(
name|acr
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_define
define|#
directive|define
name|ASYNC
value|0
end_define

begin_define
define|#
directive|define
name|RMASK
define|\
value|"\020\01HALFDUPLEX\02DUPLEX\03EXPEDITED\04MINORSYNC\05MAJORSYNC\06RESYNC\ \07ACTIVITY\010NEGOTIATED\011CAPABILITY\012EXCEPTIONS\013TYPEDATA"
end_define

begin_define
define|#
directive|define
name|PMASK
define|\
value|"\020\01MANAGEMENT\02RESTORATION"
end_define

begin_comment
comment|/*
comment|DATA */
end_comment

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|result
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*PE	pe;*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/*    ASS_IND 								 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_macro
name|ass_ind
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|PSAPctxlist
modifier|*
name|pl
decl_stmt|;
name|aca
operator|=
operator|&
name|aci
operator|->
name|aci_abort
expr_stmt|;
name|ps
operator|=
operator|&
name|acs
operator|->
name|acs_start
expr_stmt|;
name|pl
operator|=
operator|&
name|ps
operator|->
name|ps_ctxlist
expr_stmt|;
if|if
condition|(
name|AcInit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|acs
argument_list|,
name|aci
argument_list|)
operator|==
name|NOTOK
condition|)
name|acs_adios
argument_list|(
name|aca
argument_list|,
literal|"initialization fails"
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"A-ASSOCIATE.INDICATION:<%d, %s, %s, %s, %d>"
argument_list|,
name|acs
operator|->
name|acs_sd
argument_list|,
name|oid2ode
argument_list|(
name|acs
operator|->
name|acs_context
argument_list|)
argument_list|,
name|sprintaei
argument_list|(
operator|&
name|acs
operator|->
name|acs_callingtitle
argument_list|)
argument_list|,
name|sprintaei
argument_list|(
operator|&
name|acs
operator|->
name|acs_calledtitle
argument_list|)
argument_list|,
name|acs
operator|->
name|acs_ninfo
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"PSAP:<%d, %s, %s, %d, %s,"
argument_list|,
name|ps
operator|->
name|ps_sd
argument_list|,
name|paddr2str
argument_list|(
operator|&
name|ps
operator|->
name|ps_calling
argument_list|,
name|NULLNA
argument_list|)
argument_list|,
name|paddr2str
argument_list|(
operator|&
name|ps
operator|->
name|ps_called
argument_list|,
name|NULLNA
argument_list|)
argument_list|,
name|pl
operator|->
name|pc_nctx
argument_list|,
name|sprintb
argument_list|(
name|ps
operator|->
name|ps_prequirements
argument_list|,
name|PMASK
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"  %s, %d, %d>"
argument_list|,
name|sprintb
argument_list|(
name|ps
operator|->
name|ps_srequirements
argument_list|,
name|RMASK
argument_list|)
argument_list|,
name|ps
operator|->
name|ps_isn
argument_list|,
name|ps
operator|->
name|ps_ssdusize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|peerhost
argument_list|,
name|na2str
argument_list|(
name|ps
operator|->
name|ps_calling
operator|.
name|pa_addr
operator|.
name|sa_addr
operator|.
name|ta_addrs
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|=
name|acs
operator|->
name|acs_sd
expr_stmt|;
comment|/*	ACSFREE(acs); */
name|PLOG
argument_list|(
name|vt_log
argument_list|,
name|print_VT_PDUs
argument_list|,
name|acs
operator|->
name|acs_info
index|[
literal|0
index|]
argument_list|,
name|NULLCP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_event
argument_list|(
name|ASQ
argument_list|,
name|acs
operator|->
name|acs_info
index|[
literal|0
index|]
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|vassind
argument_list|(
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|vass_resp
argument_list|(
name|SUCCESS
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|vbrkreq
argument_list|()
end_macro

begin_block
block|{
name|PE
name|brk_pe
decl_stmt|;
name|BRcnt
name|brk
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|brk
argument_list|,
sizeof|sizeof
name|brk
argument_list|)
expr_stmt|;
name|brk
operator|.
name|BKQcont
operator|.
name|token_val
operator|=
name|NOBKTOK
expr_stmt|;
name|brk
operator|.
name|BKQcont
operator|.
name|ExplPtr
operator|.
name|xval
operator|=
literal|0
expr_stmt|;
name|brk
operator|.
name|BKQcont
operator|.
name|ExplPtr
operator|.
name|yval
operator|=
literal|0
expr_stmt|;
name|brk
operator|.
name|BKQcont
operator|.
name|ExplPtr
operator|.
name|zval
operator|=
name|NULLCOORD
expr_stmt|;
if|if
condition|(
operator|(
name|build_VT_BKQ__pdu
argument_list|(
operator|&
name|brk_pe
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|PEPYPARM
operator|)
operator|&
name|brk
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"BKQ build failed (%s)"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|brk_pe
operator|->
name|pe_context
operator|=
literal|1
expr_stmt|;
name|flushbufs
argument_list|()
expr_stmt|;
comment|/* flush local buffers */
operator|(
name|void
operator|)
name|do_event
argument_list|(
name|VBRKreq
argument_list|,
name|brk_pe
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|vbrkrsp
argument_list|()
end_macro

begin_block
block|{
name|PE
name|brk_pe
decl_stmt|;
name|BRcnt
name|brk
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|brk
argument_list|,
sizeof|sizeof
name|brk
argument_list|)
expr_stmt|;
name|brk
operator|.
name|BKRcont
operator|.
name|token_val
operator|=
name|NOBKTOK
expr_stmt|;
name|brk
operator|.
name|BKRcont
operator|.
name|ExplPtr
operator|.
name|xval
operator|=
literal|0
expr_stmt|;
name|brk
operator|.
name|BKRcont
operator|.
name|ExplPtr
operator|.
name|yval
operator|=
literal|0
expr_stmt|;
name|brk
operator|.
name|BKRcont
operator|.
name|ExplPtr
operator|.
name|zval
operator|=
name|NULLCOORD
expr_stmt|;
if|if
condition|(
operator|(
name|build_VT_BKR__pdu
argument_list|(
operator|&
name|brk_pe
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|brk
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"BKR build failed (%s)"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|brk_pe
operator|->
name|pe_context
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|do_event
argument_list|(
name|VBRKrsp
argument_list|,
name|brk_pe
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|vbrkind
argument_list|(
argument|brk_pe
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|brk_pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|flushbufs
argument_list|()
expr_stmt|;
name|vtok
operator|=
literal|1
expr_stmt|;
comment|/* got tokens from peer */
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"Received VT-BREAK"
argument_list|)
expr_stmt|;
name|vt_clr_obj
argument_list|()
expr_stmt|;
comment|/*Initialize Control Objects*/
name|vbrkrsp
argument_list|()
expr_stmt|;
if|if
condition|(
name|telnet_profile
condition|)
block|{
ifndef|#
directive|ifndef
name|PTYBUG
ifdef|#
directive|ifdef
name|BSD44
name|ptyecho
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setmode
argument_list|(
literal|0
argument_list|,
name|ECHO
argument_list|)
expr_stmt|;
comment|/*Return to Local Echo.  This call is not 			  the same for user (vtp) and server (vtpd) so for 			  now, VT-BREAK can only be requested at user side.*/
endif|#
directive|endif
name|vt_rem_echo
argument_list|(
operator|&
name|na_image
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vt_sup_ga
argument_list|(
operator|&
name|na_image
argument_list|)
expr_stmt|;
name|kill_proc
argument_list|()
expr_stmt|;
block|}
comment|/*Re-Negotiate Remote Echo and Suppress Go Ahead*/
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*ARGSUSED */
end_comment

begin_macro
name|vbrkcnf
argument_list|(
argument|brk_pe
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|brk_pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\r\n[break]\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|telnet_profile
condition|)
block|{
ifndef|#
directive|ifndef
name|PTYBUG
name|vt_rem_echo
argument_list|(
operator|&
name|ni_image
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vt_sup_ga
argument_list|(
operator|&
name|ni_image
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

