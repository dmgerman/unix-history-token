begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vtd.c - VT responder */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/vt/RCS/vtd.c,v 7.3 91/02/22 09:48:28 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/vt/RCS/vtd.c,v 7.3 91/02/22 09:48:28 mrose Interim $  *  *  * $Log:	vtd.c,v $  * Revision 7.3  91/02/22  09:48:28  mrose  * Interim 6.8  *   * Revision 7.2  90/07/09  14:52:06  mrose  * sync  *   * Revision 7.1  89/11/30  23:51:42  mrose  * pa2str  *   * Revision 7.0  89/11/23  22:31:55  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_undef
undef|#
directive|undef
name|MAP_BACKSPACE
end_undef

begin_comment
comment|/*Map backspace character to VT ERASE CHAR*/
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"vtpm.h"
end_include

begin_include
include|#
directive|include
file|"sector1.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD44
end_ifdef

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttydefaults.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_LOGIN
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|BSD44
end_ifndef

begin_define
define|#
directive|define
name|_PATH_LOGIN
value|"/bin/login"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_PATH_LOGIN
value|"/usr/bin/login"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/telnet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|BELL
value|'\07'
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SUNOS4
end_ifndef

begin_define
define|#
directive|define
name|BANNER
value|"\r\n\r\n4.2 BSD UNIX (%s)\r\n\r\n\r%s"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BANNER
value|"\r\n\r\nSunOS UNIX (%s)\r\n\r\n\r%s"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|connected
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|command
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * I/O data buffers, pointers, and counters.  */
end_comment

begin_decl_stmt
name|char
name|ptyobuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|pfrontp
init|=
name|ptyobuf
decl_stmt|,
modifier|*
name|pbackp
init|=
name|ptyobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netobuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|nfrontp
init|=
name|netobuf
decl_stmt|,
modifier|*
name|nbackp
init|=
name|netobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pcc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VT_PROFILE
name|vtp_profile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|erase_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|erase_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|intr_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|crp
init|=
literal|"\r"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|my_displayobj
init|=
literal|"D"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Acceptor's Display Object Name*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|my_echo_obj
init|=
literal|"NA"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Acceptor's Negotiation Control Object Name*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|my_signal_obj
init|=
literal|"DI"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Acceptor's Signal Control Object*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|his_echo_obj
init|=
literal|"NI"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Initiator's Negotiation Control Object*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|his_signal_obj
init|=
literal|"KB"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Initiator/s Signal control Object*/
end_comment

begin_decl_stmt
name|int
name|my_right
init|=
name|ACCEPTOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|kb_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*KB Control Object image*/
end_comment

begin_decl_stmt
name|char
name|di_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*DI Control Object Image*/
end_comment

begin_decl_stmt
name|char
name|ni_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NI Control Object image*/
end_comment

begin_decl_stmt
name|char
name|na_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*NA Control Object image*/
end_comment

begin_decl_stmt
name|char
name|nego_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Current state of NA affected options*/
end_comment

begin_decl_stmt
name|char
name|sync_image
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*SY Control Object image*/
end_comment

begin_decl_stmt
name|char
name|ga_image
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|transparent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Flag for Transparent repertoire*/
end_comment

begin_decl_stmt
name|int
name|telnet_profile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_break
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*If VT-BREAK agreed to*/
end_comment

begin_decl_stmt
name|int
name|showoptions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BSD44
end_ifdef

begin_decl_stmt
name|struct
name|termios
name|oterm
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|tchars
name|otc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ltchars
name|oltc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sgttyb
name|ottyb
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|myhostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|peerhost
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|PSAPaddr
name|ts_bound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pty
decl_stmt|,
name|net
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[]
init|=
literal|"/dev/ptyp0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|envinit
index|[]
init|=
block|{
literal|"TERM=network"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|SFD
name|cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|do_cleaning
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LLog
name|_vt_log
init|=
block|{
literal|"vt.log"
block|,
name|NULLCP
block|,
name|NULLCP
block|,
name|LLOG_FATAL
operator||
name|LLOG_EXCEPTIONS
operator||
name|LLOG_NOTICE
block|,
name|LLOG_FATAL
block|,
operator|-
literal|1
block|,
name|LLOGCLS
operator||
name|LLOGCRT
operator||
name|LLOGZER
block|,
name|NOTOK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LLog
modifier|*
name|vt_log
init|=
operator|&
name|_vt_log
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|f
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|line
decl_stmt|;
name|char
modifier|*
name|logname
init|=
name|NULLCP
decl_stmt|;
name|int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|t
decl_stmt|;
name|char
name|j
decl_stmt|;
ifndef|#
directive|ifndef
name|BSD44
name|struct
name|sgttyb
name|b
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|myname
operator|=
name|rindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
condition|)
name|myname
operator|++
expr_stmt|;
if|if
condition|(
name|myname
operator|==
name|NULL
operator|||
operator|*
name|myname
operator|==
name|NULL
condition|)
name|myname
operator|=
operator|*
name|argv
expr_stmt|;
name|isodetailor
argument_list|(
name|myname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|=
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
name|ll_dbinit
argument_list|(
name|vt_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
else|else
name|ll_hdinit
argument_list|(
name|vt_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|argc
operator|-
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-d"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
name|sscanf
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|debug
argument_list|)
operator|!=
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -d 0-7"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"setting debug level to %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|ll_dbinit
argument_list|(
name|vt_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-F"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|logname
operator|=
name|argv
index|[
operator|++
name|i
index|]
operator|)
operator|==
name|NULL
operator|||
operator|*
name|logname
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -F logfile"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|vt_log
operator|->
name|ll_file
operator|=
name|logname
expr_stmt|;
operator|(
name|void
operator|)
name|ll_close
argument_list|(
name|vt_log
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"logging to %s"
argument_list|,
name|logname
argument_list|)
expr_stmt|;
block|}
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [-F logfile] [-d N]"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"starting"
argument_list|)
expr_stmt|;
name|acc
operator|=
operator|&
name|accs
expr_stmt|;
name|acr
operator|=
operator|&
name|acrs
expr_stmt|;
name|aci
operator|=
operator|&
name|acis
expr_stmt|;
name|acs
operator|=
operator|&
name|acss
expr_stmt|;
if|if
condition|(
name|ass_ind
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|==
name|OK
condition|)
block|{
name|connected
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vtp_profile
operator|.
name|profile_name
argument_list|,
literal|"default"
argument_list|)
condition|)
name|telnet_profile
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD44
name|na_image
operator|=
literal|0
expr_stmt|;
name|nego_state
operator|=
literal|0
expr_stmt|;
comment|/*Start off in Local echo*/
name|i
operator|=
name|forkpty
argument_list|(
operator|&
name|p
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"vtd -- forkpty"
argument_list|)
expr_stmt|;
name|vrelreq
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|i
condition|)
block|{
name|vtd
argument_list|(
name|sd
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/*  * Get a pty, scan input lines.  */
for|for
control|(
name|j
operator|=
literal|'p'
init|;
name|j
operator|<=
literal|'t'
condition|;
name|j
operator|++
control|)
block|{
name|cp
index|[
name|strlen
argument_list|(
literal|"/dev/pty"
argument_list|)
index|]
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|cp
index|[
name|strlen
argument_list|(
literal|"/dev/ptyp"
argument_list|)
index|]
operator|=
literal|"0123456789abcdef"
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|open
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
literal|0
condition|)
goto|goto
name|gotpty
goto|;
block|}
block|}
name|perror
argument_list|(
literal|"All network ports in use"
argument_list|)
expr_stmt|;
name|vrelreq
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
name|gotpty
label|:
name|cp
index|[
name|strlen
argument_list|(
literal|"/dev/"
argument_list|)
index|]
operator|=
literal|'t'
expr_stmt|;
name|t
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCNOTTY
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl (TIOCNOTTY)"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|open
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|f
argument_list|,
name|cp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl (TIOCGETP)"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed (TIOCGETP)"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|sg_flags
operator|=
name|CRMOD
operator||
name|XTABS
operator||
name|ANYP
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCSETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl (TIOCSETP)"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed (TIOCSETP)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|p
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* XXX why is this done on the controller */
name|perror
argument_list|(
literal|"ioctl (TIOCGETP)"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed (TIOCGETP)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|telnet_profile
condition|)
name|b
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
else|else
name|b
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
comment|/*Remote echo for Default*/
if|if
condition|(
name|ioctl
argument_list|(
name|p
argument_list|,
name|TIOCSETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl (TIOCSETP)"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed (TIOCSETP)"
argument_list|)
expr_stmt|;
block|}
name|na_image
operator|=
literal|0
expr_stmt|;
name|nego_state
operator|=
literal|0
expr_stmt|;
comment|/*Start off in Local echo*/
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|fatalperror
argument_list|(
name|f
argument_list|,
literal|"fork"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|vtd
argument_list|(
name|sd
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"dup2 failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dup2
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"dup2 failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dup2
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"dup2 failed"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|environ
operator|=
name|envinit
expr_stmt|;
name|execl
argument_list|(
name|_PATH_LOGIN
argument_list|,
literal|"login"
argument_list|,
literal|"-h"
argument_list|,
name|peerhost
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fatalperror
argument_list|(
name|f
argument_list|,
name|_PATH_LOGIN
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_macro
name|fatal
argument_list|(
argument|f
argument_list|,
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %s.\n"
argument_list|,
name|myname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fatalperror
argument_list|(
argument|f
argument_list|,
argument|msg
argument_list|,
argument|errnum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %s"
argument_list|,
name|msg
argument_list|,
name|sys_errlist
index|[
name|errnum
index|]
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|f
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Main loop.  Select from pty and network.  */
end_comment

begin_macro
name|vtd
argument_list|(
argument|f
argument_list|,
argument|p
argument_list|)
end_macro

begin_block
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|nfds
decl_stmt|,
name|result
decl_stmt|;
name|do_cleaning
operator|=
literal|1
expr_stmt|;
name|net
operator|=
name|f
operator|,
name|pty
operator|=
name|p
expr_stmt|;
name|nfds
operator|=
operator|(
name|f
operator|>
name|p
condition|?
name|f
else|:
name|p
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|p
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed (FIONBIO)"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGTSTP
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Show banner that getty never gave. 	 */
name|myhostname
operator|=
name|PLocalHostName
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nfrontp
argument_list|,
name|BANNER
argument_list|,
name|myhostname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|nfrontp
operator|+=
name|strlen
argument_list|(
name|nfrontp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD44
if|if
condition|(
name|tcgetattr
argument_list|(
name|pty
argument_list|,
operator|&
name|oterm
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"tcgetattr failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|telnet_profile
condition|)
block|{
name|oterm
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|pty
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|oterm
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"tcgetattr failed"
argument_list|)
expr_stmt|;
block|}
block|}
name|erase_char
operator|=
name|oterm
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|erase_line
operator|=
name|oterm
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
name|intr_char
operator|=
name|oterm
operator|.
name|c_cc
index|[
name|VINTR
index|]
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ottyb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed (TIOCGETP)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|otc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed (TIOCGETC)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oltc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed (TIOCGLTC)"
argument_list|)
expr_stmt|;
block|}
name|erase_char
operator|=
name|ottyb
operator|.
name|sg_erase
expr_stmt|;
name|erase_line
operator|=
name|ottyb
operator|.
name|sg_kill
expr_stmt|;
name|intr_char
operator|=
name|otc
operator|.
name|t_intrc
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|fd_set
name|ibits
decl_stmt|,
name|obits
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|obits
argument_list|)
expr_stmt|;
comment|/* 		 * Never look for input if there's still 		 * stuff in the corresponding output buffer 		 */
if|if
condition|(
name|nfrontp
operator|-
name|nbackp
condition|)
block|{
name|FD_SET
argument_list|(
name|f
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FD_SET
argument_list|(
name|p
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfrontp
operator|-
name|pbackp
condition|)
block|{
name|FD_SET
argument_list|(
name|p
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FD_SET
argument_list|(
name|f
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|f
argument_list|,
operator|&
name|ibits
argument_list|)
operator|&&
name|data_pending
argument_list|()
condition|)
block|{
name|FD_CLR
argument_list|(
name|f
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|result
operator|=
name|xselect
argument_list|(
name|nfds
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
name|OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"xselect"
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|f
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xselect
argument_list|(
name|nfds
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
name|NOTOK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"xselect"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|f
argument_list|,
operator|&
name|ibits
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|p
argument_list|,
operator|&
name|ibits
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|f
argument_list|,
operator|&
name|obits
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|p
argument_list|,
operator|&
name|obits
argument_list|)
condition|)
block|{
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Something to read from the network... 		 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|f
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|>
literal|0
condition|)
operator|*
name|pfrontp
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|E_EOF
condition|)
block|{
break|break;
block|}
comment|/* 		 * Something to read from the pty... 		 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|p
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|pcc
operator|=
name|read
argument_list|(
name|p
argument_list|,
name|nfrontp
argument_list|,
operator|(
operator|&
name|netobuf
index|[
name|BUFSIZ
index|]
operator|-
name|nfrontp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|pcc
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pcc
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"problem reading from pty"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nfrontp
operator|+=
name|pcc
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|f
argument_list|,
operator|&
name|obits
argument_list|)
operator|&&
operator|(
name|nfrontp
operator|-
name|nbackp
operator|)
operator|>
literal|0
condition|)
name|netflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|p
argument_list|,
operator|&
name|obits
argument_list|)
operator|&&
operator|(
name|pfrontp
operator|-
name|pbackp
operator|)
operator|>
literal|0
condition|)
name|ptyflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"finished loop in vtp"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Send interrupt to process on other side of pty.  * If it is in raw mode, just write NULL;  * otherwise, write intr char.  */
end_comment

begin_macro
name|interrupt
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BSD44
name|struct
name|termios
name|term
decl_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|pty
argument_list|,
operator|&
name|term
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|term
operator|.
name|c_lflag
operator|&
name|ISIG
operator|)
operator|&&
name|term
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
operator|*
name|pfrontp
operator|++
operator|=
name|term
operator|.
name|c_cc
index|[
name|VINTR
index|]
expr_stmt|;
else|else
operator|*
name|pfrontp
operator|++
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|struct
name|sgttyb
name|b
decl_stmt|;
name|struct
name|tchars
name|tchars
decl_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
comment|/* half-hearted */
if|if
condition|(
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|.
name|sg_flags
operator|&
name|RAW
condition|)
block|{
operator|*
name|pfrontp
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
operator|*
name|pfrontp
operator|++
operator|=
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tchars
argument_list|)
operator|<
literal|0
condition|?
literal|'\177'
else|:
name|tchars
operator|.
name|t_intrc
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|netflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nl_flag
decl_stmt|;
comment|/*Records if Newline is included in current PDU to 			  decide if Deliver Request should follow it.  Should 			  not be required but some implementations may wait 			  for it before delivering NDQ to application*/
name|nl_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|nfrontp
operator|-
name|nbackp
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|ll_log
argument_list|(
name|vt_log
argument_list|,
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"writing to the net"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ll_printf
argument_list|(
name|vt_log
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|nfrontp
operator|-
name|nbackp
operator|)
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|ll_printf
argument_list|(
name|vt_log
argument_list|,
literal|"%02x "
argument_list|,
operator|*
operator|(
name|nbackp
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ll_printf
argument_list|(
name|vt_log
argument_list|,
literal|">>\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ll_sync
argument_list|(
name|vt_log
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transparent
condition|)
block|{
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vtsend
argument_list|()
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|vdelreq
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|cp
expr_stmt|;
block|}
name|nbackp
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|nbackp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|rflag
condition|)
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|crp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Previous char was CR so put one in NDQ*/
if|if
condition|(
name|j
condition|)
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*Skip over current CR*/
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|n
operator|-
literal|1
operator|)
condition|)
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|crp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*If CR is last char in buffer, send it*/
else|else
name|rflag
operator|=
literal|1
expr_stmt|;
comment|/*If not last char in buffer, read next one*/
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rflag
condition|)
comment|/*If previous character was CR*/
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
comment|/*Got CR-LF -- map to Next X-Array*/
block|{
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
name|vt_newline
argument_list|()
expr_stmt|;
operator|++
name|nl_flag
expr_stmt|;
continue|continue;
block|}
else|else
comment|/*Preceeding char was CR but not followed by 				   LF.  Put CR in buffer*/
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|crp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|telnet_profile
condition|)
block|{
name|rflag
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_BACKSPACE
if|if
condition|(
operator|*
name|cp
operator|==
literal|0x08
condition|)
comment|/*If believed to be erase*/
block|{
if|if
condition|(
name|j
condition|)
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|vt_char_erase
argument_list|()
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|vtp_profile
operator|.
name|arg_val
operator|.
name|tel_arg_list
operator|.
name|full_ascii
condition|)
comment|/*If ASCII GO, dump ctrl chars*/
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|<
literal|0x20
operator|)
operator|||
operator|(
operator|*
name|cp
operator|>
literal|0x7e
operator|)
condition|)
block|{
if|if
condition|(
name|j
condition|)
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|j
expr_stmt|;
operator|++
name|cp
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|j
expr_stmt|;
operator|++
name|cp
expr_stmt|;
block|}
block|}
else|else
comment|/*Else Default Profile*/
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|<
literal|0x20
operator|)
operator|||
operator|(
operator|*
name|cp
operator|>
literal|0x7e
operator|)
condition|)
block|{
if|if
condition|(
name|j
condition|)
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|nbackp
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
name|cp
operator|=
name|nbackp
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|j
expr_stmt|;
operator|++
name|cp
expr_stmt|;
block|}
block|}
block|}
comment|/*End for loop*/
if|if
condition|(
name|j
condition|)
operator|(
name|void
operator|)
name|vt_text
argument_list|(
name|nbackp
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/*Load anything left if CR or LF 						wasn't last char in buffer*/
name|nbackp
operator|+=
name|j
expr_stmt|;
name|vtsend
argument_list|()
expr_stmt|;
comment|/*Send the whole NDQ*/
if|if
condition|(
name|nl_flag
operator|&&
name|telnet_profile
condition|)
name|vdelreq
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOBUFS
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|adios
argument_list|(
literal|"closed"
argument_list|,
literal|"association"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|n
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nbackp
operator|==
name|nfrontp
condition|)
name|nbackp
operator|=
name|nfrontp
operator|=
name|netobuf
expr_stmt|;
block|}
end_block

begin_function
name|SFD
name|cleanup
parameter_list|()
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|getch
argument_list|()
operator|>
literal|0
condition|)
empty_stmt|;
comment|/*Clean out unread VT-DATA PDU's still held 				  in network.  Kludge to overcome deficiency 				  in Session Release. */
name|rmut
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD44
name|vhangup
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|vrelreq
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
name|struct
name|utmp
name|wtmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wtmpf
index|[]
init|=
literal|"/usr/adm/wtmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|utmp
index|[]
init|=
literal|"/etc/utmp"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SCPYN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncpy(a, b, sizeof (a))
end_define

begin_define
define|#
directive|define
name|SCMPN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncmp(a, b, sizeof (a))
end_define

begin_decl_stmt
name|long
name|lseek
argument_list|()
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
end_decl_stmt

begin_macro
name|rmut
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|f
expr_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|f
operator|=
name|open
argument_list|(
name|utmp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCMPN
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|line
operator|+
literal|5
argument_list|)
operator|||
name|wtmp
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|f
argument_list|,
operator|-
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS5
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|bsd43_ut_host
argument_list|)
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|wtmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|f
operator|=
name|open
argument_list|(
name|wtmpf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_line
argument_list|,
name|line
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS5
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|bsd43_ut_host
argument_list|)
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|wtmp
operator|.
name|ut_host
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|wtmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|strlen
argument_list|(
literal|"/dev/"
argument_list|)
index|]
operator|=
literal|'p'
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|line
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bye
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|do_cleaning
condition|)
block|{
name|rmut
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|flushbufs
argument_list|()
end_macro

begin_block
block|{
name|pcc
operator|=
literal|0
expr_stmt|;
name|pfrontp
operator|=
name|pbackp
operator|=
name|ptyobuf
expr_stmt|;
name|nfrontp
operator|=
name|nbackp
operator|=
name|netobuf
expr_stmt|;
while|while
condition|(
name|getch
argument_list|()
operator|>
literal|0
condition|)
continue|continue;
block|}
end_block

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_function
name|void
name|finalbye
parameter_list|()
block|{
name|bye
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|adios
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_ll_log
argument_list|(
name|vt_log
argument_list|,
name|LLOG_FATAL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|bye
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_ll_log
argument_list|(
name|vt_log
argument_list|,
name|code
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS3 */
end_comment

begin_function
name|void
name|advise
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|advise
argument_list|(
name|code
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|ptyflush
argument_list|()
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|pfrontp
operator|-
name|pbackp
operator|)
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|write
argument_list|(
name|pty
argument_list|,
name|pbackp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return;
name|pbackp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|pbackp
operator|==
name|pfrontp
condition|)
name|pbackp
operator|=
name|pfrontp
operator|=
name|ptyobuf
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BSD44
end_ifdef

begin_macro
name|ptyecho
argument_list|(
argument|on
argument_list|)
end_macro

begin_block
block|{
name|struct
name|termios
name|term
decl_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|pty
argument_list|,
operator|&
name|term
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcgetattr"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|on
condition|)
name|term
operator|.
name|c_lflag
operator||=
name|ECHO
expr_stmt|;
else|else
name|term
operator|.
name|c_lflag
operator|&=
name|ECHO
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|pty
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|term
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"tcsetattr"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_macro
name|setmode
argument_list|(
argument|on
argument_list|,
argument|off
argument_list|)
end_macro

begin_decl_stmt
name|int
name|on
decl_stmt|,
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sgttyb
name|b
decl_stmt|;
name|ptyflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|sg_flags
operator||=
name|on
expr_stmt|;
name|b
operator|.
name|sg_flags
operator|&=
operator|~
name|off
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pty
argument_list|,
name|TIOCSETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|b
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ioctl failed"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

