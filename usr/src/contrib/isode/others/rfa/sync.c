begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * RFA - Remote File Access  *  * Access and Management for a partial file system tree that exists  * at two sites either as master files or slave files  *  * sync.c  synchronize local dir with remote site  *  * Contributed by Oliver Wenzel, GMD Berlin, 1990  *  * $Header: /f/osi/others/rfa/RCS/sync.c,v 7.3 91/02/22 09:28:34 mrose Interim $  *  * $Log:	sync.c,v $  * Revision 7.3  91/02/22  09:28:34  mrose  * Interim 6.8  *   * Revision 7.2  91/01/14  13:55:09  mrose  * update  *   * Revision 1.1  91/01/04  16:08:27  ow  * Initial revision  *   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/others/rfa/RCS/sync.c,v 7.3 91/02/22 09:28:34 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *                              NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"RFA-ops.h"
end_include

begin_include
include|#
directive|include
file|"RFA-types.h"
end_include

begin_include
include|#
directive|include
file|"rfa.h"
end_include

begin_include
include|#
directive|include
file|"rfainfo.h"
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|err
decl_stmt|,
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|interactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|incstr
init|=
literal|"\t*** INCONSISTENCY : "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  createEmptyFile						*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_function
name|int
name|createEmptyFile
parameter_list|(
name|dir
parameter_list|,
name|rfa
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|struct
name|RfaInfo
modifier|*
name|rfa
decl_stmt|;
block|{
name|int
name|tt
index|[
literal|2
index|]
decl_stmt|,
name|fd
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|fn
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s%s%s"
argument_list|,
name|dir
argument_list|,
operator|*
operator|(
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
comment|/*-- create empty file for now --*/
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|makeFN
argument_list|(
name|fn
argument_list|)
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
name|rfa
operator|->
name|ri_mode
operator|&
literal|07555
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't create local SLAVE for %s (%s) ***\n"
argument_list|,
name|fn
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"This file has been created by RFA as a dummy."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" Use RFA commands 'get' and 'setauto'\nto retrieve"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" the actual content of this file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't write local SLAVE for %s (%s) ***\n"
argument_list|,
name|fn
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|makeFN
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|tt
index|[
literal|0
index|]
operator|=
name|rfa
operator|->
name|ri_modTime
operator|-
literal|60
expr_stmt|;
name|tt
index|[
literal|1
index|]
operator|=
name|rfa
operator|->
name|ri_modTime
operator|-
literal|60
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|makeFN
argument_list|(
name|fn
argument_list|)
argument_list|,
name|tt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't create local SLAVE for %s (%s) ***\n"
argument_list|,
name|fn
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|makeFN
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|changeFileOwner
argument_list|(
name|fn
argument_list|,
name|rfa
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  removeDir - check if dir is empty and remove it		*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_function
name|int
name|removeDir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/*--- dir is a directory name, so open dir ---*/
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|makeFN
argument_list|(
name|dir
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"*** can't open %s - %s ***"
argument_list|,
name|dir
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".rfainfo"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%scan't remove %s - not empty ***\n"
argument_list|,
name|incstr
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\tremoved local SLAVE directory '%s'\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  checkState - check state of files and perform actions to    */
end_comment

begin_comment
comment|/*               resolve inconsistencies if possible		*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_function
name|int
name|checkState
parameter_list|(
name|rfa
parameter_list|,
name|rrfa
parameter_list|,
name|dir
parameter_list|,
name|wrp
parameter_list|)
name|struct
name|RfaInfo
modifier|*
name|rfa
decl_stmt|,
decl|*
name|rrfa
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|wrp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|fn
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|rfa
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|rrfa
operator|==
name|NULL
operator|)
condition|)
return|return
name|OK
return|;
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s%s%s"
argument_list|,
name|dir
argument_list|,
operator|*
operator|(
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|rfa
condition|?
name|rfa
operator|->
name|ri_filename
else|:
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
comment|/*-- checks if file exists only local --*/
if|if
condition|(
name|rrfa
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|RI_STATUS
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
case|case
name|RI_MASTER
case|:
case|case
name|RI_UNREGISTERED
case|:
return|return
name|OK
return|;
case|case
name|RI_SLAVE
case|:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sno remote MASTER for local SLAVE '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|doRmWidows
condition|)
block|{
if|if
condition|(
name|rfa
operator|->
name|ri_mode
operator|&
name|S_IFDIR
condition|)
name|removeDir
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
name|unlink
argument_list|(
name|makeFN
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\tremoved local SLAVE file '%s'\n"
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
else|else
return|return
name|NOTOK
return|;
default|default:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sinvalid state for local '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/*-- checks if file exists only remote --*/
if|if
condition|(
name|rfa
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|RI_STATUS
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
case|case
name|RI_MASTER
case|:
case|case
name|RI_UNREGISTERED
case|:
return|return
name|OK
return|;
case|case
name|RI_SLAVE
case|:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sno local MASTER for remote SLAVE '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
default|default:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sinvalid state for remote '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/*-- checks if file exists at both sides --*/
switch|switch
condition|(
name|RI_STATUS
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
case|case
name|RI_UNREGISTERED
case|:
switch|switch
condition|(
name|RI_STATUS
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
case|case
name|RI_UNREGISTERED
case|:
return|return
name|OK
return|;
case|case
name|RI_SLAVE
case|:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sUNREG/SLAVE state for '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|RI_MASTER
case|:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sUNREG/MASTER state for '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
default|default:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sinvalid state for remote '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/* NOTREACHED */
case|case
name|RI_MASTER
case|:
switch|switch
condition|(
name|RI_STATUS
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
case|case
name|RI_UNREGISTERED
case|:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sMASTER/UNREG state for '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|RI_SLAVE
case|:
return|return
name|OK
return|;
case|case
name|RI_MASTER
case|:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sMASTER/MASTER state for '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
default|default:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sinvalid state for remote '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/* NOTREACHED */
case|case
name|RI_SLAVE
case|:
switch|switch
condition|(
name|RI_STATUS
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
case|case
name|RI_UNREGISTERED
case|:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sSLAVE/UNREG state for '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|doRmWidows
condition|)
block|{
name|SET_STATUS
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|,
name|RI_UNREGISTERED
argument_list|)
expr_stmt|;
name|SET_TRANSFER
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|,
name|RI_TR_REQ
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\tchanged status of '%s' to UNREGISTERED\n"
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
operator|*
name|wrp
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NOTOK
return|;
case|case
name|RI_SLAVE
case|:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sSLAVE/SLAVE state for '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|RI_MASTER
case|:
return|return
name|OK
return|;
default|default:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sinvalid state for remote '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/* NOTREACHED */
default|default:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sinvalid state for local '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  checkMasterSlave - do a consistency check on master and     */
end_comment

begin_comment
comment|/*		       slave file infos				*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_function
name|int
name|checkMasterSlave
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|,
name|ms
parameter_list|,
name|ss
parameter_list|)
name|struct
name|RfaInfo
modifier|*
name|m
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|ms
decl_stmt|,
modifier|*
name|ss
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|m
operator|->
name|ri_modTime
operator|<
name|s
operator|->
name|ri_modTime
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%s %s SLAVE version of '%s' is newer than %s MASTER ***\n"
argument_list|,
name|incstr
argument_list|,
name|ss
argument_list|,
name|m
operator|->
name|ri_filename
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|ri_modTime
operator|==
name|s
operator|->
name|ri_modTime
operator|)
operator|&&
operator|(
name|m
operator|->
name|ri_size
operator|!=
name|s
operator|->
name|ri_size
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%s %s MASTER of '%s'"
argument_list|,
name|incstr
argument_list|,
name|ms
argument_list|,
name|m
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|" has different size than %s SLAVE ***\n"
argument_list|,
name|ss
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  handleDir							*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_function
name|int
name|handleDir
parameter_list|(
name|dir
parameter_list|,
name|localRfaListPtr
parameter_list|,
name|rrfa
parameter_list|,
name|rec
parameter_list|,
name|wrp
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|struct
name|RfaInfo
modifier|*
modifier|*
name|localRfaListPtr
decl_stmt|;
name|struct
name|RfaInfo
modifier|*
name|rrfa
decl_stmt|;
name|int
name|rec
decl_stmt|;
name|int
modifier|*
name|wrp
decl_stmt|;
block|{
name|struct
name|RfaInfo
modifier|*
name|rfa
decl_stmt|;
name|char
name|fn
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rrfa
operator|->
name|ri_filename
argument_list|,
literal|"."
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|rrfa
operator|->
name|ri_filename
argument_list|,
literal|".."
argument_list|)
condition|)
return|return
name|OK
return|;
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s/%s"
argument_list|,
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|)
condition|?
name|dir
else|:
literal|""
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
name|rfa
operator|=
name|findRfaInfo
argument_list|(
name|rrfa
operator|->
name|ri_filename
argument_list|,
operator|*
name|localRfaListPtr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|RI_STATUS
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
case|case
name|RI_UNREGISTERED
case|:
if|if
condition|(
name|rfa
condition|)
name|checkState
argument_list|(
name|rfa
argument_list|,
name|rrfa
argument_list|,
name|dir
argument_list|,
name|wrp
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
case|case
name|RI_SLAVE
case|:
if|if
condition|(
name|rfa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sno local MASTER for remote SLAVE dir '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK_INCONSISTENCY
return|;
block|}
if|if
condition|(
operator|(
name|rfa
operator|->
name|ri_mode
operator|&
name|S_IFDIR
operator|&
name|S_IFMT
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%slocal file '%s' conflicts with remote directory ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK_INCONSISTENCY
return|;
block|}
if|if
condition|(
name|checkState
argument_list|(
name|rfa
argument_list|,
name|rrfa
argument_list|,
name|dir
argument_list|,
name|wrp
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK_INCONSISTENCY
return|;
break|break;
case|case
name|RI_MASTER
case|:
if|if
condition|(
name|rfa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"found new MASTER sub-directory '%s' at remote\n"
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rfa
operator|=
name|mallocRfaInfo
argument_list|(
name|strdup
argument_list|(
name|rrfa
operator|->
name|ri_filename
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%scant't create local SLAVE for %s ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK_LOCAL_ERROR
return|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
name|makeFN
argument_list|(
name|fn
argument_list|)
argument_list|,
name|rrfa
operator|->
name|ri_mode
operator|&
literal|07777
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"*** can't create subdir %s ***\n"
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK_FILEACCESS
return|;
block|}
name|SET_STATUS
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|,
name|RI_SLAVE
argument_list|)
expr_stmt|;
name|SET_LOCKINFO
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|,
name|RI_UNLOCKED
argument_list|)
expr_stmt|;
name|SET_TRANSFER
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|,
name|RI_TRANSFER
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
operator|(
name|rfa
operator|->
name|ri_lastChange
operator|)
argument_list|)
expr_stmt|;
name|rfa
operator|->
name|ri_modTime
operator|=
literal|0L
expr_stmt|;
name|rfa
operator|->
name|ri_mode
operator|=
name|rrfa
operator|->
name|ri_mode
expr_stmt|;
name|rfa
operator|->
name|ri_next
operator|=
operator|*
name|localRfaListPtr
expr_stmt|;
operator|*
name|localRfaListPtr
operator|=
name|rfa
expr_stmt|;
name|changeFileOwner
argument_list|(
name|fn
argument_list|,
name|rrfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|putRfaInfoList
argument_list|(
name|dir
argument_list|,
operator|*
name|localRfaListPtr
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%scan't set SLAVE status of %s ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|NOTOK_FILEACCESS
return|;
block|}
block|}
else|else
block|{
comment|/*--- local rfa found ---*/
if|if
condition|(
operator|(
name|rfa
operator|->
name|ri_mode
operator|&
name|S_IFDIR
operator|&
name|S_IFMT
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%slocal file '%s' conflicts with"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|" remote directory ***\n"
argument_list|)
expr_stmt|;
return|return
name|NOTOK_INCONSISTENCY
return|;
block|}
if|if
condition|(
name|checkState
argument_list|(
name|rfa
argument_list|,
name|rrfa
argument_list|,
name|dir
argument_list|,
name|wrp
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK_INCONSISTENCY
return|;
block|}
comment|/* if local rfa exists */
block|}
comment|/* switch rrfa->ri_status */
comment|/*--- now we have a local version of the dir ---*/
if|if
condition|(
name|rec
operator|&&
name|IS_TR_AUTO
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|)
condition|)
if|if
condition|(
operator|(
name|rc
operator|=
name|syncDir
argument_list|(
name|fn
argument_list|,
name|rec
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** syncdir for %s failed ***\n"
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  syncDir							*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_function
name|int
name|syncDir
parameter_list|(
name|dir
parameter_list|,
name|rec
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|rec
decl_stmt|;
block|{
name|struct
name|RfaInfo
modifier|*
name|rfa
decl_stmt|,
modifier|*
name|localRfaList
decl_stmt|,
modifier|*
name|rrfa
decl_stmt|,
modifier|*
name|remoteRfaList
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|writeList
decl_stmt|,
name|rc
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|rmode
decl_stmt|;
name|char
name|fn
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|syncfiles
index|[
name|BUFSIZ
operator|*
literal|10
index|]
decl_stmt|;
comment|/*--- get file Info ---*/
if|if
condition|(
operator|(
name|rc
operator|=
name|getLockedRfaInfoList
argument_list|(
name|dir
argument_list|,
operator|&
name|localRfaList
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't get rfainfo : %s ***\n"
argument_list|,
name|errMsg
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/*--- get remote rfa list ---*/
if|if
condition|(
operator|(
name|rc
operator|=
name|getRemoteRfaInfoList
argument_list|(
name|dir
argument_list|,
operator|&
name|remoteRfaList
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
name|releaseRfaInfoList
argument_list|(
name|dir
argument_list|,
name|localRfaList
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"syncing directory %s\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
operator|*
name|syncfiles
operator|=
literal|'\0'
expr_stmt|;
comment|/*-- check remote list agaist local one --*/
for|for
control|(
name|rrfa
operator|=
name|remoteRfaList
init|;
name|rrfa
condition|;
name|rrfa
operator|=
name|rrfa
operator|->
name|ri_next
control|)
block|{
name|writeList
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|rrfa
operator|->
name|ri_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFIFO
case|:
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
case|case
name|S_IFSOCK
case|:
continue|continue;
case|case
name|S_IFLNK
case|:
if|if
condition|(
name|rrfa
operator|->
name|ri_lnkName
operator|==
name|NULL
condition|)
continue|continue;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|makeFN2
argument_list|(
name|dir
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|rrfa
operator|->
name|ri_lnkName
operator|)
operator|==
literal|'/'
condition|)
name|lp
operator|=
name|l
operator|=
name|makeFN
argument_list|(
name|rrfa
operator|->
name|ri_lnkName
argument_list|)
expr_stmt|;
else|else
block|{
name|l
operator|=
name|rrfa
operator|->
name|ri_lnkName
expr_stmt|;
name|lp
operator|=
name|makeFN2
argument_list|(
name|dir
argument_list|,
name|rrfa
operator|->
name|ri_lnkName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|lp
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|(
name|rfa
operator|=
name|findRfaInfo
argument_list|(
name|rrfa
operator|->
name|ri_filename
argument_list|,
name|localRfaList
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\tcreating link %s to %s\n"
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|l
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't create link %s ***\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|rfa
operator|->
name|ri_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rfa
operator|->
name|ri_lnkName
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|unlink
argument_list|(
name|makeFN2
argument_list|(
name|dir
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\tcreating link %s to %s\n"
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|l
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't create link %s ***\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%slocal file %s conflicts with remote link ***\n"
argument_list|,
name|incstr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
break|break;
case|case
name|S_IFDIR
case|:
if|if
condition|(
name|handleDir
argument_list|(
name|dir
argument_list|,
operator|&
name|localRfaList
argument_list|,
name|rrfa
argument_list|,
name|rec
argument_list|,
operator|&
name|writeList
argument_list|)
operator|!=
name|OK
condition|)
block|{
continue|continue;
block|}
continue|continue;
case|case
name|S_IFREG
case|:
break|break;
default|default:
continue|continue;
block|}
comment|/*--- rrfa->ri_filename is regular file ---*/
name|rfa
operator|=
name|findRfaInfo
argument_list|(
name|rrfa
operator|->
name|ri_filename
argument_list|,
name|localRfaList
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|RI_STATUS
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
case|case
name|RI_UNREGISTERED
case|:
name|checkState
argument_list|(
name|rfa
argument_list|,
name|rrfa
argument_list|,
name|dir
argument_list|,
operator|&
name|writeList
argument_list|)
expr_stmt|;
break|break;
case|case
name|RI_SLAVE
case|:
if|if
condition|(
name|checkState
argument_list|(
name|rfa
argument_list|,
name|rrfa
argument_list|,
name|dir
argument_list|,
operator|&
name|writeList
argument_list|)
operator|==
name|NOTOK
condition|)
continue|continue;
name|checkMasterSlave
argument_list|(
name|rfa
argument_list|,
name|rrfa
argument_list|,
literal|"local"
argument_list|,
literal|"remote"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RI_MASTER
case|:
if|if
condition|(
name|rfa
operator|==
name|NULL
condition|)
block|{
comment|/*--- check if not a .rfaexec file ---*/
if|if
condition|(
name|strcmp
argument_list|(
name|rrfa
operator|->
name|ri_filename
argument_list|,
literal|".rfaexec"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sremote file '%s' is MASTER, not transfered ***\n"
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\tfound new MASTER file '%s' at remote\n"
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rfa
operator|=
name|mallocRfaInfo
argument_list|(
name|strdup
argument_list|(
name|rrfa
operator|->
name|ri_filename
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%scant't create local SLAVE for %s ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SET_STATUS
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|,
name|RI_SLAVE
argument_list|)
expr_stmt|;
name|SET_LOCKINFO
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|,
name|RI_UNLOCKED
argument_list|)
expr_stmt|;
name|SET_TRANSFER
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|,
name|RI_TRANSFER
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
operator|(
name|rfa
operator|->
name|ri_lastChange
operator|)
argument_list|)
expr_stmt|;
name|rfa
operator|->
name|ri_modTime
operator|=
literal|0L
expr_stmt|;
name|rfa
operator|->
name|ri_mode
operator|=
name|rrfa
operator|->
name|ri_mode
expr_stmt|;
name|rfa
operator|->
name|ri_next
operator|=
name|localRfaList
expr_stmt|;
name|localRfaList
operator|=
name|rfa
expr_stmt|;
name|writeList
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|checkState
argument_list|(
name|rfa
argument_list|,
name|rrfa
argument_list|,
name|dir
argument_list|,
operator|&
name|writeList
argument_list|)
operator|==
name|NOTOK
condition|)
break|break;
empty_stmt|;
name|checkMasterSlave
argument_list|(
name|rrfa
argument_list|,
name|rfa
argument_list|,
literal|"remote"
argument_list|,
literal|"local"
argument_list|)
expr_stmt|;
block|}
comment|/* if local rfa exists */
comment|/*--- now we are ready to get the remote file ---*/
if|if
condition|(
name|writeList
operator|&&
name|IS_TR_REQ
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
if|if
condition|(
name|createEmptyFile
argument_list|(
name|dir
argument_list|,
name|rrfa
argument_list|)
operator|==
name|NOTOK
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|IS_TR_AUTO
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|)
operator|&&
operator|(
name|rfa
operator|->
name|ri_modTime
operator|<
name|rrfa
operator|->
name|ri_modTime
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s%s%s"
argument_list|,
name|dir
argument_list|,
operator|*
operator|(
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t%s - "
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|getfile_aux
argument_list|(
name|fn
argument_list|,
name|rfa
argument_list|,
operator|&
name|rmode
argument_list|)
operator|)
operator|!=
name|OK
condition|)
continue|continue;
name|strcat
argument_list|(
name|syncfiles
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|syncfiles
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%sinvalid state for remote '%s' ***\n"
argument_list|,
name|incstr
argument_list|,
name|rrfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* switch rrfa->ri_status */
comment|/*--- now we have a local slave version of the file ---*/
if|if
condition|(
name|writeList
condition|)
if|if
condition|(
operator|(
name|rc
operator|=
name|putRfaInfoList
argument_list|(
name|dir
argument_list|,
name|localRfaList
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%scan't set SLAVE status of %s ***\n"
argument_list|,
name|incstr
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* for rrfa */
comment|/*-- now check local list against remote list --*/
for|for
control|(
name|rfa
operator|=
name|localRfaList
init|;
name|rfa
condition|;
name|rfa
operator|=
name|rfa
operator|->
name|ri_next
control|)
if|if
condition|(
name|findRfaInfo
argument_list|(
name|rfa
operator|->
name|ri_filename
argument_list|,
name|remoteRfaList
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|checkState
argument_list|(
name|rfa
argument_list|,
name|NULL
argument_list|,
name|dir
argument_list|,
operator|&
name|writeList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writeList
condition|)
if|if
condition|(
operator|(
name|rc
operator|=
name|putRfaInfoList
argument_list|(
name|dir
argument_list|,
name|localRfaList
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"%scan't set SLAVE status of %s ***\n"
argument_list|,
name|incstr
argument_list|,
name|rfa
operator|->
name|ri_filename
argument_list|)
expr_stmt|;
block|}
name|releaseRfaInfoList
argument_list|(
name|dir
argument_list|,
name|localRfaList
argument_list|)
expr_stmt|;
name|freeRfaInfoList
argument_list|(
name|remoteRfaList
argument_list|)
expr_stmt|;
comment|/*-- look for .rfaexec script --*/
return|return
name|rfaMake
argument_list|(
name|dir
argument_list|,
name|syncfiles
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  rfaMake							*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------*/
end_comment

begin_function
name|int
name|rfaMake
parameter_list|(
name|dir
parameter_list|,
name|fns
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
name|fns
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|RfaInfo
modifier|*
name|rfa
decl_stmt|,
modifier|*
name|rrfa
decl_stmt|,
modifier|*
name|localRfaList
decl_stmt|,
modifier|*
name|remoteRfaList
decl_stmt|;
name|char
name|parentDir
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|execfn
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/*-- check if files sync'ed --*/
if|if
condition|(
operator|*
name|fns
operator|==
literal|'\0'
operator|||
name|doRfaExec
operator|==
literal|0
condition|)
return|return
name|OK
return|;
comment|/*-- check if .rfaexec exists --*/
name|sprintf
argument_list|(
name|execfn
argument_list|,
literal|"%s/.rfaexec"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|makeFN
argument_list|(
name|execfn
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
name|OK
return|;
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't stat %s - %s"
argument_list|,
name|execfn
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK_LOCAL_ERROR
return|;
block|}
if|if
condition|(
name|access
argument_list|(
name|makeFN
argument_list|(
name|execfn
argument_list|)
argument_list|,
name|X_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't exec '%s' (%s) ***\n"
argument_list|,
name|execfn
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK_LOCAL_ERROR
return|;
block|}
comment|/*-- check if dir is locked --*/
if|if
condition|(
operator|(
name|rc
operator|=
name|getRfaInfoList
argument_list|(
name|dirname
argument_list|(
name|dir
argument_list|)
argument_list|,
operator|&
name|localRfaList
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
return|return
name|rc
return|;
block|}
if|if
condition|(
name|rfa
operator|=
name|findRfaInfo
argument_list|(
name|basename
argument_list|(
name|dir
argument_list|)
argument_list|,
name|localRfaList
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_MASTER
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|)
operator|&&
name|IS_LOCKED
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
name|freeRfaInfoList
argument_list|(
name|localRfaList
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|rfa
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rfa
operator|&&
operator|!
name|IS_MASTER
argument_list|(
name|rfa
operator|->
name|ri_status
argument_list|)
operator|)
condition|)
block|{
name|freeRfaInfoList
argument_list|(
name|localRfaList
argument_list|)
expr_stmt|;
comment|/*--- get remote rfa list ---*/
if|if
condition|(
operator|(
name|rc
operator|=
name|getRemoteRfaInfoList
argument_list|(
name|dirname
argument_list|(
name|dir
argument_list|)
argument_list|,
operator|&
name|remoteRfaList
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
return|return
name|rc
return|;
block|}
if|if
condition|(
operator|(
name|rrfa
operator|=
name|findRfaInfo
argument_list|(
name|basename
argument_list|(
name|dir
argument_list|)
argument_list|,
name|remoteRfaList
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't determine status of '%s' ***\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|freeRfaInfoList
argument_list|(
name|remoteRfaList
argument_list|)
expr_stmt|;
return|return
name|NOTOK_REMOTE_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|IS_MASTER
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't find MASTER version of '%s' ***\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|freeRfaInfoList
argument_list|(
name|remoteRfaList
argument_list|)
expr_stmt|;
return|return
name|NOTOK_REMOTE_ERROR
return|;
block|}
if|if
condition|(
name|IS_LOCKED
argument_list|(
name|rrfa
operator|->
name|ri_status
argument_list|)
condition|)
block|{
name|freeRfaInfoList
argument_list|(
name|remoteRfaList
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|freeRfaInfoList
argument_list|(
name|remoteRfaList
argument_list|)
expr_stmt|;
block|}
comment|/*-- change cwd to sync'ed dir --*/
if|if
condition|(
name|chdir
argument_list|(
name|makeFN
argument_list|(
name|dir
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\t*** can't change dir to '%s' (%s) ***\n"
argument_list|,
name|dir
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK_LOCAL_ERROR
return|;
block|}
comment|/*-- so we are able to exec .rfaexec --*/
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"\texecuting '%s'...\n"
argument_list|,
name|execfn
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|makeFN
argument_list|(
name|execfn
argument_list|)
argument_list|,
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NOTOK_LOCAL_ERROR
return|;
return|return
name|OK
return|;
block|}
end_block

end_unit

