begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Source: /f/osi/others/ntp/RCS/test.c,v $ $Revision: 7.1 $ $Date: 91/02/22 09:34:11 $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Log:	test.c,v $  * Revision 7.1  91/02/22  09:34:11  mrose  * Interim 6.8  *   * Revision 7.0  90/12/10  17:21:56  mrose  * *** empty log message ***  *   * Revision 1.1  89/06/15  20:37:07  jpo  * Initial revision  *   * Revision 3.4.1.4  89/05/18  18:37:39  louie  * Add test for GENERIC_UNS_BUG to test.c  *   * Revision 3.4.1.3  89/04/07  19:10:41  louie  * Add check for SUN_FLT_BUG problem in test.c  *   * Revision 3.4.1.2  89/03/31  16:39:19  louie  * Bug fix for VAX_COMPILER_FLT_BUG test, start of test for Sun problem.  *   * Revision 3.4.1.1  89/03/22  18:32:26  louie  * patch3: Use new RCS headers.  *   * Revision 3.4  89/03/17  18:37:32  louie  * Latest test release.  *   * Revision 3.3  89/03/15  14:20:16  louie  * New baseline for next release.  *   * Revision 3.2.1.1  89/03/15  14:11:08  louie  * Add in kludge for old VAX pcc compiler bug that incorrectly converts unsigned  * longs to doubles.  This enables the ntest program to run when  * VAX_COMPILER_FLT_BUG is defined on those systems.  *   * Revision 3.2  89/03/07  18:30:16  louie  * New version of UNIX NTP daemon based on the 6 March 1989 draft of the new  * NTP protocol spec.  This module has mostly cosmetic changes.  *   * Revision 3.1.1.1  89/02/15  08:49:34  louie  * *** empty log message ***  *   *   * Revision 3.1  89/01/30  14:43:19  louie  * Second UNIX NTP test release.  *   * Revision 3.0  88/12/12  16:01:37  louie  * Test release of new UNIX NTP software.  This version should conform to the  * revised NTP protocol specification.  *   */
end_comment

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_decl_stmt
name|int
name|test1
argument_list|()
decl_stmt|,
name|test2
argument_list|()
decl_stmt|,
name|test3
argument_list|()
decl_stmt|,
name|test4
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|value
index|[
literal|8
index|]
init|=
block|{
literal|5.1
block|,
operator|-
literal|5.1
block|,
literal|1.5
block|,
operator|-
literal|1.5
block|,
literal|0.5
block|,
operator|-
literal|0.5
block|,
operator|-
literal|0.05
block|,
literal|0.0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exit
argument_list|(
name|test1
argument_list|(
literal|1
argument_list|)
operator|+
name|test2
argument_list|(
literal|1
argument_list|)
operator|+
name|test3
argument_list|(
literal|1
argument_list|)
operator|+
name|test4
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|test3
argument_list|(
literal|0
argument_list|)
condition|)
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|test4
argument_list|(
literal|0
argument_list|)
condition|)
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|test1
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|double
name|l_fixed_to_double
parameter_list|()
function_decl|;
name|struct
name|l_fixedpt
name|sample
decl_stmt|;
name|double
name|s_fixed_to_double
parameter_list|()
function_decl|;
name|struct
name|s_fixedpt
name|s_sample
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %4.2f "
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|double_to_l_fixed
argument_list|(
operator|&
name|sample
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" x%#8X.%#8X "
argument_list|,
name|sample
operator|.
name|int_part
argument_list|,
name|sample
operator|.
name|fraction
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf(" %4.2f", l_fixed_to_double(&sample));
endif|#
directive|endif
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|double_to_s_fixed
argument_list|(
operator|&
name|s_sample
argument_list|,
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" x%#4X.%#4X "
argument_list|,
name|s_sample
operator|.
name|int_part
argument_list|,
name|s_sample
operator|.
name|fraction
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4.2f\n"
argument_list|,
name|s_fixed_to_double
argument_list|(
operator|&
name|s_sample
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|test2
argument_list|()
end_macro

begin_block
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|l_fixedpt
name|time_lm
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tstamp
argument_list|(
operator|&
name|time_lm
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tv_sec:  %d tv_usec:  %d \n"
argument_list|,
name|tp
operator|.
name|tv_sec
argument_list|,
name|tp
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"intpart: %lu fraction: %lu \n"
argument_list|,
name|ntohl
argument_list|(
name|time_lm
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|time_lm
operator|.
name|fraction
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"intpart: %lX fraction: %lX \n"
argument_list|,
name|ntohl
argument_list|(
name|time_lm
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|time_lm
operator|.
name|fraction
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|test3
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|long
name|ul
init|=
literal|0x80000001
decl_stmt|;
name|double
name|dbl
decl_stmt|;
ifdef|#
directive|ifdef
name|GENERIC_UNS_BUG
comment|/* 	 *  Hopefully, we can avoid the unsigned issue altogether.  Make sure 	 *  that the high-order (sign) bit is zero, and fiddle from there  	 */
name|dbl
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|ul
operator|>>
literal|1
operator|)
operator|&
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|dbl
operator|*=
literal|2.0
expr_stmt|;
if|if
condition|(
name|ul
operator|&
literal|1
condition|)
name|dbl
operator|+=
literal|1.0
expr_stmt|;
else|#
directive|else
name|dbl
operator|=
name|ul
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX_COMPILER_FLT_BUG
if|if
condition|(
name|dbl
operator|<
literal|0.0
condition|)
name|dbl
operator|+=
literal|4.294967296e9
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|dbl
operator|!=
literal|2147483649.0
condition|)
block|{
name|printf
argument_list|(
literal|"test3 fails: can't convert from unsigned long to float\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"             (%lu != %15g)\n"
argument_list|,
name|ul
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Try defining VAX_COMPILER_FLT_BUG or GENERIC_UNS_BUG in the Makefile.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|v
condition|)
name|printf
argument_list|(
literal|"test3 passes\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_block

begin_macro
name|test4
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|dbl
init|=
literal|1024.0
operator|*
literal|1024.0
operator|*
literal|1024.0
decl_stmt|;
comment|/* 2^30 */
ifdef|#
directive|ifdef
name|SUN_FLT_BUG
name|int
name|l
init|=
literal|1.5
operator|*
name|dbl
decl_stmt|;
name|u_long
name|ul
init|=
operator|(
name|l
operator|<<
literal|1
operator|)
decl_stmt|;
else|#
directive|else
name|u_long
name|ul
init|=
literal|3.0
operator|*
name|dbl
decl_stmt|;
comment|/* between 2^31 and 2^32 */
endif|#
directive|endif
if|if
condition|(
name|v
condition|)
name|printf
argument_list|(
literal|"test4: 3.0*1024.0*1024.0*1024.0 = 0x%08x\n"
argument_list|,
name|ul
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|!=
literal|0xc0000000
condition|)
block|{
name|printf
argument_list|(
literal|"test4 fails:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Can't convert unsigned long to double.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Try defining SUN_FLT_BUG in the Makefile\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|v
condition|)
name|printf
argument_list|(
literal|"test4 passes\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_block

end_unit

