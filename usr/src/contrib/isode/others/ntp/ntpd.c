begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/others/ntp/RCS/ntpd.c,v 7.2 91/02/22 09:33:57 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * ntp daemon - based on the 3.4 version but heavily modified for OSI  * interworking.  *  * $Log:	ntpd.c,v $  * Revision 7.2  91/02/22  09:33:57  mrose  * Interim 6.8  *   * Revision 7.1  90/12/10  23:15:49  mrose  * isode/  *   * Revision 7.0  90/12/10  17:21:38  mrose  * *** empty log message ***  *   * Revision 1.4  90/08/14  10:14:00  jpo  * new protocol version  *   * Revision 1.3  90/02/13  14:24:11  jpo  * First beta released version  *   * Revision 1.2  89/12/19  08:33:00  jpo  * Updated for ISODE 6.0ish  *   * Revision 1.1  89/06/15  20:37:00  jpo  * Initial revision  *   *   */
end_comment

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|conf
init|=
name|NTPINITFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|driftcomp_file
init|=
name|NTPDRIFTCOMP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|osiaddress
init|=
literal|"Internet=localhost+10123"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myname
init|=
literal|"ntpd"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doset
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|selfds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trusting
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keepallpeers
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logstats
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SETTICKADJ
end_ifdef

begin_decl_stmt
name|int
name|tickadj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dotickadj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NOSWAP
end_ifdef

begin_decl_stmt
name|int
name|noswap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|unsigned
name|int
name|servport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|clock_watchdog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|WayTooBig
init|=
name|WAYTOOBIG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|list
name|peer_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|tv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ntpdata
name|ntpframe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sysdata
name|sys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fd_set
name|globmask
decl_stmt|,
name|globwmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* STATIC data */
end_comment

begin_decl_stmt
specifier|static
name|int
name|drift_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LLog
name|_pgm_log
init|=
block|{
literal|"ntp.log"
block|,
name|NULLCP
block|,
name|NULLCP
block|,
name|LLOG_FATAL
operator||
name|LLOG_EXCEPTIONS
operator||
name|LLOG_NOTICE
block|,
name|LLOG_FATAL
block|,
operator|-
literal|1
block|,
name|LLOGCLS
operator||
name|LLOGCRT
block|,
name|NOTOK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LLog
modifier|*
name|pgm_log
init|=
operator|&
name|_pgm_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|priority
init|=
operator|-
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ticked
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|timeout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_ntp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_kern_vars
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hourly
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_peer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|finish
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|make_new_peer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|transmit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|process_packet
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|clock_update
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|clear
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|clock_filter
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|select_clock
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|advise
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|adios
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_logical_clock
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|create_osilisten
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|iso_init
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|incdebug
argument_list|()
decl_stmt|,
name|decdebug
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|struct
name|ntp_peer
modifier|*
name|find_peer
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|myname
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
name|myname
operator|++
expr_stmt|;
if|if
condition|(
name|myname
operator|==
name|NULL
operator|||
operator|*
name|myname
operator|==
name|NULL
condition|)
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|isodetailor
argument_list|(
name|myname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initialize
argument_list|()
expr_stmt|;
comment|/* call NTP protocol initialization first, 				   then allow others to override default 				   values */
while|while
condition|(
operator|(
name|cc
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:c:dD:lstnp:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
name|WayTooBig
operator|=
literal|10e15
expr_stmt|;
else|else
name|WayTooBig
operator|=
name|atof
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|++
expr_stmt|;
else|#
directive|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: not compiled with DEBUG"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'D'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|#
directive|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: not compiled with DEBUG"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'s'
case|:
name|doset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
ifdef|#
directive|ifdef
name|SETTICKADJ
name|dotickadj
operator|++
expr_stmt|;
else|#
directive|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: not compiled to set tickadj"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'n'
case|:
ifdef|#
directive|ifdef
name|NOSWAP
name|noswap
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: not compiled for noswap"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'l'
case|:
name|logstats
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|conf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|servport
operator|=
name|htons
argument_list|(
name|atoi
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ntpd: -%c: unknown option"
argument_list|,
name|cc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|servport
operator|==
literal|0
condition|)
block|{
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"ntp"
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|servport
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
else|else
name|servport
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
name|peer_list
operator|.
name|head
operator|=
name|peer_list
operator|.
name|tail
operator|=
name|NULL
expr_stmt|;
name|peer_list
operator|.
name|members
operator|=
literal|0
expr_stmt|;
name|srandom
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|init_ntp
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|init_kern_vars
argument_list|()
expr_stmt|;
name|init_logical_clock
argument_list|()
expr_stmt|;
name|envinit
argument_list|()
expr_stmt|;
name|create_listeners
argument_list|()
expr_stmt|;
comment|/* 	 * Attempt to open for writing the file for storing the drift comp 	 * register.  File must already exist for snapshots to be taken. 	 */
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|driftcomp_file
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0644
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|drift_fd
operator|=
name|i
expr_stmt|;
block|}
name|doit
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|doit
argument_list|()
end_macro

begin_block
block|{
name|struct
name|timeval
name|tvt
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|,
name|writefds
decl_stmt|;
name|int
name|vecp
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|newfd
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|globmask
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|globwmask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nintf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|addrs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INTF_VALID
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|FD_SET
argument_list|(
name|addrs
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|globmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrs
index|[
name|i
index|]
operator|.
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Addr %d: %s fd %d %s broadcast %s"
operator|,
name|i
operator|,
name|addrs
index|[
name|i
index|]
operator|.
name|name
operator|,
name|addrs
index|[
name|i
index|]
operator|.
name|fd
operator|,
name|paddr
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
operator|,
name|ntoa
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|bcast
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Addr %d: %s fd %d %s"
operator|,
name|i
operator|,
name|addrs
index|[
name|i
index|]
operator|.
name|name
operator|,
name|addrs
index|[
name|i
index|]
operator|.
name|fd
operator|,
name|paddr
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|finish
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|finish
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|incdebug
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|decdebug
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Find highest fd in use.  This might save a few microseconds in 	 * the select system call. 	 */
for|for
control|(
name|selfds
operator|=
name|FD_SETSIZE
operator|-
literal|1
init|;
name|selfds
condition|;
name|selfds
operator|--
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|selfds
argument_list|,
operator|&
name|globmask
argument_list|)
condition|)
break|break;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Highest fd in use is %d"
operator|,
name|selfds
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|selfds
condition|)
name|abort
argument_list|()
expr_stmt|;
name|selfds
operator|++
expr_stmt|;
comment|/* prime the pump! */
name|ticked
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* go into a finite but hopefully very long loop */
name|readfds
operator|=
name|globmask
expr_stmt|;
name|writefds
operator|=
name|globwmask
expr_stmt|;
name|TRACE
argument_list|(
literal|7
argument_list|,
operator|(
literal|"wait nfds %d, fds 0x%x 0x%x"
operator|,
name|selfds
operator|,
name|readfds
operator|.
name|fds_bits
index|[
literal|0
index|]
operator|,
name|writefds
operator|.
name|fds_bits
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ticked
condition|)
block|{
name|ticked
operator|=
literal|0
expr_stmt|;
name|tvt
operator|=
name|tv
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|TNetAcceptAux
argument_list|(
operator|&
name|vecp
argument_list|,
name|vec
argument_list|,
operator|&
name|newfd
argument_list|,
name|NULLTA
argument_list|,
name|selfds
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|,
name|NULLFD
argument_list|,
operator|(
literal|1
operator|<<
name|CLOCK_ADJ
operator|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|-
name|tvt
operator|.
name|tv_sec
operator|>=
operator|(
literal|1
operator|<<
name|CLOCK_ADJ
operator|)
condition|)
name|ticked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vecp
operator|>
literal|0
condition|)
name|iso_init
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nintf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|addrs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INTF_SELECT
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|addrs
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
operator|&&
operator|!
name|FD_ISSET
argument_list|(
name|addrs
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|writefds
argument_list|)
condition|)
continue|continue;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"Activity on if %d fd=%d (%s)"
operator|,
name|i
operator|,
name|addrs
index|[
name|i
index|]
operator|.
name|fd
operator|,
name|addrs
index|[
name|i
index|]
operator|.
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INTF_PENDING
condition|)
block|{
name|struct
name|ntp_peer
modifier|*
name|p
init|=
name|find_peer
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
operator|(
name|void
operator|)
name|make_osi_conn
argument_list|(
name|find_peer
argument_list|(
name|i
argument_list|)
argument_list|,
name|osiaddress
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|addrs
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|INTF_ACCEPTING
condition|)
block|{
name|iso_accept
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|addrs
index|[
name|i
index|]
operator|.
name|uses
operator|++
expr_stmt|;
switch|switch
condition|(
name|addrs
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|type
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|recv_inet
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
break|break;
case|case
name|AF_OSI
case|:
if|if
condition|(
name|recv_osi
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
argument_list|,
operator|&
name|tv
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
break|break;
default|default:
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Address family %d not supported"
operator|,
name|addrs
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|type
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ticked
condition|)
name|timeout
argument_list|(
call|(
name|int
call|)
argument_list|(
name|tv
operator|.
name|tv_sec
operator|-
name|tvt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|ntp_peer
modifier|*
name|check_peer
parameter_list|(
name|dst
parameter_list|,
name|sock
parameter_list|)
name|struct
name|Naddr
modifier|*
name|dst
decl_stmt|;
name|int
name|sock
decl_stmt|;
block|{
specifier|register
name|struct
name|ntp_peer
modifier|*
name|peer
init|=
name|peer_list
operator|.
name|head
decl_stmt|;
while|while
condition|(
name|peer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addr_compare
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|,
name|dst
argument_list|)
operator|&&
operator|(
operator|(
name|peer
operator|->
name|sock
operator|==
name|sock
operator|)
operator|||
operator|(
name|peer
operator|->
name|sock
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|peer
return|;
name|peer
operator|=
name|peer
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|dump_pkt
parameter_list|(
name|dst
parameter_list|,
name|pkt
parameter_list|,
name|peer
parameter_list|)
name|struct
name|Naddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|ntpdata
modifier|*
name|pkt
decl_stmt|;
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
name|struct
name|Naddr
name|clock_host
decl_stmt|;
name|printf
argument_list|(
literal|"Packet: %s\n"
argument_list|,
name|paddr
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Leap %d, version %d, mode %d, poll %d, precision %d stratum %d"
argument_list|,
operator|(
name|pkt
operator|->
name|status
operator|&
name|LEAPMASK
operator|)
operator|>>
literal|6
argument_list|,
operator|(
name|pkt
operator|->
name|status
operator|&
name|VERSIONMASK
operator|)
operator|>>
literal|3
argument_list|,
name|pkt
operator|->
name|status
operator|&
name|MODEMASK
argument_list|,
name|pkt
operator|->
name|ppoll
argument_list|,
name|pkt
operator|->
name|precision
argument_list|,
name|pkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pkt
operator|->
name|stratum
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|printf
argument_list|(
literal|" (%.4s)\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pkt
operator|->
name|refid
argument_list|)
expr_stmt|;
break|break;
default|default:
name|clock_host
operator|.
name|inet_ad
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|(
name|u_long
operator|)
name|pkt
operator|->
name|refid
expr_stmt|;
name|clock_host
operator|.
name|type
operator|=
name|AF_INET
expr_stmt|;
name|printf
argument_list|(
literal|" [%s]\n"
argument_list|,
name|paddr
argument_list|(
operator|&
name|clock_host
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"Synch Dist is %04X.%04X  Synch Dispersion is %04X.%04X\n"
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|pkt
operator|->
name|distance
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|pkt
operator|->
name|distance
operator|.
name|fraction
argument_list|)
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|pkt
operator|->
name|dispersion
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|pkt
operator|->
name|dispersion
operator|.
name|fraction
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Reference Timestamp is %08lx.%08lx\n"
argument_list|,
name|ntohl
argument_list|(
name|pkt
operator|->
name|reftime
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|pkt
operator|->
name|reftime
operator|.
name|fraction
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Originate Timestamp is %08lx.%08lx\n"
argument_list|,
name|ntohl
argument_list|(
name|pkt
operator|->
name|org
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|pkt
operator|->
name|org
operator|.
name|fraction
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Receive Timestamp is   %08lx.%08lx\n"
argument_list|,
name|ntohl
argument_list|(
name|pkt
operator|->
name|rec
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|pkt
operator|->
name|rec
operator|.
name|fraction
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Transmit Timestamp is  %08lx.%08lx\n"
argument_list|,
name|ntohl
argument_list|(
name|pkt
operator|->
name|xmt
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|pkt
operator|->
name|xmt
operator|.
name|fraction
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"Input Timestamp is     %08lx.%08lx\n"
argument_list|,
name|ntohl
argument_list|(
name|peer
operator|->
name|rec
operator|.
name|int_part
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|peer
operator|->
name|rec
operator|.
name|fraction
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|make_new_peer
parameter_list|(
name|peer
parameter_list|)
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|void
name|double_to_s_fixed
parameter_list|()
function_decl|;
comment|/* 	 * initialize peer data fields  	 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|peer
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|peer
argument_list|)
argument_list|)
expr_stmt|;
name|peer
operator|->
name|src
operator|.
name|type
operator|=
name|peer
operator|->
name|src
operator|.
name|inet_ad
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_SYM_PAS
expr_stmt|;
comment|/* default: symmetric passive mode */
name|peer
operator|->
name|timer
operator|=
literal|1
operator|<<
name|NTP_MINPOLL
expr_stmt|;
name|peer
operator|->
name|hpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|peer
operator|->
name|ppoll
operator|=
name|NTP_MAXPOLL
expr_stmt|;
name|peer
operator|->
name|vers
operator|=
literal|2
expr_stmt|;
name|peer
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|double_to_s_fixed
argument_list|(
operator|&
name|peer
operator|->
name|dispersion
argument_list|,
name|PEER_MAXDISP
argument_list|)
expr_stmt|;
name|peer
operator|->
name|estoffset
operator|=
literal|0.0
expr_stmt|;
name|peer
operator|->
name|estdelay
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_WINDOW
condition|;
name|i
operator|++
control|)
block|{
name|peer
operator|->
name|filter
operator|.
name|offset
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
name|peer
operator|->
name|filter
operator|.
name|delay
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  This procedure is called to delete a peer from our list of peers.  */
end_comment

begin_macro
name|demobilize
argument_list|(
argument|l
argument_list|,
argument|peer
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|list
modifier|*
name|l
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|struct
name|ntp_peer
name|dummy_peer
decl_stmt|;
if|if
condition|(
name|keepallpeers
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_SNOOZE
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|peer
operator|==
operator|&
name|dummy_peer
condition|)
ifdef|#
directive|ifdef
name|DEBUG
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|peer
operator|->
name|next
operator|==
name|NULL
operator|&&
name|peer
operator|->
name|prev
operator|==
name|NULL
operator|)
operator|||
name|l
operator|->
name|tail
operator|==
name|NULL
operator|||
name|l
operator|->
name|head
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* delete only peer in list? */
if|if
condition|(
name|l
operator|->
name|head
operator|==
name|l
operator|->
name|tail
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|l
operator|->
name|head
operator|!=
name|peer
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|l
operator|->
name|head
operator|=
name|l
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
comment|/* delete first peer? */
if|if
condition|(
name|l
operator|->
name|head
operator|==
name|peer
condition|)
block|{
name|l
operator|->
name|head
operator|=
name|peer
operator|->
name|next
expr_stmt|;
name|l
operator|->
name|head
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
comment|/* delete last peer? */
if|if
condition|(
name|l
operator|->
name|tail
operator|==
name|peer
condition|)
block|{
name|l
operator|->
name|tail
operator|=
name|peer
operator|->
name|prev
expr_stmt|;
name|l
operator|->
name|tail
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
comment|/* drop peer in middle */
name|peer
operator|->
name|prev
operator|->
name|next
operator|=
name|peer
operator|->
name|next
expr_stmt|;
name|peer
operator|->
name|next
operator|->
name|prev
operator|=
name|peer
operator|->
name|prev
expr_stmt|;
name|dropit
label|:
ifdef|#
directive|ifdef
name|DEBUG
comment|/* just some sanity checking */
if|if
condition|(
operator|(
name|l
operator|->
name|members
operator|<
literal|0
operator|)
operator|||
operator|(
name|l
operator|->
name|members
operator|&&
name|l
operator|->
name|tail
operator|==
name|NULL
operator|)
operator|||
operator|(
name|l
operator|->
name|members
operator|==
literal|0
operator|&&
name|l
operator|->
name|tail
operator|!=
name|NULL
operator|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"List hosed (demobilize)"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|peer
operator|->
name|next
operator|=
name|peer
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|peer
argument_list|)
expr_stmt|;
name|l
operator|->
name|members
operator|--
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_expr_stmt
name|enqueue
argument_list|(
name|l
argument_list|,
name|peer
argument_list|)
specifier|register
expr|struct
name|list
operator|*
name|l
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|l
operator|->
name|members
operator|++
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|tail
operator|==
name|NULL
condition|)
block|{
comment|/* insertion into empty list */
name|l
operator|->
name|tail
operator|=
name|l
operator|->
name|head
operator|=
name|peer
expr_stmt|;
name|peer
operator|->
name|next
operator|=
name|peer
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* insert at end of list */
name|l
operator|->
name|tail
operator|->
name|next
operator|=
name|peer
expr_stmt|;
name|peer
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|peer
operator|->
name|prev
operator|=
name|l
operator|->
name|tail
expr_stmt|;
name|l
operator|->
name|tail
operator|=
name|peer
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|void
name|timeout
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|int
name|periodic
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
ifndef|#
directive|ifndef
name|XADJTIME2
specifier|extern
name|void
name|adj_host_clock
parameter_list|()
function_decl|;
name|adj_host_clock
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TRACE
argument_list|(
literal|7
argument_list|,
operator|(
literal|"timeout (%d)"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Count down sys.hold if necessary. 	 */
if|if
condition|(
name|sys
operator|.
name|hold
condition|)
block|{
if|if
condition|(
name|sys
operator|.
name|hold
operator|<=
name|n
condition|)
name|sys
operator|.
name|hold
operator|=
literal|0
expr_stmt|;
else|else
name|sys
operator|.
name|hold
operator|-=
name|n
expr_stmt|;
block|}
comment|/* 	 * If interval has expired blast off an NTP to that host. 	 */
for|for
control|(
name|peer
operator|=
name|peer_list
operator|.
name|head
init|;
name|peer
operator|!=
name|NULL
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|peer
operator|->
name|next
operator|==
name|NULL
operator|&&
name|peer
operator|!=
name|peer_list
operator|.
name|tail
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Broken peer list"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_SNOOZE
condition|)
continue|continue;
if|if
condition|(
name|peer
operator|->
name|mode
operator|==
name|PEERMODE_QUERY
condition|)
continue|continue;
if|if
condition|(
name|peer
operator|->
name|reach
operator|!=
literal|0
operator|||
name|peer
operator|->
name|hmode
operator|!=
name|MODE_SERVER
condition|)
block|{
name|peer
operator|->
name|stopwatch
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|timer
operator|<=
name|peer
operator|->
name|stopwatch
condition|)
name|do_peer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
block|}
name|periodic
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|periodic
operator|>=
literal|60
operator|*
literal|60
condition|)
block|{
name|periodic
operator|=
literal|0
expr_stmt|;
name|hourly
argument_list|()
expr_stmt|;
block|}
name|clock_watchdog
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|clock_watchdog
operator|>=
name|NTP_MAXAGE
condition|)
block|{
comment|/* woof, woof - barking dogs bite! */
name|sys
operator|.
name|leap
operator|=
name|ALARM
expr_stmt|;
if|if
condition|(
name|clock_watchdog
operator|<
name|NTP_MAXAGE
operator|+
name|n
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"logical clock adjust timeout (%d seconds)"
argument_list|,
name|NTP_MAXAGE
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|do_peer
parameter_list|(
name|peer
parameter_list|)
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_SNOOZE
condition|)
return|return;
name|peer
operator|->
name|stopwatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_CONREQ
condition|)
block|{
switch|switch
condition|(
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_CONNSTATE
condition|)
block|{
case|case
literal|0
case|:
name|peer
operator|->
name|timer
operator|=
literal|1
operator|<<
operator|(
name|MAX
argument_list|(
name|MIN
argument_list|(
name|peer
operator|->
name|ppoll
argument_list|,
name|MIN
argument_list|(
name|peer
operator|->
name|hpoll
argument_list|,
name|NTP_MAXPOLL
argument_list|)
argument_list|)
argument_list|,
name|NTP_MINPOLL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|backoff
operator|==
literal|0
condition|)
name|peer
operator|->
name|backoff
operator|=
name|BACKOFF_COUNT
expr_stmt|;
else|else
block|{
if|if
condition|(
name|peer
operator|->
name|backoff
operator|==
literal|1
condition|)
name|poll_update
argument_list|(
name|peer
argument_list|,
operator|(
name|int
operator|)
name|peer
operator|->
name|hpoll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|peer
operator|->
name|backoff
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|make_osi_conn
argument_list|(
name|peer
argument_list|,
name|osiaddress
argument_list|)
operator|==
name|NOTOK
condition|)
return|return;
break|break;
case|case
name|PEER_FL_CONNECTED
case|:
break|break;
case|case
name|PEER_FL_CONINP1
case|:
case|case
name|PEER_FL_CONINP2
case|:
return|return;
default|default:
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Bad state flags %d"
argument_list|,
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_CONNSTATE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|transmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * init_ntp() reads NTP daemon configuration information from disk file.  */
end_comment

begin_decl_stmt
name|int
name|precision
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_ntp
parameter_list|(
name|config
parameter_list|)
name|char
modifier|*
name|config
decl_stmt|;
block|{
name|struct
name|Naddr
name|addr
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|double
name|j
decl_stmt|;
name|int
name|argc
decl_stmt|;
define|#
directive|define
name|MAXARGS
value|10
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
specifier|extern
name|double
name|drift_comp
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|config
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|config
argument_list|,
literal|"Problem opening NTP initialization file"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
comment|/* read line and parse */
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buffer
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|argc
operator|=
name|sstr2arg
argument_list|(
name|buffer
argument_list|,
name|MAXARGS
argument_list|,
name|argv
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|config_line
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
operator|!=
name|OK
condition|)
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Ignoring line %s ..."
operator|,
name|argv
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Read saved drift compensation register value. 	 */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|driftcomp_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%lf"
argument_list|,
operator|&
name|j
argument_list|)
operator|==
literal|1
operator|&&
name|j
operator|>
operator|-
literal|1.0
operator|&&
name|j
operator|<
literal|1.0
condition|)
block|{
name|drift_comp
operator|=
name|j
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"Drift compensation value initialized to %f"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"init_ntp: bad drift compensation value"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"cmd_srch.h"
end_include

begin_decl_stmt
name|CMD_TABLE
name|config_tbl
index|[]
init|=
block|{
define|#
directive|define
name|TBL_MAXPEERS
value|1
literal|"maxpeers"
block|,
name|TBL_MAXPEERS
block|,
define|#
directive|define
name|TBL_TRUSTING
value|2
literal|"trusting"
block|,
name|TBL_TRUSTING
block|,
define|#
directive|define
name|TBL_OSILISTEN
value|3
literal|"osilisten"
block|,
name|TBL_OSILISTEN
block|,
define|#
directive|define
name|TBL_LOGCLOCK
value|4
literal|"logclock"
block|,
name|TBL_LOGCLOCK
block|,
define|#
directive|define
name|TBL_DRIFTFILE
value|5
literal|"driftfile"
block|,
name|TBL_DRIFTFILE
block|,
define|#
directive|define
name|TBL_WAYTOOBIG
value|6
literal|"waytoobig"
block|,
name|TBL_WAYTOOBIG
block|,
literal|"setthreshold"
block|,
name|TBL_WAYTOOBIG
block|,
define|#
directive|define
name|TBL_DEBUGLEVEL
value|7
literal|"debuglevel"
block|,
name|TBL_DEBUGLEVEL
block|,
define|#
directive|define
name|TBL_TICKADJ
value|8
literal|"tickadj"
block|,
name|TBL_TICKADJ
block|,
define|#
directive|define
name|TBL_SETTICKADJ
value|9
literal|"settickadj"
block|,
name|TBL_SETTICKADJ
block|,
define|#
directive|define
name|TBL_NOSWAP
value|10
literal|"noswap"
block|,
name|TBL_NOSWAP
block|,
define|#
directive|define
name|TBL_BROADCAST
value|11
literal|"broadcast"
block|,
name|TBL_BROADCAST
block|,
define|#
directive|define
name|TBL_PEER
value|12
literal|"peer"
block|,
name|TBL_PEER
block|,
define|#
directive|define
name|TBL_PASSIVE
value|13
literal|"passive"
block|,
name|TBL_PASSIVE
block|,
define|#
directive|define
name|TBL_SERVER
value|14
literal|"server"
block|,
name|TBL_SERVER
block|,
define|#
directive|define
name|TBL_REFCLOCK
value|15
literal|"refclock"
block|,
name|TBL_REFCLOCK
block|,
define|#
directive|define
name|TBL_STRATUM
value|16
literal|"stratum"
block|,
name|TBL_STRATUM
block|,
define|#
directive|define
name|TBL_PRECISION
value|17
literal|"precision"
block|,
name|TBL_PRECISION
block|,
define|#
directive|define
name|TBL_LOGFILE
value|18
literal|"logfile"
block|,
name|TBL_LOGFILE
block|,
define|#
directive|define
name|TBL_PRIORITY
value|19
literal|"priority"
block|,
name|TBL_PRIORITY
block|,
define|#
directive|define
name|TBL_KEEPALLPEERS
value|20
literal|"keepallpeers"
block|,
name|TBL_KEEPALLPEERS
block|,
literal|""
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|config_line
argument_list|(
argument|argv
argument_list|,
argument|argc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|result
decl_stmt|;
name|struct
name|Naddr
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
switch|switch
condition|(
name|result
operator|=
name|cmd_srch
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|config_tbl
argument_list|)
condition|)
block|{
case|case
name|TBL_PRIORITY
case|:
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|priority
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
return|return
name|NOTOK
return|;
break|break;
case|case
name|TBL_MAXPEERS
case|:
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|sys
operator|.
name|maxpeers
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
return|return
name|NOTOK
return|;
break|break;
case|case
name|TBL_TRUSTING
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
name|trusting
operator|=
name|ynorint
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_OSILISTEN
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
name|osiaddress
operator|=
name|strdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_LOGCLOCK
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
name|logstats
operator|=
name|ynorint
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_LOGFILE
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
name|pgm_log
operator|->
name|ll_file
operator|=
name|strdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_DRIFTFILE
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
name|driftcomp_file
operator|=
name|strdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_WAYTOOBIG
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|lexequ
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
name|WayTooBig
operator|=
literal|10e15
expr_stmt|;
else|else
name|WayTooBig
operator|=
name|atof
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_DEBUGLEVEL
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|+=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TBL_STRATUM
case|:
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"Obsolete command 'stratum'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_PRECISION
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
name|sys
operator|.
name|precision
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_TICKADJ
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|SETTICKADJ
name|tickadj
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TBL_SETTICKADJ
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|SETTICKADJ
name|dotickadj
operator|=
name|ynorint
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TBL_NOSWAP
case|:
ifdef|#
directive|ifdef
name|NOSWAP
name|noswap
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TBL_BROADCAST
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|BROADCAST_NTP
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nintf
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|addrs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nintf
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"config: %s not a known interface"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|addrs
index|[
name|i
index|]
operator|.
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"config: %s doesn't support broadcast"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|peer
operator|=
name|check_peer
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|bcast
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"config file: duplicate broadcast for %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|peer
operator|=
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ntp_peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
name|adios
argument_list|(
literal|"malloc"
argument_list|,
literal|"peer"
argument_list|)
expr_stmt|;
name|make_new_peer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|=
name|PEER_FL_BCAST
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_BROADCAST
expr_stmt|;
name|peer
operator|->
name|src
operator|=
name|addrs
index|[
name|i
index|]
operator|.
name|bcast
expr_stmt|;
name|peer
operator|->
name|sock
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* BROADCAST_NTP */
break|break;
case|case
name|TBL_PEER
case|:
case|case
name|TBL_PASSIVE
case|:
case|case
name|TBL_SERVER
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|GetHostName
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: unknown host"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nintf
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|addr_compare
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
return|return
name|NOTOK
return|;
name|peer
operator|=
name|check_peer
argument_list|(
operator|&
name|addr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"Duplicate peer %s in in config file"
argument_list|,
name|paddr
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|peer
operator|=
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ntp_peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|make_new_peer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|peer
operator|->
name|flags
operator|=
name|PEER_FL_CONFIG
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|TBL_PEER
case|:
comment|/* "peer" */
name|peer
operator|->
name|hmode
operator|=
name|MODE_SYM_ACT
expr_stmt|;
name|peer
operator|->
name|stopwatch
operator|=
name|random
argument_list|()
operator|%
operator|(
literal|1
operator|<<
name|NTP_MINPOLL
operator|)
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_SYNC
expr_stmt|;
break|break;
case|case
name|TBL_SERVER
case|:
comment|/* "server" */
name|peer
operator|->
name|hmode
operator|=
name|MODE_CLIENT
expr_stmt|;
name|peer
operator|->
name|stopwatch
operator|=
name|random
argument_list|()
operator|%
operator|(
literal|1
operator|<<
name|NTP_MINPOLL
operator|)
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_SYNC
expr_stmt|;
break|break;
case|case
name|TBL_PASSIVE
case|:
comment|/* "passive" */
name|peer
operator|->
name|hmode
operator|=
name|MODE_SYM_PAS
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_SYNC
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"can't happen\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|peer
operator|->
name|src
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|type
operator|==
name|AF_OSI
condition|)
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_CONREQ
expr_stmt|;
name|peer
operator|->
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|other_peer_fields
argument_list|(
name|peer
argument_list|,
name|argv
operator|+
literal|2
argument_list|,
name|argc
operator|-
literal|2
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
operator|&
name|peer_list
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Peer %s mode %d"
operator|,
name|paddr
argument_list|(
operator|&
name|peer
operator|->
name|src
argument_list|)
operator|,
name|peer
operator|->
name|hmode
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_REFCLOCK
case|:
if|if
condition|(
name|argc
operator|<
literal|6
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|REFCLOCK
else|else
block|{
name|int
name|stratum
decl_stmt|,
name|prec
decl_stmt|;
name|char
modifier|*
name|ref_clock
decl_stmt|;
name|char
modifier|*
name|clk_type
decl_stmt|;
name|ref_clock
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|stratum
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|prec
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|clk_type
operator|=
name|argv
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|init_clock
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|clk_type
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* If we could not initialize clock line */
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Could not init reference source %s (type %s)"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|clk_type
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|peer
operator|=
operator|(
expr|struct
name|ntp_peer
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntp_peer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|make_new_peer
argument_list|(
name|peer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|peer
operator|->
name|refid
operator|.
name|rid_string
argument_list|,
name|ref_clock
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|peer
operator|->
name|refid
operator|.
name|rid_string
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|refid
operator|.
name|rid_type
operator|=
name|RID_STRING
expr_stmt|;
name|peer
operator|->
name|flags
operator|=
name|PEER_FL_CONFIG
operator||
name|PEER_FL_REFCLOCK
expr_stmt|;
name|peer
operator|->
name|hmode
operator|=
name|MODE_SYM_ACT
expr_stmt|;
name|peer
operator|->
name|stopwatch
operator|=
name|random
argument_list|()
operator|%
operator|(
literal|1
operator|<<
name|NTP_MINPOLL
operator|)
expr_stmt|;
name|peer
operator|->
name|flags
operator||=
name|PEER_FL_SYNC
expr_stmt|;
name|peer
operator|->
name|sock
operator|=
name|i
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratum
expr_stmt|;
name|peer
operator|->
name|precision
operator|=
name|prec
expr_stmt|;
name|clear
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
operator|&
name|peer_list
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Refclock %s mode %d refid %.4s stratum %d precision %d"
operator|,
name|argv
index|[
literal|1
index|]
operator|,
name|peer
operator|->
name|hmode
operator|,
name|peer
operator|->
name|refid
operator|.
name|rid_string
operator|,
name|stratum
operator|,
name|prec
operator|)
argument_list|)
expr_stmt|;
name|transmit
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* head start for REFCLOCK */
block|}
endif|#
directive|endif
endif|REFCLOCK
break|break;
case|case
name|TBL_KEEPALLPEERS
case|:
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
return|return
name|NOTOK
return|;
name|keepallpeers
operator|=
name|ynorint
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_decl_stmt
name|CMD_TABLE
name|tbl_peer_flags
index|[]
init|=
block|{
define|#
directive|define
name|TBLPEER_VERSION
value|1
literal|"version"
block|,
name|TBLPEER_VERSION
block|,
define|#
directive|define
name|TBLPEER_AUTH
value|2
literal|"auth"
block|,
name|TBLPEER_AUTH
block|,
name|NULLCP
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|other_peer_fields
argument_list|(
argument|peer
argument_list|,
argument|argv
argument_list|,
argument|argc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|cmd_srch
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|tbl_peer_flags
argument_list|)
condition|)
block|{
case|case
name|TBLPEER_VERSION
case|:
name|peer
operator|->
name|vers
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|vers
operator|<
literal|1
operator|||
name|peer
operator|->
name|vers
operator|>
literal|2
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"Bad version %d"
argument_list|,
name|peer
operator|->
name|vers
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBLPEER_AUTH
case|:
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
literal|"auth code not done yet"
argument_list|)
expr_stmt|;
break|break;
block|}
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ynorint
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'y'
operator|||
operator|*
name|s
operator|==
literal|'Y'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'n'
operator|||
operator|*
name|s
operator|==
literal|'N'
condition|)
return|return
literal|0
return|;
return|return
name|atoi
argument_list|(
name|s
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
name|int
name|kern_tickadj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kern_hz
decl_stmt|,
name|kern_tick
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NeXT
end_ifdef

begin_define
define|#
directive|define
name|n_name
value|n_un.n_name
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|init_kern_vars
parameter_list|()
block|{
name|int
name|kmem
decl_stmt|;
specifier|static
name|char
modifier|*
name|memory
init|=
literal|"/dev/kmem"
decl_stmt|;
specifier|static
name|struct
name|nlist
name|nl
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|knames
index|[]
init|=
block|{
literal|"_tickadj"
block|,
literal|"_hz"
block|,
literal|"_tick"
block|}
decl_stmt|;
specifier|static
name|int
modifier|*
name|kern_vars
index|[]
init|=
block|{
operator|&
name|kern_tickadj
block|,
operator|&
name|kern_hz
block|,
operator|&
name|kern_tick
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|kmem
operator|=
name|open
argument_list|(
name|memory
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmem
operator|<
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|memory
argument_list|,
literal|"Can't open"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|SYS5
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nl
index|[
name|i
index|]
operator|.
name|n_name
argument_list|,
name|knames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|nl
index|[
name|i
index|]
operator|.
name|n_name
operator|=
name|knames
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SYS5
operator|(
name|void
operator|)
name|nlist
argument_list|(
literal|"/unix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|nlist
argument_list|(
literal|"/vmunix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|kern_vars
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kern_vars
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|long
name|where
decl_stmt|;
if|if
condition|(
operator|(
name|where
operator|=
name|nl
index|[
name|i
index|]
operator|.
name|n_value
operator|)
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Unknown kernal var %s"
argument_list|,
name|nl
index|[
name|i
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|kmem
argument_list|,
name|where
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|""
argument_list|,
literal|"lseek for %s fails"
argument_list|,
name|nl
index|[
name|i
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|kern_vars
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|""
argument_list|,
literal|"read for %s fails"
argument_list|,
name|nl
index|[
name|i
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
operator|*
name|kern_vars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SETTICKADJ
comment|/* 	 *  If desired value of tickadj is not specified in the configuration 	 *  file, compute a "reasonable" value here, based on the assumption  	 *  that we don't have to slew more than 2ms every 4 seconds. 	 * 	 *  TODO: the 500 needs to be parameterized. 	 */
if|if
condition|(
name|tickadj
operator|==
literal|0
operator|&&
name|kern_hz
condition|)
name|tickadj
operator|=
literal|500
operator|/
name|kern_hz
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"kernel vars: tickadj = %d, hz = %d, tick = %d"
operator|,
name|kern_tickadj
operator|,
name|kern_hz
operator|,
name|kern_tick
operator|)
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"desired tickadj = %d, dotickadj = %d"
operator|,
name|tickadj
operator|,
name|dotickadj
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotickadj
operator|&&
name|tickadj
operator|&&
operator|(
name|tickadj
operator|!=
name|kern_tickadj
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|kmem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
name|memory
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
literal|0
index|]
operator|.
name|n_value
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|memory
argument_list|,
literal|"lseek fails"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|kmem
argument_list|)
expr_stmt|;
name|tickadj
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tickadj
operator|&&
name|write
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tickadj
argument_list|,
sizeof|sizeof
argument_list|(
name|tickadj
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|tickadj
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|memory
argument_list|,
literal|"tickadj set fails"
argument_list|)
expr_stmt|;
name|tickadj
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tickadj
operator|&&
name|tickadj
operator|!=
name|kern_tickadj
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"System tickadj SET to %d"
argument_list|,
name|tickadj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|memory
argument_list|,
literal|"Can't open"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SETTICKADJ */
operator|(
name|void
operator|)
name|close
argument_list|(
name|kmem
argument_list|)
expr_stmt|;
comment|/* 	 *  If we have successfully discovered `hz' from the kernel, then we 	 *  can set sys.precision, if it has not already been specified.  If 	 *  no value of `hz' is available, then use default (-6) 	 */
if|if
condition|(
name|sys
operator|.
name|precision
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|kern_hz
operator|<=
literal|64
condition|)
name|sys
operator|.
name|precision
operator|=
operator|-
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|kern_hz
operator|<=
literal|128
condition|)
name|sys
operator|.
name|precision
operator|=
operator|-
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|kern_hz
operator|<=
literal|256
condition|)
name|sys
operator|.
name|precision
operator|=
operator|-
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|kern_hz
operator|<=
literal|512
condition|)
name|sys
operator|.
name|precision
operator|=
operator|-
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
name|kern_hz
operator|<=
literal|1024
condition|)
name|sys
operator|.
name|precision
operator|=
operator|-
literal|10
expr_stmt|;
else|else
name|sys
operator|.
name|precision
operator|=
operator|-
literal|11
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"sys.precision set to %d from sys clock of %d HZ"
argument_list|,
name|sys
operator|.
name|precision
argument_list|,
name|kern_hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given host or net name or internet address in dot notation assign the  * internet address in byte format. source is ../routed/startup.c with minor  * changes to detect syntax errors.   *  * We now try to interpret the name as in address before we go off and bother  * the domain name servers.  *  * Unfortunately the library routine inet_addr() does not detect mal formed  * addresses that have characters or byte values> 255.   */
end_comment

begin_macro
name|GetHostName
argument_list|(
argument|name
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Naddr
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|HostAddr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"INET"
argument_list|)
operator|==
literal|0
condition|)
name|addr
operator|->
name|type
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"OSI"
argument_list|)
operator|==
literal|0
condition|)
name|addr
operator|->
name|type
operator|=
name|AF_OSI
expr_stmt|;
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Unknown prefix %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|name
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|addr
operator|->
name|type
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|type
operator|==
name|AF_INET
operator|&&
operator|(
name|HostAddr
operator|=
name|inet_addr
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|addr
operator|->
name|inet_ad
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|(
name|u_long
operator|)
name|HostAddr
expr_stmt|;
name|addr
operator|->
name|inet_ad
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|->
name|inet_ad
operator|.
name|sin_port
operator|=
name|servport
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|addr
operator|->
name|type
operator|==
name|AF_INET
operator|&&
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
return|return
name|NOTOK
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
operator|->
name|inet_ad
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|addr
operator|->
name|inet_ad
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|addr
operator|->
name|inet_ad
operator|.
name|sin_port
operator|=
name|servport
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|addr
operator|->
name|type
operator|==
name|AF_OSI
condition|)
block|{
name|struct
name|PSAPaddr
modifier|*
name|pa
decl_stmt|;
if|if
condition|(
operator|(
name|pa
operator|=
name|str2paddr
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULLPA
condition|)
return|return
name|NOTOK
return|;
name|addr
operator|->
name|psap_ad
operator|=
operator|*
name|pa
expr_stmt|;
return|return
name|OK
return|;
block|}
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_block

begin_comment
comment|/* every hour, dump some useful information to the log */
end_comment

begin_function
specifier|static
name|void
name|hourly
parameter_list|()
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|int
name|p
init|=
literal|0
decl_stmt|;
specifier|static
name|double
name|drifts
index|[
literal|5
index|]
init|=
block|{
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|,
literal|0.0
block|}
decl_stmt|;
specifier|static
name|int
name|drift_count
init|=
literal|0
decl_stmt|;
specifier|extern
name|double
name|drift_comp
decl_stmt|,
name|compliance
decl_stmt|;
specifier|extern
name|int
name|peer_switches
decl_stmt|,
name|peer_sw_inhibited
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"stats: dc %f comp %f peersw %d inh %d"
argument_list|,
name|drift_comp
argument_list|,
name|compliance
argument_list|,
name|peer_switches
argument_list|,
name|peer_sw_inhibited
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys
operator|.
name|peer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" UNSYNC"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REFCLOCK
block|}
elseif|else
if|if
condition|(
name|sys
operator|.
name|peer
operator|->
name|flags
operator|&
name|PEER_FL_REFCLOCK
condition|)
block|{
name|p
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
operator|+
name|p
argument_list|,
literal|" off %f SYNC %.4s %d"
argument_list|,
name|sys
operator|.
name|peer
operator|->
name|estoffset
argument_list|,
name|sys
operator|.
name|peer
operator|->
name|refid
operator|.
name|rid_string
argument_list|,
name|sys
operator|.
name|peer
operator|->
name|stratum
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|p
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
operator|+
name|p
argument_list|,
literal|" off %f SYNC %s %d"
argument_list|,
name|sys
operator|.
name|peer
operator|->
name|estoffset
argument_list|,
name|paddr
argument_list|(
operator|&
name|sys
operator|.
name|peer
operator|->
name|src
argument_list|)
argument_list|,
name|sys
operator|.
name|peer
operator|->
name|stratum
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 *  If the drift compensation snapshot file is open, then write 	 *  the current value to it.  Since there's only one block in the 	 *  file, and no one else is reading it, we'll just keep the file 	 *  open and write to it. 	 */
if|if
condition|(
name|drift_fd
operator|>=
literal|0
condition|)
block|{
name|drifts
index|[
name|drift_count
operator|%
literal|5
index|]
operator|=
name|drift_comp
expr_stmt|;
comment|/* works out to be 70 bytes */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%+12.10f %+12.10f %+12.10f %+12.10f %+12.10f %4d\n"
argument_list|,
name|drifts
index|[
name|drift_count
operator|%
literal|5
index|]
argument_list|,
name|drifts
index|[
operator|(
name|drift_count
operator|+
literal|4
operator|)
operator|%
literal|5
index|]
argument_list|,
name|drifts
index|[
operator|(
name|drift_count
operator|+
literal|3
operator|)
operator|%
literal|5
index|]
argument_list|,
name|drifts
index|[
operator|(
name|drift_count
operator|+
literal|2
operator|)
operator|%
literal|5
index|]
argument_list|,
name|drifts
index|[
operator|(
name|drift_count
operator|+
literal|1
operator|)
operator|%
literal|5
index|]
argument_list|,
name|drift_count
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|drift_fd
argument_list|,
literal|0L
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|drift_fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"write error"
argument_list|,
literal|"drift comp file"
argument_list|)
expr_stmt|;
block|}
name|drift_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|Debugging stuff */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
end_if

begin_function
name|int
specifier|static
name|incdebug
parameter_list|()
block|{
if|if
condition|(
name|debug
operator|==
literal|255
condition|)
return|return;
name|debug
operator|++
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"DEBUG LEVEL %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|decdebug
parameter_list|()
block|{
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
return|return;
name|debug
operator|--
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"DEBUG LEVEL %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|finish
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REFCLOCK
end_ifdef

begin_struct
struct|struct
name|refclock
block|{
name|int
name|fd
decl_stmt|;
name|int
function_decl|(
modifier|*
name|reader
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|refclock
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|refclocks
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
name|int
name|init_clock_local
argument_list|()
decl_stmt|,
name|read_clock_local
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PSTI
end_ifdef

begin_decl_stmt
name|int
name|init_clock_psti
argument_list|()
decl_stmt|,
name|read_clock_psti
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|PSTI
end_endif

begin_macro
name|init_clock
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|refclock
modifier|*
name|r
decl_stmt|;
name|int
function_decl|(
modifier|*
name|reader
function_decl|)
parameter_list|()
function_decl|;
name|int
name|cfd
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reader
operator|=
name|read_clock_local
expr_stmt|;
name|cfd
operator|=
name|init_clock_local
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PSTI
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"psti"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reader
operator|=
name|read_clock_psti
expr_stmt|;
name|cfd
operator|=
name|init_clock_psti
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|PSTI
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Unknown reference clock type (%s)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cfd
operator|>=
literal|0
condition|)
block|{
name|r
operator|=
operator|(
expr|struct
name|refclock
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|refclock
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|fd
operator|=
name|cfd
expr_stmt|;
name|r
operator|->
name|reader
operator|=
name|reader
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|refclocks
expr_stmt|;
name|refclocks
operator|=
name|r
expr_stmt|;
block|}
return|return
operator|(
name|cfd
operator|)
return|;
block|}
end_block

begin_macro
name|read_clock
argument_list|(
argument|cfd
argument_list|,
argument|tvpp
argument_list|,
argument|otvpp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
modifier|*
modifier|*
name|tvpp
decl_stmt|,
modifier|*
modifier|*
name|otvpp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|refclock
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|refclocks
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
name|r
operator|->
name|fd
operator|==
name|cfd
condition|)
return|return
operator|(
call|(
name|r
operator|->
name|reader
call|)
argument_list|(
name|cfd
argument_list|,
name|tvpp
argument_list|,
name|otvpp
argument_list|)
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Can't happen */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|create_listeners
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|create_sockets
argument_list|(
name|servport
argument_list|)
expr_stmt|;
name|create_osilisten
argument_list|(
name|osiaddress
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|paddr
parameter_list|(
name|addr
parameter_list|)
name|struct
name|Naddr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|type
condition|)
block|{
case|case
name|AF_UNSPEC
case|:
return|return
literal|"None"
return|;
case|case
name|AF_INET
case|:
return|return
name|ntoa
argument_list|(
operator|&
name|addr
operator|->
name|inet_ad
argument_list|)
return|;
case|case
name|AF_OSI
case|:
return|return
name|paddr2str
argument_list|(
operator|&
name|addr
operator|->
name|psap_ad
argument_list|,
name|NULLNA
argument_list|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown address type %d"
argument_list|,
name|addr
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_macro
name|envinit
argument_list|()
end_macro

begin_block
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|getdtablesize
argument_list|()
init|;
name|s
operator|>=
literal|0
condition|;
name|s
operator|--
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|s
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|s
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pgm_log
operator|->
name|ll_events
operator|=
name|LLOG_ALL
expr_stmt|;
name|ll_dbinit
argument_list|(
name|pgm_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"%s starting: version $Revision: 7.2 $ patchlevel %d"
argument_list|,
name|myname
argument_list|,
name|PATCHLEVEL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS5
operator|(
name|void
operator|)
name|nice
argument_list|(
name|priority
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|priority
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NOSWAP
if|if
condition|(
name|noswap
condition|)
if|if
condition|(
name|plock
argument_list|(
name|PROCLOCK
argument_list|)
operator|!=
literal|0
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"plock()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|adios
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
specifier|extern
name|LLog
modifier|*
name|pgm_log
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_FATAL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|;
specifier|extern
name|LLog
modifier|*
name|pgm_log
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|code
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS3 */
end_comment

begin_function
name|void
name|advise
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|advise
argument_list|(
name|code
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|addr_compare
argument_list|(
argument|pa1
argument_list|,
argument|pa2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Naddr
modifier|*
name|pa1
decl_stmt|,
modifier|*
name|pa2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pa1
operator|->
name|type
operator|!=
name|pa2
operator|->
name|type
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|pa1
operator|->
name|type
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|pa1
operator|->
name|inet_ad
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|pa2
operator|->
name|inet_ad
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pa1
operator|->
name|inet_ad
operator|.
name|sin_port
operator|!=
name|pa2
operator|->
name|inet_ad
operator|.
name|sin_port
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|AF_OSI
case|:
return|return
name|psapaddr_cmp
argument_list|(
operator|&
name|pa1
operator|->
name|psap_ad
argument_list|,
operator|&
name|pa2
operator|->
name|psap_ad
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_block

begin_macro
name|psapaddr_cmp
argument_list|(
argument|pa1
argument_list|,
argument|pa2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|PSAPaddr
modifier|*
name|pa1
decl_stmt|,
modifier|*
name|pa2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ps1
decl_stmt|,
modifier|*
name|ps2
decl_stmt|;
if|if
condition|(
operator|(
name|ps1
operator|=
name|_paddr2str
argument_list|(
name|pa1
argument_list|,
name|NULLNA
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|ps2
operator|=
name|_paddr2str
argument_list|(
name|pa2
argument_list|,
name|NULLNA
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|ps1
argument_list|,
name|ps2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|struct
name|ntp_peer
modifier|*
name|find_peer
parameter_list|(
name|n
parameter_list|)
block|{
name|struct
name|ntp_peer
modifier|*
name|peer
decl_stmt|;
for|for
control|(
name|peer
operator|=
name|peer_list
operator|.
name|head
init|;
name|peer
condition|;
name|peer
operator|=
name|peer
operator|->
name|next
control|)
if|if
condition|(
name|peer
operator|->
name|sock
operator|==
name|n
condition|)
return|return
name|peer
return|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Can't find peer with sock %d"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|intf
modifier|*
name|getintf
parameter_list|(
name|n
parameter_list|)
name|int
modifier|*
name|n
decl_stmt|;
block|{
name|int
name|acount
decl_stmt|;
name|struct
name|intf
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|acount
operator|=
literal|0
operator|,
name|ap
operator|=
name|addrs
init|;
name|acount
operator|<
name|nintf
condition|;
name|ap
operator|++
operator|,
name|acount
operator|++
control|)
if|if
condition|(
name|ap
operator|->
name|flags
operator|==
literal|0
condition|)
block|{
operator|*
name|n
operator|=
name|acount
expr_stmt|;
return|return
name|ap
return|;
block|}
if|if
condition|(
name|nintf
operator|==
literal|0
condition|)
name|addrs
operator|=
operator|(
expr|struct
name|intf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ap
argument_list|)
expr_stmt|;
else|else
name|addrs
operator|=
operator|(
expr|struct
name|intf
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addrs
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|nintf
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrs
operator|==
name|NULL
condition|)
name|adios
argument_list|(
literal|"memory"
argument_list|,
literal|"out of"
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|&
name|addrs
index|[
name|nintf
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|,
sizeof|sizeof
expr|*
name|ap
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
name|nintf
operator|++
expr_stmt|;
return|return
name|ap
return|;
block|}
end_function

end_unit

