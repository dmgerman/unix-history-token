begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* widget.c - Provides the screen and widget code */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/others/quipu/uips/sd/RCS/widget.c,v 7.2 91/02/22 09:32:29 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/others/quipu/uips/sd/RCS/widget.c,v 7.2 91/02/22 09:32:29 mrose Interim $  */
end_comment

begin_comment
comment|/*    This file has been modified by Damanjit Mahl @ Brunel University  */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/* File:	widget.c /* Author:	Paul Sharpe @ GEC Research, Hirst Research Centre. /* Date:	August 12, 1988. /* Function:	Provides the screen and widget code. /* /* DISCLAIMER: /* This source file is deemed to be public domain: any person may use the /* code in any way, on two simple provisos - /*   1 - That this header remains in this file, /*   2 - It is accepted that neither the author, nor the authors employees /*       accept any responsibility for the use, abuse or misuse of the /*       contained code. /* No guarantee is made by the author to provide maintainance or up-grading /* of this source. However, any adaptations made to this file will be viewed /* at least with interest. /*****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"widget.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|filtvalue
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|typeindx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|av_typeindx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|get_listed_object
argument_list|()
decl_stmt|,
name|scrollbar
argument_list|()
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|active
block|{
name|int
name|count
decl_stmt|;
name|WIDGET
modifier|*
name|widgets
index|[
name|MAXACTIVE
index|]
decl_stmt|;
name|char
name|lastindex
index|[
name|MAXACTIVE
index|]
decl_stmt|;
name|WINDOW
modifier|*
name|text
index|[
name|MAXACTIVE
index|]
decl_stmt|;
block|}
name|activelist
struct|;
end_struct

begin_decl_stmt
name|char
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WINDOW
modifier|*
name|Text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|text_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initwidgets
parameter_list|()
block|{
operator|(
name|void
operator|)
name|initscr
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|noecho
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|crmode
argument_list|()
expr_stmt|;
name|Text
operator|=
name|stdscr
expr_stmt|;
name|typetoggled
operator|=
literal|0
expr_stmt|;
name|activelist
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|textfresh
parameter_list|()
block|{
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setwidgets
parameter_list|(
name|thesewdgts
parameter_list|,
name|y
parameter_list|)
name|int
name|y
decl_stmt|;
name|WIDGET
modifier|*
name|thesewdgts
decl_stmt|;
block|{
name|currwidgets
operator|=
name|thesewdgts
expr_stmt|;
name|lowy
operator|=
name|posnwidgets
argument_list|(
name|thesewdgts
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|Text
operator|=
name|newwin
argument_list|(
name|LINES
operator|-
literal|1
operator|-
name|lowy
argument_list|,
name|COLS
operator|-
literal|3
argument_list|,
name|lowy
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|text_height
operator|=
name|LINES
operator|-
literal|1
operator|-
name|lowy
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|scrollok
argument_list|(
name|Text
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
name|makewidgets
argument_list|(
name|thesewdgts
argument_list|)
expr_stmt|;
name|activewidget
argument_list|(
name|thesewdgts
argument_list|,
name|Text
argument_list|)
expr_stmt|;
name|rfrshwidgets
argument_list|(
name|thesewdgts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|linec
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
name|LINES
return|;
block|}
end_function

begin_function
name|int
name|gety
parameter_list|()
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|Text
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Get rid of lint warning */
name|x
operator|=
name|x
operator|+
literal|1
expr_stmt|;
return|return
name|y
operator|+
name|lowy
return|;
block|}
end_function

begin_comment
comment|/* Determine the positions of the widgets: return the lowest point */
end_comment

begin_function
name|int
name|posnwidgets
parameter_list|(
name|thesewdgts
parameter_list|,
name|starty
parameter_list|)
name|int
name|starty
decl_stmt|;
name|WIDGET
name|thesewdgts
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|,
name|hght
init|=
name|WDGTHGHT
decl_stmt|;
comment|/* If no explicit position provided, put on the next level */
if|if
condition|(
name|starty
operator|<
literal|0
condition|)
name|starty
operator|=
name|lowesty
argument_list|()
expr_stmt|;
comment|/* Set the position of the widgets, as dynamically as possible */
while|while
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|FINISH
condition|)
block|{
if|if
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|DUMMY
condition|)
block|{
comment|/* If the widget is a scrollbar put on a new line */
if|if
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|==
name|SCROLLBAR
condition|)
block|{
name|starty
operator|+=
name|WDGTHGHT
expr_stmt|;
name|hght
operator|=
name|LINES
operator|-
name|starty
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
comment|/* If the initial structure y-value is CRNL, put on a new line */
if|if
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|y
operator|==
name|CRNL
condition|)
block|{
name|starty
operator|+=
name|WDGTHGHT
expr_stmt|;
name|hght
operator|=
name|WDGTHGHT
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we ain't got a width, make one based on the type/label-length */
if|if
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|wdth
operator|<=
literal|0
condition|)
name|setwdgtwdth
argument_list|(
operator|&
name|thesewdgts
index|[
name|cnt
index|]
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* If the widget won't fit, start a new line of widgets */
if|if
condition|(
name|x
operator|+
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|wdth
operator|>
name|COLS
condition|)
block|{
name|starty
operator|+=
name|WDGTHGHT
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|y
operator|=
name|starty
expr_stmt|;
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|hght
operator|=
name|hght
expr_stmt|;
name|x
operator|+=
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|wdth
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
else|else
operator|++
name|cnt
expr_stmt|;
block|}
return|return
operator|(
name|starty
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create the widgets: return the number of widgets */
end_comment

begin_function
name|void
name|makewidgets
parameter_list|(
name|wdgts
parameter_list|)
name|WIDGET
name|wdgts
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
specifier|register
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
comment|/* Now try to make, box and label the widget windows */
while|while
condition|(
name|wdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|FINISH
condition|)
block|{
if|if
condition|(
name|wdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|DUMMY
condition|)
block|{
name|wdgt
operator|=
operator|&
name|wdgts
index|[
name|cnt
operator|++
index|]
expr_stmt|;
name|wdgt
operator|->
name|wndw
operator|=
name|newwin
argument_list|(
name|wdgt
operator|->
name|hght
argument_list|,
name|wdgt
operator|->
name|wdth
argument_list|,
name|wdgt
operator|->
name|y
argument_list|,
name|wdgt
operator|->
name|x
argument_list|)
expr_stmt|;
name|boxwdgt
argument_list|(
name|wdgt
argument_list|,
literal|'-'
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|printwdgt
argument_list|(
name|wdgt
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
name|cnt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set a widgets width, based on the TYPE of widget and label length */
end_comment

begin_function
name|void
name|setwdgtwdth
parameter_list|(
name|wdgt
parameter_list|,
name|currx
parameter_list|)
name|int
name|currx
decl_stmt|;
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
name|char
name|expand
decl_stmt|;
specifier|register
name|int
name|len
init|=
operator|-
literal|1
decl_stmt|,
name|cnt
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|expand
operator|=
operator|(
name|wdgt
operator|->
name|wdth
operator|==
name|EXPAND
operator|)
condition|)
name|wdgt
operator|->
name|wdth
operator|=
name|COLS
operator|-
name|currx
expr_stmt|;
switch|switch
condition|(
name|wdgt
operator|->
name|type
condition|)
block|{
case|case
name|LABEL
case|:
name|len
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|label
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|wdgt
operator|->
name|wdth
operator|<
name|len
condition|)
if|if
condition|(
name|expand
condition|)
name|wdgt
operator|->
name|wdth
operator|=
name|COLS
expr_stmt|;
else|else
name|wdgt
operator|->
name|wdth
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|DIALOG
case|:
name|len
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|label
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|wdgt
operator|->
name|dstrlen
operator|>
name|DIALOGLEN
condition|)
name|len
operator|+=
name|DIALOGLEN
expr_stmt|;
else|else
name|len
operator|+=
name|wdgt
operator|->
name|dstrlen
expr_stmt|;
if|if
condition|(
name|wdgt
operator|->
name|wdth
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|expand
condition|)
name|wdgt
operator|->
name|wdth
operator|=
name|COLS
expr_stmt|;
else|else
name|wdgt
operator|->
name|wdth
operator|=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|TOGGLE
case|:
if|if
condition|(
name|wdgt
operator|->
name|tvalues
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
name|wdgt
operator|->
name|wdth
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|label
argument_list|)
operator|+
literal|2
expr_stmt|;
else|else
block|{
while|while
condition|(
name|wdgt
operator|->
name|tvalues
index|[
operator|++
name|cnt
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
if|if
condition|(
name|strlen
argument_list|(
name|wdgt
operator|->
name|tvalues
index|[
name|cnt
index|]
argument_list|)
operator|>
name|len
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|tvalues
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|wdgt
operator|->
name|wdth
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|label
argument_list|)
operator|+
name|len
operator|+
literal|2
expr_stmt|;
block|}
break|break;
default|default:
name|wdgt
operator|->
name|wdth
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|label
argument_list|)
operator|+
literal|2
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Erase and remove the widgets, decrementing the activelist counter */
end_comment

begin_function
name|void
name|killwidgets
parameter_list|(
name|thesewdgts
parameter_list|)
name|WIDGET
modifier|*
name|thesewdgts
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|FINISH
condition|)
if|if
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|DUMMY
condition|)
block|{
operator|(
name|void
operator|)
name|wclear
argument_list|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|wndw
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|thesewdgts
index|[
name|cnt
operator|++
index|]
operator|.
name|wndw
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
name|cnt
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|wclear
argument_list|(
name|Text
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
while|while
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|FINISH
condition|)
if|if
condition|(
name|thesewdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|DUMMY
condition|)
name|delwin
argument_list|(
name|thesewdgts
index|[
name|cnt
operator|++
index|]
operator|.
name|wndw
argument_list|)
expr_stmt|;
else|else
operator|++
name|cnt
expr_stmt|;
name|delwin
argument_list|(
name|Text
argument_list|)
expr_stmt|;
name|deleteactive
argument_list|()
expr_stmt|;
name|Text
operator|=
name|activelist
operator|.
name|text
index|[
name|activelist
operator|.
name|count
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|Text
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* THESE FUNCTIONS MANIPULATE THE ACTIVELIST ARRAY OF WIDGETS */
end_comment

begin_comment
comment|/* This should check that the number of active widgets is not excessive, or  * have the activelist really as a linked list.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|activewidget
parameter_list|(
name|wdgts
parameter_list|,
name|text
parameter_list|)
name|WIDGET
name|wdgts
index|[]
decl_stmt|;
name|WINDOW
modifier|*
name|text
decl_stmt|;
block|{
name|activelist
operator|.
name|widgets
index|[
name|activelist
operator|.
name|count
index|]
operator|=
name|wdgts
expr_stmt|;
name|activelist
operator|.
name|text
index|[
name|activelist
operator|.
name|count
index|]
operator|=
name|Text
expr_stmt|;
operator|++
operator|(
name|activelist
operator|.
name|count
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deleteactive
parameter_list|()
block|{
if|if
condition|(
name|activelist
operator|.
name|count
operator|>
literal|0
condition|)
operator|--
operator|(
name|activelist
operator|.
name|count
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|activeindex
parameter_list|(
name|indx
parameter_list|)
name|char
name|indx
decl_stmt|;
block|{
name|activelist
operator|.
name|lastindex
index|[
name|activelist
operator|.
name|count
operator|-
literal|1
index|]
operator|=
name|indx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Refresh each of the active widgets and the current text window */
end_comment

begin_function
name|void
name|redraw
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|clearok
argument_list|(
name|curscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|activelist
operator|.
name|count
condition|;
name|i
operator|++
control|)
name|rfrshwidgets
argument_list|(
name|activelist
operator|.
name|widgets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rfrshwidgets
parameter_list|(
name|thesewdgts
parameter_list|)
name|WIDGET
modifier|*
name|thesewdgts
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|thesewdgts
index|[
name|i
index|]
operator|.
name|wndw
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
operator|&&
name|thesewdgts
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|DUMMY
condition|)
block|{
name|touchwin
argument_list|(
name|thesewdgts
index|[
name|i
index|]
operator|.
name|wndw
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|thesewdgts
index|[
name|i
operator|++
index|]
operator|.
name|wndw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Draw a perimeter box around WDGT, with horizontal char XCH etc */
end_comment

begin_function
name|void
name|boxwdgt
parameter_list|(
name|wdgt
parameter_list|,
name|xch
parameter_list|,
name|ych
parameter_list|)
name|char
name|xch
decl_stmt|,
name|ych
decl_stmt|;
specifier|register
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|wdgt
operator|->
name|wdth
operator|-
literal|1
condition|;
name|x
operator|++
control|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|xch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ych
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|1
init|;
name|y
operator|<
name|wdgt
operator|->
name|hght
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
name|ych
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|y
argument_list|,
name|wdgt
operator|->
name|wdth
operator|-
literal|1
argument_list|,
name|ych
argument_list|)
expr_stmt|;
block|}
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|wdgt
operator|->
name|hght
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|'`'
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|wdgt
operator|->
name|wdth
operator|-
literal|1
condition|;
name|x
operator|++
control|)
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|xch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* THESE ROUTINES PRINT THE INDIVIDUAL WIDGET BOXES */
end_comment

begin_comment
comment|/* Print a widgets label, dependant on the widget type */
end_comment

begin_function
name|void
name|printwdgt
parameter_list|(
name|wdgt
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
switch|switch
condition|(
name|wdgt
operator|->
name|type
condition|)
block|{
case|case
name|LABEL
case|:
name|printlabel
argument_list|(
name|wdgt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIALOG
case|:
name|printdialog
argument_list|(
name|wdgt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOGGLE
case|:
name|printtoggle
argument_list|(
name|wdgt
argument_list|)
expr_stmt|;
break|break;
default|default :
name|printcommand
argument_list|(
name|wdgt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|printbar
parameter_list|(
name|list_size
parameter_list|,
name|first
parameter_list|,
name|display_num
parameter_list|)
name|int
name|list_size
decl_stmt|,
name|first
decl_stmt|,
name|display_num
decl_stmt|;
block|{
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|bar_size
decl_stmt|,
name|bar_pos
init|=
literal|0
decl_stmt|,
name|space_size
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|currwidgets
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|SCROLLBAR
condition|;
name|cnt
operator|++
control|)
empty_stmt|;
name|wdgt
operator|=
operator|&
name|currwidgets
index|[
name|cnt
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|wclear
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
name|boxwdgt
argument_list|(
name|wdgt
argument_list|,
literal|'-'
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
name|space_size
operator|=
name|wdgt
operator|->
name|hght
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|display_num
operator|==
name|list_size
condition|)
block|{
name|bar_size
operator|=
name|space_size
expr_stmt|;
name|bar_pos
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bar_size
operator|=
operator|(
name|display_num
operator|*
name|space_size
operator|)
operator|/
operator|(
name|list_size
operator|+
literal|1
operator|)
expr_stmt|;
name|bar_size
operator|=
name|bar_size
condition|?
name|bar_size
else|:
literal|1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|list_size
operator|*
name|bar_pos
operator|)
operator|/
operator|(
name|first
operator|*
operator|(
name|space_size
operator|+
literal|1
operator|)
operator|)
operator|)
condition|)
name|bar_pos
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|bar_size
operator|+
name|bar_pos
operator|-
literal|1
operator|)
operator|>
name|space_size
condition|)
block|{
name|bar_size
operator|--
expr_stmt|;
block|}
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|bar_size
condition|;
name|cnt
operator|++
control|)
operator|(
name|void
operator|)
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|cnt
operator|+
literal|1
operator|+
name|bar_pos
argument_list|,
literal|1
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|wdgt
operator|->
name|hght
operator|-
literal|2
argument_list|,
literal|1
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a LABEL widgets label string, dependant on the justification char */
end_comment

begin_function
name|void
name|printlabel
parameter_list|(
name|wdgt
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|labellen
decl_stmt|,
name|wdgtlen
decl_stmt|;
name|labellen
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|label
argument_list|)
expr_stmt|;
name|wdgtlen
operator|=
name|wdgt
operator|->
name|wdth
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|labellen
operator|>
name|wdgtlen
condition|)
name|wdgt
operator|->
name|label
index|[
name|wdgtlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|wdgt
operator|->
name|callch
operator|&
name|CENTRE
condition|)
name|x
operator|=
operator|(
name|wdgtlen
operator|-
name|labellen
operator|)
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|wdgt
operator|->
name|callch
operator|&
name|LEFT
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|wdgt
operator|->
name|callch
operator|&
name|RIGHT
condition|)
name|x
operator|=
name|wdgtlen
operator|-
name|labellen
expr_stmt|;
name|mvwaddstr
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|1
argument_list|,
literal|1
operator|+
name|x
argument_list|,
name|wdgt
operator|->
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a DIALOG widget label: if it don't all fit, show the last part */
end_comment

begin_function
name|void
name|printdialog
parameter_list|(
name|wdgt
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
specifier|register
name|int
name|length
decl_stmt|,
name|maxlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|showptr
decl_stmt|;
operator|(
name|void
operator|)
name|wclear
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
name|boxwdgt
argument_list|(
name|wdgt
argument_list|,
literal|'-'
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdgt
operator|->
name|dstr
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|dstr
argument_list|)
expr_stmt|;
name|maxlen
operator|=
name|wdgt
operator|->
name|wdth
operator|-
literal|4
operator|-
name|strlen
argument_list|(
name|wdgt
operator|->
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|maxlen
condition|)
name|showptr
operator|=
operator|&
operator|(
name|wdgt
operator|->
name|dstr
index|[
name|length
operator|-
name|maxlen
index|]
operator|)
expr_stmt|;
else|else
name|showptr
operator|=
name|wdgt
operator|->
name|dstr
expr_stmt|;
operator|(
name|void
operator|)
name|mvwprintw
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"%s%c%s"
argument_list|,
name|wdgt
operator|->
name|label
argument_list|,
operator|(
name|length
operator|>
name|maxlen
operator|)
condition|?
literal|'<'
else|:
literal|' '
argument_list|,
name|showptr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a TOGGLE widget label, and the current toggle value */
end_comment

begin_function
name|void
name|printtoggle
parameter_list|(
name|wdgt
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|wclear
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
name|boxwdgt
argument_list|(
name|wdgt
argument_list|,
literal|'-'
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdgt
operator|->
name|tvalues
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return;
name|mvwaddstr
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|wdgt
operator|->
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|wdgt
operator|->
name|tvalues
index|[
name|wdgt
operator|->
name|tindx
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wclrtoeol
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvwaddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|1
argument_list|,
name|wdgt
operator|->
name|wdth
operator|-
literal|1
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a COMMAND widget label */
end_comment

begin_function
name|void
name|printcommand
parameter_list|(
name|wdgt
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
name|mvwaddstr
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|wdgt
operator|->
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* THESE ROUTINES GET AND REACT TO A USERS INPUT FROM THE KEYBOARD */
end_comment

begin_comment
comment|/* Loop forever, calling widget callback functions when activated */
end_comment

begin_function
name|void
name|interact
parameter_list|()
block|{
specifier|register
name|int
name|ch
decl_stmt|,
name|indx
decl_stmt|;
name|void
name|int_quit
argument_list|()
decl_stmt|,
name|jumpback
argument_list|()
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Get a character input, and set the interrupt jump vector */
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|env
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int_quit
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|jumpback
argument_list|)
expr_stmt|;
comment|/* Allow the user to refresh the entire screen, with a CTRL-L */
if|if
condition|(
name|ch
operator|==
literal|'\014'
condition|)
block|{
name|redraw
argument_list|()
expr_stmt|;
name|scrollbar
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Search through the current widgets for one matching that required */
name|command
operator|=
name|ch
expr_stmt|;
name|indx
operator|=
name|findactiveinput
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|>=
literal|0
condition|)
name|docallback
argument_list|(
name|indx
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find a callback 'ch' from the currently active set of widgets */
end_comment

begin_function
name|int
name|findactiveinput
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
specifier|register
name|int
name|indx
decl_stmt|;
specifier|register
name|WIDGET
modifier|*
name|wdgts
decl_stmt|;
if|if
condition|(
name|ch
operator|>
literal|'z'
operator|||
name|ch
operator|<
literal|'a'
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|ch
operator|=
literal|'*'
expr_stmt|;
break|break;
case|case
literal|'['
case|:
case|case
literal|']'
case|:
name|ch
operator|=
literal|'%'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|ch
operator|=
literal|'h'
expr_stmt|;
break|break;
block|}
block|}
comment|/* See whether the 'ch' exists in the currently active widgets */
name|wdgts
operator|=
name|activelist
operator|.
name|widgets
index|[
name|activelist
operator|.
name|count
operator|-
literal|1
index|]
expr_stmt|;
name|indx
operator|=
name|getwidgetindex
argument_list|(
name|wdgts
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|>=
literal|0
condition|)
return|return
operator|(
name|indx
operator|)
return|;
comment|/* If not, check the previously active widgets, if possible */
if|if
condition|(
name|activelist
operator|.
name|count
operator|<=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|indx
operator|=
name|getwidgetindex
argument_list|(
name|activelist
operator|.
name|widgets
index|[
name|activelist
operator|.
name|count
operator|-
literal|2
index|]
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|>=
literal|0
condition|)
block|{
name|killwidgets
argument_list|(
name|activelist
operator|.
name|widgets
index|[
name|activelist
operator|.
name|count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|indx
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|docallback
parameter_list|(
name|indx
parameter_list|)
name|char
name|indx
decl_stmt|;
block|{
name|WIDGET
modifier|*
name|wdgts
decl_stmt|;
name|activeindex
argument_list|(
name|indx
argument_list|)
expr_stmt|;
name|wdgts
operator|=
name|activelist
operator|.
name|widgets
index|[
name|activelist
operator|.
name|count
operator|-
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|wdgts
index|[
name|indx
index|]
operator|.
name|type
condition|)
block|{
case|case
name|DIALOG
case|:
if|if
condition|(
name|command
operator|>=
literal|'1'
operator|&&
name|command
operator|<=
literal|'9'
condition|)
name|get_listed_object
argument_list|(
name|command
argument_list|,
operator|&
name|wdgts
index|[
name|indx
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|dialog
argument_list|(
operator|&
name|wdgts
index|[
name|indx
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|wdgts
index|[
name|indx
index|]
operator|.
name|callfn
operator|)
operator|(
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|TOGGLE
case|:
name|toggle
argument_list|(
operator|&
name|wdgts
index|[
name|indx
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|wdgts
index|[
name|indx
index|]
operator|.
name|callfn
operator|)
operator|(
operator|)
expr_stmt|;
break|break;
case|case
name|SCROLLBAR
case|:
name|scrollbar
argument_list|(
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
operator|*
name|wdgts
index|[
name|indx
index|]
operator|.
name|callfn
operator|)
operator|(
operator|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* THESE ROUTINES SEARCH THE ACTIVE WIDGET SET FOR ONE SPECIFIED WIDGET */
end_comment

begin_comment
comment|/* Find a widget based on the call-back character */
end_comment

begin_function
name|WIDGET
modifier|*
name|getwidget
parameter_list|(
name|wdgts
parameter_list|,
name|callch
parameter_list|)
name|int
name|callch
decl_stmt|;
name|WIDGET
name|wdgts
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|indx
decl_stmt|;
name|indx
operator|=
name|getwidgetindex
argument_list|(
name|wdgts
argument_list|,
name|callch
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
operator|>=
literal|0
condition|)
return|return
operator|(
operator|&
operator|(
name|wdgts
index|[
name|indx
index|]
operator|)
operator|)
return|;
return|return
operator|(
operator|(
name|WIDGET
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|getwidgetindex
parameter_list|(
name|wdgts
parameter_list|,
name|callch
parameter_list|)
name|int
name|callch
decl_stmt|;
name|WIDGET
name|wdgts
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|wdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|FINISH
condition|)
block|{
if|if
condition|(
name|callch
operator|==
name|wdgts
index|[
name|cnt
index|]
operator|.
name|callch
condition|)
break|break;
operator|++
name|cnt
expr_stmt|;
block|}
if|if
condition|(
name|wdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|FINISH
condition|)
return|return
operator|(
name|cnt
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* THESE ROUTINES MANIPULATE THE DIALOG WIDGETS */
end_comment

begin_function
name|void
name|dialog
parameter_list|(
name|wdgt
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|length
decl_stmt|,
name|labellen
decl_stmt|,
name|maxlen
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|,
modifier|*
name|endptr
decl_stmt|,
modifier|*
name|showptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|blanks
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|labellen
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|label
argument_list|)
expr_stmt|;
comment|/* The length of the prompt string  */
name|length
operator|=
name|strlen
argument_list|(
name|wdgt
operator|->
name|dstr
argument_list|)
expr_stmt|;
comment|/* The length of the current string */
name|maxlen
operator|=
name|wdgt
operator|->
name|wdth
operator|-
literal|4
operator|-
name|labellen
expr_stmt|;
comment|/* The maximum length of shown str  */
name|blanks
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|maxlen
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxlen
condition|;
name|i
operator|++
control|)
name|blanks
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|blanks
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|endptr
operator|=
operator|&
operator|(
name|wdgt
operator|->
name|dstr
index|[
name|length
index|]
operator|)
expr_stmt|;
comment|/* The next character pos'n to fill */
operator|*
name|endptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|maxlen
condition|)
name|showptr
operator|=
operator|&
operator|(
name|wdgt
operator|->
name|dstr
index|[
name|length
operator|-
name|maxlen
index|]
operator|)
expr_stmt|;
else|else
name|showptr
operator|=
name|wdgt
operator|->
name|dstr
expr_stmt|;
operator|(
name|void
operator|)
name|mvwprintw
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"%s%c%s"
argument_list|,
name|wdgt
operator|->
name|label
argument_list|,
operator|(
name|length
operator|>
name|maxlen
operator|)
condition|?
literal|'<'
else|:
literal|' '
argument_list|,
name|showptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|&
literal|127
operator|)
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|'\f'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\014'
condition|)
block|{
comment|/* Allow for redrawing */
name|redraw
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\b'
operator|||
name|ch
operator|==
literal|127
condition|)
block|{
comment|/* Delete a character, with wrapping */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
continue|continue;
operator|*
operator|(
operator|--
name|endptr
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make the last character NULL */
if|if
condition|(
name|showptr
operator|>
name|wdgt
operator|->
name|dstr
condition|)
comment|/* We have parts of the string hidden */
operator|--
name|showptr
expr_stmt|;
operator|--
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|maxlen
condition|)
block|{
comment|/* Only need to erase one character */
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|"\b \b"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We'll have to erase everything */
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|"\r|%s%c%s \b"
argument_list|,
name|wdgt
operator|->
name|label
argument_list|,
operator|(
name|length
operator|<=
name|maxlen
operator|)
condition|?
literal|' '
else|:
literal|'<'
argument_list|,
name|showptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|21
condition|)
block|{
comment|/* ^U to delete the entire line of text */
name|length
operator|=
literal|0
expr_stmt|;
name|endptr
operator|=
name|wdgt
operator|->
name|dstr
expr_stmt|;
operator|*
name|endptr
operator|=
literal|'\0'
expr_stmt|;
name|showptr
operator|=
name|wdgt
operator|->
name|dstr
expr_stmt|;
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|"\r|%s %s\r|%s "
argument_list|,
name|wdgt
operator|->
name|label
argument_list|,
name|blanks
argument_list|,
name|wdgt
operator|->
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Otherwise, add the character if there is room and it ain't a control code */
if|if
condition|(
name|length
operator|==
literal|1024
operator|||
name|ch
operator|<
literal|32
condition|)
continue|continue;
if|if
condition|(
name|length
operator|==
name|wdgt
operator|->
name|dstrlen
condition|)
block|{
operator|*
name|endptr
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|endptr
operator|=
literal|'\0'
expr_stmt|;
name|setdialogstr
argument_list|(
name|wdgt
argument_list|,
name|showptr
argument_list|,
name|wdgt
operator|->
name|dstrlen
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|endptr
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|endptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|++
name|length
operator|<=
name|maxlen
condition|)
block|{
comment|/* Just add this character to the end */
operator|(
name|void
operator|)
name|waddch
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|showptr
expr_stmt|;
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|,
literal|"\r|%s<%s"
argument_list|,
name|wdgt
operator|->
name|label
argument_list|,
name|showptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|wdgt
operator|->
name|wndw
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|blanks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setdialogstr
parameter_list|(
name|wdgt
parameter_list|,
name|dstr
parameter_list|,
name|maxlen
parameter_list|)
name|char
modifier|*
name|dstr
decl_stmt|;
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
block|{
if|if
condition|(
name|wdgt
operator|->
name|type
operator|!=
name|DIALOG
condition|)
return|return;
name|wdgt
operator|->
name|dstr
operator|=
name|dstr
expr_stmt|;
name|wdgt
operator|->
name|dstrlen
operator|=
name|maxlen
expr_stmt|;
block|}
end_function

begin_function
name|int
name|getdialogstr
parameter_list|(
name|wdgt
parameter_list|,
name|str
parameter_list|)
comment|/* 'str' must be long enough... */
name|char
name|str
index|[]
decl_stmt|;
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
if|if
condition|(
name|wdgt
operator|->
name|type
operator|!=
name|DIALOG
operator|||
name|wdgt
operator|->
name|dstr
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
name|wdgt
operator|->
name|dstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* THESE ROUTINES MANIPULATE THE TOGGLE WIDGETS */
end_comment

begin_function
name|void
name|toggle
parameter_list|(
name|wdgt
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
name|WIDGET
modifier|*
name|vwdgt
decl_stmt|;
name|int
name|av_indx
decl_stmt|;
if|if
condition|(
name|wdgt
operator|->
name|tvalues
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
name|wdgt
operator|==
name|getwidget
argument_list|(
name|currwidgets
argument_list|,
literal|'t'
argument_list|)
condition|)
block|{
name|typetoggled
operator|=
literal|1
expr_stmt|;
name|vwdgt
operator|=
name|getwidget
argument_list|(
name|currwidgets
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|filtvalue
index|[
name|wdgt
operator|->
name|tindx
index|]
argument_list|,
name|vwdgt
operator|->
name|dstr
argument_list|)
expr_stmt|;
name|av_indx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|av_typeindx
index|[
name|av_indx
index|]
operator|!=
name|wdgt
operator|->
name|tindx
operator|&&
name|av_typeindx
index|[
name|av_indx
index|]
operator|>=
literal|0
condition|)
name|av_indx
operator|++
expr_stmt|;
if|if
condition|(
name|av_typeindx
index|[
name|av_indx
index|]
operator|==
name|wdgt
operator|->
name|tindx
condition|)
name|av_indx
operator|++
expr_stmt|;
if|if
condition|(
name|av_typeindx
index|[
name|av_indx
index|]
operator|<
literal|0
condition|)
name|av_indx
operator|=
literal|0
expr_stmt|;
name|wdgt
operator|->
name|tindx
operator|=
name|av_typeindx
index|[
name|av_indx
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vwdgt
operator|->
name|dstr
argument_list|,
name|filtvalue
index|[
name|wdgt
operator|->
name|tindx
index|]
argument_list|)
expr_stmt|;
name|typeindx
operator|=
name|wdgt
operator|->
name|tindx
expr_stmt|;
name|printdialog
argument_list|(
name|vwdgt
argument_list|)
expr_stmt|;
block|}
name|printtoggle
argument_list|(
name|wdgt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|settogglstrs
parameter_list|(
name|wdgt
parameter_list|,
name|togglstrs
parameter_list|,
name|togglindx
parameter_list|)
name|int
name|togglindx
decl_stmt|;
name|char
modifier|*
modifier|*
name|togglstrs
decl_stmt|;
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
if|if
condition|(
name|wdgt
operator|->
name|type
operator|!=
name|TOGGLE
condition|)
return|return;
name|wdgt
operator|->
name|tvalues
operator|=
name|togglstrs
expr_stmt|;
name|wdgt
operator|->
name|tindx
operator|=
name|togglindx
expr_stmt|;
block|}
end_function

begin_function
name|int
name|settogglindx
parameter_list|(
name|wdgt
parameter_list|,
name|indx
parameter_list|)
name|int
name|indx
decl_stmt|;
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wdgt
operator|->
name|type
operator|!=
name|TOGGLE
operator|||
name|wdgt
operator|->
name|tvalues
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indx
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wdgt
operator|->
name|tvalues
index|[
name|i
index|]
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|indx
condition|)
comment|/* There ain't that many toggle strings */
return|return
operator|(
name|FALSE
operator|)
return|;
name|wdgt
operator|->
name|tindx
operator|=
name|indx
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gettogglindx
parameter_list|(
name|wdgt
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
block|{
if|if
condition|(
name|wdgt
operator|->
name|type
operator|!=
name|TOGGLE
operator|||
name|wdgt
operator|->
name|tvalues
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|wdgt
operator|->
name|tindx
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gettogglstr
parameter_list|(
name|wdgt
parameter_list|,
name|str
parameter_list|)
comment|/* 'str' must be long enough... */
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
name|char
name|str
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|wdgt
operator|->
name|type
operator|!=
name|TOGGLE
operator|||
name|wdgt
operator|->
name|tvalues
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
name|wdgt
operator|->
name|tvalues
index|[
name|wdgt
operator|->
name|tindx
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* THESE ROUTINES MANIPULATE THE LABEL WIDGETS */
end_comment

begin_function
name|void
name|setlabel
parameter_list|(
name|wdgt
parameter_list|,
name|label
parameter_list|)
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|wdgt
operator|->
name|label
operator|=
name|label
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getlabel
parameter_list|(
name|wdgt
parameter_list|,
name|label
parameter_list|)
comment|/* 'label' must be long enough... */
name|WIDGET
modifier|*
name|wdgt
decl_stmt|;
name|char
name|label
index|[]
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|label
argument_list|,
name|wdgt
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MISCELLANEOUS FUNCTIONS */
end_comment

begin_comment
comment|/* Try to locate the bottom of the last set of widgets displayed */
end_comment

begin_function
name|int
name|lowesty
parameter_list|()
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
specifier|register
name|WIDGET
modifier|*
name|wdgts
decl_stmt|;
if|if
condition|(
name|activelist
operator|.
name|count
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|wdgts
operator|=
name|activelist
operator|.
name|widgets
index|[
name|activelist
operator|.
name|count
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|wdgts
index|[
name|cnt
index|]
operator|.
name|type
operator|!=
name|FINISH
condition|)
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|wdgts
index|[
name|cnt
operator|-
literal|1
index|]
operator|.
name|y
operator|)
operator|+
name|WDGTHGHT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This satisfies the generalised printing structure */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|wprint
parameter_list|(
name|here
parameter_list|,
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|,
name|h
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
name|WINDOW
modifier|*
name|here
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|,
decl|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|g
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
end_function

begin_block
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|Text
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This can be called as a way for an application to print text */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|void
name|tprint
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|,
name|h
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|,
decl|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|g
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
end_function

begin_block
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|Text
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|xprint
parameter_list|(
name|fmt
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|Text
argument_list|,
literal|"%s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xprintint
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|a
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|wprintw
argument_list|(
name|Text
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cleartext
parameter_list|()
block|{
name|clearok
argument_list|(
name|Text
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wclear
argument_list|(
name|Text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Jump back to the interact function only on an interrupt */
end_comment

begin_function
name|void
name|jumpback
parameter_list|()
block|{
operator|(
name|void
operator|)
name|waddstr
argument_list|(
name|Text
argument_list|,
literal|"\n*** Interrupted ***\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is used as a declaration, when no function callback is required */
end_comment

begin_function
name|void
name|nullfn
parameter_list|()
block|{}
end_function

begin_comment
comment|/* This is used by widgets that just want to kill the current level */
end_comment

begin_function
name|void
name|quitfn
parameter_list|()
block|{
operator|(
name|void
operator|)
name|wclear
argument_list|(
name|Text
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wrefresh
argument_list|(
name|Text
argument_list|)
expr_stmt|;
name|killwidgets
argument_list|(
name|activelist
operator|.
name|widgets
index|[
name|activelist
operator|.
name|count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|endwidgets
parameter_list|()
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

