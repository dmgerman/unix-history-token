begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A 'C' version of the shellscript dishinit   * By Steve Titcombe  *  * Most of this has fixed calls to other functions, and will require going   * through again to strip out all unnecessary error trapping, etc.  * (Utterly Horrible Hack.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/others/quipu/uips/dish/RCS/quipurc.c,v 7.5 91/02/22 09:30:27 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"quipu/read.h"
end_include

begin_include
include|#
directive|include
file|"quipu/sequence.h"
end_include

begin_include
include|#
directive|include
file|"quipu/name.h"
end_include

begin_include
include|#
directive|include
file|"quipu/bind.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dsp.h"
end_include

begin_include
include|#
directive|include
file|"quipu/ds_error.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dua.h"
end_include

begin_include
include|#
directive|include
file|"quipu/ds_search.h"
end_include

begin_include
include|#
directive|include
file|"quipu/list.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/modify.h"
end_include

begin_define
define|#
directive|define
name|ORG_PERSON
value|"thornPerson& quipuObject"
end_define

begin_comment
comment|/* this should probably go elsewhere !!! */
end_comment

begin_decl_stmt
name|LLog
modifier|*
name|log_dua
decl_stmt|;
end_decl_stmt

begin_function_decl
name|DN
name|sequence_dn
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|DN
name|dn
decl_stmt|,
name|moddn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DN
name|fixed_pos
init|=
name|NULLDN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PS
name|opt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PS
name|rps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PS
name|fileps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp_quipurc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp_draft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp_tailor
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Filter
name|get_filter
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|entrymod
modifier|*
name|ems_append
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|entrymod
modifier|*
name|modify_avs
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ds_bind_arg
name|bindarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ds_bind_arg
name|bindresult
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ds_bind_error
name|binderr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ds_read_arg
name|read_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|DSError
name|read_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ds_read_result
name|read_result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ds_modifyentry_arg
name|mod_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|DSError
name|mod_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|DSError
name|search_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ds_search_result
name|search_result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ds_search_arg
name|search_arg
init|=
block|{
name|default_common_args
block|,
name|NULLDN
block|,
name|SRA_ONELEVEL
block|,
name|NULLFILTER
block|,
comment|/* filter */
name|FALSE
block|,
block|{
comment|/* eis */
name|FALSE
block|,
name|NULLATTR
block|,
name|EIS_ATTRIBUTESANDVALUES
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dua_sequence
modifier|*
name|current_sequence
init|=
name|NULL_DS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|entrymod
modifier|*
name|emnew
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AV_Sequence
name|avst
init|=
name|NULLAV
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Attr_Sequence
name|as_flag
init|=
name|NULLATTR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Attr_Sequence
name|trail
init|=
name|NULLATTR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Attr_Sequence
name|eptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Attr_Sequence
name|temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Attr_Sequence
name|as
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AttributeType
name|at
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TURBO_DISK
end_ifdef

begin_function_decl
specifier|extern
name|Attr_Sequence
name|fget_attributes
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|Attr_Sequence
name|get_attributes
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|TidyString
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Entry
name|current_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Entry
name|entry_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Manager
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Password
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Local
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|filterstring
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|struct
name|passwd
modifier|*
name|pw_entry
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|int
name|um
decl_stmt|;
name|char
name|pass1
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
name|pass2
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
name|Read_in_Stuff
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|vecptr
decl_stmt|;
name|char
modifier|*
name|tmpdraft
decl_stmt|;
name|char
name|home_dir
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|part1
decl_stmt|,
modifier|*
name|part2
decl_stmt|;
name|char
name|quipurc_file
index|[
literal|100
index|]
decl_stmt|;
name|char
name|tailor_file
index|[
literal|100
index|]
decl_stmt|;
name|char
name|user_name
index|[
literal|9
index|]
decl_stmt|;
name|char
modifier|*
name|localptr
init|=
name|Local
decl_stmt|;
name|char
name|print_format
init|=
name|EDBOUT
decl_stmt|;
name|EntryInfo
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|CommonArgs
name|ca
init|=
name|default_common_args
decl_stmt|;
name|vecptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|vecptr
index|[
literal|0
index|]
operator|=
name|malloc
argument_list|(
name|LINESIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vecptr
index|[
literal|0
index|]
argument_list|,
literal|"showentry"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pass1
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pass2
argument_list|,
literal|"y"
argument_list|)
expr_stmt|;
name|tmpdraft
operator|=
name|malloc
argument_list|(
name|LINESIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpdraft
argument_list|,
literal|"/tmp/dish-"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opt
operator|=
name|ps_alloc
argument_list|(
name|std_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
name|fatal
argument_list|(
operator|-
literal|62
argument_list|,
literal|"ps_alloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|std_setup
argument_list|(
name|opt
argument_list|,
name|stderr
argument_list|)
operator|==
name|NOTOK
condition|)
name|fatal
argument_list|(
operator|-
literal|63
argument_list|,
literal|"std_setup failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rps
operator|=
name|ps_alloc
argument_list|(
name|std_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
name|fatal
argument_list|(
operator|-
literal|64
argument_list|,
literal|"ps_alloc 2 failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|std_setup
argument_list|(
name|rps
argument_list|,
name|stdout
argument_list|)
operator|==
name|NOTOK
condition|)
name|fatal
argument_list|(
operator|-
literal|65
argument_list|,
literal|"std_setup 2 failed"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|filterstring
argument_list|,
literal|"userid="
argument_list|)
expr_stmt|;
comment|/* Sort out files, userids etc. */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pw_entry
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"Who are you? (no name for your uid number)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|user_name
argument_list|,
name|pw_entry
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmpdraft
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"No home directory?!!"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|home_dir
argument_list|,
name|pw_entry
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|home_dir
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|quipurc_file
argument_list|,
name|home_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|quipurc_file
argument_list|,
literal|"/.quipurc"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tailor_file
argument_list|,
name|isodefile
argument_list|(
literal|"dishinit"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Manager
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|Password
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|Local
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|stat
argument_list|(
name|tailor_file
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|seteuid
argument_list|(
name|buf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
comment|/* set effective to enable */
comment|/* us to read protected file */
if|if
condition|(
operator|(
name|fp_tailor
operator|=
name|fopen
argument_list|(
name|tailor_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ps_print
argument_list|(
name|rps
argument_list|,
literal|"Can't open Tailor File. Abort.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|Read_in_Stuff
argument_list|,
name|LINESIZE
argument_list|,
name|fp_tailor
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Read_in_Stuff
argument_list|,
literal|"##Anything after this line is copied into the users ~/.quipurc file\n"
argument_list|)
condition|)
block|{
break|break ;
block|}
name|p
operator|=
name|SkipSpace
argument_list|(
name|Read_in_Stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'#'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
continue|continue;
comment|/* ignore comments and blanks */
name|part1
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|part2
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"Seperator missing '%s'. Ignoring..\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|part2
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|part2
operator|=
name|TidyString
argument_list|(
name|part2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|part1
argument_list|,
literal|"manager"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Manager
argument_list|,
name|part2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
name|part1
argument_list|,
literal|"password"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Password
argument_list|,
name|part2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
name|part1
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Local
argument_list|,
name|part2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"Error in tailor. What's a %s?\n"
argument_list|,
name|part1
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
comment|/* Restore Userid to original user. */
comment|/* create ~/.quipurc file. NB this does eradicate anything in there.  * 			   (Theoretically nothing.)   */
if|if
condition|(
name|Manager
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|ps_print
argument_list|(
name|rps
argument_list|,
literal|"Can't find out the managers name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Password
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|ps_print
argument_list|(
name|rps
argument_list|,
literal|"Can't find out the managers password\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Local
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|ps_print
argument_list|(
name|rps
argument_list|,
literal|"Can't find out where to search\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|um
operator|=
name|umask
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp_quipurc
operator|=
name|fopen
argument_list|(
name|quipurc_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"Can't open ~/.quipurc. Aborting..\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fileps
operator|=
name|ps_alloc
argument_list|(
name|std_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
block|{
name|fatal
argument_list|(
operator|-
literal|66
argument_list|,
literal|"ps_alloc 2 failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|std_setup
argument_list|(
name|fileps
argument_list|,
name|fp_quipurc
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|fatal
argument_list|(
operator|-
literal|67
argument_list|,
literal|"std_setup 2 failed"
argument_list|)
expr_stmt|;
block|}
comment|/* Sorting out the bind section */
name|quipu_syntaxes
argument_list|()
expr_stmt|;
comment|/* set up the needed function pointers */
name|dsap_init
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|vecptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bindarg
operator|.
name|dba_passwd
argument_list|,
name|Password
argument_list|)
expr_stmt|;
name|bindarg
operator|.
name|dba_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|bindarg
operator|.
name|dba_passwd_len
operator|=
name|strlen
argument_list|(
name|bindarg
operator|.
name|dba_passwd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bindarg
operator|.
name|dba_dn
operator|=
name|str2dn
argument_list|(
name|Manager
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"Invalid Manager name %s (???!)\n"
argument_list|,
name|Manager
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds_bind
argument_list|(
operator|&
name|bindarg
argument_list|,
operator|&
name|binderr
argument_list|,
operator|&
name|bindresult
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"Can't bind as the manager.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Hopefully, should be successfully bound */
comment|/*  * We now call the search stuff with the right bits, to see if we can get a  * match of uid='user_name'. Once there, we echo lots of information from  * their entry out to the .quipurc file.  * Hopefully there should only be one match. This assumes that ALL dir info  * up to date, and that SG do not allow multiple users with the same login.  */
comment|/* set up the appropriate structures and defaults. */
name|search_arg
operator|.
name|sra_common
operator|=
name|ca
expr_stmt|;
comment|/* struct copy */
name|search_arg
operator|.
name|sra_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_sizelimit
operator|=
literal|2
expr_stmt|;
name|search_arg
operator|.
name|sra_eis
operator|.
name|eis_allattributes
operator|=
name|FALSE
expr_stmt|;
name|search_arg
operator|.
name|sra_searchaliases
operator|=
name|FALSE
expr_stmt|;
name|search_arg
operator|.
name|sra_subset
operator|=
name|SRA_ONELEVEL
expr_stmt|;
name|search_arg
operator|.
name|sra_eis
operator|.
name|eis_infotypes
operator|=
name|EIS_ATTRIBUTESANDVALUES
expr_stmt|;
name|search_arg
operator|.
name|sra_eis
operator|.
name|eis_select
operator|=
name|NULLATTR
expr_stmt|;
name|search_arg
operator|.
name|sra_eis
operator|.
name|eis_allattributes
operator|=
name|TRUE
expr_stmt|;
name|search_arg
operator|.
name|sra_filter
operator|=
name|filter_alloc
argument_list|()
expr_stmt|;
comment|/* Default filter. */
name|search_arg
operator|.
name|sra_filter
operator|->
name|flt_next
operator|=
name|NULLFILTER
expr_stmt|;
name|search_arg
operator|.
name|sra_filter
operator|->
name|flt_type
operator|=
name|FILTER_ITEM
expr_stmt|;
name|search_arg
operator|.
name|sra_filter
operator|->
name|FUFILT
operator|=
name|NULLFILTER
expr_stmt|;
if|if
condition|(
operator|*
name|localptr
operator|==
literal|'@'
condition|)
block|{
name|localptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|search_arg
operator|.
name|sra_baseobject
operator|=
name|str2dn
argument_list|(
name|localptr
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"Invalid sequence in username %s.\n"
argument_list|,
name|localptr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|filterstring
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
name|search_arg
operator|.
name|sra_filter
operator|->
name|flt_un
operator|.
name|flt_un_item
operator|.
name|fi_type
operator|=
name|FILTERITEM_EQUALITY
expr_stmt|;
if|if
condition|(
operator|(
name|search_arg
operator|.
name|sra_filter
operator|->
name|flt_un
operator|.
name|flt_un_item
operator|.
name|fi_un
operator|.
name|fi_un_ava
operator|.
name|ava_type
operator|=
name|AttrT_new
argument_list|(
literal|"userid"
argument_list|)
operator|)
operator|==
name|NULLAttrT
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"Oops, userid is not a valid attr type. ABORT!!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|search_arg
operator|.
name|sra_filter
operator|->
name|flt_un
operator|.
name|flt_un_item
operator|.
name|fi_un
operator|.
name|fi_un_ava
operator|.
name|ava_value
operator|=
name|str2AttrV
argument_list|(
name|user_name
argument_list|,
name|search_arg
operator|.
name|sra_filter
operator|->
name|flt_un
operator|.
name|flt_un_item
operator|.
name|fi_un
operator|.
name|fi_un_ava
operator|.
name|ava_type
operator|->
name|oa_syntax
argument_list|)
operator|)
operator|==
name|NULLAttrV
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"%s is not a valid attribute value.\n"
argument_list|,
name|user_name
argument_list|)
expr_stmt|;
block|}
comment|/* call search */
comment|/* We now ought to be in the right place, and with the search stuff set,  * ready to call search, and receive one (or no) entry back, which then   * gets processed accordingly.  */
if|if
condition|(
name|ds_search
argument_list|(
operator|&
name|search_arg
argument_list|,
operator|&
name|search_error
argument_list|,
operator|&
name|search_result
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"Search failed...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* This is not the same as coming back with */
comment|/* message "search failed to find anything. */
block|}
comment|/* If the user does not exist in the DIT, print out the limited .quipurc  * and the warning message, and allow the user to play DISH.  */
if|if
condition|(
name|search_result
operator|.
name|CSR_entries
operator|==
name|NULLENTRYINFO
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"Unfortunately, you seem to have no entry in\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"the directory. Contact '%s' who should be able to help.\n"
argument_list|,
name|Manager
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"In the mean time, you can read, but not write.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|search_result
operator|.
name|CSR_entries
expr_stmt|;
name|dn
operator|=
name|dn_cpy
argument_list|(
name|ptr
operator|->
name|ent_dn
argument_list|)
expr_stmt|;
comment|/* Essence of move user_name. */
comment|/* collect the info and put it into current_entry */
comment|/* Set up the desired attribute type to be read*/
comment|/* from read.c */
if|if
condition|(
operator|(
name|at
operator|=
name|AttrT_new
argument_list|(
literal|"userPassword"
argument_list|)
operator|)
operator|!=
name|NULLAttrT
condition|)
block|{
name|as_flag
operator|=
name|as_merge
argument_list|(
name|as_flag
argument_list|,
name|as_comp_new
argument_list|(
name|AttrT_cpy
argument_list|(
name|at
argument_list|)
argument_list|,
name|NULLAV
argument_list|,
name|NULLACL_INFO
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"Oops, Serious error. unknown attribute type 'userPassword'.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|current_entry
operator|=
name|local_find_entry
argument_list|(
name|dn
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|read_arg
operator|.
name|rda_common
operator|=
name|ca
expr_stmt|;
comment|/* struct copy */
name|read_arg
operator|.
name|rda_object
operator|=
name|dn
expr_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_infotypes
operator|=
name|EIS_ATTRIBUTESANDVALUES
expr_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_allattributes
operator|=
name|TRUE
expr_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_select
operator|=
name|NULLATTR
expr_stmt|;
if|if
condition|(
name|ds_read
argument_list|(
operator|&
name|read_arg
argument_list|,
operator|&
name|read_error
argument_list|,
operator|&
name|read_result
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"We even seem to be having problems reading\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"an entry we searched and found!! HELP!!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read_result
operator|.
name|rdr_entry
operator|.
name|ent_attr
operator|==
name|NULLATTR
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"No attributes present. Even though\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"we found you by userid attribute!!! HELP!!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cache_entry
argument_list|(
operator|&
operator|(
name|read_result
operator|.
name|rdr_entry
operator|)
argument_list|,
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_allattributes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|current_entry
operator|=
name|local_find_entry
argument_list|(
name|dn
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"We still have nothing.Even after reading? Abort.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ps_printf
argument_list|(
name|fileps
argument_list|,
literal|"username: "
argument_list|)
expr_stmt|;
name|dn_print
argument_list|(
name|fileps
argument_list|,
name|dn
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|fileps
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|fileps
argument_list|,
literal|"me: "
argument_list|)
expr_stmt|;
name|dn_print
argument_list|(
name|fileps
argument_list|,
name|dn
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|fileps
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* now showattribute -nokey to display it. */
name|ps_printf
argument_list|(
name|fileps
argument_list|,
literal|"password: "
argument_list|)
expr_stmt|;
for|for
control|(
name|eptr
operator|=
name|current_entry
operator|->
name|e_attributes
init|;
name|eptr
operator|!=
name|NULLATTR
condition|;
name|eptr
operator|=
name|eptr
operator|->
name|attr_link
control|)
block|{
comment|/* Tiptoe through the list of types until one matches, and then print value. */
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|eptr
operator|->
name|attr_type
argument_list|,
name|at
argument_list|)
operator|==
literal|0
condition|)
block|{
name|avs_print
argument_list|(
name|fileps
argument_list|,
name|eptr
operator|->
name|attr_value
argument_list|,
name|print_format
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|eptr
operator|==
name|NULLATTR
condition|)
block|{
while|while
condition|(
name|strcmp
argument_list|(
name|pass1
argument_list|,
name|pass2
argument_list|)
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"You need a password...\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pass1
argument_list|,
name|getpassword
argument_list|(
literal|"Enter Password: "
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pass2
argument_list|,
name|getpassword
argument_list|(
literal|"Re-enter password: "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pass1
argument_list|,
name|pass2
argument_list|)
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"\nMismatch - Try again.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|ps_printf
argument_list|(
name|fileps
argument_list|,
literal|"%s\n"
argument_list|,
name|pass1
argument_list|)
expr_stmt|;
name|um
operator|=
name|umask
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp_draft
operator|=
name|fopen
argument_list|(
name|tmpdraft
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ps_print
argument_list|(
name|rps
argument_list|,
literal|"Can't open draft file... Abort.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp_draft
argument_list|,
literal|"UserPassword = %s\n"
argument_list|,
name|pass1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp_draft
argument_list|,
literal|"acl = self # write # attributes # acl $ userPassword\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp_draft
argument_list|,
literal|"acl = others # compare # attributes # acl $ userPassword\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp_draft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp_draft
operator|=
name|fopen
argument_list|(
name|tmpdraft
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"Can't open draft entry %s\n"
argument_list|,
name|tmpdraft
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|entry_ptr
operator|=
name|get_default_entry
argument_list|(
name|NULLENTRY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_DISK
name|entry_ptr
operator|->
name|e_attributes
operator|=
name|fget_attributes
argument_list|(
name|fp_draft
argument_list|)
expr_stmt|;
else|#
directive|else
name|entry_ptr
operator|->
name|e_attributes
operator|=
name|get_attributes
argument_list|(
name|fp_draft
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp_draft
argument_list|)
expr_stmt|;
name|mod_arg
operator|.
name|mea_common
operator|=
name|ca
expr_stmt|;
comment|/* struct copy */
name|mod_arg
operator|.
name|mea_object
operator|=
name|dn
expr_stmt|;
for|for
control|(
name|moddn
operator|=
name|dn
init|;
name|moddn
operator|->
name|dn_parent
operator|!=
name|NULLDN
condition|;
name|moddn
operator|=
name|moddn
operator|->
name|dn_parent
control|)
empty_stmt|;
name|entry_ptr
operator|->
name|e_name
operator|=
name|rdn_cpy
argument_list|(
name|moddn
operator|->
name|dn_rdn
argument_list|)
expr_stmt|;
comment|/* add rdn as attribute */
name|avst
operator|=
name|avs_comp_new
argument_list|(
name|AttrV_cpy
argument_list|(
operator|&
name|entry_ptr
operator|->
name|e_name
operator|->
name|rdn_av
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|as_comp_new
argument_list|(
name|AttrT_cpy
argument_list|(
name|entry_ptr
operator|->
name|e_name
operator|->
name|rdn_at
argument_list|)
argument_list|,
name|avst
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|entry_ptr
operator|->
name|e_attributes
operator|=
name|as_merge
argument_list|(
name|entry_ptr
operator|->
name|e_attributes
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|as
operator|=
name|entry_ptr
operator|->
name|e_attributes
init|;
name|as
operator|!=
name|NULLATTR
condition|;
name|as
operator|=
name|as
operator|->
name|attr_link
control|)
block|{
name|emnew
operator|=
name|NULLMOD
expr_stmt|;
name|trail
operator|=
name|as
operator|->
name|attr_link
expr_stmt|;
name|as
operator|->
name|attr_link
operator|=
name|NULLATTR
expr_stmt|;
name|temp
operator|=
name|current_entry
operator|->
name|e_attributes
expr_stmt|;
for|for
control|(
init|;
name|temp
operator|!=
name|NULLATTR
condition|;
name|temp
operator|=
name|temp
operator|->
name|attr_link
control|)
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|as
operator|->
name|attr_type
argument_list|,
name|temp
operator|->
name|attr_type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it - does it need changing ? */
if|if
condition|(
name|avs_cmp
argument_list|(
name|as
operator|->
name|attr_value
argument_list|,
name|temp
operator|->
name|attr_value
argument_list|)
operator|!=
literal|0
condition|)
name|emnew
operator|=
name|modify_avs
argument_list|(
name|as
operator|->
name|attr_value
argument_list|,
name|temp
operator|->
name|attr_value
argument_list|,
name|as
operator|->
name|attr_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|temp
operator|==
name|NULLATTR
condition|)
block|{
name|emnew
operator|=
name|em_alloc
argument_list|()
expr_stmt|;
name|emnew
operator|->
name|em_type
operator|=
name|EM_ADDATTRIBUTE
expr_stmt|;
name|emnew
operator|->
name|em_what
operator|=
name|as_cpy
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|emnew
operator|->
name|em_next
operator|=
name|NULLMOD
expr_stmt|;
block|}
if|if
condition|(
name|emnew
operator|!=
name|NULLMOD
condition|)
block|{
name|mod_arg
operator|.
name|mea_changes
operator|=
name|ems_append
argument_list|(
name|mod_arg
operator|.
name|mea_changes
argument_list|,
name|emnew
argument_list|)
expr_stmt|;
block|}
name|as
operator|->
name|attr_link
operator|=
name|trail
expr_stmt|;
block|}
while|while
condition|(
name|ds_modifyentry
argument_list|(
operator|&
name|mod_arg
argument_list|,
operator|&
name|mod_error
argument_list|)
operator|!=
name|DS_OK
condition|)
block|{
if|if
condition|(
name|dish_error
argument_list|(
name|opt
argument_list|,
operator|&
name|mod_error
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ps_printf
argument_list|(
name|rps
argument_list|,
literal|"We have a dish error. Bye.\n"
argument_list|)
expr_stmt|;
name|entry_free
argument_list|(
name|entry_ptr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mod_arg
operator|.
name|mea_object
operator|=
name|mod_error
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_name
expr_stmt|;
block|}
name|ps_print
argument_list|(
name|rps
argument_list|,
literal|"Modified "
argument_list|)
expr_stmt|;
name|dn_print
argument_list|(
name|rps
argument_list|,
name|dn
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|rps
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|delete_cache
argument_list|(
name|dn
argument_list|)
expr_stmt|;
comment|/* re-cache when next read */
name|entry_free
argument_list|(
name|entry_ptr
argument_list|)
expr_stmt|;
name|ems_part_free
argument_list|(
name|mod_arg
operator|.
name|mea_changes
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|fgets
argument_list|(
name|Read_in_Stuff
argument_list|,
name|LINESIZE
argument_list|,
name|fp_tailor
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|Read_in_Stuff
argument_list|,
name|fp_quipurc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp_quipurc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp_tailor
argument_list|)
expr_stmt|;
comment|/*	(void) fprintf(fp_quipurc, "dsap: local_dit \"%s\"\n", Local) ; 	(void) fprintf(fp_quipurc, "notype: acl\n") ; 	(void) fprintf(fp_quipurc, "notype: treestructure\n") ; 	(void) fprintf(fp_quipurc, "notype: masterdsa\n") ; 	(void) fprintf(fp_quipurc, "notype: slavedsa\n") ; 	(void) fprintf(fp_quipurc, "notype: objectclass\n") ; 	(void) fprintf(fp_quipurc, "cache_time: 30\n") ; 	(void) fprintf(fp_quipurc, "connect_time: 2\n") ;  */
operator|(
name|void
operator|)
name|ds_unbind
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpdraft
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|advise
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|set_sequence
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|unset_sequence
parameter_list|()
block|{ }
end_function

begin_macro
name|dish_error
argument_list|(
argument|ps
argument_list|,
argument|error
argument_list|)
end_macro

begin_decl_stmt
name|PS
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|DSError
modifier|*
name|error
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|error
operator|->
name|dse_type
operator|==
name|DSE_ABANDONED
condition|)
block|{
name|ps_printf
argument_list|(
name|ps
argument_list|,
literal|"(DAP call interrupted - abandon successful)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|->
name|dse_type
operator|==
name|DSE_ABANDON_FAILED
condition|)
block|{
name|ps_printf
argument_list|(
name|ps
argument_list|,
literal|"(DAP call interrupted - abandon unsuccessful)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|->
name|dse_type
operator|==
name|DSE_INTRERROR
condition|)
block|{
name|ps_printf
argument_list|(
name|ps
argument_list|,
literal|"(DAP call interrupted)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ds_error
argument_list|(
name|ps
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|DN
name|sequence_dn
parameter_list|(
name|y
parameter_list|)
name|int
name|y
decl_stmt|;
block|{
name|struct
name|dua_seq_entry
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|x
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|current_sequence
operator|==
name|NULL_DS
condition|)
return|return
operator|(
name|NULLDN
operator|)
return|;
for|for
control|(
name|ptr
operator|=
name|current_sequence
operator|->
name|ds_data
init|;
operator|(
name|ptr
operator|!=
name|NULL_DE
operator|)
operator|&&
operator|(
name|x
operator|<
name|y
operator|)
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|de_next
operator|,
name|x
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL_DE
condition|)
return|return
operator|(
name|NULLDN
operator|)
return|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
operator|(
name|ptr
operator|->
name|de_name
operator|)
return|;
return|return
operator|(
name|NULLDN
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|entrymod
modifier|*
name|ems_append
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|entrymod
modifier|*
name|a
decl_stmt|;
name|struct
name|entrymod
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|entrymod
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|a
operator|)
operator|==
name|NULLMOD
condition|)
return|return
name|b
return|;
for|for
control|(
init|;
name|ptr
operator|->
name|em_next
operator|!=
name|NULLMOD
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|em_next
control|)
empty_stmt|;
name|ptr
operator|->
name|em_next
operator|=
name|b
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|struct
name|entrymod
modifier|*
name|modify_avs
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|ent_mod_at
parameter_list|)
name|AV_Sequence
name|a
decl_stmt|;
name|AV_Sequence
name|b
decl_stmt|;
name|AttributeType
name|ent_mod_at
decl_stmt|;
block|{
name|AV_Sequence
name|x
decl_stmt|;
name|AV_Sequence
name|y
decl_stmt|;
name|struct
name|entrymod
modifier|*
name|em
init|=
name|NULLMOD
decl_stmt|,
modifier|*
name|em_new
decl_stmt|;
name|int
name|removed_all
init|=
name|TRUE
decl_stmt|;
for|for
control|(
name|x
operator|=
name|b
init|;
name|x
operator|!=
name|NULLAV
condition|;
name|x
operator|=
name|x
operator|->
name|avseq_next
control|)
block|{
name|em_new
operator|=
name|NULLMOD
expr_stmt|;
for|for
control|(
name|y
operator|=
name|a
init|;
name|y
operator|!=
name|NULLAV
condition|;
name|y
operator|=
name|y
operator|->
name|avseq_next
control|)
if|if
condition|(
name|AttrV_cmp
argument_list|(
operator|&
name|x
operator|->
name|avseq_av
argument_list|,
operator|&
name|y
operator|->
name|avseq_av
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|y
operator|==
name|NULLAV
condition|)
block|{
name|em_new
operator|=
name|em_alloc
argument_list|()
expr_stmt|;
name|em_new
operator|->
name|em_type
operator|=
name|EM_REMOVEVALUES
expr_stmt|;
name|em_new
operator|->
name|em_what
operator|=
name|as_comp_new
argument_list|(
name|ent_mod_at
argument_list|,
name|avs_comp_new
argument_list|(
operator|&
name|x
operator|->
name|avseq_av
argument_list|)
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|em_new
operator|->
name|em_next
operator|=
name|NULLMOD
expr_stmt|;
block|}
else|else
name|removed_all
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|em_new
operator|!=
name|NULLMOD
condition|)
name|em
operator|=
name|ems_append
argument_list|(
name|em
argument_list|,
name|em_new
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removed_all
condition|)
block|{
name|ems_part_free
argument_list|(
name|em
argument_list|)
expr_stmt|;
name|em_new
operator|=
name|em_alloc
argument_list|()
expr_stmt|;
name|em_new
operator|->
name|em_type
operator|=
name|EM_REMOVEATTRIBUTE
expr_stmt|;
name|em_new
operator|->
name|em_what
operator|=
name|as_comp_new
argument_list|(
name|ent_mod_at
argument_list|,
name|b
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|em_new
operator|->
name|em_next
operator|=
name|em_alloc
argument_list|()
expr_stmt|;
name|em_new
operator|->
name|em_next
operator|->
name|em_type
operator|=
name|EM_ADDATTRIBUTE
expr_stmt|;
name|em_new
operator|->
name|em_next
operator|->
name|em_what
operator|=
name|as_comp_new
argument_list|(
name|ent_mod_at
argument_list|,
name|avs_cpy
argument_list|(
name|a
argument_list|)
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|em_new
operator|->
name|em_next
operator|->
name|em_next
operator|=
name|NULLMOD
expr_stmt|;
return|return
operator|(
name|em_new
operator|)
return|;
block|}
for|for
control|(
name|x
operator|=
name|a
init|;
name|x
operator|!=
name|NULLAV
condition|;
name|x
operator|=
name|x
operator|->
name|avseq_next
control|)
block|{
name|em_new
operator|=
name|NULLMOD
expr_stmt|;
for|for
control|(
name|y
operator|=
name|b
init|;
name|y
operator|!=
name|NULLAV
condition|;
name|y
operator|=
name|y
operator|->
name|avseq_next
control|)
if|if
condition|(
name|AttrV_cmp
argument_list|(
operator|&
name|x
operator|->
name|avseq_av
argument_list|,
operator|&
name|y
operator|->
name|avseq_av
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|y
operator|==
name|NULLAV
condition|)
block|{
name|em_new
operator|=
name|em_alloc
argument_list|()
expr_stmt|;
name|em_new
operator|->
name|em_type
operator|=
name|EM_ADDVALUES
expr_stmt|;
name|em_new
operator|->
name|em_what
operator|=
name|as_comp_new
argument_list|(
name|ent_mod_at
argument_list|,
name|avs_comp_new
argument_list|(
operator|&
name|x
operator|->
name|avseq_av
argument_list|)
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|em_new
operator|->
name|em_next
operator|=
name|NULLMOD
expr_stmt|;
block|}
if|if
condition|(
name|em_new
operator|!=
name|NULLMOD
condition|)
name|em
operator|=
name|ems_append
argument_list|(
name|em
argument_list|,
name|em_new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|em
operator|)
return|;
block|}
end_function

begin_macro
name|ems_part_free
argument_list|(
argument|emp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|entrymod
modifier|*
name|emp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|emp
operator|==
name|NULLMOD
condition|)
return|return;
name|ems_part_free
argument_list|(
name|emp
operator|->
name|em_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|emp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

