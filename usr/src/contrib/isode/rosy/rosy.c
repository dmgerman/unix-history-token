begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rosy.c - RO stub-generator (yacc-based) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/rosy/RCS/rosy.c,v 7.5 91/02/22 09:41:47 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/rosy/RCS/rosy.c,v 7.5 91/02/22 09:41:47 mrose Interim $  *  *  * $Log:	rosy.c,v $  * Revision 7.5  91/02/22  09:41:47  mrose  * Interim 6.8  *   * Revision 7.4  90/11/20  15:27:57  mrose  * update  *   * Revision 7.3  90/07/01  21:06:20  mrose  * pepsy  *   * Revision 7.2  90/01/27  10:27:17  mrose  * touch-up  *   * Revision 7.1  90/01/11  18:37:50  mrose  * real-sync  *   * Revision 7.0  89/11/23  22:21:50  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|pepyversion
value|rosyversion
end_define

begin_include
include|#
directive|include
file|"rosy-defs.h"
end_include

begin_include
include|#
directive|include
file|"../pepsy/pass2.h"
end_include

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
name|int
name|Cflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rosy */
end_comment

begin_decl_stmt
name|int
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pepy compat... */
end_comment

begin_decl_stmt
name|int
name|Pepsyflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pepsy compatability */
end_comment

begin_decl_stmt
name|int
name|Defsflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Produce #define function names for Pepsy */
end_comment

begin_decl_stmt
name|int
name|doexternals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linepos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rosydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bflag
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|eval
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mymodule
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mymodulename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mymodaux
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|oplistorig
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOPS
value|128
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opvp
index|[
name|NOPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|opvc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OID
name|mymoduleid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yysection
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencpref
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecpref
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfpref
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencdflt
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecdflt
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfdflt
init|=
literal|"none"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|yymode
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|classes
index|[]
init|=
block|{
literal|"UNIVERSAL "
block|,
literal|"APPLICATION "
block|,
literal|""
block|,
literal|"PRIVATE "
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|autogen
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sysin
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysout
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysdef
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|systbl
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|systub
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fdef
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ftbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fstb
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|symlist
block|{
name|char
modifier|*
name|sy_encpref
decl_stmt|;
name|char
modifier|*
name|sy_decpref
decl_stmt|;
name|char
modifier|*
name|sy_prfpref
decl_stmt|;
name|char
modifier|*
name|sy_module
decl_stmt|;
name|char
modifier|*
name|sy_name
decl_stmt|;
union|union
block|{
name|YO
name|sy_un_op
decl_stmt|;
name|YE
name|sy_un_err
decl_stmt|;
name|YP
name|sy_un_type
decl_stmt|;
block|}
name|sy_un
union|;
define|#
directive|define
name|sy_op
value|sy_un.sy_un_op
define|#
directive|define
name|sy_err
value|sy_un.sy_un_err
define|#
directive|define
name|sy_type
value|sy_un.sy_un_type
name|struct
name|symlist
modifier|*
name|sy_next
decl_stmt|;
block|}
name|symlist
operator|,
typedef|*
name|SY
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLSY
value|((SY) 0)
end_define

begin_decl_stmt
specifier|static
name|SY
name|myoperations
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|erroff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SY
name|myerrors
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SY
name|mytypes
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|modsym
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|cmodsym
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|csymmod
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|SY
name|new_symbol
argument_list|()
decl_stmt|,
name|add_symbol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|YE
name|lookup_err
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|YP
name|lookup_type
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|MAIN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|rosyversion
argument_list|)
expr_stmt|;
name|sysout
index|[
literal|0
index|]
operator|=
name|sysdef
index|[
literal|0
index|]
operator|=
name|systbl
index|[
literal|0
index|]
operator|=
name|systub
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|cp
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-pepsy"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Pepsyflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-defs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Defsflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-m"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sysout
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many output files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|)
condition|)
goto|goto
name|usage
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sysout
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-b"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many prefixes\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|bflag
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|*
name|bflag
operator|==
literal|'-'
condition|)
goto|goto
name|usage
goto|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-T"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mymodulename
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many table names\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|mymodulename
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|*
name|mymodulename
operator|==
literal|'-'
condition|)
goto|goto
name|usage
goto|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-O"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
goto|goto
name|usage
goto|;
if|if
condition|(
name|oplistorig
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|oplistorig
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oplistorig
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sysin
condition|)
block|{
name|usage
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: rosy [-pepsy] [-d] [-o module.py] [-s] module.ry\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
name|NULL
condition|)
goto|goto
name|usage
goto|;
name|sysin
operator|=
literal|""
expr_stmt|;
block|}
name|sysin
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|sysout
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
condition|)
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
operator|*
name|sp
operator|==
name|NULL
condition|)
name|sp
operator|=
name|cp
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|cp
operator|=
name|sp
argument_list|)
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|sp
operator|>
name|cp
operator|&&
name|strcmp
argument_list|(
name|sp
argument_list|,
literal|".ry"
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysout
argument_list|,
literal|"%.*s.py"
argument_list|,
name|sp
operator|-
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysout
argument_list|,
literal|"%s.py"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rosydebug
operator|=
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"ROSYTEST"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|0
condition|)
block|{
case|case
literal|2
case|:
name|yydebug
operator|++
expr_stmt|;
comment|/* fall */
case|case
literal|1
case|:
name|sflag
operator|++
expr_stmt|;
comment|/*   .. */
case|case
literal|0
case|:
break|break;
block|}
if|if
condition|(
name|sysin
operator|==
name|NULLCP
condition|)
name|sysin
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|sysin
operator|&&
name|freopen
argument_list|(
name|sysin
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to read "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysin
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sysout
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|sysout
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
operator|&&
name|freopen
argument_list|(
name|sysout
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to write "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|rosyversion
argument_list|,
literal|')'
argument_list|)
condition|)
for|for
control|(
name|cp
operator|++
init|;
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|rosyversion
operator|+
name|strlen
argument_list|(
name|rosyversion
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|autogen
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|rosyversion
argument_list|,
name|cp
operator|-
name|rosyversion
argument_list|,
name|rosyversion
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- automatically generated by %s, do not edit!\n\n"
argument_list|,
name|autogen
argument_list|)
expr_stmt|;
name|initoidtbl
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|yyparse
argument_list|()
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_expr_stmt
name|yyerror
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|yyerror_aux
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysdef
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysdef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|systbl
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|systbl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|systub
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|systub
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|warning
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buffer2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer2
argument_list|,
literal|"Warning: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|yyerror_aux
argument_list|(
name|buffer2
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|warning
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warning
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|yyerror_aux
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eval
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s: "
argument_list|,
name|yymode
argument_list|,
name|eval
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line %d: "
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eval
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last token read was \"%s\"\n"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|myyerror
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|myyerror
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|myyerror
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
specifier|static
name|pyyerror
argument_list|(
argument|va_alist
argument_list|)
name|va_dcl
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
block|;
specifier|register
name|YP
name|yp
block|;
name|va_start
argument_list|(
name|ap
argument_list|)
block|;
name|yp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|YP
argument_list|)
block|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
block|;
name|va_end
argument_list|(
name|ap
argument_list|)
block|;
name|yyerror_aux
argument_list|(
name|buffer
argument_list|)
block|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
block|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|sysdef
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysdef
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|*
name|systbl
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|systbl
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|*
name|systub
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|systub
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_expr_stmt
unit|+
specifier|static
name|pyyerror
argument_list|(
argument|yp
argument_list|,
argument|fmt
argument_list|)
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pyyerror
argument_list|(
name|yp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|yywrap
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|yyprint
argument_list|(
argument|s
argument_list|,
argument|f
argument_list|,
argument|top
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|,
name|top
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_expr_stmt
specifier|static
name|yyprint_aux
argument_list|(
argument|s
argument_list|,
argument|mode
argument_list|)
name|char
operator|*
name|s
operator|,
operator|*
name|mode
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|static
name|int
name|nameoutput
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|outputlinelen
init|=
literal|79
decl_stmt|;
if|if
condition|(
name|sflag
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|yymode
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|nameoutput
operator|=
operator|(
name|linepos
operator|=
name|strlen
argument_list|(
name|mymodule
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %ss"
argument_list|,
name|yymode
operator|=
name|mode
argument_list|)
expr_stmt|;
name|linepos
operator|+=
name|strlen
argument_list|(
name|yymode
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|linepos
operator|+=
literal|2
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|linepos
operator|!=
name|nameoutput
condition|)
if|if
condition|(
name|len
operator|+
name|linepos
operator|+
literal|1
operator|>
name|outputlinelen
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%*s"
argument_list|,
name|linepos
operator|=
name|nameoutput
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
operator|,
name|linepos
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|linepos
operator|+=
name|len
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS1 */
end_comment

begin_macro
name|pass1
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
if|if
condition|(
name|mymoduleid
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|oidprint
argument_list|(
name|mymoduleid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DEFINITIONS ::=\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|pass1_op
argument_list|(
argument|mod
argument_list|,
argument|id
argument_list|,
argument|arg
argument_list|,
argument|result
argument_list|,
argument|errors
argument_list|,
argument|linked
argument_list|,
argument|opcode
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|arg
decl_stmt|,
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YV
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YV
name|linked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|opcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
specifier|register
name|YO
name|yo
decl_stmt|;
if|if
condition|(
operator|(
name|yo
operator|=
operator|(
name|YO
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yo
argument_list|)
operator|)
operator|==
name|NULLYO
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yo
operator|->
name|yo_name
operator|=
name|id
expr_stmt|;
name|yo
operator|->
name|yo_arg
operator|=
name|arg
expr_stmt|;
name|yo
operator|->
name|yo_result
operator|=
name|result
expr_stmt|;
name|yo
operator|->
name|yo_errors
operator|=
name|errors
expr_stmt|;
name|yo
operator|->
name|yo_linked
operator|=
name|linked
expr_stmt|;
name|yo
operator|->
name|yo_opcode
operator|=
name|opcode
expr_stmt|;
if|if
condition|(
name|rosydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_op
argument_list|(
name|yo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|yyprint_aux
argument_list|(
name|id
argument_list|,
literal|"operation"
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|mod
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_op
operator|=
name|yo
expr_stmt|;
name|myoperations
operator|=
name|add_symbol
argument_list|(
name|myoperations
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|pass1_err
argument_list|(
argument|mod
argument_list|,
argument|id
argument_list|,
argument|param
argument_list|,
argument|errcode
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|param
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
specifier|register
name|YE
name|ye
decl_stmt|;
if|if
condition|(
operator|(
name|ye
operator|=
operator|(
name|YE
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ye
argument_list|)
operator|)
operator|==
name|NULLYE
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ye
operator|->
name|ye_name
operator|=
name|id
expr_stmt|;
name|ye
operator|->
name|ye_param
operator|=
name|param
expr_stmt|;
name|ye
operator|->
name|ye_errcode
operator|=
name|errcode
expr_stmt|;
name|ye
operator|->
name|ye_offset
operator|=
name|erroff
operator|++
expr_stmt|;
if|if
condition|(
name|rosydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_err
argument_list|(
name|ye
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|yyprint_aux
argument_list|(
name|id
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|mod
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_err
operator|=
name|ye
expr_stmt|;
name|myerrors
operator|=
name|add_symbol
argument_list|(
name|myerrors
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|pass1_type
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|,
name|yp
argument_list|)
specifier|register
name|char
operator|*
name|encpref
operator|,
operator|*
name|decpref
operator|,
operator|*
name|prfpref
operator|,
operator|*
name|mod
operator|,
operator|*
name|id
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|dflag
operator|&&
name|lookup_type
argument_list|(
name|mod
argument_list|,
name|id
argument_list|)
condition|)
comment|/* no duplicate entries, please... */
return|return;
if|if
condition|(
name|rosydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
operator|)
condition|)
name|yyprint_aux
argument_list|(
name|id
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_type
operator|=
name|yp
expr_stmt|;
name|mytypes
operator|=
name|add_symbol
argument_list|(
name|mytypes
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS2 */
end_comment

begin_macro
name|pass2
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|SY
name|sy
decl_stmt|,
name|sy2
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
if|if
condition|(
operator|!
name|bflag
condition|)
name|bflag
operator|=
name|mymodule
expr_stmt|;
if|if
condition|(
operator|!
name|sflag
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mymodulename
condition|)
name|mymodulename
operator|=
name|mymodule
expr_stmt|;
name|modsym_aux
argument_list|(
name|mymodulename
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
if|if
condition|(
name|oplistorig
index|[
literal|0
index|]
condition|)
block|{
name|opvc
operator|=
name|sstr2arg
argument_list|(
name|oplistorig
argument_list|,
name|NOPS
argument_list|,
name|opvp
argument_list|,
literal|", \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opvc
operator|<
literal|0
condition|)
name|opvc
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysdef
argument_list|,
literal|"%s-ops.h"
argument_list|,
name|bflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdef
operator|=
name|fopen
argument_list|(
name|sysdef
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myyerror
argument_list|(
literal|"unable to write %s"
argument_list|,
name|sysdef
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"/* automatically generated by %s, do not edit! */\n\n"
argument_list|,
name|autogen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|systbl
argument_list|,
literal|"%s-ops.c"
argument_list|,
name|bflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ftbl
operator|=
name|fopen
argument_list|(
name|systbl
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myyerror
argument_list|(
literal|"unable to write %s"
argument_list|,
name|systbl
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"/* automatically generated by %s, do not edit! */\n\n"
argument_list|,
name|autogen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pepsyflag
condition|)
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include %s\n\n\n"
argument_list|,
name|mflag
condition|?
literal|"\"rosy.h\""
else|:
literal|"<isode/rosy.h>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifndef\tPEPSY_VERSION\n#define\tPEPSY_VERSION\t\t%d\n"
argument_list|,
name|PEPSY_VERSION_NUMBER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"#include \"%s-types.h\"\n\n"
argument_list|,
name|bflag
argument_list|)
expr_stmt|;
comment|/* XXX */
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include %s\n\n\n"
argument_list|,
name|mflag
condition|?
literal|"\"rosy.h\""
else|:
literal|"<isode/rosy.h>"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"#include<stdio.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"#include \"%s\"\n\n\n"
argument_list|,
name|sysdef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pepsyflag
condition|)
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"#include \"%s-types.h\"\n\n"
argument_list|,
name|bflag
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|systub
argument_list|,
literal|"%s-stubs.c"
argument_list|,
name|bflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstb
operator|=
name|fopen
argument_list|(
name|systub
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myyerror
argument_list|(
literal|"unable to write %s"
argument_list|,
name|systbl
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"/* automatically generated by %s, do not edit! */\n\n"
argument_list|,
name|autogen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"#include<stdio.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|sysdef
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"#include \"%s-types.h\"\n\n"
argument_list|,
name|bflag
argument_list|)
expr_stmt|;
comment|/* XXX */
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\t\t\t\t\t/* OPERATIONS */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"extern struct RyOperation table_%s_Operations[];\n\n"
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t\t\t\t\t/* OPERATIONS */\n\n"
argument_list|)
expr_stmt|;
name|yymode
operator|=
literal|"operation"
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|myoperations
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sy
operator|->
name|sy_op
operator|->
name|yo_opcode
operator|)
operator|<
literal|0
condition|)
name|yyerror_aux
argument_list|(
literal|"negative operation code (warning)"
argument_list|)
expr_stmt|;
for|for
control|(
name|sy2
operator|=
name|sy
operator|->
name|sy_next
init|;
name|sy2
condition|;
name|sy2
operator|=
name|sy2
operator|->
name|sy_next
control|)
if|if
condition|(
name|i
operator|==
name|sy2
operator|->
name|sy_op
operator|->
name|yo_opcode
condition|)
block|{
name|yyerror_aux
argument_list|(
literal|"non-unique operation codes (warning)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvalue=%d op1=%s op2=%s\n"
argument_list|,
name|i
argument_list|,
name|sy
operator|->
name|sy_op
operator|->
name|yo_name
argument_list|,
name|sy2
operator|->
name|sy_op
operator|->
name|yo_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opvc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opvc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opvp
index|[
name|i
index|]
argument_list|,
name|sy
operator|->
name|sy_op
operator|->
name|yo_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|opvc
condition|)
continue|continue;
block|}
name|do_op1
argument_list|(
name|sy
operator|->
name|sy_op
argument_list|,
name|eval
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n#ifndef\tlint\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"\n#ifdef\tlint\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"struct RyOperation table_%s_Operations[] = {\n"
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|myoperations
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|opvc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opvc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|opvp
index|[
name|i
index|]
argument_list|,
name|sy
operator|->
name|sy_op
operator|->
name|yo_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|opvc
condition|)
continue|continue;
block|}
name|do_op2
argument_list|(
name|sy
operator|->
name|sy_op
argument_list|,
name|eval
operator|=
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"    NULL\n};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n\n\t\t\t\t\t/* ERRORS */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"extern struct RyError table_%s_Errors[];\n\n"
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\n\t\t\t\t\t/* ERRORS */\n\n"
argument_list|)
expr_stmt|;
name|yymode
operator|=
literal|"error"
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|myerrors
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sy
operator|->
name|sy_err
operator|->
name|ye_errcode
operator|)
operator|<
literal|0
condition|)
name|yyerror_aux
argument_list|(
literal|"negative error code (warning)"
argument_list|)
expr_stmt|;
for|for
control|(
name|sy2
operator|=
name|sy
operator|->
name|sy_next
init|;
name|sy2
condition|;
name|sy2
operator|=
name|sy2
operator|->
name|sy_next
control|)
if|if
condition|(
name|i
operator|==
name|sy2
operator|->
name|sy_err
operator|->
name|ye_errcode
condition|)
block|{
name|yyerror_aux
argument_list|(
literal|"non-unique error codes (warning)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvalue=%d err1=%s err2=%s\n"
argument_list|,
name|i
argument_list|,
name|sy
operator|->
name|sy_err
operator|->
name|ye_name
argument_list|,
name|sy2
operator|->
name|sy_err
operator|->
name|ye_name
argument_list|)
expr_stmt|;
block|}
name|do_err1
argument_list|(
name|sy
operator|->
name|sy_err
argument_list|,
name|eval
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"struct RyError table_%s_Errors[] = {\n"
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|myerrors
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
name|do_err2
argument_list|(
name|sy
operator|->
name|sy_err
argument_list|,
name|eval
operator|=
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"    NULL\n};\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BEGIN\n"
argument_list|)
expr_stmt|;
name|yymode
operator|=
literal|"type"
expr_stmt|;
name|yyencpref
operator|=
name|yydecpref
operator|=
name|yyprfpref
operator|=
literal|"none"
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mytypes
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dflag
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_ENCODER
operator|)
condition|)
name|sy
operator|->
name|sy_encpref
operator|=
literal|"none"
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_DECODER
operator|)
condition|)
name|sy
operator|->
name|sy_decpref
operator|=
literal|"none"
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_direction
operator|&
name|YP_PRINTER
operator|)
condition|)
name|sy
operator|->
name|sy_prfpref
operator|=
literal|"none"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|yyencpref
argument_list|,
name|sy
operator|->
name|sy_encpref
argument_list|)
operator|||
name|strcmp
argument_list|(
name|yydecpref
argument_list|,
name|sy
operator|->
name|sy_decpref
argument_list|)
operator|||
name|strcmp
argument_list|(
name|yyprfpref
argument_list|,
name|sy
operator|->
name|sy_prfpref
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\nSECTIONS %s %s %s\n"
argument_list|,
name|yyencpref
operator|=
name|sy
operator|->
name|sy_encpref
argument_list|,
name|yydecpref
operator|=
name|sy
operator|->
name|sy_decpref
argument_list|,
name|yyprfpref
operator|=
name|sy
operator|->
name|sy_prfpref
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action0
argument_list|,
literal|1
argument_list|,
literal|"\n%*s%%{"
argument_list|,
literal|"%%}\n%*s"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"::=\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PULLEDUP
operator|)
operator|&&
name|yp
operator|->
name|yp_action1
condition|)
block|{
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|,
literal|1
argument_list|,
literal|"%*s%%{"
argument_list|,
literal|"%%}\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_flags
operator||=
name|YP_PULLEDUP
expr_stmt|;
block|}
name|do_type
argument_list|(
name|yp
argument_list|,
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
condition|?
literal|1
else|:
literal|2
argument_list|,
name|eval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
operator|||
name|ferror
argument_list|(
name|ftbl
argument_list|)
operator|||
name|ferror
argument_list|(
name|fstb
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nEND\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fdef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ftbl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fstb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
operator|||
name|ferror
argument_list|(
name|ftbl
argument_list|)
operator|||
name|ferror
argument_list|(
name|fstb
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fdef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ftbl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fstb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_op1
argument_list|(
name|yo
argument_list|,
name|id
argument_list|)
specifier|register
name|YO
name|yo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YE
name|ye
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\t\t\t\t\t/* OPERATION %s */\n"
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define operation_%s\t%d\n\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
name|yo
operator|->
name|yo_opcode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t\t\t\t\t/* OPERATION %s */\n"
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
operator|&
name|yo
operator|->
name|yo_arg
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pepsyflag
operator|&&
operator|(
name|yp
operator|=
name|yo
operator|->
name|yo_arg
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"int\t%s (),\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s (),\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s ();\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|normalize
argument_list|(
operator|&
name|yo
operator|->
name|yo_result
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pepsyflag
operator|&&
operator|(
name|yp
operator|=
name|yo
operator|->
name|yo_result
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"int\t%s (),\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s (),\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s ();\n\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Pepsyflag
condition|)
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifdef\tINVOKER\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Pepsyflag
operator|||
name|Defsflag
condition|)
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_argument\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|yo
operator|->
name|yo_arg
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_result\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|yo
operator|->
name|yo_result
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_result\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|yo
operator|->
name|yo_result
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Pepsyflag
condition|)
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_argument\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_result\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_result\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifdef\tPERFORMER\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Pepsyflag
operator|||
name|Defsflag
condition|)
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_argument\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|yo
operator|->
name|yo_arg
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_argument\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|yo
operator|->
name|yo_arg
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_result\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|yo
operator|->
name|yo_result
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Pepsyflag
condition|)
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_argument\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_argument\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_result\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yv
operator|=
name|yo
operator|->
name|yo_errors
condition|)
block|{
if|if
condition|(
name|yv
operator|->
name|yv_code
operator|!=
name|YV_VALIST
condition|)
name|myyerror
argument_list|(
literal|"unexpected value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"static struct RyError *errors_%s[] = {\n"
argument_list|,
name|modsym
argument_list|(
name|mymodulename
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|ye
operator|=
name|lookup_err
argument_list|(
name|yv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"&table_%s_Errors[%d]%s\n"
argument_list|,
name|mymodaux
argument_list|,
name|ye
operator|->
name|ye_offset
argument_list|,
name|yv
operator|->
name|yv_next
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_op2
argument_list|(
name|yo
argument_list|,
name|id
argument_list|)
specifier|register
name|YO
name|yo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n#define stub_%s(sd,id,in,rfx,efx,class,roi)\\\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"RyStub ((sd), table_%s_Operations,"
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|" operation_%s, (id), NULLIP,\\\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\t(caddr_t) (in), (rfx), (efx), (class), (roi))\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n#define op_%s(sd,in,out,rsp,roi)\\\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"RyOperation ((sd), table_%s_Operations,"
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|" operation_%s,\\\n\t(caddr_t) (in), (out), (rsp), (roi))\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"\nint\tstub_%s (sd, id, in, rfx, efx, class, roi)\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"int\tsd,\n\tid,\n\tclass;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|yo
operator|->
name|yo_arg
condition|)
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"struct %s*"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"caddr_t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|" in;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"IFP\trfx,\n\tefx;\nstruct RoSAPindication *roi;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"{\n    return RyStub (sd, table_%s_Operations, "
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"operation_%s, id, NULLIP,\n\t\t(caddr_t) in, rfx, efx, class, roi);\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"\nint\top_%s (sd, in, out, rsp, roi)\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"int\tsd;\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|yo
operator|->
name|yo_arg
condition|)
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"struct %s*"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"caddr_t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|" in;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"caddr_t *out;\nint    *rsp;\nstruct RoSAPindication *roi;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"{\n    return RyOperation (sd, table_%s_Operations, "
argument_list|,
name|mymodaux
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"operation_%s,\n\t\t(caddr_t) in, out, rsp, roi);\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fstb
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t\t\t\t\t/* OPERATION %s */\n"
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"    \"%s\", operation_%s,\n"
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pepsyflag
condition|)
block|{
if|if
condition|(
operator|(
name|yp
operator|=
name|yo
operator|->
name|yo_arg
operator|)
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_IDEFINED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ndo_op2:arg: internal error for %s\n"
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t&%s,\n "
argument_list|,
name|cmodsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|MODTYP_SUFFIX
argument_list|,
name|PREFIX
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s,\n"
argument_list|,
name|csymmod
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
name|PREFIX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\tNULL,\n "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\tNULL,\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s_argument,\n "
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s_argument,\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s_argument,\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Pepsyflag
condition|)
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%d,\n"
argument_list|,
name|yo
operator|->
name|yo_result
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|=
name|yo
operator|->
name|yo_result
operator|)
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_IDEFINED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ndo_op2:result: internal error for %s\n"
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t&%s,\n "
argument_list|,
name|cmodsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|MODTYP_SUFFIX
argument_list|,
name|PREFIX
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s,\n"
argument_list|,
name|csymmod
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
name|PREFIX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\tNULL,\n "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\tNULL,\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%d, %s_result,\n"
argument_list|,
name|yo
operator|->
name|yo_result
condition|?
literal|1
else|:
literal|0
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t   %s_result,\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t   %s_result,\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yo
operator|->
name|yo_errors
condition|)
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\terrors_%s"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\tNULL"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|",\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_err1
argument_list|(
name|ye
argument_list|,
name|id
argument_list|)
specifier|register
name|YE
name|ye
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\t\t\t\t\t/* ERROR %s */\n"
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define error_%s\t%d\n\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
name|ye
operator|->
name|ye_errcode
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
operator|&
name|ye
operator|->
name|ye_param
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Pepsyflag
condition|)
block|{
if|if
condition|(
name|yp
operator|=
name|ye
operator|->
name|ye_param
condition|)
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"int\t%s (),\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s (),\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s ();\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifdef\tINVOKER\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_parameter\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|ye
operator|->
name|ye_param
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_parameter\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|ye
operator|->
name|ye_param
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_parameter\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_parameter\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifdef\tPERFORMER\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_parameter\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|=
name|ye
operator|->
name|ye_param
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"NULLIFP\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_parameter\tNULLIFP\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_err2
argument_list|(
name|ye
argument_list|,
name|id
argument_list|)
specifier|register
name|YE
name|ye
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t\t\t\t\t/* ERROR %s */\n"
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"    \"%s\", error_%s,\n"
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pepsyflag
condition|)
block|{
if|if
condition|(
operator|(
name|yp
operator|=
name|ye
operator|->
name|ye_param
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t&%s,\n "
argument_list|,
name|cmodsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|MODTYP_SUFFIX
argument_list|,
name|PREFIX
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s,\n"
argument_list|,
name|csymmod
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
name|PREFIX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\tNULL,\n\tNULL,\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s_parameter,\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"encode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s_parameter,\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"decode"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ftbl
argument_list|,
literal|"\t%s_parameter,\n\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_type
argument_list|(
name|yp
argument_list|,
name|level
argument_list|,
name|id
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
specifier|register
name|YT
name|yt
decl_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PULLEDUP
operator|)
operator|&&
name|yp
operator|->
name|yp_action1
condition|)
block|{
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|,
name|level
argument_list|,
literal|"%%{"
argument_list|,
literal|"%%}\n%*s"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_flags
operator||=
name|YP_PULLEDUP
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|yt
operator|=
name|yp
operator|->
name|yp_tag
operator|)
condition|)
name|myyerror
argument_list|(
literal|"lost tag"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s%d]\n"
argument_list|,
name|classes
index|[
name|yt
operator|->
name|yt_class
index|]
argument_list|,
name|val2int
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PULLEDUP
operator|)
operator|&&
name|yp
operator|->
name|yp_action1
condition|)
block|{
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|,
name|level
argument_list|,
literal|"%%{"
argument_list|,
literal|"%%}\n%*s"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_flags
operator||=
name|YP_PULLEDUP
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
name|printf
argument_list|(
literal|"IMPLICIT "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|printf
argument_list|(
literal|"%s< "
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_COMPONENTS
condition|)
name|printf
argument_list|(
literal|"COMPONENTS OF "
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ENCRYPTED
condition|)
name|printf
argument_list|(
literal|"ENCRYPTED "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
name|printf
argument_list|(
literal|"BOOLEAN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[b %s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INT
case|:
name|printf
argument_list|(
literal|"INTEGER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[i %s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_ENUMLIST
condition|)
name|printf
argument_list|(
literal|"ENUMERATED"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"INTEGER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[i %s]]\n%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
operator|)
condition|)
name|myyerror
argument_list|(
literal|"lost named number"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s(%d)"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yv
operator|->
name|yv_action
condition|)
name|printf
argument_list|(
literal|" %%{%s%%}"
argument_list|,
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|yv
operator|->
name|yv_next
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|level
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
name|printf
argument_list|(
literal|"BIT STRING"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_strexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[x %s$%s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BITLIST
case|:
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_strexp
condition|)
name|printf
argument_list|(
literal|"BIT STRING\n%*s[[x %s$%s]]\n%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"BIT STRING {\n"
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
operator|)
condition|)
name|myyerror
argument_list|(
literal|"lost named number"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%s(%d)"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yv
operator|->
name|yv_action
condition|)
name|printf
argument_list|(
literal|" %%{%s%%}"
argument_list|,
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|yv
operator|->
name|yv_next
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|level
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
name|printf
argument_list|(
literal|"OCTET STRING"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
break|break;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[o %s$%s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[%c %s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_REAL
case|:
name|printf
argument_list|(
literal|"REAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_strexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[r %s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQ
case|:
name|printf
argument_list|(
literal|"SEQUENCE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
name|printf
argument_list|(
literal|"SEQUENCE OF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
block|{
name|printf
argument_list|(
literal|" %%[ %s "
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_ptrname
condition|)
name|printf
argument_list|(
literal|"$ %s "
argument_list|,
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%]\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_action3
condition|)
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action3
argument_list|,
name|level
operator|+
literal|1
argument_list|,
literal|"%*s%%{"
argument_list|,
literal|"%%}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
name|printf
argument_list|(
literal|"%*s<<%s>>\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yp
operator|->
name|yp_type
condition|)
name|myyerror
argument_list|(
literal|"lost sequence type"
argument_list|)
expr_stmt|;
name|do_type
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|,
name|level
operator|+
literal|1
argument_list|,
literal|"element"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQLIST
case|:
name|printf
argument_list|(
literal|"SEQUENCE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
block|{
name|printf
argument_list|(
literal|" %%[ %s "
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_ptrname
condition|)
name|printf
argument_list|(
literal|"$ %s "
argument_list|,
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dflag
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PULLEDUP
operator|)
operator|&&
name|yp
operator|->
name|yp_action1
condition|)
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|,
name|level
argument_list|,
literal|"\n%*s    %%{"
argument_list|,
literal|"    %%}\n%*s{\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|yp
operator|->
name|yp_type
condition|?
literal|" {\n"
else|:
literal|" {"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|do_type
argument_list|(
name|y
argument_list|,
name|level
operator|+
operator|(
operator|(
name|y
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|,
literal|"element"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|y
operator|->
name|yp_next
condition|?
literal|",\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|yp
operator|->
name|yp_type
condition|?
literal|"%*s}"
else|:
literal|"}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SET
case|:
name|printf
argument_list|(
literal|"SET"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SETTYPE
case|:
name|printf
argument_list|(
literal|"SET OF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
block|{
name|printf
argument_list|(
literal|" %%[ %s "
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_ptrname
condition|)
name|printf
argument_list|(
literal|"$ %s "
argument_list|,
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%]\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_action3
condition|)
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action3
argument_list|,
name|level
operator|+
literal|1
argument_list|,
literal|"%*s%%{"
argument_list|,
literal|"%%}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
name|printf
argument_list|(
literal|"%*s<<%s>>\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yp
operator|->
name|yp_type
condition|)
name|myyerror
argument_list|(
literal|"lost set type"
argument_list|)
expr_stmt|;
name|do_type
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|,
name|level
operator|+
literal|1
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SETLIST
case|:
name|printf
argument_list|(
literal|"SET"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
block|{
name|printf
argument_list|(
literal|" %%[ %s "
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_ptrname
condition|)
name|printf
argument_list|(
literal|"$ %s "
argument_list|,
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dflag
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PULLEDUP
operator|)
operator|&&
name|yp
operator|->
name|yp_action1
condition|)
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|,
name|level
argument_list|,
literal|"\n%*s    %%{"
argument_list|,
literal|"    %%}\n%*s{\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|yp
operator|->
name|yp_type
condition|?
literal|" {\n"
else|:
literal|" {"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|do_type
argument_list|(
name|y
argument_list|,
name|level
operator|+
operator|(
operator|(
name|y
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|y
operator|->
name|yp_next
condition|?
literal|",\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|yp
operator|->
name|yp_type
condition|?
literal|"%*s}"
else|:
literal|"}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
name|printf
argument_list|(
literal|"CHOICE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
block|{
name|printf
argument_list|(
literal|" %%[ %s "
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_ptrname
condition|)
name|printf
argument_list|(
literal|"$ %s "
argument_list|,
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dflag
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PULLEDUP
operator|)
operator|&&
name|yp
operator|->
name|yp_action1
condition|)
block|{
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|,
name|level
argument_list|,
literal|"\n%*s    %%{"
argument_list|,
literal|"    %%}\n%*s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
name|printf
argument_list|(
literal|"<<%s>> "
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|do_type
argument_list|(
name|y
argument_list|,
name|level
operator|+
operator|(
operator|(
name|y
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|,
literal|"choice"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|y
operator|->
name|yp_next
condition|?
literal|",\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_ANY
case|:
name|printf
argument_list|(
literal|"ANY"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
name|printf
argument_list|(
literal|"OBJECT IDENTIFIER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_strexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[O %s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s."
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[%c %s$%s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n%*s[[%c %s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|printf
argument_list|(
literal|"\n%*s[[%c %s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
condition|)
name|printf
argument_list|(
literal|"\n%*s[[p %s]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_parm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown type: %d"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dflag
operator|&&
name|yp
operator|->
name|yp_action2
condition|)
name|act2prf
argument_list|(
name|yp
operator|->
name|yp_action2
argument_list|,
name|level
argument_list|,
literal|"\n%*s%%{"
argument_list|,
literal|"%%}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
name|printf
argument_list|(
literal|"\n%*sOPTIONAL"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
if|if
condition|(
operator|!
name|yp
operator|->
name|yp_default
condition|)
name|myyerror
argument_list|(
literal|"lost default"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%*sDEFAULT "
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|val2prf
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|,
name|level
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTCONTROL
condition|)
name|printf
argument_list|(
literal|"<<%s>>"
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|ERROR HANDLING */
end_comment

begin_function
specifier|static
name|YE
name|lookup_err
parameter_list|(
name|yv
parameter_list|)
name|YV
name|yv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|mod
decl_stmt|;
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_code
operator|!=
name|YV_IDEFINED
condition|)
name|myyerror
argument_list|(
literal|"unexpected value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
name|id
operator|=
name|yv
operator|->
name|yv_identifier
expr_stmt|;
name|mod
operator|=
name|yv
operator|->
name|yv_module
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|myerrors
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|mod
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mod
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sy
operator|->
name|sy_err
return|;
block|}
if|if
condition|(
name|mod
condition|)
name|myyerror
argument_list|(
literal|"error %s.%s undefined"
argument_list|,
name|mod
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|else
name|myyerror
argument_list|(
literal|"error %s undefined"
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|TYPE HANDLING */
end_comment

begin_function
specifier|static
name|YP
name|lookup_type
parameter_list|(
name|mod
parameter_list|,
name|id
parameter_list|)
specifier|register
name|char
modifier|*
name|mod
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
for|for
control|(
name|sy
operator|=
name|mytypes
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|mod
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mod
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sy
operator|->
name|sy_type
return|;
block|}
return|return
name|NULLYP
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|normalize
argument_list|(
argument|yp
argument_list|,
argument|id
argument_list|)
name|YP
operator|*
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|,
name|z
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
operator|*
name|yp
operator|)
operator|==
name|NULLYP
operator|||
name|y
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
return|return;
name|y
operator|->
name|yp_id
operator|=
name|NULLCP
expr_stmt|;
name|y
operator|->
name|yp_flags
operator|&=
operator|~
name|YP_ID
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Pseudo-%s"
argument_list|,
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|lookup_type
argument_list|(
name|mymodule
argument_list|,
name|buffer
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Pseudo-%s-%d"
argument_list|,
name|id
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|z
operator|=
name|new_type
argument_list|(
name|YP_IDEFINED
argument_list|)
expr_stmt|;
name|z
operator|->
name|yp_identifier
operator|=
name|new_string
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|yp
operator|=
name|z
expr_stmt|;
name|pass1_type
argument_list|(
name|yyencpref
argument_list|,
name|yydecpref
argument_list|,
name|yyprfpref
argument_list|,
name|mymodule
argument_list|,
name|new_string
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|VALUE HANDLING */
end_comment

begin_function
specifier|static
name|int
name|val2int
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_VALIST
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a list of values"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
case|case
name|YV_REAL
case|:
name|yyerror
argument_list|(
literal|"need and integer, not a REAL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|val2prf
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
comment|/* will this REALLY work??? */
name|do_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
name|level
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
name|printf
argument_list|(
name|yv
operator|->
name|yv_number
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_NUMBER
case|:
if|if
condition|(
name|yv
operator|->
name|yv_named
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_module
condition|)
name|printf
argument_list|(
literal|"%s."
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|val2prf
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|y
operator|->
name|yv_next
condition|?
literal|", "
else|:
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_NULL
case|:
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_REAL
case|:
name|dump_real
argument_list|(
name|yv
operator|->
name|yv_real
argument_list|)
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|dump_real
argument_list|(
argument|r
argument_list|)
name|double
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|BSD44
specifier|extern
name|char
modifier|*
name|ecvt
parameter_list|()
function_decl|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|decpt
decl_stmt|,
name|sign
decl_stmt|;
name|cp
operator|=
name|ecvt
argument_list|(
name|r
argument_list|,
literal|20
argument_list|,
operator|&
name|decpt
argument_list|,
operator|&
name|sign
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* cp gets overwritten by printf */
name|printf
argument_list|(
literal|"{ %s%s, 10, %d }"
argument_list|,
name|sign
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|sbuf
argument_list|,
name|decpt
operator|-
name|strlen
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%.19e"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|dp
operator|=
name|sbuf
operator|)
operator|==
literal|'-'
condition|)
name|sp
operator|=
literal|"-"
operator|,
name|dp
operator|++
expr_stmt|;
else|else
name|sp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|cp
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"{ 0, 10, 0 } -- %s --"
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|cp
operator|++
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"{ %s%c%s, 10, %d }"
argument_list|,
name|sp
argument_list|,
operator|*
name|dp
argument_list|,
name|dp
operator|+
literal|2
argument_list|,
name|atoi
argument_list|(
name|cp
argument_list|)
operator|-
name|strlen
argument_list|(
name|dp
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*
comment|ACTION HANDLING */
end_comment

begin_expr_stmt
specifier|static
name|act2prf
argument_list|(
argument|cp
argument_list|,
argument|level
argument_list|,
argument|e1
argument_list|,
argument|e2
argument_list|)
name|char
operator|*
name|cp
operator|,
operator|*
name|e1
operator|,
operator|*
name|e2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l4
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|e1
condition|)
name|printf
argument_list|(
name|e1
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ep
operator|=
name|index
argument_list|(
name|dp
operator|=
name|cp
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|expand
argument_list|(
name|dp
argument_list|,
name|ep
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%*.*s\n"
argument_list|,
name|ep
operator|-
name|dp
argument_list|,
name|ep
operator|-
name|dp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|ep
operator|=
name|index
argument_list|(
name|dp
operator|=
name|ep
operator|+
literal|1
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|l4
operator|=
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
for|for
control|(
init|;
operator|*
name|dp
condition|;
name|dp
operator|=
name|fp
control|)
block|{
if|if
condition|(
name|ep
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|fp
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
else|else
name|fp
operator|=
name|ep
operator|=
name|dp
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|j
operator|=
name|expand
argument_list|(
name|dp
argument_list|,
name|ep
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|fp
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|j
operator|<
name|i
condition|)
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|j
condition|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|l4
operator|+
name|j
operator|-
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*.*s\n"
argument_list|,
name|ep
operator|-
name|gp
argument_list|,
name|ep
operator|-
name|gp
argument_list|,
name|gp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|e2
condition|)
name|printf
argument_list|(
name|e2
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|expand
argument_list|(
name|dp
argument_list|,
name|ep
argument_list|,
name|gp
argument_list|)
specifier|register
name|char
operator|*
name|dp
operator|,
operator|*
name|ep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|gp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
operator|*
name|gp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dp
operator|<
name|ep
condition|;
name|dp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|dp
condition|)
block|{
case|case
literal|' '
case|:
name|i
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
name|i
operator|+=
literal|8
operator|-
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
continue|continue;
default|default:
operator|*
name|gp
operator|=
name|dp
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/*
comment|DEBUG */
end_comment

begin_expr_stmt
specifier|static
name|print_op
argument_list|(
name|yo
argument_list|,
name|level
argument_list|)
specifier|register
name|YO
name|yo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|yo
operator|==
name|NULLYO
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sname=%s opcode=%d\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yo
operator|->
name|yo_name
argument_list|,
name|yo
operator|->
name|yo_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|yo
operator|->
name|yo_arg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sargument\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yo
operator|->
name|yo_arg
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yo
operator|->
name|yo_result
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sresult\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yo
operator|->
name|yo_result
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yo
operator|->
name|yo_errors
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*serrors\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yo
operator|->
name|yo_errors
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_err
argument_list|(
name|ye
argument_list|,
name|level
argument_list|)
specifier|register
name|YE
name|ye
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ye
operator|==
name|NULLYE
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sname=%s opcode=%d\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|ye
operator|->
name|ye_name
argument_list|,
name|ye
operator|->
name|ye_errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ye
operator|->
name|ye_param
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sparameter\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|ye
operator|->
name|ye_param
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|print_type
argument_list|(
name|yp
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s direction=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|,
name|sprintb
argument_list|(
name|yp
operator|->
name|yp_flags
argument_list|,
name|YPBITS
argument_list|)
argument_list|,
name|yp
operator|->
name|yp_direction
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sintexp=\"%s\" strexp=\"%s\" prfexp=0%o declexp=\"%s\" varexp=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sparameter type=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction0 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act0_lineno
argument_list|,
name|yp
operator|->
name|yp_action0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action05
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction05 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act05_lineno
argument_list|,
name|yp
operator|->
name|yp_action05
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction1 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act1_lineno
argument_list|,
name|yp
operator|->
name|yp_action1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction2 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act2_lineno
argument_list|,
name|yp
operator|->
name|yp_action2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction3 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act3_lineno
argument_list|,
name|yp
operator|->
name|yp_action3
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stag class=0x%x value=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sdefault=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_default
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*soffset=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_BITLIST
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*svalue=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_value
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_type
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|print_type
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_module
condition|?
name|yp
operator|->
name|yp_module
else|:
literal|""
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|==
name|NULLYV
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|,
name|sprintb
argument_list|(
name|yv
operator|->
name|yv_flags
argument_list|,
name|YVBITS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_action
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_act_lineno
argument_list|,
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snamed=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_type
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snumber=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sstring=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_BOUND
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_function
specifier|static
name|SY
name|new_symbol
parameter_list|(
name|encpref
parameter_list|,
name|decpref
parameter_list|,
name|prfpref
parameter_list|,
name|mod
parameter_list|,
name|id
parameter_list|)
specifier|register
name|char
modifier|*
name|encpref
decl_stmt|,
decl|*
name|decpref
decl_stmt|,
modifier|*
name|prfpref
decl_stmt|,
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
operator|(
name|sy
operator|=
operator|(
name|SY
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|sy
argument_list|)
operator|)
operator|==
name|NULLSY
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_encpref
operator|=
name|encpref
expr_stmt|;
name|sy
operator|->
name|sy_decpref
operator|=
name|decpref
expr_stmt|;
name|sy
operator|->
name|sy_prfpref
operator|=
name|prfpref
expr_stmt|;
name|sy
operator|->
name|sy_module
operator|=
name|mod
expr_stmt|;
name|sy
operator|->
name|sy_name
operator|=
name|id
expr_stmt|;
return|return
name|sy
return|;
block|}
end_block

begin_function
specifier|static
name|SY
name|add_symbol
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|SY
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULLSY
condition|)
return|return
name|s2
return|;
for|for
control|(
name|sy
operator|=
name|s1
init|;
name|sy
operator|->
name|sy_next
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
continue|continue;
name|sy
operator|->
name|sy_next
operator|=
name|s2
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_comment
comment|/*
comment|TYPES */
end_comment

begin_function
name|YP
name|new_type
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
if|if
condition|(
operator|(
name|yp
operator|=
operator|(
name|YP
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yp
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_code
operator|=
name|code
expr_stmt|;
return|return
name|yp
return|;
block|}
end_function

begin_function
name|YP
name|add_type
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
specifier|register
name|YP
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
for|for
control|(
name|yp
operator|=
name|y
init|;
name|yp
operator|->
name|yp_next
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
continue|continue;
name|yp
operator|->
name|yp_next
operator|=
name|z
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|VALUES */
end_comment

begin_function
name|YV
name|new_value
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
operator|(
name|yv
operator|=
operator|(
name|YV
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yv
argument_list|)
operator|)
operator|==
name|NULLYV
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yv
operator|->
name|yv_code
operator|=
name|code
expr_stmt|;
return|return
name|yv
return|;
block|}
end_function

begin_function
name|YV
name|add_value
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
specifier|register
name|YV
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
for|for
control|(
name|yv
operator|=
name|y
init|;
name|yv
operator|->
name|yv_next
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
continue|continue;
name|yv
operator|->
name|yv_next
operator|=
name|z
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|TAGS */
end_comment

begin_function
name|YT
name|new_tag
parameter_list|(
name|class
parameter_list|)
name|PElementClass
name|class
decl_stmt|;
block|{
specifier|register
name|YT
name|yt
decl_stmt|;
if|if
condition|(
operator|(
name|yt
operator|=
operator|(
name|YT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yt
argument_list|)
operator|)
operator|==
name|NULLYT
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yt
operator|->
name|yt_class
operator|=
name|class
expr_stmt|;
return|return
name|yt
return|;
block|}
end_function

begin_comment
comment|/*
comment|STRINGS */
end_comment

begin_function
name|char
modifier|*
name|new_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_struct
specifier|static
struct|struct
name|triple
block|{
name|char
modifier|*
name|t_name
decl_stmt|;
name|PElementClass
name|t_class
decl_stmt|;
name|PElementID
name|t_id
decl_stmt|;
block|}
name|triples
index|[]
init|=
block|{
literal|"IA5String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"ISO646String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"NumericString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_NUMS
block|,
literal|"PrintableString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_PRTS
block|,
literal|"T61String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"TeletexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"VideotexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VTXS
block|,
literal|"GeneralizedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"GeneralisedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"UTCTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"UniversalTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"GraphicString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GFXS
block|,
literal|"VisibleString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VISS
block|,
literal|"GeneralString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENS
block|,
literal|"EXTERNAL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_EXTN
block|,
literal|"ObjectDescriptor"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_ODE
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|modsym
parameter_list|(
name|module
parameter_list|,
name|id
parameter_list|,
name|prefix
parameter_list|)
specifier|register
name|char
modifier|*
name|module
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|module
operator|==
name|NULLCP
condition|)
for|for
control|(
name|t
operator|=
name|triples
init|;
name|t
operator|->
name|t_name
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|t_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|module
operator|=
literal|"UNIV"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prefix
condition|)
name|modsym_aux
argument_list|(
name|prefix
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|module
condition|?
name|module
else|:
name|mymodule
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|id
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s"
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_comment
comment|/*  * we do the same as modsym except we generate a more "compress" name,  * no underscores between components and dash is translated to only one  * underscore to be compatiable with pepsy. Hence name Compress MODule SYMbol  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cmodsym
parameter_list|(
name|module
parameter_list|,
name|id
parameter_list|,
name|prefix
parameter_list|,
name|realid
parameter_list|)
specifier|register
name|char
modifier|*
name|module
decl_stmt|,
decl|*
name|id
decl_stmt|,
modifier|*
name|realid
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|module
operator|==
name|NULLCP
condition|)
for|for
control|(
name|t
operator|=
name|triples
init|;
name|t
operator|->
name|t_name
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|t_name
argument_list|,
name|realid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|module
operator|=
literal|"UNIV"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prefix
condition|)
name|cmodsym_aux
argument_list|(
name|prefix
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|cmodsym_aux
argument_list|(
name|module
condition|?
name|module
else|:
name|mymodule
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|cmodsym_aux
argument_list|(
name|id
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s%s%s"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s%s"
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_comment
comment|/* like cmodsym except we put identifier (sym) then the module (mod) hence its  * name symmod  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|csymmod
parameter_list|(
name|module
parameter_list|,
name|id
parameter_list|,
name|prefix
parameter_list|)
specifier|register
name|char
modifier|*
name|module
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|module
operator|==
name|NULLCP
condition|)
for|for
control|(
name|t
operator|=
name|triples
init|;
name|t
operator|->
name|t_name
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|t_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|module
operator|=
literal|"UNIV"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prefix
condition|)
name|cmodsym_aux
argument_list|(
name|prefix
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|cmodsym_aux
argument_list|(
name|id
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|cmodsym_aux
argument_list|(
name|module
condition|?
name|module
else|:
name|mymodule
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s%s%s"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s%s"
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|modsym_aux
argument_list|(
name|name
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|name
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
break|break;
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|cmodsym_aux
argument_list|(
name|name
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|name
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
break|break;
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

end_unit

