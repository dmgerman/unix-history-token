begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"cmd_srch.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|chrcnv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|load_obj_hier
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|add_oc_macro
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|oid_table
name|OIDTable
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|objectclass
name|ocOIDTable
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|oid_table_attr
name|attrOIDTable
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|NumEntries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|attrNumEntries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ocNumEntries
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|table_seq
name|table_seq_new
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|mac_buf
block|{
comment|/* for handling macros */
name|char
name|name
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|char
name|value
index|[
name|LINESIZE
index|]
decl_stmt|;
block|}
name|macro
index|[
name|BUFSIZE
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|NumMacro
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|want_oc_hierarchy
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|IFP
name|oc_load
decl_stmt|;
specifier|extern
name|IFP
name|oc_macro_add
decl_stmt|;
name|oc_load
operator|=
name|load_obj_hier
expr_stmt|;
name|oc_macro_add
operator|=
name|add_oc_macro
expr_stmt|;
block|}
end_block

begin_macro
name|load_obj_hier
argument_list|(
argument|sep
argument_list|,
argument|newname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|newname
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sep
operator|==
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"hierarchy missing %s"
operator|,
name|newname
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|get_oc_bits
argument_list|(
name|sep
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"(%s)"
operator|,
name|newname
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_function
specifier|static
name|struct
name|oc_seq
modifier|*
name|oc_seq_merge
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|oc_seq
modifier|*
name|a
decl_stmt|;
name|struct
name|oc_seq
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|struct
name|oc_seq
modifier|*
name|aptr
decl_stmt|,
modifier|*
name|bptr
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULLOCSEQ
condition|)
return|return
operator|(
name|b
operator|)
return|;
if|if
condition|(
name|b
operator|==
name|NULLOCSEQ
condition|)
return|return
operator|(
name|a
operator|)
return|;
comment|/* start sequence off, make sure 'a' is the first */
switch|switch
condition|(
name|objclass_cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* equal */
name|result
operator|=
name|a
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|a
operator|->
name|os_next
expr_stmt|;
name|bptr
operator|=
name|b
operator|->
name|os_next
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|result
operator|=
name|b
expr_stmt|;
name|aptr
operator|=
name|a
expr_stmt|;
name|bptr
operator|=
name|b
operator|->
name|os_next
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|result
operator|=
name|a
expr_stmt|;
name|aptr
operator|=
name|a
operator|->
name|os_next
expr_stmt|;
name|bptr
operator|=
name|b
expr_stmt|;
break|break;
block|}
name|trail
operator|=
name|result
expr_stmt|;
while|while
condition|(
operator|(
name|aptr
operator|!=
name|NULLOCSEQ
operator|)
operator|&&
operator|(
name|bptr
operator|!=
name|NULLOCSEQ
operator|)
condition|)
block|{
switch|switch
condition|(
name|objclass_cmp
argument_list|(
name|aptr
argument_list|,
name|bptr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* equal */
name|trail
operator|->
name|os_next
operator|=
name|aptr
expr_stmt|;
name|trail
operator|=
name|aptr
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bptr
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|aptr
operator|->
name|os_next
expr_stmt|;
name|bptr
operator|=
name|bptr
operator|->
name|os_next
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|trail
operator|->
name|os_next
operator|=
name|bptr
expr_stmt|;
name|trail
operator|=
name|bptr
expr_stmt|;
name|bptr
operator|=
name|bptr
operator|->
name|os_next
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|trail
operator|->
name|os_next
operator|=
name|aptr
expr_stmt|;
name|trail
operator|=
name|aptr
expr_stmt|;
name|aptr
operator|=
name|aptr
operator|->
name|os_next
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|aptr
operator|==
name|NULLOCSEQ
condition|)
name|trail
operator|->
name|os_next
operator|=
name|bptr
expr_stmt|;
else|else
name|trail
operator|->
name|os_next
operator|=
name|aptr
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|get_oc_bits
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr2
decl_stmt|;
name|struct
name|oc_seq
modifier|*
name|oidseq
init|=
name|NULLOCSEQ
decl_stmt|,
modifier|*
name|oidseqptr
init|=
name|oidseq
decl_stmt|;
name|objectclass
modifier|*
name|oc
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|str
argument_list|,
name|SEPERATOR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"must missing"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ptr2
operator|=
name|index
argument_list|(
name|str
argument_list|,
name|COMMA
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptr2
operator|++
operator|=
literal|0
expr_stmt|;
name|oidseqptr
operator|=
operator|(
expr|struct
name|oc_seq
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|oc_seq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oc
operator|=
name|name2oc
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLOBJECTCLASS
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"unknown objectclass in hierachy %s"
operator|,
name|str
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|oidseqptr
operator|->
name|os_oc
operator|=
name|oc
expr_stmt|;
name|oidseqptr
operator|->
name|os_next
operator|=
name|NULLOCSEQ
expr_stmt|;
name|oidseq
operator|=
name|oc_seq_merge
argument_list|(
name|oidseq
argument_list|,
name|oidseqptr
argument_list|)
expr_stmt|;
name|str
operator|=
name|ptr2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|!=
literal|0
condition|)
block|{
name|oidseqptr
operator|=
operator|(
expr|struct
name|oc_seq
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|oc_seq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no logging -> never freed */
if|if
condition|(
operator|(
name|oc
operator|=
name|name2oc
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLOBJECTCLASS
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"unknown objectclass in hierachy %s"
operator|,
name|str
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|oidseqptr
operator|->
name|os_oc
operator|=
name|oc
expr_stmt|;
name|oidseqptr
operator|->
name|os_next
operator|=
name|NULLOCSEQ
expr_stmt|;
name|oidseq
operator|=
name|oc_seq_merge
argument_list|(
name|oidseq
argument_list|,
name|oidseqptr
argument_list|)
expr_stmt|;
name|ocOIDTable
index|[
name|ocNumEntries
index|]
operator|.
name|oc_hierachy
operator|=
name|oidseq
expr_stmt|;
block|}
else|else
name|ocOIDTable
index|[
name|ocNumEntries
index|]
operator|.
name|oc_hierachy
operator|=
name|NULLOCSEQ
expr_stmt|;
name|str
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|str
argument_list|,
name|SEPERATOR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"may element missing"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|ocOIDTable
index|[
name|ocNumEntries
index|]
operator|.
name|oc_may
operator|=
name|table_seq_new
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ocOIDTable
index|[
name|ocNumEntries
index|]
operator|.
name|oc_must
operator|=
name|table_seq_new
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|table_seq
name|undo_macro
parameter_list|(
name|top
parameter_list|,
name|ptr
parameter_list|)
name|table_seq
name|top
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|table_seq
name|tab
decl_stmt|;
name|table_seq
name|tab_top
decl_stmt|;
name|table_seq
name|trail
init|=
name|NULLTABLE_SEQ
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|0
condition|)
return|return
operator|(
name|top
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumMacro
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lexequ
argument_list|(
name|macro
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|ptr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tab_top
operator|=
name|table_seq_new
argument_list|(
name|macro
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|tab
operator|=
name|tab_top
init|;
name|tab
operator|!=
name|NULLTABLE_SEQ
condition|;
name|tab
operator|=
name|tab
operator|->
name|ts_next
control|)
name|trail
operator|=
name|tab
expr_stmt|;
if|if
condition|(
name|trail
operator|!=
name|NULLTABLE_SEQ
condition|)
block|{
name|trail
operator|->
name|ts_next
operator|=
name|top
expr_stmt|;
return|return
operator|(
name|tab_top
operator|)
return|;
block|}
else|else
return|return
operator|(
name|top
operator|)
return|;
block|}
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"can't interpret %s in must/may field"
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|table_seq
name|table_seq_new
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|table_seq
name|tptr
decl_stmt|;
name|table_seq
name|top
init|=
name|NULLTABLE_SEQ
decl_stmt|;
name|oid_table_attr
modifier|*
name|at
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|0
condition|)
return|return
operator|(
name|NULLTABLE_SEQ
operator|)
return|;
while|while
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|str
argument_list|,
name|COMMA
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|name2attr
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLTABLE_ATTR
condition|)
name|top
operator|=
name|undo_macro
argument_list|(
name|top
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
block|{
name|tptr
operator|=
operator|(
name|table_seq
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no logging -> never freed */
name|tptr
operator|->
name|ts_oa
operator|=
name|at
expr_stmt|;
name|tptr
operator|->
name|ts_next
operator|=
name|top
expr_stmt|;
name|top
operator|=
name|tptr
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|COMMA
expr_stmt|;
name|str
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|at
operator|=
name|name2attr
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLTABLE_ATTR
condition|)
return|return
operator|(
name|undo_macro
argument_list|(
name|top
argument_list|,
name|str
argument_list|)
operator|)
return|;
else|else
block|{
name|tptr
operator|=
operator|(
name|table_seq
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no logging -> never freed */
name|tptr
operator|->
name|ts_oa
operator|=
name|at
expr_stmt|;
name|tptr
operator|->
name|ts_next
operator|=
name|top
expr_stmt|;
return|return
operator|(
name|tptr
operator|)
return|;
block|}
block|}
else|else
return|return
operator|(
name|NULLTABLE_SEQ
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dumpalloid
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|objectclass
modifier|*
name|oc
init|=
operator|&
name|ocOIDTable
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|oid_table_attr
modifier|*
name|at
init|=
operator|&
name|attrOIDTable
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|oid_table
modifier|*
name|oi
init|=
operator|&
name|OIDTable
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ocNumEntries
condition|;
name|i
operator|++
operator|,
name|oc
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"%s\"\t\t%s\n"
argument_list|,
name|oc
operator|->
name|oc_ot
operator|.
name|ot_name
argument_list|,
name|oc
operator|->
name|oc_ot
operator|.
name|ot_stroid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attrNumEntries
condition|;
name|i
operator|++
operator|,
name|at
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"%s\"\t\t%s\n"
argument_list|,
name|at
operator|->
name|oa_ot
operator|.
name|ot_name
argument_list|,
name|at
operator|->
name|oa_ot
operator|.
name|ot_stroid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumEntries
condition|;
name|i
operator|++
operator|,
name|oi
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"%s\"\t\t%s\n"
argument_list|,
name|oi
operator|->
name|ot_name
argument_list|,
name|oi
operator|->
name|ot_stroid
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|add_oc_macro
argument_list|(
argument|buf
argument_list|,
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|macro
index|[
name|NumMacro
index|]
operator|.
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|macro
index|[
name|NumMacro
operator|++
index|]
operator|.
name|value
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

