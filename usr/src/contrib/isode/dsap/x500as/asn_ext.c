begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* asn_ext.c - ASN.1 code pepsy can't quite do yet */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/dsap/x500as/RCS/asn_ext.c,v 7.1 91/02/22 09:21:44 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/dsap/x500as/RCS/asn_ext.c,v 7.1 91/02/22 09:21:44 mrose Interim $  *  *  * $Log:	asn_ext.c,v $  * Revision 7.1  91/02/22  09:21:44  mrose  * Interim 6.8  *   * Revision 7.0  90/12/06  07:34:40  mrose  * *** empty log message ***  *   * Revision 7.1  90/07/09  14:35:48  mrose  * sync  *   * Revision 7.0  89/11/23  21:50:05  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/common.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dsargument.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TURBO_AVL
end_ifdef

begin_include
include|#
directive|include
file|"quipu/turbo.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"IF-types.h"
end_include

begin_include
include|#
directive|include
file|"Quipu-types.h"
end_include

begin_define
define|#
directive|define
name|advise
value|PY_advise
end_define

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Encoding substring filters */
end_comment

begin_comment
comment|/*  *  *        substrings  *                %{  *                        subs_temp =&(parm->UNSUB);  *			subs_type = 1;  *			if((avs_temp = subs_temp->fi_sub_initial) == NULLAV)  *			{  *			    ++subs_type;  *			    if((avs_temp = subs_temp->fi_sub_any) == NULLAV)  *			    {  *				++subs_type;  *				avs_temp = subs_temp->fi_sub_final;  *			    }  *			}  *                %}  *                [1] SEQUENCE  *                {  *                type  *                        AttributeType [[p subs_temp->fi_sub_type]]  *                        %{  *                        %} ,  *                strings  *                        SEQUENCE OF  *                        %{  *                        %}  *<<; avs_temp != NULLAV;>>  *                                CHOICE  *<<subs_type>>  *                                {  *                                initial  *                                        [0] AttributeValue [[p&avs_temp->avseq_av]]  *                                        %{  *						if((avs_temp = avs_temp->avseq_next) == NULLAV)  *						{  *						    ++subs_type;  *						    if((avs_temp = subs_temp->fi_sub_any) == NULLAV)  *						    {  *							++subs_type;  *							avs_temp = subs_temp->fi_sub_final;  *						    }  *						}  *                                        %} ,  *                                any  *                                        [1] AttributeValue [[p&avs_temp->avseq_av]]  *                                        %{  *						if((avs_temp = avs_temp->avseq_next) == NULLAV)  *						{  *						    ++subs_type;  *						    avs_temp = subs_temp->fi_sub_final;  *						}  *                                        %} ,  *                                final  *                                        [2] AttributeValue [[p&avs_temp->avseq_av]]  *                                        %{  *						avs_temp = avs_temp->avseq_next;  *                                        %}  *                                }  *                                %{  *                                %}  *                        %{  *                        %}  *                }  *  */
end_comment

begin_macro
name|substring_encode
argument_list|(
argument|parm
argument_list|,
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|filter_item
modifier|*
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|subs_type
decl_stmt|;
name|AV_Sequence
name|avs_temp
decl_stmt|;
name|Filter_Substrings
modifier|*
name|subs_temp
decl_stmt|;
name|PE
name|p91_z
init|=
name|NULLPE
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p91
init|=
operator|&
name|p91_z
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|pe
operator|)
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|PE_CONS_SEQ
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|subs_temp
operator|=
operator|&
operator|(
name|parm
operator|->
name|UNSUB
operator|)
expr_stmt|;
name|subs_type
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|avs_temp
operator|=
name|subs_temp
operator|->
name|fi_sub_initial
operator|)
operator|==
name|NULLAV
condition|)
block|{
operator|++
name|subs_type
expr_stmt|;
if|if
condition|(
operator|(
name|avs_temp
operator|=
name|subs_temp
operator|->
name|fi_sub_any
operator|)
operator|==
name|NULLAV
condition|)
block|{
operator|++
name|subs_type
expr_stmt|;
name|avs_temp
operator|=
name|subs_temp
operator|->
name|fi_sub_final
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|p91
operator|)
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|encode_IF_AttributeType
argument_list|(
name|p91
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|subs_temp
operator|->
name|fi_sub_type
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
operator|*
name|p91
operator|)
operator|!=
name|NULLPE
condition|)
if|if
condition|(
name|seq_add
argument_list|(
operator|(
operator|*
name|pe
operator|)
argument_list|,
operator|(
operator|*
name|p91
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings %s%s"
argument_list|,
name|PEPY_ERR_BAD_SEQ
argument_list|,
name|pe_error
argument_list|(
operator|(
operator|*
name|pe
operator|)
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|p91
operator|)
operator|=
name|NULLPE
expr_stmt|;
block|{
comment|/* strings */
name|PE
name|p92
init|=
name|NULLPE
decl_stmt|;
name|PE
name|p93_z
init|=
name|NULLPE
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p93
init|=
operator|&
name|p93_z
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|p91
operator|)
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|PE_CONS_SEQ
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"strings: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
init|;
name|avs_temp
operator|!=
name|NULLAV
condition|;
control|)
block|{
block|{
name|int
name|p94
decl_stmt|;
switch|switch
condition|(
name|p94
operator|=
operator|(
name|subs_type
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* initial */
block|{
if|if
condition|(
name|encode_IF_AttributeValue
argument_list|(
name|p93
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
operator|&
name|avs_temp
operator|->
name|avseq_av
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|{
if|if
condition|(
operator|(
name|avs_temp
operator|=
name|avs_temp
operator|->
name|avseq_next
operator|)
operator|==
name|NULLAV
condition|)
block|{
operator|++
name|subs_type
expr_stmt|;
if|if
condition|(
operator|(
name|avs_temp
operator|=
name|subs_temp
operator|->
name|fi_sub_any
operator|)
operator|==
name|NULLAV
condition|)
block|{
operator|++
name|subs_type
expr_stmt|;
name|avs_temp
operator|=
name|subs_temp
operator|->
name|fi_sub_final
expr_stmt|;
block|}
block|}
block|}
block|{
comment|/* initial TAG PUSHDOWN */
name|PE
name|p95_z
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p95
init|=
operator|&
name|p95_z
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|p95
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_CONT
argument_list|,
name|PE_FORM_CONS
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"initial: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|p95
operator|)
operator|->
name|pe_cons
operator|=
operator|(
operator|*
name|p93
operator|)
expr_stmt|;
operator|(
operator|*
name|p93
operator|)
operator|=
operator|*
name|p95
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|2
case|:
comment|/* any */
block|{
if|if
condition|(
name|encode_IF_AttributeValue
argument_list|(
name|p93
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
operator|&
name|avs_temp
operator|->
name|avseq_av
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|{
if|if
condition|(
operator|(
name|avs_temp
operator|=
name|avs_temp
operator|->
name|avseq_next
operator|)
operator|==
name|NULLAV
condition|)
block|{
operator|++
name|subs_type
expr_stmt|;
name|avs_temp
operator|=
name|subs_temp
operator|->
name|fi_sub_final
expr_stmt|;
block|}
block|}
block|{
comment|/* any TAG PUSHDOWN */
name|PE
name|p96_z
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p96
init|=
operator|&
name|p96_z
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|p96
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_CONT
argument_list|,
name|PE_FORM_CONS
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"any: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|p96
operator|)
operator|->
name|pe_cons
operator|=
operator|(
operator|*
name|p93
operator|)
expr_stmt|;
operator|(
operator|*
name|p93
operator|)
operator|=
operator|*
name|p96
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|3
case|:
comment|/* final */
block|{
if|if
condition|(
name|encode_IF_AttributeValue
argument_list|(
name|p93
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
operator|&
name|avs_temp
operator|->
name|avseq_av
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|avs_temp
operator|=
name|avs_temp
operator|->
name|avseq_next
expr_stmt|;
block|{
comment|/* final TAG PUSHDOWN */
name|PE
name|p97_z
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p97
init|=
operator|&
name|p97_z
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|p97
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_CONT
argument_list|,
name|PE_FORM_CONS
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"final: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|p97
operator|)
operator|->
name|pe_cons
operator|=
operator|(
operator|*
name|p93
operator|)
expr_stmt|;
operator|(
operator|*
name|p93
operator|)
operator|=
operator|*
name|p97
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"element %s%d"
argument_list|,
name|PEPY_ERR_INVALID_CHOICE
argument_list|,
name|p94
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
name|seq_addon
argument_list|(
operator|(
operator|*
name|p91
operator|)
argument_list|,
name|p92
argument_list|,
operator|(
operator|*
name|p93
operator|)
argument_list|)
expr_stmt|;
name|p92
operator|=
operator|(
operator|*
name|p93
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|p91
operator|)
operator|!=
name|NULLPE
condition|)
if|if
condition|(
name|seq_add
argument_list|(
operator|(
operator|*
name|pe
operator|)
argument_list|,
operator|(
operator|*
name|p91
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings %s%s"
argument_list|,
name|PEPY_ERR_BAD_SEQ
argument_list|,
name|pe_error
argument_list|(
operator|(
operator|*
name|pe
operator|)
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/*  *	{	/* substrings TAG PUSHDOWN */
comment|/*	    PE p98_z;  *	    register PE *p98 =&p98_z;  *  *	    if ((*p98 = pe_alloc (PE_CLASS_CONT, PE_FORM_CONS, 1)) == NULLPE) {  *		advise (NULLCP, "substrings: %s", PEPY_ERR_NOMEM);  *		return NOTOK;  *	    }  *	    (*p98) -> pe_cons = (*pe);  *	    (*pe) = *p98;  *	}  */
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*  substring decoding  *  *        substrings  *                %{  *                        parm->fi_type = FILTERITEM_SUBSTRINGS;  *                        subs_next =&(parm->fi_un.fi_un_substrings);  *                        subs_next->fi_sub_initial = NULLAV;  *                        subs_next->fi_sub_any = NULLAV;  *                        subs_next->fi_sub_final = NULLAV;  *			avs_initial =&(subs_next->fi_sub_initial);  *			avs_any =&(subs_next->fi_sub_any);  *			avs_final =&(subs_next->fi_sub_final);  *                %}  *                [1] SEQUENCE  *                {  *                type  *                        AttributeType [[p&subs_next->fi_sub_type]]  *                        %{  *                        %} ,  *                strings  *                        SEQUENCE OF  *                        %{  *				av_next = AttrV_alloc();  *                        %}  *                                CHOICE  *                                {  *                                initial  *                                        [0] AttributeValue [[p av_next]]  *                                        %{  *						if (AttrV_decode (subs_next->fi_sub_type,av_next) != OK) {  *							LLOG (log_dsap,LLOG_EXCEPTIONS,("invalid initial value"));  *							return NOTOK;  *						}  *                                                (*avs_initial) = avs_comp_new(av_next);  *						avs_initial =&((*avs_initial)->avseq_next);  *						(*avs_initial) = NULLAV;  *                                        %} ,  *                                any  *                                        [1] AttributeValue [[p av_next]]  *                                        %{  *						if (AttrV_decode (subs_next->fi_sub_type,av_next) != OK) {  *							LLOG (log_dsap,LLOG_EXCEPTIONS,("invalid any value"));  *							return NOTOK;  *						}  *                                                (*avs_any) = avs_comp_new(av_next);  *						avs_any =&((*avs_any)->avseq_next);  *						(*avs_any) = NULLAV;  *                                        %} ,  *                                final  *                                        [2] AttributeValue [[p av_next]]  *                                        %{  *						if (AttrV_decode (subs_next->fi_sub_type,av_next) != OK) {  *							LLOG (log_dsap,LLOG_EXCEPTIONS,("invalid final value"));  *							return NOTOK;  *						}  *                                                (*avs_final) = avs_comp_new(av_next);  *						avs_final =&((*avs_final)->avseq_next);  *						(*avs_final) = NULLAV;  *                                        %}  *                                }  *                                %{  *                                %}  *                        %{  *                        %}  *                }  *  *  */
end_comment

begin_macro
name|substring_decode
argument_list|(
argument|pparm
argument_list|,
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|filter_item
modifier|*
modifier|*
name|pparm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|AV_Sequence
modifier|*
name|avs_initial
decl_stmt|;
name|AV_Sequence
modifier|*
name|avs_any
decl_stmt|;
name|AV_Sequence
modifier|*
name|avs_final
decl_stmt|;
name|AttributeValue
name|av_next
decl_stmt|;
name|Filter_Substrings
modifier|*
name|subs_next
decl_stmt|;
name|struct
name|filter_item
modifier|*
name|parm
decl_stmt|;
specifier|register
name|PE
name|p113
init|=
name|pe
decl_stmt|;
name|parm
operator|=
operator|*
name|pparm
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTANYMORE
block|{
comment|/* substrings TAG PULLUP */
specifier|register
name|PE
name|p114
decl_stmt|;
if|if
condition|(
operator|(
name|p114
operator|=
name|prim2set
argument_list|(
name|p113
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings %ssubstrings: %s"
argument_list|,
name|PEPY_ERR_BAD
argument_list|,
name|pe_error
argument_list|(
name|p113
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p114
operator|->
name|pe_cardinal
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings %s substrings: %d"
argument_list|,
name|PEPY_ERR_TOO_MANY_TAGGED
argument_list|,
name|p114
operator|->
name|pe_cardinal
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p113
operator|=
name|first_member
argument_list|(
name|p114
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|{
specifier|register
name|PE
name|p115
decl_stmt|;
if|if
condition|(
name|p113
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|p113
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
operator|||
name|p113
operator|->
name|pe_id
operator|!=
name|PE_CONS_SEQ
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|p113
operator|->
name|pe_class
index|]
argument_list|,
name|p113
operator|->
name|pe_form
argument_list|,
name|p113
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|{
name|parm
operator|->
name|fi_type
operator|=
name|FILTERITEM_SUBSTRINGS
expr_stmt|;
name|subs_next
operator|=
operator|&
operator|(
name|parm
operator|->
name|fi_un
operator|.
name|fi_un_substrings
operator|)
expr_stmt|;
name|subs_next
operator|->
name|fi_sub_initial
operator|=
name|NULLAV
expr_stmt|;
name|subs_next
operator|->
name|fi_sub_any
operator|=
name|NULLAV
expr_stmt|;
name|subs_next
operator|->
name|fi_sub_final
operator|=
name|NULLAV
expr_stmt|;
name|avs_initial
operator|=
operator|&
operator|(
name|subs_next
operator|->
name|fi_sub_initial
operator|)
expr_stmt|;
name|avs_any
operator|=
operator|&
operator|(
name|subs_next
operator|->
name|fi_sub_any
operator|)
expr_stmt|;
name|avs_final
operator|=
operator|&
operator|(
name|subs_next
operator|->
name|fi_sub_final
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p115
operator|=
name|prim2seq
argument_list|(
name|p113
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings %s%s"
argument_list|,
name|PEPY_ERR_BAD_SEQ
argument_list|,
name|pe_error
argument_list|(
name|p113
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p113
operator|=
name|p115
expr_stmt|;
block|{
specifier|register
name|PE
name|p116
decl_stmt|;
if|if
condition|(
operator|(
name|p116
operator|=
name|first_member
argument_list|(
name|p113
argument_list|)
operator|)
operator|!=
name|NULLPE
condition|)
block|{
name|p115
operator|=
name|p116
expr_stmt|;
block|{
comment|/* type */
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p116
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|decode_IF_AttributeType
argument_list|(
name|p116
argument_list|,
literal|1
argument_list|,
name|NULLINTP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|subs_next
operator|->
name|fi_sub_type
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
block|}
else|else
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings %stype element"
argument_list|,
name|PEPY_ERR_MISSING
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
block|{
specifier|register
name|PE
name|p117
decl_stmt|;
if|if
condition|(
operator|(
name|p117
operator|=
operator|(
name|p113
operator|!=
name|p115
condition|?
name|next_member
argument_list|(
name|p113
argument_list|,
name|p115
argument_list|)
else|:
name|first_member
argument_list|(
name|p113
argument_list|)
operator|)
operator|)
operator|!=
name|NULLPE
condition|)
block|{
name|p115
operator|=
name|p117
expr_stmt|;
block|{
comment|/* strings */
specifier|register
name|PE
name|p118
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p117
argument_list|,
literal|"strings"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p117
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|p117
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
operator|||
name|p117
operator|->
name|pe_id
operator|!=
name|PE_CONS_SEQ
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"strings bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|p117
operator|->
name|pe_class
index|]
argument_list|,
name|p117
operator|->
name|pe_form
argument_list|,
name|p117
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|p118
operator|=
name|prim2seq
argument_list|(
name|p117
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"strings %s%s"
argument_list|,
name|PEPY_ERR_BAD_SEQ
argument_list|,
name|pe_error
argument_list|(
name|p117
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p117
operator|=
name|p118
expr_stmt|;
for|for
control|(
name|p118
operator|=
name|first_member
argument_list|(
name|p117
argument_list|)
init|;
name|p118
condition|;
name|p118
operator|=
name|next_member
argument_list|(
name|p117
argument_list|,
name|p118
argument_list|)
control|)
block|{
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p118
argument_list|,
literal|"element"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|av_next
operator|=
name|AttrV_alloc
argument_list|()
expr_stmt|;
name|av_next
operator|->
name|av_syntax
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|PE_ID
argument_list|(
name|p118
operator|->
name|pe_class
argument_list|,
name|p118
operator|->
name|pe_id
argument_list|)
condition|)
block|{
case|case
name|PE_ID
argument_list|(
name|PE_CLASS_CONT
argument_list|,
literal|0
argument_list|)
case|:
comment|/* initial */
block|{
specifier|register
name|PE
name|p119
init|=
name|p118
decl_stmt|;
block|{
comment|/* initial TAG PULLUP */
specifier|register
name|PE
name|p120
decl_stmt|;
if|if
condition|(
operator|(
name|p120
operator|=
name|prim2set
argument_list|(
name|p119
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"initial %sinitial: %s"
argument_list|,
name|PEPY_ERR_BAD
argument_list|,
name|pe_error
argument_list|(
name|p119
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p120
operator|->
name|pe_cardinal
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"initial %s initial: %d"
argument_list|,
name|PEPY_ERR_TOO_MANY_TAGGED
argument_list|,
name|p120
operator|->
name|pe_cardinal
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p119
operator|=
name|first_member
argument_list|(
name|p120
argument_list|)
expr_stmt|;
block|}
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p119
argument_list|,
literal|"initial"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 					if (decode_IF_AttributeValue (p119, 1, NULLINTP, NULLVP,&av_next) == NOTOK) 					    return NOTOK; */
name|av_next
operator|->
name|av_struct
operator|=
operator|(
name|caddr_t
operator|)
name|p119
expr_stmt|;
name|p119
operator|->
name|pe_refcnt
operator|++
expr_stmt|;
block|{
if|if
condition|(
name|AttrV_decode
argument_list|(
name|subs_next
operator|->
name|fi_sub_type
argument_list|,
name|av_next
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"invalid initial value"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|avs_initial
operator|)
operator|=
name|avs_comp_new
argument_list|(
name|av_next
argument_list|)
expr_stmt|;
name|avs_initial
operator|=
operator|&
operator|(
operator|(
operator|*
name|avs_initial
operator|)
operator|->
name|avseq_next
operator|)
expr_stmt|;
operator|(
operator|*
name|avs_initial
operator|)
operator|=
name|NULLAV
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PE_ID
argument_list|(
name|PE_CLASS_CONT
argument_list|,
literal|1
argument_list|)
case|:
comment|/* any */
block|{
specifier|register
name|PE
name|p121
init|=
name|p118
decl_stmt|;
block|{
comment|/* any TAG PULLUP */
specifier|register
name|PE
name|p122
decl_stmt|;
if|if
condition|(
operator|(
name|p122
operator|=
name|prim2set
argument_list|(
name|p121
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"any %sany: %s"
argument_list|,
name|PEPY_ERR_BAD
argument_list|,
name|pe_error
argument_list|(
name|p121
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p122
operator|->
name|pe_cardinal
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"any %s any: %d"
argument_list|,
name|PEPY_ERR_TOO_MANY_TAGGED
argument_list|,
name|p122
operator|->
name|pe_cardinal
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p121
operator|=
name|first_member
argument_list|(
name|p122
argument_list|)
expr_stmt|;
block|}
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p121
argument_list|,
literal|"any"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 					if (decode_IF_AttributeValue (p121, 1, NULLINTP, NULLVP,&av_next) == NOTOK) 					    return NOTOK; */
name|av_next
operator|->
name|av_struct
operator|=
operator|(
name|caddr_t
operator|)
name|p121
expr_stmt|;
name|p121
operator|->
name|pe_refcnt
operator|++
expr_stmt|;
block|{
if|if
condition|(
name|AttrV_decode
argument_list|(
name|subs_next
operator|->
name|fi_sub_type
argument_list|,
name|av_next
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"invalid any value"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|avs_any
operator|)
operator|=
name|avs_comp_new
argument_list|(
name|av_next
argument_list|)
expr_stmt|;
name|avs_any
operator|=
operator|&
operator|(
operator|(
operator|*
name|avs_any
operator|)
operator|->
name|avseq_next
operator|)
expr_stmt|;
operator|(
operator|*
name|avs_any
operator|)
operator|=
name|NULLAV
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PE_ID
argument_list|(
name|PE_CLASS_CONT
argument_list|,
literal|2
argument_list|)
case|:
comment|/* final */
block|{
specifier|register
name|PE
name|p123
init|=
name|p118
decl_stmt|;
block|{
comment|/* final TAG PULLUP */
specifier|register
name|PE
name|p124
decl_stmt|;
if|if
condition|(
operator|(
name|p124
operator|=
name|prim2set
argument_list|(
name|p123
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"final %sfinal: %s"
argument_list|,
name|PEPY_ERR_BAD
argument_list|,
name|pe_error
argument_list|(
name|p123
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p124
operator|->
name|pe_cardinal
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"final %s final: %d"
argument_list|,
name|PEPY_ERR_TOO_MANY_TAGGED
argument_list|,
name|p124
operator|->
name|pe_cardinal
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p123
operator|=
name|first_member
argument_list|(
name|p124
argument_list|)
expr_stmt|;
block|}
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p123
argument_list|,
literal|"final"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  					if (decode_IF_AttributeValue (p123, 1, NULLINTP, NULLVP,&av_next) == NOTOK) 					    return NOTOK; */
name|av_next
operator|->
name|av_struct
operator|=
operator|(
name|caddr_t
operator|)
name|p123
expr_stmt|;
name|p123
operator|->
name|pe_refcnt
operator|++
expr_stmt|;
block|{
if|if
condition|(
name|AttrV_decode
argument_list|(
name|subs_next
operator|->
name|fi_sub_type
argument_list|,
name|av_next
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"invalid final value"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|avs_final
operator|)
operator|=
name|avs_comp_new
argument_list|(
name|av_next
argument_list|)
expr_stmt|;
name|avs_final
operator|=
operator|&
operator|(
operator|(
operator|*
name|avs_final
operator|)
operator|->
name|avseq_next
operator|)
expr_stmt|;
operator|(
operator|*
name|avs_final
operator|)
operator|=
name|NULLAV
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"element %s%s/%d/0x%x"
argument_list|,
name|PEPY_ERR_UNKNOWN_CHOICE
argument_list|,
name|pe_classlist
index|[
name|p118
operator|->
name|pe_class
index|]
argument_list|,
name|p118
operator|->
name|pe_form
argument_list|,
name|p118
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings %sstrings element"
argument_list|,
name|PEPY_ERR_MISSING
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
if|if
condition|(
name|p113
operator|->
name|pe_cardinal
operator|>
literal|2
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"substrings %s(2): %d"
argument_list|,
name|PEPY_ERR_TOO_MANY_ELEMENTS
argument_list|,
name|p113
operator|->
name|pe_cardinal
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/* TreeStructureSyntax encode */
end_comment

begin_comment
comment|/*  *  *TreeStructureSyntax [[P struct tree_struct *]]  *%{  *OID     oid_tmp;  *int	do_once;  *%}  *        ::=  *        %{  *                DLOG(log_dsap, LLOG_PDUS, ("About to encode TreeStructureSyntax"));  *		if (parm->tree_object == NULLOBJECTCLASS) {  *	                DLOG(log_dsap, LLOG_DEBUG, ("NULL OID in tree structure"));  *			oid_tmp = NULLOID;  *		} else {  *	                oid_tmp = oid_cpy(parm->tree_object->oc_ot.ot_oid);  *	                DLOG(log_dsap, LLOG_DEBUG, ("oc encodes as oid: %s", sprintoid(oid_tmp)));  *		}  *        %}  *        SET  *	{  *	mandatoryObjectClasses  *		[1] SET OF  *		%{  *	                DLOG(log_dsap, LLOG_DEBUG, ("Another mandatory oc"));  *		%}  *<<do_once = 1; do_once != 0; do_once = 0>>  *                	OBJECT IDENTIFIER [[O oid_tmp]] ,  *	optionalObjectClasses  *		[2] SET OF  *                	OBJECT IDENTIFIER  *		    -- OPTIONAL<<FALSE>> ,  *		    OPTIONAL ,  *	permittedRDNs  *		[3] SET OF  *			SET OF  *				AttributeType [[p NULLAttrT]]  *	}  *        %{  *		if(oid_tmp != NULLOID)  *		    oid_free (oid_tmp);  *                DLOG(log_dsap, LLOG_PDUS, ("Done encode TreeStructureSyntax"));  *        %}  *  */
end_comment

begin_macro
name|treestruct_encode
argument_list|(
argument|parm
argument_list|,
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tree_struct
modifier|*
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|OID
name|oid_tmp
decl_stmt|;
name|int
name|do_once
decl_stmt|;
name|PE
name|p23_z
init|=
name|NULLPE
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p23
init|=
operator|&
name|p23_z
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|pe
operator|)
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|PE_CONS_SET
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"TreeStructureSyntax: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|{
if|if
condition|(
name|parm
operator|->
name|tree_object
operator|==
name|NULLOBJECTCLASS
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"NULL OID in tree structure"
operator|)
argument_list|)
expr_stmt|;
name|oid_tmp
operator|=
name|NULLOID
expr_stmt|;
block|}
else|else
block|{
name|oid_tmp
operator|=
name|oid_cpy
argument_list|(
name|parm
operator|->
name|tree_object
operator|->
name|oc_ot
operator|.
name|ot_oid
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"oc encodes as oid: %s"
operator|,
name|sprintoid
argument_list|(
name|oid_tmp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|p23
operator|)
operator|=
name|NULLPE
expr_stmt|;
block|{
name|PE
name|p24
init|=
name|NULLPE
decl_stmt|;
name|PE
name|p25_z
init|=
name|NULLPE
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p25
init|=
operator|&
name|p25_z
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|p23
operator|)
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|PE_CONS_SET
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"mandatoryObjectClasses: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|do_once
operator|=
literal|1
init|;
name|do_once
operator|!=
literal|0
condition|;
name|do_once
operator|=
literal|0
control|)
block|{
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Another mandatory oc"
operator|)
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|OID
name|p26
decl_stmt|;
name|p26
operator|=
name|oid_tmp
expr_stmt|;
if|if
condition|(
name|p26
operator|==
name|NULLOID
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"member %s"
argument_list|,
name|PEPY_ERR_INIT_FAILED
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|p25
operator|)
operator|=
name|obj2prim
argument_list|(
name|p26
argument_list|,
name|PE_CLASS_UNIV
argument_list|,
name|PE_PRIM_OID
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"member: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
operator|(
operator|*
name|p25
operator|)
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|set_addon
argument_list|(
operator|(
operator|*
name|p23
operator|)
argument_list|,
name|p24
argument_list|,
operator|(
operator|*
name|p25
operator|)
argument_list|)
expr_stmt|;
name|p24
operator|=
operator|(
operator|*
name|p25
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
operator|(
operator|*
name|p23
operator|)
argument_list|,
literal|"mandatoryObjectClasses"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
comment|/* mandatoryObjectClasses TAG PUSHDOWN */
name|PE
name|p27_z
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p27
init|=
operator|&
name|p27_z
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|p27
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_CONT
argument_list|,
name|PE_FORM_CONS
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"mandatoryObjectClasses: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|p27
operator|)
operator|->
name|pe_cons
operator|=
operator|(
operator|*
name|p23
operator|)
expr_stmt|;
operator|(
operator|*
name|p23
operator|)
operator|=
operator|*
name|p27
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|p23
operator|)
operator|!=
name|NULLPE
condition|)
if|if
condition|(
name|set_add
argument_list|(
operator|(
operator|*
name|pe
operator|)
argument_list|,
operator|(
operator|*
name|p23
operator|)
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"TreeStructureSyntax %s%s"
argument_list|,
name|PEPY_ERR_BAD_SET
argument_list|,
name|pe_error
argument_list|(
operator|(
operator|*
name|pe
operator|)
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|p23
operator|)
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p23
operator|)
operator|!=
name|NULLPE
condition|)
if|if
condition|(
name|set_add
argument_list|(
operator|(
operator|*
name|pe
operator|)
argument_list|,
operator|(
operator|*
name|p23
operator|)
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"TreeStructureSyntax %s%s"
argument_list|,
name|PEPY_ERR_BAD_SET
argument_list|,
name|pe_error
argument_list|(
operator|(
operator|*
name|pe
operator|)
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|p23
operator|)
operator|=
name|NULLPE
expr_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|p23
operator|)
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|PE_CONS_SET
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"permittedRDNs: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
operator|(
operator|*
name|p23
operator|)
argument_list|,
literal|"permittedRDNs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
comment|/* permittedRDNs TAG PUSHDOWN */
name|PE
name|p30_z
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p30
init|=
operator|&
name|p30_z
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|p30
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_CONT
argument_list|,
name|PE_FORM_CONS
argument_list|,
literal|3
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"permittedRDNs: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
operator|*
name|p30
operator|)
operator|->
name|pe_cons
operator|=
operator|(
operator|*
name|p23
operator|)
expr_stmt|;
operator|(
operator|*
name|p23
operator|)
operator|=
operator|*
name|p30
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|p23
operator|)
operator|!=
name|NULLPE
condition|)
if|if
condition|(
name|set_add
argument_list|(
operator|(
operator|*
name|pe
operator|)
argument_list|,
operator|(
operator|*
name|p23
operator|)
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"TreeStructureSyntax %s%s"
argument_list|,
name|PEPY_ERR_BAD_SET
argument_list|,
name|pe_error
argument_list|(
operator|(
operator|*
name|pe
operator|)
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
operator|(
operator|*
name|pe
operator|)
argument_list|,
literal|"Quipu.TreeStructureSyntax"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|oid_tmp
operator|!=
name|NULLOID
condition|)
name|oid_free
argument_list|(
name|oid_tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/* TreeStructSyntax decode */
end_comment

begin_comment
comment|/*  *  *TreeStructureSyntax [[P struct tree_struct **]]  *%{  *AttributeType	  at_tmp;  *OID     oid_tmp;  *int	is_first;  *objectclass * oc_add();  *%}  *        ::=  *        %{  *                DLOG(log_dsap, LLOG_PDUS, ("About to decode TreeStructureSyntax"));  *		is_first = 1;  *        %}  *        SET  *	{  *	mandatoryObjectClasses  *		[1] SET OF  *                	OBJECT IDENTIFIER [[O oid_tmp]]  *                	%{  *				if(is_first != 0)  *				{  *                			(*parm) = tree_struct_alloc();  *                        		if (((*parm)->tree_object = oid2oc(oid_tmp)) == NULLOBJECTCLASS)  *						(*parm)->tree_object = oc_add (oid_tmp);  *					is_first = 0;  *				}  *				else  *				{  *					LLOG(log_dsap, LLOG_EXCEPTIONS, ("Multiple mandatory object classes"));  *				}  *                	%} ,  *	optionalObjectClasses  *		[2] SET OF  *                	OBJECT IDENTIFIER  *		    OPTIONAL ,  *	permittedRDNs  *		[3] SET OF  *			SET OF  *				AttributeType [[p& at_tmp]]  *				%{  *				%}  *	}  *        %{  *                DLOG(log_dsap, LLOG_PDUS, ("Done decode TreeStructureSyntax"));  *        %}  *  *  */
end_comment

begin_macro
name|treestruct_decode
argument_list|(
argument|parm
argument_list|,
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tree_struct
modifier|*
modifier|*
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|AttributeType
name|at_tmp
decl_stmt|;
name|OID
name|oid_tmp
decl_stmt|;
name|int
name|is_first
decl_stmt|;
name|objectclass
modifier|*
name|oc_add
parameter_list|()
function_decl|;
name|char
name|explicit
init|=
literal|0
decl_stmt|;
name|int
name|p34_count
init|=
literal|0
decl_stmt|;
specifier|register
name|PE
name|p34
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|pe
argument_list|,
literal|"Quipu.TreeStructureSyntax"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|explicit
condition|)
block|{
if|if
condition|(
name|pe
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|pe
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
operator|||
name|pe
operator|->
name|pe_id
operator|!=
name|PE_CONS_SET
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"TreeStructureSyntax bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|pe
operator|->
name|pe_class
index|]
argument_list|,
name|pe
operator|->
name|pe_form
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pe
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"TreeStructureSyntax bad form: %d"
argument_list|,
name|pe
operator|->
name|pe_form
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|{
name|is_first
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p34
operator|=
name|prim2set
argument_list|(
name|pe
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"TreeStructureSyntax %s%s"
argument_list|,
name|PEPY_ERR_BAD_SET
argument_list|,
name|pe_error
argument_list|(
name|pe
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|pe
operator|=
name|p34
expr_stmt|;
if|if
condition|(
name|p34
operator|=
name|set_find
argument_list|(
name|pe
argument_list|,
name|PE_CLASS_CONT
argument_list|,
literal|1
argument_list|)
condition|)
block|{
specifier|register
name|PE
name|p35
init|=
name|p34
decl_stmt|;
block|{
comment|/* mandatoryObjectClasses TAG PULLUP */
specifier|register
name|PE
name|p36
decl_stmt|;
if|if
condition|(
operator|(
name|p36
operator|=
name|prim2set
argument_list|(
name|p35
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"mandatoryObjectClasses %smandatoryObjectClasses: %s"
argument_list|,
name|PEPY_ERR_BAD
argument_list|,
name|pe_error
argument_list|(
name|p35
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p36
operator|->
name|pe_cardinal
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"mandatoryObjectClasses %s mandatoryObjectClasses: %d"
argument_list|,
name|PEPY_ERR_TOO_MANY_TAGGED
argument_list|,
name|p36
operator|->
name|pe_cardinal
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p35
operator|=
name|first_member
argument_list|(
name|p36
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|PE
name|p37
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p35
argument_list|,
literal|"mandatoryObjectClasses"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p35
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|p35
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
operator|||
name|p35
operator|->
name|pe_id
operator|!=
name|PE_CONS_SET
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"mandatoryObjectClasses bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|p35
operator|->
name|pe_class
index|]
argument_list|,
name|p35
operator|->
name|pe_form
argument_list|,
name|p35
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|p37
operator|=
name|prim2set
argument_list|(
name|p35
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"mandatoryObjectClasses %s%s"
argument_list|,
name|PEPY_ERR_BAD_SET
argument_list|,
name|pe_error
argument_list|(
name|p35
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p35
operator|=
name|p37
expr_stmt|;
for|for
control|(
name|p37
operator|=
name|first_member
argument_list|(
name|p35
argument_list|)
init|;
name|p37
condition|;
name|p37
operator|=
name|next_member
argument_list|(
name|p35
argument_list|,
name|p37
argument_list|)
control|)
block|{
specifier|register
name|OID
name|p38
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p37
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p37
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|p37
operator|->
name|pe_form
operator|!=
name|PE_FORM_PRIM
operator|||
name|p37
operator|->
name|pe_id
operator|!=
name|PE_PRIM_OID
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"member bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|p37
operator|->
name|pe_class
index|]
argument_list|,
name|p37
operator|->
name|pe_form
argument_list|,
name|p37
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|p38
operator|=
name|prim2oid
argument_list|(
name|p37
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"member %s%s"
argument_list|,
name|PEPY_ERR_BAD_OID
argument_list|,
name|pe_error
argument_list|(
name|p37
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/* Spurious copy noticed by Jim Reed                 oid_tmp = oid_cpy (p38); */
name|oid_tmp
operator|=
name|p38
expr_stmt|;
block|{
if|if
condition|(
name|is_first
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|parm
operator|)
operator|=
name|tree_struct_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|parm
operator|)
operator|->
name|tree_object
operator|=
name|oid2oc
argument_list|(
name|oid_tmp
argument_list|)
operator|)
operator|==
name|NULLOBJECTCLASS
condition|)
operator|(
operator|*
name|parm
operator|)
operator|->
name|tree_object
operator|=
name|oc_add
argument_list|(
name|oid_tmp
argument_list|)
expr_stmt|;
name|is_first
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Multiple mandatory object classes"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|p34_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"mandatoryObjectClasses %s mandatoryObjectClasses member"
argument_list|,
name|PEPY_ERR_MISSING
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p34
operator|=
name|set_find
argument_list|(
name|pe
argument_list|,
name|PE_CLASS_CONT
argument_list|,
literal|2
argument_list|)
condition|)
block|{
specifier|register
name|PE
name|p39
init|=
name|p34
decl_stmt|;
block|{
comment|/* optionalObjectClasses TAG PULLUP */
specifier|register
name|PE
name|p40
decl_stmt|;
if|if
condition|(
operator|(
name|p40
operator|=
name|prim2set
argument_list|(
name|p39
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"optionalObjectClasses %soptionalObjectClasses: %s"
argument_list|,
name|PEPY_ERR_BAD
argument_list|,
name|pe_error
argument_list|(
name|p39
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p40
operator|->
name|pe_cardinal
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"optionalObjectClasses %s optionalObjectClasses: %d"
argument_list|,
name|PEPY_ERR_TOO_MANY_TAGGED
argument_list|,
name|p40
operator|->
name|pe_cardinal
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p39
operator|=
name|first_member
argument_list|(
name|p40
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|PE
name|p41
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p39
argument_list|,
literal|"optionalObjectClasses"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p39
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|p39
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
operator|||
name|p39
operator|->
name|pe_id
operator|!=
name|PE_CONS_SET
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"optionalObjectClasses bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|p39
operator|->
name|pe_class
index|]
argument_list|,
name|p39
operator|->
name|pe_form
argument_list|,
name|p39
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|p41
operator|=
name|prim2set
argument_list|(
name|p39
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"optionalObjectClasses %s%s"
argument_list|,
name|PEPY_ERR_BAD_SET
argument_list|,
name|pe_error
argument_list|(
name|p39
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p39
operator|=
name|p41
expr_stmt|;
for|for
control|(
name|p41
operator|=
name|first_member
argument_list|(
name|p39
argument_list|)
init|;
name|p41
condition|;
name|p41
operator|=
name|next_member
argument_list|(
name|p39
argument_list|,
name|p41
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p41
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p41
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|p41
operator|->
name|pe_form
operator|!=
name|PE_FORM_PRIM
operator|||
name|p41
operator|->
name|pe_id
operator|!=
name|PE_PRIM_OID
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"member bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|p41
operator|->
name|pe_class
index|]
argument_list|,
name|p41
operator|->
name|pe_form
argument_list|,
name|p41
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|prim2oid
argument_list|(
name|p41
argument_list|)
operator|==
name|NULLOID
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"member %s%s"
argument_list|,
name|PEPY_ERR_BAD_OID
argument_list|,
name|pe_error
argument_list|(
name|p41
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
block|}
name|p34_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p34
operator|=
name|set_find
argument_list|(
name|pe
argument_list|,
name|PE_CLASS_CONT
argument_list|,
literal|3
argument_list|)
condition|)
block|{
specifier|register
name|PE
name|p42
init|=
name|p34
decl_stmt|;
block|{
comment|/* permittedRDNs TAG PULLUP */
specifier|register
name|PE
name|p43
decl_stmt|;
if|if
condition|(
operator|(
name|p43
operator|=
name|prim2set
argument_list|(
name|p42
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"permittedRDNs %spermittedRDNs: %s"
argument_list|,
name|PEPY_ERR_BAD
argument_list|,
name|pe_error
argument_list|(
name|p42
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p43
operator|->
name|pe_cardinal
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"permittedRDNs %s permittedRDNs: %d"
argument_list|,
name|PEPY_ERR_TOO_MANY_TAGGED
argument_list|,
name|p43
operator|->
name|pe_cardinal
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p42
operator|=
name|first_member
argument_list|(
name|p43
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|PE
name|p44
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p42
argument_list|,
literal|"permittedRDNs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p42
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|p42
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
operator|||
name|p42
operator|->
name|pe_id
operator|!=
name|PE_CONS_SET
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"permittedRDNs bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|p42
operator|->
name|pe_class
index|]
argument_list|,
name|p42
operator|->
name|pe_form
argument_list|,
name|p42
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|p44
operator|=
name|prim2set
argument_list|(
name|p42
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"permittedRDNs %s%s"
argument_list|,
name|PEPY_ERR_BAD_SET
argument_list|,
name|pe_error
argument_list|(
name|p42
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p42
operator|=
name|p44
expr_stmt|;
for|for
control|(
name|p44
operator|=
name|first_member
argument_list|(
name|p42
argument_list|)
init|;
name|p44
condition|;
name|p44
operator|=
name|next_member
argument_list|(
name|p42
argument_list|,
name|p44
argument_list|)
control|)
block|{
specifier|register
name|PE
name|p45
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p44
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p44
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|p44
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
operator|||
name|p44
operator|->
name|pe_id
operator|!=
name|PE_CONS_SET
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"member bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|p44
operator|->
name|pe_class
index|]
argument_list|,
name|p44
operator|->
name|pe_form
argument_list|,
name|p44
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|p45
operator|=
name|prim2set
argument_list|(
name|p44
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"member %s%s"
argument_list|,
name|PEPY_ERR_BAD_SET
argument_list|,
name|pe_error
argument_list|(
name|p44
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p44
operator|=
name|p45
expr_stmt|;
for|for
control|(
name|p45
operator|=
name|first_member
argument_list|(
name|p44
argument_list|)
init|;
name|p45
condition|;
name|p45
operator|=
name|next_member
argument_list|(
name|p44
argument_list|,
name|p45
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|testdebug
argument_list|(
name|p45
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|decode_IF_AttributeType
argument_list|(
name|p45
argument_list|,
literal|1
argument_list|,
name|NULLINTP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|at_tmp
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
block|}
block|}
name|p34_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"permittedRDNs %s permittedRDNs member"
argument_list|,
name|PEPY_ERR_MISSING
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p34_count
operator|!=
name|pe
operator|->
name|pe_cardinal
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|PEPY_ERR_EXTRA_MEMBERS
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_macro
name|EDB_encode
argument_list|(
argument|parm
argument_list|,
argument|pe
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|getedb_result
modifier|*
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PE
modifier|*
name|pe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|entry
modifier|*
name|ent_tmp
decl_stmt|;
name|PE
name|p31
init|=
name|NULLPE
decl_stmt|;
name|PE
name|p32_z
init|=
name|NULLPE
decl_stmt|;
specifier|register
name|PE
modifier|*
name|p32
init|=
operator|&
name|p32_z
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|pe
operator|)
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|PE_CONS_SEQ
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"EntryDataBlock: %s"
argument_list|,
name|PEPY_ERR_NOMEM
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
for|for
control|(
name|ent_tmp
operator|=
operator|(
name|Entry
operator|)
name|avl_getfirst
argument_list|(
name|parm
operator|->
name|gr_edb
argument_list|)
init|;
name|ent_tmp
operator|!=
name|NULLENTRY
condition|;
name|ent_tmp
operator|=
operator|(
name|Entry
operator|)
name|avl_getnext
argument_list|()
control|)
block|{
else|#
directive|else
for|for
control|(
name|ent_tmp
operator|=
name|parm
operator|->
name|gr_edb
init|;
name|ent_tmp
operator|!=
name|NULLENTRY
condition|;
name|ent_tmp
operator|=
name|ent_tmp
operator|->
name|e_sibling
control|)
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|ent_tmp
operator|->
name|e_data
operator|!=
name|E_DATA_MASTER
operator|)
operator|&&
operator|(
name|ent_tmp
operator|->
name|e_data
operator|!=
name|E_TYPE_SLAVE
operator|)
condition|)
continue|continue;
if|if
condition|(
name|encode_Quipu_RelativeEntry
argument_list|(
name|p32
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
name|ent_tmp
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|seq_addon
argument_list|(
operator|(
operator|*
name|pe
operator|)
argument_list|,
name|p31
argument_list|,
operator|(
operator|*
name|p32
operator|)
argument_list|)
expr_stmt|;
name|p31
operator|=
operator|(
operator|*
name|p32
operator|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
name|EDB_decode
argument_list|(
argument|pparm
argument_list|,
argument|pe
argument_list|)
name|struct
name|getedb_result
modifier|*
modifier|*
name|pparm
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TURBO_AVL
name|Avlnode
modifier|*
modifier|*
name|tree
decl_stmt|;
name|struct
name|entry
modifier|*
name|tmp
decl_stmt|;
name|int
name|entry_cmp
parameter_list|()
function_decl|;
else|#
directive|else
name|struct
name|entry
modifier|*
modifier|*
name|ent_tmp
decl_stmt|;
endif|#
directive|endif
specifier|register
name|PE
name|p46
decl_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_class
operator|!=
name|PE_CLASS_UNIV
operator|||
name|pe
operator|->
name|pe_form
operator|!=
name|PE_FORM_CONS
operator|||
name|pe
operator|->
name|pe_id
operator|!=
name|PE_CONS_SEQ
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"EntryDataBlock bad class/form/id: %s/%d/0x%x"
argument_list|,
name|pe_classlist
index|[
name|pe
operator|->
name|pe_class
index|]
argument_list|,
name|pe
operator|->
name|pe_form
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|p46
operator|=
name|prim2seq
argument_list|(
name|pe
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"EntryDataBlock %s%s"
argument_list|,
name|PEPY_ERR_BAD_SEQ
argument_list|,
name|pe_error
argument_list|(
name|pe
operator|->
name|pe_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|pe
operator|=
name|p46
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
operator|(
operator|*
name|pparm
operator|)
operator|->
name|gr_edb
operator|=
name|NULLAVL
expr_stmt|;
name|tree
operator|=
operator|&
operator|(
operator|(
operator|*
name|pparm
operator|)
operator|->
name|gr_edb
operator|)
expr_stmt|;
else|#
directive|else
operator|(
operator|*
operator|(
operator|*
name|pparm
operator|)
operator|)
operator|=
name|NULLENTRY
expr_stmt|;
name|ent_tmp
operator|=
operator|&
operator|(
operator|(
operator|*
name|pparm
operator|)
operator|->
name|gr_edb
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p46
operator|=
name|first_member
argument_list|(
name|pe
argument_list|)
init|;
name|p46
condition|;
name|p46
operator|=
name|next_member
argument_list|(
name|pe
argument_list|,
name|p46
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|TURBO_AVL
if|if
condition|(
name|decode_Quipu_RelativeEntry
argument_list|(
name|p46
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|tmp
operator|->
name|e_leaf
operator|=
name|TRUE
expr_stmt|;
name|tmp
operator|->
name|e_complete
operator|=
name|TRUE
expr_stmt|;
name|tmp
operator|->
name|e_data
operator|=
name|E_TYPE_SLAVE
expr_stmt|;
if|if
condition|(
name|avl_insert
argument_list|(
name|tree
argument_list|,
name|tmp
argument_list|,
name|entry_cmp
argument_list|,
name|avl_dup_error
argument_list|)
operator|==
name|NOTOK
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Bad EDB update (contains duplicates)"
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|decode_Quipu_RelativeEntry
argument_list|(
name|p46
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|ent_tmp
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
operator|*
name|ent_tmp
operator|)
operator|->
name|e_leaf
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|ent_tmp
operator|)
operator|->
name|e_complete
operator|=
name|TRUE
expr_stmt|;
operator|(
operator|*
name|ent_tmp
operator|)
operator|->
name|e_data
operator|=
name|E_TYPE_SLAVE
expr_stmt|;
name|ent_tmp
operator|=
operator|&
operator|(
operator|(
operator|*
name|ent_tmp
operator|)
operator|->
name|e_sibling
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|TURBO_AVL
operator|*
name|ent_tmp
operator|=
name|NULLENTRY
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_block

end_unit

