begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tsaprovider.c - implement the transport service */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/tsap/RCS/tsaprovider.c,v 7.7 91/02/22 09:47:43 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/tsap/RCS/tsaprovider.c,v 7.7 91/02/22 09:47:43 mrose Interim $  *  *  * $Log:	tsaprovider.c,v $  * Revision 7.7  91/02/22  09:47:43  mrose  * Interim 6.8  *   * Revision 7.6  90/11/21  11:31:36  mrose  * sun  *   * Revision 7.5  90/10/29  18:39:17  mrose  * updates  *   * Revision 7.4  90/08/08  14:14:08  mrose  * update  *   * Revision 7.3  90/03/23  17:31:50  mrose  * 8  *   * Revision 7.2  90/01/11  18:38:09  mrose  * real-sync  *   * Revision 7.1  89/12/07  01:07:53  mrose  * queued writes  *   * Revision 7.0  89/11/23  22:30:56  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"tpkt.h"
end_include

begin_include
include|#
directive|include
file|"mpkt.h"
end_include

begin_include
include|#
directive|include
file|"isoservent.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_define
define|#
directive|define
name|selmask
parameter_list|(
name|fd
parameter_list|,
name|m
parameter_list|,
name|n
parameter_list|)
define|\
value|{ \     FD_SET (fd,&(m)); \     if ((fd)>= (n)) \ 	(n) = (fd) + 1; \ }
end_define

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
specifier|static
name|int
name|once_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tsapblk
name|tsapque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tsapblk
modifier|*
name|THead
init|=
operator|&
name|tsapque
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SIGPOLL
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|TPid
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|xselect_blocking_on_intr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|T-DATA.REQUEST */
end_comment

begin_function
name|int
name|TDataRequest
parameter_list|(
name|sd
parameter_list|,
name|data
parameter_list|,
name|cc
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|,
name|imask
decl_stmt|;
name|SFP
name|istat
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|udvec
name|uvs
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|struct
name|udvec
modifier|*
name|uv
init|=
name|uvs
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|missingP
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"illegal value for TSDU length (%d)"
argument_list|,
name|cc
argument_list|)
return|;
name|missingP
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|tsapPsig
argument_list|(
name|tb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
operator|)
operator|!=
name|SIG_DFL
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|imask
operator|=
name|siginblock
argument_list|()
expr_stmt|;
block|}
name|uv
operator|->
name|uv_base
operator|=
name|data
operator|,
name|uv
operator|->
name|uv_len
operator|=
name|cc
operator|,
name|uv
operator|++
expr_stmt|;
name|uv
operator|->
name|uv_base
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|tb
operator|->
name|tb_writePfnx
call|)
argument_list|(
name|tb
argument_list|,
name|uvs
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|!=
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|siginmask
argument_list|(
name|imask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|T-EXPEDITED-DATA.REQUEST */
end_comment

begin_function
name|int
name|TExpdRequest
parameter_list|(
name|sd
parameter_list|,
name|data
parameter_list|,
name|cc
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|,
name|imask
decl_stmt|;
name|SFP
name|istat
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|udvec
name|uvs
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|struct
name|udvec
modifier|*
name|uv
init|=
name|uvs
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|missingP
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|toomuchP
argument_list|(
name|data
argument_list|,
name|cc
argument_list|,
name|TX_SIZE
argument_list|,
literal|"expedited"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"illegal value for XSDU length (%d)"
argument_list|,
name|cc
argument_list|)
return|;
name|missingP
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|tsapPsig
argument_list|(
name|tb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
operator|)
operator|!=
name|SIG_DFL
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|imask
operator|=
name|siginblock
argument_list|()
expr_stmt|;
block|}
name|uv
operator|->
name|uv_base
operator|=
name|data
operator|,
name|uv
operator|->
name|uv_len
operator|=
name|cc
operator|,
name|uv
operator|++
expr_stmt|;
name|uv
operator|->
name|uv_base
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_flags
operator|&
name|TB_EXPD
condition|)
name|result
operator|=
call|(
modifier|*
name|tb
operator|->
name|tb_writePfnx
call|)
argument_list|(
name|tb
argument_list|,
name|uvs
argument_list|,
literal|1
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_OPERATION
argument_list|,
name|NULLCP
argument_list|,
literal|"expedited service unavailable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|!=
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|siginmask
argument_list|(
name|imask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|T-WRITE.REQUEST (pseudo; write user data vectors) */
end_comment

begin_function
name|int
name|TWriteRequest
parameter_list|(
name|sd
parameter_list|,
name|uv
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
name|struct
name|udvec
modifier|*
name|uv
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|SBV
name|smask
decl_stmt|,
name|imask
decl_stmt|;
name|SFP
name|istat
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
specifier|register
name|struct
name|udvec
modifier|*
name|vv
decl_stmt|;
name|missingP
argument_list|(
name|uv
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vv
operator|=
name|uv
init|;
name|vv
operator|->
name|uv_base
condition|;
name|vv
operator|++
control|)
name|n
operator|+=
name|vv
operator|->
name|uv_len
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"zero-length TSDU"
argument_list|)
return|;
name|missingP
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|tsapPsig
argument_list|(
name|tb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
operator|)
operator|!=
name|SIG_DFL
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|imask
operator|=
name|siginblock
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
call|(
modifier|*
name|tb
operator|->
name|tb_writePfnx
call|)
argument_list|(
name|tb
argument_list|,
name|uv
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|!=
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|siginmask
argument_list|(
name|imask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|T-READ.REQUEST (pseudo; synchronous read) */
end_comment

begin_function
name|int
name|TReadRequest
parameter_list|(
name|sd
parameter_list|,
name|tx
parameter_list|,
name|secs
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|TSAPdata
modifier|*
name|tx
decl_stmt|;
name|int
name|secs
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|,
name|imask
decl_stmt|;
name|SFP
name|istat
decl_stmt|;
name|int
name|nfds
decl_stmt|,
name|oob
decl_stmt|,
name|result
decl_stmt|;
name|fd_set
name|ifds
decl_stmt|,
name|efds
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|missingP
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|tsapPsig
argument_list|(
name|tb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
operator|)
operator|!=
name|SIG_DFL
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|imask
operator|=
name|siginblock
argument_list|()
expr_stmt|;
block|}
name|nfds
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|selmask
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|mask
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ifds
operator|=
name|efds
operator|=
name|mask
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|tb
operator|->
name|tb_checkfnx
operator|==
name|NULLIFP
operator|||
call|(
modifier|*
name|tb
operator|->
name|tb_checkfnx
call|)
argument_list|(
name|tb
argument_list|)
operator|!=
name|OK
condition|)
switch|switch
condition|(
call|(
modifier|*
name|tb
operator|->
name|tb_selectfnx
call|)
argument_list|(
name|nfds
argument_list|,
operator|&
name|ifds
argument_list|,
name|NULLFD
argument_list|,
operator|&
name|efds
argument_list|,
name|secs
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
comment|/* let read function find error... */
name|ifds
operator|=
name|mask
expr_stmt|;
break|break;
case|case
name|OK
case|:
name|result
operator|=
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_TIMER
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
break|break;
block|}
else|else
name|FD_ZERO
argument_list|(
operator|&
name|efds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oob
operator|=
name|FD_ISSET
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
operator|&
name|efds
argument_list|)
operator|)
operator|||
name|FD_ISSET
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
operator|&
name|ifds
argument_list|)
condition|)
name|result
operator|=
call|(
modifier|*
name|tb
operator|->
name|tb_readPfnx
call|)
argument_list|(
name|tb
argument_list|,
name|tx
argument_list|,
name|td
argument_list|,
name|secs
operator|!=
name|NOTOK
argument_list|,
name|oob
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|DONE
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|DONE
condition|)
break|break;
if|if
condition|(
name|secs
operator|!=
name|NOTOK
condition|)
block|{
name|result
operator|=
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_TIMER
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
empty_stmt|;
if|if
condition|(
name|istat
operator|!=
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|siginmask
argument_list|(
name|imask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|T-DISCONNECT.REQUEST */
end_comment

begin_function
name|int
name|TDiscRequest
parameter_list|(
name|sd
parameter_list|,
name|data
parameter_list|,
name|cc
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|cc
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|toomuchP
argument_list|(
name|data
argument_list|,
name|cc
argument_list|,
name|TD_SIZE
argument_list|,
literal|"disconnect"
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|=
name|findtblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"invalid transport descriptor"
argument_list|)
return|;
block|}
name|result
operator|=
call|(
modifier|*
name|tb
operator|->
name|tb_discPfnx
call|)
argument_list|(
name|tb
argument_list|,
name|data
argument_list|,
name|cc
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|set asynchronous event indications */
end_comment

begin_function_decl
specifier|static
name|SFD
name|DATAser
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|TSetIndications
parameter_list|(
name|sd
parameter_list|,
name|data
parameter_list|,
name|disc
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
name|IFP
name|data
decl_stmt|,
name|disc
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
if|if
condition|(
name|data
operator|||
name|disc
condition|)
block|{
name|missingP
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|disc
argument_list|)
expr_stmt|;
block|}
name|_iosignals_set
operator|=
literal|1
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
name|tsapPsig
argument_list|(
name|tb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_DataIndication
operator|=
name|data
condition|)
block|{
name|tb
operator|->
name|tb_flags
operator||=
name|TB_ASYN
expr_stmt|;
name|xselect_blocking_on_intr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tb
operator|->
name|tb_flags
operator|&=
operator|~
name|TB_ASYN
expr_stmt|;
name|xselect_blocking_on_intr
operator|=
literal|0
expr_stmt|;
block|}
name|tb
operator|->
name|tb_DiscIndication
operator|=
name|disc
expr_stmt|;
name|result
operator|=
name|TWakeUp
argument_list|(
name|tb
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* Kick the signal handling routine once to make it hand up the      * indications that were queued in the kernel when TSetIndications      * was called.      * TBD: We could be more efficient by only doing this for only      * one file descriptor.      */
operator|(
name|void
operator|)
name|DATAser
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
operator|(
operator|(
expr|struct
name|sigcontext
operator|*
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|map transport descriptors for select() */
end_comment

begin_function
name|int
name|TSelectMask
parameter_list|(
name|sd
parameter_list|,
name|mask
parameter_list|,
name|nfds
parameter_list|,
name|td
parameter_list|)
name|int
name|sd
decl_stmt|;
name|fd_set
modifier|*
name|mask
decl_stmt|;
name|int
modifier|*
name|nfds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|SBV
name|smask
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|missingP
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|missingP
argument_list|(
name|nfds
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tb
operator|=
name|findtblk
argument_list|(
name|sd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_PARAMETER
argument_list|,
name|NULLCP
argument_list|,
literal|"invalid transport descriptor"
argument_list|)
return|;
block|}
if|if
condition|(
name|tb
operator|->
name|tb_checkfnx
operator|&&
call|(
modifier|*
name|tb
operator|->
name|tb_checkfnx
call|)
argument_list|(
name|tb
argument_list|)
operator|==
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_WAITING
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
return|;
block|}
name|selmask
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
operator|*
name|mask
argument_list|,
operator|*
name|nfds
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|NSAP interface: N-DATA.INDICATION */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SFD
name|DATAser
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|sc
parameter_list|)
name|int
name|sig
decl_stmt|;
name|long
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|nfds
decl_stmt|,
name|oob
decl_stmt|,
name|sd
decl_stmt|;
name|fd_set
name|ifds
decl_stmt|,
name|efds
decl_stmt|,
name|imask
decl_stmt|,
name|emask
decl_stmt|;
ifndef|#
directive|ifndef
name|BSDSIGS
name|SBV
name|smask
decl_stmt|;
endif|#
directive|endif
name|IFP
name|disc
decl_stmt|;
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|,
modifier|*
name|tb2
decl_stmt|;
name|struct
name|TSAPdata
name|txs
decl_stmt|;
specifier|register
name|struct
name|TSAPdata
modifier|*
name|tx
init|=
operator|&
name|txs
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
ifndef|#
directive|ifndef
name|BSDSIGS
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|DATAser
argument_list|)
expr_stmt|;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|efds
argument_list|)
expr_stmt|;
for|for
control|(
name|tb
operator|=
name|THead
operator|->
name|tb_forw
init|;
name|tb
operator|!=
name|THead
condition|;
name|tb
operator|=
name|tb
operator|->
name|tb_forw
control|)
if|if
condition|(
name|tb
operator|->
name|tb_fd
operator|!=
name|NOTOK
operator|&&
operator|(
name|tb
operator|->
name|tb_flags
operator|&
name|TB_ASYN
operator|)
condition|)
block|{
name|nfds
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|imask
argument_list|)
expr_stmt|;
name|selmask
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|imask
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
name|emask
operator|=
name|imask
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
call|(
modifier|*
name|tb
operator|->
name|tb_selectfnx
call|)
argument_list|(
name|nfds
argument_list|,
operator|&
name|imask
argument_list|,
name|NULLFD
argument_list|,
operator|&
name|emask
argument_list|,
literal|0
argument_list|)
operator|>
name|OK
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
operator|&
name|imask
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
operator|&
name|emask
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
operator|&
name|efds
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|tb
operator|=
name|THead
operator|->
name|tb_forw
init|;
name|tb
operator|!=
name|THead
condition|;
name|tb
operator|=
name|tb2
control|)
block|{
name|tb2
operator|=
name|tb
operator|->
name|tb_forw
expr_stmt|;
name|sd
operator|=
name|tb
operator|->
name|tb_fd
expr_stmt|;
if|if
condition|(
operator|(
name|oob
operator|=
name|FD_ISSET
argument_list|(
name|sd
argument_list|,
operator|&
name|efds
argument_list|)
operator|)
operator|||
name|FD_ISSET
argument_list|(
name|sd
argument_list|,
operator|&
name|ifds
argument_list|)
condition|)
block|{
name|disc
operator|=
name|tb
operator|->
name|tb_DiscIndication
expr_stmt|;
switch|switch
condition|(
call|(
modifier|*
name|tb
operator|->
name|tb_readPfnx
call|)
argument_list|(
name|tb
argument_list|,
name|tx
argument_list|,
name|td
argument_list|,
literal|1
argument_list|,
name|oob
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
call|(
modifier|*
name|disc
call|)
argument_list|(
name|sd
argument_list|,
name|td
argument_list|)
expr_stmt|;
break|break;
case|case
name|OK
case|:
call|(
modifier|*
name|tb
operator|->
name|tb_DataIndication
call|)
argument_list|(
name|sd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
break|break;
case|case
name|DONE
case|:
comment|/* partially assembled TSDU */
break|break;
block|}
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|SIGPOLL
operator|(
name|void
operator|)
name|kill
argument_list|(
name|TPid
argument_list|,
name|SIGEMT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIGPOLL
end_ifndef

begin_function
specifier|static
name|int
name|TWakeUp
parameter_list|(
name|tb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nfds
decl_stmt|;
name|fd_set
name|mask
decl_stmt|;
name|char
name|buf1
index|[
literal|10
index|]
decl_stmt|,
name|buf2
index|[
literal|10
index|]
decl_stmt|,
name|buf3
index|[
literal|10
index|]
decl_stmt|;
specifier|register
name|struct
name|isoservent
modifier|*
name|is
decl_stmt|;
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TPid
operator|>
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|kill
argument_list|(
name|TPid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|TPid
operator|=
name|NOTOK
expr_stmt|;
block|}
name|nfds
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|tb
operator|=
name|THead
operator|->
name|tb_forw
init|;
name|tb
operator|!=
name|THead
condition|;
name|tb
operator|=
name|tb
operator|->
name|tb_forw
control|)
if|if
condition|(
name|tb
operator|->
name|tb_fd
operator|!=
name|NOTOK
operator|&&
operator|(
name|tb
operator|->
name|tb_flags
operator|&
name|TB_ASYN
operator|)
condition|)
name|selmask
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|mask
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfds
operator|==
literal|0
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|nfds
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"you lose"
argument_list|)
return|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
ifndef|#
directive|ifndef
name|BSDSIGS
name|int
name|smask
init|=
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGEMT
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|DATAser
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BSDSIGS
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inited
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|is
operator|=
name|getisoserventbyname
argument_list|(
literal|"isore"
argument_list|,
literal|"tsap"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"ISO service tsap/isore not found"
argument_list|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"%d"
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
operator|*
name|is
operator|->
name|is_tail
operator|++
operator|=
name|buf1
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"0x%x"
argument_list|,
name|mask
operator|.
name|fds_bits
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|is
operator|->
name|is_tail
operator|++
operator|=
name|buf2
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf3
argument_list|,
literal|"%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|is
operator|->
name|is_tail
operator|++
operator|=
name|buf3
expr_stmt|;
operator|*
name|is
operator|->
name|is_tail
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|TPid
operator|=
name|vfork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
continue|continue;
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execv
argument_list|(
operator|*
name|is
operator|->
name|is_vec
argument_list|,
name|is
operator|->
name|is_vec
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
return|return
name|OK
return|;
block|}
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"isore"
argument_list|,
literal|"unable to fork"
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|BSDSIGS
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|TWakeUp
parameter_list|(
name|tb
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|SUNOS4
name|int
name|pgrp
decl_stmt|;
endif|#
directive|endif
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_flags
operator|&
name|TB_ASYN
condition|)
block|{
if|if
condition|(
operator|!
name|inited
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPOLL
argument_list|,
name|DATAser
argument_list|)
expr_stmt|;
name|inited
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BSDSIGS
ifdef|#
directive|ifdef
name|SUNOS4
if|if
condition|(
name|fcntl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"fcntl F_SETOWN"
argument_list|)
return|;
else|#
directive|else
name|pgrp
operator|=
operator|-
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|SIOCSPGRP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgrp
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"ioctl SIOCSPGRP %d"
argument_list|,
name|pgrp
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|result
operator|=
name|fcntl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0x00
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"fcntl F_GETFL"
argument_list|)
return|;
name|result
operator||=
name|FASYNC
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|F_SETFL
argument_list|,
name|result
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"fcntl F_SETFL 0x%x"
argument_list|,
name|result
argument_list|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|ioctl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|I_GETSIG
argument_list|,
operator|&
name|result
argument_list|)
operator|==
name|NOTOK
condition|)
name|result
operator|=
literal|0
expr_stmt|;
name|result
operator||=
name|S_INPUT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|I_SETSIG
argument_list|,
name|result
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"ioctl I_SETSIG 0x%x"
argument_list|,
name|result
argument_list|)
return|;
else|#
directive|else
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
name|NULLCP
argument_list|,
literal|"asynchronous operations not yet supported under SVR3"
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BSDSIGS
if|if
condition|(
operator|(
name|result
operator|=
name|fcntl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0x00
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"fcntl F_GETFL"
argument_list|)
return|;
name|result
operator|&=
operator|~
name|FASYNC
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|F_SETFL
argument_list|,
name|result
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"fcntl F_SETFL 0x%x"
argument_list|,
name|result
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|I_GETSIG
argument_list|,
operator|&
name|result
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"ioctl I_GETSIG"
argument_list|)
return|;
name|result
operator|&=
operator|~
name|S_INPUT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|,
name|I_SETSIG
argument_list|,
name|result
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|tsaplose
argument_list|(
name|td
argument_list|,
name|DR_CONGEST
argument_list|,
literal|"failed"
argument_list|,
literal|"ioctl I_SETSIG 0x%x"
argument_list|,
name|result
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|INTERNAL */
end_comment

begin_function
name|struct
name|tsapblk
modifier|*
name|newtblk
parameter_list|()
block|{
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
name|tb
operator|=
operator|(
expr|struct
name|tsapblk
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|tb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|tb
operator|->
name|tb_fd
operator|=
name|NOTOK
expr_stmt|;
name|tb
operator|->
name|tb_qbuf
operator|.
name|qb_forw
operator|=
name|tb
operator|->
name|tb_qbuf
operator|.
name|qb_back
operator|=
operator|&
name|tb
operator|->
name|tb_qbuf
expr_stmt|;
name|tb
operator|->
name|tb_qwrites
operator|.
name|qb_forw
operator|=
name|tb
operator|->
name|tb_qwrites
operator|.
name|qb_back
operator|=
operator|&
name|tb
operator|->
name|tb_qwrites
expr_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
block|{
name|THead
operator|->
name|tb_forw
operator|=
name|THead
operator|->
name|tb_back
operator|=
name|THead
expr_stmt|;
name|once_only
operator|++
expr_stmt|;
block|}
name|insque
argument_list|(
name|tb
argument_list|,
name|THead
operator|->
name|tb_back
argument_list|)
expr_stmt|;
return|return
name|tb
return|;
block|}
end_function

begin_expr_stmt
name|freetblk
argument_list|(
name|tb
argument_list|)
specifier|register
expr|struct
name|tsapblk
operator|*
name|tb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|SBV
name|smask
decl_stmt|;
ifndef|#
directive|ifndef
name|SIGPOLL
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
name|smask
operator|=
name|sigioblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_fd
operator|!=
name|NOTOK
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|tb
operator|->
name|tb_closefnx
argument_list|)
argument_list|(
name|tb
operator|->
name|tb_fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MGMT
if|if
condition|(
name|tb
operator|->
name|tb_manfnx
condition|)
call|(
modifier|*
name|tb
operator|->
name|tb_manfnx
call|)
argument_list|(
name|DISCREQ
argument_list|,
name|tb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tb
operator|->
name|tb_retry
condition|)
name|freetpkt
argument_list|(
name|tb
operator|->
name|tb_retry
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_calling
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tb
operator|->
name|tb_calling
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_called
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tb
operator|->
name|tb_called
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_data
condition|)
name|free
argument_list|(
name|tb
operator|->
name|tb_data
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGPOLL
if|if
condition|(
operator|(
name|tb
operator|->
name|tb_flags
operator|&
name|TB_ASYN
operator|)
operator|&&
name|TPid
operator|>
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|kill
argument_list|(
name|TPid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|TPid
operator|=
name|NOTOK
expr_stmt|;
block|}
endif|#
directive|endif
name|QBFREE
argument_list|(
operator|&
name|tb
operator|->
name|tb_qbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_queuePfnx
condition|)
call|(
modifier|*
name|tb
operator|->
name|tb_queuePfnx
call|)
argument_list|(
name|tb
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|TSAPdisconnect
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|QBFREE
argument_list|(
operator|&
name|tb
operator|->
name|tb_qwrites
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tb
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGPOLL
for|for
control|(
name|tb
operator|=
name|THead
operator|->
name|tb_forw
init|;
name|tb
operator|!=
name|THead
condition|;
name|tb
operator|=
name|tb
operator|->
name|tb_forw
control|)
if|if
condition|(
name|tb
operator|->
name|tb_fd
operator|!=
name|NOTOK
operator|&&
operator|(
name|tb
operator|->
name|tb_flags
operator|&
name|TB_ASYN
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|TWakeUp
argument_list|(
name|tb
argument_list|,
operator|&
name|tds
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|sigiomask
argument_list|(
name|smask
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|struct
name|tsapblk
modifier|*
name|findtblk
parameter_list|(
name|sd
parameter_list|)
specifier|register
name|int
name|sd
decl_stmt|;
block|{
specifier|register
name|struct
name|tsapblk
modifier|*
name|tb
decl_stmt|;
if|if
condition|(
name|once_only
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|tb
operator|=
name|THead
operator|->
name|tb_forw
init|;
name|tb
operator|!=
name|THead
condition|;
name|tb
operator|=
name|tb
operator|->
name|tb_forw
control|)
if|if
condition|(
name|tb
operator|->
name|tb_fd
operator|==
name|sd
condition|)
return|return
name|tb
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|copyTSAPaddrX
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|struct
name|tsapADDR
modifier|*
name|in
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|out
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
sizeof|sizeof
expr|*
name|out
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|in
operator|->
name|ta_selector
argument_list|,
name|out
operator|->
name|ta_selector
argument_list|,
name|out
operator|->
name|ta_selectlen
operator|=
name|in
operator|->
name|ta_selectlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|ta_present
condition|)
block|{
name|out
operator|->
name|ta_addrs
index|[
literal|0
index|]
operator|=
name|in
operator|->
name|ta_addr
expr_stmt|;
comment|/* struct copy */
name|out
operator|->
name|ta_naddr
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|copyTSAPaddrY
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|struct
name|TSAPaddr
modifier|*
name|in
decl_stmt|;
name|struct
name|tsapADDR
modifier|*
name|out
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
sizeof|sizeof
expr|*
name|out
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|in
operator|->
name|ta_selector
argument_list|,
name|out
operator|->
name|ta_selector
argument_list|,
name|out
operator|->
name|ta_selectlen
operator|=
name|in
operator|->
name|ta_selectlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|->
name|ta_present
operator|=
operator|(
name|in
operator|->
name|ta_naddr
operator|>=
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
condition|)
name|out
operator|->
name|ta_addr
operator|=
name|in
operator|->
name|ta_addrs
index|[
literal|0
index|]
expr_stmt|;
comment|/* struct copy */
block|}
end_function

end_unit

