begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dsa_chain.c - take referral and chain if allowed */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/dsa_chain.c,v 7.5 91/02/22 09:39:06 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/dsa_chain.c,v 7.5 91/02/22 09:39:06 mrose Interim $  *  *  * $Log:	dsa_chain.c,v $  * Revision 7.5  91/02/22  09:39:06  mrose  * Interim 6.8  *   * Revision 7.4  90/10/17  11:54:03  mrose  * sync  *   * Revision 7.3  90/07/09  14:45:58  mrose  * sync  *   * Revision 7.2  89/12/19  16:20:26  mrose  * sync  *   * Revision 7.1  89/11/27  10:30:12  mrose  * sync  *   * Revision 7.0  89/11/23  22:17:21  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"acsap.h"
end_include

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mydsaname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|no_dsp_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|AttributeType
name|at_relaydsa
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|oper_act
modifier|*
name|task2oper
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|di_block
modifier|*
name|di_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|di_block
modifier|*
name|select_refer_dsa
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|connection
modifier|*
name|conn_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|oper_act
modifier|*
name|oper_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|PSAPaddr
modifier|*
name|psap_cpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|access_point
modifier|*
name|ap_cpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Entry
name|local_find_entry_aux
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|struct
name|connection
modifier|*
name|make_conn_block
parameter_list|(
name|name
parameter_list|,
name|addr
parameter_list|,
name|conn_ctx
parameter_list|)
name|DN
name|name
decl_stmt|;
name|struct
name|PSAPaddr
modifier|*
name|addr
decl_stmt|;
name|char
name|conn_ctx
decl_stmt|;
block|{
name|struct
name|connection
modifier|*
name|cn
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|tb
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|nb
decl_stmt|;
specifier|extern
name|struct
name|PSAPaddr
modifier|*
name|mydsaaddr
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|char
name|onnet
init|=
name|FALSE
decl_stmt|;
comment|/*     * Set up a new connection block and add it to the list.     */
if|if
condition|(
name|dn_cmp
argument_list|(
name|name
argument_list|,
name|mydsadn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"Trying to connect to self :-)"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULLCONN
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|addr
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Invalid (accesspoint) reference"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULLCONN
operator|)
return|;
block|}
comment|/* see if on the appropriate net */
name|ta
operator|=
operator|&
operator|(
name|addr
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
name|tb
operator|=
operator|&
operator|(
name|mydsaaddr
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
comment|/* compare ta and tb to see if they have a network in common */
for|for
control|(
name|na
operator|=
name|ta
operator|->
name|ta_addrs
operator|,
name|x
operator|=
name|ta
operator|->
name|ta_naddr
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|na
operator|++
operator|,
name|x
operator|--
control|)
block|{
for|for
control|(
name|nb
operator|=
name|tb
operator|->
name|ta_addrs
operator|,
name|y
operator|=
name|tb
operator|->
name|ta_naddr
operator|-
literal|1
init|;
name|y
operator|>=
literal|0
condition|;
name|nb
operator|++
operator|,
name|y
operator|--
control|)
block|{
if|if
condition|(
name|na
operator|->
name|na_community
operator|==
name|nb
operator|->
name|na_community
condition|)
block|{
name|onnet
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|onnet
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"make_conn_block - no network in common"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULLCONN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cn
operator|=
name|conn_alloc
argument_list|()
operator|)
operator|==
name|NULLCONN
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"make_conn_block - conn_alloc() out of memory"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULLCONN
operator|)
return|;
block|}
name|cn
operator|->
name|cn_state
operator|=
name|CN_WAITING
expr_stmt|;
name|cn
operator|->
name|cn_ctx
operator|=
name|conn_ctx
expr_stmt|;
name|cn
operator|->
name|cn_initiator
operator|=
name|TRUE
expr_stmt|;
name|make_dsa_bind_arg
argument_list|(
operator|&
operator|(
name|cn
operator|->
name|cn_connect
operator|.
name|cc_req
operator|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_dn
operator|=
name|dn_cpy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Before psap_dup: %s"
operator|,
name|paddr2str
argument_list|(
name|addr
argument_list|,
name|NULLNA
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|psap_dup
argument_list|(
operator|&
operator|(
name|cn
operator|->
name|cn_addr
operator|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"After psap_dup:  %s"
operator|,
name|paddr2str
argument_list|(
operator|&
operator|(
name|cn
operator|->
name|cn_addr
operator|)
argument_list|,
name|NULLNA
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cn
operator|)
return|;
block|}
end_function

begin_function
name|int
name|link_op_to_conn
parameter_list|(
name|on
parameter_list|)
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
block|{
name|char
name|conn_ctx
init|=
name|DS_CTX_X500_DSP
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|next_di
decl_stmt|;
name|struct
name|connection
modifier|*
name|cn
decl_stmt|;
name|int
name|do_conn
decl_stmt|;
name|struct
name|access_point
modifier|*
name|loop_ap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|sort_dsa_list
argument_list|(
operator|&
name|on
operator|->
name|on_dsas
argument_list|)
expr_stmt|;
comment|/*     *  Use an open connection if one is available.     */
name|next_di
operator|=
operator|&
operator|(
name|on
operator|->
name|on_dsas
operator|)
expr_stmt|;
for|for
control|(
name|di
operator|=
name|on
operator|->
name|on_dsas
init|;
name|di
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di
operator|=
name|di
operator|->
name|di_next
control|)
block|{
for|for
control|(
name|cn
operator|=
name|connlist
init|;
name|cn
operator|!=
name|NULLCONN
condition|;
name|cn
operator|=
name|cn
operator|->
name|cn_next
control|)
block|{
comment|/* Must be a suitable context */
if|if
condition|(
name|cn
operator|->
name|cn_ctx
operator|==
name|DS_CTX_X500_DAP
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - open conn has DAP context"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|cn
operator|->
name|cn_ctx
operator|==
name|DS_CTX_X500_DSP
operator|)
operator|&&
operator|(
operator|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_EDB
operator|)
operator|||
operator|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_DSA_INFO
operator|)
operator|||
operator|(
operator|!
name|cn
operator|->
name|cn_initiator
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|cn
operator|->
name|cn_initiator
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - open conn has DSP context - we must initiate it"
operator|)
argument_list|)
expr_stmt|;
else|else
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - open conn has DSP context - QUIPU context needed"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|cn
operator|->
name|cn_dn
operator|!=
name|NULLDN
operator|)
operator|&&
operator|(
name|dn_cmp
argument_list|(
name|cn
operator|->
name|cn_dn
argument_list|,
name|di
operator|->
name|di_dn
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|cn
operator|!=
name|NULLCONN
condition|)
break|break;
name|next_di
operator|=
operator|&
operator|(
name|di
operator|->
name|di_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|di
operator|!=
name|NULL_DI_BLOCK
condition|)
block|{
comment|/* Got one - remove successful di_block and link op to conn */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - Found suitable open connection"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|di_state
operator|==
name|DI_DEFERRED
condition|)
block|{
comment|/* We have an open connection, but not a cache entry */
comment|/*		(must have used an access point in the past) */
comment|/* Need to be careful about freeing - do it later ! */
name|di
operator|->
name|di_oper
operator|=
name|NULLOPER
expr_stmt|;
block|}
else|else
name|di_extract
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_conn
operator|=
name|cn
expr_stmt|;
name|on
operator|->
name|on_next_conn
operator|=
name|cn
operator|->
name|cn_operlist
expr_stmt|;
name|cn
operator|->
name|cn_operlist
operator|=
name|on
expr_stmt|;
name|on
operator|->
name|on_relay
operator|=
name|FALSE
expr_stmt|;
comment|/* No need we have an open connection */
return|return
operator|(
name|OK
operator|)
return|;
block|}
comment|/*     *  Use a waiting connection if one is available.     */
name|next_di
operator|=
operator|&
operator|(
name|on
operator|->
name|on_dsas
operator|)
expr_stmt|;
for|for
control|(
name|di
operator|=
name|on
operator|->
name|on_dsas
init|;
name|di
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di
operator|=
name|di
operator|->
name|di_next
control|)
block|{
for|for
control|(
name|cn
operator|=
name|connwaitlist
init|;
name|cn
operator|!=
name|NULLCONN
condition|;
name|cn
operator|=
name|cn
operator|->
name|cn_next
control|)
block|{
comment|/* 	*  Could do some clever stuff here and convert a waiting  	*  connection to QUIPU from X500 if possible and useful. 	*  Left as an exercise for the reader. 	*/
comment|/* Must be a suitable context */
if|if
condition|(
name|cn
operator|->
name|cn_ctx
operator|==
name|DS_CTX_X500_DAP
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cn
operator|->
name|cn_ctx
operator|==
name|DS_CTX_X500_DSP
operator|)
operator|&&
operator|(
operator|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_EDB
operator|)
operator|||
operator|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_DSA_INFO
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cn
operator|->
name|cn_dn
operator|!=
name|NULLDN
operator|)
operator|&&
operator|(
name|dn_cmp
argument_list|(
name|cn
operator|->
name|cn_dn
argument_list|,
name|di
operator|->
name|di_dn
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|cn
operator|!=
name|NULLCONN
condition|)
break|break;
name|next_di
operator|=
operator|&
operator|(
name|di
operator|->
name|di_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|di
operator|!=
name|NULL_DI_BLOCK
condition|)
block|{
comment|/* Got one - remove successful di_block and link op to conn */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - Found suitable waiting connection"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
name|di_extract
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_conn
operator|=
name|cn
expr_stmt|;
name|on
operator|->
name|on_next_conn
operator|=
name|cn
operator|->
name|cn_operlist
expr_stmt|;
name|cn
operator|->
name|cn_operlist
operator|=
name|on
expr_stmt|;
name|on
operator|->
name|on_relay
operator|=
name|FALSE
expr_stmt|;
comment|/* No need we will chain sooner or later */
return|return
operator|(
name|OK
operator|)
return|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Neither an open nor a waiting conn suitable"
operator|)
argument_list|)
expr_stmt|;
name|next_di
operator|=
operator|&
operator|(
name|on
operator|->
name|on_dsas
operator|)
expr_stmt|;
for|for
control|(
name|di
operator|=
name|on
operator|->
name|on_dsas
init|;
name|di
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di
operator|=
operator|(
operator|*
name|next_di
operator|)
control|)
block|{
if|if
condition|(
name|di
operator|->
name|di_state
operator|==
name|DI_DEFERRED
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - deferred di_block"
operator|)
argument_list|)
expr_stmt|;
name|next_di
operator|=
operator|&
operator|(
name|di
operator|->
name|di_next
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|di
operator|->
name|di_state
operator|==
name|DI_ACCESSPOINT
condition|)
block|{
comment|/* context problem: 		if we have not got the entry, we don't know which context it 		will accept. 		If the operation is a getedb, or getdsainfo  			ASSUME Quipu context is OK 	    */
if|if
condition|(
operator|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_EDB
operator|)
operator|||
operator|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_DSA_INFO
operator|)
condition|)
name|conn_ctx
operator|=
name|DS_CTX_QUIPU_DSP
expr_stmt|;
else|else
block|{
name|conn_ctx
operator|=
name|DS_CTX_X500_DSP
expr_stmt|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - make conn block from access point"
operator|)
argument_list|)
expr_stmt|;
comment|/* There *should* only be one access point -  	     * but QUIPU may give a choice try find one that will work...              * This is *wrong* if it is a non specific subordinate reference.              */
if|if
condition|(
name|di
operator|->
name|di_reftype
operator|==
name|RT_NONSPECIFICSUBORDINATE
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Should try each access point - not just one !!!"
operator|)
argument_list|)
expr_stmt|;
comment|/* throw back to user */
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
name|di_extract
argument_list|(
name|di
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|loop_ap
operator|=
name|di
operator|->
name|di_accesspoints
init|;
name|loop_ap
operator|!=
name|NULLACCESSPOINT
condition|;
name|loop_ap
operator|=
name|loop_ap
operator|->
name|ap_next
control|)
if|if
condition|(
operator|(
name|cn
operator|=
name|make_conn_block
argument_list|(
name|loop_ap
operator|->
name|ap_name
argument_list|,
name|loop_ap
operator|->
name|ap_address
argument_list|,
name|conn_ctx
argument_list|)
operator|)
operator|!=
name|NULLCONN
condition|)
block|{
name|on
operator|->
name|on_relay
operator|=
name|FALSE
expr_stmt|;
comment|/* Made a connection block */
break|break;
block|}
if|if
condition|(
name|loop_ap
operator|==
name|NULLACCESSPOINT
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"link_op_to_conn - make_conn_block failed 1"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
name|di_extract
argument_list|(
name|di
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|di
operator|->
name|di_state
operator|==
name|DI_COMPLETE
condition|)
block|{
comment|/* 	    *  Open a quipu context connection if possible: this is so if 	    *  the entry for the dsa in question has object class quipuDSA. 	    */
if|if
condition|(
operator|(
name|res
operator|=
name|quipu_ctx_supported
argument_list|(
name|di
operator|->
name|di_entry
argument_list|)
operator|)
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_EDB
operator|)
operator|||
operator|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_DSA_INFO
operator|)
operator|||
operator|(
name|res
operator|==
operator|-
literal|1
operator|)
condition|)
comment|/* DAP only !!! */
block|{
comment|/* Ditch this di_block and carry on looking */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"link_op_to_conn - avoiding non-quipu context for GetEDB"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
name|di_extract
argument_list|(
name|di
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"link_op_to_conn - linking to a connection without a quipu context"
operator|)
argument_list|)
expr_stmt|;
name|conn_ctx
operator|=
name|DS_CTX_X500_DSP
expr_stmt|;
block|}
block|}
else|else
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"link_op_to_conn - linking to a connection with a quipu context"
operator|)
argument_list|)
expr_stmt|;
name|conn_ctx
operator|=
name|DS_CTX_QUIPU_DSP
expr_stmt|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - make conn block from entry"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cn
operator|=
name|make_conn_block
argument_list|(
name|di
operator|->
name|di_dn
argument_list|,
name|di
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_addr
argument_list|,
name|conn_ctx
argument_list|)
operator|)
operator|==
name|NULLCONN
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"link_op_to_conn - make_conn_block failed 2"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
name|di_extract
argument_list|(
name|di
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|on
operator|->
name|on_relay
operator|=
name|FALSE
expr_stmt|;
comment|/* Made a connection block */
block|}
comment|/* 	*  Decide whether to request connection or place it 	*  on the list of waiting connections. 	*/
switch|switch
condition|(
name|on
operator|->
name|on_type
condition|)
block|{
case|case
name|ON_TYPE_GET_DSA_INFO
case|:
name|do_conn
operator|=
operator|(
name|conns_used
operator|<
name|MAX_CONNS
operator|)
expr_stmt|;
break|break;
case|case
name|ON_TYPE_GET_EDB
case|:
case|case
name|ON_TYPE_SHADOW
case|:
name|do_conn
operator|=
operator|(
name|conns_used
operator|<
operator|(
name|MAX_CONNS
operator|-
name|CONNS_RESERVED_DI
operator|-
name|CONNS_RESERVED_X500
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|do_conn
operator|=
operator|(
name|conns_used
operator|<
operator|(
name|MAX_CONNS
operator|-
name|CONNS_RESERVED_DI
operator|)
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|do_conn
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"link_op_to_conn - about to request connection"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn_request
argument_list|(
name|cn
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"link_op_to_conn - conn_request failed"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
name|di_extract
argument_list|(
name|di
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"link_op_to_conn - conn_request OK"
operator|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_next
operator|=
name|connlist
expr_stmt|;
name|connlist
operator|=
name|cn
expr_stmt|;
name|conns_used
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Waiting for a free connection slot"
operator|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_next
operator|=
name|connwaitlist
expr_stmt|;
name|connwaitlist
operator|=
name|cn
expr_stmt|;
block|}
operator|(
operator|*
name|next_di
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
name|di_extract
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_conn
operator|=
name|cn
expr_stmt|;
name|on
operator|->
name|on_next_conn
operator|=
name|cn
operator|->
name|cn_operlist
expr_stmt|;
name|cn
operator|->
name|cn_operlist
operator|=
name|on
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
comment|/*     *  If we get this far it means that we are waiting for a dsa info     *  operation to complete, or there are no di_blocks left to try.     *  Callers of link_op_to_conn must check on_dsas to discover which it is.     */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"link_op_to_conn: returning NOTOK"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|oper_chain
parameter_list|(
name|on
parameter_list|)
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
block|{
if|if
condition|(
name|link_op_to_conn
argument_list|(
name|on
argument_list|)
operator|==
name|OK
condition|)
block|{
if|if
condition|(
name|on
operator|->
name|on_conn
operator|==
name|NULLCONN
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"oper_chain - link_op_to_conn: OK but no conn"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"oper_chain - link_op_to_conn: OK got conn"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|->
name|on_conn
operator|->
name|cn_state
operator|==
name|CN_OPEN
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"oper_chain - link_op_to_conn: OK got open conn"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper_send_invoke
argument_list|(
name|on
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"oper_chain - oper_send failed"
operator|)
argument_list|)
expr_stmt|;
comment|/* Have another go? */
return|return
operator|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"oper_chain - oper_send succeeded"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|on
operator|->
name|on_state
operator|=
name|ON_CHAINED
expr_stmt|;
block|}
else|else
block|{
comment|/* 	*  If on->on_dsas is empty then chaining has failed 	*  otherwise the op is deferred. 	*/
if|if
condition|(
name|on
operator|->
name|on_dsas
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
if|if
condition|(
name|relay_dsa
argument_list|(
name|on
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Trying to relay..."
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|)
return|;
block|}
name|on
operator|->
name|on_state
operator|=
name|ON_DEFERRED
expr_stmt|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|task_chain
parameter_list|(
name|tk
parameter_list|,
name|di
parameter_list|)
specifier|register
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
block|{
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
init|=
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di_tmp
decl_stmt|;
name|char
name|refer_ok
init|=
name|TRUE
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"task_chain called with:"
operator|)
argument_list|)
expr_stmt|;
name|di_list_log
argument_list|(
name|di
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NB At some point this routine must assign the di_block list to * either the task (if it is intended to geneate a referral) or to * an operation hanging off that task if it is intended to chain the * task. This is fine when there are no deferred di_blocks, but when * there are then the information they will eventually contain is * needed to make a full decision on whether to chain or refer. * This needs a lot of thought to get right, for now the chain/refer * decision is made once and for all on the basis of the information * available now. Any information not available is assumed to force a * referral (the safe option  -  until network connectivity is considered)! * THis may introduce the unwelcome effect that a first request to a * DSA may produce a referral where subsequent requests do not - so much * for consistency but it won't happen that often if DSA info is cached * sensibly. */
comment|/*     *  Generate the referral which the DSA will pass back if     *  chaining is disallowed or oper_chain fails for all     *  DSAs listed.     */
name|sort_dsa_list
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|di_tmp
operator|=
name|select_refer_dsa
argument_list|(
name|di
argument_list|,
name|tk
argument_list|)
operator|)
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
comment|/* The remote END is probably unable to follow the referral - chain if allowed */
name|refer_ok
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|di_tmp
operator|=
name|di
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|di_tmp
operator|->
name|di_state
operator|==
name|DI_DEFERRED
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEBUG
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"About to call di2cref with:"
operator|)
argument_list|)
expr_stmt|;
name|di_log
argument_list|(
name|di_tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|di2cref
argument_list|(
name|di_tmp
argument_list|,
name|err
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
argument_list|)
operator|==
name|OK
condition|)
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|di2cref
argument_list|(
name|di_tmp
argument_list|,
name|err
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
argument_list|)
operator|!=
name|OK
condition|)
name|di_tmp
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
comment|/* waiting... */
if|if
condition|(
name|di_tmp
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
comment|/* 	*  Want to generate a referral - but all di_blocks (if any) 	*  are deferred. Would we be lying too much if we said the 	*  DSA was "busy" at this point??? 	*/
name|ds_error_free
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_BUSY
expr_stmt|;
name|di_desist
argument_list|(
name|di
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
comment|/*     *  If it would be inappropriate to chain this operation, then     *  generate a referral from the di_block list.     */
if|if
condition|(
name|chain_ok
argument_list|(
name|tk
argument_list|,
name|refer_ok
argument_list|,
name|di_tmp
operator|->
name|di_dn
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Referring!"
operator|)
argument_list|)
expr_stmt|;
name|di_desist
argument_list|(
name|di
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Chaining!"
operator|)
argument_list|)
expr_stmt|;
comment|/* Chain. Generate the new operation to send */
if|if
condition|(
operator|(
name|on
operator|=
name|task2oper
argument_list|(
name|tk
argument_list|)
operator|)
operator|==
name|NULLOPER
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Why did task2oper fail??"
operator|)
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_UNAVAILABLE
expr_stmt|;
name|di_desist
argument_list|(
name|di
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|ti_is_elem
argument_list|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_charg
operator|.
name|cha_trace
argument_list|,
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_charg
operator|.
name|cha_trace
operator|->
name|ti_next
argument_list|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Loop found in oper_chain()"
operator|)
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_LOOPDETECT
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|on
operator|->
name|on_next_task
operator|=
name|tk
operator|->
name|tk_operlist
expr_stmt|;
name|tk
operator|->
name|tk_operlist
operator|=
name|on
expr_stmt|;
name|on
operator|->
name|on_task
operator|=
name|tk
expr_stmt|;
comment|/* Hand control of di_blocks to the operation */
name|on
operator|->
name|on_dsas
operator|=
name|di
expr_stmt|;
for|for
control|(
name|di_tmp
operator|=
name|di
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
name|di_tmp
operator|->
name|di_type
operator|=
name|DI_OPERATION
expr_stmt|;
name|di_tmp
operator|->
name|di_oper
operator|=
name|on
expr_stmt|;
block|}
if|if
condition|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|oper_task_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|on
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_macro
name|oper_rechain
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|DSE_referral
modifier|*
name|ref
init|=
operator|&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_REFERRAL
operator|)
decl_stmt|;
name|struct
name|continuation_ref
modifier|*
name|cref
decl_stmt|;
specifier|register
name|struct
name|chain_arg
modifier|*
name|cha
init|=
operator|&
operator|(
name|on
operator|->
name|on_req
operator|.
name|dca_charg
operator|)
decl_stmt|;
name|struct
name|trace_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|di_block
modifier|*
name|ap2di
parameter_list|()
function_decl|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Rechain an operation ..."
operator|)
argument_list|)
expr_stmt|;
name|cref
operator|=
name|ref
operator|->
name|DSE_ref_candidates
expr_stmt|;
if|if
condition|(
name|cref
operator|==
name|NULLCONTINUATIONREF
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"No continuation reference to rechain"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|cha
operator|->
name|cha_target
operator|=
name|dn_cpy
argument_list|(
name|cref
operator|->
name|cr_name
argument_list|)
expr_stmt|;
name|cha
operator|->
name|cha_progress
operator|=
name|cref
operator|->
name|cr_progress
expr_stmt|;
name|cha
operator|->
name|cha_aliasderef
operator|=
operator|(
operator|(
name|cha
operator|->
name|cha_aliasedrdns
operator|=
name|cref
operator|->
name|cr_aliasedRDNs
operator|)
operator|!=
name|CR_NOALIASEDRDNS
operator|)
expr_stmt|;
if|if
condition|(
name|cha
operator|->
name|cha_aliasderef
condition|)
block|{
if|if
condition|(
operator|(
name|on
operator|->
name|on_arg
operator|->
name|dca_dsarg
operator|.
name|arg_type
operator|==
name|OP_SEARCH
operator|)
operator|&&
operator|(
name|on
operator|->
name|on_arg
operator|->
name|dca_dsarg
operator|.
name|arg_sr
operator|.
name|sra_subset
operator|==
name|SRA_ONELEVEL
operator|)
condition|)
ifdef|#
directive|ifdef
name|COMPAT_6_0
block|{
name|on
operator|->
name|on_arg
operator|->
name|dca_dsarg
operator|.
name|arg_sr
operator|.
name|sra_subset
operator|=
name|SRA_BASEOBJECT
expr_stmt|;
name|cha
operator|->
name|cha_entryonly
operator|=
name|FALSE
expr_stmt|;
block|}
else|#
directive|else
name|cha
operator|->
name|cha_entryonly
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
else|else
name|cha
operator|->
name|cha_entryonly
operator|=
name|FALSE
expr_stmt|;
block|}
name|cha
operator|->
name|cha_returnrefs
operator|=
name|FALSE
expr_stmt|;
name|cha
operator|->
name|cha_domaininfo
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
operator|(
name|cha
operator|->
name|cha_reftype
operator|=
name|cref
operator|->
name|cr_reftype
operator|)
operator|==
name|RT_UNDEFINED
condition|)
name|cha
operator|->
name|cha_reftype
operator|=
name|RT_SUPERIOR
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"oper_rechain - Setting trace info"
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|=
operator|(
expr|struct
name|trace_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trace_info
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_dsa
operator|=
name|dn_cpy
argument_list|(
name|on
operator|->
name|on_conn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_target
operator|=
name|dn_cpy
argument_list|(
name|cref
operator|->
name|cr_name
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_progress
operator|=
name|cref
operator|->
name|cr_progress
expr_stmt|;
name|ti
operator|->
name|ti_next
operator|=
name|cha
operator|->
name|cha_trace
expr_stmt|;
name|cha
operator|->
name|cha_trace
operator|=
name|ti
expr_stmt|;
if|if
condition|(
name|ti_is_elem
argument_list|(
name|ti
argument_list|,
name|ti
operator|->
name|ti_next
argument_list|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Loop found in oper_rechain()"
operator|)
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_LOOPDETECT
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|oper_conn_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
comment|/*     *  Problem - having converted to di_blocks it is harder to handle referrals     *  Set up a single di_block with the address in the parent field ??     */
name|di_desist
argument_list|(
name|on
operator|->
name|on_dsas
argument_list|)
expr_stmt|;
if|if
condition|(
name|cref
operator|->
name|cr_reftype
operator|!=
name|RT_NONSPECIFICSUBORDINATE
condition|)
name|on
operator|->
name|on_dsas
operator|=
name|ap2di
argument_list|(
name|cref
operator|->
name|cr_accesspoints
argument_list|,
name|cref
operator|->
name|cr_name
argument_list|,
name|FALSE
argument_list|,
name|DI_OPERATION
argument_list|,
name|on
argument_list|,
name|cref
operator|->
name|cr_reftype
argument_list|)
expr_stmt|;
else|else
block|{
name|on
operator|->
name|on_dsas
operator|=
name|di_alloc
argument_list|()
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|cref
operator|->
name|cr_name
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|->
name|di_dn
operator|=
name|dn_cpy
argument_list|(
name|cref
operator|->
name|cr_accesspoints
operator|->
name|ap_name
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"oper_rechain allocates di_block with dn[%x]"
operator|,
name|on
operator|->
name|on_dsas
operator|->
name|di_dn
operator|)
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|->
name|di_type
operator|=
name|DI_OPERATION
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|->
name|di_reftype
operator|=
name|RT_NONSPECIFICSUBORDINATE
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|->
name|di_oper
operator|=
name|on
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|->
name|di_state
operator|=
name|DI_ACCESSPOINT
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|->
name|di_accesspoints
operator|=
name|ap_cpy
argument_list|(
name|cref
operator|->
name|cr_accesspoints
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|->
name|di_next
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
block|}
name|sort_dsa_list
argument_list|(
operator|&
name|on
operator|->
name|on_dsas
argument_list|)
expr_stmt|;
comment|/* might be able to turn DI_ACCESS into DI_COMPLETE */
if|if
condition|(
name|on
operator|->
name|on_relay
operator|==
name|FALSE
condition|)
comment|/* but not 2 ! */
name|on
operator|->
name|on_relay
operator|=
name|TRUE
expr_stmt|;
comment|/* allow relay for new DSA set */
return|return
operator|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|oper_act
modifier|*
name|task2oper
parameter_list|(
name|tk
parameter_list|)
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
block|{
specifier|register
name|struct
name|chain_arg
modifier|*
name|cha
init|=
operator|&
operator|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_charg
operator|)
decl_stmt|;
name|struct
name|continuation_ref
modifier|*
name|cref
init|=
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
decl_stmt|;
name|struct
name|trace_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Chain a task ..."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|on
operator|=
name|oper_alloc
argument_list|()
operator|)
operator|==
name|NULLOPER
condition|)
return|return
operator|(
name|NULLOPER
operator|)
return|;
name|on
operator|->
name|on_type
operator|=
name|ON_TYPE_X500
expr_stmt|;
name|cha
operator|->
name|cha_target
operator|=
name|NULLDN
expr_stmt|;
if|if
condition|(
name|cref
operator|->
name|cr_name
operator|!=
name|NULLDN
condition|)
block|{
name|cha
operator|->
name|cha_target
operator|=
name|dn_cpy
argument_list|(
name|cref
operator|->
name|cr_name
argument_list|)
expr_stmt|;
block|}
name|cha
operator|->
name|cha_progress
operator|=
name|cref
operator|->
name|cr_progress
expr_stmt|;
name|cha
operator|->
name|cha_aliasderef
operator|=
operator|(
operator|(
name|cha
operator|->
name|cha_aliasedrdns
operator|=
name|cref
operator|->
name|cr_aliasedRDNs
operator|)
operator|!=
name|CR_NOALIASEDRDNS
operator|)
expr_stmt|;
if|if
condition|(
name|cha
operator|->
name|cha_aliasderef
condition|)
block|{
if|if
condition|(
operator|(
name|on
operator|->
name|on_arg
operator|->
name|dca_dsarg
operator|.
name|arg_type
operator|==
name|OP_SEARCH
operator|)
operator|&&
operator|(
name|on
operator|->
name|on_arg
operator|->
name|dca_dsarg
operator|.
name|arg_sr
operator|.
name|sra_subset
operator|==
name|SRA_ONELEVEL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|COMPAT_6_0
block|{
name|on
operator|->
name|on_arg
operator|->
name|dca_dsarg
operator|.
name|arg_sr
operator|.
name|sra_subset
operator|=
name|SRA_BASEOBJECT
expr_stmt|;
name|cha
operator|->
name|cha_entryonly
operator|=
name|FALSE
expr_stmt|;
block|}
else|#
directive|else
name|cha
operator|->
name|cha_entryonly
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|cha
operator|->
name|cha_entryonly
operator|=
name|FALSE
expr_stmt|;
block|}
name|cha
operator|->
name|cha_returnrefs
operator|=
name|FALSE
expr_stmt|;
name|cha
operator|->
name|cha_domaininfo
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
operator|(
name|cha
operator|->
name|cha_reftype
operator|=
name|cref
operator|->
name|cr_reftype
operator|)
operator|==
name|RT_UNDEFINED
condition|)
name|cha
operator|->
name|cha_reftype
operator|=
name|RT_SUPERIOR
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Checking history of op"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
operator|==
name|DS_CTX_X500_DAP
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"... user originated ..."
operator|)
argument_list|)
expr_stmt|;
name|cha
operator|->
name|cha_originator
operator|=
name|dn_cpy
argument_list|(
name|tk
operator|->
name|tk_conn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
name|cha
operator|->
name|cha_trace
operator|=
name|NULLTRACEINFO
expr_stmt|;
block|}
if|if
condition|(
name|tk
operator|->
name|tk_timed
operator|==
name|FALSE
condition|)
block|{
name|cha
operator|->
name|cha_timelimit
operator|=
name|NULLCP
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CHAIN_ARGS_TIMEOUT
name|struct
name|UTCtime
name|ut
decl_stmt|;
name|tm2ut
argument_list|(
name|gmtime
argument_list|(
operator|&
operator|(
name|tk
operator|->
name|tk_timeout
operator|)
argument_list|)
argument_list|,
operator|&
operator|(
name|ut
operator|)
argument_list|)
expr_stmt|;
name|cha
operator|->
name|cha_timelimit
operator|=
name|strdup
argument_list|(
name|utct2str
argument_list|(
operator|&
name|ut
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cha
operator|->
name|cha_timelimit
operator|=
name|NULLCP
expr_stmt|;
endif|#
directive|endif
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Setting trace info"
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|=
operator|(
expr|struct
name|trace_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trace_info
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_dsa
operator|=
name|dn_cpy
argument_list|(
name|mydsadn
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_target
operator|=
name|dn_cpy
argument_list|(
name|cref
operator|->
name|cr_name
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_progress
operator|=
name|cref
operator|->
name|cr_progress
expr_stmt|;
name|ti
operator|->
name|ti_next
operator|=
name|cha
operator|->
name|cha_trace
expr_stmt|;
name|cha
operator|->
name|cha_trace
operator|=
name|ti
expr_stmt|;
name|on
operator|->
name|on_arg
operator|=
operator|&
operator|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|)
expr_stmt|;
return|return
operator|(
name|on
operator|)
return|;
block|}
end_function

begin_function
name|int
name|chain_ok
parameter_list|(
name|tk
parameter_list|,
name|refer_ok
parameter_list|,
name|dsadn
parameter_list|)
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|char
name|refer_ok
decl_stmt|;
name|DN
name|dsadn
decl_stmt|;
block|{
name|struct
name|common_args
modifier|*
name|ca
decl_stmt|;
name|struct
name|common_args
modifier|*
name|get_ca_ref
parameter_list|()
function_decl|;
name|ca
operator|=
name|get_ca_ref
argument_list|(
operator|&
operator|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|)
argument_list|)
expr_stmt|;
comment|/* if refer_ok is FALSE - we MUST chain unless prevented, otherwise operation will fail */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"chain_ok: Checking if chaining is ok"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refer_ok
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"We MUST chain"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
operator|!=
name|DS_CTX_X500_DAP
operator|)
operator|&&
name|no_dsp_chain
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Not chaining because of NO_DSP_CHAIN"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_CHAININGPROHIBIT
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"But prohibited"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_LOCALSCOPE
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"But out of scope"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Forced chain OK!"
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
operator|!=
name|DS_CTX_X500_DAP
condition|)
block|{
if|if
condition|(
name|no_dsp_chain
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Not chaining because of NO_DSP_CHAIN (2)"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_PREFERCHAIN
operator|)
condition|)
block|{
comment|/* Don't send a self reference back to a remote DSA - chain if possible */
comment|/* Should not need it, when self reference bug is fixed ! */
if|if
condition|(
operator|(
name|tk
operator|->
name|tk_conn
operator|->
name|cn_initiator
operator|)
operator|||
operator|(
name|dn_cmp
argument_list|(
name|dsadn
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_dn
argument_list|)
operator|==
name|NOTOK
operator|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Not chaining because of preference"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_CHAININGPROHIBIT
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Not chaining because of prohibition"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_LOCALSCOPE
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Not chaining because of scope"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
switch|switch
condition|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_dsarg
operator|.
name|arg_type
condition|)
block|{
case|case
name|OP_ADDENTRY
case|:
case|case
name|OP_REMOVEENTRY
case|:
case|case
name|OP_MODIFYRDN
case|:
case|case
name|OP_MODIFYENTRY
case|:
comment|/* QUIPU DSAs will only allow modification over DAP */
if|if
condition|(
operator|!
operator|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_PREFERCHAIN
operator|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Not chaining because of authentication"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
default|default:
break|break;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Chain OK!"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_macro
name|task_result_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"task_result_wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|=
name|on
operator|->
name|on_task
operator|)
operator|==
name|NULLTASK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Oper can't wake up (result)extracted task"
operator|)
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	*  Were waiting for a remote result and here it is. 	*  Attempt to tidy up and send result. 	*/
name|ds_error_free
argument_list|(
name|tk
operator|->
name|tk_error
argument_list|)
expr_stmt|;
name|tk
operator|->
name|tk_result
operator|=
operator|&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|)
expr_stmt|;
name|dsp_cache
argument_list|(
operator|&
operator|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_dsarg
operator|)
argument_list|,
operator|&
operator|(
name|tk
operator|->
name|tk_result
operator|->
name|dcr_dsres
operator|)
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_result
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|task_error_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"task_error_wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|=
name|on
operator|->
name|on_task
operator|)
operator|==
name|NULLTASK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Oper can't wake up (error) extracted task"
operator|)
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	*  Were waiting for a remote result and got a remote error. 	*  If it is a referral, then rechain the operation if appropriate 	*  otherwise return the error. 	*/
if|if
condition|(
operator|!
operator|(
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|==
name|DSE_SECURITYERROR
operator|)
operator|&&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_SECURITY
operator|.
name|DSE_sc_problem
operator|==
name|DSE_SC_AUTHENTICATION
operator|)
operator|)
condition|)
block|{
comment|/* If is not an authenticaton error, swap errors */
name|ds_error_free
argument_list|(
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
argument_list|)
expr_stmt|;
name|tk
operator|->
name|tk_error
operator|=
operator|&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|==
name|DSE_DSAREFERRAL
operator|)
operator|||
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|==
name|DSE_REFERRAL
operator|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Try rechaining"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper_rechain
argument_list|(
name|on
argument_list|)
operator|==
name|OK
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Succeeded rechaining"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Failed rechaining"
operator|)
argument_list|)
expr_stmt|;
block|}
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_error
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|task_fail_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"task_fail_wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|=
name|on
operator|->
name|on_task
operator|)
operator|==
name|NULLTASK
condition|)
block|{
if|if
condition|(
name|on
operator|->
name|on_state
operator|!=
name|ON_ABANDONED
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"task_fail_wakeup: no task"
operator|)
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*     *  Were waiting for a remote result and got a remote failure.     *  If it is a referral, then rechain the operation if appropriate     *  otherwise return the error.     */
comment|/*     *  If the task does not have a suitable referral error set up     *  then return serviceError invalid reference.     */
name|err
operator|=
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|->
name|dse_type
operator|!=
name|DSE_REFERRAL
operator|)
operator|&&
operator|(
name|err
operator|->
name|dse_type
operator|!=
name|DSE_DSAREFERRAL
operator|)
condition|)
block|{
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_UNAVAILABLE
expr_stmt|;
block|}
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_error
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|oper_conn_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_task_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|task_dsa_info_wakeup
argument_list|(
argument|di
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|task_act
modifier|*
name|tk
init|=
name|di
operator|->
name|di_task
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"task_dsa_info_wakeup"
operator|)
argument_list|)
expr_stmt|;
comment|/*     * Were waiting for a reference to return.     * Check if the reference now returned is acceptable.     * If it is return a referral and unwrap everything,     * otherwise try another di_block for the reference.     */
name|sort_dsa_list
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|==
name|NULLTASK
condition|)
return|return;
comment|/* already done it ! */
if|if
condition|(
name|di2cref
argument_list|(
name|di
argument_list|,
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"task_dsa_info_wakeup - reference not acceptable"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove di_block which generated unwanted referral wait */
if|if
condition|(
name|tk
operator|->
name|tk_dsas
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
comment|/* No more dsas from which to request info to form referral */
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_INVALIDREFERENCE
expr_stmt|;
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_error
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_error
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|struct
name|access_point
modifier|*
name|di2ap
parameter_list|(
name|di
parameter_list|)
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
block|{
name|struct
name|access_point
modifier|*
name|ap
decl_stmt|;
switch|switch
condition|(
name|di
operator|->
name|di_state
condition|)
block|{
case|case
name|DI_ACCESSPOINT
case|:
return|return
operator|(
name|ap_cpy
argument_list|(
name|di
operator|->
name|di_accesspoints
argument_list|)
operator|)
return|;
case|case
name|DI_COMPLETE
case|:
if|if
condition|(
name|di
operator|->
name|di_entry
operator|==
name|NULLENTRY
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"di2ap - di_entry NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULLACCESSPOINT
return|;
block|}
if|if
condition|(
name|di
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|==
name|NULL
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"di2ap - e_dsainfo NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULLACCESSPOINT
return|;
block|}
if|if
condition|(
name|di
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_addr
operator|==
name|NULLPA
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"di2ap - dsa_addr NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULLACCESSPOINT
return|;
block|}
name|ap
operator|=
operator|(
expr|struct
name|access_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|access_point
argument_list|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_name
operator|=
name|dn_cpy
argument_list|(
name|di
operator|->
name|di_dn
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ap_address
operator|=
name|psap_cpy
argument_list|(
name|di
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ap
operator|)
return|;
default|default:
return|return
name|NULLACCESSPOINT
return|;
block|}
block|}
end_function

begin_function
name|int
name|di2cref
parameter_list|(
name|di
parameter_list|,
name|err
parameter_list|,
name|ctx
parameter_list|)
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|char
name|ctx
decl_stmt|;
block|{
name|struct
name|continuation_ref
modifier|*
name|cref
decl_stmt|;
name|struct
name|di_block
modifier|*
name|loop
decl_stmt|;
name|struct
name|access_point
modifier|*
name|ap_append
argument_list|()
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"di2cref"
operator|)
argument_list|)
expr_stmt|;
name|di_log
argument_list|(
name|di
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|di
operator|->
name|di_state
condition|)
block|{
case|case
name|DI_ACCESSPOINT
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"di2cref - generating referrral from di_accesspoints"
operator|)
argument_list|)
expr_stmt|;
comment|/* Should check context */
name|err
operator|->
name|dse_type
operator|=
name|DSE_REFERRAL
expr_stmt|;
name|err
operator|->
name|ERR_REFERRAL
operator|.
name|DSE_ref_prefix
operator|=
name|NULLDN
expr_stmt|;
name|cref
operator|=
name|err
operator|->
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|=
operator|(
expr|struct
name|continuation_ref
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_ref
argument_list|)
argument_list|)
expr_stmt|;
name|cref
operator|->
name|cr_accesspoints
operator|=
name|ap_cpy
argument_list|(
name|di
operator|->
name|di_accesspoints
argument_list|)
expr_stmt|;
name|cref
operator|->
name|cr_name
operator|=
name|dn_cpy
argument_list|(
name|di
operator|->
name|di_target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cref
operator|->
name|cr_rdn_resolved
operator|=
name|di
operator|->
name|di_rdn_resolved
operator|)
operator|<=
literal|0
condition|)
block|{
name|cref
operator|->
name|cr_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_NOTSTARTED
expr_stmt|;
name|cref
operator|->
name|cr_progress
operator|.
name|op_nextrdntoberesolved
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cref
operator|->
name|cr_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_PROCEEDING
expr_stmt|;
name|cref
operator|->
name|cr_progress
operator|.
name|op_nextrdntoberesolved
operator|=
name|di
operator|->
name|di_rdn_resolved
expr_stmt|;
block|}
name|cref
operator|->
name|cr_aliasedRDNs
operator|=
name|di
operator|->
name|di_aliasedRDNs
expr_stmt|;
name|cref
operator|->
name|cr_reftype
operator|=
name|di
operator|->
name|di_reftype
expr_stmt|;
break|break;
case|case
name|DI_COMPLETE
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"di2cref - generating referrral from di_entry"
operator|)
argument_list|)
expr_stmt|;
comment|/* Should check context */
name|err
operator|->
name|dse_type
operator|=
name|DSE_REFERRAL
expr_stmt|;
name|err
operator|->
name|ERR_REFERRAL
operator|.
name|DSE_ref_prefix
operator|=
name|NULLDN
expr_stmt|;
name|cref
operator|=
name|err
operator|->
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|=
operator|(
expr|struct
name|continuation_ref
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|continuation_ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cref
operator|->
name|cr_accesspoints
operator|=
name|di2ap
argument_list|(
name|di
argument_list|)
operator|)
operator|==
name|NULLACCESSPOINT
condition|)
return|return
name|NOTOK
return|;
name|cref
operator|->
name|cr_name
operator|=
name|dn_cpy
argument_list|(
name|di
operator|->
name|di_target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cref
operator|->
name|cr_rdn_resolved
operator|=
name|di
operator|->
name|di_rdn_resolved
operator|)
operator|<=
literal|0
condition|)
block|{
name|cref
operator|->
name|cr_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_NOTSTARTED
expr_stmt|;
name|cref
operator|->
name|cr_progress
operator|.
name|op_nextrdntoberesolved
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cref
operator|->
name|cr_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_PROCEEDING
expr_stmt|;
name|cref
operator|->
name|cr_progress
operator|.
name|op_nextrdntoberesolved
operator|=
name|di
operator|->
name|di_rdn_resolved
expr_stmt|;
block|}
name|cref
operator|->
name|cr_aliasedRDNs
operator|=
name|di
operator|->
name|di_aliasedRDNs
expr_stmt|;
name|cref
operator|->
name|cr_reftype
operator|=
name|di
operator|->
name|di_reftype
expr_stmt|;
break|break;
case|case
name|DI_DEFERRED
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"di2cref - Trying to turn deferred di_block into continuation reference!"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"di2cref - invalid di_state %d"
operator|,
name|di
operator|->
name|di_state
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|ctx
operator|==
name|DS_CTX_QUIPU_DSP
condition|)
block|{
comment|/* Make QSSR */
comment|/* append AP's from remaining di_blocks */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Making a QSSR"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|di
operator|->
name|di_next
init|;
name|loop
operator|!=
name|NULL_DI_BLOCK
condition|;
name|loop
operator|=
name|loop
operator|->
name|di_next
control|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|di2ap
argument_list|(
name|loop
argument_list|)
operator|)
operator|==
name|NULLACCESSPOINT
condition|)
return|return
name|OK
return|;
comment|/* Have finished - return OK */
name|cref
operator|->
name|cr_accesspoints
operator|=
name|ap_append
argument_list|(
name|cref
operator|->
name|cr_accesspoints
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|OK
return|;
block|}
end_function

begin_macro
name|oper_fail_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"oper_fail_wakeup()"
operator|)
argument_list|)
expr_stmt|;
comment|/*     *  Attempt to perform operation remotely has failed.     *  Check the type of operation and take appropriate action.     */
if|if
condition|(
name|on
operator|==
name|NULLOPER
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"No operation to fail"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|on
operator|->
name|on_type
condition|)
block|{
case|case
name|ON_TYPE_X500
case|:
name|task_fail_wakeup
argument_list|(
name|on
argument_list|)
expr_stmt|;
break|break;
case|case
name|ON_TYPE_SUBTASK
case|:
name|subtask_fail_wakeup
argument_list|(
name|on
argument_list|)
expr_stmt|;
break|break;
case|case
name|ON_TYPE_BIND_COMPARE
case|:
name|bind_compare_fail_wakeup
argument_list|(
name|on
argument_list|)
expr_stmt|;
break|break;
case|case
name|ON_TYPE_GET_DSA_INFO
case|:
name|dsa_info_fail_wakeup
argument_list|(
name|on
argument_list|)
expr_stmt|;
break|break;
case|case
name|ON_TYPE_GET_EDB
case|:
name|get_edb_fail_wakeup
argument_list|(
name|on
argument_list|)
expr_stmt|;
break|break;
case|case
name|ON_TYPE_SHADOW
case|:
name|shadow_fail_wakeup
argument_list|(
name|on
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"oper_fail_wakeup - op has invalid type"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|subtask_chain
argument_list|(
argument|tk
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ds_search_task
modifier|*
name|refer
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
name|nref
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
name|trail
init|=
name|NULL_ST
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
name|st_done
parameter_list|()
function_decl|;
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di_tmp
decl_stmt|;
specifier|register
name|struct
name|chain_arg
modifier|*
name|tkcha
init|=
operator|&
operator|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_charg
operator|)
decl_stmt|;
specifier|register
name|struct
name|chain_arg
modifier|*
name|oncha
decl_stmt|;
name|struct
name|trace_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|DSError
name|err
decl_stmt|;
name|struct
name|common_args
modifier|*
name|ca
decl_stmt|;
name|struct
name|common_args
modifier|*
name|get_ca_ref
parameter_list|()
function_decl|;
name|ca
operator|=
name|get_ca_ref
argument_list|(
operator|&
operator|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|->
name|refer_st
operator|==
name|NULL_ST
condition|)
return|return;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Chain search subtasks ..."
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|refer
operator|=
name|tk
operator|->
name|refer_st
init|;
name|refer
operator|!=
name|NULL_ST
condition|;
name|refer
operator|=
name|nref
control|)
block|{
name|nref
operator|=
name|refer
operator|->
name|st_next
expr_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|refer
operator|->
name|st_di
operator|)
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"search referred without di_block list"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sort_dsa_list
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
name|err
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|=
name|NULLCONTINUATIONREF
expr_stmt|;
if|if
condition|(
operator|(
name|di_tmp
operator|=
name|select_refer_dsa
argument_list|(
name|di
argument_list|,
name|tk
argument_list|)
operator|)
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
comment|/* The remote END is probably unable to follow the referral - chain if allowed */
for|for
control|(
name|di_tmp
operator|=
name|di
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|di_tmp
operator|->
name|di_state
operator|==
name|DI_DEFERRED
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEBUG
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"About to call di2cref with:"
operator|)
argument_list|)
expr_stmt|;
name|di_log
argument_list|(
name|di_tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|di2cref
argument_list|(
name|di_tmp
argument_list|,
operator|&
name|err
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
argument_list|)
operator|==
name|OK
condition|)
break|break;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|di2cref
argument_list|(
name|di_tmp
argument_list|,
operator|&
name|err
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
argument_list|)
expr_stmt|;
name|on
operator|=
name|oper_alloc
argument_list|()
expr_stmt|;
name|on
operator|->
name|on_type
operator|=
name|ON_TYPE_SUBTASK
expr_stmt|;
name|on
operator|->
name|on_dsas
operator|=
name|di
expr_stmt|;
for|for
control|(
name|di_tmp
operator|=
name|di
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
name|di_tmp
operator|->
name|di_type
operator|=
name|DI_OPERATION
expr_stmt|;
name|di_tmp
operator|->
name|di_oper
operator|=
name|on
expr_stmt|;
block|}
name|on
operator|->
name|on_subtask
operator|=
name|refer
expr_stmt|;
name|on
operator|->
name|on_task
operator|=
name|tk
expr_stmt|;
name|on
operator|->
name|on_next_task
operator|=
name|tk
operator|->
name|tk_operlist
expr_stmt|;
name|tk
operator|->
name|tk_operlist
operator|=
name|on
expr_stmt|;
name|oncha
operator|=
operator|&
operator|(
name|on
operator|->
name|on_req
operator|.
name|dca_charg
operator|)
expr_stmt|;
if|if
condition|(
name|refer
operator|->
name|st_alias
operator|==
name|NULLDN
condition|)
block|{
if|if
condition|(
name|err
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
condition|)
name|oncha
operator|->
name|cha_target
operator|=
name|dn_cpy
argument_list|(
name|err
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|->
name|cr_name
argument_list|)
expr_stmt|;
else|else
name|oncha
operator|->
name|cha_target
operator|=
name|dn_cpy
argument_list|(
name|di
operator|->
name|di_target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oncha
operator|->
name|cha_target
operator|=
name|dn_cpy
argument_list|(
name|refer
operator|->
name|st_alias
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|di
operator|->
name|di_rdn_resolved
operator|<=
literal|0
condition|)
block|{
name|oncha
operator|->
name|cha_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_NOTSTARTED
expr_stmt|;
name|oncha
operator|->
name|cha_progress
operator|.
name|op_nextrdntoberesolved
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|oncha
operator|->
name|cha_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_PROCEEDING
expr_stmt|;
name|oncha
operator|->
name|cha_progress
operator|.
name|op_nextrdntoberesolved
operator|=
name|di
operator|->
name|di_rdn_resolved
expr_stmt|;
block|}
name|oncha
operator|->
name|cha_aliasderef
operator|=
operator|(
operator|(
name|oncha
operator|->
name|cha_aliasedrdns
operator|=
name|di
operator|->
name|di_aliasedRDNs
operator|)
operator|!=
name|CR_NOALIASEDRDNS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|oncha
operator|->
name|cha_reftype
operator|=
name|di
operator|->
name|di_reftype
operator|)
operator|==
name|RT_UNDEFINED
condition|)
name|oncha
operator|->
name|cha_reftype
operator|=
name|RT_SUPERIOR
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_6_0
name|oncha
operator|->
name|cha_entryonly
operator|=
name|FALSE
expr_stmt|;
else|#
directive|else
name|oncha
operator|->
name|cha_entryonly
operator|=
name|refer
operator|->
name|st_entryonly
expr_stmt|;
endif|#
directive|endif
name|oncha
operator|->
name|cha_returnrefs
operator|=
name|FALSE
expr_stmt|;
name|oncha
operator|->
name|cha_domaininfo
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|tk
operator|->
name|tk_timed
operator|==
name|FALSE
condition|)
block|{
name|oncha
operator|->
name|cha_timelimit
operator|=
name|NULLCP
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CHAIN_ARGS_TIMEOUT
name|struct
name|UTCtime
name|ut
decl_stmt|;
name|tm2ut
argument_list|(
name|gmtime
argument_list|(
operator|&
operator|(
name|tk
operator|->
name|tk_timeout
operator|)
argument_list|)
argument_list|,
operator|&
operator|(
name|ut
operator|)
argument_list|)
expr_stmt|;
name|oncha
operator|->
name|cha_timelimit
operator|=
name|strdup
argument_list|(
name|utct2str
argument_list|(
operator|&
name|ut
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|oncha
operator|->
name|cha_timelimit
operator|=
name|NULLCP
expr_stmt|;
endif|#
directive|endif
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Checking history of op"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
operator|==
name|DS_CTX_X500_DAP
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"... user originated ..."
operator|)
argument_list|)
expr_stmt|;
name|oncha
operator|->
name|cha_originator
operator|=
name|dn_cpy
argument_list|(
name|tk
operator|->
name|tk_conn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
name|oncha
operator|->
name|cha_trace
operator|=
name|NULLTRACEINFO
expr_stmt|;
block|}
else|else
block|{
name|oncha
operator|->
name|cha_originator
operator|=
name|dn_cpy
argument_list|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_charg
operator|.
name|cha_originator
argument_list|)
expr_stmt|;
name|oncha
operator|->
name|cha_trace
operator|=
name|ti_cpy
argument_list|(
name|tkcha
operator|->
name|cha_trace
argument_list|)
expr_stmt|;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Setting trace info"
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|=
operator|(
expr|struct
name|trace_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trace_info
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_dsa
operator|=
name|dn_cpy
argument_list|(
name|mydsadn
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_target
operator|=
name|dn_cpy
argument_list|(
name|di
operator|->
name|di_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|di_rdn_resolved
operator|<=
literal|0
condition|)
block|{
name|ti
operator|->
name|ti_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_NOTSTARTED
expr_stmt|;
name|ti
operator|->
name|ti_progress
operator|.
name|op_nextrdntoberesolved
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ti
operator|->
name|ti_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_PROCEEDING
expr_stmt|;
name|ti
operator|->
name|ti_progress
operator|.
name|op_nextrdntoberesolved
operator|=
name|di
operator|->
name|di_rdn_resolved
expr_stmt|;
block|}
name|ti
operator|->
name|ti_next
operator|=
name|oncha
operator|->
name|cha_trace
expr_stmt|;
name|oncha
operator|->
name|cha_trace
operator|=
name|ti
expr_stmt|;
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|=
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_dsarg
expr_stmt|;
comment|/* struct copy */
comment|/* 	(void) ds_arg_dup (&(tk->tk_dx.dx_arg.dca_dsarg),&(on->on_req.dca_dsarg)); */
ifdef|#
directive|ifdef
name|COMPAT_6_0
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_sr
operator|.
name|sra_subset
operator|=
name|refer
operator|->
name|st_subset
expr_stmt|;
endif|#
directive|endif
name|on
operator|->
name|on_arg
operator|=
operator|&
operator|(
name|on
operator|->
name|on_req
operator|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Generating search subtask OP"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|&
name|SVC_OPT_CHAININGPROHIBIT
operator|)
operator|||
operator|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|!=
name|OK
operator|)
condition|)
block|{
name|add_cref2poq
argument_list|(
operator|&
name|tk
operator|->
name|tk_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_sr
argument_list|,
name|err
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
argument_list|)
expr_stmt|;
name|oper_task_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|trail
operator|==
name|NULL_ST
condition|)
name|tk
operator|->
name|refer_st
operator|=
name|st_done
argument_list|(
operator|&
name|refer
argument_list|)
expr_stmt|;
else|else
name|trail
operator|->
name|st_next
operator|=
name|st_done
argument_list|(
operator|&
name|refer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|refer
operator|->
name|st_cr
operator|=
name|err
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
expr_stmt|;
name|trail
operator|=
name|refer
expr_stmt|;
block|}
block|}
if|if
condition|(
name|trail
operator|!=
name|NULL_ST
condition|)
name|trail
operator|->
name|st_next
operator|=
name|tk
operator|->
name|referred_st
expr_stmt|;
name|tk
operator|->
name|referred_st
operator|=
name|tk
operator|->
name|refer_st
expr_stmt|;
name|tk
operator|->
name|refer_st
operator|=
name|NULL_ST
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|->
name|referred_st
operator|==
name|NULL_ST
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_state
operator|==
name|TK_PASSIVE
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_operlist
operator|==
name|NULLOPER
operator|)
condition|)
block|{
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_result
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|subtask_result_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
modifier|*
name|next_st
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
name|st
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"subtask_result_wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|=
name|on
operator|->
name|on_task
operator|)
operator|==
name|NULLTASK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Oper can't wake up (result)extracted task"
operator|)
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	*  Were waiting for a remote subtask result and here it is. 	*/
name|next_st
operator|=
operator|&
operator|(
name|tk
operator|->
name|referred_st
operator|)
expr_stmt|;
for|for
control|(
name|st
operator|=
name|tk
operator|->
name|referred_st
init|;
name|st
operator|!=
name|NULL_ST
condition|;
name|st
operator|=
operator|(
operator|*
name|next_st
operator|)
control|)
block|{
if|if
condition|(
name|st
operator|==
name|on
operator|->
name|on_subtask
condition|)
break|break;
name|next_st
operator|=
operator|&
operator|(
name|st
operator|->
name|st_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|==
name|NULL_ST
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"subtask_result_wakeup - subtask lost from referred list"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	    *  Correlate uncorrelated search results from oper, 	    *  then merge with correlated search results of task. 	    */
name|struct
name|ds_search_result
modifier|*
name|tk_sr
init|=
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_sr
operator|)
decl_stmt|;
name|struct
name|ds_search_result
modifier|*
name|op_sr
init|=
operator|&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_sr
operator|)
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Collating a search result"
operator|)
argument_list|)
expr_stmt|;
name|st_comp_free
argument_list|(
name|st
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_st
operator|)
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
name|correlate_search_results
argument_list|(
name|op_sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk_sr
operator|->
name|srr_next
operator|==
name|NULLSRR
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Search result unallocated!"
operator|)
argument_list|)
expr_stmt|;
name|tk_sr
operator|->
name|srr_next
operator|=
operator|(
expr|struct
name|ds_search_result
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ds_search_result
argument_list|)
argument_list|)
expr_stmt|;
name|tk_sr
operator|->
name|srr_next
operator|->
name|srr_correlated
operator|=
name|TRUE
expr_stmt|;
name|tk_sr
operator|->
name|srr_next
operator|->
name|srr_un
operator|.
name|srr_unit
operator|=
operator|(
expr|struct
name|ds_search_unit
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ds_search_unit
argument_list|)
argument_list|)
expr_stmt|;
name|tk_sr
operator|->
name|srr_next
operator|->
name|CSR_limitproblem
operator|=
name|LSR_NOLIMITPROBLEM
expr_stmt|;
block|}
name|merge_search_results
argument_list|(
name|tk_sr
operator|->
name|srr_next
argument_list|,
name|op_sr
argument_list|)
expr_stmt|;
block|}
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|->
name|referred_st
operator|==
name|NULL_ST
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_state
operator|==
name|TK_PASSIVE
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_operlist
operator|==
name|NULLOPER
operator|)
condition|)
block|{
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_result
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|subtask_error_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
modifier|*
name|next_st
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
name|st
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"subtask_error_wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|=
name|on
operator|->
name|on_task
operator|)
operator|==
name|NULLTASK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Oper can't wake up (error) extracted task"
operator|)
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	*  Were waiting for a remote subtask result and got a remote error. 	*  If it is a referral, then rechain the operation if appropriate 	*  otherwise dump the subtask and check the task for completion. 	*/
comment|/* 	ds_error_free(&(tk->tk_resp.di_error.de_err)); */
name|tk
operator|->
name|tk_error
operator|=
operator|&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|==
name|DSE_DSAREFERRAL
operator|)
operator|||
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|==
name|DSE_REFERRAL
operator|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Try rechaining st"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper_rechain
argument_list|(
name|on
argument_list|)
operator|==
name|OK
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Succeeded rechaining st"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Failed rechaining st"
operator|)
argument_list|)
expr_stmt|;
name|add_cref2poq
argument_list|(
operator|&
name|tk
operator|->
name|tk_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_sr
argument_list|,
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_REFERRAL
operator|.
name|DSE_ref_candidates
operator|=
name|NULLCONTINUATIONREF
expr_stmt|;
block|}
name|next_st
operator|=
operator|&
operator|(
name|tk
operator|->
name|referred_st
operator|)
expr_stmt|;
for|for
control|(
name|st
operator|=
name|tk
operator|->
name|referred_st
init|;
name|st
operator|!=
name|NULL_ST
condition|;
name|st
operator|=
operator|(
operator|*
name|next_st
operator|)
control|)
block|{
if|if
condition|(
name|st
operator|==
name|on
operator|->
name|on_subtask
condition|)
break|break;
name|next_st
operator|=
operator|&
operator|(
name|st
operator|->
name|st_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|==
name|NULL_ST
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"subtask_result_wakeup - subtask lost from referred list"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|st_comp_free
argument_list|(
name|st
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_st
operator|)
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
block|}
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|->
name|referred_st
operator|==
name|NULL_ST
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_state
operator|==
name|TK_PASSIVE
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_operlist
operator|==
name|NULLOPER
operator|)
condition|)
block|{
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_result
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|subtask_fail_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
modifier|*
name|next_st
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
name|st
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"subtask_fail_wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|=
name|on
operator|->
name|on_task
operator|)
operator|==
name|NULLTASK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"subtask_fail_wakeup: no task"
operator|)
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|next_st
operator|=
operator|&
operator|(
name|tk
operator|->
name|referred_st
operator|)
expr_stmt|;
for|for
control|(
name|st
operator|=
name|tk
operator|->
name|referred_st
init|;
name|st
operator|!=
name|NULL_ST
condition|;
name|st
operator|=
operator|(
operator|*
name|next_st
operator|)
control|)
block|{
if|if
condition|(
name|st
operator|==
name|on
operator|->
name|on_subtask
condition|)
break|break;
name|next_st
operator|=
operator|&
operator|(
name|st
operator|->
name|st_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|==
name|NULL_ST
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"subtask_result_wakeup - subtask lost from referred list"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_cref2poq
argument_list|(
operator|&
name|tk
operator|->
name|tk_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_sr
argument_list|,
name|st
operator|->
name|st_cr
argument_list|)
expr_stmt|;
name|st_comp_free
argument_list|(
name|st
argument_list|)
expr_stmt|;
operator|(
operator|*
name|next_st
operator|)
operator|=
name|st
operator|->
name|st_next
expr_stmt|;
block|}
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tk
operator|->
name|referred_st
operator|==
name|NULL_ST
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_state
operator|==
name|TK_PASSIVE
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_operlist
operator|==
name|NULLOPER
operator|)
condition|)
block|{
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_result
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|->
name|dse_type
operator|!=
name|DSE_REFERRAL
operator|)
operator|&&
operator|(
name|err
operator|->
name|dse_type
operator|!=
name|DSE_DSAREFERRAL
operator|)
condition|)
block|{
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_UNAVAILABLE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|subtask_dsa_info_wakeup
argument_list|(
argument|di
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|task_act
modifier|*
name|tk
init|=
name|di
operator|->
name|di_task
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"subtask_dsa_info_wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|==
name|NULLTASK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"subtask_dsa_info_wakeup no task"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*     * Were waiting for a reference to return.     * Check if the reference now returned is acceptable.     * If it is return a referral and unwrap everything,     * otherwise try another di_block for the reference.     */
if|if
condition|(
name|di2cref
argument_list|(
name|di
argument_list|,
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
argument_list|,
name|tk
operator|->
name|tk_conn
operator|->
name|cn_ctx
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"subtask_dsa_info_wakeup - reference not acceptable"
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove di_block which generated unwanted referral wait */
if|if
condition|(
name|tk
operator|->
name|tk_dsas
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
comment|/* No more dsas from which to request info to form referral */
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_INVALIDREFERENCE
expr_stmt|;
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_error
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
name|task_conn_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_error
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|add_cref2poq
argument_list|(
argument|res
argument_list|,
argument|cref
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ds_search_result
modifier|*
name|res
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ContinuationRef
name|cref
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ContinuationRef
name|cr
decl_stmt|;
if|if
condition|(
name|res
operator|->
name|CSR_cr
operator|==
name|NULLCONTINUATIONREF
condition|)
block|{
name|res
operator|->
name|CSR_cr
operator|=
name|cref
expr_stmt|;
return|return;
block|}
for|for
control|(
name|cr
operator|=
name|res
operator|->
name|CSR_cr
init|;
name|cr
operator|->
name|cr_next
operator|!=
name|NULLCONTINUATIONREF
condition|;
name|cr
operator|=
name|cr
operator|->
name|cr_next
control|)
empty_stmt|;
name|cr
operator|->
name|cr_next
operator|=
name|cref
expr_stmt|;
block|}
end_block

begin_macro
name|relay_dsa
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|DSError
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
init|=
name|NULL_DI_BLOCK
decl_stmt|;
name|Entry
name|my_entry
decl_stmt|;
name|Attr_Sequence
name|as
decl_stmt|,
name|entry_find_type
argument_list|()
decl_stmt|;
name|AV_Sequence
name|avs
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_trail
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
init|=
name|NULLDNSEQ
decl_stmt|;
if|if
condition|(
operator|(
name|on
operator|==
name|NULLOPER
operator|)
operator|||
operator|(
name|on
operator|->
name|on_relay
operator|==
name|FALSE
operator|)
operator|||
operator|(
name|on
operator|->
name|on_relay
operator|==
literal|2
operator|)
comment|/* relayed once before */
operator|||
operator|(
name|on
operator|->
name|on_task
operator|==
name|NULLTASK
operator|)
operator|||
operator|(
name|on
operator|->
name|on_task
operator|->
name|tk_conn
operator|==
name|NULLCONN
operator|)
operator|||
operator|(
name|on
operator|->
name|on_task
operator|->
name|tk_conn
operator|->
name|cn_ctx
operator|!=
name|DS_CTX_X500_DAP
operator|)
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|my_entry
operator|=
name|local_find_entry_aux
argument_list|(
name|mydsadn
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|as
operator|=
name|entry_find_type
argument_list|(
name|my_entry
argument_list|,
name|at_relaydsa
argument_list|)
operator|)
operator|==
name|NULLATTR
condition|)
return|return
name|NOTOK
return|;
name|di_trail
operator|=
operator|&
name|di
expr_stmt|;
for|for
control|(
name|avs
operator|=
name|as
operator|->
name|attr_value
init|;
name|avs
operator|!=
name|NULLAV
condition|;
name|avs
operator|=
name|avs
operator|->
name|avseq_next
control|)
block|{
if|if
condition|(
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|get_dsa_info
argument_list|(
operator|(
name|DN
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|,
name|dn_stack
argument_list|,
operator|&
name|err
argument_list|,
name|di_trail
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
comment|/* di_trail is a completed dsa info block */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"In relay gdiOK:"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
operator|*
name|di_trail
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|di_trail
operator|)
operator|->
name|di_target
operator|=
name|NULLDN
expr_stmt|;
name|di_trail
operator|=
operator|&
operator|(
operator|(
operator|*
name|di_trail
operator|)
operator|->
name|di_next
operator|)
expr_stmt|;
break|break;
case|case
name|DS_CONTINUE
case|:
comment|/* di_trail is a deferred dsa info block */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"In relay gdiCONT:"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
operator|*
name|di_trail
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|di_trail
operator|)
operator|->
name|di_target
operator|=
name|NULLDN
expr_stmt|;
name|di_trail
operator|=
operator|&
operator|(
operator|(
operator|*
name|di_trail
operator|)
operator|->
name|di_next
operator|)
expr_stmt|;
break|break;
case|case
name|DS_X500_ERROR
case|:
comment|/* Error encountered generating di_block */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"relay - get_dsa_info (slave) returned X500 ERROR"
operator|)
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"dsa_info_new - get_dsa_info (master) unexpected return"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|on
operator|->
name|on_relay
operator|=
literal|2
expr_stmt|;
comment|/* Don't relay twice to same DSA ! */
if|if
condition|(
name|di
operator|==
name|NULL_DI_BLOCK
condition|)
return|return
name|NOTOK
return|;
name|on
operator|->
name|on_dsas
operator|=
name|di
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

end_unit

