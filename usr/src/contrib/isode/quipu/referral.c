begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* referral.c - create referral notices */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/referral.c,v 7.3 91/02/22 09:39:46 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/referral.c,v 7.3 91/02/22 09:39:46 mrose Interim $  *  *  * $Log:	referral.c,v $  * Revision 7.3  91/02/22  09:39:46  mrose  * Interim 6.8  *   * Revision 7.2  90/10/17  11:54:41  mrose  * sync  *   * Revision 7.1  89/12/19  16:20:45  mrose  * sync  *   * Revision 7.0  89/11/23  22:18:01  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|remote_lookup
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|PSAPaddr
modifier|*
name|psap_cpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|dn_seq
modifier|*
name|dn_seq_push
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|dn_seq
modifier|*
name|dn_seq_pop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|di_block
modifier|*
name|di_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|access_point
modifier|*
name|top_ap
init|=
name|NULLACCESSPOINT
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|access_point
modifier|*
name|ap_cpy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|access_point
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|access_point
modifier|*
name|ret_ap
decl_stmt|;
name|struct
name|access_point
modifier|*
modifier|*
name|tmp_ap
decl_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULLACCESSPOINT
condition|)
return|return
operator|(
name|NULLACCESSPOINT
operator|)
return|;
for|for
control|(
name|tmp_ap
operator|=
operator|&
name|ret_ap
init|;
name|ap
operator|!=
name|NULLACCESSPOINT
condition|;
name|ap
operator|=
name|ap
operator|->
name|ap_next
control|)
block|{
operator|(
operator|*
name|tmp_ap
operator|)
operator|=
operator|(
expr|struct
name|access_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|access_point
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|tmp_ap
operator|)
operator|->
name|ap_name
operator|=
name|dn_cpy
argument_list|(
name|ap
operator|->
name|ap_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ap_address
condition|)
operator|(
operator|*
name|tmp_ap
operator|)
operator|->
name|ap_address
operator|=
name|psap_cpy
argument_list|(
name|ap
operator|->
name|ap_address
argument_list|)
expr_stmt|;
name|tmp_ap
operator|=
operator|&
operator|(
operator|(
operator|*
name|tmp_ap
operator|)
operator|->
name|ap_next
operator|)
expr_stmt|;
block|}
operator|(
operator|*
name|tmp_ap
operator|)
operator|=
name|NULLACCESSPOINT
expr_stmt|;
return|return
operator|(
name|ret_ap
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ContinuationRef
name|new_ref
parameter_list|(
name|name
parameter_list|,
name|rt
parameter_list|,
name|ap
parameter_list|)
name|DN
name|name
decl_stmt|;
name|int
name|rt
decl_stmt|;
name|struct
name|access_point
modifier|*
name|ap
decl_stmt|;
block|{
name|ContinuationRef
name|ptr
decl_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULLACCESSPOINT
condition|)
return|return
operator|(
name|NULLCONTINUATIONREF
operator|)
return|;
name|ptr
operator|=
operator|(
name|ContinuationRef
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|continuation_ref
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|cr_aliasedRDNs
operator|=
name|CR_NOALIASEDRDNS
expr_stmt|;
name|ptr
operator|->
name|cr_name
operator|=
name|dn_cpy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|cr_rdn_resolved
operator|=
name|CR_RDNRESOLVED_NOTDEFINED
expr_stmt|;
name|ptr
operator|->
name|cr_reftype
operator|=
name|rt
expr_stmt|;
name|ptr
operator|->
name|cr_accesspoints
operator|=
name|ap_cpy
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|access_point
modifier|*
name|ap_append
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|access_point
modifier|*
name|a
decl_stmt|;
name|struct
name|access_point
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|access_point
modifier|*
name|trail
decl_stmt|;
name|struct
name|access_point
modifier|*
name|top
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULLACCESSPOINT
condition|)
return|return
operator|(
name|b
operator|)
return|;
if|if
condition|(
name|b
operator|==
name|NULLACCESSPOINT
condition|)
return|return
operator|(
name|a
operator|)
return|;
for|for
control|(
name|top
operator|=
name|a
init|;
name|a
operator|!=
name|NULLACCESSPOINT
condition|;
name|a
operator|=
name|a
operator|->
name|ap_next
control|)
name|trail
operator|=
name|a
expr_stmt|;
name|trail
operator|->
name|ap_next
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_function
name|ContinuationRef
name|cont_ref_parent
parameter_list|(
name|name
parameter_list|)
name|DN
name|name
decl_stmt|;
block|{
return|return
operator|(
name|new_ref
argument_list|(
name|name
argument_list|,
name|RT_SUPERIOR
argument_list|,
name|top_ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|add_str_parent
argument_list|(
argument|sdn
argument_list|,
argument|spsap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sdn
decl_stmt|,
modifier|*
name|spsap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DN
name|dn
decl_stmt|,
name|str2dn
argument_list|()
decl_stmt|;
name|struct
name|PSAPaddr
modifier|*
name|psap
decl_stmt|,
modifier|*
name|str2paddr
argument_list|()
decl_stmt|;
name|struct
name|access_point
modifier|*
name|next_ap
decl_stmt|;
comment|/* add string DN and string PSAP to list of parents */
if|if
condition|(
operator|(
name|psap
operator|=
name|str2paddr
argument_list|(
name|spsap
argument_list|)
operator|)
operator|==
name|NULLPA
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid parent address %s"
operator|,
name|spsap
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|dn
operator|=
name|str2dn
argument_list|(
name|sdn
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid parent dn %s"
operator|,
name|sdn
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|next_ap
operator|=
operator|(
expr|struct
name|access_point
operator|*
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|access_point
argument_list|)
argument_list|)
expr_stmt|;
name|next_ap
operator|->
name|ap_name
operator|=
name|dn
expr_stmt|;
name|next_ap
operator|->
name|ap_address
operator|=
name|psap_cpy
argument_list|(
name|psap
argument_list|)
expr_stmt|;
name|next_ap
operator|->
name|ap_next
operator|=
name|NULLACCESSPOINT
expr_stmt|;
name|top_ap
operator|=
name|ap_append
argument_list|(
name|top_ap
argument_list|,
name|next_ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|PSAPaddr
modifier|*
name|parent_psap
parameter_list|()
block|{
if|if
condition|(
name|top_ap
operator|==
name|NULLACCESSPOINT
condition|)
return|return
operator|(
name|NULLPA
operator|)
return|;
return|return
operator|(
name|top_ap
operator|->
name|ap_address
operator|)
return|;
block|}
end_function

begin_comment
comment|/* *  Generate a list of dsa information blocks (di_block) from the master-dsa *  and slave-dsa attributes of the entry, the dsa dn for which an info block *  is generated is the name from the attribute. *  Currently all of the dsa DNs are used to generate info blocks in the *  list; since this requires access to the entry for each DSA dn this may *  result in some suspended operations being initiated. *  If some info blocks are generated then DS_CONTINUE is returned; *  If no completed or suspended info blocks can be generated then the calling *  process is returned an invalid reference error. * *  NB - As with get_dsa_info, the blocks generated need to be further *  processed by the calling routine. */
end_comment

begin_function
name|int
name|dsa_info_new
parameter_list|(
name|name
parameter_list|,
name|dn_stack
parameter_list|,
name|master
parameter_list|,
name|entry_ptr
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|)
name|DN
name|name
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|int
name|master
decl_stmt|;
name|Entry
name|entry_ptr
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
block|{
name|AV_Sequence
name|avs
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
name|struct
name|DSError
name|err_tmp
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_trail
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|new_dn_stack
decl_stmt|;
name|struct
name|access_point
modifier|*
name|aps
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"in dsa_info_new"
operator|)
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|DS_ERROR_LOCAL
expr_stmt|;
name|di_trail
operator|=
name|di_p
expr_stmt|;
name|new_dn_stack
operator|=
name|dn_seq_push
argument_list|(
name|name
argument_list|,
name|dn_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_ptr
operator|->
name|e_external
condition|)
block|{
name|aps
operator|=
operator|(
expr|struct
name|access_point
operator|*
operator|)
name|entry_ptr
operator|->
name|e_reference
operator|->
name|avseq_av
operator|.
name|av_struct
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|=
name|di_alloc
argument_list|()
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_type
operator|=
name|DI_TASK
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_dn
operator|=
name|dn_cpy
argument_list|(
name|aps
operator|->
name|ap_name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_state
operator|=
name|DI_ACCESSPOINT
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_rdn_resolved
operator|=
name|CR_RDNRESOLVED_NOTDEFINED
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_aliasedRDNs
operator|=
name|CR_NOALIASEDRDNS
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_reftype
operator|=
name|entry_ptr
operator|->
name|e_reftype
operator|)
operator|==
name|RT_NONSPECIFICSUBORDINATE
condition|)
block|{
for|for
control|(
name|avs
operator|=
name|entry_ptr
operator|->
name|e_reference
init|;
name|avs
operator|!=
name|NULLAV
condition|;
name|avs
operator|=
name|avs
operator|->
name|avseq_next
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|access_point
operator|*
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
operator|)
operator|->
name|ap_address
operator|==
name|NULLPA
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"No address in NSSR"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|aps
operator|=
name|ap_cpy
argument_list|(
operator|(
expr|struct
name|access_point
operator|*
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|)
expr_stmt|;
name|aps
operator|->
name|ap_next
operator|=
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_accesspoints
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_accesspoints
operator|=
name|aps
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_accesspoints
operator|==
name|NULLACCESSPOINT
condition|)
block|{
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_INVALIDREFERENCE
expr_stmt|;
name|new_dn_stack
operator|=
name|dn_seq_pop
argument_list|(
name|new_dn_stack
argument_list|)
expr_stmt|;
return|return
name|DS_X500_ERROR
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|aps
operator|->
name|ap_address
operator|!=
name|NULLPA
condition|)
block|{
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_accesspoints
operator|=
name|ap_cpy
argument_list|(
name|aps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|di_free
argument_list|(
operator|*
name|di_p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|get_dsa_info
argument_list|(
name|aps
operator|->
name|ap_name
argument_list|,
name|new_dn_stack
argument_list|,
operator|&
operator|(
name|err_tmp
operator|)
argument_list|,
name|di_p
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
case|case
name|DS_CONTINUE
case|:
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DS_X500_ERROR
case|:
comment|/* Error encountered generating di_block */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"dsa_info_new - get_dsa_info (external) returned X500 ERROR"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err_tmp
operator|.
name|dse_type
operator|==
name|DSE_SERVICEERROR
operator|)
operator|&&
operator|(
name|err_tmp
operator|.
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|==
name|DSE_SV_DITERROR
operator|)
condition|)
block|{
operator|*
name|err
operator|=
name|err_tmp
expr_stmt|;
name|new_dn_stack
operator|=
name|dn_seq_pop
argument_list|(
name|new_dn_stack
argument_list|)
expr_stmt|;
return|return
name|DS_X500_ERROR
return|;
block|}
name|ds_error_free
argument_list|(
operator|&
name|err_tmp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
return|return
name|DS_CONTINUE
return|;
block|}
for|for
control|(
name|avs
operator|=
name|entry_ptr
operator|->
name|e_master
init|;
name|avs
operator|!=
name|NULLAV
condition|;
name|avs
operator|=
name|avs
operator|->
name|avseq_next
control|)
block|{
if|if
condition|(
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|get_dsa_info
argument_list|(
operator|(
name|DN
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|,
name|new_dn_stack
argument_list|,
operator|(
operator|&
name|err_tmp
operator|)
argument_list|,
name|di_trail
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
case|case
name|DS_CONTINUE
case|:
operator|(
operator|*
name|di_trail
operator|)
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|di_trail
operator|=
operator|&
operator|(
operator|(
operator|*
name|di_trail
operator|)
operator|->
name|di_next
operator|)
expr_stmt|;
name|ret_val
operator|=
name|DS_CONTINUE
expr_stmt|;
break|break;
case|case
name|DS_X500_ERROR
case|:
comment|/* Error encountered generating di_block */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"dsa_info_new - get_dsa_info (master) returned X500 ERROR"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err_tmp
operator|.
name|dse_type
operator|==
name|DSE_SERVICEERROR
operator|)
operator|&&
operator|(
name|err_tmp
operator|.
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|==
name|DSE_SV_DITERROR
operator|)
condition|)
block|{
operator|*
name|err
operator|=
name|err_tmp
expr_stmt|;
name|new_dn_stack
operator|=
name|dn_seq_pop
argument_list|(
name|new_dn_stack
argument_list|)
expr_stmt|;
return|return
name|DS_X500_ERROR
return|;
block|}
name|ds_error_free
argument_list|(
operator|&
name|err_tmp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|master
condition|)
block|{
comment|/* repeat for slaves */
for|for
control|(
name|avs
operator|=
name|entry_ptr
operator|->
name|e_slave
init|;
name|avs
operator|!=
name|NULLAV
condition|;
name|avs
operator|=
name|avs
operator|->
name|avseq_next
control|)
block|{
if|if
condition|(
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|get_dsa_info
argument_list|(
operator|(
name|DN
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|,
name|new_dn_stack
argument_list|,
operator|&
operator|(
name|err_tmp
operator|)
argument_list|,
name|di_trail
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
case|case
name|DS_CONTINUE
case|:
operator|(
operator|*
name|di_trail
operator|)
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|di_trail
operator|=
operator|&
operator|(
operator|(
operator|*
name|di_trail
operator|)
operator|->
name|di_next
operator|)
expr_stmt|;
name|ret_val
operator|=
name|DS_CONTINUE
expr_stmt|;
break|break;
case|case
name|DS_X500_ERROR
case|:
comment|/* Error encountered generating di_block */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"dsa_info_new - get_dsa_info slave returned X500 ERROR"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err_tmp
operator|.
name|dse_type
operator|==
name|DSE_SERVICEERROR
operator|)
operator|&&
operator|(
name|err_tmp
operator|.
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|==
name|DSE_SV_DITERROR
operator|)
condition|)
block|{
operator|*
name|err
operator|=
name|err_tmp
expr_stmt|;
name|new_dn_stack
operator|=
name|dn_seq_pop
argument_list|(
name|new_dn_stack
argument_list|)
expr_stmt|;
return|return
name|DS_X500_ERROR
return|;
block|}
name|ds_error_free
argument_list|(
operator|&
name|err_tmp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|out
label|:
empty_stmt|;
name|new_dn_stack
operator|=
name|dn_seq_pop
argument_list|(
name|new_dn_stack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_val
operator|==
name|DS_ERROR_LOCAL
operator|)
operator|||
operator|(
name|ret_val
operator|==
name|DS_X500_ERROR
operator|)
condition|)
block|{
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_INVALIDREFERENCE
expr_stmt|;
name|ret_val
operator|=
name|DS_X500_ERROR
expr_stmt|;
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Invalid reference in entry"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|di_block
modifier|*
name|ap2di
parameter_list|(
name|ap
parameter_list|,
name|name
parameter_list|,
name|master
parameter_list|,
name|di_type
parameter_list|,
name|oper
parameter_list|,
name|cr_type
parameter_list|)
name|struct
name|access_point
modifier|*
name|ap
decl_stmt|;
name|DN
name|name
decl_stmt|;
name|char
name|master
decl_stmt|;
name|char
name|di_type
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|oper
decl_stmt|;
name|int
name|cr_type
decl_stmt|;
block|{
name|struct
name|access_point
modifier|*
name|loop
decl_stmt|;
name|struct
name|di_block
modifier|*
name|res
init|=
name|NULL_DI_BLOCK
decl_stmt|;
name|struct
name|di_block
modifier|*
name|ptr
decl_stmt|;
name|struct
name|di_block
modifier|*
name|trail
decl_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULLACCESSPOINT
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"No acces point to make into a di"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL_DI_BLOCK
return|;
block|}
for|for
control|(
name|loop
operator|=
name|ap
init|;
name|loop
operator|!=
name|NULLACCESSPOINT
condition|;
name|loop
operator|=
name|loop
operator|->
name|ap_next
control|)
block|{
name|ptr
operator|=
name|di_alloc
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|di_dn
operator|=
name|dn_cpy
argument_list|(
name|loop
operator|->
name|ap_name
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|di_reftype
operator|=
name|cr_type
expr_stmt|;
name|ptr
operator|->
name|di_state
operator|=
name|DI_ACCESSPOINT
expr_stmt|;
name|ptr
operator|->
name|di_type
operator|=
name|di_type
expr_stmt|;
name|ptr
operator|->
name|di_oper
operator|=
name|oper
expr_stmt|;
name|ptr
operator|->
name|di_accesspoints
operator|=
operator|(
expr|struct
name|access_point
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|access_point
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|di_accesspoints
operator|->
name|ap_name
operator|=
name|dn_cpy
argument_list|(
name|loop
operator|->
name|ap_name
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|di_accesspoints
operator|->
name|ap_address
operator|=
name|psap_cpy
argument_list|(
name|loop
operator|->
name|ap_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL_DI_BLOCK
condition|)
name|trail
operator|=
name|res
operator|=
name|ptr
expr_stmt|;
else|else
name|trail
operator|=
operator|(
name|trail
operator|->
name|di_next
operator|=
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|master
condition|)
break|break;
comment|/* Only want to use first AP */
block|}
name|sort_dsa_list
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|dsa_info_parent
parameter_list|(
name|name
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|,
name|master
parameter_list|)
name|DN
name|name
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
name|char
name|master
decl_stmt|;
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"dsa_info_parent"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_ap
operator|==
name|NULLACCESSPOINT
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"No parents!"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_INVALIDREFERENCE
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
operator|*
name|di_p
operator|=
name|ap2di
argument_list|(
name|top_ap
argument_list|,
name|name
argument_list|,
name|master
argument_list|,
name|DI_TASK
argument_list|,
name|NULLOPER
argument_list|,
name|RT_SUPERIOR
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_CONTINUE
operator|)
return|;
block|}
end_function

end_unit

