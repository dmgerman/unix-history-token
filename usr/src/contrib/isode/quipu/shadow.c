begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* shadow.c - spot shadowing of entries */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/shadow.c,v 7.2 91/03/09 11:57:05 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/quipu/RCS/shadow.c,v 7.2 91/03/09 11:57:05 mrose Exp $  *  *  * $Log:	shadow.c,v $  * Revision 7.2  91/03/09  11:57:05  mrose  * update  *   * Revision 7.1  91/02/22  09:39:50  mrose  * Interim 6.8  *   * Revision 7.0  90/12/01  18:08:35  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/read.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dua.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_include
include|#
directive|include
file|"quipu/malloc.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STATS
end_ifndef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_stat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dn_seq
modifier|*
name|shades
init|=
name|NULLDNSEQ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dn_seq
modifier|*
name|dn_shades
init|=
name|NULLDNSEQ
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|dn_seq
modifier|*
name|dn_seq_push
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|di_block
modifier|*
name|di_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|oper_act
modifier|*
name|oper_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Entry
name|entry_cpy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|Entry
name|database_root
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|new_version
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Attr_Sequence
name|as_comp_cpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Attr_Sequence
name|entry_find_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|access_point
modifier|*
name|ap_cpy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|time_t
name|timenow
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Entry
name|make_path
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Entry
name|local_find_entry_aux
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|AttributeType
name|at_subord
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|AttributeType
name|at_xref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|AttributeType
name|at_nssr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|AttributeType
name|at_objectclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Attr_Sequence
name|cpy_as_comp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|short
name|syntax_dn
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_atlist
block|{
name|AttributeType
name|at
decl_stmt|;
name|struct
name|_atlist
modifier|*
name|next
decl_stmt|;
block|}
typedef|*
name|atlist
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLATL
value|(atlist)NULL
end_define

begin_decl_stmt
name|atlist
name|at_list
init|=
name|NULLATL
decl_stmt|;
end_decl_stmt

begin_macro
name|shadow_entry
argument_list|(
argument|eptr
argument_list|)
end_macro

begin_decl_stmt
name|Entry
name|eptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DN
name|dn
decl_stmt|,
name|ndn
decl_stmt|;
name|Attr_Sequence
name|as
decl_stmt|;
name|AV_Sequence
name|avs
decl_stmt|;
name|atlist
name|at
decl_stmt|;
comment|/* All MASTER entries get passed through here. */
comment|/* See if it need shadowing, if so, add to shades */
if|if
condition|(
name|eptr
operator|->
name|e_data
operator|==
name|E_DATA_MASTER
condition|)
block|{
if|if
condition|(
operator|(
name|eptr
operator|->
name|e_dsainfo
operator|)
operator|&&
operator|(
name|quipu_ctx_supported
argument_list|(
name|eptr
argument_list|)
operator|==
literal|2
operator|)
operator|&&
operator|(
name|quipu_version_7
argument_list|(
name|eptr
argument_list|)
operator|)
condition|)
block|{
comment|/* Its a version 7 quipuDSA */
name|dn
operator|=
name|get_copy_dn
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_cmp
argument_list|(
name|dn
argument_list|,
name|mydsadn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return;
comment|/* can't shadow myself ! */
block|}
if|if
condition|(
name|check_dnseq
argument_list|(
name|shades
argument_list|,
name|dn
argument_list|)
operator|==
name|NOTOK
condition|)
name|shades
operator|=
name|dn_seq_push
argument_list|(
name|dn
argument_list|,
name|shades
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|eptr
operator|->
name|e_external
operator|)
operator|&&
operator|(
name|eptr
operator|->
name|e_reftype
operator|!=
name|RT_NONSPECIFICSUBORDINATE
operator|)
condition|)
block|{
name|dn
operator|=
name|get_copy_dn
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_dnseq
argument_list|(
name|shades
argument_list|,
name|dn
argument_list|)
operator|==
name|NOTOK
condition|)
name|shades
operator|=
name|dn_seq_push
argument_list|(
name|dn
argument_list|,
name|shades
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|as
operator|=
name|eptr
operator|->
name|e_attributes
init|;
name|as
operator|!=
name|NULLATTR
condition|;
name|as
operator|=
name|as
operator|->
name|attr_link
control|)
if|if
condition|(
name|as
operator|->
name|attr_type
operator|->
name|oa_syntax
operator|==
name|syntax_dn
condition|)
for|for
control|(
name|at
operator|=
name|at_list
init|;
name|at
operator|!=
name|NULLATL
condition|;
name|at
operator|=
name|at
operator|->
name|next
control|)
if|if
condition|(
name|as
operator|->
name|attr_type
operator|==
name|at
operator|->
name|at
condition|)
block|{
for|for
control|(
name|avs
operator|=
name|as
operator|->
name|attr_value
init|;
name|avs
operator|!=
name|NULLAV
condition|;
name|avs
operator|=
name|avs
operator|->
name|avseq_next
control|)
block|{
name|ndn
operator|=
operator|(
name|DN
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
expr_stmt|;
if|if
condition|(
name|check_dnseq
argument_list|(
name|dn_shades
argument_list|,
name|ndn
argument_list|)
operator|==
name|NOTOK
condition|)
name|dn_shades
operator|=
name|dn_seq_push
argument_list|(
name|ndn
argument_list|,
name|dn_shades
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|shadow_attribute
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|AttributeType
name|at
decl_stmt|;
name|atlist
name|new_atl
decl_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|AttrT_new
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULLAttrT
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Unknown shadow attr %s"
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|new_atl
operator|=
operator|(
name|atlist
operator|)
name|smalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_atl
argument_list|)
argument_list|)
expr_stmt|;
name|new_atl
operator|->
name|at
operator|=
name|at
expr_stmt|;
name|new_atl
operator|->
name|next
operator|=
name|at_list
expr_stmt|;
name|at_list
operator|=
name|new_atl
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|shadow_update
argument_list|()
end_macro

begin_block
block|{
name|struct
name|dn_seq
modifier|*
name|dnseq
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|op
decl_stmt|;
specifier|static
name|struct
name|ds_read_arg
name|sarg
init|=
block|{
name|default_common_args
block|,
name|NULLDN
block|,
block|{
comment|/* entry info selection */
name|TRUE
block|,
name|NULLATTR
block|,
name|EIS_ATTRIBUTESANDVALUES
block|}
block|}
decl_stmt|;
name|Entry
name|eptr
decl_stmt|;
name|DN
name|tdn
decl_stmt|;
name|struct
name|access_point
modifier|*
name|aps
decl_stmt|;
name|struct
name|DSError
name|err
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"shadow_update"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dnseq
operator|=
name|dn_shades
init|;
name|dnseq
operator|!=
name|NULLDNSEQ
condition|;
name|dnseq
operator|=
name|dnseq
operator|->
name|dns_next
control|)
block|{
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
comment|/* aliases !!! */
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
name|eptr
operator|=
name|make_path
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eptr
operator|->
name|e_alias
condition|)
name|eptr
operator|=
name|make_path
argument_list|(
name|eptr
operator|->
name|e_alias
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|eptr
operator|->
name|e_data
operator|==
name|E_TYPE_SLAVE
operator|)
operator|||
operator|(
name|eptr
operator|->
name|e_data
operator|==
name|E_DATA_MASTER
operator|)
condition|)
continue|continue;
if|if
condition|(
name|check_dnseq
argument_list|(
name|shades
argument_list|,
name|dnseq
operator|->
name|dns_dn
argument_list|)
operator|==
name|NOTOK
condition|)
name|shades
operator|=
name|dn_seq_push
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|,
name|shades
argument_list|)
expr_stmt|;
block|}
name|dn_seq_free
argument_list|(
name|dn_shades
argument_list|)
expr_stmt|;
name|dn_shades
operator|=
name|NULLDNSEQ
expr_stmt|;
for|for
control|(
name|dnseq
operator|=
name|shades
init|;
name|dnseq
operator|!=
name|NULLDNSEQ
condition|;
name|dnseq
operator|=
name|dnseq
operator|->
name|dns_next
control|)
block|{
if|if
condition|(
operator|(
name|op
operator|=
name|oper_alloc
argument_list|()
operator|)
operator|==
name|NULLOPER
condition|)
return|return;
name|op
operator|->
name|on_type
operator|=
name|ON_TYPE_SHADOW
expr_stmt|;
name|op
operator|->
name|on_arg
operator|=
operator|&
operator|(
name|op
operator|->
name|on_req
operator|)
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_type
operator|=
name|OP_READ
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_rd
operator|=
name|sarg
expr_stmt|;
comment|/* struct copy */
name|op
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_rd
operator|.
name|rda_object
operator|=
name|dn_cpy
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_originator
operator|=
name|dn_cpy
argument_list|(
name|mydsadn
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_reftype
operator|=
name|RT_SUBORDINATE
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_PROCEEDING
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_progress
operator|.
name|op_nextrdntoberesolved
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|tdn
operator|=
name|dnseq
operator|->
name|dns_dn
init|;
name|tdn
operator|!=
name|NULLDN
condition|;
name|tdn
operator|=
name|tdn
operator|->
name|dn_parent
control|)
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_progress
operator|.
name|op_nextrdntoberesolved
operator|++
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_trace
operator|=
operator|(
expr|struct
name|trace_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trace_info
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_trace
operator|->
name|ti_dsa
operator|=
name|dn_cpy
argument_list|(
name|mydsadn
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_trace
operator|->
name|ti_target
operator|=
name|dn_cpy
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_trace
operator|->
name|ti_progress
operator|=
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_progress
expr_stmt|;
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_trace
operator|->
name|ti_next
operator|=
name|NULLTRACEINFO
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry_aux
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry_aux
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Shadow entry missing"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|dnseq
operator|->
name|dns_dn
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|op
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|eptr
operator|->
name|e_external
condition|)
block|{
name|op
operator|->
name|on_dsas
operator|=
name|di_alloc
argument_list|()
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_type
operator|=
name|DI_TASK
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_rdn_resolved
operator|=
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_progress
operator|.
name|op_nextrdntoberesolved
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_aliasedRDNs
operator|=
name|CR_NOALIASEDRDNS
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_oper
operator|=
name|op
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_type
operator|=
name|DI_OPERATION
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_reftype
operator|=
name|eptr
operator|->
name|e_reftype
expr_stmt|;
name|aps
operator|=
name|ap_cpy
argument_list|(
operator|(
expr|struct
name|access_point
operator|*
operator|)
name|eptr
operator|->
name|e_reference
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_dn
operator|=
name|dn_cpy
argument_list|(
name|aps
operator|->
name|ap_name
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_accesspoints
operator|=
name|aps
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_state
operator|=
name|DI_ACCESSPOINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|eptr
operator|->
name|e_data
operator|==
name|E_TYPE_SLAVE
operator|)
operator|||
operator|(
name|eptr
operator|->
name|e_data
operator|==
name|E_DATA_MASTER
operator|)
condition|)
block|{
name|op
operator|->
name|on_dsas
operator|=
name|di_alloc
argument_list|()
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_type
operator|=
name|DI_TASK
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_rdn_resolved
operator|=
name|op
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_progress
operator|.
name|op_nextrdntoberesolved
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_aliasedRDNs
operator|=
name|CR_NOALIASEDRDNS
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_oper
operator|=
name|op
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_type
operator|=
name|DI_OPERATION
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_dn
operator|=
name|dn_cpy
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_target
operator|=
name|dn_cpy
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|)
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_reftype
operator|=
name|RT_SUBORDINATE
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_entry
operator|=
name|eptr
expr_stmt|;
name|eptr
operator|->
name|e_refcount
operator|++
expr_stmt|;
name|op
operator|->
name|on_dsas
operator|->
name|di_state
operator|=
name|DI_COMPLETE
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|constructor_dsa_info
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|,
name|NULLDNSEQ
argument_list|,
name|TRUE
argument_list|,
name|eptr
argument_list|,
operator|&
name|err
argument_list|,
operator|&
operator|(
name|op
operator|->
name|on_dsas
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|on_dsas
condition|)
name|schedule_operation
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
name|oper_free
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|shadow_fail_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|oper_act
modifier|*
name|on_tmp
decl_stmt|;
name|struct
name|oper_act
modifier|*
modifier|*
name|on_p
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Shadow fail wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|->
name|on_resp
operator|.
name|di_type
operator|==
name|DI_ERROR
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Remote shadow error"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_rd
operator|.
name|rda_object
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
argument_list|)
expr_stmt|;
block|}
name|on_p
operator|=
operator|&
operator|(
name|get_edb_ops
operator|)
expr_stmt|;
for|for
control|(
name|on_tmp
operator|=
name|get_edb_ops
init|;
name|on_tmp
operator|!=
name|NULLOPER
condition|;
name|on_tmp
operator|=
name|on_tmp
operator|->
name|on_next_task
control|)
block|{
if|if
condition|(
name|on_tmp
operator|==
name|on
condition|)
break|break;
name|on_p
operator|=
operator|&
operator|(
name|on_tmp
operator|->
name|on_next_task
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|on_tmp
operator|!=
name|NULLOPER
condition|)
block|{
operator|(
operator|*
name|on_p
operator|)
operator|=
name|on_tmp
operator|->
name|on_next_task
expr_stmt|;
block|}
else|else
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"subtask_fail_wakeup - op escaped from get_edb_ops (the global list)"
operator|)
argument_list|)
expr_stmt|;
block|}
name|oper_conn_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TURBO_AVL
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|inherit_link
argument_list|(
argument|e
argument_list|,
argument|parent
argument_list|)
end_macro

begin_decl_stmt
name|Entry
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Entry
name|parent
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|set_inheritance
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|process_shadow
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|TURBO_AVL
name|Entry
name|trail
init|=
name|NULLENTRY
decl_stmt|;
endif|#
directive|endif
name|Entry
name|eptr
decl_stmt|,
name|ne
decl_stmt|;
name|struct
name|DSError
name|err
decl_stmt|;
name|Attr_Sequence
name|new_as
decl_stmt|,
name|as
decl_stmt|,
name|tas
decl_stmt|;
name|DN
name|dn
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Process shadow"
operator|)
argument_list|)
expr_stmt|;
name|dn
operator|=
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_rd
operator|.
name|rdr_entry
operator|.
name|ent_dn
expr_stmt|;
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry_aux
argument_list|(
name|dn
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
comment|/* aliases on route !!! */
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry_aux
argument_list|(
name|dn
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Shadow has gone"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|dn
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_as
operator|=
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_rd
operator|.
name|rdr_entry
operator|.
name|ent_attr
expr_stmt|;
if|if
condition|(
name|eptr
operator|->
name|e_external
condition|)
block|{
comment|/* Add in Quipu attributes */
if|if
condition|(
operator|(
operator|(
name|as
operator|=
name|entry_find_type
argument_list|(
name|eptr
argument_list|,
name|at_subord
argument_list|)
operator|)
operator|==
name|NULLATTR
operator|)
operator|&&
operator|(
operator|(
name|as
operator|=
name|entry_find_type
argument_list|(
name|eptr
argument_list|,
name|at_xref
argument_list|)
operator|)
operator|!=
name|NULLATTR
operator|)
operator|&&
operator|(
operator|(
name|as
operator|=
name|entry_find_type
argument_list|(
name|eptr
argument_list|,
name|at_nssr
argument_list|)
operator|)
operator|!=
name|NULLATTR
operator|)
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"external reference missing"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_as
operator|=
name|as_merge
argument_list|(
name|new_as
argument_list|,
name|cpy_as_comp
argument_list|(
name|as
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|as
operator|=
name|as_find_type
argument_list|(
name|new_as
argument_list|,
name|at_objectclass
argument_list|)
operator|)
operator|==
name|NULLATTR
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"no objectclass in shadow entry"
operator|)
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_rd
operator|.
name|rdr_entry
operator|.
name|ent_attr
operator|=
name|new_as
expr_stmt|;
return|return;
block|}
name|tas
operator|=
name|as_comp_new
argument_list|(
name|AttrT_cpy
argument_list|(
name|at_objectclass
argument_list|)
argument_list|,
name|str2avs
argument_list|(
name|EXTERNOBJECT
argument_list|,
name|at_objectclass
argument_list|)
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|new_as
operator|=
name|as_merge
argument_list|(
name|new_as
argument_list|,
name|tas
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_rd
operator|.
name|rdr_entry
operator|.
name|ent_attr
operator|=
name|new_as
expr_stmt|;
block|}
if|if
condition|(
name|as_cmp
argument_list|(
name|eptr
operator|->
name|e_attributes
argument_list|,
name|new_as
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Shadow: no change"
operator|)
argument_list|)
expr_stmt|;
name|eptr
operator|->
name|e_age
operator|=
name|timenow
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|TURBO_AVL
if|if
condition|(
name|eptr
operator|->
name|e_parent
operator|==
name|NULLENTRY
condition|)
name|ne
operator|=
name|database_root
operator|->
name|e_child
expr_stmt|;
else|else
name|ne
operator|=
name|eptr
operator|->
name|e_parent
operator|->
name|e_child
expr_stmt|;
comment|/* bring shadow entry to the top */
for|for
control|(
init|;
name|ne
operator|!=
name|eptr
condition|;
name|ne
operator|=
name|ne
operator|->
name|e_sibling
control|)
name|trail
operator|=
name|ne
expr_stmt|;
if|if
condition|(
name|trail
condition|)
block|{
name|trail
operator|->
name|e_sibling
operator|=
name|eptr
operator|->
name|e_sibling
expr_stmt|;
name|eptr
operator|->
name|e_sibling
operator|=
name|eptr
operator|->
name|e_parent
operator|->
name|e_child
expr_stmt|;
name|eptr
operator|->
name|e_parent
operator|->
name|e_child
operator|=
name|eptr
expr_stmt|;
block|}
endif|#
directive|endif
name|DATABASE_HEAP
expr_stmt|;
name|ne
operator|=
name|entry_cpy
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
name|GENERAL_HEAP
expr_stmt|;
name|as_free
argument_list|(
name|ne
operator|->
name|e_attributes
argument_list|)
expr_stmt|;
name|ne
operator|->
name|e_attributes
operator|=
name|as_cpy
argument_list|(
name|new_as
argument_list|)
expr_stmt|;
if|if
condition|(
name|ne
operator|->
name|e_data
operator|==
name|E_TYPE_CONSTRUCTOR
condition|)
block|{
name|ne
operator|->
name|e_data
operator|=
name|E_TYPE_CACHE_FROM_MASTER
expr_stmt|;
name|new_cacheEDB
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
ifdef|#
directive|ifdef
name|TURBO_INDEX
name|turbo_index_delete
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unravel_attribute
argument_list|(
name|ne
argument_list|,
operator|&
name|err
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"shadow: unravel failure"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|dn
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|entry_free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|check_oc_hierarchy
argument_list|(
name|ne
operator|->
name|e_oc
argument_list|)
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"shadow: objectclass failure"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|dn
argument_list|)
expr_stmt|;
name|entry_free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|check_schema
argument_list|(
name|ne
argument_list|,
name|NULLATTR
argument_list|,
operator|&
name|err
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"shadow: schema failure"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|dn
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|entry_free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ne
operator|->
name|e_parent
operator|==
name|NULLENTRY
condition|)
block|{
name|entry_replace
argument_list|(
name|database_root
argument_list|,
name|ne
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry_replace
argument_list|(
name|eptr
argument_list|,
name|ne
argument_list|)
expr_stmt|;
block|}
name|entry_free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
name|ne
operator|=
name|eptr
expr_stmt|;
if|if
condition|(
name|unravel_attribute
argument_list|(
name|eptr
argument_list|,
operator|&
name|err
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|log_ds_error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|avl_apply
argument_list|(
name|eptr
operator|->
name|e_children
argument_list|,
name|inherit_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|eptr
argument_list|,
name|NOTOK
argument_list|,
name|AVL_PREORDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|->
name|e_parent
operator|->
name|e_edbversion
condition|)
name|free
argument_list|(
name|eptr
operator|->
name|e_parent
operator|->
name|e_edbversion
argument_list|)
expr_stmt|;
name|eptr
operator|->
name|e_parent
operator|->
name|e_edbversion
operator|=
name|new_version
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_INDEX
comment|/* add the new modified entry to the index */
name|turbo_add2index
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|unravel_attribute
argument_list|(
name|ne
argument_list|,
operator|&
name|err
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|log_ds_error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|entry_free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|check_oc_hierarchy
argument_list|(
name|ne
operator|->
name|e_oc
argument_list|)
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"shadow: objectclass failure"
operator|)
argument_list|)
expr_stmt|;
name|entry_free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|check_schema
argument_list|(
name|ne
argument_list|,
name|NULLATTR
argument_list|,
operator|&
name|err
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|log_ds_error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
name|entry_free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* slot into tree */
if|if
condition|(
name|ne
operator|->
name|e_parent
operator|==
name|NULLENTRY
condition|)
block|{
name|database_root
operator|=
name|ne
expr_stmt|;
name|entry_free
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|entry_free
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
comment|/* now alter all parent pointers */
name|ne
operator|->
name|e_parent
operator|->
name|e_child
operator|=
name|ne
expr_stmt|;
for|for
control|(
name|eptr
operator|=
name|ne
operator|->
name|e_child
init|;
name|eptr
operator|!=
name|NULLENTRY
condition|;
name|eptr
operator|=
name|eptr
operator|->
name|e_sibling
control|)
block|{
name|eptr
operator|->
name|e_parent
operator|=
name|ne
expr_stmt|;
name|set_inheritance
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TURBO_DISK
if|if
condition|(
name|turbo_write
argument_list|(
name|ne
argument_list|)
operator|!=
name|OK
condition|)
name|fatal
argument_list|(
operator|-
literal|33
argument_list|,
literal|"shadow rewrite failed - check database"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|journal
argument_list|(
name|ne
argument_list|)
operator|!=
name|OK
condition|)
name|fatal
argument_list|(
operator|-
literal|33
argument_list|,
literal|"shadow rewrite failed - check database"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_STATS
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_TRACE
argument_list|,
literal|"Shadow update"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_rd
operator|.
name|rdr_entry
operator|.
name|ent_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ne
operator|->
name|e_age
operator|=
name|timenow
expr_stmt|;
block|}
end_block

end_unit

