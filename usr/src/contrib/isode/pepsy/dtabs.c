begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dtabs.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepsy/RCS/dtabs.c,v 7.10 91/02/22 09:48:47 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/pepsy/RCS/dtabs.c,v 7.10 91/02/22 09:48:47 mrose Interim $  *  *  * $Log:	dtabs.c,v $  * Revision 7.10  91/02/22  09:48:47  mrose  * Interim 6.8  *   * Revision 7.9  91/01/08  12:49:21  mrose  * update  *   * Revision 7.8  90/12/23  17:24:26  mrose  * patches  *   * Revision 7.7  90/12/11  10:33:19  mrose  * sync  *   * Revision 7.5  90/11/11  09:58:51  mrose  * touch-up  *   * Revision 7.4  90/11/04  19:18:21  mrose  * update  *   * Revision 7.3  90/08/18  00:44:15  mrose  * touch-up  *   * Revision 7.2  90/07/27  08:49:09  mrose  * update  *   * Revision 7.1  90/07/09  14:52:25  mrose  * sync  *   * Revision 7.0  90/07/01  19:54:15  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pepsydefs.h"
end_include

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_include
include|#
directive|include
file|"mine.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|c_tag
argument_list|()
decl_stmt|,
modifier|*
name|c_class
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ec_tag
argument_list|()
decl_stmt|,
modifier|*
name|ec_class
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strip_last
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|str_yp_code
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|get_val
argument_list|()
decl_stmt|,
modifier|*
name|get_comp
argument_list|()
decl_stmt|,
modifier|*
name|strp2name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_table
modifier|*
name|lookup_list
argument_list|()
decl_stmt|,
modifier|*
name|get_offset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|YP
name|tdec_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|my_strcat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rm_indirect
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getfield
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|setfield
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|gen_sentry
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* extern int explicit; */
end_comment

begin_define
define|#
directive|define
name|WORDSIZE
value|20
end_define

begin_comment
comment|/*  * table encode a type. generate tables for the encoding of a type  */
end_comment

begin_macro
name|tdec_typ
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|id
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s_table
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|;
name|YP
name|y
decl_stmt|;
name|YAL
name|yal
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|<
literal|0
operator|||
name|yp
operator|->
name|yp_code
operator|>
name|YP_REAL
condition|)
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ: unimplemented type %d\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULL
condition|)
block|{
name|ferr
argument_list|(
literal|0
argument_list|,
literal|"tdec_typ:NULL arguement\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
condition|)
name|t
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:SETLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_bef_alist
condition|)
block|{
name|yal
operator|->
name|yal_type
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|yal
operator|->
name|yal_dec
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_bef_alist
operator|->
name|yal_dec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_aft_alist
condition|)
block|{
name|yal
operator|->
name|yal_type
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_control_act
condition|)
name|yal
operator|->
name|yal_type
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_optional_act
condition|)
name|yal
operator|->
name|yal_type
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULLCP
condition|)
block|{
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
comment|/* 	     * These generate MEMALLOC entries inside *_START .. 	     * PE_END fields for historical reasons. One day we might 	     * fix this to be all done the same way. 	     */
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_CHOICE
case|:
break|break;
default|default:
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|==
name|NULL
condition|)
break|break;
comment|/* S* type entry - doesn't need a 				 * malloc */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ MEMALLOC, 0, sizeof (%s), 0 },\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
operator|)
operator|&&
name|yp
operator|->
name|yp_parm
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_parm
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_parm
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|strdup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|yp
operator|->
name|yp_varexp
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|==
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator|)
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
name|char
modifier|*
name|bitno
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_optional_act
operator|&&
name|yp
operator|->
name|yp_optional_act
operator|->
name|yal_dec
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ BOPTIONAL, %d, 0, FL_USELECT},\n"
argument_list|,
name|control_act
argument_list|(
name|yp
operator|->
name|yp_optional_act
operator|->
name|yal_dec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|f1
operator|=
name|getfldbit
argument_list|(
name|yp
operator|->
name|yp_optcontrol
argument_list|,
operator|&
name|bitno
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:BOPTIONAL: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ BOPTIONAL, AOFFSET(%s, %s), %s, 0},\n"
argument_list|,
name|t
argument_list|,
name|f1
argument_list|,
name|bitno
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ ETAG, 0, "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s, %s },\n"
argument_list|,
name|ec_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|ec_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_yfn
operator|&&
name|yp
operator|->
name|yp_yfn
operator|->
name|yfn_dec
condition|)
block|{
name|gen_fn
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|yp
operator|->
name|yp_yfn
operator|->
name|yfn_dec
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen_freefn
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|)
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_aft_alist
operator|&&
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_dec
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_dec
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_UNDF
case|:
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:Undefined type\n"
argument_list|)
expr_stmt|;
case|case
name|YP_BOOL
case|:
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:BOOL: must specify a field for boolean\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BOOLEAN"
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_intexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
break|break;
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:BOOL: couldn't determine type\n"
argument_list|)
expr_stmt|;
comment|/* This needs to be fixed up in the action generating area */
case|case
name|YP_INTLIST
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:INT: must specify a field for an integer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_intexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"INTEGER"
expr_stmt|;
break|break;
block|}
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:INT: couldn't determine type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_REAL
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:REAL: must specify a field for a REAL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"REALTYPE"
expr_stmt|;
break|break;
block|}
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:REAL: couldn't determine type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:BIT: must specify a [[ x ... ]] value\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_PTR"
expr_stmt|;
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:BIT: must specify a [[ x ... ]] value\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_LEN"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_strexp
operator|==
name|NULLCP
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_intexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"BITSTRING"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SBITSTRING, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
block|{
switch|switch
condition|(
name|yp
operator|->
name|yp_prfexp
condition|)
block|{
case|case
literal|'q'
case|:
comment|/* [[ q parm->qbufptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"SOCTETSTRING"
expr_stmt|;
else|else
name|p1
operator|=
literal|"OCTETSTRING"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* [[ s ptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:OCTET: must specify a field [[ s .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"T_STRING"
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* [[ o ptr $ length ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:OCTET: must specify a field [[ o .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_PTR"
expr_stmt|;
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:OCTET: must specify a field [[ o .. $ .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_LEN"
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ: Unknown Octet string specifier %c\n"
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|f
condition|)
block|{
name|p1
operator|=
literal|"OCTETSTRING"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SOCTETSTRING, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"OBJID"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SOBJID, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"ANY"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SANY, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
name|p1
operator|=
literal|"T_NULL"
expr_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
operator|)
operator|&&
name|yp
operator|->
name|yp_prfexp
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"\n[[ ? reference ]] [[ p reference ]] is illegal\n\t only one allowed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_prfexp
condition|)
block|{
comment|/* [[ ? parm->field ]] - complex to process */
name|gen_identry
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|gen_ventry
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
break|break;
block|}
block|{
comment|/* Predefined Universal Type */
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|,
modifier|*
name|univtyp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|univ_flags
operator|&
name|UNF_EXTMOD
condition|)
block|{
name|yp
operator|->
name|yp_module
operator|=
name|p
operator|->
name|univ_mod
expr_stmt|;
goto|goto
name|do_obj
goto|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* No offset type */
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
name|prstfield
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|int2tstr
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
argument_list|)
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prstfield
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|int2tstr
argument_list|(
name|p
operator|->
name|univ_id
argument_list|)
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|p
operator|->
name|univ_class
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
name|prtfield
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|int2tstr
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
argument_list|)
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|int2tstr
argument_list|(
name|p
operator|->
name|univ_id
argument_list|)
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|p
operator|->
name|univ_class
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|do_obj
label|:
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ IMP_OBJ, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prstfield
argument_list|(
name|fp
argument_list|,
literal|"OBJECT"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|concat
argument_list|(
literal|"_Z"
argument_list|,
name|proc_name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
literal|"OBJECT"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|concat
argument_list|(
literal|"_Z"
argument_list|,
name|proc_name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prstfield
argument_list|(
name|fp
argument_list|,
literal|"EXTOBJ"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|concat
argument_list|(
literal|"_Z"
argument_list|,
name|strp2name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
literal|"EXTOBJ"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|concat
argument_list|(
literal|"_Z"
argument_list|,
name|strp2name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ EXTMOD, %d, 0, 0 },\n"
argument_list|,
name|gen_modref
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQLIST
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|==
name|NULL
operator|&&
name|type
operator|!=
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:YP_SEQLIST:NULL varexp pointer\n"
argument_list|)
expr_stmt|;
name|prcte
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
literal|"SEQ_START"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:SEQLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:YP_SEQLIST:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|genmalloc
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|optfield
argument_list|(
name|y
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ OPTL, OFFSET(%s, optionals), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
name|tdec_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SETLIST
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
name|p1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|==
name|NULL
operator|&&
name|type
operator|!=
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:YP_SETLIST:NULL varexp pointer\n"
argument_list|)
expr_stmt|;
name|prcte
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
literal|"SET_START"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:SETLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:YP_SETLIST:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|genmalloc
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|optfield
argument_list|(
name|y
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ OPTL, OFFSET(%s, optionals), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
name|tdec_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
comment|/* What is the difference ?? */
name|p1
operator|=
name|NULL
expr_stmt|;
name|prcte
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
literal|"SEQOF_START"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:SEQTYPE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:YP_SEQTYPE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|genmalloc
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|tdec_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:SEQ OF: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, %s), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_structname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, next), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SETTYPE
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
name|prcte
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
literal|"SETOF_START"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:SETTYPE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:YP_SETTYPE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|genmalloc
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|tdec_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:SET OF: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, %s), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_structname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, next), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
if|if
condition|(
name|hflag
operator|&&
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|!
name|y
operator|->
name|yp_next
condition|)
block|{
name|tdec_typ
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|type
operator|&&
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prstfield
argument_list|(
name|fp
argument_list|,
literal|"CHOICE_START"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
literal|"CHOICE_START"
argument_list|,
name|t
argument_list|,
name|type
condition|?
name|f
else|:
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:CHOICE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:YP_CHOICE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|genmalloc
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_control_act
operator|&&
name|yp
operator|->
name|yp_control_act
operator|->
name|yal_dec
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, %d, 0, FL_USELECT },\n"
argument_list|,
name|control_act
argument_list|(
name|yp
operator|->
name|yp_control_act
operator|->
name|yal_dec
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:CHOICE: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, OFFSET(%s, %s), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_structname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, OFFSET(%s, offset), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
else|else
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"\nCHOICE missing SCTRL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntdec_typ:CHOICE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ:YP_CHOICE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
name|tdec_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"tdec_typ: yp_code = %d  not implemented\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
block|{
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_DEC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_aft_alist
operator|&&
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_dec
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_dec
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|fflags
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|7
block|,}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * generate tables for encoding a contructed type  */
end_comment

begin_function
name|YP
name|tdec_loop
parameter_list|(
name|fp
parameter_list|,
name|yp
parameter_list|,
name|id
parameter_list|,
name|type
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|YP
name|yp
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
for|for
control|(
init|;
name|yp
operator|!=
name|NULL
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
block|{
name|tdec_typ
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Generate a malloc of for the given object  */
end_comment

begin_macro
name|genmalloc
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|hasdatstr
argument_list|(
name|yp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ MEMALLOC, 0, sizeof (%s), 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Has Data Structure,  * determine if this type needs a data structure allocated to it - calls  * itself recursively to handle the cases of pulled up types  * returns non zero if it does need a type allocated for it  */
end_comment

begin_macro
name|hasdatstr
argument_list|(
argument|yp
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|YP
name|y
decl_stmt|;
name|YP
name|yp1
decl_stmt|;
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_OID
case|:
break|break;
case|case
name|YP_IDEFINED
case|:
name|yp1
operator|=
name|lkup
argument_list|(
name|yp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp1
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|univ_type
operator|<=
name|YP_UNDF
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* we can't tell unless we know what this is */
comment|/* ferr(0, "\tcomptag:treated as implicit\n"); */
block|}
if|if
condition|(
name|p
operator|->
name|univ_flags
operator|&
name|UNF_HASDATA
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
name|hasdatstr
argument_list|(
name|yp1
argument_list|)
operator|)
return|;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|hflag
operator|&&
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|!
name|y
operator|->
name|yp_next
condition|)
block|{
return|return
operator|(
name|hasdatstr
argument_list|(
name|y
argument_list|)
operator|)
return|;
block|}
comment|/* else fall */
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|control_act
parameter_list|(
name|act
parameter_list|)
name|Action
name|act
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|act
operator|->
name|a_data
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|==
literal|'0'
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|act
operator|->
name|a_num
return|;
block|}
end_function

begin_comment
comment|/*  * generate an entry for the freeing routines  * if there is a freeing function just call that  * if not specify the type and offset so the free routines know how to free it  * return non zero if we don't want the normal decoding entry to be  * generated after us for freeing purposes.  */
end_comment

begin_macro
name|gen_freefn
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_yfn
operator|&&
operator|(
name|fn
operator|=
name|yp
operator|->
name|yp_yfn
operator|->
name|yfn_fre
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ FFN_CALL, %d, 0, 0, },\n"
argument_list|,
name|addptr
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* don't free as per normal */
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ FREE_ONLY, 0, 0, 0, },\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

