begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XStrKeysym.c,v 11.15 91/06/07 18:20:55 rws Exp $ */
end_comment

begin_comment
comment|/* Copyright 1985, 1987, 1990 Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xresource.h>
end_include

begin_include
include|#
directive|include
file|<X11/keysymdef.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|X_NOT_STDC_ENV
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|XrmQuark
name|_XrmInternalStringToQuark
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_define
define|#
directive|define
name|Const
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Const
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|long
name|Signature
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NEEDKTABLE
end_define

begin_include
include|#
directive|include
file|"ks_tables.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KEYSYMDB
end_ifndef

begin_define
define|#
directive|define
name|KEYSYMDB
value|"/usr/lib/X11/XKeysymDB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Bool
name|initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XrmDatabase
name|keysymdb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XrmQuark
name|Qkeysym
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|XrmDatabase
name|_XInitKeysymDB
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|char
modifier|*
name|dbname
decl_stmt|;
name|XrmInitialize
argument_list|()
expr_stmt|;
comment|/* use and name of this env var is not part of the standard */
comment|/* implementation-dependent feature */
name|dbname
operator|=
name|getenv
argument_list|(
literal|"XKEYSYMDB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbname
condition|)
name|dbname
operator|=
name|KEYSYMDB
expr_stmt|;
name|keysymdb
operator|=
name|XrmGetFileDatabase
argument_list|(
name|dbname
argument_list|)
expr_stmt|;
if|if
condition|(
name|keysymdb
condition|)
name|Qkeysym
index|[
literal|0
index|]
operator|=
name|XrmStringToQuark
argument_list|(
literal|"Keysym"
argument_list|)
expr_stmt|;
name|initialized
operator|=
name|True
expr_stmt|;
block|}
return|return
name|keysymdb
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|KeySym
name|XStringToKeysym
parameter_list|(
name|s
parameter_list|)
name|_Xconst
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|KeySym XStringToKeysym
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|h
decl_stmt|;
specifier|register
name|Signature
name|sig
init|=
literal|0
decl_stmt|;
specifier|register
name|Const
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
name|Const
name|unsigned
name|char
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|char
name|sig1
decl_stmt|,
name|sig2
decl_stmt|;
name|KeySym
name|val
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
name|i
operator|=
name|sig
operator|%
name|KTABLESIZE
expr_stmt|;
name|h
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|sig1
operator|=
operator|(
name|sig
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sig2
operator|=
name|sig
operator|&
literal|0xff
expr_stmt|;
name|n
operator|=
name|KMAXHASH
expr_stmt|;
while|while
condition|(
name|idx
operator|=
name|hashString
index|[
name|i
index|]
condition|)
block|{
name|entry
operator|=
operator|&
name|_XkeyTable
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|entry
index|[
literal|0
index|]
operator|==
name|sig1
operator|)
operator|&&
operator|(
name|entry
index|[
literal|1
index|]
operator|==
name|sig2
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|entry
operator|+
literal|4
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
name|entry
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|entry
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|val
operator|=
name|XK_VoidSymbol
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
operator|!
operator|--
name|n
condition|)
break|break;
name|i
operator|+=
name|h
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|KTABLESIZE
condition|)
name|i
operator|-=
name|KTABLESIZE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|initialized
condition|)
operator|(
name|void
operator|)
name|_XInitKeysymDB
argument_list|()
expr_stmt|;
if|if
condition|(
name|keysymdb
condition|)
block|{
name|XrmValue
name|result
decl_stmt|;
name|XrmRepresentation
name|from_type
decl_stmt|;
name|char
name|c
decl_stmt|;
name|KeySym
name|val
decl_stmt|;
name|XrmQuark
name|names
index|[
literal|2
index|]
decl_stmt|;
name|names
index|[
literal|0
index|]
operator|=
name|_XrmInternalStringToQuark
argument_list|(
name|s
argument_list|,
name|p
operator|-
name|s
operator|-
literal|1
argument_list|,
name|sig
argument_list|,
name|False
argument_list|)
expr_stmt|;
name|names
index|[
literal|1
index|]
operator|=
name|NULLQUARK
expr_stmt|;
operator|(
name|void
operator|)
name|XrmQGetResource
argument_list|(
name|keysymdb
argument_list|,
name|names
argument_list|,
name|Qkeysym
argument_list|,
operator|&
name|from_type
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|addr
operator|&&
operator|(
name|result
operator|.
name|size
operator|>
literal|1
operator|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|result
operator|.
name|addr
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
name|NoSymbol
return|;
block|}
return|return
name|val
return|;
block|}
block|}
return|return
operator|(
name|NoSymbol
operator|)
return|;
block|}
end_function

end_unit

