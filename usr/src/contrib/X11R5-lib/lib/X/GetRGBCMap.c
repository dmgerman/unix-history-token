begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 1989 Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* $XConsortium: GetRGBCMap.c,v 1.5 91/01/08 14:39:37 gildea Exp $ */
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include

begin_include
include|#
directive|include
file|"Xatomtype.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xatom.h>
end_include

begin_function
name|Status
name|XGetRGBColormaps
parameter_list|(
name|dpy
parameter_list|,
name|w
parameter_list|,
name|stdcmap
parameter_list|,
name|count
parameter_list|,
name|property
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|Window
name|w
decl_stmt|;
name|XStandardColormap
modifier|*
modifier|*
name|stdcmap
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|count
decl_stmt|;
comment|/* RETURN */
name|Atom
name|property
decl_stmt|;
comment|/* XA_RGB_BEST_MAP, etc. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* iterator variable */
name|xPropStandardColormap
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
comment|/* data read in from prop */
name|Atom
name|actual_type
decl_stmt|;
comment|/* how the prop was actually stored */
name|int
name|actual_format
decl_stmt|;
comment|/* ditto */
name|unsigned
name|long
name|leftover
decl_stmt|;
comment|/* how much was left over */
name|unsigned
name|long
name|nitems
decl_stmt|;
comment|/* number of 32bits read */
name|int
name|ncmaps
decl_stmt|;
comment|/* number of structs this makes */
name|Bool
name|old_style
init|=
name|False
decl_stmt|;
comment|/* if was too short */
name|VisualID
name|def_visual
init|=
name|None
decl_stmt|;
comment|/* visual to use if prop too short */
name|XStandardColormap
modifier|*
name|cmaps
decl_stmt|;
comment|/* return value */
if|if
condition|(
name|XGetWindowProperty
argument_list|(
name|dpy
argument_list|,
name|w
argument_list|,
name|property
argument_list|,
literal|0L
argument_list|,
literal|1000000L
argument_list|,
name|False
argument_list|,
name|XA_RGB_COLOR_MAP
argument_list|,
operator|&
name|actual_type
argument_list|,
operator|&
name|actual_format
argument_list|,
operator|&
name|nitems
argument_list|,
operator|&
name|leftover
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|data
argument_list|)
operator|!=
name|Success
condition|)
return|return
name|False
return|;
comment|/* if wrong type or format, or too small for us, then punt */
if|if
condition|(
operator|(
name|actual_type
operator|!=
name|XA_RGB_COLOR_MAP
operator|)
operator|||
operator|(
name|actual_format
operator|!=
literal|32
operator|)
operator|||
operator|(
name|nitems
operator|<
name|OldNumPropStandardColormapElements
operator|)
condition|)
block|{
if|if
condition|(
name|data
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
comment|/*      * See how many properties were found; if pre-ICCCM then assume       * default visual and a kill id of 1.      */
if|if
condition|(
name|nitems
operator|<
name|NumPropStandardColormapElements
condition|)
block|{
name|ncmaps
operator|=
literal|1
expr_stmt|;
name|old_style
operator|=
name|True
expr_stmt|;
if|if
condition|(
name|nitems
operator|<
operator|(
name|NumPropStandardColormapElements
operator|-
literal|1
operator|)
condition|)
block|{
name|Screen
modifier|*
name|sp
init|=
name|_XScreenOfWindow
argument_list|(
name|dpy
argument_list|,
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
block|{
if|if
condition|(
name|data
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
name|def_visual
operator|=
name|sp
operator|->
name|root_visual
operator|->
name|visualid
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * make sure we have an integral number of colormaps  	 */
name|ncmaps
operator|=
operator|(
name|nitems
operator|/
name|NumPropStandardColormapElements
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ncmaps
operator|)
operator|*
name|NumPropStandardColormapElements
operator|)
operator|!=
name|nitems
condition|)
block|{
if|if
condition|(
name|data
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
block|}
comment|/*      * allocate array      */
name|cmaps
operator|=
operator|(
name|XStandardColormap
operator|*
operator|)
name|Xmalloc
argument_list|(
name|ncmaps
operator|*
sizeof|sizeof
argument_list|(
name|XStandardColormap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmaps
condition|)
block|{
if|if
condition|(
name|data
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
comment|/*      * and fill it in, handling compatibility with pre-ICCCM short stdcmaps      */
block|{
specifier|register
name|XStandardColormap
modifier|*
name|map
decl_stmt|;
specifier|register
name|xPropStandardColormap
modifier|*
name|prop
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ncmaps
operator|,
name|map
operator|=
name|cmaps
operator|,
name|prop
operator|=
name|data
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|map
operator|++
operator|,
name|prop
operator|++
control|)
block|{
name|map
operator|->
name|colormap
operator|=
name|prop
operator|->
name|colormap
expr_stmt|;
name|map
operator|->
name|red_max
operator|=
name|prop
operator|->
name|red_max
expr_stmt|;
name|map
operator|->
name|red_mult
operator|=
name|prop
operator|->
name|red_mult
expr_stmt|;
name|map
operator|->
name|green_max
operator|=
name|prop
operator|->
name|green_max
expr_stmt|;
name|map
operator|->
name|green_mult
operator|=
name|prop
operator|->
name|green_mult
expr_stmt|;
name|map
operator|->
name|blue_max
operator|=
name|prop
operator|->
name|blue_max
expr_stmt|;
name|map
operator|->
name|blue_mult
operator|=
name|prop
operator|->
name|blue_mult
expr_stmt|;
name|map
operator|->
name|base_pixel
operator|=
name|prop
operator|->
name|base_pixel
expr_stmt|;
name|map
operator|->
name|visualid
operator|=
operator|(
name|def_visual
condition|?
name|def_visual
else|:
name|prop
operator|->
name|visualid
operator|)
expr_stmt|;
name|map
operator|->
name|killid
operator|=
operator|(
name|old_style
condition|?
name|None
else|:
name|prop
operator|->
name|killid
operator|)
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
operator|*
name|stdcmap
operator|=
name|cmaps
expr_stmt|;
operator|*
name|count
operator|=
name|ncmaps
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

end_unit

