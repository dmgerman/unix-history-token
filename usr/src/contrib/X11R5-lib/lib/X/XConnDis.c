begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: XConnDis.c,v 11.88 91/12/17 17:55:57 rws Exp $  *  * Copyright 1989 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of M.I.T. not be used in advertising  * or publicity pertaining to distribution of the software without specific,  * written prior permission.  M.I.T. makes no representations about the  * suitability of this software for any purpose.  It is provided "as is"  * without express or implied warranty.  *  * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *   * This file contains operating system dependencies.  */
end_comment

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|"Xlibnet.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xauth.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_include
include|#
directive|include
file|<netdnet/dn.h>
end_include

begin_include
include|#
directive|include
file|<netdnet/dnetdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSCONN
end_ifdef

begin_define
define|#
directive|define
name|select
value|_XSelect
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|X_CONNECTION_RETRIES
end_ifndef

begin_comment
comment|/* number retries on ECONNREFUSED */
end_comment

begin_define
define|#
directive|define
name|X_CONNECTION_RETRIES
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_function_decl
specifier|static
name|int
name|MakeDECnetConnection
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNIXCONN
end_ifdef

begin_function_decl
specifier|static
name|int
name|MakeUNIXSocketConnection
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TCPCONN
end_ifdef

begin_function_decl
specifier|static
name|int
name|MakeTCPConnection
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSCONN
end_ifdef

begin_function_decl
specifier|extern
name|int
name|_XMakeStreamsConnection
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|GetAuthorization
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|copystring
parameter_list|(
name|src
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|dst
init|=
name|Xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dst
condition|)
block|{
name|strncpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dst
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*   * Attempts to connect to server, given display name. Returns file descriptor  * (network socket) or -1 if connection fails.  Display names may be of the  * following format:  *  *     [hostname] : [:] displaynumber [.screennumber]  *  * The second colon indicates a DECnet style name.  No hostname is interpretted  * as the most efficient local connection to a server on the same machine.    * This is usually:  *  *     o  shared memory  *     o  local stream  *     o  UNIX domain socket  *     o  TCP to local host  */
end_comment

begin_function
name|int
name|_XConnectDisplay
parameter_list|(
name|display_name
parameter_list|,
name|fullnamep
parameter_list|,
name|dpynump
parameter_list|,
name|screenp
parameter_list|,
name|auth_namep
parameter_list|,
name|auth_namelenp
parameter_list|,
name|auth_datap
parameter_list|,
name|auth_datalenp
parameter_list|)
name|char
modifier|*
name|display_name
decl_stmt|;
name|char
modifier|*
modifier|*
name|fullnamep
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|dpynump
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|screenp
decl_stmt|;
comment|/* RETURN */
name|char
modifier|*
modifier|*
name|auth_namep
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|auth_namelenp
decl_stmt|;
comment|/* RETURN */
name|char
modifier|*
modifier|*
name|auth_datap
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|auth_datalenp
decl_stmt|;
comment|/* RETURN */
block|{
name|int
name|family
decl_stmt|;
name|int
name|saddrlen
decl_stmt|;
name|char
modifier|*
name|saddr
decl_stmt|;
name|char
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* char pointers */
name|char
modifier|*
name|phostname
init|=
name|NULL
decl_stmt|;
comment|/* start of host of display */
name|char
modifier|*
name|pdpynum
init|=
name|NULL
decl_stmt|;
comment|/* start of dpynum of display */
name|char
modifier|*
name|pscrnum
init|=
name|NULL
decl_stmt|;
comment|/* start of screen of display */
name|Bool
name|dnet
init|=
name|False
decl_stmt|;
comment|/* if true, then DECnet format */
name|int
name|idisplay
decl_stmt|;
comment|/* required display number */
name|int
name|iscreen
init|=
literal|0
decl_stmt|;
comment|/* optional screen number */
name|int
function_decl|(
modifier|*
name|connfunc
function_decl|)
parameter_list|()
function_decl|;
comment|/* method to create connection */
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* file descriptor to return */
name|int
name|len
decl_stmt|;
comment|/* length tmp variable */
name|p
operator|=
name|display_name
expr_stmt|;
name|saddrlen
operator|=
literal|0
expr_stmt|;
comment|/* set so that we can clear later */
name|saddr
operator|=
name|NULL
expr_stmt|;
comment|/*      * Step 1, find the hostname.  This is delimited by the required       * first colon.      */
for|for
control|(
name|lastp
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
return|return
operator|-
literal|1
return|;
comment|/* must have a colon */
if|if
condition|(
name|p
operator|!=
name|lastp
condition|)
block|{
comment|/* no hostname given */
name|phostname
operator|=
name|copystring
argument_list|(
name|lastp
argument_list|,
name|p
operator|-
name|lastp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phostname
condition|)
goto|goto
name|bad
goto|;
comment|/* no memory */
block|}
comment|/*      * Step 2, see if this is a DECnet address by looking for the optional      * second colon.      */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* then DECnet format */
name|dnet
operator|=
name|True
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/*      * see if we're allowed to have a DECnet address      */
ifndef|#
directive|ifndef
name|DNETCONN
if|if
condition|(
name|dnet
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
comment|/*      * Step 3, find the display number.  This field is required and is       * delimited either by a nul or a period, depending on whether or not      * a screen number is present.      */
for|for
control|(
name|lastp
operator|=
operator|++
name|p
init|;
operator|*
name|p
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|p
operator|==
name|lastp
operator|)
operator|||
comment|/* required field */
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
operator|)
operator|||
comment|/* invalid non-digit terminator */
operator|!
operator|(
name|pdpynum
operator|=
name|copystring
argument_list|(
name|lastp
argument_list|,
name|p
operator|-
name|lastp
argument_list|)
operator|)
condition|)
comment|/* no memory */
goto|goto
name|bad
goto|;
name|idisplay
operator|=
name|atoi
argument_list|(
name|pdpynum
argument_list|)
expr_stmt|;
comment|/*      * Step 4, find the screen number.  This field is optional.  It is       * present only if the display number was followed by a period (which      * we've already verified is the only non-nul character).      */
if|if
condition|(
operator|*
name|p
condition|)
block|{
for|for
control|(
name|lastp
operator|=
operator|++
name|p
init|;
operator|*
name|p
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|||
comment|/* non-digits */
operator|!
operator|(
name|pscrnum
operator|=
name|copystring
argument_list|(
name|lastp
argument_list|,
name|p
operator|-
name|lastp
argument_list|)
operator|)
condition|)
comment|/* no memory */
goto|goto
name|bad
goto|;
name|iscreen
operator|=
name|atoi
argument_list|(
name|lastp
argument_list|)
expr_stmt|;
block|}
comment|/*      * At this point, we know the following information:      *      *     phostname                hostname string or NULL      *     idisplay                 display number      *     iscreen                  screen number      *     dnet                     DECnet boolean      *       * We can now decide which transport to use based on the ConnectionFlags      * build parameter the hostname string.  If phostname is NULL or equals      * the string "local", then choose the best transport.  If phostname      * is "unix", then choose BSD UNIX domain sockets (if configured).      *      * First, choose default transports:  DECnet else (TCP or STREAMS)      */
ifdef|#
directive|ifdef
name|DNETCONN
if|if
condition|(
name|dnet
condition|)
name|connfunc
operator|=
name|MakeDECnetConnection
expr_stmt|;
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCPCONN
name|connfunc
operator|=
name|MakeTCPConnection
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STREAMSCONN
name|connfunc
operator|=
name|_XMakeStreamsConnection
expr_stmt|;
else|#
directive|else
name|connfunc
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIXCONN
comment|/*      * Now that the defaults have been established, see if we have any       * special names that we have to override:      *      *     :N         =>     if UNIXCONN then unix-domain-socket      *     ::N        =>     if UNIXCONN then unix-domain-socket      *     unix:N     =>     if UNIXCONN then unix-domain-socket      *      * Note that if UNIXCONN isn't defined, then we can use the default      * transport connection function set above.      */
if|if
condition|(
operator|!
name|phostname
condition|)
block|{
ifdef|#
directive|ifdef
name|apollo
empty_stmt|;
comment|/* Unix domain sockets are *really* bad on apollos */
else|#
directive|else
name|connfunc
operator|=
name|MakeUNIXSocketConnection
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|phostname
argument_list|,
literal|"unix"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|connfunc
operator|=
name|MakeUNIXSocketConnection
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|connfunc
condition|)
goto|goto
name|bad
goto|;
ifdef|#
directive|ifdef
name|UNIXCONN
define|#
directive|define
name|LOCALCONNECTION
value|(!phostname || connfunc == MakeUNIXSocketConnection)
else|#
directive|else
define|#
directive|define
name|LOCALCONNECTION
value|(!phostname)
endif|#
directive|endif
if|if
condition|(
name|LOCALCONNECTION
condition|)
block|{
comment|/* 	 * Get the auth info for local hosts so that it doesn't have to be 	 * repeated everywhere; the particular values in these fields are 	 * not part of the protocol. 	 */
name|char
name|hostnamebuf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|len
init|=
name|_XGetHostname
argument_list|(
name|hostnamebuf
argument_list|,
sizeof|sizeof
name|hostnamebuf
argument_list|)
decl_stmt|;
name|family
operator|=
name|FamilyLocal
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|saddr
operator|=
name|Xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|saddr
condition|)
block|{
name|strcpy
argument_list|(
name|saddr
argument_list|,
name|hostnamebuf
argument_list|)
expr_stmt|;
name|saddrlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|saddrlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|LOCALCONNECTION
comment|/*      * Make the connection, also need to get the auth address info for      * non-local connections.  Do retries in case server host has hit its      * backlog (which, unfortunately, isn't distinguishable from there not      * being a server listening at all, which is why we have to not retry      * too many times).      */
if|if
condition|(
operator|(
name|fd
operator|=
call|(
modifier|*
name|connfunc
call|)
argument_list|(
name|phostname
argument_list|,
name|idisplay
argument_list|,
name|X_CONNECTION_RETRIES
argument_list|,
operator|&
name|family
argument_list|,
operator|&
name|saddrlen
argument_list|,
operator|&
name|saddr
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|fd
operator|>=
name|OPEN_MAX
condition|)
goto|goto
name|bad
goto|;
comment|/*      * Set close-on-exec so that programs that fork() doesn't get confused.      */
ifdef|#
directive|ifdef
name|FD_CLOEXEC
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Build the expanded display name:      *      *     [host] : [:] dpy . scr \0      */
name|len
operator|=
operator|(
operator|(
name|phostname
condition|?
name|strlen
argument_list|(
name|phostname
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|1
operator|+
operator|(
name|dnet
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|pdpynum
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|pscrnum
condition|?
name|strlen
argument_list|(
name|pscrnum
argument_list|)
else|:
literal|1
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|fullnamep
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|fullnamep
condition|)
goto|goto
name|bad
goto|;
name|sprintf
argument_list|(
operator|*
name|fullnamep
argument_list|,
literal|"%s%s%d.%d"
argument_list|,
operator|(
name|phostname
condition|?
name|phostname
else|:
literal|""
operator|)
argument_list|,
operator|(
name|dnet
condition|?
literal|"::"
else|:
literal|":"
operator|)
argument_list|,
name|idisplay
argument_list|,
name|iscreen
argument_list|)
expr_stmt|;
operator|*
name|dpynump
operator|=
name|idisplay
expr_stmt|;
operator|*
name|screenp
operator|=
name|iscreen
expr_stmt|;
if|if
condition|(
name|phostname
condition|)
name|Xfree
argument_list|(
name|phostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdpynum
condition|)
name|Xfree
argument_list|(
name|pdpynum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pscrnum
condition|)
name|Xfree
argument_list|(
name|pscrnum
argument_list|)
expr_stmt|;
name|GetAuthorization
argument_list|(
name|fd
argument_list|,
name|family
argument_list|,
name|saddr
argument_list|,
name|saddrlen
argument_list|,
name|idisplay
argument_list|,
name|auth_namep
argument_list|,
name|auth_namelenp
argument_list|,
name|auth_datap
argument_list|,
name|auth_datalenp
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
comment|/*      * error return; make sure everything is cleaned up.      */
name|bad
label|:
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|saddr
condition|)
name|Xfree
argument_list|(
name|saddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|phostname
condition|)
name|Xfree
argument_list|(
name|phostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdpynum
condition|)
name|Xfree
argument_list|(
name|pdpynum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pscrnum
condition|)
name|Xfree
argument_list|(
name|pscrnum
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *                                                                           *  *			   Make Connection Routines                          *  *                                                                           *  *****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_comment
comment|/* stupid makedepend */
end_comment

begin_define
define|#
directive|define
name|NEED_BSDISH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNIXCONN
end_ifdef

begin_define
define|#
directive|define
name|NEED_BSDISH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TCPCONN
end_ifdef

begin_define
define|#
directive|define
name|NEED_BSDISH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_BSDISH
end_ifdef

begin_comment
comment|/* makedepend can't handle #if */
end_comment

begin_comment
comment|/*  * 4.2bsd-based systems  */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_define
define|#
directive|define
name|NO_TCP_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MOTOROLA
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|NO_TCP_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TCP_H
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__OSF1__
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_BSDISH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_function
specifier|static
name|int
name|MakeDECnetConnection
parameter_list|(
name|phostname
parameter_list|,
name|idisplay
parameter_list|,
name|retries
parameter_list|,
name|familyp
parameter_list|,
name|saddrlenp
parameter_list|,
name|saddrp
parameter_list|)
name|char
modifier|*
name|phostname
decl_stmt|;
name|int
name|idisplay
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
modifier|*
name|familyp
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|saddrlenp
decl_stmt|;
comment|/* RETURN */
name|char
modifier|*
modifier|*
name|saddrp
decl_stmt|;
comment|/* RETURN */
block|{
name|int
name|fd
decl_stmt|;
name|char
name|objname
index|[
literal|20
index|]
decl_stmt|;
specifier|extern
name|int
name|dnet_conn
parameter_list|()
function_decl|;
name|struct
name|dn_naddr
modifier|*
name|dnaddrp
decl_stmt|,
name|dnaddr
decl_stmt|;
name|struct
name|nodeent
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|!
name|phostname
condition|)
name|phostname
operator|=
literal|"0"
expr_stmt|;
comment|/*      * build the target object name.      */
name|sprintf
argument_list|(
name|objname
argument_list|,
literal|"X$X%d"
argument_list|,
name|idisplay
argument_list|)
expr_stmt|;
comment|/*      * Attempt to open the DECnet connection, return -1 if fails; ought to      * do some retries here....      */
if|if
condition|(
operator|(
name|fd
operator|=
name|dnet_conn
argument_list|(
name|phostname
argument_list|,
name|objname
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|familyp
operator|=
name|FamilyDECnet
expr_stmt|;
if|if
condition|(
name|dnaddrp
operator|=
name|dnet_addr
argument_list|(
name|phostname
argument_list|)
condition|)
block|{
comment|/* stolen from xhost */
name|dnaddr
operator|=
operator|*
name|dnaddrp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|np
operator|=
name|getnodebyname
argument_list|(
name|phostname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dnaddr
operator|.
name|a_len
operator|=
name|np
operator|->
name|n_length
expr_stmt|;
name|bcopy
argument_list|(
name|np
operator|->
name|n_addr
argument_list|,
name|dnaddr
operator|.
name|a_addr
argument_list|,
name|np
operator|->
name|n_length
argument_list|)
expr_stmt|;
block|}
operator|*
name|saddrlenp
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_naddr
argument_list|)
expr_stmt|;
operator|*
name|saddrp
operator|=
name|Xmalloc
argument_list|(
operator|*
name|saddrlenp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|saddrp
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dnaddr
argument_list|,
operator|*
name|saddrp
argument_list|,
operator|*
name|saddrlenp
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DNETCONN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIXCONN
end_ifdef

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|MakeUNIXSocketConnection
parameter_list|(
name|phostname
parameter_list|,
name|idisplay
parameter_list|,
name|retries
parameter_list|,
name|familyp
parameter_list|,
name|saddrlenp
parameter_list|,
name|saddrp
parameter_list|)
name|char
modifier|*
name|phostname
decl_stmt|;
name|int
name|idisplay
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
modifier|*
name|familyp
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|saddrlenp
decl_stmt|;
comment|/* RETURN */
name|char
modifier|*
modifier|*
name|saddrp
decl_stmt|;
comment|/* RETURN */
block|{
name|struct
name|sockaddr_un
name|unaddr
decl_stmt|;
comment|/* UNIX socket data block */
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
comment|/* generic socket pointer */
name|int
name|addrlen
decl_stmt|;
comment|/* length of addr */
name|int
name|fd
decl_stmt|;
comment|/* socket file descriptor */
ifdef|#
directive|ifdef
name|hpux
comment|/* this is disgusting */
name|struct
name|sockaddr_un
name|ounaddr
decl_stmt|;
comment|/* UNIX socket data block */
name|struct
name|sockaddr
modifier|*
name|oaddr
decl_stmt|;
comment|/* generic socket pointer */
name|int
name|oaddrlen
decl_stmt|;
comment|/* length of addr */
endif|#
directive|endif
name|unaddr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|sprintf
argument_list|(
name|unaddr
operator|.
name|sun_path
argument_list|,
literal|"%s%d"
argument_list|,
name|X_UNIX_PATH
argument_list|,
name|idisplay
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|unaddr
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_LEN
name|addrlen
operator|=
name|SUN_LEN
argument_list|(
operator|&
name|unaddr
argument_list|)
expr_stmt|;
else|#
directive|else
name|addrlen
operator|=
name|strlen
argument_list|(
name|unaddr
operator|.
name|sun_path
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|unaddr
operator|.
name|sun_family
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hpux
comment|/* this is disgusting */
name|ounaddr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|sprintf
argument_list|(
name|ounaddr
operator|.
name|sun_path
argument_list|,
literal|"%s%d"
argument_list|,
name|OLD_UNIX_PATH
argument_list|,
name|idisplay
argument_list|)
expr_stmt|;
name|oaddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ounaddr
expr_stmt|;
name|oaddrlen
operator|=
name|strlen
argument_list|(
name|ounaddr
operator|.
name|sun_path
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ounaddr
operator|.
name|sun_family
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Open the network connection.      */
do|do
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
operator|(
name|int
operator|)
name|addr
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|olderrno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|hpux
comment|/* this is disgusting */
if|if
condition|(
name|olderrno
operator|==
name|ENOENT
condition|)
block|{
name|fd
operator|=
name|socket
argument_list|(
operator|(
name|int
operator|)
name|oaddr
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
name|oaddr
argument_list|,
name|oaddrlen
argument_list|)
operator|>=
literal|0
condition|)
break|break;
name|olderrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|olderrno
operator|!=
name|ENOENT
operator|||
name|retries
operator|<=
literal|0
condition|)
block|{
name|errno
operator|=
name|olderrno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
do|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
do|;
comment|/*      * Don't need to get auth info since we're local      */
return|return
name|fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIXCONN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCPCONN
end_ifdef

begin_function
specifier|static
name|int
name|MakeTCPConnection
parameter_list|(
name|phostname
parameter_list|,
name|idisplay
parameter_list|,
name|retries
parameter_list|,
name|familyp
parameter_list|,
name|saddrlenp
parameter_list|,
name|saddrp
parameter_list|)
name|char
modifier|*
name|phostname
decl_stmt|;
name|int
name|idisplay
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
modifier|*
name|familyp
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|saddrlenp
decl_stmt|;
comment|/* RETURN */
name|char
modifier|*
modifier|*
name|saddrp
decl_stmt|;
comment|/* RETURN */
block|{
name|char
name|hostnamebuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* tmp space */
name|unsigned
name|long
name|hostinetaddr
decl_stmt|;
comment|/* result of inet_addr of arpa addr */
name|struct
name|sockaddr_in
name|inaddr
decl_stmt|;
comment|/* IP socket */
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
comment|/* generic socket pointer */
name|int
name|addrlen
decl_stmt|;
comment|/* length of addr */
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
comment|/* entry in hosts table */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* character pointer iterator */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor to return */
name|int
name|len
decl_stmt|;
comment|/* length tmp variable */
define|#
directive|define
name|INVALID_INETADDR
value|((unsigned long) -1)
if|if
condition|(
operator|!
name|phostname
condition|)
block|{
name|hostnamebuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|_XGetHostname
argument_list|(
name|hostnamebuf
argument_list|,
sizeof|sizeof
name|hostnamebuf
argument_list|)
expr_stmt|;
name|phostname
operator|=
name|hostnamebuf
expr_stmt|;
block|}
comment|/*      * if numeric host name then try to parse it as such; do the number      * first because some systems return garbage instead of INVALID_INETADDR      */
if|if
condition|(
name|isascii
argument_list|(
name|phostname
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|phostname
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|hostinetaddr
operator|=
name|inet_addr
argument_list|(
name|phostname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hostinetaddr
operator|=
name|INVALID_INETADDR
expr_stmt|;
block|}
comment|/*      * try numeric      */
if|if
condition|(
name|hostinetaddr
operator|==
name|INVALID_INETADDR
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|phostname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* No such host! */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
comment|/* is IP host? */
comment|/* Not an Internet host! */
return|return
operator|-
literal|1
return|;
block|}
comment|/* Set up the socket data. */
name|inaddr
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|OLDTCP
argument_list|)
comment|/* Only Cray UNICOS3 and UNICOS4 will define this */
block|{
name|long
name|t
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|inaddr
operator|.
name|sin_addr
operator|=
name|t
expr_stmt|;
block|}
else|#
directive|else
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CRAY and OLDTCP */
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|CRAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|OLDTCP
argument_list|)
comment|/* Only Cray UNICOS3 and UNICOS4 will define this */
name|inaddr
operator|.
name|sin_addr
operator|=
name|hostinetaddr
expr_stmt|;
else|#
directive|else
name|inaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|hostinetaddr
expr_stmt|;
endif|#
directive|endif
comment|/* CRAY and OLDTCP */
name|inaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
block|}
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|inaddr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|inaddr
operator|.
name|sin_port
operator|=
name|X_TCP_PORT
operator|+
name|idisplay
expr_stmt|;
name|inaddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|inaddr
operator|.
name|sin_port
argument_list|)
expr_stmt|;
comment|/* may be funky macro */
comment|/*      * Open the network connection.      */
do|do
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
operator|(
name|int
operator|)
name|addr
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * turn off TCP coalescence 	 */
ifdef|#
directive|ifdef
name|TCP_NODELAY
block|{
name|int
name|tmp
init|=
literal|1
decl_stmt|;
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * connect to the socket; if there is no X server or if the backlog has 	 * been reached, then ECONNREFUSED will be returned. 	 */
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|olderrno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|olderrno
operator|!=
name|ECONNREFUSED
operator|||
name|retries
operator|<=
literal|0
condition|)
block|{
name|errno
operator|=
name|olderrno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
do|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
do|;
comment|/*      * Success!  So, save the auth information      */
ifdef|#
directive|ifdef
name|CRAY
ifdef|#
directive|ifdef
name|OLDTCP
name|len
operator|=
sizeof|sizeof
argument_list|(
name|inaddr
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|SIZEOF_in_addr
expr_stmt|;
endif|#
directive|endif
comment|/* OLDTCP */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
operator|.
name|sin_addr
expr_stmt|;
else|#
directive|else
comment|/* else not CRAY */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|inaddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
endif|#
directive|endif
comment|/* CRAY */
comment|/*      * We are special casing the BSD hack localhost address      * 127.0.0.1, since this address shouldn't be copied to      * other machines.  So, we simply omit generating the auth info      * since we set it to the local machine before calling this routine!      */
if|if
condition|(
operator|!
operator|(
operator|(
name|len
operator|==
literal|4
operator|)
operator|&&
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|127
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cp
index|[
literal|2
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cp
index|[
literal|3
index|]
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
operator|*
name|saddrp
operator|=
name|Xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|saddrp
condition|)
block|{
operator|*
name|saddrlenp
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|*
name|saddrp
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|familyp
operator|=
name|FamilyInternet
expr_stmt|;
block|}
else|else
block|{
operator|*
name|saddrlenp
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|fd
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|INVALID_INETADDR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCPCONN */
end_comment

begin_comment
comment|/*****************************************************************************  *                                                                           *  *			  Connection Utility Routines                        *  *                                                                           *  *****************************************************************************/
end_comment

begin_comment
comment|/*   * Disconnect from server.  */
end_comment

begin_function
name|int
name|_XDisconnectDisplay
parameter_list|(
name|server
parameter_list|)
name|int
name|server
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|server
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is an OS dependent routine which:  * 1) returns as soon as the connection can be written on....  * 2) if the connection can be read, must enqueue events and handle errors,  * until the connection is writable.  */
end_comment

begin_macro
name|_XWaitForWritable
argument_list|(
argument|dpy
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|long
name|r_mask
index|[
name|MSKCNT
index|]
decl_stmt|;
name|unsigned
name|long
name|w_mask
index|[
name|MSKCNT
index|]
decl_stmt|;
name|int
name|nfound
decl_stmt|;
name|CLEARBITS
argument_list|(
name|r_mask
argument_list|)
expr_stmt|;
name|CLEARBITS
argument_list|(
name|w_mask
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BITSET
argument_list|(
name|r_mask
argument_list|,
name|dpy
operator|->
name|fd
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|w_mask
argument_list|,
name|dpy
operator|->
name|fd
argument_list|)
expr_stmt|;
do|do
block|{
name|nfound
operator|=
name|select
argument_list|(
name|dpy
operator|->
name|fd
operator|+
literal|1
argument_list|,
name|r_mask
argument_list|,
name|w_mask
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfound
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nfound
operator|<=
literal|0
condition|)
do|;
if|if
condition|(
name|_XANYSET
argument_list|(
name|r_mask
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|long
name|pend_not_register
decl_stmt|;
specifier|register
name|long
name|pend
decl_stmt|;
specifier|register
name|xEvent
modifier|*
name|ev
decl_stmt|;
comment|/* find out how much data can be read */
if|if
condition|(
name|BytesReadable
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pend_not_register
argument_list|)
operator|<
literal|0
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|pend
operator|=
name|pend_not_register
expr_stmt|;
comment|/* must read at least one xEvent; if none is pending, then 	       we'll just block waiting for it */
if|if
condition|(
name|pend
operator|<
name|SIZEOF
argument_list|(
name|xEvent
argument_list|)
condition|)
name|pend
operator|=
name|SIZEOF
argument_list|(
name|xEvent
argument_list|)
expr_stmt|;
comment|/* but we won't read more than the max buffer size */
if|if
condition|(
name|pend
operator|>
name|BUFSIZE
condition|)
name|pend
operator|=
name|BUFSIZE
expr_stmt|;
comment|/* round down to an integral number of XReps */
name|pend
operator|=
operator|(
name|pend
operator|/
name|SIZEOF
argument_list|(
name|xEvent
argument_list|)
operator|)
operator|*
name|SIZEOF
argument_list|(
name|xEvent
argument_list|)
expr_stmt|;
name|_XRead
argument_list|(
name|dpy
argument_list|,
name|buf
argument_list|,
name|pend
argument_list|)
expr_stmt|;
comment|/* no space between comma and type or else macro will die */
name|STARTITERATE
argument_list|(
argument|ev
argument_list|,
argument|xEvent
argument_list|,
argument|buf
argument_list|,
argument|(pend>
literal|0
argument|)
argument_list|,
argument|(pend -= SIZEOF(xEvent))
argument_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|==
name|X_Error
condition|)
name|_XError
argument_list|(
name|dpy
argument_list|,
operator|(
name|xError
operator|*
operator|)
name|ev
argument_list|)
expr_stmt|;
else|else
comment|/* it's an event packet; enqueue it */
name|_XEnq
argument_list|(
name|dpy
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
name|ENDITERATE
block|}
if|if
condition|(
name|_XANYSET
argument_list|(
name|w_mask
argument_list|)
condition|)
return|return;
block|}
block|}
end_block

begin_macro
name|_XWaitForReadable
argument_list|(
argument|dpy
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|long
name|r_mask
index|[
name|MSKCNT
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
name|CLEARBITS
argument_list|(
name|r_mask
argument_list|)
expr_stmt|;
do|do
block|{
name|BITSET
argument_list|(
name|r_mask
argument_list|,
name|dpy
operator|->
name|fd
argument_list|)
expr_stmt|;
name|result
operator|=
name|select
argument_list|(
name|dpy
operator|->
name|fd
operator|+
literal|1
argument_list|,
name|r_mask
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|<=
literal|0
condition|)
do|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|padlength
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make sure auth is multiple of 4 */
end_comment

begin_function
name|Bool
name|_XSendClientPrefix
parameter_list|(
name|dpy
parameter_list|,
name|client
parameter_list|,
name|auth_proto
parameter_list|,
name|auth_string
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|xConnClientPrefix
modifier|*
name|client
decl_stmt|;
comment|/* contains count for auth_* */
name|char
modifier|*
name|auth_proto
decl_stmt|,
decl|*
name|auth_string
decl_stmt|;
end_function

begin_comment
comment|/* NOT null-terminated */
end_comment

begin_block
block|{
name|int
name|auth_length
init|=
name|client
operator|->
name|nbytesAuthProto
decl_stmt|;
name|int
name|auth_strlen
init|=
name|client
operator|->
name|nbytesAuthString
decl_stmt|;
name|char
name|padbuf
index|[
literal|3
index|]
decl_stmt|;
comment|/* for padding to 4x bytes */
name|int
name|pad
decl_stmt|;
name|struct
name|iovec
name|iovarray
index|[
literal|5
index|]
decl_stmt|,
modifier|*
name|iov
init|=
name|iovarray
decl_stmt|;
name|int
name|niov
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|add_to_iov
parameter_list|(
name|b
parameter_list|,
name|l
parameter_list|)
define|\
value|{ iov->iov_base = (b); iov->iov_len = (l); iov++, niov++; len += (l); }
name|add_to_iov
argument_list|(
operator|(
name|caddr_t
operator|)
name|client
argument_list|,
name|SIZEOF
argument_list|(
name|xConnClientPrefix
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * write authorization protocol name and data      */
if|if
condition|(
name|auth_length
operator|>
literal|0
condition|)
block|{
name|add_to_iov
argument_list|(
name|auth_proto
argument_list|,
name|auth_length
argument_list|)
expr_stmt|;
name|pad
operator|=
name|padlength
index|[
name|auth_length
operator|&
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|pad
condition|)
name|add_to_iov
argument_list|(
name|padbuf
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth_strlen
operator|>
literal|0
condition|)
block|{
name|add_to_iov
argument_list|(
name|auth_string
argument_list|,
name|auth_strlen
argument_list|)
expr_stmt|;
name|pad
operator|=
name|padlength
index|[
name|auth_strlen
operator|&
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|pad
condition|)
name|add_to_iov
argument_list|(
name|padbuf
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|add_to_iov
name|len
operator|-=
name|WritevToServer
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|iovarray
argument_list|,
name|niov
argument_list|)
expr_stmt|;
comment|/*      * Set the connection non-blocking since we use select() to block.      */
comment|/* ultrix reads hang on Unix sockets, hpux reads fail */
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|ultrix
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AIXV3
argument_list|)
operator|)
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|FIOSNBIO
block|{
name|int
name|arg
init|=
literal|1
decl_stmt|;
name|ioctl
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|AIXV3
argument_list|)
operator|&&
name|defined
argument_list|(
name|FIONBIO
argument_list|)
block|{
name|int
name|arg
decl_stmt|;
name|arg
operator|=
literal|1
expr_stmt|;
name|ioctl
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
return|return
name|len
operator|==
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSCONN
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_include
include|#
directive|include
file|<tiuser.h>
end_include

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|HASXDMAUTH
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SECURE_RPC
end_ifdef

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ultrix
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<rpc/auth_des.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * First, a routine for setting authorization data  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xauth_namelen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xauth_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NULL means use default mechanism */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xauth_datalen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xauth_data
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NULL means get default data */
end_comment

begin_comment
comment|/*  * This is a list of the authorization names which Xlib currently supports.  * Xau will choose the file entry which matches the earliest entry in this  * array, allowing us to prioritize these in terms of the most secure first  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_xauth_names
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SECURE_RPC
literal|"SUN-DES-1"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HASXDMAUTH
literal|"XDM-AUTHORIZATION-1"
block|,
endif|#
directive|endif
literal|"MIT-MAGIC-COOKIE-1"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_xauth_lengths
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SECURE_RPC
literal|9
block|,
comment|/* strlen ("SUN-DES-1") */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HASXDMAUTH
literal|19
block|,
comment|/* strlen ("XDM-AUTHORIZATION-1") */
endif|#
directive|endif
literal|18
comment|/* strlen ("MIT-MAGIC-COOKIE-1") */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_DEFAULT_AUTH
value|(sizeof (default_xauth_names) / sizeof (default_xauth_names[0]))
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|xauth_names
init|=
name|default_xauth_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|xauth_lengths
init|=
name|default_xauth_lengths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xauth_names_length
init|=
name|NUM_DEFAULT_AUTH
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|XSetAuthorization
parameter_list|(
name|name
parameter_list|,
name|namelen
parameter_list|,
name|data
parameter_list|,
name|datalen
parameter_list|)
name|int
name|namelen
decl_stmt|,
name|datalen
decl_stmt|;
comment|/* lengths of name and data */
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|data
decl_stmt|;
end_function

begin_comment
comment|/* NULL or arbitrary array of bytes */
end_comment

begin_block
block|{
name|char
modifier|*
name|tmpname
decl_stmt|,
modifier|*
name|tmpdata
decl_stmt|;
if|if
condition|(
name|xauth_name
condition|)
name|Xfree
argument_list|(
name|xauth_name
argument_list|)
expr_stmt|;
comment|/* free any existing data */
if|if
condition|(
name|xauth_data
condition|)
name|Xfree
argument_list|(
name|xauth_data
argument_list|)
expr_stmt|;
name|xauth_name
operator|=
name|xauth_data
operator|=
name|NULL
expr_stmt|;
comment|/* mark it no longer valid */
name|xauth_namelen
operator|=
name|xauth_datalen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|<
literal|0
condition|)
name|namelen
operator|=
literal|0
expr_stmt|;
comment|/* check for bogus inputs */
if|if
condition|(
name|datalen
operator|<
literal|0
condition|)
name|datalen
operator|=
literal|0
expr_stmt|;
comment|/* maybe should return? */
if|if
condition|(
name|namelen
operator|>
literal|0
condition|)
block|{
comment|/* try to allocate space */
name|tmpname
operator|=
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpname
condition|)
return|return;
name|bcopy
argument_list|(
name|name
argument_list|,
name|tmpname
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
block|{
name|tmpdata
operator|=
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpdata
condition|)
block|{
if|if
condition|(
name|tmpname
condition|)
operator|(
name|void
operator|)
name|Xfree
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|data
argument_list|,
name|tmpdata
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpdata
operator|=
name|NULL
expr_stmt|;
block|}
name|xauth_name
operator|=
name|tmpname
expr_stmt|;
comment|/* and store the suckers */
name|xauth_namelen
operator|=
name|namelen
expr_stmt|;
if|if
condition|(
name|tmpname
condition|)
block|{
name|xauth_names
operator|=
operator|&
name|xauth_name
expr_stmt|;
name|xauth_lengths
operator|=
operator|&
name|xauth_namelen
expr_stmt|;
name|xauth_names_length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xauth_names
operator|=
name|default_xauth_names
expr_stmt|;
name|xauth_lengths
operator|=
name|default_xauth_lengths
expr_stmt|;
name|xauth_names_length
operator|=
name|NUM_DEFAULT_AUTH
expr_stmt|;
block|}
name|xauth_data
operator|=
name|tmpdata
expr_stmt|;
name|xauth_datalen
operator|=
name|datalen
expr_stmt|;
return|return;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SECURE_RPC
end_ifdef

begin_comment
comment|/*  * Create a credential that we can send to the X server.  */
end_comment

begin_function
specifier|static
name|int
name|auth_ezencode
parameter_list|(
name|servername
parameter_list|,
name|window
parameter_list|,
name|cred_out
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|servername
decl_stmt|;
name|int
name|window
decl_stmt|;
name|char
modifier|*
name|cred_out
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
block|{
name|AUTH
modifier|*
name|a
decl_stmt|;
name|XDR
name|xdr
decl_stmt|;
name|a
operator|=
name|authdes_create
argument_list|(
name|servername
argument_list|,
name|window
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
operator|(
name|AUTH
operator|*
operator|)
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"auth_create"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xdrmem_create
argument_list|(
operator|&
name|xdr
argument_list|,
name|cred_out
argument_list|,
operator|*
name|len
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|AUTH_MARSHALL
argument_list|(
name|a
argument_list|,
operator|&
name|xdr
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|perror
argument_list|(
literal|"auth_marshall"
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|len
operator|=
name|xdr_getpos
argument_list|(
operator|&
name|xdr
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|GetAuthorization
parameter_list|(
name|fd
parameter_list|,
name|family
parameter_list|,
name|saddr
parameter_list|,
name|saddrlen
parameter_list|,
name|idisplay
parameter_list|,
name|auth_namep
parameter_list|,
name|auth_namelenp
parameter_list|,
name|auth_datap
parameter_list|,
name|auth_datalenp
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
name|family
decl_stmt|;
name|int
name|saddrlen
decl_stmt|;
name|int
name|idisplay
decl_stmt|;
name|char
modifier|*
name|saddr
decl_stmt|;
name|char
modifier|*
modifier|*
name|auth_namep
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|auth_namelenp
decl_stmt|;
comment|/* RETURN */
name|char
modifier|*
modifier|*
name|auth_datap
decl_stmt|;
comment|/* RETURN */
name|int
modifier|*
name|auth_datalenp
decl_stmt|;
comment|/* RETURN */
block|{
ifdef|#
directive|ifdef
name|SECURE_RPC
name|char
name|rpc_cred
index|[
name|MAX_AUTH_BYTES
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HASXDMAUTH
name|char
name|xdmcp_data
index|[
literal|192
operator|/
literal|8
index|]
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|auth_name
decl_stmt|;
name|int
name|auth_namelen
decl_stmt|;
name|char
modifier|*
name|auth_data
decl_stmt|;
name|int
name|auth_datalen
decl_stmt|;
name|Xauth
modifier|*
name|authptr
init|=
name|NULL
decl_stmt|;
comment|/*  * Look up the authorization protocol name and data if necessary.  */
if|if
condition|(
name|xauth_name
operator|&&
name|xauth_data
condition|)
block|{
name|auth_namelen
operator|=
name|xauth_namelen
expr_stmt|;
name|auth_name
operator|=
name|xauth_name
expr_stmt|;
name|auth_datalen
operator|=
name|xauth_datalen
expr_stmt|;
name|auth_data
operator|=
name|xauth_data
expr_stmt|;
block|}
else|else
block|{
name|char
name|dpynumbuf
index|[
literal|40
index|]
decl_stmt|;
comment|/* big enough to hold 2^64 and more */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dpynumbuf
argument_list|,
literal|"%d"
argument_list|,
name|idisplay
argument_list|)
expr_stmt|;
name|authptr
operator|=
name|XauGetBestAuthByAddr
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|family
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|saddrlen
argument_list|,
name|saddr
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|strlen
argument_list|(
name|dpynumbuf
argument_list|)
argument_list|,
name|dpynumbuf
argument_list|,
name|xauth_names_length
argument_list|,
name|xauth_names
argument_list|,
name|xauth_lengths
argument_list|)
expr_stmt|;
if|if
condition|(
name|authptr
condition|)
block|{
name|auth_namelen
operator|=
name|authptr
operator|->
name|name_length
expr_stmt|;
name|auth_name
operator|=
operator|(
name|char
operator|*
operator|)
name|authptr
operator|->
name|name
expr_stmt|;
name|auth_datalen
operator|=
name|authptr
operator|->
name|data_length
expr_stmt|;
name|auth_data
operator|=
operator|(
name|char
operator|*
operator|)
name|authptr
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|auth_namelen
operator|=
literal|0
expr_stmt|;
name|auth_name
operator|=
name|NULL
expr_stmt|;
name|auth_datalen
operator|=
literal|0
expr_stmt|;
name|auth_data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HASXDMAUTH
comment|/*      * build XDM-AUTHORIZATION-1 data      */
if|if
condition|(
name|auth_namelen
operator|==
literal|19
operator|&&
operator|!
name|strncmp
argument_list|(
name|auth_name
argument_list|,
literal|"XDM-AUTHORIZATION-1"
argument_list|,
literal|19
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|long
name|now
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|xdmcp_data
index|[
name|j
index|]
operator|=
name|auth_data
index|[
name|j
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAMSCONN
comment|/*&& SVR4 */
block|{
name|int
name|i
decl_stmt|;
name|struct
name|netbuf
name|netb
decl_stmt|;
name|char
name|addrret
index|[
literal|1024
index|]
decl_stmt|;
name|netb
operator|.
name|maxlen
operator|=
sizeof|sizeof
name|addrret
expr_stmt|;
name|netb
operator|.
name|buf
operator|=
name|addrret
expr_stmt|;
if|if
condition|(
name|t_getname
argument_list|(
name|fd
argument_list|,
operator|&
name|netb
argument_list|,
name|LOCALNAME
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|t_error
argument_list|(
literal|"t_getname"
argument_list|)
expr_stmt|;
comment|/* 	     * XXX - assumes that the return data 	     * are in a struct sockaddr_in, and that 	     * the data structure is layed out in 	     * the normal fashion.  This WILL NOT WORK 	     * on a non 32-bit machine (same in Xstreams.c) 	     */
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
name|netb
operator|.
name|buf
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
name|netb
operator|.
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
else|#
directive|else
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|unsigned
name|short
name|port
decl_stmt|;
ifdef|#
directive|ifdef
name|TCPCONN
name|int
name|addrlen
decl_stmt|;
name|struct
name|sockaddr_in
name|in_addr
decl_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|in_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|in_addr
argument_list|,
operator|&
name|addrlen
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|addrlen
operator|>=
sizeof|sizeof
name|in_addr
operator|&&
name|in_addr
operator|.
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|addr
operator|=
name|ntohl
argument_list|(
name|in_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|in_addr
operator|.
name|sin_port
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
specifier|static
name|unsigned
name|long
name|unix_addr
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|addr
operator|=
name|unix_addr
operator|--
expr_stmt|;
name|port
operator|=
name|getpid
argument_list|()
expr_stmt|;
block|}
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|addr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|addr
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|port
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|port
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
endif|#
directive|endif
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|now
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|now
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|now
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|now
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
while|while
condition|(
name|j
operator|<
literal|192
operator|/
literal|8
condition|)
name|xdmcp_data
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|XdmcpWrap
argument_list|(
name|xdmcp_data
argument_list|,
name|auth_data
operator|+
literal|8
argument_list|,
name|xdmcp_data
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|auth_data
operator|=
name|xdmcp_data
expr_stmt|;
name|auth_datalen
operator|=
name|j
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HASXDMAUTH */
ifdef|#
directive|ifdef
name|SECURE_RPC
comment|/*      * The SUN-DES-1 authorization protocol uses the      * "secure RPC" mechanism in SunOS 4.0+.      */
if|if
condition|(
name|auth_namelen
operator|==
literal|9
operator|&&
operator|!
name|strncmp
argument_list|(
name|auth_name
argument_list|,
literal|"SUN-DES-1"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|char
name|servernetname
index|[
name|MAXNETNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Copy over the server's netname from the authorization 	 * data field filled in by XauGetAuthByAddr(). 	 */
if|if
condition|(
name|auth_datalen
operator|>
name|MAXNETNAMELEN
condition|)
block|{
name|auth_datalen
operator|=
literal|0
expr_stmt|;
name|auth_data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|auth_data
argument_list|,
name|servernetname
argument_list|,
name|auth_datalen
argument_list|)
expr_stmt|;
name|servernetname
index|[
name|auth_datalen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|auth_datalen
operator|=
sizeof|sizeof
argument_list|(
name|rpc_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_ezencode
argument_list|(
name|servernetname
argument_list|,
literal|100
argument_list|,
name|rpc_cred
argument_list|,
operator|&
name|auth_datalen
argument_list|)
condition|)
name|auth_data
operator|=
name|rpc_cred
expr_stmt|;
else|else
name|auth_data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|saddr
condition|)
name|Xfree
argument_list|(
name|saddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|auth_namelenp
operator|=
name|auth_namelen
condition|)
block|{
if|if
condition|(
operator|*
name|auth_namep
operator|=
name|Xmalloc
argument_list|(
name|auth_namelen
argument_list|)
condition|)
name|bcopy
argument_list|(
name|auth_name
argument_list|,
operator|*
name|auth_namep
argument_list|,
name|auth_namelen
argument_list|)
expr_stmt|;
else|else
operator|*
name|auth_namelenp
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|auth_namep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|auth_datalenp
operator|=
name|auth_datalen
condition|)
block|{
if|if
condition|(
operator|*
name|auth_datap
operator|=
name|Xmalloc
argument_list|(
name|auth_datalen
argument_list|)
condition|)
name|bcopy
argument_list|(
name|auth_data
argument_list|,
operator|*
name|auth_datap
argument_list|,
name|auth_datalen
argument_list|)
expr_stmt|;
else|else
operator|*
name|auth_datalenp
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|auth_datap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|authptr
condition|)
name|XauDisposeAuth
argument_list|(
name|authptr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

