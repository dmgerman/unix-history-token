begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XcmsInt.c,v 1.9 92/01/02 19:27:32 rws Exp $" */
end_comment

begin_comment
comment|/*  * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.  * 	All Rights Reserved  *   * This file is a component of an X Window System-specific implementation  * of Xcms based on the TekColor Color Management System.  Permission is  * hereby granted to use, copy, modify, sell, and otherwise distribute this  * software and its documentation for any purpose and without fee, provided  * that this copyright, permission, and disclaimer notice is reproduced in  * all copies of this software and in supporting documentation.  TekColor  * is a trademark of Tektronix, Inc.  *   * Tektronix makes no representation about the suitability of this software  * for any purpose.  It is provided "as is" and with all faults.  *   * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,  * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.  *  *  *	NAME  *		XcmsInt.c - Xcms API utility routines  *  *	DESCRIPTION  *		Xcms Application Program Interface (API) utility  *		routines for hanging information directly onto  *		the Display structure.  *  *  */
end_comment

begin_comment
comment|/* #define NEED_EVENTS */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xcmsint.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|XCMSCOMPPROC
end_ifndef

begin_define
define|#
directive|define
name|XCMSCOMPPROC
value|XcmsTekHVCClipC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *      EXTERNS  */
end_comment

begin_decl_stmt
specifier|extern
name|XcmsColorSpace
modifier|*
modifier|*
name|_XcmsDIColorSpaces
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|XcmsFunctionSet
modifier|*
modifier|*
name|_XcmsSCCFuncSets
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|_XcmsFreeDefaultCCCs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *      GLOBALS  */
end_comment

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			   API PRIVATE ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		_XcmsCopyPointerArray  *  *	SYNOPSIS  */
end_comment

begin_function
name|XPointer
modifier|*
name|_XcmsCopyPointerArray
parameter_list|(
name|pap
parameter_list|)
name|XPointer
modifier|*
name|pap
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Copies an array of NULL terminated pointers.  *  *	RETURNS  *		Returns NULL if failed; otherwise the address to  *		the copy.  *  */
block|{
name|XPointer
modifier|*
name|newArray
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmp
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|pap
operator|,
name|n
operator|=
literal|0
init|;
operator|*
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|++
operator|,
name|n
operator|++
control|)
empty_stmt|;
name|n
operator|++
expr_stmt|;
comment|/* add 1 to include the NULL pointer */
if|if
condition|(
name|newArray
operator|=
operator|(
name|XPointer
operator|*
operator|)
name|Xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|XPointer
argument_list|)
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pap
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newArray
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|XPointer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|XPointer
operator|*
operator|)
name|newArray
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	NAME  *		_XcmsFreePointerArray  *  *	SYNOPSIS  */
end_comment

begin_function
name|void
name|_XcmsFreePointerArray
parameter_list|(
name|pap
parameter_list|)
name|XPointer
modifier|*
name|pap
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Frees an array of NULL terminated pointers.  *  *	RETURNS  *		void  *  */
block|{
name|Xfree
argument_list|(
name|pap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	NAME  *		_XcmsPushPointerArray  *  *	SYNOPSIS  */
end_comment

begin_function
name|XPointer
modifier|*
name|_XcmsPushPointerArray
parameter_list|(
name|pap
parameter_list|,
name|p
parameter_list|,
name|papNoFree
parameter_list|)
name|XPointer
modifier|*
name|pap
decl_stmt|;
name|XPointer
name|p
decl_stmt|;
name|XPointer
modifier|*
name|papNoFree
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Places the specified pointer at the head of an array of NULL  *		terminated pointers.  *  *	RETURNS  *		Returns NULL if failed; otherwise the address to  *		the head of the array.  *  */
block|{
name|XPointer
modifier|*
name|newArray
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmp
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|pap
operator|,
name|n
operator|=
literal|0
init|;
operator|*
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|++
operator|,
name|n
operator|++
control|)
empty_stmt|;
comment|/* add 2: 1 for the new pointer and another for the NULL pointer */
name|n
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|newArray
operator|=
operator|(
name|XPointer
operator|*
operator|)
name|Xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|XPointer
argument_list|)
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pap
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|newArray
operator|+
literal|1
operator|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|XPointer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|newArray
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|pap
operator|!=
name|papNoFree
condition|)
block|{
name|_XcmsFreePointerArray
argument_list|(
name|pap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|XPointer
operator|*
operator|)
name|newArray
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	NAME  *		_XcmsInitDefaultCCCs  *  *	SYNOPSIS  */
end_comment

begin_function
name|int
name|_XcmsInitDefaultCCCs
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Initializes the Xcms per Display Info structure  *		(XcmsPerDpyInfo).  *  *	RETURNS  *		Returns 0 if failed; otherwise non-zero.  *  */
block|{
name|int
name|nScrn
init|=
name|ScreenCount
argument_list|(
name|dpy
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|XcmsCCC
name|ccc
decl_stmt|;
if|if
condition|(
name|nScrn
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Create an array of XcmsCCC structures, one for each screen.      * They serve as the screen's default CCC.      */
if|if
condition|(
operator|!
operator|(
name|ccc
operator|=
operator|(
name|XcmsCCC
operator|)
name|Xcalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nScrn
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|XcmsCCCRec
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
operator|=
operator|(
name|XPointer
operator|)
name|ccc
expr_stmt|;
name|dpy
operator|->
name|free_funcs
operator|->
name|defaultCCCs
operator|=
name|_XcmsFreeDefaultCCCs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nScrn
condition|;
name|i
operator|++
operator|,
name|ccc
operator|++
control|)
block|{
name|ccc
operator|->
name|dpy
operator|=
name|dpy
expr_stmt|;
name|ccc
operator|->
name|screenNumber
operator|=
name|i
expr_stmt|;
name|ccc
operator|->
name|visual
operator|=
name|DefaultVisual
argument_list|(
name|dpy
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Used calloc to allocate memory so: 	 *	ccc->clientWhitePt->format == XcmsUndefinedFormat 	 *	ccc->gamutCompProc == NULL 	 *	ccc->whitePtAdjProc == NULL 	 *	ccc->pPerScrnInfo = NULL 	 * 	 * Don't need to create XcmsPerScrnInfo and its functionSet and 	 * pScreenData components until the default CCC is accessed. 	 * Note that the XcmsDefaultCCC routine calls _XcmsInitScrnInto 	 * to do this. 	 */
name|ccc
operator|->
name|gamutCompProc
operator|=
name|XCMSCOMPPROC
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsFreeDefaultCCCs - Free Default CCCs and its PerScrnInfo  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|_XcmsFreeDefaultCCCs
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
comment|/*  *	DESCRIPTION  *		This routine frees the default XcmsCCC's associated with  *		each screen and its associated substructures as neccessary.  *  *	RETURNS  *		void  *  *  */
block|{
name|int
name|nScrn
init|=
name|ScreenCount
argument_list|(
name|dpy
argument_list|)
decl_stmt|;
name|XcmsCCC
name|ccc
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Free Screen data in each DefaultCCC      *		Do not use XcmsFreeCCC here because it will not free      *		DefaultCCC's.      */
name|ccc
operator|=
operator|(
name|XcmsCCC
operator|)
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nScrn
init|;
name|i
operator|--
condition|;
name|ccc
operator|++
control|)
block|{
comment|/* 	 * Check if XcmsPerScrnInfo exists. 	 * 	 * This is the only place where XcmsPerScrnInfo structures 	 * are freed since there is only one allocated per Screen. 	 * It just so happens that we place its reference in the 	 * default CCC. 	 */
if|if
condition|(
name|ccc
operator|->
name|pPerScrnInfo
condition|)
block|{
comment|/* Check if SCCData exists */
if|if
condition|(
operator|(
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|state
operator|==
name|XcmsInitSuccess
operator|||
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|state
operator|==
name|XcmsInitDefault
operator|)
operator|&&
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|screenData
condition|)
block|{
operator|(
operator|*
operator|(
operator|(
name|XcmsFunctionSet
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|functionSet
operator|)
operator|->
name|screenFreeProc
operator|)
operator|(
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|screenData
operator|)
expr_stmt|;
block|}
name|Xfree
argument_list|(
name|ccc
operator|->
name|pPerScrnInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Free the array of XcmsCCC structures      */
name|Xfree
argument_list|(
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
argument_list|)
expr_stmt|;
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
operator|=
operator|(
name|XPointer
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsInitScrnInfo  *  *	SYNOPSIS  */
end_comment

begin_function
name|int
name|_XcmsInitScrnInfo
parameter_list|(
name|dpy
parameter_list|,
name|screenNumber
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
name|int
name|screenNumber
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Given a display and screen number, this routine attempts  *		to initialize the Xcms per Screen Info structure  *		(XcmsPerScrnInfo).  *  *	RETURNS  *		Returns zero if initialization failed; non-zero otherwise.  */
block|{
name|XcmsFunctionSet
modifier|*
modifier|*
name|papSCCFuncSet
init|=
name|_XcmsSCCFuncSets
decl_stmt|;
name|XcmsCCC
name|defaultccc
decl_stmt|;
comment|/*      * Check if the XcmsCCC's for each screen has been created.      * Really dont need to be created until some routine uses the Xcms      * API routines.      */
if|if
condition|(
operator|(
name|XcmsCCC
operator|)
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|_XcmsInitDefaultCCCs
argument_list|(
name|dpy
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|defaultccc
operator|=
operator|(
name|XcmsCCC
operator|)
name|dpy
operator|->
name|cms
operator|.
name|defaultCCCs
operator|+
name|screenNumber
expr_stmt|;
comment|/*      * For each SCCFuncSet, try its pInitScrnFunc.      *	If the function succeeds, then we got it!      */
if|if
condition|(
operator|!
name|defaultccc
operator|->
name|pPerScrnInfo
condition|)
block|{
comment|/* 	 * This is one of two places where XcmsPerScrnInfo structures 	 * are allocated.  There is one allocated per Screen that is 	 * shared among visuals that do not have specific intensity 	 * tables.  Other XcmsPerScrnInfo structures are created 	 * for the latter (see XcmsCreateCCC).  The ones created 	 * here are referenced by the default CCC. 	 */
if|if
condition|(
operator|!
operator|(
name|defaultccc
operator|->
name|pPerScrnInfo
operator|=
operator|(
name|XcmsPerScrnInfo
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|XcmsPerScrnInfo
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|defaultccc
operator|->
name|pPerScrnInfo
operator|->
name|state
operator|=
name|XcmsInitNone
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|papSCCFuncSet
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
operator|*
name|papSCCFuncSet
operator|)
operator|->
name|screenInitProc
operator|)
operator|(
name|dpy
operator|,
name|screenNumber
operator|,
name|defaultccc
operator|->
name|pPerScrnInfo
operator|)
condition|)
block|{
name|defaultccc
operator|->
name|pPerScrnInfo
operator|->
name|state
operator|=
name|XcmsInitSuccess
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|papSCCFuncSet
operator|++
expr_stmt|;
block|}
comment|/*      * Use Default SCCData      */
return|return
operator|(
name|_XcmsLRGB_InitScrnDefault
argument_list|(
name|dpy
argument_list|,
name|screenNumber
argument_list|,
name|defaultccc
operator|->
name|pPerScrnInfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsFreeIntensityMaps  *  *	SYNOPSIS  */
end_comment

begin_function
name|void
name|_XcmsFreeIntensityMaps
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Frees all XcmsIntensityMap structures in the linked list  *		and sets dpy->cms.perVisualIntensityMaps to NULL.  *  *	RETURNS  *		void  *  */
block|{
name|XcmsIntensityMap
modifier|*
name|pNext
decl_stmt|,
modifier|*
name|pFree
decl_stmt|;
name|pNext
operator|=
operator|(
name|XcmsIntensityMap
operator|*
operator|)
name|dpy
operator|->
name|cms
operator|.
name|perVisualIntensityMaps
expr_stmt|;
while|while
condition|(
name|pNext
operator|!=
name|NULL
condition|)
block|{
name|pFree
operator|=
name|pNext
expr_stmt|;
name|pNext
operator|=
name|pNext
operator|->
name|pNext
expr_stmt|;
call|(
modifier|*
name|pFree
operator|->
name|pFreeScreenData
call|)
argument_list|(
name|pFree
operator|->
name|screenData
argument_list|)
expr_stmt|;
comment|/* Now free the XcmsIntensityMap structure */
name|Xfree
argument_list|(
name|pFree
argument_list|)
expr_stmt|;
block|}
name|dpy
operator|->
name|cms
operator|.
name|perVisualIntensityMaps
operator|=
operator|(
name|XPointer
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsGetIntensityMap  *  *	SYNOPSIS  */
end_comment

begin_function
name|XcmsIntensityMap
modifier|*
name|_XcmsGetIntensityMap
parameter_list|(
name|dpy
parameter_list|,
name|visual
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|Visual
modifier|*
name|visual
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Attempts to return a per-Visual intensity map.  *  *	RETURNS  *		Pointer to the XcmsIntensityMap structure if found;  *		otherwise NULL  *  */
block|{
name|VisualID
name|targetID
init|=
name|visual
operator|->
name|visualid
decl_stmt|;
name|XcmsIntensityMap
modifier|*
name|pNext
decl_stmt|;
name|pNext
operator|=
operator|(
name|XcmsIntensityMap
operator|*
operator|)
name|dpy
operator|->
name|cms
operator|.
name|perVisualIntensityMaps
expr_stmt|;
while|while
condition|(
name|pNext
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|targetID
operator|==
name|pNext
operator|->
name|visualID
condition|)
block|{
return|return
operator|(
name|pNext
operator|)
return|;
block|}
name|pNext
operator|=
name|pNext
operator|->
name|pNext
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|XcmsIntensityMap
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

end_unit

