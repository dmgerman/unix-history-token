begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XcmsCvCols.c,v 1.9 91/07/25 01:08:38 rws Exp $" */
end_comment

begin_comment
comment|/*  * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.  * 	All Rights Reserved  *   * This file is a component of an X Window System-specific implementation  * of Xcms based on the TekColor Color Management System.  Permission is  * hereby granted to use, copy, modify, sell, and otherwise distribute this  * software and its documentation for any purpose and without fee, provided  * that this copyright, permission, and disclaimer notice is reproduced in  * all copies of this software and in supporting documentation.  TekColor  * is a trademark of Tektronix, Inc.  *   * Tektronix makes no representation about the suitability of this software  * for any purpose.  It is provided "as is" and with all faults.  *   * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,  * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.  *  *  *	NAME  *		XcmsCvCols.c  *  *	DESCRIPTION  *		TekCMS API routine that converts between the  *		device-independent color spaces.  *  *  */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xcmsint.h"
end_include

begin_comment
comment|/*  *      EXTERNS  *              External declarations required locally to this package  *              that are not already declared in any of the included header  *		files (external includes or internal includes).  */
end_comment

begin_decl_stmt
specifier|extern
name|XcmsRegColorSpaceEntry
name|_XcmsRegColorSpaces
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|XcmsColorSpace
modifier|*
modifier|*
name|_XcmsDIColorSpaces
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|XcmsColorSpace
modifier|*
modifier|*
name|_XcmsDDColorSpaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      LOCAL DEFINES  */
end_comment

begin_define
define|#
directive|define
name|DD_FORMAT
value|0x01
end_define

begin_define
define|#
directive|define
name|DI_FORMAT
value|0x02
end_define

begin_define
define|#
directive|define
name|MIX_FORMAT
value|0x04
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *      FORWARD DECLARATIONS  */
end_comment

begin_function_decl
name|Status
name|_XcmsDIConvertColors
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Status
name|_XcmsDDConvertColors
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			 PRIVATE ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		EqualCIEXYZ  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|int
name|EqualCIEXYZ
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|XcmsColor
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_comment
comment|/*  *	DESCRIPTION  *		Compares two XcmsColor structures that are in XcmsCIEXYZFormat  *  *	RETURNS  *		Returns 1 if equal; 0 otherwise.  *  */
end_comment

begin_block
block|{
if|if
condition|(
name|p1
operator|->
name|format
operator|!=
name|XcmsCIEXYZFormat
operator|||
name|p2
operator|->
name|format
operator|!=
name|XcmsCIEXYZFormat
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p1
operator|->
name|spec
operator|.
name|CIEXYZ
operator|.
name|X
operator|!=
name|p2
operator|->
name|spec
operator|.
name|CIEXYZ
operator|.
name|X
operator|)
operator|||
operator|(
name|p1
operator|->
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|!=
name|p2
operator|->
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|)
operator|||
operator|(
name|p1
operator|->
name|spec
operator|.
name|CIEXYZ
operator|.
name|Z
operator|!=
name|p2
operator|->
name|spec
operator|.
name|CIEXYZ
operator|.
name|Z
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsColorSpace  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|XcmsColorSpace
modifier|*
name|ColorSpaceOfID
parameter_list|(
name|ccc
parameter_list|,
name|id
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColorFormat
name|id
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Returns a pointer to the color space structure  *		(XcmsColorSpace) associated with the specified color space  *		ID.  *  *	RETURNS  *		Pointer to matching XcmsColorSpace structure if found;  *		otherwise NULL.  */
block|{
name|XcmsColorSpace
modifier|*
modifier|*
name|papColorSpaces
decl_stmt|;
if|if
condition|(
name|ccc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * First try Device-Independent color spaces      */
name|papColorSpaces
operator|=
name|_XcmsDIColorSpaces
expr_stmt|;
if|if
condition|(
name|papColorSpaces
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|papColorSpaces
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|papColorSpaces
operator|)
operator|->
name|id
operator|==
name|id
condition|)
block|{
return|return
operator|(
operator|*
name|papColorSpaces
operator|)
return|;
block|}
name|papColorSpaces
operator|++
expr_stmt|;
block|}
block|}
comment|/*      * Next try Device-Dependent color spaces      */
name|papColorSpaces
operator|=
operator|(
operator|(
name|XcmsFunctionSet
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|functionSet
operator|)
operator|->
name|DDColorSpaces
expr_stmt|;
if|if
condition|(
name|papColorSpaces
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|papColorSpaces
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|papColorSpaces
operator|)
operator|->
name|id
operator|==
name|id
condition|)
block|{
return|return
operator|(
operator|*
name|papColorSpaces
operator|)
return|;
block|}
name|papColorSpaces
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		ValidDIColorSpaceID  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|int
name|ValidDIColorSpaceID
parameter_list|(
name|id
parameter_list|)
name|XcmsColorFormat
name|id
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Determines if the specified color space ID is a valid  *		Device-Independent color space in the specified Color  *		Conversion Context.  *  *	RETURNS  *		Returns zero if not valid; otherwise non-zero.  */
block|{
name|XcmsColorSpace
modifier|*
modifier|*
name|papRec
decl_stmt|;
name|papRec
operator|=
name|_XcmsDIColorSpaces
expr_stmt|;
if|if
condition|(
name|papRec
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|papRec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|papRec
operator|)
operator|->
name|id
operator|==
name|id
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|papRec
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		ValidDDColorSpaceID  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|int
name|ValidDDColorSpaceID
parameter_list|(
name|ccc
parameter_list|,
name|id
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColorFormat
name|id
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Determines if the specified color space ID is a valid  *		Device-Dependent color space in the specified Color  *		Conversion Context.  *  *	RETURNS  *		Returns zero if not valid; otherwise non-zero.  */
block|{
name|XcmsColorSpace
modifier|*
modifier|*
name|papRec
decl_stmt|;
if|if
condition|(
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|state
operator|==
name|XcmsInitSuccess
operator|||
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|state
operator|==
name|XcmsInitDefault
condition|)
block|{
name|papRec
operator|=
operator|(
operator|(
name|XcmsFunctionSet
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|functionSet
operator|)
operator|->
name|DDColorSpaces
expr_stmt|;
while|while
condition|(
operator|*
name|papRec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|papRec
operator|)
operator|->
name|id
operator|==
name|id
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|papRec
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		ConvertMixedColors - Convert XcmsColor structures  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|Status
name|ConvertMixedColors
parameter_list|(
name|ccc
parameter_list|,
name|pColors_in_out
parameter_list|,
name|pWhitePt
parameter_list|,
name|nColors
parameter_list|,
name|targetFormat
parameter_list|,
name|format_flag
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pColors_in_out
decl_stmt|;
name|XcmsColor
modifier|*
name|pWhitePt
decl_stmt|;
name|unsigned
name|int
name|nColors
decl_stmt|;
name|XcmsColorFormat
name|targetFormat
decl_stmt|;
name|unsigned
name|char
name|format_flag
decl_stmt|;
comment|/*  *	DESCRIPTION  *		This routine will only convert the following types of  *		batches:  *			DI to DI  *			DD to DD  *			DD to CIEXYZ  *		In other words, it will not convert the following types of  *		batches:  *			DI to DD  *			DD to DI(not CIEXYZ)  *		  *		format_flag:  *		    0x01 : convert Device-Dependent only specifications to the  *			target format.  *		    0x02 : convert Device-Independent only specifications to the  *			target format.  *		    0x03 : convert all specifications to the target format.  *  *	RETURNS  *		XcmsFailure if failed,  *		XcmsSuccess if none of the color specifications were  *			compressed in the conversion process  *		XcmsSuccessWithCompression if at least one of the  *			color specifications were compressed in the  *			conversion process.  *  */
block|{
name|XcmsColor
modifier|*
name|pColor
decl_stmt|,
modifier|*
name|pColors_start
decl_stmt|;
name|XcmsColorFormat
name|format
decl_stmt|;
name|Status
name|retval_tmp
decl_stmt|;
name|Status
name|retval
init|=
name|XcmsSuccess
decl_stmt|;
name|unsigned
name|int
name|iColors
decl_stmt|;
name|unsigned
name|int
name|nBatch
decl_stmt|;
comment|/*      * Convert array of mixed color specifications in batches of      * contiguous formats to the target format      */
name|iColors
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|iColors
operator|<
name|nColors
condition|)
block|{
comment|/* 	 * Find contiguous array of color specifications with the 	 * same format 	 */
name|pColor
operator|=
name|pColors_start
operator|=
name|pColors_in_out
operator|+
name|iColors
expr_stmt|;
name|format
operator|=
name|pColors_start
operator|->
name|format
expr_stmt|;
name|nBatch
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|iColors
operator|<
name|nColors
operator|&&
name|pColor
operator|->
name|format
operator|==
name|format
condition|)
block|{
name|pColor
operator|++
expr_stmt|;
name|nBatch
operator|++
expr_stmt|;
name|iColors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|!=
name|targetFormat
condition|)
block|{
comment|/* 	     * Need to convert this batch from current format to target format. 	     */
if|if
condition|(
name|XCMS_DI_ID
argument_list|(
name|format
argument_list|)
operator|&&
operator|(
name|format_flag
operator|&
name|DI_FORMAT
operator|)
operator|&&
name|XCMS_DI_ID
argument_list|(
name|targetFormat
argument_list|)
condition|)
block|{
comment|/* 		 * DI->DI 		 * 		 * Format of interest is Device-Independent, 		 * This batch contains Device-Independent specifications, and 		 * the Target format is Device-Independent. 		 */
name|retval_tmp
operator|=
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_start
argument_list|,
name|pWhitePt
argument_list|,
name|nBatch
argument_list|,
name|targetFormat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XCMS_DD_ID
argument_list|(
name|format
argument_list|)
operator|&&
operator|(
name|format_flag
operator|&
name|DD_FORMAT
operator|)
operator|&&
operator|(
name|targetFormat
operator|==
name|XcmsCIEXYZFormat
operator|)
condition|)
block|{
comment|/* 		 * DD->CIEXYZ 		 * 		 * Format of interest is Device-Dependent, 		 * This batch contains Device-Dependent specifications, and 		 * the Target format is CIEXYZ. 		 * 		 * Since DD->CIEXYZ we can use NULL instead of pCompressed. 		 */
if|if
condition|(
operator|(
name|ccc
operator|->
name|whitePtAdjProc
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|_XcmsEqualWhitePts
argument_list|(
name|ccc
argument_list|,
name|pWhitePt
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		     * Need to call WhiteAdjustProc (Screen White Point to 		     *   White Point). 		     */
name|retval_tmp
operator|=
call|(
modifier|*
name|ccc
operator|->
name|whitePtAdjProc
call|)
argument_list|(
name|ccc
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|,
name|pWhitePt
argument_list|,
name|XcmsCIEXYZFormat
argument_list|,
name|pColors_start
argument_list|,
name|nBatch
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval_tmp
operator|=
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_start
argument_list|,
name|nBatch
argument_list|,
name|XcmsCIEXYZFormat
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|XCMS_DD_ID
argument_list|(
name|format
argument_list|)
operator|&&
operator|(
name|format_flag
operator|&
name|DD_FORMAT
operator|)
operator|&&
name|XCMS_DD_ID
argument_list|(
name|targetFormat
argument_list|)
condition|)
block|{
comment|/* 		 * DD->DD(not CIEXYZ) 		 * 		 * Format of interest is Device-Dependent, 		 * This batch contains Device-Dependent specifications, and 		 * the Target format is Device-Dependent and not CIEXYZ. 		 */
name|retval_tmp
operator|=
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_start
argument_list|,
name|nBatch
argument_list|,
name|targetFormat
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This routine is called for the wrong reason. 		 */
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|retval_tmp
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|retval
operator|=
name|MAX
argument_list|(
name|retval
argument_list|,
name|retval_tmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			 API PRIVATE ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		_XcmsEqualWhitePts  *  *	SYNOPSIS  */
end_comment

begin_function
name|int
name|_XcmsEqualWhitePts
parameter_list|(
name|ccc
parameter_list|,
name|pWhitePt1
parameter_list|,
name|pWhitePt2
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pWhitePt1
decl_stmt|,
decl|*
name|pWhitePt2
decl_stmt|;
end_function

begin_comment
comment|/*  *	DESCRIPTION  *  *	RETURNS  *		Returns 0 if not equal; otherwise 1.  *  */
end_comment

begin_block
block|{
name|XcmsColor
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pWhitePt1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp1
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pWhitePt2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp2
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|.
name|format
operator|!=
name|XcmsCIEXYZFormat
condition|)
block|{
if|if
condition|(
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
operator|&
name|tmp1
argument_list|,
operator|(
name|XcmsColor
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|XcmsCIEXYZFormat
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tmp2
operator|.
name|format
operator|!=
name|XcmsCIEXYZFormat
condition|)
block|{
if|if
condition|(
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
operator|&
name|tmp2
argument_list|,
operator|(
name|XcmsColor
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|XcmsCIEXYZFormat
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EqualCIEXYZ
argument_list|(
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsDIConvertColors - Convert XcmsColor structures  *  *	SYNOPSIS  */
end_comment

begin_function
name|Status
name|_XcmsDIConvertColors
parameter_list|(
name|ccc
parameter_list|,
name|pColors_in_out
parameter_list|,
name|pWhitePt
parameter_list|,
name|nColors
parameter_list|,
name|newFormat
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pColors_in_out
decl_stmt|;
name|XcmsColor
modifier|*
name|pWhitePt
decl_stmt|;
name|unsigned
name|int
name|nColors
decl_stmt|;
name|XcmsColorFormat
name|newFormat
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Convert XcmsColor structures to another Device-Independent  *		form.  *  *		Here are some assumptions that this routine makes:  *		1. The calling routine has already checked if  *		    pColors_in_out->format == newFormat, therefore  *		    there is no need to check again here.  *		2. The calling routine has already checked nColors,  *		    therefore this routine assumes nColors> 0.  *		3. The calling routine may want to convert only between  *			CIExyY<-> CIEXYZ<-> CIEuvY  *		    therefore, this routine allows pWhitePt to equal NULL.  *		  *  *	RETURNS  *		XcmsFailure if failed,  *		XcmsSuccess if succeeded.  *  */
block|{
name|XcmsColorSpace
modifier|*
name|pFrom
decl_stmt|,
modifier|*
name|pTo
decl_stmt|;
name|XcmsConversionProc
modifier|*
name|src_to_CIEXYZ
decl_stmt|,
modifier|*
name|src_from_CIEXYZ
decl_stmt|;
name|XcmsConversionProc
modifier|*
name|dest_to_CIEXYZ
decl_stmt|,
modifier|*
name|dest_from_CIEXYZ
decl_stmt|;
name|XcmsConversionProc
modifier|*
name|to_CIEXYZ_stop
decl_stmt|,
modifier|*
name|from_CIEXYZ_start
decl_stmt|;
name|XcmsConversionProc
modifier|*
name|tmp
decl_stmt|;
comment|/*      * Allow pWhitePt to equal NULL.  This appropriate when converting      *    anywhere between:      *		CIExyY<-> CIEXYZ<-> CIEuvY      */
if|if
condition|(
name|pColors_in_out
operator|==
name|NULL
operator|||
operator|!
name|ValidDIColorSpaceID
argument_list|(
name|pColors_in_out
operator|->
name|format
argument_list|)
operator|||
operator|!
name|ValidDIColorSpaceID
argument_list|(
name|newFormat
argument_list|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*      * Get a handle on the function list for the current specification format      */
if|if
condition|(
operator|(
name|pFrom
operator|=
name|ColorSpaceOfID
argument_list|(
name|ccc
argument_list|,
name|pColors_in_out
operator|->
name|format
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*      * Get a handle on the function list for the new specification format      */
if|if
condition|(
operator|(
name|pTo
operator|=
name|ColorSpaceOfID
argument_list|(
name|ccc
argument_list|,
name|newFormat
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|src_to_CIEXYZ
operator|=
name|pFrom
operator|->
name|to_CIEXYZ
expr_stmt|;
name|src_from_CIEXYZ
operator|=
name|pFrom
operator|->
name|from_CIEXYZ
expr_stmt|;
name|dest_to_CIEXYZ
operator|=
name|pTo
operator|->
name|to_CIEXYZ
expr_stmt|;
name|dest_from_CIEXYZ
operator|=
name|pTo
operator|->
name|from_CIEXYZ
expr_stmt|;
if|if
condition|(
name|pTo
operator|->
name|inverse_flag
operator|&&
name|pFrom
operator|->
name|inverse_flag
condition|)
block|{
comment|/* 	 * Find common function pointers 	 */
for|for
control|(
name|to_CIEXYZ_stop
operator|=
name|src_to_CIEXYZ
init|;
operator|*
name|to_CIEXYZ_stop
condition|;
name|to_CIEXYZ_stop
operator|++
control|)
block|{
for|for
control|(
name|tmp
operator|=
name|dest_to_CIEXYZ
init|;
operator|*
name|tmp
condition|;
name|tmp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|to_CIEXYZ_stop
operator|==
operator|*
name|tmp
condition|)
block|{
goto|goto
name|Continue
goto|;
block|}
block|}
block|}
name|Continue
label|:
comment|/* 	 * Execute the functions to CIEXYZ, stopping short as necessary 	 */
while|while
condition|(
name|src_to_CIEXYZ
operator|!=
name|to_CIEXYZ_stop
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|src_to_CIEXYZ
operator|++
operator|)
operator|(
name|ccc
operator|,
name|pWhitePt
operator|,
name|pColors_in_out
operator|,
name|nColors
operator|)
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
block|}
comment|/* 	 * Determine where to start on the from_CIEXYZ path. 	 */
name|from_CIEXYZ_start
operator|=
name|dest_from_CIEXYZ
expr_stmt|;
name|tmp
operator|=
name|src_from_CIEXYZ
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|from_CIEXYZ_start
operator|==
operator|*
name|tmp
operator|)
operator|&&
operator|(
operator|*
name|from_CIEXYZ_start
operator|!=
name|NULL
operator|)
condition|)
block|{
name|from_CIEXYZ_start
operator|++
expr_stmt|;
name|tmp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * The function in at least one of the Color Spaces are not 	 * complementary, i.e., 	 *	for an i, 0<= i< n elements 	 *	from_CIEXYZ[i] is not the inverse of to_CIEXYZ[i] 	 *	 	 * Execute the functions all the way to CIEXYZ 	 */
while|while
condition|(
operator|*
name|src_to_CIEXYZ
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|src_to_CIEXYZ
operator|++
operator|)
operator|(
name|ccc
operator|,
name|pWhitePt
operator|,
name|pColors_in_out
operator|,
name|nColors
operator|)
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
block|}
comment|/* 	 * Determine where to start on the from_CIEXYZ path. 	 */
name|from_CIEXYZ_start
operator|=
name|dest_from_CIEXYZ
expr_stmt|;
block|}
comment|/*      * Execute the functions from CIEXYZ.      */
while|while
condition|(
operator|*
name|from_CIEXYZ_start
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|from_CIEXYZ_start
operator|++
operator|)
operator|(
name|ccc
operator|,
name|pWhitePt
operator|,
name|pColors_in_out
operator|,
name|nColors
operator|)
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsDDConvertColors - Convert XcmsColor structures  *  *	SYNOPSIS  */
end_comment

begin_function
name|Status
name|_XcmsDDConvertColors
parameter_list|(
name|ccc
parameter_list|,
name|pColors_in_out
parameter_list|,
name|nColors
parameter_list|,
name|newFormat
parameter_list|,
name|pCompressed
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pColors_in_out
decl_stmt|;
name|unsigned
name|int
name|nColors
decl_stmt|;
name|XcmsColorFormat
name|newFormat
decl_stmt|;
name|Bool
modifier|*
name|pCompressed
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Convert XcmsColor structures:  *  *		1. From CIEXYZ to Device-Dependent formats (typically RGB and  *			RGBi),  *		    or  *		2. Between Device-Dependent formats (typically RGB and RGBi).  *  *		Assumes that these specifications have already been white point  *		adjusted if necessary from Client White Point to Screen  *		White Point.  Therefore, the white point now associated  *		with the specifications is the Screen White Point.  *  *		pCompressed may be NULL.  If so this indicates that the  *		calling routine is not interested in knowing exactly which  *		color was compressed, if any.  *  *  *	RETURNS  *		XcmsFailure if failed,  *		XcmsSuccess if none of the color specifications were  *			compressed in the conversion process  *		XcmsSuccessWithCompression if at least one of the  *			color specifications were compressed in the  *			conversion process.  *  */
block|{
name|XcmsColorSpace
modifier|*
name|pFrom
decl_stmt|,
modifier|*
name|pTo
decl_stmt|;
name|XcmsConversionProc
modifier|*
name|src_to_CIEXYZ
decl_stmt|,
modifier|*
name|src_from_CIEXYZ
decl_stmt|;
name|XcmsConversionProc
modifier|*
name|dest_to_CIEXYZ
decl_stmt|,
modifier|*
name|dest_from_CIEXYZ
decl_stmt|;
name|XcmsConversionProc
modifier|*
name|from_CIEXYZ_start
decl_stmt|,
modifier|*
name|to_CIEXYZ_stop
decl_stmt|;
name|XcmsConversionProc
modifier|*
name|tmp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|hasCompressed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ccc
operator|==
name|NULL
operator|||
name|pColors_in_out
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|nColors
operator|==
literal|0
operator|||
name|pColors_in_out
operator|->
name|format
operator|==
name|newFormat
condition|)
block|{
comment|/* do nothing */
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|XcmsFunctionSet
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|functionSet
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
comment|/* hmm, an internal error? */
block|}
comment|/*      * Its ok if pColors_in_out->format == XcmsCIEXYZFormat      *	or       * if newFormat == XcmsCIEXYZFormat      */
if|if
condition|(
operator|!
operator|(
name|ValidDDColorSpaceID
argument_list|(
name|ccc
argument_list|,
name|pColors_in_out
operator|->
name|format
argument_list|)
operator|||
operator|(
name|pColors_in_out
operator|->
name|format
operator|==
name|XcmsCIEXYZFormat
operator|)
operator|)
operator|||
operator|!
operator|(
name|ValidDDColorSpaceID
argument_list|(
name|ccc
argument_list|,
name|newFormat
argument_list|)
operator|||
name|newFormat
operator|==
name|XcmsCIEXYZFormat
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pFrom
operator|=
name|ColorSpaceOfID
argument_list|(
name|ccc
argument_list|,
name|pColors_in_out
operator|->
name|format
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pTo
operator|=
name|ColorSpaceOfID
argument_list|(
name|ccc
argument_list|,
name|newFormat
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|src_to_CIEXYZ
operator|=
name|pFrom
operator|->
name|to_CIEXYZ
expr_stmt|;
name|src_from_CIEXYZ
operator|=
name|pFrom
operator|->
name|from_CIEXYZ
expr_stmt|;
name|dest_to_CIEXYZ
operator|=
name|pTo
operator|->
name|to_CIEXYZ
expr_stmt|;
name|dest_from_CIEXYZ
operator|=
name|pTo
operator|->
name|from_CIEXYZ
expr_stmt|;
if|if
condition|(
name|pTo
operator|->
name|inverse_flag
operator|&&
name|pFrom
operator|->
name|inverse_flag
condition|)
block|{
comment|/* 	 * Find common function pointers 	 */
for|for
control|(
name|to_CIEXYZ_stop
operator|=
name|src_to_CIEXYZ
init|;
operator|*
name|to_CIEXYZ_stop
condition|;
name|to_CIEXYZ_stop
operator|++
control|)
block|{
for|for
control|(
name|tmp
operator|=
name|dest_to_CIEXYZ
init|;
operator|*
name|tmp
condition|;
name|tmp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|to_CIEXYZ_stop
operator|==
operator|*
name|tmp
condition|)
block|{
goto|goto
name|Continue
goto|;
block|}
block|}
block|}
name|Continue
label|:
comment|/* 	 * Execute the functions 	 */
while|while
condition|(
name|src_to_CIEXYZ
operator|!=
name|to_CIEXYZ_stop
condition|)
block|{
name|retval
operator|=
operator|(
operator|*
name|src_to_CIEXYZ
operator|++
operator|)
operator|(
name|ccc
operator|,
name|pColors_in_out
operator|,
name|nColors
operator|,
name|pCompressed
operator|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|hasCompressed
operator||=
operator|(
name|retval
operator|==
name|XcmsSuccessWithCompression
operator|)
expr_stmt|;
block|}
comment|/* 	 * Determine where to start on the from_CIEXYZ path. 	 */
name|from_CIEXYZ_start
operator|=
name|dest_from_CIEXYZ
expr_stmt|;
name|tmp
operator|=
name|src_from_CIEXYZ
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|from_CIEXYZ_start
operator|==
operator|*
name|tmp
operator|)
operator|&&
operator|(
operator|*
name|from_CIEXYZ_start
operator|!=
name|NULL
operator|)
condition|)
block|{
name|from_CIEXYZ_start
operator|++
expr_stmt|;
name|tmp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * The function in at least one of the Color Spaces are not 	 * complementary, i.e., 	 *	for an i, 0<= i< n elements 	 *	from_CIEXYZ[i] is not the inverse of to_CIEXYZ[i] 	 *	 	 * Execute the functions all the way to CIEXYZ 	 */
while|while
condition|(
operator|*
name|src_to_CIEXYZ
condition|)
block|{
name|retval
operator|=
operator|(
operator|*
name|src_to_CIEXYZ
operator|++
operator|)
operator|(
name|ccc
operator|,
name|pColors_in_out
operator|,
name|nColors
operator|,
name|pCompressed
operator|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|hasCompressed
operator||=
operator|(
name|retval
operator|==
name|XcmsSuccessWithCompression
operator|)
expr_stmt|;
block|}
comment|/* 	 * Determine where to start on the from_CIEXYZ path. 	 */
name|from_CIEXYZ_start
operator|=
name|dest_from_CIEXYZ
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|from_CIEXYZ_start
condition|)
block|{
name|retval
operator|=
operator|(
operator|*
name|from_CIEXYZ_start
operator|++
operator|)
operator|(
name|ccc
operator|,
name|pColors_in_out
operator|,
name|nColors
operator|,
name|pCompressed
operator|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|XcmsFailure
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|hasCompressed
operator||=
operator|(
name|retval
operator|==
name|XcmsSuccessWithCompression
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|hasCompressed
condition|?
name|XcmsSuccessWithCompression
else|:
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			 PUBLIC ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		XcmsConvertColors - Convert XcmsColor structures  *  *	SYNOPSIS  */
end_comment

begin_function
name|Status
name|XcmsConvertColors
parameter_list|(
name|ccc
parameter_list|,
name|pColors_in_out
parameter_list|,
name|nColors
parameter_list|,
name|targetFormat
parameter_list|,
name|pCompressed
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pColors_in_out
decl_stmt|;
name|unsigned
name|int
name|nColors
decl_stmt|;
name|XcmsColorFormat
name|targetFormat
decl_stmt|;
name|Bool
modifier|*
name|pCompressed
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Convert XcmsColor structures to another format  *  *	RETURNS  *		XcmsFailure if failed,  *		XcmsSuccess if succeeded without gamut compression,  *		XcmsSuccessWithCompression if succeeded with gamut  *			compression.  *  */
block|{
name|XcmsColor
name|clientWhitePt
decl_stmt|;
name|XcmsColor
name|Color1
decl_stmt|;
name|XcmsColor
modifier|*
name|pColors_tmp
decl_stmt|;
name|int
name|callWhiteAdjustProc
init|=
literal|0
decl_stmt|;
name|XcmsColorFormat
name|format
decl_stmt|;
name|Status
name|retval
decl_stmt|;
name|unsigned
name|char
name|contents_flag
init|=
literal|0x00
decl_stmt|;
name|unsigned
name|int
name|iColors
decl_stmt|;
if|if
condition|(
name|ccc
operator|==
name|NULL
operator|||
name|pColors_in_out
operator|==
name|NULL
operator|||
operator|!
operator|(
name|ValidDIColorSpaceID
argument_list|(
name|targetFormat
argument_list|)
operator|||
name|ValidDDColorSpaceID
argument_list|(
name|ccc
argument_list|,
name|targetFormat
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*      * Check formats in color specification array      */
name|format
operator|=
name|pColors_in_out
operator|->
name|format
expr_stmt|;
for|for
control|(
name|pColors_tmp
operator|=
name|pColors_in_out
operator|,
name|iColors
operator|=
name|nColors
init|;
name|iColors
condition|;
name|pColors_tmp
operator|++
operator|,
name|iColors
operator|--
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ValidDIColorSpaceID
argument_list|(
name|pColors_tmp
operator|->
name|format
argument_list|)
operator|||
name|ValidDDColorSpaceID
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
operator|->
name|format
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|XCMS_DI_ID
argument_list|(
name|pColors_tmp
operator|->
name|format
argument_list|)
condition|)
block|{
name|contents_flag
operator||=
name|DI_FORMAT
expr_stmt|;
block|}
else|else
block|{
name|contents_flag
operator||=
name|DD_FORMAT
expr_stmt|;
block|}
if|if
condition|(
name|pColors_tmp
operator|->
name|format
operator|!=
name|format
condition|)
block|{
name|contents_flag
operator||=
name|MIX_FORMAT
expr_stmt|;
block|}
block|}
comment|/*      * Check if we need the Client White Point.      */
if|if
condition|(
operator|(
name|contents_flag
operator|&
name|DI_FORMAT
operator|)
operator|||
name|XCMS_DI_ID
argument_list|(
name|targetFormat
argument_list|)
condition|)
block|{
comment|/* To proceed, we need to get the Client White Point */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ccc
operator|->
name|clientWhitePt
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|clientWhitePt
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clientWhitePt
operator|.
name|format
operator|==
name|XcmsUndefinedFormat
condition|)
block|{
comment|/* 	     * Client White Point is undefined, therefore set to the Screen 	     *   White Point. 	     * Since Client White Point == Screen White Point, WhiteAdjustProc 	     *   is not called. 	     */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|screenWhitePt
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|clientWhitePt
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccc
operator|->
name|whitePtAdjProc
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|_XcmsEqualWhitePts
argument_list|(
name|ccc
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 	     * Client White Point != Screen White Point, and WhiteAdjustProc 	     *   is not NULL, therefore, will need to call it when 	     *   converting between DI and DD specifications. 	     */
name|callWhiteAdjustProc
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * Make copy of array of color specifications      */
if|if
condition|(
name|nColors
operator|>
literal|1
condition|)
block|{
name|pColors_tmp
operator|=
operator|(
name|XcmsColor
operator|*
operator|)
name|Xmalloc
argument_list|(
name|nColors
operator|*
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pColors_tmp
operator|=
operator|&
name|Color1
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pColors_in_out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pColors_tmp
argument_list|,
name|nColors
operator|*
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * zero out pCompressed      */
if|if
condition|(
name|pCompressed
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pCompressed
argument_list|,
name|nColors
operator|*
sizeof|sizeof
argument_list|(
name|Bool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|contents_flag
operator|==
name|DD_FORMAT
operator|||
name|contents_flag
operator|==
name|DI_FORMAT
condition|)
block|{
comment|/* 	 * ENTIRE ARRAY IS IN ONE FORMAT. 	 */
if|if
condition|(
name|XCMS_DI_ID
argument_list|(
name|format
argument_list|)
operator|&&
name|XCMS_DI_ID
argument_list|(
name|targetFormat
argument_list|)
condition|)
block|{
comment|/* 	     * DI-to-DI only conversion 	     */
name|retval
operator|=
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|nColors
argument_list|,
name|targetFormat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XCMS_DD_ID
argument_list|(
name|format
argument_list|)
operator|&&
name|XCMS_DD_ID
argument_list|(
name|targetFormat
argument_list|)
condition|)
block|{
comment|/* 	     * DD-to-DD only conversion 	     *   Since DD->DD there will be no compressed thus we can 	     *   pass NULL instead of pCompressed. 	     */
name|retval
operator|=
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
name|nColors
argument_list|,
name|targetFormat
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Otherwise we have: 	     *    1. Device-Independent to Device-Dependent Conversion 	     *		OR 	     *    2. Device-Dependent to Device-Independent Conversion 	     * 	     *  We need to go from oldFormat -> CIEXYZ -> targetFormat 	     *	adjusting for white points as necessary. 	     */
if|if
condition|(
name|XCMS_DI_ID
argument_list|(
name|format
argument_list|)
condition|)
block|{
comment|/* 		 *    1. Device-Independent to Device-Dependent Conversion 		 */
if|if
condition|(
name|callWhiteAdjustProc
condition|)
block|{
comment|/* 		     * White Point Adjustment 		     *		Client White Point to Screen White Point 		     */
name|retval
operator|=
call|(
modifier|*
name|ccc
operator|->
name|whitePtAdjProc
call|)
argument_list|(
name|ccc
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|,
name|targetFormat
argument_list|,
name|pColors_tmp
argument_list|,
name|nColors
argument_list|,
name|pCompressed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|nColors
argument_list|,
name|XcmsCIEXYZFormat
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|Failure
goto|;
block|}
name|retval
operator|=
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
name|nColors
argument_list|,
name|targetFormat
argument_list|,
name|pCompressed
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 *    2. Device-Dependent to Device-Independent Conversion 		 */
if|if
condition|(
name|callWhiteAdjustProc
condition|)
block|{
comment|/* 		     * White Point Adjustment 		     *		Screen White Point to Client White Point 		     */
name|retval
operator|=
call|(
modifier|*
name|ccc
operator|->
name|whitePtAdjProc
call|)
argument_list|(
name|ccc
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|targetFormat
argument_list|,
name|pColors_tmp
argument_list|,
name|nColors
argument_list|,
name|pCompressed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * Since DD->CIEXYZ, no compression takes place therefore 		     * we can pass NULL instead of pCompressed. 		     */
if|if
condition|(
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
name|nColors
argument_list|,
name|XcmsCIEXYZFormat
argument_list|,
operator|(
name|Bool
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|Failure
goto|;
block|}
name|retval
operator|=
name|_XcmsDIConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|nColors
argument_list|,
name|targetFormat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 	 * ARRAY HAS MIXED FORMATS. 	 */
if|if
condition|(
operator|(
name|contents_flag
operator|==
operator|(
name|DI_FORMAT
operator||
name|MIX_FORMAT
operator|)
operator|)
operator|&&
name|XCMS_DI_ID
argument_list|(
name|targetFormat
argument_list|)
condition|)
block|{
comment|/* 	     * Convert from DI to DI in batches of contiguous formats 	     * 	     * Because DI->DI, WhiteAdjustProc not called. 	     */
name|retval
operator|=
name|ConvertMixedColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|nColors
argument_list|,
name|targetFormat
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|DI_FORMAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|contents_flag
operator|==
operator|(
name|DD_FORMAT
operator||
name|MIX_FORMAT
operator|)
operator|)
operator|&&
name|XCMS_DD_ID
argument_list|(
name|targetFormat
argument_list|)
condition|)
block|{
comment|/* 	     * Convert from DD to DD in batches of contiguous formats 	     * 	     * Because DD->DD, WhiteAdjustProc not called. 	     */
name|retval
operator|=
name|ConvertMixedColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
operator|(
name|XcmsColor
operator|*
operator|)
name|NULL
argument_list|,
name|nColors
argument_list|,
name|targetFormat
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|DD_FORMAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XCMS_DI_ID
argument_list|(
name|targetFormat
argument_list|)
condition|)
block|{
comment|/* 	     * We need to convert from DI-to-DI and DD-to-DI, therefore 	     *   1. convert DD specifications to CIEXYZ, then 	     *   2. convert all in batches to the target DI format. 	     * 	     * Note that ConvertMixedColors will call WhiteAdjustProc 	     * as necessary. 	     */
comment|/* 	     * Convert only DD specifications in batches of contiguous formats 	     * to CIEXYZ 	     * 	     * Since DD->CIEXYZ, ConvertMixedColors will apply WhiteAdjustProc 	     * if required. 	     */
name|retval
operator|=
name|ConvertMixedColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|nColors
argument_list|,
name|XcmsCIEXYZFormat
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|DD_FORMAT
argument_list|)
expr_stmt|;
comment|/* 	     * Because at this point we may have a mix of DI formats 	     * (e.g., CIEXYZ, CIELuv) we must convert the specs to the 	     * target DI format in batches of contiguous source formats. 	     */
name|retval
operator|=
name|ConvertMixedColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|nColors
argument_list|,
name|targetFormat
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|DI_FORMAT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * We need to convert from DI-to-DD and DD-to-DD, therefore 	     *   1. convert DI specifications to CIEXYZ, then 	     *   2. convert all to the DD target format. 	     * 	     *   This allows white point adjustment and gamut compression 	     *	 to be applied to all the color specifications in one 	     *   swoop if those functions do in fact modify the entire 	     *   group of color specifications. 	     */
comment|/* 	     * Convert in batches to CIEXYZ 	     * 	     * If DD->CIEXYZ, ConvertMixedColors will apply WhiteAdjustProc 	     * if required. 	     */
if|if
condition|(
operator|(
name|retval
operator|=
name|ConvertMixedColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|nColors
argument_list|,
name|XcmsCIEXYZFormat
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|DI_FORMAT
operator||
name|DD_FORMAT
argument_list|)
argument_list|)
operator|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|Failure
goto|;
block|}
comment|/* 	     * Convert all specifications (now in CIEXYZ format) to 	     * the target DD format. 	     * Since CIEXYZ->DD, compression MAY take place therefore 	     * we must pass pCompressed. 	     * Note that WhiteAdjustProc must be used if necessary. 	     */
if|if
condition|(
name|callWhiteAdjustProc
condition|)
block|{
comment|/* 		 * White Point Adjustment 		 *	Client White Point to Screen White Point 		 */
name|retval
operator|=
call|(
modifier|*
name|ccc
operator|->
name|whitePtAdjProc
call|)
argument_list|(
name|ccc
argument_list|,
operator|&
name|clientWhitePt
argument_list|,
name|ScreenWhitePointOfCCC
argument_list|(
name|ccc
argument_list|)
argument_list|,
name|targetFormat
argument_list|,
name|pColors_tmp
argument_list|,
name|nColors
argument_list|,
name|pCompressed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|_XcmsDDConvertColors
argument_list|(
name|ccc
argument_list|,
name|pColors_tmp
argument_list|,
name|nColors
argument_list|,
name|targetFormat
argument_list|,
name|pCompressed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|retval
operator|!=
name|XcmsFailure
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pColors_tmp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pColors_in_out
argument_list|,
name|nColors
operator|*
sizeof|sizeof
argument_list|(
name|XcmsColor
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nColors
operator|>
literal|1
condition|)
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pColors_tmp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
name|Failure
label|:
if|if
condition|(
name|nColors
operator|>
literal|1
condition|)
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pColors_tmp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsRegFormatOfPrefix  *  *	SYNOPSIS  */
end_comment

begin_function
name|XcmsColorFormat
name|_XcmsRegFormatOfPrefix
parameter_list|(
name|prefix
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Returns a color space ID associated with the specified  *		X Consortium registered color space prefix.  *  *	RETURNS  *		The color space ID if found;  *		otherwise NULL.  */
block|{
name|XcmsRegColorSpaceEntry
modifier|*
name|pEntry
init|=
name|_XcmsRegColorSpaces
decl_stmt|;
while|while
condition|(
name|pEntry
operator|->
name|prefix
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prefix
argument_list|,
name|pEntry
operator|->
name|prefix
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|pEntry
operator|->
name|id
operator|)
return|;
block|}
name|pEntry
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|XcmsUndefinedFormat
operator|)
return|;
block|}
end_function

end_unit

