begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XcmsLRGB.c,v 1.22 92/01/02 19:28:13 rws Exp $" */
end_comment

begin_comment
comment|/*  * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.  * 	All Rights Reserved  *   * This file is a component of an X Window System-specific implementation  * of Xcms based on the TekColor Color Management System.  Permission is  * hereby granted to use, copy, modify, sell, and otherwise distribute this  * software and its documentation for any purpose and without fee, provided  * that this copyright, permission, and disclaimer notice is reproduced in  * all copies of this software and in supporting documentation.  TekColor  * is a trademark of Tektronix, Inc.  *   * Tektronix makes no representation about the suitability of this software  * for any purpose.  It is provided "as is" and with all faults.  *   * TEKTRONIX DISCLAIMS ALL WARRANTIES APPLICABLE TO THIS SOFTWARE,  * INCLUDING THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL TEKTRONIX BE LIABLE FOR ANY  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER  * RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER IN AN ACTION OF  * CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR THE PERFORMANCE OF THIS SOFTWARE.  *  *  *	NAME  *		XcmsLRGB.c  *  *	DESCRIPTION  *		This file contains the conversion routines:  *		    1. CIE XYZ to RGB intensity  *		    2. RGB intensity to device RGB  *		    3. device RGB to RGB intensity  *		    4. RGB intensity to CIE XYZ  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xatom.h>
end_include

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xcmsint.h"
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_define
define|#
directive|define
name|Const
value|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Const
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *      EXTERNS  *              External declarations required locally to this package  *              that are not already declared in any of the included header  *		files (external includes or internal includes).  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|XcmsRGB_prefix
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|XcmsRGBi_prefix
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|unsigned
name|long
name|_XcmsGetElement
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_XcmsFreeIntensityMaps
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *      LOCAL DEFINES  *		#define declarations local to this package.  */
end_comment

begin_define
define|#
directive|define
name|EPS
value|0.001
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (y) : (x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MIN */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN3
end_ifndef

begin_define
define|#
directive|define
name|MIN3
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(MIN(x, MIN(y, z)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MIN3 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX3
end_ifndef

begin_define
define|#
directive|define
name|MAX3
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(MAX(x, MAX(y, z)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAX3 */
end_comment

begin_comment
comment|/*  *      LOCAL TYPEDEFS  *              typedefs local to this package (for use with local vars).  *  */
end_comment

begin_comment
comment|/*  *      FORWARD DECLARATIONS  */
end_comment

begin_function_decl
specifier|static
name|void
name|LINEAR_RGB_FreeSCCData
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LINEAR_RGB_InitSCCData
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|XcmsLRGB_RGB_ParseString
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|XcmsLRGB_RGBi_ParseString
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Status
name|_XcmsGetTableType0
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Status
name|_XcmsGetTableType1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *      LOCALS VARIABLES  *		Variables local to this package.  *		    Usage example:  *		        static int	ExampleLocalVar;  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|Const
name|MASK
index|[
literal|17
index|]
init|=
block|{
literal|0x0000
block|,
comment|/*  0 bitsPerRGB */
literal|0x8000
block|,
comment|/*  1 bitsPerRGB */
literal|0xc000
block|,
comment|/*  2 bitsPerRGB */
literal|0xe000
block|,
comment|/*  3 bitsPerRGB */
literal|0xf000
block|,
comment|/*  4 bitsPerRGB */
literal|0xf800
block|,
comment|/*  5 bitsPerRGB */
literal|0xfc00
block|,
comment|/*  6 bitsPerRGB */
literal|0xfe00
block|,
comment|/*  7 bitsPerRGB */
literal|0xff00
block|,
comment|/*  8 bitsPerRGB */
literal|0xff80
block|,
comment|/*  9 bitsPerRGB */
literal|0xffc0
block|,
comment|/* 10 bitsPerRGB */
literal|0xffe0
block|,
comment|/* 11 bitsPerRGB */
literal|0xfff0
block|,
comment|/* 12 bitsPerRGB */
literal|0xfff8
block|,
comment|/* 13 bitsPerRGB */
literal|0xfffc
block|,
comment|/* 14 bitsPerRGB */
literal|0xfffe
block|,
comment|/* 15 bitsPerRGB */
literal|0xffff
comment|/* 16 bitsPerRGB */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * A NULL terminated array of function pointers that when applied      * in series will convert an XcmsColor structure from XcmsRGBFormat      * to XcmsCIEXYZFormat.      */
end_comment

begin_decl_stmt
specifier|static
name|XcmsConversionProc
name|Fl_RGB_to_CIEXYZ
index|[]
init|=
block|{
name|XcmsRGBToRGBi
block|,
name|XcmsRGBiToCIEXYZ
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * A NULL terminated array of function pointers that when applied      * in series will convert an XcmsColor structure from XcmsCIEXYZFormat      * to XcmsRGBFormat.      */
end_comment

begin_decl_stmt
specifier|static
name|XcmsConversionProc
name|Fl_CIEXYZ_to_RGB
index|[]
init|=
block|{
name|XcmsCIEXYZToRGBi
block|,
name|XcmsRGBiToRGB
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * A NULL terminated array of function pointers that when applied      * in series will convert an XcmsColor structure from XcmsRGBiFormat      * to XcmsCIEXYZFormat.      */
end_comment

begin_decl_stmt
specifier|static
name|XcmsConversionProc
name|Fl_RGBi_to_CIEXYZ
index|[]
init|=
block|{
name|XcmsRGBiToCIEXYZ
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * A NULL terminated array of function pointers that when applied      * in series will convert an XcmsColor structure from XcmsCIEXYZFormat      * to XcmsRGBiFormat.      */
end_comment

begin_decl_stmt
specifier|static
name|XcmsConversionProc
name|Fl_CIEXYZ_to_RGBi
index|[]
init|=
block|{
name|XcmsCIEXYZToRGBi
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * RGBi Color Spaces      */
end_comment

begin_decl_stmt
name|XcmsColorSpace
name|XcmsRGBiColorSpace
init|=
block|{
name|XcmsRGBi_prefix
block|,
comment|/* prefix */
name|XcmsRGBiFormat
block|,
comment|/* id */
name|XcmsLRGB_RGBi_ParseString
block|,
comment|/* parseString */
name|Fl_RGBi_to_CIEXYZ
block|,
comment|/* to_CIEXYZ */
name|Fl_CIEXYZ_to_RGBi
block|,
comment|/* from_CIEXYZ */
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * RGB Color Spaces      */
end_comment

begin_decl_stmt
name|XcmsColorSpace
name|XcmsRGBColorSpace
init|=
block|{
name|XcmsRGB_prefix
block|,
comment|/* prefix */
name|XcmsRGBFormat
block|,
comment|/* id */
name|XcmsLRGB_RGB_ParseString
block|,
comment|/* parseString */
name|Fl_RGB_to_CIEXYZ
block|,
comment|/* to_CIEXYZ */
name|Fl_CIEXYZ_to_RGB
block|,
comment|/* from_CIEXYZ */
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      * Device-Independent Color Spaces known to the       * LINEAR_RGB Screen Color Characteristics Function Set.      */
end_comment

begin_decl_stmt
specifier|static
name|XcmsColorSpace
modifier|*
name|DDColorSpaces
index|[]
init|=
block|{
operator|&
name|XcmsRGBColorSpace
block|,
operator|&
name|XcmsRGBiColorSpace
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      GLOBALS  *              Variables declared in this package that are allowed  *		to be used globally.  */
end_comment

begin_comment
comment|/*      * LINEAR_RGB Screen Color Characteristics Function Set.      */
end_comment

begin_decl_stmt
name|XcmsFunctionSet
name|XcmsLinearRGBFunctionSet
init|=
block|{
operator|&
name|DDColorSpaces
index|[
literal|0
index|]
block|,
comment|/* pDDColorSpaces */
name|LINEAR_RGB_InitSCCData
block|,
comment|/* pInitScrnFunc */
name|LINEAR_RGB_FreeSCCData
comment|/* pFreeSCCData */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	DESCRIPTION  *		Contents of Default SCCData should be replaced if other  *		data should be used as default.  *  *  */
end_comment

begin_comment
comment|/*  * NAME		Tektronix 19" (Sony) CRT  * PART_NUMBER		119-2451-00  * MODEL		Tek4300, Tek4800  */
end_comment

begin_decl_stmt
specifier|static
name|IntensityRec
name|Const
name|Default_RGB_RedTuples
index|[]
init|=
block|{
comment|/* {unsigned short value, XcmsFloat intensity} */
literal|0x0000
block|,
literal|0.000000
block|,
literal|0x0909
block|,
literal|0.000000
block|,
literal|0x0a0a
block|,
literal|0.000936
block|,
literal|0x0f0f
block|,
literal|0.001481
block|,
literal|0x1414
block|,
literal|0.002329
block|,
literal|0x1919
block|,
literal|0.003529
block|,
literal|0x1e1e
block|,
literal|0.005127
block|,
literal|0x2323
block|,
literal|0.007169
block|,
literal|0x2828
block|,
literal|0.009699
block|,
literal|0x2d2d
block|,
literal|0.012759
block|,
literal|0x3232
block|,
literal|0.016392
block|,
literal|0x3737
block|,
literal|0.020637
block|,
literal|0x3c3c
block|,
literal|0.025533
block|,
literal|0x4141
block|,
literal|0.031119
block|,
literal|0x4646
block|,
literal|0.037431
block|,
literal|0x4b4b
block|,
literal|0.044504
block|,
literal|0x5050
block|,
literal|0.052373
block|,
literal|0x5555
block|,
literal|0.061069
block|,
literal|0x5a5a
block|,
literal|0.070624
block|,
literal|0x5f5f
block|,
literal|0.081070
block|,
literal|0x6464
block|,
literal|0.092433
block|,
literal|0x6969
block|,
literal|0.104744
block|,
literal|0x6e6e
block|,
literal|0.118026
block|,
literal|0x7373
block|,
literal|0.132307
block|,
literal|0x7878
block|,
literal|0.147610
block|,
literal|0x7d7d
block|,
literal|0.163958
block|,
literal|0x8282
block|,
literal|0.181371
block|,
literal|0x8787
block|,
literal|0.199871
block|,
literal|0x8c8c
block|,
literal|0.219475
block|,
literal|0x9191
block|,
literal|0.240202
block|,
literal|0x9696
block|,
literal|0.262069
block|,
literal|0x9b9b
block|,
literal|0.285089
block|,
literal|0xa0a0
block|,
literal|0.309278
block|,
literal|0xa5a5
block|,
literal|0.334647
block|,
literal|0xaaaa
block|,
literal|0.361208
block|,
literal|0xafaf
block|,
literal|0.388971
block|,
literal|0xb4b4
block|,
literal|0.417945
block|,
literal|0xb9b9
block|,
literal|0.448138
block|,
literal|0xbebe
block|,
literal|0.479555
block|,
literal|0xc3c3
block|,
literal|0.512202
block|,
literal|0xc8c8
block|,
literal|0.546082
block|,
literal|0xcdcd
block|,
literal|0.581199
block|,
literal|0xd2d2
block|,
literal|0.617552
block|,
literal|0xd7d7
block|,
literal|0.655144
block|,
literal|0xdcdc
block|,
literal|0.693971
block|,
literal|0xe1e1
block|,
literal|0.734031
block|,
literal|0xe6e6
block|,
literal|0.775322
block|,
literal|0xebeb
block|,
literal|0.817837
block|,
literal|0xf0f0
block|,
literal|0.861571
block|,
literal|0xf5f5
block|,
literal|0.906515
block|,
literal|0xfafa
block|,
literal|0.952662
block|,
literal|0xffff
block|,
literal|1.000000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IntensityRec
name|Const
name|Default_RGB_GreenTuples
index|[]
init|=
block|{
comment|/* {unsigned short value, XcmsFloat intensity} */
literal|0x0000
block|,
literal|0.000000
block|,
literal|0x1313
block|,
literal|0.000000
block|,
literal|0x1414
block|,
literal|0.000832
block|,
literal|0x1919
block|,
literal|0.001998
block|,
literal|0x1e1e
block|,
literal|0.003612
block|,
literal|0x2323
block|,
literal|0.005736
block|,
literal|0x2828
block|,
literal|0.008428
block|,
literal|0x2d2d
block|,
literal|0.011745
block|,
literal|0x3232
block|,
literal|0.015740
block|,
literal|0x3737
block|,
literal|0.020463
block|,
literal|0x3c3c
block|,
literal|0.025960
block|,
literal|0x4141
block|,
literal|0.032275
block|,
literal|0x4646
block|,
literal|0.039449
block|,
literal|0x4b4b
block|,
literal|0.047519
block|,
literal|0x5050
block|,
literal|0.056520
block|,
literal|0x5555
block|,
literal|0.066484
block|,
literal|0x5a5a
block|,
literal|0.077439
block|,
literal|0x5f5f
block|,
literal|0.089409
block|,
literal|0x6464
block|,
literal|0.102418
block|,
literal|0x6969
block|,
literal|0.116485
block|,
literal|0x6e6e
block|,
literal|0.131625
block|,
literal|0x7373
block|,
literal|0.147853
block|,
literal|0x7878
block|,
literal|0.165176
block|,
literal|0x7d7d
block|,
literal|0.183604
block|,
literal|0x8282
block|,
literal|0.203140
block|,
literal|0x8787
block|,
literal|0.223783
block|,
literal|0x8c8c
block|,
literal|0.245533
block|,
literal|0x9191
block|,
literal|0.268384
block|,
literal|0x9696
block|,
literal|0.292327
block|,
literal|0x9b9b
block|,
literal|0.317351
block|,
literal|0xa0a0
block|,
literal|0.343441
block|,
literal|0xa5a5
block|,
literal|0.370580
block|,
literal|0xaaaa
block|,
literal|0.398747
block|,
literal|0xafaf
block|,
literal|0.427919
block|,
literal|0xb4b4
block|,
literal|0.458068
block|,
literal|0xb9b9
block|,
literal|0.489165
block|,
literal|0xbebe
block|,
literal|0.521176
block|,
literal|0xc3c3
block|,
literal|0.554067
block|,
literal|0xc8c8
block|,
literal|0.587797
block|,
literal|0xcdcd
block|,
literal|0.622324
block|,
literal|0xd2d2
block|,
literal|0.657604
block|,
literal|0xd7d7
block|,
literal|0.693588
block|,
literal|0xdcdc
block|,
literal|0.730225
block|,
literal|0xe1e1
block|,
literal|0.767459
block|,
literal|0xe6e6
block|,
literal|0.805235
block|,
literal|0xebeb
block|,
literal|0.843491
block|,
literal|0xf0f0
block|,
literal|0.882164
block|,
literal|0xf5f5
block|,
literal|0.921187
block|,
literal|0xfafa
block|,
literal|0.960490
block|,
literal|0xffff
block|,
literal|1.000000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IntensityRec
name|Const
name|Default_RGB_BlueTuples
index|[]
init|=
block|{
comment|/* {unsigned short value, XcmsFloat intensity} */
literal|0x0000
block|,
literal|0.000000
block|,
literal|0x0e0e
block|,
literal|0.000000
block|,
literal|0x0f0f
block|,
literal|0.001341
block|,
literal|0x1414
block|,
literal|0.002080
block|,
literal|0x1919
block|,
literal|0.003188
block|,
literal|0x1e1e
block|,
literal|0.004729
block|,
literal|0x2323
block|,
literal|0.006766
block|,
literal|0x2828
block|,
literal|0.009357
block|,
literal|0x2d2d
block|,
literal|0.012559
block|,
literal|0x3232
block|,
literal|0.016424
block|,
literal|0x3737
block|,
literal|0.021004
block|,
literal|0x3c3c
block|,
literal|0.026344
block|,
literal|0x4141
block|,
literal|0.032489
block|,
literal|0x4646
block|,
literal|0.039481
block|,
literal|0x4b4b
block|,
literal|0.047357
block|,
literal|0x5050
block|,
literal|0.056154
block|,
literal|0x5555
block|,
literal|0.065903
block|,
literal|0x5a5a
block|,
literal|0.076634
block|,
literal|0x5f5f
block|,
literal|0.088373
block|,
literal|0x6464
block|,
literal|0.101145
block|,
literal|0x6969
block|,
literal|0.114968
block|,
literal|0x6e6e
block|,
literal|0.129862
block|,
literal|0x7373
block|,
literal|0.145841
block|,
literal|0x7878
block|,
literal|0.162915
block|,
literal|0x7d7d
block|,
literal|0.181095
block|,
literal|0x8282
block|,
literal|0.200386
block|,
literal|0x8787
block|,
literal|0.220791
block|,
literal|0x8c8c
block|,
literal|0.242309
block|,
literal|0x9191
block|,
literal|0.264937
block|,
literal|0x9696
block|,
literal|0.288670
block|,
literal|0x9b9b
block|,
literal|0.313499
block|,
literal|0xa0a0
block|,
literal|0.339410
block|,
literal|0xa5a5
block|,
literal|0.366390
block|,
literal|0xaaaa
block|,
literal|0.394421
block|,
literal|0xafaf
block|,
literal|0.423481
block|,
literal|0xb4b4
block|,
literal|0.453547
block|,
literal|0xb9b9
block|,
literal|0.484592
block|,
literal|0xbebe
block|,
literal|0.516587
block|,
literal|0xc3c3
block|,
literal|0.549498
block|,
literal|0xc8c8
block|,
literal|0.583291
block|,
literal|0xcdcd
block|,
literal|0.617925
block|,
literal|0xd2d2
block|,
literal|0.653361
block|,
literal|0xd7d7
block|,
literal|0.689553
block|,
literal|0xdcdc
block|,
literal|0.726454
block|,
literal|0xe1e1
block|,
literal|0.764013
block|,
literal|0xe6e6
block|,
literal|0.802178
block|,
literal|0xebeb
block|,
literal|0.840891
block|,
literal|0xf0f0
block|,
literal|0.880093
block|,
literal|0xf5f5
block|,
literal|0.919723
block|,
literal|0xfafa
block|,
literal|0.959715
block|,
literal|0xffff
block|,
literal|1.00000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IntensityTbl
name|Default_RGB_RedTbl
init|=
block|{
comment|/* IntensityRec *pBase */
operator|(
name|IntensityRec
operator|*
operator|)
name|Default_RGB_RedTuples
block|,
comment|/* unsigned int nEntries */
literal|52
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IntensityTbl
name|Default_RGB_GreenTbl
init|=
block|{
comment|/* IntensityRec *pBase */
operator|(
name|IntensityRec
operator|*
operator|)
name|Default_RGB_GreenTuples
block|,
comment|/* unsigned int nEntries */
literal|50
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IntensityTbl
name|Default_RGB_BlueTbl
init|=
block|{
comment|/* IntensityRec *pBase */
operator|(
name|IntensityRec
operator|*
operator|)
name|Default_RGB_BlueTuples
block|,
comment|/* unsigned int nEntries */
literal|51
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LINEAR_RGB_SCCData
name|Default_RGB_SCCData
init|=
block|{
comment|/* XcmsFloat XYZtoRGBmatrix[3][3] */
literal|3.48340481253539000
block|,
operator|-
literal|1.52176374927285200
block|,
operator|-
literal|0.55923133354049780
block|,
operator|-
literal|1.07152751306193600
block|,
literal|1.96593795204372400
block|,
literal|0.03673691339553462
block|,
literal|0.06351179790497788
block|,
operator|-
literal|0.20020501000496480
block|,
literal|0.81070942031648220
block|,
comment|/* XcmsFloat RGBtoXYZmatrix[3][3] */
literal|0.38106149108714790
block|,
literal|0.32025712365352110
block|,
literal|0.24834578525933100
block|,
literal|0.20729745115140850
block|,
literal|0.68054638776373240
block|,
literal|0.11215616108485920
block|,
literal|0.02133944350088028
block|,
literal|0.14297193020246480
block|,
literal|1.24172892629665500
block|,
comment|/* IntensityTbl *pRedTbl */
operator|&
name|Default_RGB_RedTbl
block|,
comment|/* IntensityTbl *pGreenTbl */
operator|&
name|Default_RGB_GreenTbl
block|,
comment|/* IntensityTbl *pBlueTbl */
operator|&
name|Default_RGB_BlueTbl
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			PRIVATE ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		LINEAR_RGB_InitSCCData()  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|Status
name|LINEAR_RGB_InitSCCData
parameter_list|(
name|dpy
parameter_list|,
name|screenNumber
parameter_list|,
name|pPerScrnInfo
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|int
name|screenNumber
decl_stmt|;
name|XcmsPerScrnInfo
modifier|*
name|pPerScrnInfo
decl_stmt|;
comment|/*  *	DESCRIPTION  *  *	RETURNS  *		XcmsFailure if failed.  *		XcmsSuccess if succeeded.  *  */
block|{
name|Atom
name|CorrectAtom
init|=
name|XInternAtom
argument_list|(
name|dpy
argument_list|,
name|XDCCC_CORRECT_ATOM_NAME
argument_list|,
name|True
argument_list|)
decl_stmt|;
name|Atom
name|MatrixAtom
init|=
name|XInternAtom
argument_list|(
name|dpy
argument_list|,
name|XDCCC_MATRIX_ATOM_NAME
argument_list|,
name|True
argument_list|)
decl_stmt|;
name|int
name|format_return
decl_stmt|,
name|count
decl_stmt|,
name|cType
decl_stmt|,
name|nTables
decl_stmt|;
name|unsigned
name|long
name|nitems
decl_stmt|,
name|nbytes_return
decl_stmt|;
name|char
modifier|*
name|property_return
decl_stmt|,
modifier|*
name|pChar
decl_stmt|;
name|XcmsFloat
modifier|*
name|pValue
decl_stmt|;
ifdef|#
directive|ifdef
name|ALLDEBUG
name|IntensityRec
modifier|*
name|pIRec
decl_stmt|;
endif|#
directive|endif
comment|/* ALLDEBUG */
name|VisualID
name|visualID
decl_stmt|;
name|LINEAR_RGB_SCCData
modifier|*
name|pScreenData
decl_stmt|,
modifier|*
name|pScreenDefaultData
decl_stmt|;
name|XcmsIntensityMap
modifier|*
name|pNewMap
decl_stmt|;
comment|/*      * Allocate memory for pScreenData      */
if|if
condition|(
operator|!
operator|(
name|pScreenData
operator|=
name|pScreenDefaultData
operator|=
operator|(
name|LINEAR_RGB_SCCData
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|LINEAR_RGB_SCCData
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*       *  1. Get the XYZ->RGB and RGB->XYZ matrices      */
if|if
condition|(
name|MatrixAtom
operator|==
name|None
operator|||
operator|!
name|_XcmsGetProperty
argument_list|(
name|dpy
argument_list|,
name|RootWindow
argument_list|(
name|dpy
argument_list|,
name|screenNumber
argument_list|)
argument_list|,
name|MatrixAtom
argument_list|,
operator|&
name|format_return
argument_list|,
operator|&
name|nitems
argument_list|,
operator|&
name|nbytes_return
argument_list|,
operator|&
name|property_return
argument_list|)
operator|||
name|nitems
operator|!=
literal|18
operator|||
name|format_return
operator|!=
literal|32
condition|)
block|{
comment|/* 	 * As per the XDCCC, there must be 18 data items and each must be 	 * in 32 bits ! 	 */
goto|goto
name|FreeSCCData
goto|;
block|}
else|else
block|{
comment|/* 	 * RGBtoXYZ and XYZtoRGB matrices 	 */
name|pValue
operator|=
operator|(
name|XcmsFloat
operator|*
operator|)
name|pScreenData
expr_stmt|;
name|pChar
operator|=
name|property_return
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|18
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|pValue
operator|++
operator|=
operator|(
name|long
operator|)
name|_XcmsGetElement
argument_list|(
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
operator|/
operator|(
name|XcmsFloat
operator|)
name|XDCCC_NUMBER
expr_stmt|;
block|}
name|XFree
argument_list|(
name|property_return
argument_list|)
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|X
operator|=
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|=
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Z
operator|=
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|+
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * Compute the Screen White Point 	 */
if|if
condition|(
operator|(
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|<
operator|(
literal|1.0
operator|-
name|EPS
operator|)
operator|)
operator|||
operator|(
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|>
operator|(
literal|1.0
operator|+
name|EPS
operator|)
operator|)
condition|)
block|{
goto|goto
name|FreeSCCData
goto|;
block|}
else|else
block|{
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|=
literal|1.0
expr_stmt|;
block|}
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|format
operator|=
name|XcmsCIEXYZFormat
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|pixel
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PDEBUG
name|printf
argument_list|(
literal|"RGB to XYZ Matrix values:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       %f %f %f\n       %f %f %f\n       %f %f %f\n"
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pScreenData
operator|->
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"XYZ to RGB Matrix values:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       %f %f %f\n       %f %f %f\n       %f %f %f\n"
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|2
index|]
index|[
literal|0
index|]
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|2
index|]
index|[
literal|1
index|]
argument_list|,
name|pScreenData
operator|->
name|XYZtoRGBmatrix
index|[
literal|2
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Screen White Pt value: %f %f %f\n"
argument_list|,
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|X
argument_list|,
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
argument_list|,
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PDEBUG */
block|}
comment|/*      *	2. Get the Intensity Profile      */
if|if
condition|(
name|CorrectAtom
operator|==
name|None
operator|||
operator|!
name|_XcmsGetProperty
argument_list|(
name|dpy
argument_list|,
name|RootWindow
argument_list|(
name|dpy
argument_list|,
name|screenNumber
argument_list|)
argument_list|,
name|CorrectAtom
argument_list|,
operator|&
name|format_return
argument_list|,
operator|&
name|nitems
argument_list|,
operator|&
name|nbytes_return
argument_list|,
operator|&
name|property_return
argument_list|)
condition|)
block|{
name|XFree
argument_list|(
name|property_return
argument_list|)
expr_stmt|;
goto|goto
name|FreeSCCData
goto|;
block|}
name|pChar
operator|=
name|property_return
expr_stmt|;
while|while
condition|(
name|nitems
condition|)
block|{
switch|switch
condition|(
name|format_return
condition|)
block|{
case|case
literal|8
case|:
comment|/* 	     * Must have at least: 	     *		VisualID0 	     *		VisualID1 	     *		VisualID2 	     *		VisualID3 	     *		type 	     *		count 	     *		length 	     *		intensity1 	     *		intensity2 	     */
if|if
condition|(
name|nitems
operator|<
literal|9
condition|)
block|{
name|XFree
argument_list|(
name|property_return
argument_list|)
expr_stmt|;
goto|goto
name|FreeSCCData
goto|;
block|}
name|count
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* 	     * Must have at least: 	     *		VisualID0 	     *		VisualID3 	     *		type 	     *		count 	     *		length 	     *		intensity1 	     *		intensity2 	     */
if|if
condition|(
name|nitems
operator|<
literal|7
condition|)
block|{
name|XFree
argument_list|(
name|property_return
argument_list|)
expr_stmt|;
goto|goto
name|FreeSCCData
goto|;
block|}
name|count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|32
case|:
comment|/* 	     * Must have at least: 	     *		VisualID0 	     *		type 	     *		count 	     *		length 	     *		intensity1 	     *		intensity2 	     */
if|if
condition|(
name|nitems
operator|<
literal|6
condition|)
block|{
name|XFree
argument_list|(
name|property_return
argument_list|)
expr_stmt|;
goto|goto
name|FreeSCCData
goto|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|XFree
argument_list|(
name|property_return
argument_list|)
expr_stmt|;
goto|goto
name|FreeSCCData
goto|;
block|}
comment|/* 	 * Get VisualID 	 */
name|visualID
operator|=
name|_XcmsGetElement
argument_list|(
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|visualID
operator|=
name|visualID
operator|<<
name|format_return
expr_stmt|;
name|visualID
operator||=
name|_XcmsGetElement
argument_list|(
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|visualID
operator|==
literal|0
condition|)
block|{
comment|/* 	     * This is a shared intensity table 	     */
name|pScreenData
operator|=
name|pScreenDefaultData
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * This is a per-Visual intensity table 	     */
if|if
condition|(
operator|!
operator|(
name|pScreenData
operator|=
operator|(
name|LINEAR_RGB_SCCData
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|LINEAR_RGB_SCCData
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/* copy matrices */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pScreenDefaultData
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pScreenData
argument_list|,
literal|18
operator|*
sizeof|sizeof
argument_list|(
name|XcmsFloat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create, initialize, and add map */
if|if
condition|(
operator|!
operator|(
name|pNewMap
operator|=
operator|(
name|XcmsIntensityMap
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsIntensityMap
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|Xfree
argument_list|(
name|pScreenData
argument_list|)
expr_stmt|;
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|pNewMap
operator|->
name|visualID
operator|=
name|visualID
expr_stmt|;
name|pNewMap
operator|->
name|screenData
operator|=
operator|(
name|XPointer
operator|)
name|pScreenData
expr_stmt|;
name|pNewMap
operator|->
name|pFreeScreenData
operator|=
name|LINEAR_RGB_FreeSCCData
expr_stmt|;
name|pNewMap
operator|->
name|pNext
operator|=
operator|(
name|XcmsIntensityMap
operator|*
operator|)
name|dpy
operator|->
name|cms
operator|.
name|perVisualIntensityMaps
expr_stmt|;
name|dpy
operator|->
name|cms
operator|.
name|perVisualIntensityMaps
operator|=
operator|(
name|XPointer
operator|)
name|pNewMap
expr_stmt|;
name|dpy
operator|->
name|free_funcs
operator|->
name|intensityMaps
operator|=
name|_XcmsFreeIntensityMaps
expr_stmt|;
block|}
name|cType
operator|=
name|_XcmsGetElement
argument_list|(
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
expr_stmt|;
name|nTables
operator|=
name|_XcmsGetElement
argument_list|(
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
expr_stmt|;
if|if
condition|(
name|cType
operator|==
literal|0
condition|)
block|{
comment|/* Red Intensity Table */
if|if
condition|(
operator|!
operator|(
name|pScreenData
operator|->
name|pRedTbl
operator|=
operator|(
name|IntensityTbl
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IntensityTbl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|FreeSCCData
goto|;
block|}
if|if
condition|(
name|_XcmsGetTableType0
argument_list|(
name|pScreenData
operator|->
name|pRedTbl
argument_list|,
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|FreeRedTbl
goto|;
block|}
if|if
condition|(
name|nTables
operator|==
literal|1
condition|)
block|{
comment|/* Green Intensity Table */
name|pScreenData
operator|->
name|pGreenTbl
operator|=
name|pScreenData
operator|->
name|pRedTbl
expr_stmt|;
comment|/* Blue Intensity Table */
name|pScreenData
operator|->
name|pBlueTbl
operator|=
name|pScreenData
operator|->
name|pRedTbl
expr_stmt|;
block|}
else|else
block|{
comment|/* Green Intensity Table */
if|if
condition|(
operator|!
operator|(
name|pScreenData
operator|->
name|pGreenTbl
operator|=
operator|(
name|IntensityTbl
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IntensityTbl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|FreeRedTblElements
goto|;
block|}
if|if
condition|(
name|_XcmsGetTableType0
argument_list|(
name|pScreenData
operator|->
name|pGreenTbl
argument_list|,
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|FreeGreenTbl
goto|;
block|}
comment|/* Blue Intensity Table */
if|if
condition|(
operator|!
operator|(
name|pScreenData
operator|->
name|pBlueTbl
operator|=
operator|(
name|IntensityTbl
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IntensityTbl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|FreeGreenTblElements
goto|;
block|}
if|if
condition|(
name|_XcmsGetTableType0
argument_list|(
name|pScreenData
operator|->
name|pBlueTbl
argument_list|,
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|FreeBlueTbl
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cType
operator|==
literal|1
condition|)
block|{
comment|/* Red Intensity Table */
if|if
condition|(
operator|!
operator|(
name|pScreenData
operator|->
name|pRedTbl
operator|=
operator|(
name|IntensityTbl
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IntensityTbl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|FreeSCCData
goto|;
block|}
if|if
condition|(
name|_XcmsGetTableType1
argument_list|(
name|pScreenData
operator|->
name|pRedTbl
argument_list|,
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|FreeRedTbl
goto|;
block|}
if|if
condition|(
name|nTables
operator|==
literal|1
condition|)
block|{
comment|/* Green Intensity Table */
name|pScreenData
operator|->
name|pGreenTbl
operator|=
name|pScreenData
operator|->
name|pRedTbl
expr_stmt|;
comment|/* Blue Intensity Table */
name|pScreenData
operator|->
name|pBlueTbl
operator|=
name|pScreenData
operator|->
name|pRedTbl
expr_stmt|;
block|}
else|else
block|{
comment|/* Green Intensity Table */
if|if
condition|(
operator|!
operator|(
name|pScreenData
operator|->
name|pGreenTbl
operator|=
operator|(
name|IntensityTbl
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IntensityTbl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|FreeRedTblElements
goto|;
block|}
if|if
condition|(
name|_XcmsGetTableType1
argument_list|(
name|pScreenData
operator|->
name|pGreenTbl
argument_list|,
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|FreeGreenTbl
goto|;
block|}
comment|/* Blue Intensity Table */
if|if
condition|(
operator|!
operator|(
name|pScreenData
operator|->
name|pBlueTbl
operator|=
operator|(
name|IntensityTbl
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IntensityTbl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|FreeBlueTblElements
goto|;
block|}
if|if
condition|(
name|_XcmsGetTableType1
argument_list|(
name|pScreenData
operator|->
name|pBlueTbl
argument_list|,
name|format_return
argument_list|,
operator|&
name|pChar
argument_list|,
operator|&
name|nitems
argument_list|)
operator|==
name|XcmsFailure
condition|)
block|{
goto|goto
name|FreeBlueTbl
goto|;
block|}
block|}
block|}
else|else
block|{
name|XFree
argument_list|(
name|property_return
argument_list|)
expr_stmt|;
goto|goto
name|FreeSCCData
goto|;
block|}
ifdef|#
directive|ifdef
name|ALLDEBUG
name|printf
argument_list|(
literal|"Intensity Table  RED    %d\n"
argument_list|,
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|nEntries
argument_list|)
expr_stmt|;
name|pIRec
operator|=
operator|(
name|IntensityRec
operator|*
operator|)
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|nEntries
condition|;
name|count
operator|++
operator|,
name|pIRec
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t0x%4x\t%f\n"
argument_list|,
name|pIRec
operator|->
name|value
argument_list|,
name|pIRec
operator|->
name|intensity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|pBase
operator|!=
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
condition|)
block|{
name|printf
argument_list|(
literal|"Intensity Table  GREEN  %d\n"
argument_list|,
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|nEntries
argument_list|)
expr_stmt|;
name|pIRec
operator|=
operator|(
name|IntensityRec
operator|*
operator|)
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|pBase
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|nEntries
condition|;
name|count
operator|++
operator|,
name|pIRec
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t0x%4x\t%f\n"
argument_list|,
name|pIRec
operator|->
name|value
argument_list|,
name|pIRec
operator|->
name|intensity
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
operator|!=
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
condition|)
block|{
name|printf
argument_list|(
literal|"Intensity Table  BLUE   %d\n"
argument_list|,
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|nEntries
argument_list|)
expr_stmt|;
name|pIRec
operator|=
operator|(
name|IntensityRec
operator|*
operator|)
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|nEntries
condition|;
name|count
operator|++
operator|,
name|pIRec
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t0x%4x\t%f\n"
argument_list|,
name|pIRec
operator|->
name|value
argument_list|,
name|pIRec
operator|->
name|intensity
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ALLDEBUG */
block|}
name|XFree
argument_list|(
name|property_return
argument_list|)
expr_stmt|;
comment|/* Free the old memory and use the new structure created. */
name|LINEAR_RGB_FreeSCCData
argument_list|(
operator|(
name|LINEAR_RGB_SCCData
operator|*
operator|)
name|pPerScrnInfo
operator|->
name|screenData
argument_list|)
expr_stmt|;
name|pPerScrnInfo
operator|->
name|functionSet
operator|=
operator|(
name|XPointer
operator|)
operator|&
name|XcmsLinearRGBFunctionSet
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenData
operator|=
operator|(
name|XPointer
operator|)
name|pScreenData
expr_stmt|;
name|pPerScrnInfo
operator|->
name|state
operator|=
name|XcmsInitSuccess
expr_stmt|;
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
name|FreeBlueTblElements
label|:
name|free
argument_list|(
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
argument_list|)
expr_stmt|;
name|FreeBlueTbl
label|:
name|free
argument_list|(
name|pScreenData
operator|->
name|pBlueTbl
argument_list|)
expr_stmt|;
name|FreeGreenTblElements
label|:
name|free
argument_list|(
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
argument_list|)
expr_stmt|;
name|FreeGreenTbl
label|:
name|free
argument_list|(
name|pScreenData
operator|->
name|pGreenTbl
argument_list|)
expr_stmt|;
name|FreeRedTblElements
label|:
name|free
argument_list|(
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
argument_list|)
expr_stmt|;
name|FreeRedTbl
label|:
name|free
argument_list|(
name|pScreenData
operator|->
name|pRedTbl
argument_list|)
expr_stmt|;
name|FreeSCCData
label|:
name|free
argument_list|(
name|pScreenData
argument_list|)
expr_stmt|;
name|pPerScrnInfo
operator|->
name|state
operator|=
name|XcmsInitNone
expr_stmt|;
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		LINEAR_RGB_FreeSCCData()  *  *	SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|LINEAR_RGB_FreeSCCData
parameter_list|(
name|pScreenDataTemp
parameter_list|)
name|XPointer
name|pScreenDataTemp
decl_stmt|;
comment|/*  *	DESCRIPTION  *  *	RETURNS  *		0 if failed.  *		1 if succeeded with no modifications.  *  */
block|{
name|LINEAR_RGB_SCCData
modifier|*
name|pScreenData
init|=
operator|(
name|LINEAR_RGB_SCCData
operator|*
operator|)
name|pScreenDataTemp
decl_stmt|;
if|if
condition|(
name|pScreenData
operator|&&
name|pScreenData
operator|!=
operator|&
name|Default_RGB_SCCData
condition|)
block|{
if|if
condition|(
name|pScreenData
operator|->
name|pRedTbl
condition|)
block|{
if|if
condition|(
name|pScreenData
operator|->
name|pGreenTbl
condition|)
block|{
if|if
condition|(
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
operator|!=
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|pBase
condition|)
block|{
if|if
condition|(
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|pBase
condition|)
block|{
name|free
argument_list|(
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|pBase
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pScreenData
operator|->
name|pGreenTbl
operator|!=
name|pScreenData
operator|->
name|pRedTbl
condition|)
block|{
name|free
argument_list|(
name|pScreenData
operator|->
name|pGreenTbl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pScreenData
operator|->
name|pBlueTbl
condition|)
block|{
if|if
condition|(
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
operator|!=
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
condition|)
block|{
if|if
condition|(
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
condition|)
block|{
name|free
argument_list|(
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pScreenData
operator|->
name|pBlueTbl
operator|!=
name|pScreenData
operator|->
name|pRedTbl
condition|)
block|{
name|free
argument_list|(
name|pScreenData
operator|->
name|pBlueTbl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
condition|)
block|{
name|free
argument_list|(
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pScreenData
operator|->
name|pRedTbl
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pScreenData
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			API PRIVATE ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		_XcmsGetTableType0  *  *	SYNOPSIS  */
end_comment

begin_function
name|Status
name|_XcmsGetTableType0
parameter_list|(
name|pTbl
parameter_list|,
name|format
parameter_list|,
name|pChar
parameter_list|,
name|pCount
parameter_list|)
name|IntensityTbl
modifier|*
name|pTbl
decl_stmt|;
name|int
name|format
decl_stmt|;
name|char
modifier|*
modifier|*
name|pChar
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pCount
decl_stmt|;
comment|/*  *	DESCRIPTION  *  *	RETURNS  *		XcmsFailure if failed.  *		XcmsSuccess if succeeded.  *  */
block|{
name|unsigned
name|int
name|nElements
decl_stmt|;
name|IntensityRec
modifier|*
name|pIRec
decl_stmt|;
name|nElements
operator|=
name|pTbl
operator|->
name|nEntries
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pIRec
operator|=
name|pTbl
operator|->
name|pBase
operator|=
operator|(
name|IntensityRec
operator|*
operator|)
name|Xcalloc
argument_list|(
name|nElements
argument_list|,
sizeof|sizeof
argument_list|(
name|IntensityRec
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|8
case|:
for|for
control|(
init|;
name|nElements
operator|--
condition|;
name|pIRec
operator|++
control|)
block|{
comment|/* 0xFFFF/0xFF = 0x101 */
name|pIRec
operator|->
name|value
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
operator|*
literal|0x101
expr_stmt|;
name|pIRec
operator|->
name|intensity
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
operator|/
operator|(
name|XcmsFloat
operator|)
literal|255.0
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
for|for
control|(
init|;
name|nElements
operator|--
condition|;
name|pIRec
operator|++
control|)
block|{
name|pIRec
operator|->
name|value
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
expr_stmt|;
name|pIRec
operator|->
name|intensity
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
operator|/
operator|(
name|XcmsFloat
operator|)
literal|65535.0
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
for|for
control|(
init|;
name|nElements
operator|--
condition|;
name|pIRec
operator|++
control|)
block|{
name|pIRec
operator|->
name|value
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
expr_stmt|;
name|pIRec
operator|->
name|intensity
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
operator|/
operator|(
name|XcmsFloat
operator|)
literal|4294967295.0
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsGetTableType1  *  *	SYNOPSIS  */
end_comment

begin_function
name|Status
name|_XcmsGetTableType1
parameter_list|(
name|pTbl
parameter_list|,
name|format
parameter_list|,
name|pChar
parameter_list|,
name|pCount
parameter_list|)
name|IntensityTbl
modifier|*
name|pTbl
decl_stmt|;
name|int
name|format
decl_stmt|;
name|char
modifier|*
modifier|*
name|pChar
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pCount
decl_stmt|;
comment|/*  *	DESCRIPTION  *  *	RETURNS  *		XcmsFailure if failed.  *		XcmsSuccess if succeeded.  *  */
block|{
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|max_index
decl_stmt|;
name|IntensityRec
modifier|*
name|pIRec
decl_stmt|;
name|max_index
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
expr_stmt|;
name|pTbl
operator|->
name|nEntries
operator|=
name|max_index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pIRec
operator|=
name|pTbl
operator|->
name|pBase
operator|=
operator|(
name|IntensityRec
operator|*
operator|)
name|Xcalloc
argument_list|(
name|max_index
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IntensityRec
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|8
case|:
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|max_index
operator|+
literal|1
condition|;
name|count
operator|++
operator|,
name|pIRec
operator|++
control|)
block|{
name|pIRec
operator|->
name|value
operator|=
operator|(
name|count
operator|*
literal|65535
operator|)
operator|/
name|max_index
expr_stmt|;
name|pIRec
operator|->
name|intensity
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
operator|/
operator|(
name|XcmsFloat
operator|)
literal|255.0
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|max_index
operator|+
literal|1
condition|;
name|count
operator|++
operator|,
name|pIRec
operator|++
control|)
block|{
name|pIRec
operator|->
name|value
operator|=
operator|(
name|count
operator|*
literal|65535
operator|)
operator|/
name|max_index
expr_stmt|;
name|pIRec
operator|->
name|intensity
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
operator|/
operator|(
name|XcmsFloat
operator|)
literal|65535.0
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|max_index
operator|+
literal|1
condition|;
name|count
operator|++
operator|,
name|pIRec
operator|++
control|)
block|{
name|pIRec
operator|->
name|value
operator|=
operator|(
name|count
operator|*
literal|65535
operator|)
operator|/
name|max_index
expr_stmt|;
name|pIRec
operator|->
name|intensity
operator|=
name|_XcmsGetElement
argument_list|(
name|format
argument_list|,
name|pChar
argument_list|,
name|pCount
argument_list|)
operator|/
operator|(
name|XcmsFloat
operator|)
literal|4294967295.0
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		ValueCmp  *  *	SYNOPSIS  */
end_comment

begin_function
name|int
name|_XcmsValueCmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|IntensityRec
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_comment
comment|/*  *	DESCRIPTION  *		Compares the value component of two IntensityRec  *		structures.  *  *	RETURNS  *		0 if p1->value is equal to p2->value  *< 0 if p1->value is less than p2->value  *> 0 if p1->value is greater than p2->value  *  */
end_comment

begin_block
block|{
return|return
operator|(
name|p1
operator|->
name|value
operator|-
name|p2
operator|->
name|value
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		IntensityCmp  *  *	SYNOPSIS  */
end_comment

begin_function
name|int
name|_XcmsIntensityCmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|IntensityRec
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_comment
comment|/*  *	DESCRIPTION  *		Compares the intensity component of two IntensityRec  *		structures.  *  *	RETURNS  *		0 if equal;  *< 0 if first precedes second  *> 0 if first succeeds second  *  */
end_comment

begin_block
block|{
if|if
condition|(
name|p1
operator|->
name|intensity
operator|<
name|p2
operator|->
name|intensity
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|intensity
operator|>
name|p2
operator|->
name|intensity
condition|)
block|{
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		ValueInterpolation  *  *	SYNOPSIS  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|_XcmsValueInterpolation
parameter_list|(
name|key
parameter_list|,
name|lo
parameter_list|,
name|hi
parameter_list|,
name|answer
parameter_list|,
name|bitsPerRGB
parameter_list|)
name|IntensityRec
modifier|*
name|key
decl_stmt|,
decl|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|,
modifier|*
name|answer
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|bitsPerRGB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	DESCRIPTION  *		Based on a given value, performs a linear interpolation  *		on the intensities between two IntensityRec structures.  *		Note that the bitsPerRGB parameter is ignored.  *  *	RETURNS  *		Returns 0 if failed; otherwise non-zero.  */
end_comment

begin_block
block|{
name|XcmsFloat
name|ratio
decl_stmt|;
name|ratio
operator|=
operator|(
operator|(
name|XcmsFloat
operator|)
name|key
operator|->
name|value
operator|-
operator|(
name|XcmsFloat
operator|)
name|lo
operator|->
name|value
operator|)
operator|/
operator|(
operator|(
name|XcmsFloat
operator|)
name|hi
operator|->
name|value
operator|-
operator|(
name|XcmsFloat
operator|)
name|lo
operator|->
name|value
operator|)
expr_stmt|;
name|answer
operator|->
name|value
operator|=
name|key
operator|->
name|value
expr_stmt|;
name|answer
operator|->
name|intensity
operator|=
operator|(
name|hi
operator|->
name|intensity
operator|-
name|lo
operator|->
name|intensity
operator|)
operator|*
name|ratio
expr_stmt|;
name|answer
operator|->
name|intensity
operator|+=
name|lo
operator|->
name|intensity
expr_stmt|;
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		IntensityInterpolation  *  *	SYNOPSIS  */
end_comment

begin_function
name|int
name|_XcmsIntensityInterpolation
parameter_list|(
name|key
parameter_list|,
name|lo
parameter_list|,
name|hi
parameter_list|,
name|answer
parameter_list|,
name|bitsPerRGB
parameter_list|)
name|IntensityRec
modifier|*
name|key
decl_stmt|,
decl|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|,
modifier|*
name|answer
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|bitsPerRGB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	DESCRIPTION  *		Based on a given intensity, performs a linear interpolation  *		on the values between two IntensityRec structures.  *		The bitsPerRGB parameter is necessary to perform rounding  *		to the correct number of significant bits.  *  *	RETURNS  *		Returns 0 if failed; otherwise non-zero.  */
end_comment

begin_block
block|{
name|XcmsFloat
name|ratio
decl_stmt|;
name|long
name|target
decl_stmt|,
name|up
decl_stmt|,
name|down
decl_stmt|;
name|int
name|shift
init|=
literal|16
operator|-
name|bitsPerRGB
decl_stmt|;
name|int
name|max_color
init|=
operator|(
literal|1
operator|<<
name|bitsPerRGB
operator|)
operator|-
literal|1
decl_stmt|;
name|ratio
operator|=
operator|(
name|key
operator|->
name|intensity
operator|-
name|lo
operator|->
name|intensity
operator|)
operator|/
operator|(
name|hi
operator|->
name|intensity
operator|-
name|lo
operator|->
name|intensity
operator|)
expr_stmt|;
name|answer
operator|->
name|intensity
operator|=
name|key
operator|->
name|intensity
expr_stmt|;
name|target
operator|=
name|hi
operator|->
name|value
operator|-
name|lo
operator|->
name|value
expr_stmt|;
name|target
operator|*=
name|ratio
expr_stmt|;
name|target
operator|+=
name|lo
operator|->
name|value
expr_stmt|;
comment|/*      * Ok now, lets find the closest in respects to bits per RGB      */
name|up
operator|=
operator|(
operator|(
name|target
operator|>>
name|shift
operator|)
operator|*
literal|0xFFFF
operator|)
operator|/
name|max_color
expr_stmt|;
if|if
condition|(
name|up
operator|<
name|target
condition|)
block|{
name|down
operator|=
name|up
expr_stmt|;
name|up
operator|=
operator|(
name|MIN
argument_list|(
operator|(
name|down
operator|>>
name|shift
operator|)
operator|+
literal|1
argument_list|,
name|max_color
argument_list|)
operator|*
literal|0xFFFF
operator|)
operator|/
name|max_color
expr_stmt|;
block|}
else|else
block|{
name|down
operator|=
operator|(
name|MAX
argument_list|(
operator|(
name|up
operator|>>
name|shift
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|*
literal|0xFFFF
operator|)
operator|/
name|max_color
expr_stmt|;
block|}
name|answer
operator|->
name|value
operator|=
operator|(
operator|(
name|up
operator|-
name|target
operator|)
operator|<
operator|(
name|target
operator|-
name|down
operator|)
condition|?
name|up
else|:
name|down
operator|)
expr_stmt|;
name|answer
operator|->
name|value
operator|&=
name|MASK
index|[
name|bitsPerRGB
index|]
expr_stmt|;
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsTableSearch  *  *	SYNOPSIS  */
end_comment

begin_decl_stmt
name|int
name|_XcmsTableSearch
argument_list|(
name|key
argument_list|,
name|bitsPerRGB
argument_list|,
name|base
argument_list|,
name|nel
argument_list|,
name|nKeyPtrSize
argument_list|,
name|compar
argument_list|,
name|interpol
argument_list|,
name|answer
argument_list|)
name|char
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bitsPerRGB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|nel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|nKeyPtrSize
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|interpol
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|answer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	DESCRIPTION  *		A binary search through the specificied table.  *  *	RETURNS  *		Returns 0 if failed; otherwise non-zero.  *  */
end_comment

begin_block
block|{
name|char
modifier|*
name|hi
decl_stmt|,
modifier|*
name|lo
decl_stmt|,
modifier|*
name|mid
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|result
decl_stmt|;
name|last
operator|=
name|hi
operator|=
name|base
operator|+
operator|(
operator|(
name|nel
operator|-
literal|1
operator|)
operator|*
name|nKeyPtrSize
operator|)
expr_stmt|;
name|mid
operator|=
name|lo
operator|=
name|base
expr_stmt|;
comment|/* use only the significants bits, then scale into 16 bits */
operator|(
operator|(
name|IntensityRec
operator|*
operator|)
name|key
operator|)
operator|->
name|value
operator|=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
operator|(
name|IntensityRec
operator|*
operator|)
name|key
operator|)
operator|->
name|value
operator|>>
operator|(
literal|16
operator|-
name|bitsPerRGB
operator|)
argument_list|)
operator|*
literal|0xFFFF
operator|)
operator|/
operator|(
operator|(
literal|1
operator|<<
name|bitsPerRGB
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Special case so that zero intensity always maps to zero value */
if|if
condition|(
call|(
modifier|*
name|compar
call|)
argument_list|(
name|key
argument_list|,
name|lo
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|lo
argument_list|,
name|answer
argument_list|,
name|nKeyPtrSize
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IntensityRec
operator|*
operator|)
name|answer
operator|)
operator|->
name|value
operator|&=
name|MASK
index|[
name|bitsPerRGB
index|]
expr_stmt|;
return|return
name|XcmsSuccess
return|;
block|}
while|while
condition|(
name|mid
operator|!=
name|last
condition|)
block|{
name|last
operator|=
name|mid
expr_stmt|;
name|mid
operator|=
name|lo
operator|+
operator|(
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|hi
operator|-
name|lo
argument_list|)
operator|/
name|nKeyPtrSize
operator|)
operator|/
literal|2
operator|)
operator|*
name|nKeyPtrSize
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|compar
call|)
argument_list|(
name|key
argument_list|,
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|mid
argument_list|,
name|answer
argument_list|,
name|nKeyPtrSize
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IntensityRec
operator|*
operator|)
name|answer
operator|)
operator|->
name|value
operator|&=
name|MASK
index|[
name|bitsPerRGB
index|]
expr_stmt|;
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|hi
operator|=
name|mid
expr_stmt|;
block|}
else|else
block|{
name|lo
operator|=
name|mid
expr_stmt|;
block|}
block|}
comment|/*      * If we got to here, we didn't find a solution, so we      * need to apply interpolation.      */
return|return
operator|(
call|(
modifier|*
name|interpol
call|)
argument_list|(
name|key
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|answer
argument_list|,
name|bitsPerRGB
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *      NAME  *		_XcmsMatVec - multiply a 3 x 3 by a 3 x 1 vector  *  *	SYNOPSIS  */
end_comment

begin_function
name|void
name|_XcmsMatVec
parameter_list|(
name|pMat
parameter_list|,
name|pIn
parameter_list|,
name|pOut
parameter_list|)
name|XcmsFloat
modifier|*
name|pMat
decl_stmt|,
decl|*
name|pIn
decl_stmt|,
modifier|*
name|pOut
decl_stmt|;
end_function

begin_comment
comment|/*  *      DESCRIPTION  *		Multiply the passed vector by the passed matrix to return a   *		vector. Matrix is 3x3, vectors are of length 3.  *  *	RETURNS  *		void  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|pOut
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|pOut
index|[
name|i
index|]
operator|+=
operator|*
operator|(
name|pMat
operator|+
operator|(
name|i
operator|*
literal|3
operator|)
operator|+
name|j
operator|)
operator|*
name|pIn
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/************************************************************************  *									*  *			 PUBLIC ROUTINES				*  *									*  ************************************************************************/
end_comment

begin_comment
comment|/*  *	NAME  *		XcmsLRGB_RGB_ParseString  *  *	SYNOPSIS  */
end_comment

begin_function
name|int
name|XcmsLRGB_RGB_ParseString
parameter_list|(
name|spec
parameter_list|,
name|pColor
parameter_list|)
specifier|register
name|char
modifier|*
name|spec
decl_stmt|;
name|XcmsColor
modifier|*
name|pColor
decl_stmt|;
comment|/*  *	DESCRIPTION  *		This routines takes a string and attempts to convert  *		it into a XcmsColor structure with XcmsRGBFormat.  *  *	RETURNS  *		0 if failed, non-zero otherwise.  */
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|short
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|pchar
decl_stmt|;
name|unsigned
name|short
modifier|*
name|pShort
decl_stmt|;
comment|/*      * Check for old # format      */
if|if
condition|(
operator|*
name|spec
operator|==
literal|'#'
condition|)
block|{
comment|/* 	 * Attempt to parse the value portion. 	 */
name|spec
operator|++
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|3
operator|&&
name|n
operator|!=
literal|6
operator|&&
name|n
operator|!=
literal|9
operator|&&
name|n
operator|!=
literal|12
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|n
operator|/=
literal|3
expr_stmt|;
name|g
operator|=
name|b
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|r
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|b
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|spec
operator|++
expr_stmt|;
name|b
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|b
operator||=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* assume string in lowercase 		else if (c>= 'A'&& c<= 'F') 		    b |= c - ('A' - 10); 		*/
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|b
operator||=
name|c
operator|-
operator|(
literal|'a'
operator|-
literal|10
operator|)
expr_stmt|;
else|else
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|spec
operator|!=
literal|'\0'
condition|)
do|;
comment|/* 	 * Succeeded ! 	 */
name|n
operator|<<=
literal|2
expr_stmt|;
name|n
operator|=
literal|16
operator|-
name|n
expr_stmt|;
comment|/* shift instead of scale, to match old broken semantics */
name|pColor
operator|->
name|spec
operator|.
name|RGB
operator|.
name|red
operator|=
name|r
operator|<<
name|n
expr_stmt|;
name|pColor
operator|->
name|spec
operator|.
name|RGB
operator|.
name|green
operator|=
name|g
operator|<<
name|n
expr_stmt|;
name|pColor
operator|->
name|spec
operator|.
name|RGB
operator|.
name|blue
operator|=
name|b
operator|<<
name|n
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pchar
operator|=
name|strchr
argument_list|(
name|spec
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|pchar
operator|-
name|spec
argument_list|)
expr_stmt|;
comment|/* 	 * Check for proper prefix. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|spec
argument_list|,
name|XcmsRGB_prefix
argument_list|,
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/* 	 * Attempt to parse the value portion. 	 */
name|spec
operator|+=
operator|(
name|n
operator|+
literal|1
operator|)
expr_stmt|;
name|pShort
operator|=
operator|&
name|pColor
operator|->
name|spec
operator|.
name|RGB
operator|.
name|red
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
operator|,
name|pShort
operator|++
operator|,
name|spec
operator|++
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
operator|*
name|pShort
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|spec
operator|!=
literal|'/'
operator|&&
operator|*
name|spec
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|++
name|n
operator|>
literal|4
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|c
operator|=
operator|*
name|spec
operator|++
expr_stmt|;
operator|*
name|pShort
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
operator|*
name|pShort
operator||=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* assume string in lowercase 		else if (c>= 'A'&& c<= 'F') 		    *pShort |= c - ('A' - 10); 		*/
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
operator|*
name|pShort
operator||=
name|c
operator|-
operator|(
literal|'a'
operator|-
literal|10
operator|)
expr_stmt|;
else|else
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|4
condition|)
block|{
operator|*
name|pShort
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|*
name|pShort
operator|*
literal|0xFFFF
operator|)
operator|/
operator|(
operator|(
literal|1
operator|<<
name|n
operator|*
literal|4
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
name|pColor
operator|->
name|format
operator|=
name|XcmsRGBFormat
expr_stmt|;
name|pColor
operator|->
name|pixel
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsLRGB_RGBi_ParseString  *  *	SYNOPSIS  */
end_comment

begin_function
name|int
name|XcmsLRGB_RGBi_ParseString
parameter_list|(
name|spec
parameter_list|,
name|pColor
parameter_list|)
specifier|register
name|char
modifier|*
name|spec
decl_stmt|;
name|XcmsColor
modifier|*
name|pColor
decl_stmt|;
comment|/*  *	DESCRIPTION  *		This routines takes a string and attempts to convert  *		it into a XcmsColor structure with XcmsRGBiFormat.  *		The assumed RGBi string syntax is:  *		    RGBi:<r>/<g>/<b>  *		Where r, g, and b are in string input format for floats  *		consisting of:  *		    a. an optional sign  *		    b. a string of numbers possibly containing a decimal point,  *		    c. an optional exponent field containing an 'E' or 'e'  *			followed by a possibly signed integer string.  *  *	RETURNS  *		0 if failed, non-zero otherwise.  */
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|pchar
decl_stmt|;
if|if
condition|(
operator|(
name|pchar
operator|=
name|strchr
argument_list|(
name|spec
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|pchar
operator|-
name|spec
argument_list|)
expr_stmt|;
comment|/*      * Check for proper prefix.      */
if|if
condition|(
name|strncmp
argument_list|(
name|spec
argument_list|,
name|XcmsRGBi_prefix
argument_list|,
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*      * Attempt to parse the value portion.      */
if|if
condition|(
name|sscanf
argument_list|(
name|spec
operator|+
name|n
operator|+
literal|1
argument_list|,
literal|"%lf/%lf/%lf"
argument_list|,
operator|&
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|red
argument_list|,
operator|&
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|green
argument_list|,
operator|&
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|blue
argument_list|)
operator|!=
literal|3
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/*      * Succeeded !      */
name|pColor
operator|->
name|format
operator|=
name|XcmsRGBiFormat
expr_stmt|;
name|pColor
operator|->
name|pixel
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsCIEXYZToRGBi - convert CIE XYZ to RGB  *  *	SYNOPSIS  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Status
name|XcmsCIEXYZToRGBi
parameter_list|(
name|ccc
parameter_list|,
name|pXcmsColors_in_out
parameter_list|,
name|nColors
parameter_list|,
name|pCompressed
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pXcmsColors_in_out
decl_stmt|;
comment|/* pointer to XcmsColors to convert 	*/
name|unsigned
name|int
name|nColors
decl_stmt|;
comment|/* Number of colors			*/
name|Bool
modifier|*
name|pCompressed
decl_stmt|;
comment|/* pointer to an array of Bool		*/
comment|/*  *	DESCRIPTION  *		Converts color specifications in an array of XcmsColor  *		structures from RGB format to RGBi format.  *  *	RETURNS  *		XcmsFailure if failed,  *		XcmsSuccess if succeeded without gamut compression.  *		XcmsSuccessWithCompression if succeeded with gamut  *			compression.  */
block|{
name|LINEAR_RGB_SCCData
modifier|*
name|pScreenData
decl_stmt|;
name|XcmsFloat
name|tmp
index|[
literal|3
index|]
decl_stmt|;
name|int
name|hasCompressed
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|XcmsColor
modifier|*
name|pColor
init|=
name|pXcmsColors_in_out
decl_stmt|;
if|if
condition|(
name|ccc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|pScreenData
operator|=
operator|(
name|LINEAR_RGB_SCCData
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|screenData
expr_stmt|;
comment|/*      * XcmsColors should be White Point Adjusted, if necessary, by now!      */
comment|/*      * NEW!!! for extended gamut compression      *      * 1. Need to zero out pCompressed      *      * 2. Need to save initial address of pColor      *      * 3. Need to save initial address of pCompressed      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nColors
condition|;
name|i
operator|++
control|)
block|{
comment|/* Make sure format is XcmsCIEXYZFormat */
if|if
condition|(
name|pColor
operator|->
name|format
operator|!=
name|XcmsCIEXYZFormat
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/* Multiply [A]-1 * [XYZ] to get RGB intensity */
name|_XcmsMatVec
argument_list|(
operator|(
name|XcmsFloat
operator|*
operator|)
name|pScreenData
operator|->
name|XYZtoRGBmatrix
argument_list|,
operator|(
name|XcmsFloat
operator|*
operator|)
operator|&
name|pColor
operator|->
name|spec
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|MIN3
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
operator|<
operator|-
name|EPS
operator|)
operator|||
operator|(
name|MAX3
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
operator|>
operator|(
literal|1.0
operator|+
name|EPS
operator|)
operator|)
condition|)
block|{
comment|/* 	     * RGBi out of screen's gamut 	     */
if|if
condition|(
name|ccc
operator|->
name|gamutCompProc
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Aha!! Here's that little trick that will allow 		 * gamut compression routines to get the out of bound 		 * RGBi.   		 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pColor
operator|->
name|spec
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|pColor
operator|->
name|format
operator|=
name|XcmsRGBiFormat
expr_stmt|;
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
elseif|else
if|if
condition|(
call|(
modifier|*
name|ccc
operator|->
name|gamutCompProc
call|)
argument_list|(
name|ccc
argument_list|,
name|pXcmsColors_in_out
argument_list|,
name|nColors
argument_list|,
name|i
argument_list|,
name|pCompressed
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
comment|/* 	     * The gamut compression function should return colors in CIEXYZ 	     *	Also check again to if the new color is within gamut. 	     */
if|if
condition|(
name|pColor
operator|->
name|format
operator|!=
name|XcmsCIEXYZFormat
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|_XcmsMatVec
argument_list|(
operator|(
name|XcmsFloat
operator|*
operator|)
name|pScreenData
operator|->
name|XYZtoRGBmatrix
argument_list|,
operator|(
name|XcmsFloat
operator|*
operator|)
operator|&
name|pColor
operator|->
name|spec
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|MIN3
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
operator|<
operator|-
name|EPS
operator|)
operator|||
operator|(
name|MAX3
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|tmp
index|[
literal|2
index|]
argument_list|)
operator|>
operator|(
literal|1.0
operator|+
name|EPS
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|hasCompressed
operator|++
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pColor
operator|->
name|spec
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These if statements are done to ensure the fudge factor is */
comment|/* is taken into account. */
if|if
condition|(
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|red
operator|<
literal|0.0
condition|)
block|{
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|red
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|red
operator|>
literal|1.0
condition|)
block|{
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|red
operator|=
literal|1.0
expr_stmt|;
block|}
if|if
condition|(
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|green
operator|<
literal|0.0
condition|)
block|{
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|green
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|green
operator|>
literal|1.0
condition|)
block|{
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|green
operator|=
literal|1.0
expr_stmt|;
block|}
if|if
condition|(
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|blue
operator|<
literal|0.0
condition|)
block|{
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|blue
operator|=
literal|0.0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|blue
operator|>
literal|1.0
condition|)
block|{
name|pColor
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|blue
operator|=
literal|1.0
expr_stmt|;
block|}
operator|(
name|pColor
operator|++
operator|)
operator|->
name|format
operator|=
name|XcmsRGBiFormat
expr_stmt|;
block|}
return|return
operator|(
name|hasCompressed
condition|?
name|XcmsSuccessWithCompression
else|:
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		LINEAR_RGBi_to_CIEXYZ - convert RGBi to CIEXYZ  *  *	SYNOPSIS  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Status
name|XcmsRGBiToCIEXYZ
parameter_list|(
name|ccc
parameter_list|,
name|pXcmsColors_in_out
parameter_list|,
name|nColors
parameter_list|,
name|pCompressed
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pXcmsColors_in_out
decl_stmt|;
comment|/* pointer to XcmsColors to convert 	*/
name|unsigned
name|int
name|nColors
decl_stmt|;
comment|/* Number of colors			*/
name|Bool
modifier|*
name|pCompressed
decl_stmt|;
comment|/* pointer to a bit array		*/
comment|/*  *	DESCRIPTION  *		Converts color specifications in an array of XcmsColor  *		structures from RGBi format to CIEXYZ format.  *  *	RETURNS  *		XcmsFailure if failed,  *		XcmsSuccess if succeeded.  */
block|{
name|LINEAR_RGB_SCCData
modifier|*
name|pScreenData
decl_stmt|;
name|XcmsFloat
name|tmp
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * pCompressed ignored in this function.      */
if|if
condition|(
name|ccc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|pScreenData
operator|=
operator|(
name|LINEAR_RGB_SCCData
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|screenData
expr_stmt|;
comment|/*      * XcmsColors should be White Point Adjusted, if necessary, by now!      */
while|while
condition|(
name|nColors
operator|--
condition|)
block|{
comment|/* Multiply [A]-1 * [XYZ] to get RGB intensity */
name|_XcmsMatVec
argument_list|(
operator|(
name|XcmsFloat
operator|*
operator|)
name|pScreenData
operator|->
name|RGBtoXYZmatrix
argument_list|,
operator|(
name|XcmsFloat
operator|*
operator|)
operator|&
name|pXcmsColors_in_out
operator|->
name|spec
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pXcmsColors_in_out
operator|->
name|spec
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|pXcmsColors_in_out
operator|++
operator|)
operator|->
name|format
operator|=
name|XcmsCIEXYZFormat
expr_stmt|;
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsRGBiToRGB  *  *	SYNOPSIS  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Status
name|XcmsRGBiToRGB
parameter_list|(
name|ccc
parameter_list|,
name|pXcmsColors_in_out
parameter_list|,
name|nColors
parameter_list|,
name|pCompressed
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pXcmsColors_in_out
decl_stmt|;
comment|/* pointer to XcmsColors to convert 	*/
name|unsigned
name|int
name|nColors
decl_stmt|;
comment|/* Number of colors			*/
name|Bool
modifier|*
name|pCompressed
decl_stmt|;
comment|/* pointer to a bit array		*/
comment|/*  *	DESCRIPTION  *		Converts color specifications in an array of XcmsColor  *		structures from RGBi format to RGB format.  *  *	RETURNS  *		XcmsFailure if failed,  *		XcmsSuccess if succeeded without gamut compression.  *		XcmsSuccessWithCompression if succeeded with gamut  *			compression.  */
block|{
name|LINEAR_RGB_SCCData
modifier|*
name|pScreenData
decl_stmt|;
name|XcmsRGB
name|tmpRGB
decl_stmt|;
name|IntensityRec
name|keyIRec
decl_stmt|,
name|answerIRec
decl_stmt|;
comment|/*      * pCompressed ignored in this function.      */
if|if
condition|(
name|ccc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|pScreenData
operator|=
operator|(
name|LINEAR_RGB_SCCData
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|screenData
expr_stmt|;
while|while
condition|(
name|nColors
operator|--
condition|)
block|{
comment|/* Make sure format is XcmsRGBiFormat */
if|if
condition|(
name|pXcmsColors_in_out
operator|->
name|format
operator|!=
name|XcmsRGBiFormat
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|keyIRec
operator|.
name|intensity
operator|=
name|pXcmsColors_in_out
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|red
expr_stmt|;
if|if
condition|(
operator|!
name|_XcmsTableSearch
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyIRec
argument_list|,
name|ccc
operator|->
name|visual
operator|->
name|bits_per_rgb
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
argument_list|,
operator|(
name|unsigned
operator|)
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|nEntries
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|IntensityRec
argument_list|)
argument_list|,
name|_XcmsIntensityCmp
argument_list|,
name|_XcmsIntensityInterpolation
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|answerIRec
argument_list|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|tmpRGB
operator|.
name|red
operator|=
name|answerIRec
operator|.
name|value
expr_stmt|;
name|keyIRec
operator|.
name|intensity
operator|=
name|pXcmsColors_in_out
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|green
expr_stmt|;
if|if
condition|(
operator|!
name|_XcmsTableSearch
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyIRec
argument_list|,
name|ccc
operator|->
name|visual
operator|->
name|bits_per_rgb
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|pBase
argument_list|,
operator|(
name|unsigned
operator|)
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|nEntries
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|IntensityRec
argument_list|)
argument_list|,
name|_XcmsIntensityCmp
argument_list|,
name|_XcmsIntensityInterpolation
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|answerIRec
argument_list|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|tmpRGB
operator|.
name|green
operator|=
name|answerIRec
operator|.
name|value
expr_stmt|;
name|keyIRec
operator|.
name|intensity
operator|=
name|pXcmsColors_in_out
operator|->
name|spec
operator|.
name|RGBi
operator|.
name|blue
expr_stmt|;
if|if
condition|(
operator|!
name|_XcmsTableSearch
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyIRec
argument_list|,
name|ccc
operator|->
name|visual
operator|->
name|bits_per_rgb
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
argument_list|,
operator|(
name|unsigned
operator|)
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|nEntries
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|IntensityRec
argument_list|)
argument_list|,
name|_XcmsIntensityCmp
argument_list|,
name|_XcmsIntensityInterpolation
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|answerIRec
argument_list|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|tmpRGB
operator|.
name|blue
operator|=
name|answerIRec
operator|.
name|value
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tmpRGB
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pXcmsColors_in_out
operator|->
name|spec
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsRGB
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|pXcmsColors_in_out
operator|++
operator|)
operator|->
name|format
operator|=
name|XcmsRGBFormat
expr_stmt|;
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		XcmsRGBToRGBi  *  *	SYNOPSIS  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Status
name|XcmsRGBToRGBi
parameter_list|(
name|ccc
parameter_list|,
name|pXcmsColors_in_out
parameter_list|,
name|nColors
parameter_list|,
name|pCompressed
parameter_list|)
name|XcmsCCC
name|ccc
decl_stmt|;
name|XcmsColor
modifier|*
name|pXcmsColors_in_out
decl_stmt|;
comment|/* pointer to XcmsColors to convert 	*/
name|unsigned
name|int
name|nColors
decl_stmt|;
comment|/* Number of colors			*/
name|Bool
modifier|*
name|pCompressed
decl_stmt|;
comment|/* pointer to a bit array		*/
comment|/*  *	DESCRIPTION  *		Converts color specifications in an array of XcmsColor  *		structures from RGB format to RGBi format.  *  *	RETURNS  *		XcmsFailure if failed,  *		XcmsSuccess if succeeded.  */
block|{
name|LINEAR_RGB_SCCData
modifier|*
name|pScreenData
decl_stmt|;
name|XcmsRGBi
name|tmpRGBi
decl_stmt|;
name|IntensityRec
name|keyIRec
decl_stmt|,
name|answerIRec
decl_stmt|;
comment|/*      * pCompressed ignored in this function.      */
if|if
condition|(
name|ccc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|pScreenData
operator|=
operator|(
name|LINEAR_RGB_SCCData
operator|*
operator|)
name|ccc
operator|->
name|pPerScrnInfo
operator|->
name|screenData
expr_stmt|;
while|while
condition|(
name|nColors
operator|--
condition|)
block|{
comment|/* Make sure format is XcmsRGBFormat */
if|if
condition|(
name|pXcmsColors_in_out
operator|->
name|format
operator|!=
name|XcmsRGBFormat
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|keyIRec
operator|.
name|value
operator|=
name|pXcmsColors_in_out
operator|->
name|spec
operator|.
name|RGB
operator|.
name|red
expr_stmt|;
if|if
condition|(
operator|!
name|_XcmsTableSearch
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyIRec
argument_list|,
name|ccc
operator|->
name|visual
operator|->
name|bits_per_rgb
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|pBase
argument_list|,
operator|(
name|unsigned
operator|)
name|pScreenData
operator|->
name|pRedTbl
operator|->
name|nEntries
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|IntensityRec
argument_list|)
argument_list|,
name|_XcmsValueCmp
argument_list|,
name|_XcmsValueInterpolation
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|answerIRec
argument_list|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|tmpRGBi
operator|.
name|red
operator|=
name|answerIRec
operator|.
name|intensity
expr_stmt|;
name|keyIRec
operator|.
name|value
operator|=
name|pXcmsColors_in_out
operator|->
name|spec
operator|.
name|RGB
operator|.
name|green
expr_stmt|;
if|if
condition|(
operator|!
name|_XcmsTableSearch
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyIRec
argument_list|,
name|ccc
operator|->
name|visual
operator|->
name|bits_per_rgb
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|pBase
argument_list|,
operator|(
name|unsigned
operator|)
name|pScreenData
operator|->
name|pGreenTbl
operator|->
name|nEntries
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|IntensityRec
argument_list|)
argument_list|,
name|_XcmsValueCmp
argument_list|,
name|_XcmsValueInterpolation
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|answerIRec
argument_list|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|tmpRGBi
operator|.
name|green
operator|=
name|answerIRec
operator|.
name|intensity
expr_stmt|;
name|keyIRec
operator|.
name|value
operator|=
name|pXcmsColors_in_out
operator|->
name|spec
operator|.
name|RGB
operator|.
name|blue
expr_stmt|;
if|if
condition|(
operator|!
name|_XcmsTableSearch
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyIRec
argument_list|,
name|ccc
operator|->
name|visual
operator|->
name|bits_per_rgb
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|pBase
argument_list|,
operator|(
name|unsigned
operator|)
name|pScreenData
operator|->
name|pBlueTbl
operator|->
name|nEntries
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|IntensityRec
argument_list|)
argument_list|,
name|_XcmsValueCmp
argument_list|,
name|_XcmsValueInterpolation
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|answerIRec
argument_list|)
condition|)
block|{
return|return
operator|(
name|XcmsFailure
operator|)
return|;
block|}
name|tmpRGBi
operator|.
name|blue
operator|=
name|answerIRec
operator|.
name|intensity
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tmpRGBi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pXcmsColors_in_out
operator|->
name|spec
argument_list|,
sizeof|sizeof
argument_list|(
name|XcmsRGBi
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|pXcmsColors_in_out
operator|++
operator|)
operator|->
name|format
operator|=
name|XcmsRGBiFormat
expr_stmt|;
block|}
return|return
operator|(
name|XcmsSuccess
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	NAME  *		_XcmsInitScrnDefaultInfo  *  *	SYNOPSIS  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|_XcmsLRGB_InitScrnDefault
parameter_list|(
name|dpy
parameter_list|,
name|screenNumber
parameter_list|,
name|pPerScrnInfo
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|int
name|screenNumber
decl_stmt|;
name|XcmsPerScrnInfo
modifier|*
name|pPerScrnInfo
decl_stmt|;
comment|/*  *	DESCRIPTION  *		Given a display and screen number, this routine attempts  *		to initialize the TekCMS per Screen Info structure  *		(XcmsPerScrnInfo) with defaults.  *  *	RETURNS  *		Returns zero if initialization failed; non-zero otherwise.  */
block|{
name|pPerScrnInfo
operator|->
name|screenData
operator|=
operator|(
name|XPointer
operator|)
operator|&
name|Default_RGB_SCCData
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|X
operator|=
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|=
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Z
operator|=
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|+
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|+
name|Default_RGB_SCCData
operator|.
name|RGBtoXYZmatrix
index|[
literal|2
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|<
operator|(
literal|1.0
operator|-
name|EPS
operator|)
operator|)
operator|||
operator|(
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|>
operator|(
literal|1.0
operator|+
name|EPS
operator|)
operator|)
condition|)
block|{
name|pPerScrnInfo
operator|->
name|screenData
operator|=
operator|(
name|XPointer
operator|)
name|NULL
expr_stmt|;
name|pPerScrnInfo
operator|->
name|state
operator|=
name|XcmsInitNone
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|spec
operator|.
name|CIEXYZ
operator|.
name|Y
operator|=
literal|1.0
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|format
operator|=
name|XcmsCIEXYZFormat
expr_stmt|;
name|pPerScrnInfo
operator|->
name|screenWhitePt
operator|.
name|pixel
operator|=
literal|0
expr_stmt|;
name|pPerScrnInfo
operator|->
name|functionSet
operator|=
operator|(
name|XPointer
operator|)
operator|&
name|XcmsLinearRGBFunctionSet
expr_stmt|;
name|pPerScrnInfo
operator|->
name|state
operator|=
name|XcmsInitDefault
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

