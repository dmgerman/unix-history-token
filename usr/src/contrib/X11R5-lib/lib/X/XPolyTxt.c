begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XPolyTxt.c,v 11.19 91/01/06 11:47:20 rws Exp $ */
end_comment

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1986	*/
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_expr_stmt
name|XDrawText
argument_list|(
name|dpy
argument_list|,
name|d
argument_list|,
name|gc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|items
argument_list|,
name|nitems
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Drawable
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GC
name|gc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XTextItem
modifier|*
name|items
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nitems
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|XTextItem
modifier|*
name|item
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
specifier|register
name|xPolyText8Req
modifier|*
name|req
decl_stmt|;
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|FlushGC
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|)
expr_stmt|;
name|GetReq
argument_list|(
name|PolyText8
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|drawable
operator|=
name|d
expr_stmt|;
name|req
operator|->
name|gc
operator|=
name|gc
operator|->
name|gid
expr_stmt|;
name|req
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|req
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|item
operator|=
name|items
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|item
operator|->
name|font
condition|)
name|length
operator|+=
literal|5
expr_stmt|;
comment|/* a 255 byte, plus size of Font id */
if|if
condition|(
name|item
operator|->
name|delta
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|delta
operator|>
literal|0
condition|)
block|{
name|length
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
operator|*
operator|(
operator|(
name|item
operator|->
name|delta
operator|+
literal|126
operator|)
operator|/
literal|127
operator|)
expr_stmt|;
block|}
else|else
block|{
name|length
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
operator|*
operator|(
operator|(
name|abs
argument_list|(
name|item
operator|->
name|delta
argument_list|)
operator|+
literal|127
operator|)
operator|/
literal|128
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|item
operator|->
name|nchars
operator|>
literal|0
condition|)
block|{
name|length
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
operator|*
operator|(
operator|(
name|item
operator|->
name|nchars
operator|+
literal|253
operator|)
operator|/
literal|254
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|delta
condition|)
name|length
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
expr_stmt|;
name|length
operator|+=
name|item
operator|->
name|nchars
expr_stmt|;
block|}
name|item
operator|++
expr_stmt|;
block|}
name|req
operator|->
name|length
operator|+=
operator|(
name|length
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* convert to number of 32-bit words */
comment|/*       * If the entire request does not fit into the remaining space in the      * buffer, flush the buffer first.   If the request does fit into the      * empty buffer, then we won't have to flush it at the end to keep      * the buffer 32-bit aligned.       */
if|if
condition|(
name|dpy
operator|->
name|bufptr
operator|+
name|length
operator|>
name|dpy
operator|->
name|bufmax
condition|)
name|_XFlush
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|item
operator|=
name|items
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|item
operator|->
name|font
condition|)
block|{
comment|/* to mark a font shift, write a 255 byte followed by 	       the 4 bytes of font ID, big-end first */
specifier|register
name|unsigned
name|char
modifier|*
name|f
decl_stmt|;
name|BufAlloc
argument_list|(
argument|unsigned char *
argument_list|,
argument|f
argument_list|,
literal|5
argument_list|)
empty_stmt|;
name|f
index|[
literal|0
index|]
operator|=
literal|255
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
operator|(
name|item
operator|->
name|font
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
operator|(
name|item
operator|->
name|font
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|f
index|[
literal|3
index|]
operator|=
operator|(
name|item
operator|->
name|font
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|f
index|[
literal|4
index|]
operator|=
name|item
operator|->
name|font
operator|&
literal|0x000000ff
expr_stmt|;
comment|/* update GC shadow */
name|gc
operator|->
name|values
operator|.
name|font
operator|=
name|item
operator|->
name|font
expr_stmt|;
block|}
block|{
name|int
name|nbytes
init|=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
decl_stmt|;
name|int
name|PartialNChars
init|=
name|item
operator|->
name|nchars
decl_stmt|;
name|int
name|PartialDelta
init|=
name|item
operator|->
name|delta
decl_stmt|;
comment|/* register xTextElt *elt; */
name|int
name|FirstTimeThrough
init|=
name|True
decl_stmt|;
name|char
modifier|*
name|CharacterOffset
init|=
name|item
operator|->
name|chars
decl_stmt|;
name|char
modifier|*
name|tbuf
decl_stmt|;
while|while
condition|(
operator|(
name|PartialDelta
operator|<
operator|-
literal|128
operator|)
operator|||
operator|(
name|PartialDelta
operator|>
literal|127
operator|)
condition|)
block|{
name|int
name|nb
init|=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
decl_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|tbuf
argument_list|,
name|nb
argument_list|)
expr_stmt|;
operator|*
name|tbuf
operator|=
literal|0
expr_stmt|;
comment|/*   elt->len  */
if|if
condition|(
name|PartialDelta
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|tbuf
operator|+
literal|1
operator|)
operator|=
literal|127
expr_stmt|;
comment|/* elt->delta  */
name|PartialDelta
operator|=
name|PartialDelta
operator|-
literal|127
expr_stmt|;
block|}
else|else
block|{
comment|/* -128 = 0x8, need to be careful of signed chars... */
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|tbuf
operator|+
literal|1
operator|)
operator|)
operator|=
literal|0x80
expr_stmt|;
comment|/* elt->delta */
name|PartialDelta
operator|=
name|PartialDelta
operator|+
literal|128
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PartialDelta
condition|)
block|{
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|tbuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|*
name|tbuf
operator|=
literal|0
expr_stmt|;
comment|/* elt->len */
operator|*
operator|(
name|tbuf
operator|+
literal|1
operator|)
operator|=
name|PartialDelta
expr_stmt|;
comment|/* elt->delta  */
block|}
while|while
condition|(
name|PartialNChars
operator|>
literal|254
condition|)
block|{
name|nbytes
operator|=
literal|254
expr_stmt|;
if|if
condition|(
name|FirstTimeThrough
condition|)
block|{
name|FirstTimeThrough
operator|=
name|False
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|delta
condition|)
block|{
name|nbytes
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
expr_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|tbuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tbuf
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* elt->delta */
block|}
else|else
block|{
name|char
modifier|*
name|DummyChar
decl_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|DummyChar
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nbytes
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
expr_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|tbuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tbuf
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* elt->delta */
block|}
comment|/* watch out for signs on chars */
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tbuf
operator|=
literal|254
expr_stmt|;
comment|/* elt->len */
operator|*
name|tbuf
operator|=
literal|254
expr_stmt|;
comment|/* elt->len */
name|bcopy
argument_list|(
name|CharacterOffset
argument_list|,
name|tbuf
operator|+
literal|2
argument_list|,
literal|254
argument_list|)
expr_stmt|;
name|PartialNChars
operator|=
name|PartialNChars
operator|-
literal|254
expr_stmt|;
name|CharacterOffset
operator|+=
literal|254
expr_stmt|;
block|}
if|if
condition|(
name|PartialNChars
condition|)
block|{
name|nbytes
operator|=
name|PartialNChars
expr_stmt|;
if|if
condition|(
name|FirstTimeThrough
condition|)
block|{
name|FirstTimeThrough
operator|=
name|False
expr_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|delta
condition|)
block|{
name|nbytes
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
expr_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|tbuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tbuf
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
comment|/*  elt->delta  */
block|}
else|else
block|{
name|char
modifier|*
name|DummyChar
decl_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|DummyChar
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nbytes
operator|+=
name|SIZEOF
argument_list|(
name|xTextElt
argument_list|)
expr_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|tbuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tbuf
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* elt->delta  */
block|}
operator|*
name|tbuf
operator|=
name|PartialNChars
expr_stmt|;
comment|/*  elt->len  */
name|bcopy
argument_list|(
name|CharacterOffset
argument_list|,
name|tbuf
operator|+
literal|2
argument_list|,
name|PartialNChars
argument_list|)
expr_stmt|;
block|}
block|}
name|item
operator|++
expr_stmt|;
block|}
comment|/* Pad request out to a 32-bit boundary */
if|if
condition|(
name|length
operator|&=
literal|3
condition|)
block|{
name|char
modifier|*
name|pad
decl_stmt|;
comment|/*  	 * BufAlloc is a macro that uses its last argument more than 	 * once, otherwise I'd write "BufAlloc (char *, pad, 4-length)"  	 */
name|length
operator|=
literal|4
operator|-
name|length
expr_stmt|;
name|BufAlloc
argument_list|(
name|char
operator|*
argument_list|,
name|pad
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/*  	 * if there are 3 bytes of padding, the first byte MUST be 0 	 * so the pad bytes aren't mistaken for a final xTextElt  	 */
operator|*
name|pad
operator|=
literal|0
expr_stmt|;
block|}
comment|/*       * If the buffer pointer is not now pointing to a 32-bit boundary,      * we must flush the buffer so that it does point to a 32-bit boundary      * at the end of this routine.       */
if|if
condition|(
operator|(
name|dpy
operator|->
name|bufptr
operator|-
name|dpy
operator|->
name|buffer
operator|)
operator|&
literal|3
condition|)
name|_XFlush
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|SyncHandle
argument_list|()
expr_stmt|;
return|return;
block|}
end_block

end_unit

