begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XPolyReg.c,v 11.21 92/09/15 14:22:38 rws Exp $ */
end_comment

begin_comment
comment|/************************************************************************ Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment

begin_define
define|#
directive|define
name|LARGE_COORDINATE
value|1000000
end_define

begin_define
define|#
directive|define
name|SMALL_COORDINATE
value|-LARGE_COORDINATE
end_define

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xutil.h"
end_include

begin_include
include|#
directive|include
file|"region.h"
end_include

begin_include
include|#
directive|include
file|"poly.h"
end_include

begin_comment
comment|/*  *     InsertEdgeInET  *  *     Insert the given edge into the edge table.  *     First we must find the correct bucket in the  *     Edge table, then find the right slot in the  *     bucket.  Finally, we can insert it.  *  */
end_comment

begin_function
specifier|static
name|void
name|InsertEdgeInET
parameter_list|(
name|ET
parameter_list|,
name|ETE
parameter_list|,
name|scanline
parameter_list|,
name|SLLBlock
parameter_list|,
name|iSLLBlock
parameter_list|)
name|EdgeTable
modifier|*
name|ET
decl_stmt|;
name|EdgeTableEntry
modifier|*
name|ETE
decl_stmt|;
name|int
name|scanline
decl_stmt|;
name|ScanLineListBlock
modifier|*
modifier|*
name|SLLBlock
decl_stmt|;
name|int
modifier|*
name|iSLLBlock
decl_stmt|;
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|start
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
specifier|register
name|ScanLineList
modifier|*
name|pSLL
decl_stmt|,
modifier|*
name|pPrevSLL
decl_stmt|;
name|ScanLineListBlock
modifier|*
name|tmpSLLBlock
decl_stmt|;
comment|/*      * find the right bucket to put the edge into      */
name|pPrevSLL
operator|=
operator|&
name|ET
operator|->
name|scanlines
expr_stmt|;
name|pSLL
operator|=
name|pPrevSLL
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|pSLL
operator|&&
operator|(
name|pSLL
operator|->
name|scanline
operator|<
name|scanline
operator|)
condition|)
block|{
name|pPrevSLL
operator|=
name|pSLL
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
comment|/*      * reassign pSLL (pointer to ScanLineList) if necessary      */
if|if
condition|(
operator|(
operator|!
name|pSLL
operator|)
operator|||
operator|(
name|pSLL
operator|->
name|scanline
operator|>
name|scanline
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|iSLLBlock
operator|>
name|SLLSPERBLOCK
operator|-
literal|1
condition|)
block|{
name|tmpSLLBlock
operator|=
operator|(
name|ScanLineListBlock
operator|*
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ScanLineListBlock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|SLLBlock
operator|)
operator|->
name|next
operator|=
name|tmpSLLBlock
expr_stmt|;
name|tmpSLLBlock
operator|->
name|next
operator|=
operator|(
name|ScanLineListBlock
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|SLLBlock
operator|=
name|tmpSLLBlock
expr_stmt|;
operator|*
name|iSLLBlock
operator|=
literal|0
expr_stmt|;
block|}
name|pSLL
operator|=
operator|&
operator|(
operator|(
operator|*
name|SLLBlock
operator|)
operator|->
name|SLLs
index|[
operator|(
operator|*
name|iSLLBlock
operator|)
operator|++
index|]
operator|)
expr_stmt|;
name|pSLL
operator|->
name|next
operator|=
name|pPrevSLL
operator|->
name|next
expr_stmt|;
name|pSLL
operator|->
name|edgelist
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|pPrevSLL
operator|->
name|next
operator|=
name|pSLL
expr_stmt|;
block|}
name|pSLL
operator|->
name|scanline
operator|=
name|scanline
expr_stmt|;
comment|/*      * now insert the edge in the right bucket      */
name|prev
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|start
operator|=
name|pSLL
operator|->
name|edgelist
expr_stmt|;
while|while
condition|(
name|start
operator|&&
operator|(
name|start
operator|->
name|bres
operator|.
name|minor_axis
operator|<
name|ETE
operator|->
name|bres
operator|.
name|minor_axis
operator|)
condition|)
block|{
name|prev
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|start
operator|->
name|next
expr_stmt|;
block|}
name|ETE
operator|->
name|next
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|ETE
expr_stmt|;
else|else
name|pSLL
operator|->
name|edgelist
operator|=
name|ETE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *     CreateEdgeTable  *  *     This routine creates the edge table for  *     scan converting polygons.   *     The Edge Table (ET) looks like:  *  *    EdgeTable  *     --------  *    |  ymax  |        ScanLineLists  *    |scanline|-->------------>-------------->...  *     --------   |scanline|   |scanline|  *                |edgelist|   |edgelist|  *                ---------    ---------  *                    |             |  *                    |             |  *                    V             V  *              list of ETEs   list of ETEs  *  *     where ETE is an EdgeTableEntry data structure,  *     and there is one ScanLineList per scanline at  *     which an edge is initially entered.  *  */
end_comment

begin_function
specifier|static
name|void
name|CreateETandAET
parameter_list|(
name|count
parameter_list|,
name|pts
parameter_list|,
name|ET
parameter_list|,
name|AET
parameter_list|,
name|pETEs
parameter_list|,
name|pSLLBlock
parameter_list|)
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|XPoint
modifier|*
name|pts
decl_stmt|;
name|EdgeTable
modifier|*
name|ET
decl_stmt|;
name|EdgeTableEntry
modifier|*
name|AET
decl_stmt|;
specifier|register
name|EdgeTableEntry
modifier|*
name|pETEs
decl_stmt|;
name|ScanLineListBlock
modifier|*
name|pSLLBlock
decl_stmt|;
block|{
specifier|register
name|XPoint
modifier|*
name|top
decl_stmt|,
modifier|*
name|bottom
decl_stmt|;
specifier|register
name|XPoint
modifier|*
name|PrevPt
decl_stmt|,
modifier|*
name|CurrPt
decl_stmt|;
name|int
name|iSLLBlock
init|=
literal|0
decl_stmt|;
name|int
name|dy
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|2
condition|)
return|return;
comment|/*      *  initialize the Active Edge Table      */
name|AET
operator|->
name|next
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|AET
operator|->
name|back
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|AET
operator|->
name|nextWETE
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|AET
operator|->
name|bres
operator|.
name|minor_axis
operator|=
name|SMALL_COORDINATE
expr_stmt|;
comment|/*      *  initialize the Edge Table.      */
name|ET
operator|->
name|scanlines
operator|.
name|next
operator|=
operator|(
name|ScanLineList
operator|*
operator|)
name|NULL
expr_stmt|;
name|ET
operator|->
name|ymax
operator|=
name|SMALL_COORDINATE
expr_stmt|;
name|ET
operator|->
name|ymin
operator|=
name|LARGE_COORDINATE
expr_stmt|;
name|pSLLBlock
operator|->
name|next
operator|=
operator|(
name|ScanLineListBlock
operator|*
operator|)
name|NULL
expr_stmt|;
name|PrevPt
operator|=
operator|&
name|pts
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
comment|/*      *  for each vertex in the array of points.      *  In this loop we are dealing with two vertices at      *  a time -- these make up one edge of the polygon.      */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|CurrPt
operator|=
name|pts
operator|++
expr_stmt|;
comment|/*          *  find out which point is above and which is below.          */
if|if
condition|(
name|PrevPt
operator|->
name|y
operator|>
name|CurrPt
operator|->
name|y
condition|)
block|{
name|bottom
operator|=
name|PrevPt
operator|,
name|top
operator|=
name|CurrPt
expr_stmt|;
name|pETEs
operator|->
name|ClockWise
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
name|CurrPt
operator|,
name|top
operator|=
name|PrevPt
expr_stmt|;
name|pETEs
operator|->
name|ClockWise
operator|=
literal|1
expr_stmt|;
block|}
comment|/*          * don't add horizontal edges to the Edge table.          */
if|if
condition|(
name|bottom
operator|->
name|y
operator|!=
name|top
operator|->
name|y
condition|)
block|{
name|pETEs
operator|->
name|ymax
operator|=
name|bottom
operator|->
name|y
operator|-
literal|1
expr_stmt|;
comment|/* -1 so we don't get last scanline */
comment|/*              *  initialize integer edge algorithm              */
name|dy
operator|=
name|bottom
operator|->
name|y
operator|-
name|top
operator|->
name|y
expr_stmt|;
name|BRESINITPGONSTRUCT
argument_list|(
name|dy
argument_list|,
name|top
operator|->
name|x
argument_list|,
name|bottom
operator|->
name|x
argument_list|,
name|pETEs
operator|->
name|bres
argument_list|)
expr_stmt|;
name|InsertEdgeInET
argument_list|(
name|ET
argument_list|,
name|pETEs
argument_list|,
name|top
operator|->
name|y
argument_list|,
operator|&
name|pSLLBlock
argument_list|,
operator|&
name|iSLLBlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|PrevPt
operator|->
name|y
operator|>
name|ET
operator|->
name|ymax
condition|)
name|ET
operator|->
name|ymax
operator|=
name|PrevPt
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|PrevPt
operator|->
name|y
operator|<
name|ET
operator|->
name|ymin
condition|)
name|ET
operator|->
name|ymin
operator|=
name|PrevPt
operator|->
name|y
expr_stmt|;
name|pETEs
operator|++
expr_stmt|;
block|}
name|PrevPt
operator|=
name|CurrPt
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *     loadAET  *  *     This routine moves EdgeTableEntries from the  *     EdgeTable into the Active Edge Table,  *     leaving them sorted by smaller x coordinate.  *  */
end_comment

begin_function
specifier|static
name|void
name|loadAET
parameter_list|(
name|AET
parameter_list|,
name|ETEs
parameter_list|)
specifier|register
name|EdgeTableEntry
modifier|*
name|AET
decl_stmt|,
decl|*
name|ETEs
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|pPrevAET
decl_stmt|;
specifier|register
name|EdgeTableEntry
modifier|*
name|tmp
decl_stmt|;
name|pPrevAET
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|ETEs
condition|)
block|{
while|while
condition|(
name|AET
operator|&&
operator|(
name|AET
operator|->
name|bres
operator|.
name|minor_axis
operator|<
name|ETEs
operator|->
name|bres
operator|.
name|minor_axis
operator|)
condition|)
block|{
name|pPrevAET
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
block|}
name|tmp
operator|=
name|ETEs
operator|->
name|next
expr_stmt|;
name|ETEs
operator|->
name|next
operator|=
name|AET
expr_stmt|;
if|if
condition|(
name|AET
condition|)
name|AET
operator|->
name|back
operator|=
name|ETEs
expr_stmt|;
name|ETEs
operator|->
name|back
operator|=
name|pPrevAET
expr_stmt|;
name|pPrevAET
operator|->
name|next
operator|=
name|ETEs
expr_stmt|;
name|pPrevAET
operator|=
name|ETEs
expr_stmt|;
name|ETEs
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *     computeWAET  *  *     This routine links the AET by the  *     nextWETE (winding EdgeTableEntry) link for  *     use by the winding number rule.  The final   *     Active Edge Table (AET) might look something  *     like:  *  *     AET  *     ----------  ---------   ---------  *     |ymax    |  |ymax    |  |ymax    |   *     | ...    |  |...     |  |...     |  *     |next    |->|next    |->|next    |->...  *     |nextWETE|  |nextWETE|  |nextWETE|  *     ---------   ---------   ^--------  *         |                   |       |  *         V------------------->       V---> ...  *  */
end_comment

begin_function
specifier|static
name|void
name|computeWAET
parameter_list|(
name|AET
parameter_list|)
specifier|register
name|EdgeTableEntry
modifier|*
name|AET
decl_stmt|;
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|pWETE
decl_stmt|;
specifier|register
name|int
name|inside
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|isInside
init|=
literal|0
decl_stmt|;
name|AET
operator|->
name|nextWETE
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
name|pWETE
operator|=
name|AET
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|AET
condition|)
block|{
if|if
condition|(
name|AET
operator|->
name|ClockWise
condition|)
name|isInside
operator|++
expr_stmt|;
else|else
name|isInside
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|inside
operator|&&
operator|!
name|isInside
operator|)
operator|||
operator|(
name|inside
operator|&&
name|isInside
operator|)
condition|)
block|{
name|pWETE
operator|->
name|nextWETE
operator|=
name|AET
expr_stmt|;
name|pWETE
operator|=
name|AET
expr_stmt|;
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
block|}
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
block|}
name|pWETE
operator|->
name|nextWETE
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *     InsertionSort  *  *     Just a simple insertion sort using  *     pointers and back pointers to sort the Active  *     Edge Table.  *  */
end_comment

begin_function
specifier|static
name|int
name|InsertionSort
parameter_list|(
name|AET
parameter_list|)
specifier|register
name|EdgeTableEntry
modifier|*
name|AET
decl_stmt|;
block|{
specifier|register
name|EdgeTableEntry
modifier|*
name|pETEchase
decl_stmt|;
specifier|register
name|EdgeTableEntry
modifier|*
name|pETEinsert
decl_stmt|;
specifier|register
name|EdgeTableEntry
modifier|*
name|pETEchaseBackTMP
decl_stmt|;
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|AET
condition|)
block|{
name|pETEinsert
operator|=
name|AET
expr_stmt|;
name|pETEchase
operator|=
name|AET
expr_stmt|;
while|while
condition|(
name|pETEchase
operator|->
name|back
operator|->
name|bres
operator|.
name|minor_axis
operator|>
name|AET
operator|->
name|bres
operator|.
name|minor_axis
condition|)
name|pETEchase
operator|=
name|pETEchase
operator|->
name|back
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pETEchase
operator|!=
name|pETEinsert
condition|)
block|{
name|pETEchaseBackTMP
operator|=
name|pETEchase
operator|->
name|back
expr_stmt|;
name|pETEinsert
operator|->
name|back
operator|->
name|next
operator|=
name|AET
expr_stmt|;
if|if
condition|(
name|AET
condition|)
name|AET
operator|->
name|back
operator|=
name|pETEinsert
operator|->
name|back
expr_stmt|;
name|pETEinsert
operator|->
name|next
operator|=
name|pETEchase
expr_stmt|;
name|pETEchase
operator|->
name|back
operator|->
name|next
operator|=
name|pETEinsert
expr_stmt|;
name|pETEchase
operator|->
name|back
operator|=
name|pETEinsert
expr_stmt|;
name|pETEinsert
operator|->
name|back
operator|=
name|pETEchaseBackTMP
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|changed
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *     Clean up our act.  */
end_comment

begin_function
specifier|static
name|void
name|FreeStorage
parameter_list|(
name|pSLLBlock
parameter_list|)
specifier|register
name|ScanLineListBlock
modifier|*
name|pSLLBlock
decl_stmt|;
block|{
specifier|register
name|ScanLineListBlock
modifier|*
name|tmpSLLBlock
decl_stmt|;
while|while
condition|(
name|pSLLBlock
condition|)
block|{
name|tmpSLLBlock
operator|=
name|pSLLBlock
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pSLLBlock
argument_list|)
expr_stmt|;
name|pSLLBlock
operator|=
name|tmpSLLBlock
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *     Create an array of rectangles from a list of points.  *     If indeed these things (POINTS, RECTS) are the same,  *     then this proc is still needed, because it allocates  *     storage for the array, which was allocated on the  *     stack by the calling procedure.  *  */
end_comment

begin_function
specifier|static
name|int
name|PtsToRegion
parameter_list|(
name|numFullPtBlocks
parameter_list|,
name|iCurPtBlock
parameter_list|,
name|FirstPtBlock
parameter_list|,
name|reg
parameter_list|)
specifier|register
name|int
name|numFullPtBlocks
decl_stmt|,
name|iCurPtBlock
decl_stmt|;
name|POINTBLOCK
modifier|*
name|FirstPtBlock
decl_stmt|;
name|REGION
modifier|*
name|reg
decl_stmt|;
block|{
specifier|register
name|BOX
modifier|*
name|rects
decl_stmt|;
specifier|register
name|XPoint
modifier|*
name|pts
decl_stmt|;
specifier|register
name|POINTBLOCK
modifier|*
name|CurPtBlock
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|BOX
modifier|*
name|extents
decl_stmt|;
specifier|register
name|int
name|numRects
decl_stmt|;
name|extents
operator|=
operator|&
name|reg
operator|->
name|extents
expr_stmt|;
name|numRects
operator|=
operator|(
operator|(
name|numFullPtBlocks
operator|*
name|NUMPTSTOBUFFER
operator|)
operator|+
name|iCurPtBlock
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|->
name|rects
operator|=
operator|(
name|BOX
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|->
name|rects
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|BOX
argument_list|)
operator|*
name|numRects
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reg
operator|->
name|size
operator|=
name|numRects
expr_stmt|;
name|CurPtBlock
operator|=
name|FirstPtBlock
expr_stmt|;
name|rects
operator|=
name|reg
operator|->
name|rects
operator|-
literal|1
expr_stmt|;
name|numRects
operator|=
literal|0
expr_stmt|;
name|extents
operator|->
name|x1
operator|=
name|MAXSHORT
operator|,
name|extents
operator|->
name|x2
operator|=
name|MINSHORT
expr_stmt|;
for|for
control|(
init|;
name|numFullPtBlocks
operator|>=
literal|0
condition|;
name|numFullPtBlocks
operator|--
control|)
block|{
comment|/* the loop uses 2 points per iteration */
name|i
operator|=
name|NUMPTSTOBUFFER
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|numFullPtBlocks
condition|)
name|i
operator|=
name|iCurPtBlock
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|pts
operator|=
name|CurPtBlock
operator|->
name|pts
init|;
name|i
operator|--
condition|;
name|pts
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|pts
operator|->
name|x
operator|==
name|pts
index|[
literal|1
index|]
operator|.
name|x
condition|)
continue|continue;
if|if
condition|(
name|numRects
operator|&&
name|pts
operator|->
name|x
operator|==
name|rects
operator|->
name|x1
operator|&&
name|pts
operator|->
name|y
operator|==
name|rects
operator|->
name|y2
operator|&&
name|pts
index|[
literal|1
index|]
operator|.
name|x
operator|==
name|rects
operator|->
name|x2
operator|&&
operator|(
name|numRects
operator|==
literal|1
operator|||
name|rects
index|[
operator|-
literal|1
index|]
operator|.
name|y1
operator|!=
name|rects
operator|->
name|y1
operator|)
operator|&&
operator|(
operator|!
name|i
operator|||
name|pts
index|[
literal|2
index|]
operator|.
name|y
operator|>
name|pts
index|[
literal|1
index|]
operator|.
name|y
operator|)
condition|)
block|{
name|rects
operator|->
name|y2
operator|=
name|pts
index|[
literal|1
index|]
operator|.
name|y
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|numRects
operator|++
expr_stmt|;
name|rects
operator|++
expr_stmt|;
name|rects
operator|->
name|x1
operator|=
name|pts
operator|->
name|x
expr_stmt|;
name|rects
operator|->
name|y1
operator|=
name|pts
operator|->
name|y
expr_stmt|;
name|rects
operator|->
name|x2
operator|=
name|pts
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|rects
operator|->
name|y2
operator|=
name|pts
index|[
literal|1
index|]
operator|.
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rects
operator|->
name|x1
operator|<
name|extents
operator|->
name|x1
condition|)
name|extents
operator|->
name|x1
operator|=
name|rects
operator|->
name|x1
expr_stmt|;
if|if
condition|(
name|rects
operator|->
name|x2
operator|>
name|extents
operator|->
name|x2
condition|)
name|extents
operator|->
name|x2
operator|=
name|rects
operator|->
name|x2
expr_stmt|;
block|}
name|CurPtBlock
operator|=
name|CurPtBlock
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|numRects
condition|)
block|{
name|extents
operator|->
name|y1
operator|=
name|reg
operator|->
name|rects
operator|->
name|y1
expr_stmt|;
name|extents
operator|->
name|y2
operator|=
name|rects
operator|->
name|y2
expr_stmt|;
block|}
else|else
block|{
name|extents
operator|->
name|x1
operator|=
literal|0
expr_stmt|;
name|extents
operator|->
name|y1
operator|=
literal|0
expr_stmt|;
name|extents
operator|->
name|x2
operator|=
literal|0
expr_stmt|;
name|extents
operator|->
name|y2
operator|=
literal|0
expr_stmt|;
block|}
name|reg
operator|->
name|numRects
operator|=
name|numRects
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *     polytoregion  *  *     Scan converts a polygon by returning a run-length  *     encoding of the resultant bitmap -- the run-length  *     encoding is in the form of an array of rectangles.  */
end_comment

begin_function
name|Region
name|XPolygonRegion
parameter_list|(
name|Pts
parameter_list|,
name|Count
parameter_list|,
name|rule
parameter_list|)
name|int
name|Count
decl_stmt|;
comment|/* number of pts           */
name|XPoint
modifier|*
name|Pts
decl_stmt|;
comment|/* the pts                 */
name|int
name|rule
decl_stmt|;
comment|/* winding rule */
block|{
name|Region
name|region
decl_stmt|;
specifier|register
name|EdgeTableEntry
modifier|*
name|pAET
decl_stmt|;
comment|/* Active Edge Table       */
specifier|register
name|int
name|y
decl_stmt|;
comment|/* current scanline        */
specifier|register
name|int
name|iPts
init|=
literal|0
decl_stmt|;
comment|/* number of pts in buffer */
specifier|register
name|EdgeTableEntry
modifier|*
name|pWETE
decl_stmt|;
comment|/* Winding Edge Table Entry*/
specifier|register
name|ScanLineList
modifier|*
name|pSLL
decl_stmt|;
comment|/* current scanLineList    */
specifier|register
name|XPoint
modifier|*
name|pts
decl_stmt|;
comment|/* output buffer           */
name|EdgeTableEntry
modifier|*
name|pPrevAET
decl_stmt|;
comment|/* ptr to previous AET     */
name|EdgeTable
name|ET
decl_stmt|;
comment|/* header node for ET      */
name|EdgeTableEntry
name|AET
decl_stmt|;
comment|/* header node for AET     */
name|EdgeTableEntry
modifier|*
name|pETEs
decl_stmt|;
comment|/* EdgeTableEntries pool   */
name|ScanLineListBlock
name|SLLBlock
decl_stmt|;
comment|/* header for scanlinelist */
name|int
name|fixWAET
init|=
name|FALSE
decl_stmt|;
name|POINTBLOCK
name|FirstPtBlock
decl_stmt|,
modifier|*
name|curPtBlock
decl_stmt|;
comment|/* PtBlock buffers    */
name|POINTBLOCK
modifier|*
name|tmpPtBlock
decl_stmt|;
name|int
name|numFullPtBlocks
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|region
operator|=
name|XCreateRegion
argument_list|()
operator|)
condition|)
return|return
operator|(
name|Region
operator|)
name|NULL
return|;
comment|/* special case a rectangle */
name|pts
operator|=
name|Pts
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|Count
operator|==
literal|4
operator|)
operator|||
operator|(
operator|(
name|Count
operator|==
literal|5
operator|)
operator|&&
operator|(
name|pts
index|[
literal|4
index|]
operator|.
name|x
operator|==
name|pts
index|[
literal|0
index|]
operator|.
name|x
operator|)
operator|&&
operator|(
name|pts
index|[
literal|4
index|]
operator|.
name|y
operator|==
name|pts
index|[
literal|0
index|]
operator|.
name|y
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|pts
index|[
literal|0
index|]
operator|.
name|y
operator|==
name|pts
index|[
literal|1
index|]
operator|.
name|y
operator|)
operator|&&
operator|(
name|pts
index|[
literal|1
index|]
operator|.
name|x
operator|==
name|pts
index|[
literal|2
index|]
operator|.
name|x
operator|)
operator|&&
operator|(
name|pts
index|[
literal|2
index|]
operator|.
name|y
operator|==
name|pts
index|[
literal|3
index|]
operator|.
name|y
operator|)
operator|&&
operator|(
name|pts
index|[
literal|3
index|]
operator|.
name|x
operator|==
name|pts
index|[
literal|0
index|]
operator|.
name|x
operator|)
operator|)
operator|||
operator|(
operator|(
name|pts
index|[
literal|0
index|]
operator|.
name|x
operator|==
name|pts
index|[
literal|1
index|]
operator|.
name|x
operator|)
operator|&&
operator|(
name|pts
index|[
literal|1
index|]
operator|.
name|y
operator|==
name|pts
index|[
literal|2
index|]
operator|.
name|y
operator|)
operator|&&
operator|(
name|pts
index|[
literal|2
index|]
operator|.
name|x
operator|==
name|pts
index|[
literal|3
index|]
operator|.
name|x
operator|)
operator|&&
operator|(
name|pts
index|[
literal|3
index|]
operator|.
name|y
operator|==
name|pts
index|[
literal|0
index|]
operator|.
name|y
operator|)
operator|)
operator|)
condition|)
block|{
name|region
operator|->
name|extents
operator|.
name|x1
operator|=
name|min
argument_list|(
name|pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|region
operator|->
name|extents
operator|.
name|y1
operator|=
name|min
argument_list|(
name|pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|,
name|pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|region
operator|->
name|extents
operator|.
name|x2
operator|=
name|max
argument_list|(
name|pts
index|[
literal|0
index|]
operator|.
name|x
argument_list|,
name|pts
index|[
literal|2
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|region
operator|->
name|extents
operator|.
name|y2
operator|=
name|max
argument_list|(
name|pts
index|[
literal|0
index|]
operator|.
name|y
argument_list|,
name|pts
index|[
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|region
operator|->
name|extents
operator|.
name|x1
operator|!=
name|region
operator|->
name|extents
operator|.
name|x2
operator|)
operator|&&
operator|(
name|region
operator|->
name|extents
operator|.
name|y1
operator|!=
name|region
operator|->
name|extents
operator|.
name|y2
operator|)
condition|)
block|{
name|region
operator|->
name|numRects
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|region
operator|->
name|rects
operator|)
operator|=
name|region
operator|->
name|extents
expr_stmt|;
block|}
return|return
operator|(
name|region
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|pETEs
operator|=
operator|(
name|EdgeTableEntry
operator|*
operator|)
name|Xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|EdgeTableEntry
argument_list|)
operator|*
name|Count
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|Region
operator|)
name|NULL
return|;
name|pts
operator|=
name|FirstPtBlock
operator|.
name|pts
expr_stmt|;
name|CreateETandAET
argument_list|(
name|Count
argument_list|,
name|Pts
argument_list|,
operator|&
name|ET
argument_list|,
operator|&
name|AET
argument_list|,
name|pETEs
argument_list|,
operator|&
name|SLLBlock
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|ET
operator|.
name|scanlines
operator|.
name|next
expr_stmt|;
name|curPtBlock
operator|=
operator|&
name|FirstPtBlock
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|EvenOddRule
condition|)
block|{
comment|/*          *  for each scanline          */
for|for
control|(
name|y
operator|=
name|ET
operator|.
name|ymin
init|;
name|y
operator|<
name|ET
operator|.
name|ymax
condition|;
name|y
operator|++
control|)
block|{
comment|/*              *  Add a new edge to the active edge table when we              *  get to the next edge.              */
if|if
condition|(
name|pSLL
operator|!=
name|NULL
operator|&&
name|y
operator|==
name|pSLL
operator|->
name|scanline
condition|)
block|{
name|loadAET
argument_list|(
operator|&
name|AET
argument_list|,
name|pSLL
operator|->
name|edgelist
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
name|pPrevAET
operator|=
operator|&
name|AET
expr_stmt|;
name|pAET
operator|=
name|AET
operator|.
name|next
expr_stmt|;
comment|/*              *  for each active edge              */
while|while
condition|(
name|pAET
condition|)
block|{
name|pts
operator|->
name|x
operator|=
name|pAET
operator|->
name|bres
operator|.
name|minor_axis
operator|,
name|pts
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|pts
operator|++
operator|,
name|iPts
operator|++
expr_stmt|;
comment|/*                  *  send out the buffer                  */
if|if
condition|(
name|iPts
operator|==
name|NUMPTSTOBUFFER
condition|)
block|{
name|tmpPtBlock
operator|=
operator|(
name|POINTBLOCK
operator|*
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|POINTBLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|curPtBlock
operator|->
name|next
operator|=
name|tmpPtBlock
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
name|pts
operator|=
name|curPtBlock
operator|->
name|pts
expr_stmt|;
name|numFullPtBlocks
operator|++
expr_stmt|;
name|iPts
operator|=
literal|0
expr_stmt|;
block|}
name|EVALUATEEDGEEVENODD
argument_list|(
name|pAET
argument_list|,
name|pPrevAET
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|InsertionSort
argument_list|(
operator|&
name|AET
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*          *  for each scanline          */
for|for
control|(
name|y
operator|=
name|ET
operator|.
name|ymin
init|;
name|y
operator|<
name|ET
operator|.
name|ymax
condition|;
name|y
operator|++
control|)
block|{
comment|/*              *  Add a new edge to the active edge table when we              *  get to the next edge.              */
if|if
condition|(
name|pSLL
operator|!=
name|NULL
operator|&&
name|y
operator|==
name|pSLL
operator|->
name|scanline
condition|)
block|{
name|loadAET
argument_list|(
operator|&
name|AET
argument_list|,
name|pSLL
operator|->
name|edgelist
argument_list|)
expr_stmt|;
name|computeWAET
argument_list|(
operator|&
name|AET
argument_list|)
expr_stmt|;
name|pSLL
operator|=
name|pSLL
operator|->
name|next
expr_stmt|;
block|}
name|pPrevAET
operator|=
operator|&
name|AET
expr_stmt|;
name|pAET
operator|=
name|AET
operator|.
name|next
expr_stmt|;
name|pWETE
operator|=
name|pAET
expr_stmt|;
comment|/*              *  for each active edge              */
while|while
condition|(
name|pAET
condition|)
block|{
comment|/*                  *  add to the buffer only those edges that                  *  are in the Winding active edge table.                  */
if|if
condition|(
name|pWETE
operator|==
name|pAET
condition|)
block|{
name|pts
operator|->
name|x
operator|=
name|pAET
operator|->
name|bres
operator|.
name|minor_axis
operator|,
name|pts
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|pts
operator|++
operator|,
name|iPts
operator|++
expr_stmt|;
comment|/*                      *  send out the buffer                      */
if|if
condition|(
name|iPts
operator|==
name|NUMPTSTOBUFFER
condition|)
block|{
name|tmpPtBlock
operator|=
operator|(
name|POINTBLOCK
operator|*
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|POINTBLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|curPtBlock
operator|->
name|next
operator|=
name|tmpPtBlock
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
name|pts
operator|=
name|curPtBlock
operator|->
name|pts
expr_stmt|;
name|numFullPtBlocks
operator|++
expr_stmt|;
name|iPts
operator|=
literal|0
expr_stmt|;
block|}
name|pWETE
operator|=
name|pWETE
operator|->
name|nextWETE
expr_stmt|;
block|}
name|EVALUATEEDGEWINDING
argument_list|(
name|pAET
argument_list|,
name|pPrevAET
argument_list|,
name|y
argument_list|,
name|fixWAET
argument_list|)
expr_stmt|;
block|}
comment|/*              *  recompute the winding active edge table if              *  we just resorted or have exited an edge.              */
if|if
condition|(
name|InsertionSort
argument_list|(
operator|&
name|AET
argument_list|)
operator|||
name|fixWAET
condition|)
block|{
name|computeWAET
argument_list|(
operator|&
name|AET
argument_list|)
expr_stmt|;
name|fixWAET
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
name|FreeStorage
argument_list|(
name|SLLBlock
operator|.
name|next
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PtsToRegion
argument_list|(
name|numFullPtBlocks
argument_list|,
name|iPts
argument_list|,
operator|&
name|FirstPtBlock
argument_list|,
name|region
argument_list|)
expr_stmt|;
for|for
control|(
name|curPtBlock
operator|=
name|FirstPtBlock
operator|.
name|next
init|;
operator|--
name|numFullPtBlocks
operator|>=
literal|0
condition|;
control|)
block|{
name|tmpPtBlock
operator|=
name|curPtBlock
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|curPtBlock
argument_list|)
expr_stmt|;
name|curPtBlock
operator|=
name|tmpPtBlock
expr_stmt|;
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pETEs
argument_list|)
expr_stmt|;
return|return
operator|(
name|region
operator|)
return|;
block|}
end_function

end_unit

