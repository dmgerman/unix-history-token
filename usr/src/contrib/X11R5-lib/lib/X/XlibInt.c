begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: XlibInt.c,v 11.156.1.1 92/11/11 10:10:50 rws Exp $  */
end_comment

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985, 1986, 1987 */
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_comment
comment|/*  *	XlibInternal.c - Internal support routines for the C subroutine  *	interface library (Xlib) to the X Window System Protocol V11.0.  */
end_comment

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_define
define|#
directive|define
name|NEED_REPLIES
end_define

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|"Xlibnet.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function_decl
specifier|static
name|void
name|_EatData32
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* check for both EAGAIN and EWOULDBLOCK, because some supposedly POSIX  * systems are broken and return EWOULDBLOCK when they should return EAGAIN  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EAGAIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
end_if

begin_define
define|#
directive|define
name|ETEST
parameter_list|(
name|err
parameter_list|)
value|(err == EAGAIN || err == EWOULDBLOCK)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|EAGAIN
end_ifdef

begin_define
define|#
directive|define
name|ETEST
parameter_list|(
name|err
parameter_list|)
value|(err == EAGAIN)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ETEST
parameter_list|(
name|err
parameter_list|)
value|(err == EWOULDBLOCK)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LACHMAN
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|EMSGSIZE
end_ifdef

begin_undef
undef|#
directive|undef
name|EMSGSIZE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EMSGSIZE
value|ERANGE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following routines are internal routines used by Xlib for protocol  * packet transmission and reception.  *  * XIOError(Display *) will be called if any sort of system call error occurs.  * This is assumed to be a fatal condition, i.e., XIOError should not return.  *  * XError(Display *, XErrorEvent *) will be called whenever an X_Error event is  * received.  This is not assumed to be a fatal condition, i.e., it is  * acceptable for this procedure to return.  However, XError should NOT  * perform any operations (directly or indirectly) on the DISPLAY.  *  * Routines declared with a return type of 'Status' return 0 on failure,  * and non 0 on success.  Routines with no declared return type don't   * return anything.  Whenever possible routines that create objects return  * the object they have created.  */
end_comment

begin_decl_stmt
specifier|extern
name|_XQEvent
modifier|*
name|_qfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|padlength
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lookup table for adding padding bytes to data that is read from     	or written to the X socket.  */
end_comment

begin_decl_stmt
specifier|static
name|xReq
name|_dummy_request
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * _XFlush - Flush the X request buffer.  If the buffer is empty, no  * action is taken.  This routine correctly handles incremental writes.  * This routine may have to be reworked if int< long.  */
end_comment

begin_expr_stmt
name|_XFlush
argument_list|(
name|dpy
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|long
name|size
decl_stmt|,
name|todo
decl_stmt|;
specifier|register
name|int
name|write_stat
decl_stmt|;
specifier|register
name|char
modifier|*
name|bufindex
decl_stmt|;
if|if
condition|(
name|dpy
operator|->
name|flags
operator|&
name|XlibDisplayIOError
condition|)
return|return;
name|size
operator|=
name|todo
operator|=
name|dpy
operator|->
name|bufptr
operator|-
name|dpy
operator|->
name|buffer
expr_stmt|;
name|bufindex
operator|=
name|dpy
operator|->
name|bufptr
operator|=
name|dpy
operator|->
name|buffer
expr_stmt|;
comment|/* 	 * While write has not written the entire buffer, keep looping 	 * until the entire buffer is written.  bufindex will be incremented 	 * and size decremented as buffer is written out. 	 */
while|while
condition|(
name|size
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|write_stat
operator|=
name|WriteToServer
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|bufindex
argument_list|,
operator|(
name|int
operator|)
name|todo
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_stat
operator|>=
literal|0
condition|)
block|{
name|size
operator|-=
name|write_stat
expr_stmt|;
name|todo
operator|=
name|size
expr_stmt|;
name|bufindex
operator|+=
name|write_stat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ETEST
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|_XWaitForWritable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNSYSV
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
name|_XWaitForWritable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EMSGSIZE
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EMSGSIZE
condition|)
block|{
if|if
condition|(
name|todo
operator|>
literal|1
condition|)
name|todo
operator|>>=
literal|1
expr_stmt|;
else|else
name|_XWaitForWritable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
comment|/* Write failed! */
comment|/* errno set by write system call. */
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
block|}
name|dpy
operator|->
name|last_req
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|_dummy_request
expr_stmt|;
block|}
end_block

begin_function
name|int
name|_XEventsQueued
parameter_list|(
name|dpy
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|pend
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
specifier|register
name|xReply
modifier|*
name|rep
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QueuedAfterFlush
condition|)
block|{
name|_XFlush
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|qlen
condition|)
return|return
operator|(
name|dpy
operator|->
name|qlen
operator|)
return|;
block|}
if|if
condition|(
name|dpy
operator|->
name|flags
operator|&
name|XlibDisplayIOError
condition|)
return|return
operator|(
name|dpy
operator|->
name|qlen
operator|)
return|;
if|if
condition|(
name|BytesReadable
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pend
argument_list|)
operator|<
literal|0
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XCONN_CHECK_FREQ
comment|/* This is a crock, required because FIONREAD or equivalent is 	 * not guaranteed to detect a broken connection. 	 */
if|if
condition|(
operator|!
name|pend
operator|&&
operator|!
name|dpy
operator|->
name|qlen
operator|&&
operator|++
name|dpy
operator|->
name|conn_checker
operator|>=
name|XCONN_CHECK_FREQ
condition|)
block|{
name|unsigned
name|long
name|r_mask
index|[
name|MSKCNT
index|]
decl_stmt|;
specifier|static
name|struct
name|timeval
name|zero_time
decl_stmt|;
name|dpy
operator|->
name|conn_checker
operator|=
literal|0
expr_stmt|;
name|CLEARBITS
argument_list|(
name|r_mask
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|r_mask
argument_list|,
name|dpy
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
operator|=
name|select
argument_list|(
name|dpy
operator|->
name|fd
operator|+
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|r_mask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|zero_time
argument_list|)
condition|)
block|{
if|if
condition|(
name|pend
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|BytesReadable
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pend
argument_list|)
operator|<
literal|0
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
comment|/* we should not get zero, if we do, force a read */
if|if
condition|(
operator|!
name|pend
condition|)
name|pend
operator|=
name|SIZEOF
argument_list|(
name|xReply
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pend
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* XCONN_CHECK_FREQ */
if|if
condition|(
operator|!
operator|(
name|len
operator|=
name|pend
operator|)
condition|)
return|return
operator|(
name|dpy
operator|->
name|qlen
operator|)
return|;
comment|/* _XFlush can enqueue events */
comment|/* Force a read if there is not enough data.  Otherwise,        * a select() loop at a higher-level will spin undesirably,        * and we've seen at least one OS that appears to not update        * the result from FIONREAD once it has returned nonzero.        */
if|if
condition|(
name|len
operator|<
name|SIZEOF
argument_list|(
name|xReply
argument_list|)
condition|)
name|len
operator|=
name|SIZEOF
argument_list|(
name|xReply
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
name|BUFSIZE
condition|)
name|len
operator|=
name|BUFSIZE
expr_stmt|;
name|len
operator|/=
name|SIZEOF
argument_list|(
name|xReply
argument_list|)
expr_stmt|;
name|pend
operator|=
name|len
operator|*
name|SIZEOF
argument_list|(
name|xReply
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XCONN_CHECK_FREQ
name|dpy
operator|->
name|conn_checker
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|_XRead
argument_list|(
name|dpy
argument_list|,
name|buf
argument_list|,
operator|(
name|long
operator|)
name|pend
argument_list|)
expr_stmt|;
comment|/* no space between comma and type or else macro will die */
name|STARTITERATE
argument_list|(
argument|rep
argument_list|,
argument|xReply
argument_list|,
argument|buf
argument_list|,
argument|(len>
literal|0
argument|)
argument_list|,
argument|len--
argument_list|)
block|{
if|if
condition|(
name|rep
operator|->
name|generic
operator|.
name|type
operator|==
name|X_Error
condition|)
name|_XError
argument_list|(
name|dpy
argument_list|,
operator|(
name|xError
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
else|else
comment|/* must be an event packet */
name|_XEnq
argument_list|(
name|dpy
argument_list|,
operator|(
name|xEvent
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
block|}
name|ENDITERATE
return|return
operator|(
name|dpy
operator|->
name|qlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/* _XReadEvents - Flush the output queue,  * then read as many events as possible (but at least 1) and enqueue them  */
end_comment

begin_expr_stmt
name|_XReadEvents
argument_list|(
name|dpy
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|long
name|pend_not_register
decl_stmt|;
comment|/* because can't "&" a register variable */
specifier|register
name|long
name|pend
decl_stmt|;
specifier|register
name|xEvent
modifier|*
name|ev
decl_stmt|;
name|Bool
name|not_yet_flushed
init|=
name|True
decl_stmt|;
do|do
block|{
comment|/* find out how much data can be read */
if|if
condition|(
name|BytesReadable
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pend_not_register
argument_list|)
operator|<
literal|0
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|pend
operator|=
name|pend_not_register
expr_stmt|;
comment|/* must read at least one xEvent; if none is pending, then 	       we'll just flush and block waiting for it */
if|if
condition|(
name|pend
operator|<
name|SIZEOF
argument_list|(
name|xEvent
argument_list|)
condition|)
block|{
name|pend
operator|=
name|SIZEOF
argument_list|(
name|xEvent
argument_list|)
expr_stmt|;
comment|/* don't flush until we block the first time */
if|if
condition|(
name|not_yet_flushed
condition|)
block|{
name|int
name|qlen
init|=
name|dpy
operator|->
name|qlen
decl_stmt|;
name|_XFlush
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|qlen
operator|!=
name|dpy
operator|->
name|qlen
condition|)
return|return;
name|not_yet_flushed
operator|=
name|False
expr_stmt|;
block|}
block|}
comment|/* but we won't read more than the max buffer size */
if|if
condition|(
name|pend
operator|>
name|BUFSIZE
condition|)
name|pend
operator|=
name|BUFSIZE
expr_stmt|;
comment|/* round down to an integral number of XReps */
name|pend
operator|=
operator|(
name|pend
operator|/
name|SIZEOF
argument_list|(
name|xEvent
argument_list|)
operator|)
operator|*
name|SIZEOF
argument_list|(
name|xEvent
argument_list|)
expr_stmt|;
name|_XRead
argument_list|(
name|dpy
argument_list|,
name|buf
argument_list|,
name|pend
argument_list|)
expr_stmt|;
comment|/* no space between comma and type or else macro will die */
name|STARTITERATE
argument_list|(
argument|ev
argument_list|,
argument|xEvent
argument_list|,
argument|buf
argument_list|,
argument|(pend>
literal|0
argument|)
argument_list|,
argument|pend -= SIZEOF(xEvent)
argument_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|==
name|X_Error
condition|)
name|_XError
argument_list|(
name|dpy
argument_list|,
operator|(
name|xError
operator|*
operator|)
name|ev
argument_list|)
expr_stmt|;
else|else
comment|/* it's an event packet; enqueue it */
name|_XEnq
argument_list|(
name|dpy
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
name|ENDITERATE
block|}
do|while
condition|(
name|dpy
operator|->
name|head
operator|==
name|NULL
condition|)
do|;
block|}
end_block

begin_comment
comment|/*   * _XRead - Read bytes from the socket taking into account incomplete  * reads.  This routine may have to be reworked if int< long.  */
end_comment

begin_expr_stmt
name|_XRead
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|bytes_read
decl_stmt|;
if|if
condition|(
operator|(
name|dpy
operator|->
name|flags
operator|&
name|XlibDisplayIOError
operator|)
operator|||
name|size
operator|==
literal|0
condition|)
return|return;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|bytes_read
operator|=
name|ReadFromServer
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|data
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
operator|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|bytes_read
operator|>
literal|0
condition|)
block|{
name|size
operator|-=
name|bytes_read
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ETEST
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|_XWaitForReadable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUNSYSV
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
name|_XWaitForReadable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
block|{
comment|/* Read failed because of end of file! */
name|errno
operator|=
name|EPIPE
expr_stmt|;
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* bytes_read is less than 0; presumably -1 */
block|{
comment|/* If it's a system call interrupt, it's not an error. */
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|WORD64
end_ifdef

begin_comment
comment|/*  * XXX This is a *really* stupid way of doing this....  * PACKBUFFERSIZE must be a multiple of 4.  */
end_comment

begin_define
define|#
directive|define
name|PACKBUFFERSIZE
value|4096
end_define

begin_comment
comment|/*  * _XRead32 - Read bytes from the socket unpacking each 32 bits  *            into a long (64 bits on a CRAY computer).  *   */
end_comment

begin_expr_stmt
specifier|static
name|_doXRead32
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|packbuffer
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|long
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|packbuffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|lpack
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|long
name|mask32
init|=
literal|0x00000000ffffffff
decl_stmt|;
name|long
name|maskw
decl_stmt|,
name|nwords
decl_stmt|,
name|i
decl_stmt|,
name|bits
decl_stmt|;
name|_XReadPad
argument_list|(
name|dpy
argument_list|,
name|packbuffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|lp
operator|=
name|data
expr_stmt|;
name|lpack
operator|=
operator|(
name|long
operator|*
operator|)
name|packbuffer
expr_stmt|;
name|nwords
operator|=
name|size
operator|>>
literal|2
expr_stmt|;
name|bits
operator|=
literal|32
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|maskw
operator|=
name|mask32
operator|<<
name|bits
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
operator|(
operator|*
name|lpack
operator|&
name|maskw
operator|)
operator|>>
name|bits
expr_stmt|;
name|bits
operator|=
name|bits
operator|^
literal|32
expr_stmt|;
if|if
condition|(
name|bits
condition|)
block|{
name|lpack
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|_XRead32
argument_list|(
argument|dpy
argument_list|,
argument|data
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|packbuffer
index|[
name|PACKBUFFERSIZE
index|]
decl_stmt|;
name|unsigned
name|nunits
init|=
name|PACKBUFFERSIZE
operator|>>
literal|2
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
name|PACKBUFFERSIZE
condition|;
name|len
operator|-=
name|PACKBUFFERSIZE
operator|,
name|data
operator|+=
name|nunits
control|)
block|{
name|_doXRead32
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|PACKBUFFERSIZE
argument_list|,
name|packbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
name|_doXRead32
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|packbuffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * _XRead16 - Read bytes from the socket unpacking each 16 bits  *            into a long (64 bits on a CRAY computer).  *  */
end_comment

begin_expr_stmt
specifier|static
name|_doXRead16
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|packbuffer
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|packbuffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|lpack
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|long
name|mask16
init|=
literal|0x000000000000ffff
decl_stmt|;
name|long
name|maskw
decl_stmt|,
name|nwords
decl_stmt|,
name|i
decl_stmt|,
name|bits
decl_stmt|;
name|_XRead
argument_list|(
name|dpy
argument_list|,
name|packbuffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* don't do a padded read... */
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
name|data
expr_stmt|;
name|lpack
operator|=
operator|(
name|long
operator|*
operator|)
name|packbuffer
expr_stmt|;
name|nwords
operator|=
name|size
operator|>>
literal|1
expr_stmt|;
comment|/* number of 16 bit words to be unpacked */
name|bits
operator|=
literal|48
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
name|maskw
operator|=
name|mask16
operator|<<
name|bits
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
operator|(
operator|*
name|lpack
operator|&
name|maskw
operator|)
operator|>>
name|bits
expr_stmt|;
name|bits
operator|-=
literal|16
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|0
condition|)
block|{
name|lpack
operator|++
expr_stmt|;
name|bits
operator|=
literal|48
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|_XRead16
argument_list|(
argument|dpy
argument_list|,
argument|data
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|packbuffer
index|[
name|PACKBUFFERSIZE
index|]
decl_stmt|;
name|unsigned
name|nunits
init|=
name|PACKBUFFERSIZE
operator|>>
literal|1
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
name|PACKBUFFERSIZE
condition|;
name|len
operator|-=
name|PACKBUFFERSIZE
operator|,
name|data
operator|+=
name|nunits
control|)
block|{
name|_doXRead16
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|PACKBUFFERSIZE
argument_list|,
name|packbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
name|_doXRead16
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|packbuffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|_XRead16Pad
argument_list|(
argument|dpy
argument_list|,
argument|data
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|slop
init|=
operator|(
name|size
operator|&
literal|3
operator|)
decl_stmt|;
name|short
name|slopbuf
index|[
literal|3
index|]
decl_stmt|;
name|_XRead16
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|slop
operator|>
literal|0
condition|)
block|{
name|_XRead16
argument_list|(
name|dpy
argument_list|,
name|slopbuf
argument_list|,
literal|4
operator|-
name|slop
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WORD64 */
end_comment

begin_comment
comment|/*  * _XReadPad - Read bytes from the socket taking into account incomplete  * reads.  If the number of bytes is not 0 mod 32, read additional pad  * bytes. This routine may have to be reworked if int< long.  */
end_comment

begin_expr_stmt
name|_XReadPad
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|bytes_read
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|char
name|pad
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|dpy
operator|->
name|flags
operator|&
name|XlibDisplayIOError
operator|)
operator|||
name|size
operator|==
literal|0
condition|)
return|return;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
operator|(
name|int
operator|)
name|size
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|data
expr_stmt|;
comment|/*  	 * The following hack is used to provide 32 bit long-word 	 * aligned padding.  The [1] vector is of length 0, 1, 2, or 3, 	 * whatever is needed. 	 */
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|padlength
index|[
name|size
operator|&
literal|3
index|]
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|pad
expr_stmt|;
name|size
operator|+=
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|bytes_read
operator|=
name|ReadvFromServer
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|bytes_read
operator|>
literal|0
condition|)
block|{
name|size
operator|-=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|-=
name|bytes_read
operator|)
operator|<
literal|0
condition|)
block|{
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|+=
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|-=
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|+=
name|bytes_read
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ETEST
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|_XWaitForReadable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUNSYSV
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
name|_XWaitForReadable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
block|{
comment|/* Read failed because of end of file! */
name|errno
operator|=
name|EPIPE
expr_stmt|;
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* bytes_read is less than 0; presumably -1 */
block|{
comment|/* If it's a system call interrupt, it's not an error. */
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * _XSend - Flush the buffer and send the client data. 32 bit word aligned  * transmission is used, if size is not 0 mod 4, extra bytes are transmitted.  * This routine may have to be reworked if int< long;  */
end_comment

begin_expr_stmt
name|_XSend
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|iovec
name|iov
index|[
literal|3
index|]
decl_stmt|;
specifier|static
name|char
name|pad
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* XText8 and XText16 require that the padding bytes be zero! */
name|long
name|skip
init|=
literal|0
decl_stmt|;
name|long
name|dpybufsize
init|=
operator|(
name|dpy
operator|->
name|bufptr
operator|-
name|dpy
operator|->
name|buffer
operator|)
decl_stmt|;
name|long
name|padsize
init|=
name|padlength
index|[
name|size
operator|&
literal|3
index|]
decl_stmt|;
name|long
name|total
init|=
name|dpybufsize
operator|+
name|size
operator|+
name|padsize
decl_stmt|;
name|long
name|todo
init|=
name|total
decl_stmt|;
if|if
condition|(
name|dpy
operator|->
name|flags
operator|&
name|XlibDisplayIOError
condition|)
return|return;
comment|/* 	 * There are 3 pieces that may need to be written out: 	 * 	 *     o  whatever is in the display buffer 	 *     o  the data passed in by the user 	 *     o  any padding needed to 32bit align the whole mess 	 * 	 * This loop looks at all 3 pieces each time through.  It uses skip 	 * to figure out whether or not a given piece is needed. 	 */
while|while
condition|(
name|total
condition|)
block|{
name|long
name|before
init|=
name|skip
decl_stmt|;
comment|/* amount of whole thing written */
name|long
name|remain
init|=
name|todo
decl_stmt|;
comment|/* amount to try this time,<= total */
name|int
name|i
init|=
literal|0
decl_stmt|;
name|long
name|len
decl_stmt|;
comment|/* You could be very general here and have "in" and "out" iovecs 	     * and write a loop without using a macro, but what the heck.  This 	     * translates to: 	     * 	     *     how much of this piece is new? 	     *     if more new then we are trying this time, clamp 	     *     if nothing new 	     *         then bump down amount already written, for next piece 	     *         else put new stuff in iovec, will need all of next piece 	     * 	     * Note that todo had better be at least 1 or else we'll end up 	     * writing 0 iovecs. 	     */
define|#
directive|define
name|InsertIOV
parameter_list|(
name|pointer
parameter_list|,
name|length
parameter_list|)
define|\
value|len = (length) - before; \ 	    if (len> remain) \ 		len = remain; \ 	    if (len<= 0) { \ 		before = (-len); \ 	    } else { \ 		iov[i].iov_len = len; \ 		iov[i].iov_base = (pointer) + before; \ 		i++; \ 		remain -= len; \ 		before = 0; \ 	    }
name|InsertIOV
argument_list|(
argument|dpy->buffer
argument_list|,
argument|dpybufsize
argument_list|)
name|InsertIOV
argument_list|(
argument|data
argument_list|,
argument|size
argument_list|)
name|InsertIOV
argument_list|(
argument|pad
argument_list|,
argument|padsize
argument_list|)
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|WritevToServer
argument_list|(
name|dpy
operator|->
name|fd
argument_list|,
name|iov
argument_list|,
name|i
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|skip
operator|+=
name|len
expr_stmt|;
name|total
operator|-=
name|len
expr_stmt|;
name|todo
operator|=
name|total
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ETEST
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|_XWaitForWritable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNSYSV
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
name|_XWaitForWritable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EMSGSIZE
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EMSGSIZE
condition|)
block|{
if|if
condition|(
name|todo
operator|>
literal|1
condition|)
name|todo
operator|>>=
literal|1
expr_stmt|;
else|else
name|_XWaitForWritable
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
block|}
name|dpy
operator|->
name|bufptr
operator|=
name|dpy
operator|->
name|buffer
expr_stmt|;
name|dpy
operator|->
name|last_req
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|_dummy_request
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * _XAllocID - normal resource ID allocation routine.  A client  * can roll his own and instatantiate it if he wants, but must  * follow the rules.  */
end_comment

begin_function
name|XID
name|_XAllocID
parameter_list|(
name|dpy
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
block|{
name|XID
name|id
decl_stmt|;
name|id
operator|=
name|dpy
operator|->
name|resource_id
operator|<<
name|dpy
operator|->
name|resource_shift
expr_stmt|;
if|if
condition|(
name|id
operator|<=
name|dpy
operator|->
name|resource_mask
condition|)
block|{
name|dpy
operator|->
name|resource_id
operator|++
expr_stmt|;
return|return
operator|(
name|dpy
operator|->
name|resource_base
operator|+
name|id
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|!=
literal|0x10000000
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Xlib: resource ID allocation space exhausted!\n"
argument_list|)
expr_stmt|;
name|id
operator|=
literal|0x10000000
expr_stmt|;
name|dpy
operator|->
name|resource_id
operator|=
name|id
operator|>>
name|dpy
operator|->
name|resource_shift
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/*  * The hard part about this is that we only get 16 bits from a reply.  Well,  * then, we have three values that will march along, with the following  * invariant:  *	dpy->last_request_read<= rep->sequenceNumber<= dpy->request  * The right choice for rep->sequenceNumber is the largest that  * still meets these constraints.  */
end_comment

begin_function
name|unsigned
name|long
name|_XSetLastRequestRead
parameter_list|(
name|dpy
parameter_list|,
name|rep
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
specifier|register
name|xGenericReply
modifier|*
name|rep
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|newseq
decl_stmt|,
name|lastseq
decl_stmt|;
comment|/*      * KeymapNotify has no sequence number, but is always guaranteed      * to immediately follow another event, except when generated via      * SendEvent (hmmm).      */
if|if
condition|(
operator|(
name|rep
operator|->
name|type
operator|&
literal|0x7f
operator|)
operator|==
name|KeymapNotify
condition|)
return|return
operator|(
name|dpy
operator|->
name|last_request_read
operator|)
return|;
name|newseq
operator|=
operator|(
name|dpy
operator|->
name|last_request_read
operator|&
operator|~
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|0xffff
operator|)
operator|)
operator||
name|rep
operator|->
name|sequenceNumber
expr_stmt|;
name|lastseq
operator|=
name|dpy
operator|->
name|last_request_read
expr_stmt|;
while|while
condition|(
name|newseq
operator|<
name|lastseq
condition|)
block|{
name|newseq
operator|+=
literal|0x10000
expr_stmt|;
if|if
condition|(
name|newseq
operator|>
name|dpy
operator|->
name|request
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Xlib:  sequence lost (0x%lx> 0x%lx) in reply type 0x%x!\n"
argument_list|,
name|newseq
argument_list|,
name|dpy
operator|->
name|request
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rep
operator|->
name|type
argument_list|)
expr_stmt|;
name|newseq
operator|-=
literal|0x10000
expr_stmt|;
break|break;
block|}
block|}
name|dpy
operator|->
name|last_request_read
operator|=
name|newseq
expr_stmt|;
return|return
operator|(
name|newseq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _XReply - Wait for a reply packet and copy its contents into the  * specified rep.  Mean while we must handle error and event packets that  * we may encounter.  */
end_comment

begin_function
name|Status
name|_XReply
parameter_list|(
name|dpy
parameter_list|,
name|rep
parameter_list|,
name|extra
parameter_list|,
name|discard
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
specifier|register
name|xReply
modifier|*
name|rep
decl_stmt|;
name|int
name|extra
decl_stmt|;
comment|/* number of 32-bit words expected after the reply */
name|Bool
name|discard
decl_stmt|;
comment|/* should I discard data following "extra" words? */
block|{
comment|/* Pull out the serial number now, so that (currently illegal) requests      * generated by an error handler don't confuse us.      */
name|unsigned
name|long
name|cur_request
init|=
name|dpy
operator|->
name|request
decl_stmt|;
if|if
condition|(
name|dpy
operator|->
name|flags
operator|&
name|XlibDisplayIOError
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|_XFlush
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|_XRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rep
argument_list|,
operator|(
name|long
operator|)
name|SIZEOF
argument_list|(
name|xReply
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|rep
operator|->
name|generic
operator|.
name|type
condition|)
block|{
case|case
name|X_Reply
case|:
comment|/* Reply received.  Fast update for synchronous replies, 		 * but deal with multiple outstanding replies. 		 */
if|if
condition|(
name|rep
operator|->
name|generic
operator|.
name|sequenceNumber
operator|==
operator|(
name|cur_request
operator|&
literal|0xffff
operator|)
condition|)
name|dpy
operator|->
name|last_request_read
operator|=
name|cur_request
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|_XSetLastRequestRead
argument_list|(
name|dpy
argument_list|,
operator|&
name|rep
operator|->
name|generic
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|discard
operator|&&
operator|(
name|rep
operator|->
name|generic
operator|.
name|length
operator|>
literal|0
operator|)
condition|)
comment|/* unexpectedly long reply! */
name|_EatData32
argument_list|(
name|dpy
argument_list|,
name|rep
operator|->
name|generic
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|extra
operator|==
name|rep
operator|->
name|generic
operator|.
name|length
condition|)
block|{
comment|/*  		     * Read the extra data into storage immediately following 		     * the GenericReply structure.  		     */
name|_XRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|NEXTPTR
argument_list|(
name|rep
argument_list|,
name|xReply
argument_list|)
operator|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|extra
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|extra
operator|<
name|rep
operator|->
name|generic
operator|.
name|length
condition|)
block|{
comment|/* Actual reply is longer than "extra" */
name|_XRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|NEXTPTR
argument_list|(
name|rep
argument_list|,
name|xReply
argument_list|)
operator|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|extra
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|discard
condition|)
name|_EatData32
argument_list|(
name|dpy
argument_list|,
name|rep
operator|->
name|generic
operator|.
name|length
operator|-
name|extra
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  		 *if we get here, then extra> rep->generic.length--meaning we 		 * read a reply that's shorter than we expected.  This is an  		 * error,  but we still need to figure out how to handle it... 		 */
name|_XRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|NEXTPTR
argument_list|(
name|rep
argument_list|,
name|xReply
argument_list|)
operator|)
argument_list|,
operator|(
operator|(
name|long
operator|)
name|rep
operator|->
name|generic
operator|.
name|length
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|X_Error
case|:
block|{
specifier|register
name|_XExtension
modifier|*
name|ext
decl_stmt|;
specifier|register
name|Bool
name|ret
init|=
name|False
decl_stmt|;
name|int
name|ret_code
decl_stmt|;
name|xError
modifier|*
name|err
init|=
operator|(
name|xError
operator|*
operator|)
name|rep
decl_stmt|;
name|unsigned
name|long
name|serial
decl_stmt|;
name|serial
operator|=
name|_XSetLastRequestRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|xGenericReply
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial
operator|==
name|cur_request
condition|)
comment|/* do not die on "no such font", "can't allocate", 			   "can't grab" failures */
switch|switch
condition|(
operator|(
name|int
operator|)
name|err
operator|->
name|errorCode
condition|)
block|{
case|case
name|BadName
case|:
switch|switch
condition|(
name|err
operator|->
name|majorCode
condition|)
block|{
case|case
name|X_OpenFont
case|:
case|case
name|X_LookupColor
case|:
case|case
name|X_AllocNamedColor
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|BadFont
case|:
if|if
condition|(
name|err
operator|->
name|majorCode
operator|==
name|X_QueryFont
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|BadAlloc
case|:
case|case
name|BadAccess
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  		 * we better see if there is an extension who may 		 * want to suppress the error. 		 */
for|for
control|(
name|ext
operator|=
name|dpy
operator|->
name|ext_procs
init|;
operator|!
name|ret
operator|&&
name|ext
condition|;
name|ext
operator|=
name|ext
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ext
operator|->
name|error
condition|)
name|ret
operator|=
call|(
modifier|*
name|ext
operator|->
name|error
call|)
argument_list|(
name|dpy
argument_list|,
name|err
argument_list|,
operator|&
name|ext
operator|->
name|codes
argument_list|,
operator|&
name|ret_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|_XError
argument_list|(
name|dpy
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ret_code
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|serial
operator|==
name|cur_request
condition|)
return|return
operator|(
name|ret_code
operator|)
return|;
block|}
break|break;
default|default:
name|_XEnq
argument_list|(
name|dpy
argument_list|,
operator|(
name|xEvent
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read and discard "n" 8-bit bytes of data */
end_comment

begin_function
name|void
name|_XEatData
parameter_list|(
name|dpy
parameter_list|,
name|n
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
specifier|register
name|unsigned
name|long
name|n
decl_stmt|;
block|{
define|#
directive|define
name|SCRATCHSIZE
value|2048
name|char
name|buf
index|[
name|SCRATCHSIZE
index|]
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
specifier|register
name|long
name|bytes_read
init|=
operator|(
name|n
operator|>
name|SCRATCHSIZE
operator|)
condition|?
name|SCRATCHSIZE
else|:
name|n
decl_stmt|;
name|_XRead
argument_list|(
name|dpy
argument_list|,
name|buf
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|n
operator|-=
name|bytes_read
expr_stmt|;
block|}
undef|#
directive|undef
name|SCRATCHSIZE
block|}
end_function

begin_comment
comment|/* Read and discard "n" 32-bit words. */
end_comment

begin_function
specifier|static
name|void
name|_EatData32
parameter_list|(
name|dpy
parameter_list|,
name|n
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
block|{
name|_XEatData
argument_list|(
name|dpy
argument_list|,
name|n
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * _XEnq - Place event packets on the display's queue.  * note that no squishing of move events in V11, since there  * is pointer motion hints....  */
end_comment

begin_expr_stmt
name|_XEnq
argument_list|(
name|dpy
argument_list|,
name|event
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|xEvent
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|_XQEvent
modifier|*
name|qelt
decl_stmt|;
comment|/*NOSTRICT*/
if|if
condition|(
name|qelt
operator|=
name|_qfree
condition|)
block|{
comment|/* If _qfree is non-NULL do this, else malloc a new one. */
name|_qfree
operator|=
name|qelt
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|qelt
operator|=
operator|(
name|_XQEvent
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|_XQEvent
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Malloc call failed! */
name|errno
operator|=
name|ENOMEM
expr_stmt|;
name|_XIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
name|qelt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* go call through display to find proper event reformatter */
if|if
condition|(
call|(
modifier|*
name|dpy
operator|->
name|event_vec
index|[
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|&
literal|0177
index|]
call|)
argument_list|(
name|dpy
argument_list|,
operator|&
name|qelt
operator|->
name|event
argument_list|,
name|event
argument_list|)
condition|)
block|{
if|if
condition|(
name|dpy
operator|->
name|tail
condition|)
name|dpy
operator|->
name|tail
operator|->
name|next
operator|=
name|qelt
expr_stmt|;
else|else
name|dpy
operator|->
name|head
operator|=
name|qelt
expr_stmt|;
name|dpy
operator|->
name|tail
operator|=
name|qelt
expr_stmt|;
name|dpy
operator|->
name|qlen
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* ignored, or stashed away for many-to-one compression */
name|qelt
operator|->
name|next
operator|=
name|_qfree
expr_stmt|;
name|_qfree
operator|=
name|qelt
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * EventToWire in separate file in that often not needed.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|Bool
name|_XUnknownWireEvent
parameter_list|(
name|dpy
parameter_list|,
name|re
parameter_list|,
name|event
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
comment|/* pointer to display structure */
specifier|register
name|XEvent
modifier|*
name|re
decl_stmt|;
comment|/* pointer to where event should be reformatted */
specifier|register
name|xEvent
modifier|*
name|event
decl_stmt|;
comment|/* wire protocol event */
block|{
ifdef|#
directive|ifdef
name|notdef
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Xlib: unhandled wire event! event number = %d, display = %x\n."
argument_list|,
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|type
argument_list|,
name|dpy
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|False
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|Status
name|_XUnknownNativeEvent
parameter_list|(
name|dpy
parameter_list|,
name|re
parameter_list|,
name|event
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
comment|/* pointer to display structure */
specifier|register
name|XEvent
modifier|*
name|re
decl_stmt|;
comment|/* pointer to where event should be reformatted */
specifier|register
name|xEvent
modifier|*
name|event
decl_stmt|;
comment|/* wire protocol event */
block|{
ifdef|#
directive|ifdef
name|notdef
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Xlib: unhandled native event! event number = %d, display = %x\n."
argument_list|,
name|re
operator|->
name|type
argument_list|,
name|dpy
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reformat a wire event into an XEvent structure of the right type.  */
end_comment

begin_function
name|Bool
name|_XWireToEvent
parameter_list|(
name|dpy
parameter_list|,
name|re
parameter_list|,
name|event
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
comment|/* pointer to display structure */
specifier|register
name|XEvent
modifier|*
name|re
decl_stmt|;
comment|/* pointer to where event should be reformatted */
specifier|register
name|xEvent
modifier|*
name|event
decl_stmt|;
comment|/* wire protocol event */
block|{
name|re
operator|->
name|type
operator|=
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|&
literal|0x7f
expr_stmt|;
operator|(
operator|(
name|XAnyEvent
operator|*
operator|)
name|re
operator|)
operator|->
name|serial
operator|=
name|_XSetLastRequestRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|xGenericReply
operator|*
operator|)
name|event
argument_list|)
expr_stmt|;
operator|(
operator|(
name|XAnyEvent
operator|*
operator|)
name|re
operator|)
operator|->
name|send_event
operator|=
operator|(
operator|(
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|&
literal|0x80
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
operator|(
operator|(
name|XAnyEvent
operator|*
operator|)
name|re
operator|)
operator|->
name|display
operator|=
name|dpy
expr_stmt|;
comment|/* Ignore the leading bit of the event type since it is set when a 		client sends an event rather than the server. */
switch|switch
condition|(
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|&
literal|0177
condition|)
block|{
case|case
name|KeyPress
case|:
case|case
name|KeyRelease
case|:
block|{
specifier|register
name|XKeyEvent
modifier|*
name|ev
init|=
operator|(
name|XKeyEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|root
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|root
expr_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|subwindow
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|child
expr_stmt|;
name|ev
operator|->
name|time
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|time
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|eventX
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|eventY
argument_list|)
expr_stmt|;
name|ev
operator|->
name|x_root
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootX
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y_root
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootY
argument_list|)
expr_stmt|;
name|ev
operator|->
name|state
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|state
expr_stmt|;
name|ev
operator|->
name|same_screen
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|sameScreen
expr_stmt|;
name|ev
operator|->
name|keycode
operator|=
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|detail
expr_stmt|;
block|}
break|break;
case|case
name|ButtonPress
case|:
case|case
name|ButtonRelease
case|:
block|{
specifier|register
name|XButtonEvent
modifier|*
name|ev
init|=
operator|(
name|XButtonEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|root
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|root
expr_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|subwindow
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|child
expr_stmt|;
name|ev
operator|->
name|time
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|time
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|eventX
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|eventY
argument_list|)
expr_stmt|;
name|ev
operator|->
name|x_root
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootX
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y_root
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootY
argument_list|)
expr_stmt|;
name|ev
operator|->
name|state
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|state
expr_stmt|;
name|ev
operator|->
name|same_screen
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|sameScreen
expr_stmt|;
name|ev
operator|->
name|button
operator|=
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|detail
expr_stmt|;
block|}
break|break;
case|case
name|MotionNotify
case|:
block|{
specifier|register
name|XMotionEvent
modifier|*
name|ev
init|=
operator|(
name|XMotionEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|root
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|root
expr_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|subwindow
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|child
expr_stmt|;
name|ev
operator|->
name|time
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|time
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|eventX
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|eventY
argument_list|)
expr_stmt|;
name|ev
operator|->
name|x_root
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootX
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y_root
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootY
argument_list|)
expr_stmt|;
name|ev
operator|->
name|state
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|state
expr_stmt|;
name|ev
operator|->
name|same_screen
operator|=
name|event
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|sameScreen
expr_stmt|;
name|ev
operator|->
name|is_hint
operator|=
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|detail
expr_stmt|;
block|}
break|break;
case|case
name|EnterNotify
case|:
case|case
name|LeaveNotify
case|:
block|{
specifier|register
name|XCrossingEvent
modifier|*
name|ev
init|=
operator|(
name|XCrossingEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|root
operator|=
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|root
expr_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|subwindow
operator|=
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|child
expr_stmt|;
name|ev
operator|->
name|time
operator|=
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|time
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|eventX
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|eventY
argument_list|)
expr_stmt|;
name|ev
operator|->
name|x_root
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|rootX
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y_root
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|rootY
argument_list|)
expr_stmt|;
name|ev
operator|->
name|state
operator|=
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|state
expr_stmt|;
name|ev
operator|->
name|mode
operator|=
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|mode
expr_stmt|;
name|ev
operator|->
name|same_screen
operator|=
operator|(
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|flags
operator|&
name|ELFlagSameScreen
operator|)
operator|&&
name|True
expr_stmt|;
name|ev
operator|->
name|focus
operator|=
operator|(
name|event
operator|->
name|u
operator|.
name|enterLeave
operator|.
name|flags
operator|&
name|ELFlagFocus
operator|)
operator|&&
name|True
expr_stmt|;
name|ev
operator|->
name|detail
operator|=
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|detail
expr_stmt|;
block|}
break|break;
case|case
name|FocusIn
case|:
case|case
name|FocusOut
case|:
block|{
specifier|register
name|XFocusChangeEvent
modifier|*
name|ev
init|=
operator|(
name|XFocusChangeEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|focus
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|mode
operator|=
name|event
operator|->
name|u
operator|.
name|focus
operator|.
name|mode
expr_stmt|;
name|ev
operator|->
name|detail
operator|=
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|detail
expr_stmt|;
block|}
break|break;
case|case
name|KeymapNotify
case|:
block|{
specifier|register
name|XKeymapEvent
modifier|*
name|ev
init|=
operator|(
name|XKeymapEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|dpy
operator|->
name|current
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|xKeymapEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|map
argument_list|,
operator|&
name|ev
operator|->
name|key_vector
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|xKeymapEvent
operator|*
operator|)
name|event
operator|)
operator|->
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Expose
case|:
block|{
specifier|register
name|XExposeEvent
modifier|*
name|ev
init|=
operator|(
name|XExposeEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|expose
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|event
operator|->
name|u
operator|.
name|expose
operator|.
name|x
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|event
operator|->
name|u
operator|.
name|expose
operator|.
name|y
expr_stmt|;
name|ev
operator|->
name|width
operator|=
name|event
operator|->
name|u
operator|.
name|expose
operator|.
name|width
expr_stmt|;
name|ev
operator|->
name|height
operator|=
name|event
operator|->
name|u
operator|.
name|expose
operator|.
name|height
expr_stmt|;
name|ev
operator|->
name|count
operator|=
name|event
operator|->
name|u
operator|.
name|expose
operator|.
name|count
expr_stmt|;
block|}
break|break;
case|case
name|GraphicsExpose
case|:
block|{
specifier|register
name|XGraphicsExposeEvent
modifier|*
name|ev
init|=
operator|(
name|XGraphicsExposeEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|drawable
operator|=
name|event
operator|->
name|u
operator|.
name|graphicsExposure
operator|.
name|drawable
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|event
operator|->
name|u
operator|.
name|graphicsExposure
operator|.
name|x
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|event
operator|->
name|u
operator|.
name|graphicsExposure
operator|.
name|y
expr_stmt|;
name|ev
operator|->
name|width
operator|=
name|event
operator|->
name|u
operator|.
name|graphicsExposure
operator|.
name|width
expr_stmt|;
name|ev
operator|->
name|height
operator|=
name|event
operator|->
name|u
operator|.
name|graphicsExposure
operator|.
name|height
expr_stmt|;
name|ev
operator|->
name|count
operator|=
name|event
operator|->
name|u
operator|.
name|graphicsExposure
operator|.
name|count
expr_stmt|;
name|ev
operator|->
name|major_code
operator|=
name|event
operator|->
name|u
operator|.
name|graphicsExposure
operator|.
name|majorEvent
expr_stmt|;
name|ev
operator|->
name|minor_code
operator|=
name|event
operator|->
name|u
operator|.
name|graphicsExposure
operator|.
name|minorEvent
expr_stmt|;
block|}
break|break;
case|case
name|NoExpose
case|:
block|{
specifier|register
name|XNoExposeEvent
modifier|*
name|ev
init|=
operator|(
name|XNoExposeEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|drawable
operator|=
name|event
operator|->
name|u
operator|.
name|noExposure
operator|.
name|drawable
expr_stmt|;
name|ev
operator|->
name|major_code
operator|=
name|event
operator|->
name|u
operator|.
name|noExposure
operator|.
name|majorEvent
expr_stmt|;
name|ev
operator|->
name|minor_code
operator|=
name|event
operator|->
name|u
operator|.
name|noExposure
operator|.
name|minorEvent
expr_stmt|;
block|}
break|break;
case|case
name|VisibilityNotify
case|:
block|{
specifier|register
name|XVisibilityEvent
modifier|*
name|ev
init|=
operator|(
name|XVisibilityEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|visibility
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|state
operator|=
name|event
operator|->
name|u
operator|.
name|visibility
operator|.
name|state
expr_stmt|;
block|}
break|break;
case|case
name|CreateNotify
case|:
block|{
specifier|register
name|XCreateWindowEvent
modifier|*
name|ev
init|=
operator|(
name|XCreateWindowEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|createNotify
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|parent
operator|=
name|event
operator|->
name|u
operator|.
name|createNotify
operator|.
name|parent
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|createNotify
operator|.
name|x
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|createNotify
operator|.
name|y
argument_list|)
expr_stmt|;
name|ev
operator|->
name|width
operator|=
name|event
operator|->
name|u
operator|.
name|createNotify
operator|.
name|width
expr_stmt|;
name|ev
operator|->
name|height
operator|=
name|event
operator|->
name|u
operator|.
name|createNotify
operator|.
name|height
expr_stmt|;
name|ev
operator|->
name|border_width
operator|=
name|event
operator|->
name|u
operator|.
name|createNotify
operator|.
name|borderWidth
expr_stmt|;
name|ev
operator|->
name|override_redirect
operator|=
name|event
operator|->
name|u
operator|.
name|createNotify
operator|.
name|override
expr_stmt|;
block|}
break|break;
case|case
name|DestroyNotify
case|:
block|{
specifier|register
name|XDestroyWindowEvent
modifier|*
name|ev
init|=
operator|(
name|XDestroyWindowEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|destroyNotify
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|event
operator|=
name|event
operator|->
name|u
operator|.
name|destroyNotify
operator|.
name|event
expr_stmt|;
block|}
break|break;
case|case
name|UnmapNotify
case|:
block|{
specifier|register
name|XUnmapEvent
modifier|*
name|ev
init|=
operator|(
name|XUnmapEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|unmapNotify
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|event
operator|=
name|event
operator|->
name|u
operator|.
name|unmapNotify
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|from_configure
operator|=
name|event
operator|->
name|u
operator|.
name|unmapNotify
operator|.
name|fromConfigure
expr_stmt|;
block|}
break|break;
case|case
name|MapNotify
case|:
block|{
specifier|register
name|XMapEvent
modifier|*
name|ev
init|=
operator|(
name|XMapEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|mapNotify
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|event
operator|=
name|event
operator|->
name|u
operator|.
name|mapNotify
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|override_redirect
operator|=
name|event
operator|->
name|u
operator|.
name|mapNotify
operator|.
name|override
expr_stmt|;
block|}
break|break;
case|case
name|MapRequest
case|:
block|{
specifier|register
name|XMapRequestEvent
modifier|*
name|ev
init|=
operator|(
name|XMapRequestEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|mapRequest
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|parent
operator|=
name|event
operator|->
name|u
operator|.
name|mapRequest
operator|.
name|parent
expr_stmt|;
block|}
break|break;
case|case
name|ReparentNotify
case|:
block|{
specifier|register
name|XReparentEvent
modifier|*
name|ev
init|=
operator|(
name|XReparentEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|event
operator|=
name|event
operator|->
name|u
operator|.
name|reparent
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|reparent
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|parent
operator|=
name|event
operator|->
name|u
operator|.
name|reparent
operator|.
name|parent
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|reparent
operator|.
name|x
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|reparent
operator|.
name|y
argument_list|)
expr_stmt|;
name|ev
operator|->
name|override_redirect
operator|=
name|event
operator|->
name|u
operator|.
name|reparent
operator|.
name|override
expr_stmt|;
block|}
break|break;
case|case
name|ConfigureNotify
case|:
block|{
specifier|register
name|XConfigureEvent
modifier|*
name|ev
init|=
operator|(
name|XConfigureEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|event
operator|=
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|above
operator|=
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|aboveSibling
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|x
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|y
argument_list|)
expr_stmt|;
name|ev
operator|->
name|width
operator|=
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|width
expr_stmt|;
name|ev
operator|->
name|height
operator|=
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|height
expr_stmt|;
name|ev
operator|->
name|border_width
operator|=
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|borderWidth
expr_stmt|;
name|ev
operator|->
name|override_redirect
operator|=
name|event
operator|->
name|u
operator|.
name|configureNotify
operator|.
name|override
expr_stmt|;
block|}
break|break;
case|case
name|ConfigureRequest
case|:
block|{
specifier|register
name|XConfigureRequestEvent
modifier|*
name|ev
init|=
operator|(
name|XConfigureRequestEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|parent
operator|=
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|parent
expr_stmt|;
name|ev
operator|->
name|above
operator|=
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|sibling
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|x
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|y
argument_list|)
expr_stmt|;
name|ev
operator|->
name|width
operator|=
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|width
expr_stmt|;
name|ev
operator|->
name|height
operator|=
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|height
expr_stmt|;
name|ev
operator|->
name|border_width
operator|=
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|borderWidth
expr_stmt|;
name|ev
operator|->
name|value_mask
operator|=
name|event
operator|->
name|u
operator|.
name|configureRequest
operator|.
name|valueMask
expr_stmt|;
name|ev
operator|->
name|detail
operator|=
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|detail
expr_stmt|;
block|}
break|break;
case|case
name|GravityNotify
case|:
block|{
specifier|register
name|XGravityEvent
modifier|*
name|ev
init|=
operator|(
name|XGravityEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|gravity
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|event
operator|=
name|event
operator|->
name|u
operator|.
name|gravity
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|x
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|gravity
operator|.
name|x
argument_list|)
expr_stmt|;
name|ev
operator|->
name|y
operator|=
name|cvtINT16toInt
argument_list|(
name|event
operator|->
name|u
operator|.
name|gravity
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ResizeRequest
case|:
block|{
specifier|register
name|XResizeRequestEvent
modifier|*
name|ev
init|=
operator|(
name|XResizeRequestEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|resizeRequest
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|width
operator|=
name|event
operator|->
name|u
operator|.
name|resizeRequest
operator|.
name|width
expr_stmt|;
name|ev
operator|->
name|height
operator|=
name|event
operator|->
name|u
operator|.
name|resizeRequest
operator|.
name|height
expr_stmt|;
block|}
break|break;
case|case
name|CirculateNotify
case|:
block|{
specifier|register
name|XCirculateEvent
modifier|*
name|ev
init|=
operator|(
name|XCirculateEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|circulate
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|event
operator|=
name|event
operator|->
name|u
operator|.
name|circulate
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|place
operator|=
name|event
operator|->
name|u
operator|.
name|circulate
operator|.
name|place
expr_stmt|;
block|}
break|break;
case|case
name|CirculateRequest
case|:
block|{
specifier|register
name|XCirculateRequestEvent
modifier|*
name|ev
init|=
operator|(
name|XCirculateRequestEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|circulate
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|parent
operator|=
name|event
operator|->
name|u
operator|.
name|circulate
operator|.
name|event
expr_stmt|;
name|ev
operator|->
name|place
operator|=
name|event
operator|->
name|u
operator|.
name|circulate
operator|.
name|place
expr_stmt|;
block|}
break|break;
case|case
name|PropertyNotify
case|:
block|{
specifier|register
name|XPropertyEvent
modifier|*
name|ev
init|=
operator|(
name|XPropertyEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|property
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|atom
operator|=
name|event
operator|->
name|u
operator|.
name|property
operator|.
name|atom
expr_stmt|;
name|ev
operator|->
name|time
operator|=
name|event
operator|->
name|u
operator|.
name|property
operator|.
name|time
expr_stmt|;
name|ev
operator|->
name|state
operator|=
name|event
operator|->
name|u
operator|.
name|property
operator|.
name|state
expr_stmt|;
block|}
break|break;
case|case
name|SelectionClear
case|:
block|{
specifier|register
name|XSelectionClearEvent
modifier|*
name|ev
init|=
operator|(
name|XSelectionClearEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|selectionClear
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|selection
operator|=
name|event
operator|->
name|u
operator|.
name|selectionClear
operator|.
name|atom
expr_stmt|;
name|ev
operator|->
name|time
operator|=
name|event
operator|->
name|u
operator|.
name|selectionClear
operator|.
name|time
expr_stmt|;
block|}
break|break;
case|case
name|SelectionRequest
case|:
block|{
specifier|register
name|XSelectionRequestEvent
modifier|*
name|ev
init|=
operator|(
name|XSelectionRequestEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|owner
operator|=
name|event
operator|->
name|u
operator|.
name|selectionRequest
operator|.
name|owner
expr_stmt|;
name|ev
operator|->
name|requestor
operator|=
name|event
operator|->
name|u
operator|.
name|selectionRequest
operator|.
name|requestor
expr_stmt|;
name|ev
operator|->
name|selection
operator|=
name|event
operator|->
name|u
operator|.
name|selectionRequest
operator|.
name|selection
expr_stmt|;
name|ev
operator|->
name|target
operator|=
name|event
operator|->
name|u
operator|.
name|selectionRequest
operator|.
name|target
expr_stmt|;
name|ev
operator|->
name|property
operator|=
name|event
operator|->
name|u
operator|.
name|selectionRequest
operator|.
name|property
expr_stmt|;
name|ev
operator|->
name|time
operator|=
name|event
operator|->
name|u
operator|.
name|selectionRequest
operator|.
name|time
expr_stmt|;
block|}
break|break;
case|case
name|SelectionNotify
case|:
block|{
specifier|register
name|XSelectionEvent
modifier|*
name|ev
init|=
operator|(
name|XSelectionEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|requestor
operator|=
name|event
operator|->
name|u
operator|.
name|selectionNotify
operator|.
name|requestor
expr_stmt|;
name|ev
operator|->
name|selection
operator|=
name|event
operator|->
name|u
operator|.
name|selectionNotify
operator|.
name|selection
expr_stmt|;
name|ev
operator|->
name|target
operator|=
name|event
operator|->
name|u
operator|.
name|selectionNotify
operator|.
name|target
expr_stmt|;
name|ev
operator|->
name|property
operator|=
name|event
operator|->
name|u
operator|.
name|selectionNotify
operator|.
name|property
expr_stmt|;
name|ev
operator|->
name|time
operator|=
name|event
operator|->
name|u
operator|.
name|selectionNotify
operator|.
name|time
expr_stmt|;
block|}
break|break;
case|case
name|ColormapNotify
case|:
block|{
specifier|register
name|XColormapEvent
modifier|*
name|ev
init|=
operator|(
name|XColormapEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|colormap
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|colormap
operator|=
name|event
operator|->
name|u
operator|.
name|colormap
operator|.
name|colormap
expr_stmt|;
name|ev
operator|->
name|new
operator|=
name|event
operator|->
name|u
operator|.
name|colormap
operator|.
name|new
expr_stmt|;
name|ev
operator|->
name|state
operator|=
name|event
operator|->
name|u
operator|.
name|colormap
operator|.
name|state
expr_stmt|;
block|}
break|break;
case|case
name|ClientMessage
case|:
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|XClientMessageEvent
modifier|*
name|ev
init|=
operator|(
name|XClientMessageEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|window
expr_stmt|;
name|ev
operator|->
name|format
operator|=
name|event
operator|->
name|u
operator|.
name|u
operator|.
name|detail
expr_stmt|;
switch|switch
condition|(
name|ev
operator|->
name|format
condition|)
block|{
case|case
literal|8
case|:
name|ev
operator|->
name|message_type
operator|=
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|b
operator|.
name|type
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|ev
operator|->
name|data
operator|.
name|b
index|[
name|i
index|]
operator|=
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|b
operator|.
name|bytes
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|ev
operator|->
name|message_type
operator|=
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|type
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts0
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts1
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|2
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts2
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|3
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts3
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|4
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts4
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|5
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts5
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|6
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts6
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|7
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts7
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|8
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts8
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|s
index|[
literal|9
index|]
operator|=
name|cvtINT16toShort
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|s
operator|.
name|shorts9
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|ev
operator|->
name|message_type
operator|=
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|l
operator|.
name|type
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|l
index|[
literal|0
index|]
operator|=
name|cvtINT32toLong
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|l
operator|.
name|longs0
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|l
index|[
literal|1
index|]
operator|=
name|cvtINT32toLong
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|l
operator|.
name|longs1
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|l
index|[
literal|2
index|]
operator|=
name|cvtINT32toLong
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|l
operator|.
name|longs2
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|l
index|[
literal|3
index|]
operator|=
name|cvtINT32toLong
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|l
operator|.
name|longs3
argument_list|)
expr_stmt|;
name|ev
operator|->
name|data
operator|.
name|l
index|[
literal|4
index|]
operator|=
name|cvtINT32toLong
argument_list|(
name|event
operator|->
name|u
operator|.
name|clientMessage
operator|.
name|u
operator|.
name|l
operator|.
name|longs4
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* XXX should never occur */
break|break;
block|}
block|}
break|break;
case|case
name|MappingNotify
case|:
block|{
specifier|register
name|XMappingEvent
modifier|*
name|ev
init|=
operator|(
name|XMappingEvent
operator|*
operator|)
name|re
decl_stmt|;
name|ev
operator|->
name|window
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|first_keycode
operator|=
name|event
operator|->
name|u
operator|.
name|mappingNotify
operator|.
name|firstKeyCode
expr_stmt|;
name|ev
operator|->
name|request
operator|=
name|event
operator|->
name|u
operator|.
name|mappingNotify
operator|.
name|request
expr_stmt|;
name|ev
operator|->
name|count
operator|=
name|event
operator|->
name|u
operator|.
name|mappingNotify
operator|.
name|count
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|_XUnknownWireEvent
argument_list|(
name|dpy
argument_list|,
name|re
argument_list|,
name|event
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|True
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|USL_SHARELIB
end_ifndef

begin_function
specifier|static
name|char
modifier|*
name|_SysErrorMsg
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
operator|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|n
index|]
else|:
literal|"unknown error"
operator|)
decl_stmt|;
return|return
operator|(
name|s
condition|?
name|s
else|:
literal|"no such error"
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USL sharedlibs in don't define for SVR3.2 */
end_comment

begin_comment
comment|/*  * _XDefaultIOError - Default fatal system error reporting routine.  Called   * when an X internal system error is encountered.  */
end_comment

begin_macro
name|_XDefaultIOError
argument_list|(
argument|dpy
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XIO:  fatal IO error %d (%s) on X server \"%s\"\r\n"
argument_list|,
name|errno
argument_list|,
name|_SysErrorMsg
argument_list|(
name|errno
argument_list|)
argument_list|,
name|DisplayString
argument_list|(
name|dpy
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      after %lu requests (%lu known processed) with %d events remaining.\r\n"
argument_list|,
name|NextRequest
argument_list|(
name|dpy
argument_list|)
operator|-
literal|1
argument_list|,
name|LastKnownRequestProcessed
argument_list|(
name|dpy
argument_list|)
argument_list|,
name|QLength
argument_list|(
name|dpy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      The connection was probably broken by a server shutdown or KillClient.\r\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|_XPrintDefaultError
parameter_list|(
name|dpy
parameter_list|,
name|event
parameter_list|,
name|fp
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|XErrorEvent
modifier|*
name|event
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|mesg
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|number
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|mtype
init|=
literal|"XlibMessage"
decl_stmt|;
specifier|register
name|_XExtension
modifier|*
name|ext
init|=
operator|(
name|_XExtension
operator|*
operator|)
name|NULL
decl_stmt|;
name|_XExtension
modifier|*
name|bext
init|=
operator|(
name|_XExtension
operator|*
operator|)
name|NULL
decl_stmt|;
name|XGetErrorText
argument_list|(
name|dpy
argument_list|,
name|event
operator|->
name|error_code
argument_list|,
name|buffer
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
literal|"XError"
argument_list|,
literal|"X Error"
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s:  %s\n  "
argument_list|,
name|mesg
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
literal|"MajorCode"
argument_list|,
literal|"Request Major code %d"
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|mesg
argument_list|,
name|event
operator|->
name|request_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|request_code
operator|<
literal|128
condition|)
block|{
name|sprintf
argument_list|(
name|number
argument_list|,
literal|"%d"
argument_list|,
name|event
operator|->
name|request_code
argument_list|)
expr_stmt|;
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
literal|"XRequest"
argument_list|,
name|number
argument_list|,
literal|""
argument_list|,
name|buffer
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ext
operator|=
name|dpy
operator|->
name|ext_procs
init|;
name|ext
operator|&&
operator|(
name|ext
operator|->
name|codes
operator|.
name|major_opcode
operator|!=
name|event
operator|->
name|request_code
operator|)
condition|;
name|ext
operator|=
name|ext
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|ext
condition|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|ext
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" (%s)\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|request_code
operator|>=
literal|128
condition|)
block|{
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
literal|"MinorCode"
argument_list|,
literal|"Request Minor code %d"
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|mesg
argument_list|,
name|event
operator|->
name|minor_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
condition|)
block|{
name|sprintf
argument_list|(
name|mesg
argument_list|,
literal|"%s.%d"
argument_list|,
name|ext
operator|->
name|name
argument_list|,
name|event
operator|->
name|minor_code
argument_list|)
expr_stmt|;
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
literal|"XRequest"
argument_list|,
name|mesg
argument_list|,
literal|""
argument_list|,
name|buffer
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" (%s)"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|->
name|error_code
operator|>=
literal|128
condition|)
block|{
comment|/* kludge, try to find the extension that caused it */
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ext
operator|=
name|dpy
operator|->
name|ext_procs
init|;
name|ext
condition|;
name|ext
operator|=
name|ext
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ext
operator|->
name|error_string
condition|)
call|(
modifier|*
name|ext
operator|->
name|error_string
call|)
argument_list|(
name|dpy
argument_list|,
name|event
operator|->
name|error_code
argument_list|,
operator|&
name|ext
operator|->
name|codes
argument_list|,
name|buffer
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
block|{
name|bext
operator|=
name|ext
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ext
operator|->
name|codes
operator|.
name|first_error
operator|&&
name|ext
operator|->
name|codes
operator|.
name|first_error
operator|<
name|event
operator|->
name|error_code
operator|&&
operator|(
operator|!
name|bext
operator|||
name|ext
operator|->
name|codes
operator|.
name|first_error
operator|>
name|bext
operator|->
name|codes
operator|.
name|first_error
operator|)
condition|)
name|bext
operator|=
name|ext
expr_stmt|;
block|}
if|if
condition|(
name|bext
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s.%d"
argument_list|,
name|bext
operator|->
name|name
argument_list|,
name|event
operator|->
name|error_code
operator|-
name|bext
operator|->
name|codes
operator|.
name|first_error
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"Value"
argument_list|)
expr_stmt|;
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
name|buffer
argument_list|,
literal|""
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesg
index|[
literal|0
index|]
condition|)
block|{
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|mesg
argument_list|,
name|event
operator|->
name|resourceid
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* let extensions try to print the values */
for|for
control|(
name|ext
operator|=
name|dpy
operator|->
name|ext_procs
init|;
name|ext
condition|;
name|ext
operator|=
name|ext
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ext
operator|->
name|error_values
condition|)
call|(
modifier|*
name|ext
operator|->
name|error_values
call|)
argument_list|(
name|dpy
argument_list|,
name|event
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadWindow
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadPixmap
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadCursor
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadFont
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadDrawable
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadColor
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadGC
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadIDChoice
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadValue
operator|)
operator|||
operator|(
name|event
operator|->
name|error_code
operator|==
name|BadAtom
operator|)
condition|)
block|{
if|if
condition|(
name|event
operator|->
name|error_code
operator|==
name|BadValue
condition|)
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
literal|"Value"
argument_list|,
literal|"Value 0x%x"
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|->
name|error_code
operator|==
name|BadAtom
condition|)
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
literal|"AtomID"
argument_list|,
literal|"AtomID 0x%x"
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|else
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
literal|"ResourceID"
argument_list|,
literal|"ResourceID 0x%x"
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|mesg
argument_list|,
name|event
operator|->
name|resourceid
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
literal|"ErrorSerial"
argument_list|,
literal|"Error Serial #%d"
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|mesg
argument_list|,
name|event
operator|->
name|serial
argument_list|)
expr_stmt|;
name|XGetErrorDatabaseText
argument_list|(
name|dpy
argument_list|,
name|mtype
argument_list|,
literal|"CurrentSerial"
argument_list|,
literal|"Current Serial #%d"
argument_list|,
name|mesg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n  "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|mesg
argument_list|,
name|dpy
operator|->
name|request
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|error_code
operator|==
name|BadImplementation
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|_XDefaultError
parameter_list|(
name|dpy
parameter_list|,
name|event
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|XErrorEvent
modifier|*
name|event
decl_stmt|;
block|{
if|if
condition|(
name|_XPrintDefaultError
argument_list|(
name|dpy
argument_list|,
name|event
argument_list|,
name|stderr
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|Bool
name|_XDefaultWireError
parameter_list|(
name|display
parameter_list|,
name|he
parameter_list|,
name|we
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|XErrorEvent
modifier|*
name|he
decl_stmt|;
name|xError
modifier|*
name|we
decl_stmt|;
block|{
return|return
name|True
return|;
block|}
end_function

begin_comment
comment|/*  * _XError - prepare to upcall user protocol error handler  */
end_comment

begin_function
name|int
name|_XError
parameter_list|(
name|dpy
parameter_list|,
name|rep
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|xError
modifier|*
name|rep
decl_stmt|;
block|{
comment|/*       * X_Error packet encountered!  We need to unpack the error before      * giving it to the user.      */
name|XEvent
name|event
decl_stmt|;
comment|/* make it a large event */
name|event
operator|.
name|xerror
operator|.
name|display
operator|=
name|dpy
expr_stmt|;
name|event
operator|.
name|xerror
operator|.
name|type
operator|=
name|X_Error
expr_stmt|;
name|event
operator|.
name|xerror
operator|.
name|serial
operator|=
name|_XSetLastRequestRead
argument_list|(
name|dpy
argument_list|,
operator|(
name|xGenericReply
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
name|event
operator|.
name|xerror
operator|.
name|resourceid
operator|=
name|rep
operator|->
name|resourceID
expr_stmt|;
name|event
operator|.
name|xerror
operator|.
name|error_code
operator|=
name|rep
operator|->
name|errorCode
expr_stmt|;
name|event
operator|.
name|xerror
operator|.
name|request_code
operator|=
name|rep
operator|->
name|majorCode
expr_stmt|;
name|event
operator|.
name|xerror
operator|.
name|minor_code
operator|=
name|rep
operator|->
name|minorCode
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|error_vec
operator|&&
operator|!
call|(
modifier|*
name|dpy
operator|->
name|error_vec
index|[
name|rep
operator|->
name|errorCode
index|]
call|)
argument_list|(
name|dpy
argument_list|,
operator|&
name|event
operator|.
name|xerror
argument_list|,
name|rep
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|_XErrorFunction
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
call|(
modifier|*
name|_XErrorFunction
call|)
argument_list|(
name|dpy
argument_list|,
operator|&
name|event
argument_list|)
operator|)
return|;
comment|/* upcall */
block|}
else|else
block|{
return|return
name|_XDefaultError
argument_list|(
name|dpy
argument_list|,
operator|&
name|event
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * _XIOError - call user connection error handler and exit  */
end_comment

begin_function
name|int
name|_XIOError
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
block|{
name|dpy
operator|->
name|flags
operator||=
name|XlibDisplayIOError
expr_stmt|;
if|if
condition|(
name|_XIOErrorFunction
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|_XIOErrorFunction
call|)
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
else|else
name|_XDefaultIOError
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine can be used to (cheaply) get some memory within a single  * Xlib routine for scratch space.  It is reallocated from the same place  * each time, unless the library needs a large scratch space.  */
end_comment

begin_function
name|char
modifier|*
name|_XAllocScratch
parameter_list|(
name|dpy
parameter_list|,
name|nbytes
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
name|unsigned
name|long
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
name|nbytes
operator|>
name|dpy
operator|->
name|scratch_length
condition|)
block|{
if|if
condition|(
name|dpy
operator|->
name|scratch_buffer
condition|)
name|Xfree
argument_list|(
name|dpy
operator|->
name|scratch_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpy
operator|->
name|scratch_buffer
operator|=
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nbytes
argument_list|)
condition|)
name|dpy
operator|->
name|scratch_length
operator|=
name|nbytes
expr_stmt|;
else|else
name|dpy
operator|->
name|scratch_length
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|dpy
operator|->
name|scratch_buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a visual id, find the visual structure for this id on this display.  */
end_comment

begin_function
name|Visual
modifier|*
name|_XVIDtoVisual
parameter_list|(
name|dpy
parameter_list|,
name|id
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|VisualID
name|id
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|Screen
modifier|*
name|sp
decl_stmt|;
specifier|register
name|Depth
modifier|*
name|dp
decl_stmt|;
specifier|register
name|Visual
modifier|*
name|vp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpy
operator|->
name|nscreens
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
operator|&
name|dpy
operator|->
name|screens
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sp
operator|->
name|ndepths
condition|;
name|j
operator|++
control|)
block|{
name|dp
operator|=
operator|&
name|sp
operator|->
name|depths
index|[
name|j
index|]
expr_stmt|;
comment|/* if nvisuals == 0 then visuals will be NULL */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|dp
operator|->
name|nvisuals
condition|;
name|k
operator|++
control|)
block|{
name|vp
operator|=
operator|&
name|dp
operator|->
name|visuals
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|visualid
operator|==
name|id
condition|)
return|return
operator|(
name|vp
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_macro
name|XFree
argument_list|(
argument|void *data
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_macro
name|XFree
argument_list|(
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|Xfree
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|_XNEEDBCOPYFUNC
end_ifdef

begin_decl_stmt
name|void
name|_Xbcopy
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|,
name|length
argument_list|)
decl|register
name|char
modifier|*
name|b1
decl_stmt|,
modifier|*
name|b2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|length
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|b1
operator|<
name|b2
condition|)
block|{
name|b2
operator|+=
name|length
expr_stmt|;
name|b1
operator|+=
name|length
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
operator|*
operator|--
name|b2
operator|=
operator|*
operator|--
name|b1
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|length
operator|--
condition|)
operator|*
name|b2
operator|++
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DataRoutineIsProcedure
end_ifdef

begin_function
name|void
name|Data
parameter_list|(
name|dpy
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|long
name|len
decl_stmt|;
block|{
if|if
condition|(
name|dpy
operator|->
name|bufptr
operator|+
operator|(
name|len
operator|)
operator|<=
name|dpy
operator|->
name|bufmax
condition|)
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
name|dpy
operator|->
name|bufptr
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|dpy
operator|->
name|bufptr
operator|+=
operator|(
operator|(
name|len
operator|)
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
else|else
block|{
name|_XSend
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DataRoutineIsProcedure */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WORD64
end_ifdef

begin_comment
comment|/*  * XXX This is a *really* stupid way of doing this.  It should just use   * dpy->bufptr directly, taking into account where in the word it is.  */
end_comment

begin_comment
comment|/*  * Data16 - Place 16 bit data in the buffer.  *  * "dpy" is a pointer to a Display.  * "data" is a pointer to the data.  * "len" is the length in bytes of the data.  */
end_comment

begin_expr_stmt
specifier|static
name|doData16
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|packbuffer
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|short
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|packbuffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lpack
decl_stmt|;
name|long
name|i
decl_stmt|,
name|nwords
decl_stmt|,
name|bits
decl_stmt|;
name|long
name|mask16
init|=
literal|0x000000000000ffff
decl_stmt|;
name|lp
operator|=
operator|(
name|long
operator|*
operator|)
name|data
expr_stmt|;
name|lpack
operator|=
operator|(
name|long
operator|*
operator|)
name|packbuffer
expr_stmt|;
comment|/*  nwords is the number of 16 bit values to be packed,  *  the low order 16 bits of each word will be packed  *  into 64 bit words  */
name|nwords
operator|=
name|len
operator|>>
literal|1
expr_stmt|;
name|bits
operator|=
literal|48
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bits
operator|==
literal|48
condition|)
operator|*
name|lpack
operator|=
literal|0
expr_stmt|;
operator|*
name|lpack
operator|^=
operator|(
operator|*
name|lp
operator|&
name|mask16
operator|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|-=
literal|16
expr_stmt|;
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|0
condition|)
block|{
name|lpack
operator|++
expr_stmt|;
name|bits
operator|=
literal|48
expr_stmt|;
block|}
block|}
name|Data
argument_list|(
name|dpy
argument_list|,
name|packbuffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Data16
argument_list|(
argument|dpy
argument_list|,
argument|data
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|packbuffer
index|[
name|PACKBUFFERSIZE
index|]
decl_stmt|;
name|unsigned
name|nunits
init|=
name|PACKBUFFERSIZE
operator|>>
literal|1
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
name|PACKBUFFERSIZE
condition|;
name|len
operator|-=
name|PACKBUFFERSIZE
operator|,
name|data
operator|+=
name|nunits
control|)
block|{
name|doData16
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|PACKBUFFERSIZE
argument_list|,
name|packbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
name|doData16
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|packbuffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Data32 - Place 32 bit data in the buffer.  *  * "dpy" is a pointer to a Display.  * "data" is a pointer to the data.  * "len" is the length in bytes of the data.  */
end_comment

begin_expr_stmt
specifier|static
name|doData32
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|packbuffer
argument_list|)
specifier|register
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|long
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|packbuffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lpack
decl_stmt|;
name|long
name|i
decl_stmt|,
name|bits
decl_stmt|,
name|nwords
decl_stmt|;
name|long
name|mask32
init|=
literal|0x00000000ffffffff
decl_stmt|;
name|lpack
operator|=
operator|(
name|long
operator|*
operator|)
name|packbuffer
expr_stmt|;
name|lp
operator|=
name|data
expr_stmt|;
comment|/*  nwords is the number of 32 bit values to be packed  *  the low order 32 bits of each word will be packed  *  into 64 bit words  */
name|nwords
operator|=
name|len
operator|>>
literal|2
expr_stmt|;
name|bits
operator|=
literal|32
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bits
operator|==
literal|32
condition|)
operator|*
name|lpack
operator|=
literal|0
expr_stmt|;
operator|*
name|lpack
operator|^=
operator|(
operator|*
name|lp
operator|&
name|mask32
operator|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|=
name|bits
operator|^
literal|32
expr_stmt|;
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|bits
condition|)
name|lpack
operator|++
expr_stmt|;
block|}
name|Data
argument_list|(
name|dpy
argument_list|,
name|packbuffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Data32
argument_list|(
argument|dpy
argument_list|,
argument|data
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|packbuffer
index|[
name|PACKBUFFERSIZE
index|]
decl_stmt|;
name|unsigned
name|nunits
init|=
name|PACKBUFFERSIZE
operator|>>
literal|2
decl_stmt|;
for|for
control|(
init|;
name|len
operator|>
name|PACKBUFFERSIZE
condition|;
name|len
operator|-=
name|PACKBUFFERSIZE
operator|,
name|data
operator|+=
name|nunits
control|)
block|{
name|doData32
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|PACKBUFFERSIZE
argument_list|,
name|packbuffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
name|doData32
argument_list|(
name|dpy
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|packbuffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WORD64 */
end_comment

begin_comment
comment|/*  * _XFreeQ - free the queue of events, called by XCloseDisplay  */
end_comment

begin_function
name|void
name|_XFreeQ
parameter_list|()
block|{
specifier|register
name|_XQEvent
modifier|*
name|qelt
init|=
name|_qfree
decl_stmt|;
while|while
condition|(
name|qelt
condition|)
block|{
specifier|register
name|_XQEvent
modifier|*
name|qnxt
init|=
name|qelt
operator|->
name|next
decl_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qelt
argument_list|)
expr_stmt|;
name|qelt
operator|=
name|qnxt
expr_stmt|;
block|}
name|_qfree
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Make sure this produces the same string as DefineLocal/DefineSelf in xdm.  * Otherwise, Xau will not be able to find your cookies in the Xauthority file.  *  * Note: POSIX says that the ``nodename'' member of utsname does _not_ have  *       to have sufficient information for interfacing to the network,  *       and so, you may be better off using gethostname (if it exists).  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AIXV3
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|SVR4
argument_list|)
end_if

begin_define
define|#
directive|define
name|NEED_UTSNAME
end_define

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * _XGetHostname - similar to gethostname but allows special processing.  */
end_comment

begin_function
name|int
name|_XGetHostname
parameter_list|(
name|buf
parameter_list|,
name|maxlen
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|NEED_UTSNAME
name|struct
name|utsname
name|name
decl_stmt|;
name|uname
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
operator|.
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|maxlen
condition|)
name|len
operator|=
name|maxlen
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|name
operator|.
name|nodename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|buf
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|buf
index|[
name|maxlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEED_UTSNAME */
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * _XScreenOfWindow - get the Screen of a given window  */
end_comment

begin_function
name|Screen
modifier|*
name|_XScreenOfWindow
parameter_list|(
name|dpy
parameter_list|,
name|w
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|Window
name|w
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|Window
name|root
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* dummy variables */
name|unsigned
name|int
name|width
decl_stmt|,
name|height
decl_stmt|,
name|bw
decl_stmt|,
name|depth
decl_stmt|;
comment|/* dummy variables */
if|if
condition|(
name|XGetGeometry
argument_list|(
name|dpy
argument_list|,
name|w
argument_list|,
operator|&
name|root
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|bw
argument_list|,
operator|&
name|depth
argument_list|)
operator|==
name|False
condition|)
block|{
return|return
name|None
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ScreenCount
argument_list|(
name|dpy
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* find root from list */
if|if
condition|(
name|root
operator|==
name|RootWindow
argument_list|(
name|dpy
argument_list|,
name|i
argument_list|)
condition|)
block|{
return|return
name|ScreenOfDisplay
argument_list|(
name|dpy
argument_list|,
name|i
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|MSKCNT
operator|>
literal|4
operator|)
end_if

begin_comment
comment|/*  * This is a macro if MSKCNT<= 4  */
end_comment

begin_macro
name|_XANYSET
argument_list|(
argument|src
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MSKCNT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|src
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CRAY
end_ifdef

begin_comment
comment|/*  * Cray UniCOS does not have readv and writev so we emulate  */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_function
name|int
name|_XReadV
parameter_list|(
name|fd
parameter_list|,
name|iov
parameter_list|,
name|iovcnt
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|int
name|iovcnt
decl_stmt|;
block|{
name|struct
name|msghdr
name|hdr
decl_stmt|;
name|hdr
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|hdr
operator|.
name|msg_iovlen
operator|=
name|iovcnt
expr_stmt|;
name|hdr
operator|.
name|msg_accrights
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|msg_accrightslen
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|msg_name
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|msg_namelen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|recvmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|hdr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_XWriteV
parameter_list|(
name|fd
parameter_list|,
name|iov
parameter_list|,
name|iovcnt
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|int
name|iovcnt
decl_stmt|;
block|{
name|struct
name|msghdr
name|hdr
decl_stmt|;
name|hdr
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|hdr
operator|.
name|msg_iovlen
operator|=
name|iovcnt
expr_stmt|;
name|hdr
operator|.
name|msg_accrights
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|msg_accrightslen
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|msg_name
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|msg_namelen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sendmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|hdr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRAY */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYSV386
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STREAMSCONN
argument_list|)
end_if

begin_comment
comment|/*  * SYSV/386 does not have readv so we emulate  */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_function
name|int
name|_XReadV
parameter_list|(
name|fd
parameter_list|,
name|iov
parameter_list|,
name|iovcnt
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|int
name|iovcnt
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|total
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|total
operator|=
literal|0
init|;
name|i
operator|<
name|iovcnt
condition|;
name|i
operator|++
operator|,
name|iov
operator|++
control|)
block|{
name|len
operator|=
name|iov
operator|->
name|iov_len
expr_stmt|;
name|base
operator|=
name|iov
operator|->
name|iov_base
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
operator|&&
name|total
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
return|return
name|total
return|;
name|errno
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
name|nbytes
expr_stmt|;
name|total
operator|+=
name|nbytes
expr_stmt|;
name|base
operator|+=
name|nbytes
expr_stmt|;
block|}
block|}
return|return
name|total
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV&& SYSV386&& !STREAMSCONN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMSCONN
end_ifdef

begin_comment
comment|/*  * Copyright 1988, 1989 AT&T, Inc.  *  * Permission to use, copy, modify, and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of AT&T not be used in advertising  * or publicity pertaining to distribution of the software without specific,  * written prior permission.  AT&T makes no representations about the  * suitability of this software for any purpose.  It is provided "as is"  * without express or implied warranty.  *  * AT&T DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL AT&T  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  iovec.c (C source file) 	Acc: 575557389 Mon Mar 28 08:03:09 1988 	Mod: 575557397 Mon Mar 28 08:03:17 1988 	Sta: 575557397 Mon Mar 28 08:03:17 1988 	Owner: 2011 	Group: 1985 	Permissions: 664 */
end_comment

begin_comment
comment|/* 	START USER STAMP AREA */
end_comment

begin_comment
comment|/* 	END USER STAMP AREA */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|_XsTypeofStream
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Xstream
name|_XsStream
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_WORKAREA
value|4096
end_define

begin_decl_stmt
specifier|static
name|char
name|workarea
index|[
name|MAX_WORKAREA
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_XReadV
parameter_list|(
name|fd
parameter_list|,
name|v
parameter_list|,
name|n
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
name|v
index|[]
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|len
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|workarea
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|n
operator|>
literal|16
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|v
index|[
name|i
index|]
operator|.
name|iov_len
operator|)
operator|<
literal|0
operator|||
name|v
index|[
name|i
index|]
operator|.
name|iov_base
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|size
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|>
name|MAX_WORKAREA
operator|)
operator|&&
operator|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
operator|(
operator|*
name|_XsStream
index|[
name|_XsTypeOfStream
index|[
name|fd
index|]
index|]
operator|.
name|ReadFromStream
operator|)
operator|(
name|fd
operator|,
name|buf
operator|,
name|size
operator|,
name|BUFFERING
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buf
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|v
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|p
argument_list|,
name|len
operator|=
name|v
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|>
name|MAX_WORKAREA
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_XWriteV
parameter_list|(
name|fd
parameter_list|,
name|v
parameter_list|,
name|n
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|iovec
name|v
index|[]
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|len
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|workarea
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|n
operator|>
literal|16
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|v
index|[
name|i
index|]
operator|.
name|iov_len
operator|)
operator|<
literal|0
operator|||
name|v
index|[
name|i
index|]
operator|.
name|iov_base
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|size
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|>
name|MAX_WORKAREA
operator|)
operator|&&
operator|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buf
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|v
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|len
operator|=
name|v
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
name|rc
operator|=
operator|(
operator|*
name|_XsStream
index|[
name|_XsTypeOfStream
index|[
name|fd
index|]
index|]
operator|.
name|WriteToStream
operator|)
operator|(
name|fd
operator|,
name|buf
operator|,
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|MAX_WORKAREA
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAMSCONN */
end_comment

end_unit

