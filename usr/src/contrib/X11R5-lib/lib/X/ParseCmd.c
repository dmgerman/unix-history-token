begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: ParseCmd.c,v 1.24 91/05/08 09:48:53 gildea Exp $  */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* XrmParseCommand()     Parse command line and store argument values into resource database     Allows any un-ambiguous abbreviation for an option name, but requires    that the table be ordered with any options that are prefixes of    other options appearing before the longer version in the table. */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xresource.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
specifier|static
name|void
name|_XReportParseError
parameter_list|(
name|arg
parameter_list|,
name|msg
parameter_list|)
name|XrmOptionDescRec
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error parsing argument \"%s\" (%s); %s\n"
argument_list|,
name|arg
operator|->
name|option
argument_list|,
name|arg
operator|->
name|specifier
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|void
name|XrmParseCommand
parameter_list|(
name|XrmDatabase
modifier|*
name|pdb
parameter_list|,
comment|/* data base */
specifier|register
name|XrmOptionDescList
name|options
parameter_list|,
comment|/* pointer to table of valid options */
name|int
name|num_options
parameter_list|,
comment|/* number of options		     */
name|_Xconst
name|char
modifier|*
name|prefix
parameter_list|,
comment|/* name to prefix resources with     */
name|int
modifier|*
name|argc
parameter_list|,
comment|/* address of argument count 	     */
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
comment|/* argument list (command line)	     */
else|#
directive|else
function|void XrmParseCommand
parameter_list|(
name|pdb
parameter_list|,
name|options
parameter_list|,
name|num_options
parameter_list|,
name|prefix
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|XrmDatabase
modifier|*
name|pdb
decl_stmt|;
comment|/* data base */
specifier|register
name|XrmOptionDescList
name|options
decl_stmt|;
comment|/* pointer to table of valid options */
name|int
name|num_options
decl_stmt|;
comment|/* number of options		     */
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* name to prefix resources with     */
name|int
modifier|*
name|argc
decl_stmt|;
comment|/* address of argument count 	     */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* argument list (command line)	     */
endif|#
directive|endif
block|{
name|int
name|foundOption
decl_stmt|;
name|char
modifier|*
modifier|*
name|argsave
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|myargc
decl_stmt|;
name|XrmBinding
name|bindings
index|[
literal|100
index|]
decl_stmt|;
name|XrmQuark
name|quarks
index|[
literal|100
index|]
decl_stmt|;
name|XrmBinding
modifier|*
name|start_bindings
decl_stmt|;
name|XrmQuark
modifier|*
name|start_quarks
decl_stmt|;
name|char
modifier|*
name|optP
decl_stmt|,
modifier|*
name|argP
decl_stmt|,
name|optchar
decl_stmt|,
name|argchar
decl_stmt|;
name|int
name|matches
decl_stmt|;
enum|enum
block|{
name|DontCare
block|,
name|Check
block|,
name|NotSorted
block|,
name|Sorted
block|}
name|table_is_sorted
enum|;
name|char
modifier|*
modifier|*
name|argend
decl_stmt|;
define|#
directive|define
name|PutCommandResource
parameter_list|(
name|value_str
parameter_list|)
define|\
value|{								\     XrmStringToBindingQuarkList(				\ 	options[i].specifier, start_bindings, start_quarks);    \     XrmQPutStringResource(pdb, bindings, quarks, value_str);    \     }
comment|/* PutCommandResource */
name|myargc
operator|=
operator|(
operator|*
name|argc
operator|)
expr_stmt|;
name|argend
operator|=
name|argv
operator|+
name|myargc
expr_stmt|;
name|argsave
operator|=
operator|++
name|argv
expr_stmt|;
comment|/* Initialize bindings/quark list with prefix (typically app name). */
name|quarks
index|[
literal|0
index|]
operator|=
name|XrmStringToName
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|bindings
index|[
literal|0
index|]
operator|=
name|XrmBindTightly
expr_stmt|;
name|start_quarks
operator|=
name|quarks
operator|+
literal|1
expr_stmt|;
name|start_bindings
operator|=
name|bindings
operator|+
literal|1
expr_stmt|;
name|table_is_sorted
operator|=
operator|(
name|myargc
operator|>
literal|2
operator|)
condition|?
name|Check
else|:
name|DontCare
expr_stmt|;
for|for
control|(
operator|--
name|myargc
init|;
name|myargc
operator|>
literal|0
condition|;
operator|--
name|myargc
operator|,
operator|++
name|argv
control|)
block|{
name|foundOption
operator|=
name|False
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_options
condition|;
operator|++
name|i
control|)
block|{
comment|/* checking the sort order first insures we don't have to 	       re-do the check if the arg hits on the last entry in 	       the table.  Useful because usually '=' is the last entry 	       and users frequently specify geometry early in the command */
if|if
condition|(
name|table_is_sorted
operator|==
name|Check
operator|&&
name|i
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|options
index|[
name|i
index|]
operator|.
name|option
argument_list|,
name|options
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|option
argument_list|)
operator|<
literal|0
condition|)
block|{
name|table_is_sorted
operator|=
name|NotSorted
expr_stmt|;
block|}
for|for
control|(
name|argP
operator|=
operator|*
name|argv
operator|,
name|optP
operator|=
name|options
index|[
name|i
index|]
operator|.
name|option
init|;
operator|(
name|optchar
operator|=
operator|*
name|optP
operator|++
operator|)
operator|&&
operator|(
name|argchar
operator|=
operator|*
name|argP
operator|++
operator|)
operator|&&
name|argchar
operator|==
name|optchar
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|optchar
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|argP
operator|||
name|options
index|[
name|i
index|]
operator|.
name|argKind
operator|==
name|XrmoptionStickyArg
operator|||
name|options
index|[
name|i
index|]
operator|.
name|argKind
operator|==
name|XrmoptionIsArg
condition|)
block|{
comment|/* give preference to exact matches, StickyArg and IsArg */
name|matches
operator|=
literal|1
expr_stmt|;
name|foundOption
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|argchar
condition|)
block|{
comment|/* may be an abbreviation for this option */
name|matches
operator|++
expr_stmt|;
name|foundOption
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|table_is_sorted
operator|==
name|Sorted
operator|&&
name|optchar
operator|>
name|argchar
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|table_is_sorted
operator|==
name|Check
operator|&&
name|i
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|options
index|[
name|i
index|]
operator|.
name|option
argument_list|,
name|options
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|option
argument_list|)
operator|<
literal|0
condition|)
block|{
name|table_is_sorted
operator|=
name|NotSorted
expr_stmt|;
block|}
block|}
if|if
condition|(
name|table_is_sorted
operator|==
name|Check
operator|&&
name|i
operator|>=
operator|(
name|num_options
operator|-
literal|1
operator|)
condition|)
name|table_is_sorted
operator|=
name|Sorted
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|1
condition|)
block|{
name|i
operator|=
name|foundOption
expr_stmt|;
switch|switch
condition|(
name|options
index|[
name|i
index|]
operator|.
name|argKind
condition|)
block|{
case|case
name|XrmoptionNoArg
case|:
operator|--
operator|(
operator|*
name|argc
operator|)
expr_stmt|;
name|PutCommandResource
argument_list|(
name|options
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|XrmoptionIsArg
case|:
operator|--
operator|(
operator|*
name|argc
operator|)
expr_stmt|;
name|PutCommandResource
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
name|XrmoptionStickyArg
case|:
operator|--
operator|(
operator|*
name|argc
operator|)
expr_stmt|;
name|PutCommandResource
argument_list|(
name|argP
argument_list|)
expr_stmt|;
break|break;
case|case
name|XrmoptionSepArg
case|:
if|if
condition|(
name|myargc
operator|>
literal|1
condition|)
block|{
operator|++
name|argv
expr_stmt|;
operator|--
name|myargc
expr_stmt|;
operator|--
operator|(
operator|*
name|argc
operator|)
expr_stmt|;
operator|--
operator|(
operator|*
name|argc
operator|)
expr_stmt|;
name|PutCommandResource
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|argsave
operator|++
operator|)
operator|=
operator|(
operator|*
name|argv
operator|)
expr_stmt|;
break|break;
case|case
name|XrmoptionResArg
case|:
if|if
condition|(
name|myargc
operator|>
literal|1
condition|)
block|{
operator|++
name|argv
expr_stmt|;
operator|--
name|myargc
expr_stmt|;
operator|--
operator|(
operator|*
name|argc
operator|)
expr_stmt|;
operator|--
operator|(
operator|*
name|argc
operator|)
expr_stmt|;
name|XrmPutLineResource
argument_list|(
name|pdb
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|argsave
operator|++
operator|)
operator|=
operator|(
operator|*
name|argv
operator|)
expr_stmt|;
break|break;
case|case
name|XrmoptionSkipArg
case|:
if|if
condition|(
name|myargc
operator|>
literal|1
condition|)
block|{
operator|--
name|myargc
expr_stmt|;
operator|(
operator|*
name|argsave
operator|++
operator|)
operator|=
operator|(
operator|*
name|argv
operator|++
operator|)
expr_stmt|;
block|}
operator|(
operator|*
name|argsave
operator|++
operator|)
operator|=
operator|(
operator|*
name|argv
operator|)
expr_stmt|;
break|break;
case|case
name|XrmoptionSkipLine
case|:
for|for
control|(
init|;
name|myargc
operator|>
literal|0
condition|;
name|myargc
operator|--
control|)
operator|(
operator|*
name|argsave
operator|++
operator|)
operator|=
operator|(
operator|*
name|argv
operator|++
operator|)
expr_stmt|;
break|break;
case|case
name|XrmoptionSkipNArgs
case|:
block|{
specifier|register
name|int
name|j
init|=
literal|1
operator|+
operator|(
name|int
operator|)
name|options
index|[
name|i
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|j
operator|>
name|myargc
condition|)
name|j
operator|=
name|myargc
expr_stmt|;
for|for
control|(
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
operator|(
operator|*
name|argsave
operator|++
operator|)
operator|=
operator|(
operator|*
name|argv
operator|++
operator|)
expr_stmt|;
name|myargc
operator|--
expr_stmt|;
block|}
name|argv
operator|--
expr_stmt|;
comment|/* went one too far before */
name|myargc
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|_XReportParseError
argument_list|(
operator|&
name|options
index|[
name|i
index|]
argument_list|,
literal|"unknown kind"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
operator|(
operator|*
name|argsave
operator|++
operator|)
operator|=
operator|(
operator|*
name|argv
operator|)
expr_stmt|;
comment|/*compress arglist*/
block|}
if|if
condition|(
name|argsave
operator|<
name|argend
condition|)
operator|(
operator|*
name|argsave
operator|)
operator|=
name|NULL
expr_stmt|;
comment|/* put NULL terminator on compressed argv */
block|}
end_function

end_unit

