begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 1989 Massachusetts Institute of Technolgoy */
end_comment

begin_comment
comment|/* $XConsortium: SetRGBCMap.c,v 1.4 91/01/08 14:40:02 gildea Exp $ */
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include

begin_include
include|#
directive|include
file|"Xatomtype.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xatom.h>
end_include

begin_function
name|void
name|XSetRGBColormaps
parameter_list|(
name|dpy
parameter_list|,
name|w
parameter_list|,
name|cmaps
parameter_list|,
name|count
parameter_list|,
name|property
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|Window
name|w
decl_stmt|;
name|XStandardColormap
modifier|*
name|cmaps
decl_stmt|;
name|int
name|count
decl_stmt|;
name|Atom
name|property
decl_stmt|;
comment|/* XA_RGB_BEST_MAP, etc. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* iterator variable */
specifier|register
name|xPropStandardColormap
modifier|*
name|map
decl_stmt|;
comment|/* tmp variable, data in prop */
specifier|register
name|XStandardColormap
modifier|*
name|cmap
decl_stmt|;
comment|/* tmp variable, user data */
name|xPropStandardColormap
modifier|*
name|data
decl_stmt|,
name|tmpdata
decl_stmt|;
comment|/* scratch data */
name|int
name|mode
init|=
name|PropModeReplace
decl_stmt|;
comment|/* for partial writes */
name|Bool
name|alloced_scratch_space
decl_stmt|;
comment|/* do we need to free? */
if|if
condition|(
name|count
operator|<
literal|1
condition|)
return|return;
comment|/*      * if doing more than one, allocate scratch space for it      */
if|if
condition|(
operator|(
name|count
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|data
operator|=
operator|(
operator|(
name|xPropStandardColormap
operator|*
operator|)
name|Xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|xPropStandardColormap
argument_list|)
argument_list|)
operator|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|alloced_scratch_space
operator|=
name|True
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
operator|&
name|tmpdata
expr_stmt|;
name|alloced_scratch_space
operator|=
name|False
expr_stmt|;
block|}
comment|/*      * Do the iteration.  If using temp space put out each part of the prop;      * otherwise, wait until the end and blast it all at once.      */
for|for
control|(
name|i
operator|=
name|count
operator|,
name|map
operator|=
name|data
operator|,
name|cmap
operator|=
name|cmaps
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|cmap
operator|++
control|)
block|{
name|map
operator|->
name|colormap
operator|=
name|cmap
operator|->
name|colormap
expr_stmt|;
name|map
operator|->
name|red_max
operator|=
name|cmap
operator|->
name|red_max
expr_stmt|;
name|map
operator|->
name|red_mult
operator|=
name|cmap
operator|->
name|red_mult
expr_stmt|;
name|map
operator|->
name|green_max
operator|=
name|cmap
operator|->
name|green_max
expr_stmt|;
name|map
operator|->
name|green_mult
operator|=
name|cmap
operator|->
name|green_mult
expr_stmt|;
name|map
operator|->
name|blue_max
operator|=
name|cmap
operator|->
name|blue_max
expr_stmt|;
name|map
operator|->
name|blue_mult
operator|=
name|cmap
operator|->
name|blue_mult
expr_stmt|;
name|map
operator|->
name|base_pixel
operator|=
name|cmap
operator|->
name|base_pixel
expr_stmt|;
name|map
operator|->
name|visualid
operator|=
name|cmap
operator|->
name|visualid
expr_stmt|;
name|map
operator|->
name|killid
operator|=
name|cmap
operator|->
name|killid
expr_stmt|;
if|if
condition|(
name|alloced_scratch_space
condition|)
block|{
name|map
operator|++
expr_stmt|;
block|}
else|else
block|{
name|XChangeProperty
argument_list|(
name|dpy
argument_list|,
name|w
argument_list|,
name|property
argument_list|,
name|XA_RGB_COLOR_MAP
argument_list|,
literal|32
argument_list|,
name|mode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
name|NumPropStandardColormapElements
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PropModeAppend
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alloced_scratch_space
condition|)
block|{
name|XChangeProperty
argument_list|(
name|dpy
argument_list|,
name|w
argument_list|,
name|property
argument_list|,
name|XA_RGB_COLOR_MAP
argument_list|,
literal|32
argument_list|,
name|PropModeReplace
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
call|(
name|int
call|)
argument_list|(
name|count
operator|*
name|NumPropStandardColormapElements
argument_list|)
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

