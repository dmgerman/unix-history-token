begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XRegion.c,v 11.36 92/10/21 10:05:54 rws Exp $ */
end_comment

begin_comment
comment|/************************************************************************ Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ************************************************************************/
end_comment

begin_comment
comment|/*  * The functions in this file implement the Region abstraction, similar to one  * used in the X11 sample server. A Region is simply an area, as the name  * implies, and is implemented as a "y-x-banded" array of rectangles. To  * explain: Each Region is made up of a certain number of rectangles sorted  * by y coordinate first, and then by x coordinate.  *  * Furthermore, the rectangles are banded such that every rectangle with a  * given upper-left y coordinate (y1) will have the same lower-right y  * coordinate (y2) and vice versa. If a rectangle has scanlines in a band, it  * will span the entire vertical distance of the band. This means that some  * areas that could be merged into a taller rectangle will be represented as  * several shorter rectangles to account for shorter rectangles to its left  * or right but within its "vertical scope".  *  * An added constraint on the rectangles is that they must cover as much  * horizontal area as possible. E.g. no two rectangles in a band are allowed  * to touch.  *  * Whenever possible, bands will be merged together to cover a greater vertical  * distance (and thus reduce the number of rectangles). Two bands can be merged  * only if the bottom of one touches the top of the other and they have  * rectangles in the same places (of the same width, of course). This maintains  * the y-x-banding that's so nice to have...  */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xutil.h"
end_include

begin_include
include|#
directive|include
file|"region.h"
end_include

begin_include
include|#
directive|include
file|"poly.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expr
parameter_list|)
value|{if (!(expr)) fprintf(stderr,\ "Assertion failed file %s, line %d: expr\n", __FILE__, __LINE__); }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expr
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|voidProcp
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|char
modifier|*
name|_XAllocScratch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|miRegionOp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*	Create a new empty region	*/
end_comment

begin_function
name|Region
name|XCreateRegion
parameter_list|()
block|{
name|Region
name|temp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
operator|(
name|Region
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|REGION
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|Region
operator|)
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|temp
operator|->
name|rects
operator|=
operator|(
name|BOX
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|BOX
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Region
operator|)
name|NULL
return|;
block|}
name|temp
operator|->
name|numRects
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|extents
operator|.
name|x1
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|extents
operator|.
name|y1
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|extents
operator|.
name|x2
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|extents
operator|.
name|y2
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_macro
name|XClipBox
argument_list|(
argument|r
argument_list|,
argument|rect
argument_list|)
end_macro

begin_decl_stmt
name|Region
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XRectangle
modifier|*
name|rect
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rect
operator|->
name|x
operator|=
name|r
operator|->
name|extents
operator|.
name|x1
expr_stmt|;
name|rect
operator|->
name|y
operator|=
name|r
operator|->
name|extents
operator|.
name|y1
expr_stmt|;
name|rect
operator|->
name|width
operator|=
name|r
operator|->
name|extents
operator|.
name|x2
operator|-
name|r
operator|->
name|extents
operator|.
name|x1
expr_stmt|;
name|rect
operator|->
name|height
operator|=
name|r
operator|->
name|extents
operator|.
name|y2
operator|-
name|r
operator|->
name|extents
operator|.
name|y1
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|XUnionRectWithRegion
argument_list|(
name|rect
argument_list|,
name|source
argument_list|,
name|dest
argument_list|)
specifier|register
name|XRectangle
operator|*
name|rect
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Region
name|source
decl_stmt|,
name|dest
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REGION
name|region
decl_stmt|;
if|if
condition|(
operator|!
name|rect
operator|->
name|width
operator|||
operator|!
name|rect
operator|->
name|height
condition|)
return|return;
name|region
operator|.
name|rects
operator|=
operator|&
name|region
operator|.
name|extents
expr_stmt|;
name|region
operator|.
name|numRects
operator|=
literal|1
expr_stmt|;
name|region
operator|.
name|extents
operator|.
name|x1
operator|=
name|rect
operator|->
name|x
expr_stmt|;
name|region
operator|.
name|extents
operator|.
name|y1
operator|=
name|rect
operator|->
name|y
expr_stmt|;
name|region
operator|.
name|extents
operator|.
name|x2
operator|=
name|rect
operator|->
name|x
operator|+
name|rect
operator|->
name|width
expr_stmt|;
name|region
operator|.
name|extents
operator|.
name|y2
operator|=
name|rect
operator|->
name|y
operator|+
name|rect
operator|->
name|height
expr_stmt|;
name|region
operator|.
name|size
operator|=
literal|1
expr_stmt|;
name|XUnionRegion
argument_list|(
operator|&
name|region
argument_list|,
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSetExtents --  *	Reset the extents of a region to what they should be. Called by  *	miSubtract and miIntersect b/c they can't figure it out along the  *	way or do so easily, as miUnion can.  *  * Results:  *	None.  *  * Side Effects:  *	The region's 'extents' structure is overwritten.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|miSetExtents
parameter_list|(
name|pReg
parameter_list|)
name|Region
name|pReg
decl_stmt|;
block|{
specifier|register
name|BoxPtr
name|pBox
decl_stmt|,
name|pBoxEnd
decl_stmt|,
name|pExtents
decl_stmt|;
if|if
condition|(
name|pReg
operator|->
name|numRects
operator|==
literal|0
condition|)
block|{
name|pReg
operator|->
name|extents
operator|.
name|x1
operator|=
literal|0
expr_stmt|;
name|pReg
operator|->
name|extents
operator|.
name|y1
operator|=
literal|0
expr_stmt|;
name|pReg
operator|->
name|extents
operator|.
name|x2
operator|=
literal|0
expr_stmt|;
name|pReg
operator|->
name|extents
operator|.
name|y2
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|pExtents
operator|=
operator|&
name|pReg
operator|->
name|extents
expr_stmt|;
name|pBox
operator|=
name|pReg
operator|->
name|rects
expr_stmt|;
name|pBoxEnd
operator|=
operator|&
name|pBox
index|[
name|pReg
operator|->
name|numRects
operator|-
literal|1
index|]
expr_stmt|;
comment|/*      * Since pBox is the first rectangle in the region, it must have the      * smallest y1 and since pBoxEnd is the last rectangle in the region,      * it must have the largest y2, because of banding. Initialize x1 and      * x2 from  pBox and pBoxEnd, resp., as good things to initialize them      * to...      */
name|pExtents
operator|->
name|x1
operator|=
name|pBox
operator|->
name|x1
expr_stmt|;
name|pExtents
operator|->
name|y1
operator|=
name|pBox
operator|->
name|y1
expr_stmt|;
name|pExtents
operator|->
name|x2
operator|=
name|pBoxEnd
operator|->
name|x2
expr_stmt|;
name|pExtents
operator|->
name|y2
operator|=
name|pBoxEnd
operator|->
name|y2
expr_stmt|;
name|assert
argument_list|(
name|pExtents
operator|->
name|y1
operator|<
name|pExtents
operator|->
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|pBox
operator|<=
name|pBoxEnd
condition|)
block|{
if|if
condition|(
name|pBox
operator|->
name|x1
operator|<
name|pExtents
operator|->
name|x1
condition|)
block|{
name|pExtents
operator|->
name|x1
operator|=
name|pBox
operator|->
name|x1
expr_stmt|;
block|}
if|if
condition|(
name|pBox
operator|->
name|x2
operator|>
name|pExtents
operator|->
name|x2
condition|)
block|{
name|pExtents
operator|->
name|x2
operator|=
name|pBox
operator|->
name|x2
expr_stmt|;
block|}
name|pBox
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|pExtents
operator|->
name|x1
operator|<
name|pExtents
operator|->
name|x2
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|XSetRegion
argument_list|(
argument|dpy
argument_list|,
argument|gc
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GC
name|gc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Region
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|XRectangle
modifier|*
name|xr
decl_stmt|,
modifier|*
name|pr
decl_stmt|;
specifier|register
name|BOX
modifier|*
name|pb
decl_stmt|;
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|xr
operator|=
operator|(
name|XRectangle
operator|*
operator|)
name|_XAllocScratch
argument_list|(
name|dpy
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|r
operator|->
name|numRects
operator|*
sizeof|sizeof
argument_list|(
name|XRectangle
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|pr
operator|=
name|xr
operator|,
name|pb
operator|=
name|r
operator|->
name|rects
operator|,
name|i
operator|=
name|r
operator|->
name|numRects
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pr
operator|++
operator|,
name|pb
operator|++
control|)
block|{
name|pr
operator|->
name|x
operator|=
name|pb
operator|->
name|x1
expr_stmt|;
name|pr
operator|->
name|y
operator|=
name|pb
operator|->
name|y1
expr_stmt|;
name|pr
operator|->
name|width
operator|=
name|pb
operator|->
name|x2
operator|-
name|pb
operator|->
name|x1
expr_stmt|;
name|pr
operator|->
name|height
operator|=
name|pb
operator|->
name|y2
operator|-
name|pb
operator|->
name|y1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xr
operator|||
operator|!
name|r
operator|->
name|numRects
condition|)
name|_XSetClipRectangles
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xr
argument_list|,
name|r
operator|->
name|numRects
argument_list|,
name|YXBanded
argument_list|)
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|SyncHandle
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|XDestroyRegion
argument_list|(
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|Region
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
operator|->
name|rects
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* TranslateRegion(pRegion, x, y)    translates in place    added by raymond */
end_comment

begin_expr_stmt
name|XOffsetRegion
argument_list|(
name|pRegion
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|Region
name|pRegion
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nbox
decl_stmt|;
specifier|register
name|BOX
modifier|*
name|pbox
decl_stmt|;
name|pbox
operator|=
name|pRegion
operator|->
name|rects
expr_stmt|;
name|nbox
operator|=
name|pRegion
operator|->
name|numRects
expr_stmt|;
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
name|pbox
operator|->
name|x1
operator|+=
name|x
expr_stmt|;
name|pbox
operator|->
name|x2
operator|+=
name|x
expr_stmt|;
name|pbox
operator|->
name|y1
operator|+=
name|y
expr_stmt|;
name|pbox
operator|->
name|y2
operator|+=
name|y
expr_stmt|;
name|pbox
operator|++
expr_stmt|;
block|}
name|pRegion
operator|->
name|extents
operator|.
name|x1
operator|+=
name|x
expr_stmt|;
name|pRegion
operator|->
name|extents
operator|.
name|x2
operator|+=
name|x
expr_stmt|;
name|pRegion
operator|->
name|extents
operator|.
name|y1
operator|+=
name|y
expr_stmt|;
name|pRegion
operator|->
name|extents
operator|.
name|y2
operator|+=
name|y
expr_stmt|;
block|}
end_block

begin_comment
comment|/*     Utility procedure Compress:    Replace r by the region r', where       p in r' iff (Quantifer m<= dx) (p + m in r), and      Quantifier is Exists if grow is TRUE, For all if grow is FALSE, and      (x,y) + m = (x+m,y) if xdir is TRUE; (x,y+m) if xdir is FALSE.     Thus, if xdir is TRUE and grow is FALSE, r is replaced by the region    of all points p such that p and the next dx points on the same    horizontal scan line are all in r.  We do this using by noting    that p is the head of a run of length 2^i + k iff p is the head    of a run of length 2^i and p+2^i is the head of a run of length    k. Thus, the loop invariant: s contains the region corresponding    to the runs of length shift.  r contains the region corresponding    to the runs of length 1 + dxo& (shift-1), where dxo is the original    value of dx.  dx = dxo& ~(shift-1).  As parameters, s and t are    scratch regions, so that we don't have to allocate them on every    call. */
end_comment

begin_define
define|#
directive|define
name|ZOpRegion
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|if (grow) XUnionRegion(a,b,c); \ 			 else XIntersectRegion(a,b,c)
end_define

begin_define
define|#
directive|define
name|ZShiftRegion
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if (xdir) XOffsetRegion(a,b,0); \ 			  else XOffsetRegion(a,0,b)
end_define

begin_define
define|#
directive|define
name|ZCopyRegion
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|XUnionRegion(a,a,b)
end_define

begin_function
specifier|static
name|void
name|Compress
parameter_list|(
name|r
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|,
name|dx
parameter_list|,
name|xdir
parameter_list|,
name|grow
parameter_list|)
name|Region
name|r
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|unsigned
name|dx
decl_stmt|;
specifier|register
name|int
name|xdir
decl_stmt|,
name|grow
decl_stmt|;
block|{
specifier|register
name|unsigned
name|shift
init|=
literal|1
decl_stmt|;
name|ZCopyRegion
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|dx
condition|)
block|{
if|if
condition|(
name|dx
operator|&
name|shift
condition|)
block|{
name|ZShiftRegion
argument_list|(
name|r
argument_list|,
operator|-
operator|(
name|int
operator|)
name|shift
argument_list|)
expr_stmt|;
name|ZOpRegion
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|dx
operator|-=
name|shift
expr_stmt|;
if|if
condition|(
operator|!
name|dx
condition|)
break|break;
block|}
name|ZCopyRegion
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ZShiftRegion
argument_list|(
name|s
argument_list|,
operator|-
operator|(
name|int
operator|)
name|shift
argument_list|)
expr_stmt|;
name|ZOpRegion
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|shift
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|ZOpRegion
end_undef

begin_undef
undef|#
directive|undef
name|ZShiftRegion
end_undef

begin_undef
undef|#
directive|undef
name|ZCopyRegion
end_undef

begin_macro
name|XShrinkRegion
argument_list|(
argument|r
argument_list|,
argument|dx
argument_list|,
argument|dy
argument_list|)
end_macro

begin_decl_stmt
name|Region
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Region
name|s
decl_stmt|,
name|t
decl_stmt|;
name|int
name|grow
decl_stmt|;
if|if
condition|(
operator|!
name|dx
operator|&&
operator|!
name|dy
condition|)
return|return;
if|if
condition|(
operator|(
operator|!
operator|(
name|s
operator|=
name|XCreateRegion
argument_list|()
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|t
operator|=
name|XCreateRegion
argument_list|()
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|grow
operator|=
operator|(
name|dx
operator|<
literal|0
operator|)
condition|)
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
if|if
condition|(
name|dx
condition|)
name|Compress
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|t
argument_list|,
operator|(
name|unsigned
operator|)
literal|2
operator|*
name|dx
argument_list|,
name|TRUE
argument_list|,
name|grow
argument_list|)
expr_stmt|;
if|if
condition|(
name|grow
operator|=
operator|(
name|dy
operator|<
literal|0
operator|)
condition|)
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
if|if
condition|(
name|dy
condition|)
name|Compress
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|t
argument_list|,
operator|(
name|unsigned
operator|)
literal|2
operator|*
name|dy
argument_list|,
name|FALSE
argument_list|,
name|grow
argument_list|)
expr_stmt|;
name|XOffsetRegion
argument_list|(
name|r
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|XDestroyRegion
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|XDestroyRegion
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/***********************************************************  *     Bop down the array of rects until we have passed  *     scanline y.  numRects is the size of the array.  ***********************************************************/
end_comment

begin_function
specifier|static
name|BOX
modifier|*
name|IndexRects
parameter_list|(
name|rects
parameter_list|,
name|numRects
parameter_list|,
name|y
parameter_list|)
specifier|register
name|BOX
modifier|*
name|rects
decl_stmt|;
specifier|register
name|int
name|numRects
decl_stmt|;
specifier|register
name|int
name|y
decl_stmt|;
block|{
while|while
condition|(
operator|(
name|numRects
operator|--
operator|)
operator|&&
operator|(
name|rects
operator|->
name|y2
operator|<=
name|y
operator|)
condition|)
name|rects
operator|++
expr_stmt|;
return|return
operator|(
name|rects
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*======================================================================  *	    Region Intersection  *====================================================================*/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miIntersectO --  *	Handle an overlapping band for miIntersect.  *  * Results:  *	None.  *  * Side Effects:  *	Rectangles may be added to the region.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* static void*/
end_comment

begin_expr_stmt
specifier|static
name|miIntersectO
argument_list|(
name|pReg
argument_list|,
name|r1
argument_list|,
name|r1End
argument_list|,
name|r2
argument_list|,
name|r2End
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
specifier|register
name|Region
name|pReg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|BoxPtr
name|r1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|r1End
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|BoxPtr
name|r2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|r2End
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|y1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|x1
decl_stmt|;
specifier|register
name|short
name|x2
decl_stmt|;
specifier|register
name|BoxPtr
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
operator|&
name|pReg
operator|->
name|rects
index|[
name|pReg
operator|->
name|numRects
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|r1
operator|!=
name|r1End
operator|)
operator|&&
operator|(
name|r2
operator|!=
name|r2End
operator|)
condition|)
block|{
name|x1
operator|=
name|max
argument_list|(
name|r1
operator|->
name|x1
argument_list|,
name|r2
operator|->
name|x1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|min
argument_list|(
name|r1
operator|->
name|x2
argument_list|,
name|r2
operator|->
name|x2
argument_list|)
expr_stmt|;
comment|/* 	 * If there's any overlap between the two rectangles, add that 	 * overlap to the new region. 	 * There's no need to check for subsumption because the only way 	 * such a need could arise is if some region has two rectangles 	 * right next to each other. Since that should never happen... 	 */
if|if
condition|(
name|x1
operator|<
name|x2
condition|)
block|{
name|assert
argument_list|(
name|y1
operator|<
name|y2
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
name|pReg
argument_list|,
name|pNextRect
argument_list|,
name|pReg
operator|->
name|rects
argument_list|)
expr_stmt|;
name|pNextRect
operator|->
name|x1
operator|=
name|x1
expr_stmt|;
name|pNextRect
operator|->
name|y1
operator|=
name|y1
expr_stmt|;
name|pNextRect
operator|->
name|x2
operator|=
name|x2
expr_stmt|;
name|pNextRect
operator|->
name|y2
operator|=
name|y2
expr_stmt|;
name|pReg
operator|->
name|numRects
operator|+=
literal|1
expr_stmt|;
name|pNextRect
operator|++
expr_stmt|;
name|assert
argument_list|(
name|pReg
operator|->
name|numRects
operator|<=
name|pReg
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Need to advance the pointers. Shift the one that extends 	 * to the right the least, since the other still has a chance to 	 * overlap with that region's next rectangle, if you see what I mean. 	 */
if|if
condition|(
name|r1
operator|->
name|x2
operator|<
name|r2
operator|->
name|x2
condition|)
block|{
name|r1
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|x2
operator|<
name|r1
operator|->
name|x2
condition|)
block|{
name|r2
operator|++
expr_stmt|;
block|}
else|else
block|{
name|r1
operator|++
expr_stmt|;
name|r2
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
comment|/* lint */
block|}
end_block

begin_macro
name|XIntersectRegion
argument_list|(
argument|reg1
argument_list|,
argument|reg2
argument_list|,
argument|newReg
argument_list|)
end_macro

begin_decl_stmt
name|Region
name|reg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Region
name|reg2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* source regions     */
end_comment

begin_decl_stmt
specifier|register
name|Region
name|newReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination Region */
end_comment

begin_block
block|{
comment|/* check for trivial reject */
if|if
condition|(
operator|(
operator|!
operator|(
name|reg1
operator|->
name|numRects
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|reg2
operator|->
name|numRects
operator|)
operator|)
operator|||
operator|(
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|reg1
operator|->
name|extents
argument_list|,
operator|&
name|reg2
operator|->
name|extents
argument_list|)
operator|)
condition|)
name|newReg
operator|->
name|numRects
operator|=
literal|0
expr_stmt|;
else|else
name|miRegionOp
argument_list|(
name|newReg
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|,
operator|(
name|voidProcp
operator|)
name|miIntersectO
argument_list|,
operator|(
name|voidProcp
operator|)
name|NULL
argument_list|,
operator|(
name|voidProcp
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Can't alter newReg's extents before we call miRegionOp because      * it might be one of the source regions and miRegionOp depends      * on the extents of those regions being the same. Besides, this      * way there's no checking against rectangles that will be nuked      * due to coalescing, so we have to examine fewer rectangles.      */
name|miSetExtents
argument_list|(
name|newReg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|miRegionCopy
parameter_list|(
name|dstrgn
parameter_list|,
name|rgn
parameter_list|)
specifier|register
name|Region
name|dstrgn
decl_stmt|;
specifier|register
name|Region
name|rgn
decl_stmt|;
block|{
if|if
condition|(
name|dstrgn
operator|!=
name|rgn
condition|)
comment|/*  don't want to copy to itself */
block|{
if|if
condition|(
name|dstrgn
operator|->
name|size
operator|<
name|rgn
operator|->
name|numRects
condition|)
block|{
if|if
condition|(
name|dstrgn
operator|->
name|rects
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dstrgn
operator|->
name|rects
operator|=
operator|(
name|BOX
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dstrgn
operator|->
name|rects
argument_list|,
operator|(
name|unsigned
operator|)
name|rgn
operator|->
name|numRects
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|BOX
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return;
block|}
name|dstrgn
operator|->
name|size
operator|=
name|rgn
operator|->
name|numRects
expr_stmt|;
block|}
name|dstrgn
operator|->
name|numRects
operator|=
name|rgn
operator|->
name|numRects
expr_stmt|;
name|dstrgn
operator|->
name|extents
operator|.
name|x1
operator|=
name|rgn
operator|->
name|extents
operator|.
name|x1
expr_stmt|;
name|dstrgn
operator|->
name|extents
operator|.
name|y1
operator|=
name|rgn
operator|->
name|extents
operator|.
name|y1
expr_stmt|;
name|dstrgn
operator|->
name|extents
operator|.
name|x2
operator|=
name|rgn
operator|->
name|extents
operator|.
name|x2
expr_stmt|;
name|dstrgn
operator|->
name|extents
operator|.
name|y2
operator|=
name|rgn
operator|->
name|extents
operator|.
name|y2
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rgn
operator|->
name|rects
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dstrgn
operator|->
name|rects
argument_list|,
call|(
name|int
call|)
argument_list|(
name|rgn
operator|->
name|numRects
operator|*
sizeof|sizeof
argument_list|(
name|BOX
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  *  combinRegs(newReg, reg1, reg2)  *    if one region is above or below the other. */
end_comment

begin_function
specifier|static
name|void
name|combineRegs
parameter_list|(
name|newReg
parameter_list|,
name|reg1
parameter_list|,
name|reg2
parameter_list|)
specifier|register
name|Region
name|newReg
decl_stmt|;
name|Region
name|reg1
decl_stmt|;
name|Region
name|reg2
decl_stmt|;
block|{
specifier|register
name|Region
name|tempReg
decl_stmt|;
specifier|register
name|BOX
modifier|*
name|rects
decl_stmt|;
specifier|register
name|BOX
modifier|*
name|rects1
decl_stmt|;
specifier|register
name|BOX
modifier|*
name|rects2
decl_stmt|;
specifier|register
name|int
name|total
decl_stmt|;
name|rects1
operator|=
name|reg1
operator|->
name|rects
expr_stmt|;
name|rects2
operator|=
name|reg2
operator|->
name|rects
expr_stmt|;
name|total
operator|=
name|reg1
operator|->
name|numRects
operator|+
name|reg2
operator|->
name|numRects
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tempReg
operator|=
name|XCreateRegion
argument_list|()
operator|)
condition|)
return|return;
name|tempReg
operator|->
name|size
operator|=
name|total
expr_stmt|;
comment|/*  region 1 is below region 2  */
if|if
condition|(
name|reg1
operator|->
name|extents
operator|.
name|y1
operator|>
name|reg2
operator|->
name|extents
operator|.
name|y1
condition|)
block|{
name|miRegionCopy
argument_list|(
name|tempReg
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
name|rects
operator|=
operator|&
name|tempReg
operator|->
name|rects
index|[
name|tempReg
operator|->
name|numRects
index|]
expr_stmt|;
name|total
operator|-=
name|tempReg
operator|->
name|numRects
expr_stmt|;
while|while
condition|(
name|total
operator|--
condition|)
operator|*
name|rects
operator|++
operator|=
operator|*
name|rects1
operator|++
expr_stmt|;
block|}
else|else
block|{
name|miRegionCopy
argument_list|(
name|tempReg
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
name|rects
operator|=
operator|&
name|tempReg
operator|->
name|rects
index|[
name|tempReg
operator|->
name|numRects
index|]
expr_stmt|;
name|total
operator|-=
name|tempReg
operator|->
name|numRects
expr_stmt|;
while|while
condition|(
name|total
operator|--
condition|)
operator|*
name|rects
operator|++
operator|=
operator|*
name|rects2
operator|++
expr_stmt|;
block|}
name|tempReg
operator|->
name|extents
operator|=
name|reg1
operator|->
name|extents
expr_stmt|;
name|tempReg
operator|->
name|numRects
operator|=
name|reg1
operator|->
name|numRects
operator|+
name|reg2
operator|->
name|numRects
expr_stmt|;
name|EXTENTS
argument_list|(
operator|&
name|reg2
operator|->
name|extents
argument_list|,
name|tempReg
argument_list|)
expr_stmt|;
name|miRegionCopy
argument_list|(
name|newReg
argument_list|,
name|tempReg
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tempReg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  QuickCheck checks to see if it does not have to go through all the  *  the ugly code for the region call.  It returns 1 if it did all  *  the work for Union, otherwise 0 - still work to be done. */
end_comment

begin_function
specifier|static
name|int
name|QuickCheck
parameter_list|(
name|newReg
parameter_list|,
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|Region
name|newReg
decl_stmt|,
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
block|{
comment|/*  if unioning with itself or no rects to union with  */
if|if
condition|(
operator|(
name|reg1
operator|==
name|reg2
operator|)
operator|||
operator|(
operator|!
operator|(
name|reg1
operator|->
name|numRects
operator|)
operator|)
condition|)
block|{
name|miRegionCopy
argument_list|(
name|newReg
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*   if nothing to union   */
if|if
condition|(
operator|!
operator|(
name|reg2
operator|->
name|numRects
operator|)
condition|)
block|{
name|miRegionCopy
argument_list|(
name|newReg
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*   could put an extent check to see if add above or below */
if|if
condition|(
operator|(
name|reg1
operator|->
name|extents
operator|.
name|y1
operator|>=
name|reg2
operator|->
name|extents
operator|.
name|y2
operator|)
operator|||
operator|(
name|reg2
operator|->
name|extents
operator|.
name|y1
operator|>=
name|reg1
operator|->
name|extents
operator|.
name|y2
operator|)
condition|)
block|{
name|combineRegs
argument_list|(
name|newReg
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   TopRects(rects, reg1, reg2)  * N.B. We now assume that reg1 and reg2 intersect.  Therefore we are  * NOT checking in the two while loops for stepping off the end of the  * region.    */
end_comment

begin_function
specifier|static
name|int
name|TopRects
parameter_list|(
name|newReg
parameter_list|,
name|rects
parameter_list|,
name|reg1
parameter_list|,
name|reg2
parameter_list|,
name|FirstRect
parameter_list|)
specifier|register
name|Region
name|newReg
decl_stmt|;
specifier|register
name|BOX
modifier|*
name|rects
decl_stmt|;
specifier|register
name|Region
name|reg1
decl_stmt|;
specifier|register
name|Region
name|reg2
decl_stmt|;
name|BOX
modifier|*
name|FirstRect
decl_stmt|;
block|{
specifier|register
name|BOX
modifier|*
name|tempRects
decl_stmt|;
comment|/*  need to add some rects from region 1 */
if|if
condition|(
name|reg1
operator|->
name|extents
operator|.
name|y1
operator|<
name|reg2
operator|->
name|extents
operator|.
name|y1
condition|)
block|{
name|tempRects
operator|=
name|reg1
operator|->
name|rects
expr_stmt|;
while|while
condition|(
name|tempRects
operator|->
name|y1
operator|<
name|reg2
operator|->
name|extents
operator|.
name|y1
condition|)
block|{
name|MEMCHECK
argument_list|(
name|newReg
argument_list|,
name|rects
argument_list|,
name|FirstRect
argument_list|)
expr_stmt|;
name|ADDRECTNOX
argument_list|(
name|newReg
argument_list|,
name|rects
argument_list|,
name|tempRects
operator|->
name|x1
argument_list|,
name|tempRects
operator|->
name|y1
argument_list|,
name|tempRects
operator|->
name|x2
argument_list|,
name|MIN
argument_list|(
name|tempRects
operator|->
name|y2
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|tempRects
operator|++
expr_stmt|;
block|}
block|}
comment|/*  need to add some rects from region 2 */
if|if
condition|(
name|reg2
operator|->
name|extents
operator|.
name|y1
operator|<
name|reg1
operator|->
name|extents
operator|.
name|y1
condition|)
block|{
name|tempRects
operator|=
name|reg2
operator|->
name|rects
expr_stmt|;
while|while
condition|(
name|tempRects
operator|->
name|y1
operator|<
name|reg1
operator|->
name|extents
operator|.
name|y1
condition|)
block|{
name|MEMCHECK
argument_list|(
name|newReg
argument_list|,
name|rects
argument_list|,
name|FirstRect
argument_list|)
expr_stmt|;
name|ADDRECTNOX
argument_list|(
name|newReg
argument_list|,
name|rects
argument_list|,
name|tempRects
operator|->
name|x1
argument_list|,
name|tempRects
operator|->
name|y1
argument_list|,
name|tempRects
operator|->
name|x2
argument_list|,
name|MIN
argument_list|(
name|tempRects
operator|->
name|y2
argument_list|,
name|reg1
operator|->
name|extents
operator|.
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|tempRects
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*======================================================================  *	    Generic Region Operator  *====================================================================*/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miCoalesce --  *	Attempt to merge the boxes in the current band with those in the  *	previous one. Used only by miRegionOp.  *  * Results:  *	The new index for the previous band.  *  * Side Effects:  *	If coalescing takes place:  *	    - rectangles in the previous band will have their y2 fields  *	      altered.  *	    - pReg->numRects will be decreased.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* static int*/
end_comment

begin_expr_stmt
specifier|static
name|miCoalesce
argument_list|(
name|pReg
argument_list|,
name|prevStart
argument_list|,
name|curStart
argument_list|)
specifier|register
name|Region
name|pReg
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Region to coalesce */
end_comment

begin_decl_stmt
name|int
name|prevStart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of start of previous band */
end_comment

begin_decl_stmt
name|int
name|curStart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of start of current band */
end_comment

begin_block
block|{
specifier|register
name|BoxPtr
name|pPrevBox
decl_stmt|;
comment|/* Current box in previous band */
specifier|register
name|BoxPtr
name|pCurBox
decl_stmt|;
comment|/* Current box in current band */
specifier|register
name|BoxPtr
name|pRegEnd
decl_stmt|;
comment|/* End of region */
name|int
name|curNumRects
decl_stmt|;
comment|/* Number of rectangles in current 					 * band */
name|int
name|prevNumRects
decl_stmt|;
comment|/* Number of rectangles in previous 					 * band */
name|int
name|bandY1
decl_stmt|;
comment|/* Y1 coordinate for current band */
name|pRegEnd
operator|=
operator|&
name|pReg
operator|->
name|rects
index|[
name|pReg
operator|->
name|numRects
index|]
expr_stmt|;
name|pPrevBox
operator|=
operator|&
name|pReg
operator|->
name|rects
index|[
name|prevStart
index|]
expr_stmt|;
name|prevNumRects
operator|=
name|curStart
operator|-
name|prevStart
expr_stmt|;
comment|/*      * Figure out how many rectangles are in the current band. Have to do      * this because multiple bands could have been added in miRegionOp      * at the end when one region has been exhausted.      */
name|pCurBox
operator|=
operator|&
name|pReg
operator|->
name|rects
index|[
name|curStart
index|]
expr_stmt|;
name|bandY1
operator|=
name|pCurBox
operator|->
name|y1
expr_stmt|;
for|for
control|(
name|curNumRects
operator|=
literal|0
init|;
operator|(
name|pCurBox
operator|!=
name|pRegEnd
operator|)
operator|&&
operator|(
name|pCurBox
operator|->
name|y1
operator|==
name|bandY1
operator|)
condition|;
name|curNumRects
operator|++
control|)
block|{
name|pCurBox
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pCurBox
operator|!=
name|pRegEnd
condition|)
block|{
comment|/* 	 * If more than one band was added, we have to find the start 	 * of the last band added so the next coalescing job can start 	 * at the right place... (given when multiple bands are added, 	 * this may be pointless -- see above). 	 */
name|pRegEnd
operator|--
expr_stmt|;
while|while
condition|(
name|pRegEnd
index|[
operator|-
literal|1
index|]
operator|.
name|y1
operator|==
name|pRegEnd
operator|->
name|y1
condition|)
block|{
name|pRegEnd
operator|--
expr_stmt|;
block|}
name|curStart
operator|=
name|pRegEnd
operator|-
name|pReg
operator|->
name|rects
expr_stmt|;
name|pRegEnd
operator|=
name|pReg
operator|->
name|rects
operator|+
name|pReg
operator|->
name|numRects
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|curNumRects
operator|==
name|prevNumRects
operator|)
operator|&&
operator|(
name|curNumRects
operator|!=
literal|0
operator|)
condition|)
block|{
name|pCurBox
operator|-=
name|curNumRects
expr_stmt|;
comment|/* 	 * The bands may only be coalesced if the bottom of the previous 	 * matches the top scanline of the current. 	 */
if|if
condition|(
name|pPrevBox
operator|->
name|y2
operator|==
name|pCurBox
operator|->
name|y1
condition|)
block|{
comment|/* 	     * Make sure the bands have boxes in the same places. This 	     * assumes that boxes have been added in such a way that they 	     * cover the most area possible. I.e. two boxes in a band must 	     * have some horizontal space between them. 	     */
do|do
block|{
if|if
condition|(
operator|(
name|pPrevBox
operator|->
name|x1
operator|!=
name|pCurBox
operator|->
name|x1
operator|)
operator|||
operator|(
name|pPrevBox
operator|->
name|x2
operator|!=
name|pCurBox
operator|->
name|x2
operator|)
condition|)
block|{
comment|/* 		     * The bands don't line up so they can't be coalesced. 		     */
return|return
operator|(
name|curStart
operator|)
return|;
block|}
name|pPrevBox
operator|++
expr_stmt|;
name|pCurBox
operator|++
expr_stmt|;
name|prevNumRects
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|prevNumRects
operator|!=
literal|0
condition|)
do|;
name|pReg
operator|->
name|numRects
operator|-=
name|curNumRects
expr_stmt|;
name|pCurBox
operator|-=
name|curNumRects
expr_stmt|;
name|pPrevBox
operator|-=
name|curNumRects
expr_stmt|;
comment|/* 	     * The bands may be merged, so set the bottom y of each box 	     * in the previous band to that of the corresponding box in 	     * the current band. 	     */
do|do
block|{
name|pPrevBox
operator|->
name|y2
operator|=
name|pCurBox
operator|->
name|y2
expr_stmt|;
name|pPrevBox
operator|++
expr_stmt|;
name|pCurBox
operator|++
expr_stmt|;
name|curNumRects
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|curNumRects
operator|!=
literal|0
condition|)
do|;
comment|/* 	     * If only one band was added to the region, we have to backup 	     * curStart to the start of the previous band. 	     * 	     * If more than one band was added to the region, copy the 	     * other bands down. The assumption here is that the other bands 	     * came from the same region as the current one and no further 	     * coalescing can be done on them since it's all been done 	     * already... curStart is already in the right place. 	     */
if|if
condition|(
name|pCurBox
operator|==
name|pRegEnd
condition|)
block|{
name|curStart
operator|=
name|prevStart
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
operator|*
name|pPrevBox
operator|++
operator|=
operator|*
name|pCurBox
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|pCurBox
operator|!=
name|pRegEnd
condition|)
do|;
block|}
block|}
block|}
return|return
operator|(
name|curStart
operator|)
return|;
block|}
end_block

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miRegionOp --  *	Apply an operation to two regions. Called by miUnion, miInverse,  *	miSubtract, miIntersect...  *  * Results:  *	None.  *  * Side Effects:  *	The new region is overwritten.  *  * Notes:  *	The idea behind this function is to view the two regions as sets.  *	Together they cover a rectangle of area that this function divides  *	into horizontal bands where points are covered only by one region  *	or by both. For the first case, the nonOverlapFunc is called with  *	each the band and the band's upper and lower extents. For the  *	second, the overlapFunc is called to process the entire band. It  *	is responsible for clipping the rectangles in the band, though  *	this function provides the boundaries.  *	At the end of each band, the new region is coalesced, if possible,  *	to reduce the number of rectangles in the region.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* static void*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|miRegionOp
argument_list|(
name|newReg
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|,
name|overlapFunc
argument_list|,
name|nonOverlap1Func
argument_list|,
name|nonOverlap2Func
argument_list|)
decl|register
name|Region
name|newReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place to store result */
end_comment

begin_decl_stmt
name|Region
name|reg1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First region in operation */
end_comment

begin_decl_stmt
name|Region
name|reg2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2d region in operation */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|overlapFunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Function to call for over- 						 * lapping bands */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|nonOverlap1Func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Function to call for non- 						 * overlapping bands in region 						 * 1 */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|nonOverlap2Func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Function to call for non- 						 * overlapping bands in region 						 * 2 */
end_comment

begin_block
block|{
specifier|register
name|BoxPtr
name|r1
decl_stmt|;
comment|/* Pointer into first region */
specifier|register
name|BoxPtr
name|r2
decl_stmt|;
comment|/* Pointer into 2d region */
name|BoxPtr
name|r1End
decl_stmt|;
comment|/* End of 1st region */
name|BoxPtr
name|r2End
decl_stmt|;
comment|/* End of 2d region */
specifier|register
name|short
name|ybot
decl_stmt|;
comment|/* Bottom of intersection */
specifier|register
name|short
name|ytop
decl_stmt|;
comment|/* Top of intersection */
name|BoxPtr
name|oldRects
decl_stmt|;
comment|/* Old rects for newReg */
name|int
name|prevBand
decl_stmt|;
comment|/* Index of start of 						 * previous band in newReg */
name|int
name|curBand
decl_stmt|;
comment|/* Index of start of current 						 * band in newReg */
specifier|register
name|BoxPtr
name|r1BandEnd
decl_stmt|;
comment|/* End of current band in r1 */
specifier|register
name|BoxPtr
name|r2BandEnd
decl_stmt|;
comment|/* End of current band in r2 */
name|short
name|top
decl_stmt|;
comment|/* Top of non-overlapping 						 * band */
name|short
name|bot
decl_stmt|;
comment|/* Bottom of non-overlapping 						 * band */
comment|/*      * Initialization:      *	set r1, r2, r1End and r2End appropriately, preserve the important      * parts of the destination region until the end in case it's one of      * the two source regions, then mark the "new" region empty, allocating      * another array of rectangles for it to use.      */
name|r1
operator|=
name|reg1
operator|->
name|rects
expr_stmt|;
name|r2
operator|=
name|reg2
operator|->
name|rects
expr_stmt|;
name|r1End
operator|=
name|r1
operator|+
name|reg1
operator|->
name|numRects
expr_stmt|;
name|r2End
operator|=
name|r2
operator|+
name|reg2
operator|->
name|numRects
expr_stmt|;
name|oldRects
operator|=
name|newReg
operator|->
name|rects
expr_stmt|;
name|EMPTY_REGION
argument_list|(
name|newReg
argument_list|)
expr_stmt|;
comment|/*      * Allocate a reasonable number of rectangles for the new region. The idea      * is to allocate enough so the individual functions don't need to      * reallocate and copy the array, which is time consuming, yet we don't      * have to worry about using too much memory. I hope to be able to      * nuke the Xrealloc() at the end of this function eventually.      */
name|newReg
operator|->
name|size
operator|=
name|max
argument_list|(
name|reg1
operator|->
name|numRects
argument_list|,
name|reg2
operator|->
name|numRects
argument_list|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|newReg
operator|->
name|rects
operator|=
operator|(
name|BoxPtr
operator|)
name|Xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|BoxRec
argument_list|)
operator|*
name|newReg
operator|->
name|size
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|newReg
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*      * Initialize ybot and ytop.      * In the upcoming loop, ybot and ytop serve different functions depending      * on whether the band being handled is an overlapping or non-overlapping      * band.      * 	In the case of a non-overlapping band (only one of the regions      * has points in the band), ybot is the bottom of the most recent      * intersection and thus clips the top of the rectangles in that band.      * ytop is the top of the next intersection between the two regions and      * serves to clip the bottom of the rectangles in the current band.      *	For an overlapping band (where the two regions intersect), ytop clips      * the top of the rectangles of both regions and ybot clips the bottoms.      */
if|if
condition|(
name|reg1
operator|->
name|extents
operator|.
name|y1
operator|<
name|reg2
operator|->
name|extents
operator|.
name|y1
condition|)
name|ybot
operator|=
name|reg1
operator|->
name|extents
operator|.
name|y1
expr_stmt|;
else|else
name|ybot
operator|=
name|reg2
operator|->
name|extents
operator|.
name|y1
expr_stmt|;
comment|/*      * prevBand serves to mark the start of the previous band so rectangles      * can be coalesced into larger rectangles. qv. miCoalesce, above.      * In the beginning, there is no previous band, so prevBand == curBand      * (curBand is set later on, of course, but the first band will always      * start at index 0). prevBand and curBand must be indices because of      * the possible expansion, and resultant moving, of the new region's      * array of rectangles.      */
name|prevBand
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|curBand
operator|=
name|newReg
operator|->
name|numRects
expr_stmt|;
comment|/* 	 * This algorithm proceeds one source-band (as opposed to a 	 * destination band, which is determined by where the two regions 	 * intersect) at a time. r1BandEnd and r2BandEnd serve to mark the 	 * rectangle after the last one in the current band for their 	 * respective regions. 	 */
name|r1BandEnd
operator|=
name|r1
expr_stmt|;
while|while
condition|(
operator|(
name|r1BandEnd
operator|!=
name|r1End
operator|)
operator|&&
operator|(
name|r1BandEnd
operator|->
name|y1
operator|==
name|r1
operator|->
name|y1
operator|)
condition|)
block|{
name|r1BandEnd
operator|++
expr_stmt|;
block|}
name|r2BandEnd
operator|=
name|r2
expr_stmt|;
while|while
condition|(
operator|(
name|r2BandEnd
operator|!=
name|r2End
operator|)
operator|&&
operator|(
name|r2BandEnd
operator|->
name|y1
operator|==
name|r2
operator|->
name|y1
operator|)
condition|)
block|{
name|r2BandEnd
operator|++
expr_stmt|;
block|}
comment|/* 	 * First handle the band that doesn't intersect, if any. 	 * 	 * Note that attention is restricted to one band in the 	 * non-intersecting region at once, so if a region has n 	 * bands between the current position and the next place it overlaps 	 * the other, this entire loop will be passed through n times. 	 */
if|if
condition|(
name|r1
operator|->
name|y1
operator|<
name|r2
operator|->
name|y1
condition|)
block|{
name|top
operator|=
name|max
argument_list|(
name|r1
operator|->
name|y1
argument_list|,
name|ybot
argument_list|)
expr_stmt|;
name|bot
operator|=
name|min
argument_list|(
name|r1
operator|->
name|y2
argument_list|,
name|r2
operator|->
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|top
operator|!=
name|bot
operator|)
operator|&&
operator|(
name|nonOverlap1Func
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
operator|)
condition|)
block|{
call|(
modifier|*
name|nonOverlap1Func
call|)
argument_list|(
name|newReg
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
block|}
name|ytop
operator|=
name|r2
operator|->
name|y1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|y1
operator|<
name|r1
operator|->
name|y1
condition|)
block|{
name|top
operator|=
name|max
argument_list|(
name|r2
operator|->
name|y1
argument_list|,
name|ybot
argument_list|)
expr_stmt|;
name|bot
operator|=
name|min
argument_list|(
name|r2
operator|->
name|y2
argument_list|,
name|r1
operator|->
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|top
operator|!=
name|bot
operator|)
operator|&&
operator|(
name|nonOverlap2Func
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
operator|)
condition|)
block|{
call|(
modifier|*
name|nonOverlap2Func
call|)
argument_list|(
name|newReg
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
block|}
name|ytop
operator|=
name|r1
operator|->
name|y1
expr_stmt|;
block|}
else|else
block|{
name|ytop
operator|=
name|r1
operator|->
name|y1
expr_stmt|;
block|}
comment|/* 	 * If any rectangles got added to the region, try and coalesce them 	 * with rectangles from the previous band. Note we could just do 	 * this test in miCoalesce, but some machines incur a not 	 * inconsiderable cost for function calls, so... 	 */
if|if
condition|(
name|newReg
operator|->
name|numRects
operator|!=
name|curBand
condition|)
block|{
name|prevBand
operator|=
name|miCoalesce
argument_list|(
name|newReg
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now see if we've hit an intersecting band. The two bands only 	 * intersect if ybot> ytop 	 */
name|ybot
operator|=
name|min
argument_list|(
name|r1
operator|->
name|y2
argument_list|,
name|r2
operator|->
name|y2
argument_list|)
expr_stmt|;
name|curBand
operator|=
name|newReg
operator|->
name|numRects
expr_stmt|;
if|if
condition|(
name|ybot
operator|>
name|ytop
condition|)
block|{
call|(
modifier|*
name|overlapFunc
call|)
argument_list|(
name|newReg
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|ytop
argument_list|,
name|ybot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newReg
operator|->
name|numRects
operator|!=
name|curBand
condition|)
block|{
name|prevBand
operator|=
name|miCoalesce
argument_list|(
name|newReg
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we've finished with a band (y2 == ybot) we skip forward 	 * in the region to the next band. 	 */
if|if
condition|(
name|r1
operator|->
name|y2
operator|==
name|ybot
condition|)
block|{
name|r1
operator|=
name|r1BandEnd
expr_stmt|;
block|}
if|if
condition|(
name|r2
operator|->
name|y2
operator|==
name|ybot
condition|)
block|{
name|r2
operator|=
name|r2BandEnd
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|r1
operator|!=
name|r1End
operator|)
operator|&&
operator|(
name|r2
operator|!=
name|r2End
operator|)
condition|)
do|;
comment|/*      * Deal with whichever region still has rectangles left.      */
name|curBand
operator|=
name|newReg
operator|->
name|numRects
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
if|if
condition|(
name|nonOverlap1Func
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
condition|)
block|{
do|do
block|{
name|r1BandEnd
operator|=
name|r1
expr_stmt|;
while|while
condition|(
operator|(
name|r1BandEnd
operator|<
name|r1End
operator|)
operator|&&
operator|(
name|r1BandEnd
operator|->
name|y1
operator|==
name|r1
operator|->
name|y1
operator|)
condition|)
block|{
name|r1BandEnd
operator|++
expr_stmt|;
block|}
call|(
modifier|*
name|nonOverlap1Func
call|)
argument_list|(
name|newReg
argument_list|,
name|r1
argument_list|,
name|r1BandEnd
argument_list|,
name|max
argument_list|(
name|r1
operator|->
name|y1
argument_list|,
name|ybot
argument_list|)
argument_list|,
name|r1
operator|->
name|y2
argument_list|)
expr_stmt|;
name|r1
operator|=
name|r1BandEnd
expr_stmt|;
block|}
do|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|r2
operator|!=
name|r2End
operator|)
operator|&&
operator|(
name|nonOverlap2Func
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
operator|)
condition|)
block|{
do|do
block|{
name|r2BandEnd
operator|=
name|r2
expr_stmt|;
while|while
condition|(
operator|(
name|r2BandEnd
operator|<
name|r2End
operator|)
operator|&&
operator|(
name|r2BandEnd
operator|->
name|y1
operator|==
name|r2
operator|->
name|y1
operator|)
condition|)
block|{
name|r2BandEnd
operator|++
expr_stmt|;
block|}
call|(
modifier|*
name|nonOverlap2Func
call|)
argument_list|(
name|newReg
argument_list|,
name|r2
argument_list|,
name|r2BandEnd
argument_list|,
name|max
argument_list|(
name|r2
operator|->
name|y1
argument_list|,
name|ybot
argument_list|)
argument_list|,
name|r2
operator|->
name|y2
argument_list|)
expr_stmt|;
name|r2
operator|=
name|r2BandEnd
expr_stmt|;
block|}
do|while
condition|(
name|r2
operator|!=
name|r2End
condition|)
do|;
block|}
if|if
condition|(
name|newReg
operator|->
name|numRects
operator|!=
name|curBand
condition|)
block|{
operator|(
name|void
operator|)
name|miCoalesce
argument_list|(
name|newReg
argument_list|,
name|prevBand
argument_list|,
name|curBand
argument_list|)
expr_stmt|;
block|}
comment|/*      * A bit of cleanup. To keep regions from growing without bound,      * we shrink the array of rectangles to match the new number of      * rectangles in the region. This never goes to 0, however...      *      * Only do this stuff if the number of rectangles allocated is more than      * twice the number of rectangles in the region (a simple optimization...).      */
if|if
condition|(
name|newReg
operator|->
name|numRects
operator|<
operator|(
name|newReg
operator|->
name|size
operator|>>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|REGION_NOT_EMPTY
argument_list|(
name|newReg
argument_list|)
condition|)
block|{
name|BoxPtr
name|prev_rects
init|=
name|newReg
operator|->
name|rects
decl_stmt|;
name|newReg
operator|->
name|size
operator|=
name|newReg
operator|->
name|numRects
expr_stmt|;
name|newReg
operator|->
name|rects
operator|=
operator|(
name|BoxPtr
operator|)
name|Xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newReg
operator|->
name|rects
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|BoxRec
argument_list|)
operator|*
name|newReg
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newReg
operator|->
name|rects
condition|)
name|newReg
operator|->
name|rects
operator|=
name|prev_rects
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * No point in doing the extra work involved in an Xrealloc if 	     * the region is empty 	     */
name|newReg
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newReg
operator|->
name|rects
argument_list|)
expr_stmt|;
name|newReg
operator|->
name|rects
operator|=
operator|(
name|BoxPtr
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BoxRec
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldRects
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*======================================================================  *	    Region Union  *====================================================================*/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miUnionNonO --  *	Handle a non-overlapping band for the union operation. Just  *	Adds the rectangles into the region. Doesn't have to check for  *	subsumption or anything.  *  * Results:  *	None.  *  * Side Effects:  *	pReg->numRects is incremented and the final rectangles overwritten  *	with the rectangles we're passed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* static void*/
end_comment

begin_expr_stmt
specifier|static
name|miUnionNonO
argument_list|(
name|pReg
argument_list|,
name|r
argument_list|,
name|rEnd
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
specifier|register
name|Region
name|pReg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|BoxPtr
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|rEnd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|y1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BoxPtr
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
operator|&
name|pReg
operator|->
name|rects
index|[
name|pReg
operator|->
name|numRects
index|]
expr_stmt|;
name|assert
argument_list|(
name|y1
operator|<
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|rEnd
condition|)
block|{
name|assert
argument_list|(
name|r
operator|->
name|x1
operator|<
name|r
operator|->
name|x2
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
name|pReg
argument_list|,
name|pNextRect
argument_list|,
name|pReg
operator|->
name|rects
argument_list|)
expr_stmt|;
name|pNextRect
operator|->
name|x1
operator|=
name|r
operator|->
name|x1
expr_stmt|;
name|pNextRect
operator|->
name|y1
operator|=
name|y1
expr_stmt|;
name|pNextRect
operator|->
name|x2
operator|=
name|r
operator|->
name|x2
expr_stmt|;
name|pNextRect
operator|->
name|y2
operator|=
name|y2
expr_stmt|;
name|pReg
operator|->
name|numRects
operator|+=
literal|1
expr_stmt|;
name|pNextRect
operator|++
expr_stmt|;
name|assert
argument_list|(
name|pReg
operator|->
name|numRects
operator|<=
name|pReg
operator|->
name|size
argument_list|)
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* lint */
block|}
end_block

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miUnionO --  *	Handle an overlapping band for the union operation. Picks the  *	left-most rectangle each time and merges it into the region.  *  * Results:  *	None.  *  * Side Effects:  *	Rectangles are overwritten in pReg->rects and pReg->numRects will  *	be changed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* static void*/
end_comment

begin_expr_stmt
specifier|static
name|miUnionO
argument_list|(
name|pReg
argument_list|,
name|r1
argument_list|,
name|r1End
argument_list|,
name|r2
argument_list|,
name|r2End
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
specifier|register
name|Region
name|pReg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|BoxPtr
name|r1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|r1End
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|BoxPtr
name|r2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|r2End
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|y1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BoxPtr
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
operator|&
name|pReg
operator|->
name|rects
index|[
name|pReg
operator|->
name|numRects
index|]
expr_stmt|;
define|#
directive|define
name|MERGERECT
parameter_list|(
name|r
parameter_list|)
define|\
value|if ((pReg->numRects != 0)&&  \ 	(pNextRect[-1].y1 == y1)&&  \ 	(pNextRect[-1].y2 == y2)&&  \ 	(pNextRect[-1].x2>= r->x1))  \     {  \ 	if (pNextRect[-1].x2< r->x2)  \ 	{  \ 	    pNextRect[-1].x2 = r->x2;  \ 	    assert(pNextRect[-1].x1<pNextRect[-1].x2); \ 	}  \     }  \     else  \     {  \ 	MEMCHECK(pReg, pNextRect, pReg->rects);  \ 	pNextRect->y1 = y1;  \ 	pNextRect->y2 = y2;  \ 	pNextRect->x1 = r->x1;  \ 	pNextRect->x2 = r->x2;  \ 	pReg->numRects += 1;  \         pNextRect += 1;  \     }  \     assert(pReg->numRects<=pReg->size);\     r++;
name|assert
argument_list|(
name|y1
operator|<
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r1
operator|!=
name|r1End
operator|)
operator|&&
operator|(
name|r2
operator|!=
name|r2End
operator|)
condition|)
block|{
if|if
condition|(
name|r1
operator|->
name|x1
operator|<
name|r2
operator|->
name|x1
condition|)
block|{
name|MERGERECT
argument_list|(
name|r1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MERGERECT
argument_list|(
name|r2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
do|do
block|{
name|MERGERECT
argument_list|(
name|r1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
do|;
block|}
else|else
while|while
condition|(
name|r2
operator|!=
name|r2End
condition|)
block|{
name|MERGERECT
argument_list|(
name|r2
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* lint */
block|}
end_block

begin_macro
name|XUnionRegion
argument_list|(
argument|reg1
argument_list|,
argument|reg2
argument_list|,
argument|newReg
argument_list|)
end_macro

begin_decl_stmt
name|Region
name|reg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Region
name|reg2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* source regions     */
end_comment

begin_decl_stmt
name|Region
name|newReg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination Region */
end_comment

begin_block
block|{
comment|/*  checks all the simple cases */
comment|/*      * Region 1 and 2 are the same or region 1 is empty      */
if|if
condition|(
operator|(
name|reg1
operator|==
name|reg2
operator|)
operator|||
operator|(
operator|!
operator|(
name|reg1
operator|->
name|numRects
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|newReg
operator|!=
name|reg2
condition|)
name|miRegionCopy
argument_list|(
name|newReg
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*      * if nothing to union (region 2 empty)      */
if|if
condition|(
operator|!
operator|(
name|reg2
operator|->
name|numRects
operator|)
condition|)
block|{
if|if
condition|(
name|newReg
operator|!=
name|reg1
condition|)
name|miRegionCopy
argument_list|(
name|newReg
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*      * Region 1 completely subsumes region 2      */
if|if
condition|(
operator|(
name|reg1
operator|->
name|numRects
operator|==
literal|1
operator|)
operator|&&
operator|(
name|reg1
operator|->
name|extents
operator|.
name|x1
operator|<=
name|reg2
operator|->
name|extents
operator|.
name|x1
operator|)
operator|&&
operator|(
name|reg1
operator|->
name|extents
operator|.
name|y1
operator|<=
name|reg2
operator|->
name|extents
operator|.
name|y1
operator|)
operator|&&
operator|(
name|reg1
operator|->
name|extents
operator|.
name|x2
operator|>=
name|reg2
operator|->
name|extents
operator|.
name|x2
operator|)
operator|&&
operator|(
name|reg1
operator|->
name|extents
operator|.
name|y2
operator|>=
name|reg2
operator|->
name|extents
operator|.
name|y2
operator|)
condition|)
block|{
if|if
condition|(
name|newReg
operator|!=
name|reg1
condition|)
name|miRegionCopy
argument_list|(
name|newReg
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*      * Region 2 completely subsumes region 1      */
if|if
condition|(
operator|(
name|reg2
operator|->
name|numRects
operator|==
literal|1
operator|)
operator|&&
operator|(
name|reg2
operator|->
name|extents
operator|.
name|x1
operator|<=
name|reg1
operator|->
name|extents
operator|.
name|x1
operator|)
operator|&&
operator|(
name|reg2
operator|->
name|extents
operator|.
name|y1
operator|<=
name|reg1
operator|->
name|extents
operator|.
name|y1
operator|)
operator|&&
operator|(
name|reg2
operator|->
name|extents
operator|.
name|x2
operator|>=
name|reg1
operator|->
name|extents
operator|.
name|x2
operator|)
operator|&&
operator|(
name|reg2
operator|->
name|extents
operator|.
name|y2
operator|>=
name|reg1
operator|->
name|extents
operator|.
name|y2
operator|)
condition|)
block|{
if|if
condition|(
name|newReg
operator|!=
name|reg2
condition|)
name|miRegionCopy
argument_list|(
name|newReg
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|miRegionOp
argument_list|(
name|newReg
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|,
operator|(
name|voidProcp
operator|)
name|miUnionO
argument_list|,
operator|(
name|voidProcp
operator|)
name|miUnionNonO
argument_list|,
operator|(
name|voidProcp
operator|)
name|miUnionNonO
argument_list|)
expr_stmt|;
name|newReg
operator|->
name|extents
operator|.
name|x1
operator|=
name|min
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|x1
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|x1
argument_list|)
expr_stmt|;
name|newReg
operator|->
name|extents
operator|.
name|y1
operator|=
name|min
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|y1
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|y1
argument_list|)
expr_stmt|;
name|newReg
operator|->
name|extents
operator|.
name|x2
operator|=
name|max
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|x2
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|x2
argument_list|)
expr_stmt|;
name|newReg
operator|->
name|extents
operator|.
name|y2
operator|=
name|max
argument_list|(
name|reg1
operator|->
name|extents
operator|.
name|y2
argument_list|,
name|reg2
operator|->
name|extents
operator|.
name|y2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*======================================================================  * 	    	  Region Subtraction  *====================================================================*/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtractNonO --  *	Deal with non-overlapping band for subtraction. Any parts from  *	region 2 we discard. Anything from region 1 we add to the region.  *  * Results:  *	None.  *  * Side Effects:  *	pReg may be affected.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* static void*/
end_comment

begin_expr_stmt
specifier|static
name|miSubtractNonO1
argument_list|(
name|pReg
argument_list|,
name|r
argument_list|,
name|rEnd
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
specifier|register
name|Region
name|pReg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|BoxPtr
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|rEnd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|y1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BoxPtr
name|pNextRect
decl_stmt|;
name|pNextRect
operator|=
operator|&
name|pReg
operator|->
name|rects
index|[
name|pReg
operator|->
name|numRects
index|]
expr_stmt|;
name|assert
argument_list|(
name|y1
operator|<
name|y2
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|rEnd
condition|)
block|{
name|assert
argument_list|(
name|r
operator|->
name|x1
operator|<
name|r
operator|->
name|x2
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
name|pReg
argument_list|,
name|pNextRect
argument_list|,
name|pReg
operator|->
name|rects
argument_list|)
expr_stmt|;
name|pNextRect
operator|->
name|x1
operator|=
name|r
operator|->
name|x1
expr_stmt|;
name|pNextRect
operator|->
name|y1
operator|=
name|y1
expr_stmt|;
name|pNextRect
operator|->
name|x2
operator|=
name|r
operator|->
name|x2
expr_stmt|;
name|pNextRect
operator|->
name|y2
operator|=
name|y2
expr_stmt|;
name|pReg
operator|->
name|numRects
operator|+=
literal|1
expr_stmt|;
name|pNextRect
operator|++
expr_stmt|;
name|assert
argument_list|(
name|pReg
operator|->
name|numRects
operator|<=
name|pReg
operator|->
name|size
argument_list|)
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* lint */
block|}
end_block

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtractO --  *	Overlapping band subtraction. x1 is the left-most point not yet  *	checked.  *  * Results:  *	None.  *  * Side Effects:  *	pReg may have rectangles added to it.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* static void*/
end_comment

begin_expr_stmt
specifier|static
name|miSubtractO
argument_list|(
name|pReg
argument_list|,
name|r1
argument_list|,
name|r1End
argument_list|,
name|r2
argument_list|,
name|r2End
argument_list|,
name|y1
argument_list|,
name|y2
argument_list|)
specifier|register
name|Region
name|pReg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|BoxPtr
name|r1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|r1End
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|BoxPtr
name|r2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BoxPtr
name|r2End
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|y1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|short
name|y2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BoxPtr
name|pNextRect
decl_stmt|;
specifier|register
name|int
name|x1
decl_stmt|;
name|x1
operator|=
name|r1
operator|->
name|x1
expr_stmt|;
name|assert
argument_list|(
name|y1
operator|<
name|y2
argument_list|)
expr_stmt|;
name|pNextRect
operator|=
operator|&
name|pReg
operator|->
name|rects
index|[
name|pReg
operator|->
name|numRects
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|r1
operator|!=
name|r1End
operator|)
operator|&&
operator|(
name|r2
operator|!=
name|r2End
operator|)
condition|)
block|{
if|if
condition|(
name|r2
operator|->
name|x2
operator|<=
name|x1
condition|)
block|{
comment|/* 	     * Subtrahend missed the boat: go to next subtrahend. 	     */
name|r2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|x1
operator|<=
name|x1
condition|)
block|{
comment|/* 	     * Subtrahend preceeds minuend: nuke left edge of minuend. 	     */
name|x1
operator|=
name|r2
operator|->
name|x2
expr_stmt|;
if|if
condition|(
name|x1
operator|>=
name|r1
operator|->
name|x2
condition|)
block|{
comment|/* 		 * Minuend completely covered: advance to next minuend and 		 * reset left fence to edge of new minuend. 		 */
name|r1
operator|++
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|x1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Subtrahend now used up since it doesn't extend beyond 		 * minuend 		 */
name|r2
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r2
operator|->
name|x1
operator|<
name|r1
operator|->
name|x2
condition|)
block|{
comment|/* 	     * Left part of subtrahend covers part of minuend: add uncovered 	     * part of minuend to region and skip to next subtrahend. 	     */
name|assert
argument_list|(
name|x1
operator|<
name|r2
operator|->
name|x1
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
name|pReg
argument_list|,
name|pNextRect
argument_list|,
name|pReg
operator|->
name|rects
argument_list|)
expr_stmt|;
name|pNextRect
operator|->
name|x1
operator|=
name|x1
expr_stmt|;
name|pNextRect
operator|->
name|y1
operator|=
name|y1
expr_stmt|;
name|pNextRect
operator|->
name|x2
operator|=
name|r2
operator|->
name|x1
expr_stmt|;
name|pNextRect
operator|->
name|y2
operator|=
name|y2
expr_stmt|;
name|pReg
operator|->
name|numRects
operator|+=
literal|1
expr_stmt|;
name|pNextRect
operator|++
expr_stmt|;
name|assert
argument_list|(
name|pReg
operator|->
name|numRects
operator|<=
name|pReg
operator|->
name|size
argument_list|)
expr_stmt|;
name|x1
operator|=
name|r2
operator|->
name|x2
expr_stmt|;
if|if
condition|(
name|x1
operator|>=
name|r1
operator|->
name|x2
condition|)
block|{
comment|/* 		 * Minuend used up: advance to new... 		 */
name|r1
operator|++
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
name|x1
operator|=
name|r1
operator|->
name|x1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Subtrahend used up 		 */
name|r2
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Minuend used up: add any remaining piece before advancing. 	     */
if|if
condition|(
name|r1
operator|->
name|x2
operator|>
name|x1
condition|)
block|{
name|MEMCHECK
argument_list|(
name|pReg
argument_list|,
name|pNextRect
argument_list|,
name|pReg
operator|->
name|rects
argument_list|)
expr_stmt|;
name|pNextRect
operator|->
name|x1
operator|=
name|x1
expr_stmt|;
name|pNextRect
operator|->
name|y1
operator|=
name|y1
expr_stmt|;
name|pNextRect
operator|->
name|x2
operator|=
name|r1
operator|->
name|x2
expr_stmt|;
name|pNextRect
operator|->
name|y2
operator|=
name|y2
expr_stmt|;
name|pReg
operator|->
name|numRects
operator|+=
literal|1
expr_stmt|;
name|pNextRect
operator|++
expr_stmt|;
name|assert
argument_list|(
name|pReg
operator|->
name|numRects
operator|<=
name|pReg
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|r1
operator|++
expr_stmt|;
name|x1
operator|=
name|r1
operator|->
name|x1
expr_stmt|;
block|}
block|}
comment|/*      * Add remaining minuend rectangles to region.      */
while|while
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
name|assert
argument_list|(
name|x1
operator|<
name|r1
operator|->
name|x2
argument_list|)
expr_stmt|;
name|MEMCHECK
argument_list|(
name|pReg
argument_list|,
name|pNextRect
argument_list|,
name|pReg
operator|->
name|rects
argument_list|)
expr_stmt|;
name|pNextRect
operator|->
name|x1
operator|=
name|x1
expr_stmt|;
name|pNextRect
operator|->
name|y1
operator|=
name|y1
expr_stmt|;
name|pNextRect
operator|->
name|x2
operator|=
name|r1
operator|->
name|x2
expr_stmt|;
name|pNextRect
operator|->
name|y2
operator|=
name|y2
expr_stmt|;
name|pReg
operator|->
name|numRects
operator|+=
literal|1
expr_stmt|;
name|pNextRect
operator|++
expr_stmt|;
name|assert
argument_list|(
name|pReg
operator|->
name|numRects
operator|<=
name|pReg
operator|->
name|size
argument_list|)
expr_stmt|;
name|r1
operator|++
expr_stmt|;
if|if
condition|(
name|r1
operator|!=
name|r1End
condition|)
block|{
name|x1
operator|=
name|r1
operator|->
name|x1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
comment|/* lint */
block|}
end_block

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * miSubtract --  *	Subtract regS from regM and leave the result in regD.  *	S stands for subtrahend, M for minuend and D for difference.  *  * Results:  *	TRUE.  *  * Side Effects:  *	regD is overwritten.  *  *-----------------------------------------------------------------------  */
end_comment

begin_macro
name|XSubtractRegion
argument_list|(
argument|regM
argument_list|,
argument|regS
argument_list|,
argument|regD
argument_list|)
end_macro

begin_decl_stmt
name|Region
name|regM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Region
name|regS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Region
name|regD
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* check for trivial reject */
if|if
condition|(
operator|(
operator|!
operator|(
name|regM
operator|->
name|numRects
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|regS
operator|->
name|numRects
operator|)
operator|)
operator|||
operator|(
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|regM
operator|->
name|extents
argument_list|,
operator|&
name|regS
operator|->
name|extents
argument_list|)
operator|)
condition|)
block|{
name|miRegionCopy
argument_list|(
name|regD
argument_list|,
name|regM
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|miRegionOp
argument_list|(
name|regD
argument_list|,
name|regM
argument_list|,
name|regS
argument_list|,
operator|(
name|voidProcp
operator|)
name|miSubtractO
argument_list|,
operator|(
name|voidProcp
operator|)
name|miSubtractNonO1
argument_list|,
operator|(
name|voidProcp
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Can't alter newReg's extents before we call miRegionOp because      * it might be one of the source regions and miRegionOp depends      * on the extents of those regions being the unaltered. Besides, this      * way there's no checking against rectangles that will be nuked      * due to coalescing, so we have to examine fewer rectangles.      */
name|miSetExtents
argument_list|(
name|regD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|XXorRegion
argument_list|(
argument|sra
argument_list|,
argument|srb
argument_list|,
argument|dr
argument_list|)
end_macro

begin_decl_stmt
name|Region
name|sra
decl_stmt|,
name|srb
decl_stmt|,
name|dr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Region
name|tra
decl_stmt|,
name|trb
decl_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|tra
operator|=
name|XCreateRegion
argument_list|()
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|trb
operator|=
name|XCreateRegion
argument_list|()
operator|)
operator|)
condition|)
return|return;
operator|(
name|void
operator|)
name|XSubtractRegion
argument_list|(
name|sra
argument_list|,
name|srb
argument_list|,
name|tra
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|XSubtractRegion
argument_list|(
name|srb
argument_list|,
name|sra
argument_list|,
name|trb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|XUnionRegion
argument_list|(
name|tra
argument_list|,
name|trb
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|XDestroyRegion
argument_list|(
name|tra
argument_list|)
expr_stmt|;
name|XDestroyRegion
argument_list|(
name|trb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check to see if the region is empty.  Assumes a region is passed   * as a parameter  */
end_comment

begin_function
name|int
name|XEmptyRegion
parameter_list|(
name|r
parameter_list|)
name|Region
name|r
decl_stmt|;
block|{
if|if
condition|(
name|r
operator|->
name|numRects
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Check to see if two regions are equal	  */
end_comment

begin_function
name|int
name|XEqualRegion
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
name|Region
name|r1
decl_stmt|,
name|r2
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|r1
operator|->
name|numRects
operator|!=
name|r2
operator|->
name|numRects
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|numRects
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|extents
operator|.
name|x1
operator|!=
name|r2
operator|->
name|extents
operator|.
name|x1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|extents
operator|.
name|x2
operator|!=
name|r2
operator|->
name|extents
operator|.
name|x2
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|extents
operator|.
name|y1
operator|!=
name|r2
operator|->
name|extents
operator|.
name|y1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|extents
operator|.
name|y2
operator|!=
name|r2
operator|->
name|extents
operator|.
name|y2
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r1
operator|->
name|numRects
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|r1
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|x1
operator|!=
name|r2
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|x1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|x2
operator|!=
name|r2
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|x2
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|y1
operator|!=
name|r2
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|y1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|y2
operator|!=
name|r2
operator|->
name|rects
index|[
name|i
index|]
operator|.
name|y2
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|XPointInRegion
parameter_list|(
name|pRegion
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|Region
name|pRegion
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pRegion
operator|->
name|numRects
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|INBOX
argument_list|(
name|pRegion
operator|->
name|extents
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pRegion
operator|->
name|numRects
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|INBOX
argument_list|(
name|pRegion
operator|->
name|rects
index|[
name|i
index|]
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|XRectInRegion
parameter_list|(
name|region
parameter_list|,
name|rx
parameter_list|,
name|ry
parameter_list|,
name|rwidth
parameter_list|,
name|rheight
parameter_list|)
specifier|register
name|Region
name|region
decl_stmt|;
name|int
name|rx
decl_stmt|,
name|ry
decl_stmt|;
name|unsigned
name|int
name|rwidth
decl_stmt|,
name|rheight
decl_stmt|;
block|{
specifier|register
name|BoxPtr
name|pbox
decl_stmt|;
specifier|register
name|BoxPtr
name|pboxEnd
decl_stmt|;
name|Box
name|rect
decl_stmt|;
specifier|register
name|BoxPtr
name|prect
init|=
operator|&
name|rect
decl_stmt|;
name|int
name|partIn
decl_stmt|,
name|partOut
decl_stmt|;
name|prect
operator|->
name|x1
operator|=
name|rx
expr_stmt|;
name|prect
operator|->
name|y1
operator|=
name|ry
expr_stmt|;
name|prect
operator|->
name|x2
operator|=
name|rwidth
operator|+
name|rx
expr_stmt|;
name|prect
operator|->
name|y2
operator|=
name|rheight
operator|+
name|ry
expr_stmt|;
comment|/* this is (just) a useful optimization */
if|if
condition|(
operator|(
name|region
operator|->
name|numRects
operator|==
literal|0
operator|)
operator|||
operator|!
name|EXTENTCHECK
argument_list|(
operator|&
name|region
operator|->
name|extents
argument_list|,
name|prect
argument_list|)
condition|)
return|return
operator|(
name|RectangleOut
operator|)
return|;
name|partOut
operator|=
name|FALSE
expr_stmt|;
name|partIn
operator|=
name|FALSE
expr_stmt|;
comment|/* can stop when both partOut and partIn are TRUE, or we reach prect->y2 */
for|for
control|(
name|pbox
operator|=
name|region
operator|->
name|rects
operator|,
name|pboxEnd
operator|=
name|pbox
operator|+
name|region
operator|->
name|numRects
init|;
name|pbox
operator|<
name|pboxEnd
condition|;
name|pbox
operator|++
control|)
block|{
if|if
condition|(
name|pbox
operator|->
name|y2
operator|<=
name|ry
condition|)
continue|continue;
comment|/* getting up to speed or skipping remainder of band */
if|if
condition|(
name|pbox
operator|->
name|y1
operator|>
name|ry
condition|)
block|{
name|partOut
operator|=
name|TRUE
expr_stmt|;
comment|/* missed part of rectangle above */
if|if
condition|(
name|partIn
operator|||
operator|(
name|pbox
operator|->
name|y1
operator|>=
name|prect
operator|->
name|y2
operator|)
condition|)
break|break;
name|ry
operator|=
name|pbox
operator|->
name|y1
expr_stmt|;
comment|/* x guaranteed to be == prect->x1 */
block|}
if|if
condition|(
name|pbox
operator|->
name|x2
operator|<=
name|rx
condition|)
continue|continue;
comment|/* not far enough over yet */
if|if
condition|(
name|pbox
operator|->
name|x1
operator|>
name|rx
condition|)
block|{
name|partOut
operator|=
name|TRUE
expr_stmt|;
comment|/* missed part of rectangle to left */
if|if
condition|(
name|partIn
condition|)
break|break;
block|}
if|if
condition|(
name|pbox
operator|->
name|x1
operator|<
name|prect
operator|->
name|x2
condition|)
block|{
name|partIn
operator|=
name|TRUE
expr_stmt|;
comment|/* definitely overlap */
if|if
condition|(
name|partOut
condition|)
break|break;
block|}
if|if
condition|(
name|pbox
operator|->
name|x2
operator|>=
name|prect
operator|->
name|x2
condition|)
block|{
name|ry
operator|=
name|pbox
operator|->
name|y2
expr_stmt|;
comment|/* finished with this band */
if|if
condition|(
name|ry
operator|>=
name|prect
operator|->
name|y2
condition|)
break|break;
name|rx
operator|=
name|prect
operator|->
name|x1
expr_stmt|;
comment|/* reset x out to left again */
block|}
else|else
block|{
comment|/* 	     * Because boxes in a band are maximal width, if the first box 	     * to overlap the rectangle doesn't completely cover it in that 	     * band, the rectangle must be partially out, since some of it 	     * will be uncovered in that band. partIn will have been set true 	     * by now... 	     */
break|break;
block|}
block|}
return|return
operator|(
name|partIn
condition|?
operator|(
operator|(
name|ry
operator|<
name|prect
operator|->
name|y2
operator|)
condition|?
name|RectanglePart
else|:
name|RectangleIn
operator|)
else|:
name|RectangleOut
operator|)
return|;
block|}
end_function

end_unit

