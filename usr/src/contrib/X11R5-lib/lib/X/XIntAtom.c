begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XIntAtom.c,v 11.19 91/08/14 09:52:08 rws Exp $ */
end_comment

begin_comment
comment|/*  Copyright 1986, 1990 by the Massachusetts Institute of Technology  Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_define
define|#
directive|define
name|NEED_REPLIES
end_define

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_define
define|#
directive|define
name|TABLESIZE
value|64
end_define

begin_typedef
typedef|typedef
struct|struct
name|_Entry
block|{
name|unsigned
name|long
name|sig
decl_stmt|;
name|Atom
name|atom
decl_stmt|;
block|}
name|EntryRec
operator|,
typedef|*
name|Entry
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EntryName
parameter_list|(
name|e
parameter_list|)
value|((char *)(e+1))
end_define

begin_typedef
typedef|typedef
struct|struct
name|_XDisplayAtoms
block|{
name|Entry
name|table
index|[
name|TABLESIZE
index|]
decl_stmt|;
block|}
name|AtomTable
typedef|;
end_typedef

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|sig
parameter_list|)
value|((sig)& (TABLESIZE-1))
end_define

begin_define
define|#
directive|define
name|REHASHVAL
parameter_list|(
name|sig
parameter_list|)
value|((((sig) % (TABLESIZE-3)) + 2) | 1)
end_define

begin_define
define|#
directive|define
name|REHASH
parameter_list|(
name|idx
parameter_list|,
name|rehash
parameter_list|)
value|((idx + rehash)& (TABLESIZE-1))
end_define

begin_function
specifier|static
name|void
name|_XFreeAtomTable
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
block|{
specifier|register
name|Entry
modifier|*
name|table
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Entry
name|e
decl_stmt|;
if|if
condition|(
name|table
operator|=
name|dpy
operator|->
name|atoms
operator|->
name|table
condition|)
block|{
for|for
control|(
name|i
operator|=
name|TABLESIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|=
operator|*
name|table
operator|++
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpy
operator|->
name|atoms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|Atom
name|XInternAtom
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
name|_Xconst
name|char
modifier|*
name|name
parameter_list|,
name|Bool
name|onlyIfExists
parameter_list|)
else|#
directive|else
function|Atom XInternAtom
parameter_list|(
name|dpy
parameter_list|,
name|name
parameter_list|,
name|onlyIfExists
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Bool
name|onlyIfExists
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|AtomTable
modifier|*
name|atoms
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|unsigned
name|long
name|sig
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
name|Entry
name|e
decl_stmt|,
name|oe
decl_stmt|;
name|int
name|n
decl_stmt|,
name|firstidx
decl_stmt|,
name|rehash
decl_stmt|;
name|xInternAtomReply
name|rep
decl_stmt|;
name|xInternAtomReq
modifier|*
name|req
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
literal|""
expr_stmt|;
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
comment|/* look in the cache first */
if|if
condition|(
operator|!
operator|(
name|atoms
operator|=
name|dpy
operator|->
name|atoms
operator|)
condition|)
block|{
name|dpy
operator|->
name|atoms
operator|=
name|atoms
operator|=
operator|(
name|AtomTable
operator|*
operator|)
name|Xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|AtomTable
argument_list|)
argument_list|)
expr_stmt|;
name|dpy
operator|->
name|free_funcs
operator|->
name|atoms
operator|=
name|_XFreeAtomTable
expr_stmt|;
block|}
name|sig
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s1
operator|=
operator|(
name|char
operator|*
operator|)
name|name
init|;
name|c
operator|=
operator|*
name|s1
operator|++
condition|;
control|)
name|sig
operator|=
operator|(
name|sig
operator|<<
literal|1
operator|)
operator|+
name|c
expr_stmt|;
name|n
operator|=
name|s1
operator|-
operator|(
name|char
operator|*
operator|)
name|name
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|atoms
condition|)
block|{
name|firstidx
operator|=
name|idx
operator|=
name|HASH
argument_list|(
name|sig
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
operator|=
name|atoms
operator|->
name|table
index|[
name|idx
index|]
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|sig
operator|==
name|sig
condition|)
block|{
for|for
control|(
name|i
operator|=
name|n
operator|,
name|s1
operator|=
operator|(
name|char
operator|*
operator|)
name|name
operator|,
name|s2
operator|=
name|EntryName
argument_list|(
name|e
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s1
operator|++
operator|!=
operator|*
name|s2
operator|++
condition|)
goto|goto
name|nomatch
goto|;
block|}
if|if
condition|(
operator|!
operator|*
name|s2
condition|)
block|{
name|rep
operator|.
name|atom
operator|=
name|e
operator|->
name|atom
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return
name|rep
operator|.
name|atom
return|;
block|}
block|}
name|nomatch
label|:
if|if
condition|(
name|idx
operator|==
name|firstidx
condition|)
name|rehash
operator|=
name|REHASHVAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|idx
operator|=
name|REHASH
argument_list|(
name|idx
argument_list|,
name|rehash
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|firstidx
condition|)
break|break;
block|}
block|}
comment|/* not found, go to the server */
name|GetReq
argument_list|(
name|InternAtom
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|req
operator|->
name|nbytes
operator|=
name|n
expr_stmt|;
name|req
operator|->
name|onlyIfExists
operator|=
name|onlyIfExists
expr_stmt|;
name|req
operator|->
name|length
operator|+=
operator|(
name|n
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
name|_XSend
argument_list|(
name|dpy
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* use _XSend instead of Data, since the following _XReply            will always flush the buffer anyway */
if|if
condition|(
name|_XReply
argument_list|(
name|dpy
argument_list|,
operator|(
name|xReply
operator|*
operator|)
operator|&
name|rep
argument_list|,
literal|0
argument_list|,
name|xTrue
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rep
operator|.
name|atom
operator|=
name|None
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|.
name|atom
operator|&&
name|atoms
condition|)
block|{
comment|/* store it in the cache */
name|e
operator|=
operator|(
name|Entry
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EntryRec
argument_list|)
operator|+
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|e
operator|->
name|sig
operator|=
name|sig
expr_stmt|;
name|e
operator|->
name|atom
operator|=
name|rep
operator|.
name|atom
expr_stmt|;
name|strcpy
argument_list|(
name|EntryName
argument_list|(
name|e
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|oe
operator|=
name|atoms
operator|->
name|table
index|[
name|idx
index|]
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oe
argument_list|)
expr_stmt|;
name|atoms
operator|->
name|table
index|[
name|idx
index|]
operator|=
name|e
expr_stmt|;
block|}
block|}
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|SyncHandle
argument_list|()
expr_stmt|;
return|return
operator|(
name|rep
operator|.
name|atom
operator|)
return|;
block|}
end_function

end_unit

