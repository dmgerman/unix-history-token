begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: ProtoFlt.c,v 1.28 92/10/22 14:25:16 rws Exp $  */
end_comment

begin_comment
comment|/*  * Copyright 1990, 1991 by OMRON Corporation  * Copyright 1991 by the Massachusetts Institute of Technology  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of OMRON and MIT not be used in  * advertising or publicity pertaining to distribution of the software without  * specific, written prior permission.  OMRON and MIT make no representations  * about the suitability of this software for any purpose.  It is provided  * "as is" without express or implied warranty.  *  * OMRON AND MIT DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO  * EVENT SHALL OMRON OR MIT BE LIABLE FOR ANY SPECIAL, INDIRECT OR  * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER  * TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.   *  *	Author:	Seiji Kuwari	OMRON Corporation  *				kuwa@omron.co.jp  *				kuwa%omron.co.jp@uunet.uu.net  */
end_comment

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_define
define|#
directive|define
name|XK_MISCELLANY
end_define

begin_define
define|#
directive|define
name|XK_LATIN1
end_define

begin_include
include|#
directive|include
file|<X11/keysymdef.h>
end_include

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xi18nint.h"
end_include

begin_include
include|#
directive|include
file|"XIMlibint.h"
end_include

begin_function
specifier|static
name|void
name|_call_preedit_draw
parameter_list|(
name|ic
parameter_list|,
name|cb
parameter_list|)
name|XipIC
name|ic
decl_stmt|;
name|XIMCallback
modifier|*
name|cb
decl_stmt|;
block|{
name|XipIM
name|im
init|=
name|ipIMofIC
argument_list|(
name|ic
argument_list|)
decl_stmt|;
name|XIMPreeditDrawCallbackStruct
name|call_data
decl_stmt|;
name|XIMText
name|text
decl_stmt|;
name|ximPreDrawReply
name|reply
decl_stmt|;
name|XIMFeedback
name|fb
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|wc_len
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|scanned_bytes
decl_stmt|;
ifndef|#
directive|ifndef
name|X_WCHAR
name|int
name|mb_len
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply
argument_list|,
name|sz_ximPreDrawReply
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return;
block|}
name|length
operator|=
operator|(
name|int
operator|)
name|reply
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|reply
operator|.
name|encoding_is_wchar
operator|!=
name|True
condition|)
block|{
if|if
condition|(
name|length
operator|>
name|ic
operator|->
name|max_of_ct
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ct_buf
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ct_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|ic
operator|->
name|max_of_ct
operator|=
name|length
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|ct_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|Xrealloc
argument_list|(
name|ic
operator|->
name|ct_buf
argument_list|,
operator|(
name|ic
operator|->
name|max_of_ct
operator|=
name|length
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
name|ic
operator|->
name|ct_buf
argument_list|,
name|length
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|ic
operator|->
name|ct_buf
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
name|ic
operator|->
name|max_of_wc
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|wc_buf
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|wc_buf
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|ic
operator|->
name|max_of_wc
operator|=
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|wc_buf
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|Xrealloc
argument_list|(
name|ic
operator|->
name|wc_buf
argument_list|,
operator|(
name|ic
operator|->
name|max_of_wc
operator|=
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reply
operator|.
name|encoding_is_wchar
operator|!=
name|True
condition|)
block|{
name|wc_len
operator|=
name|ic
operator|->
name|max_of_wc
expr_stmt|;
ifdef|#
directive|ifdef
name|X_WCHAR
name|ret
operator|=
name|_XConvertCTToWC
argument_list|(
name|ic
operator|->
name|wc
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ic
operator|->
name|ct_buf
argument_list|,
name|length
argument_list|,
operator|(
name|wchar
operator|*
operator|)
name|ic
operator|->
name|wc_buf
argument_list|,
operator|&
name|wc_len
argument_list|,
operator|&
name|scanned_bytes
argument_list|,
operator|(
name|_State
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|mb_len
operator|=
name|length
operator|*
literal|2
expr_stmt|;
name|mbuf
operator|=
name|_XAllocScratch
argument_list|(
name|im
operator|->
name|core
operator|.
name|display
argument_list|,
name|mb_len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_XConvertCTToMB
argument_list|(
name|ic
operator|->
name|mb
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ic
operator|->
name|ct_buf
argument_list|,
name|length
argument_list|,
name|mbuf
argument_list|,
operator|&
name|mb_len
argument_list|,
operator|&
name|scanned_bytes
argument_list|,
operator|(
name|_State
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|macII
name|wc_len
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|mbuf
index|[
name|mb_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wc_len
operator|=
name|mbstowcs
argument_list|(
name|ic
operator|->
name|wc_buf
argument_list|,
name|mbuf
argument_list|,
name|ic
operator|->
name|max_of_wc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wc_len
operator|==
name|ic
operator|->
name|max_of_wc
condition|)
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ic
operator|->
name|wc_buf
argument_list|,
operator|(
name|length
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|ic
operator|->
name|wc_buf
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|wc_len
operator|=
name|length
expr_stmt|;
block|}
name|text
operator|.
name|length
operator|=
name|wc_len
expr_stmt|;
name|fb
operator|=
operator|(
name|XIMFeedback
operator|)
name|reply
operator|.
name|feedback
expr_stmt|;
name|text
operator|.
name|feedback
operator|=
operator|&
name|fb
expr_stmt|;
name|text
operator|.
name|encoding_is_wchar
operator|=
name|True
expr_stmt|;
name|text
operator|.
name|string
operator|.
name|wide_char
operator|=
name|ic
operator|->
name|wc_buf
expr_stmt|;
block|}
else|else
block|{
name|text
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|feedback
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|encoding_is_wchar
operator|=
name|True
expr_stmt|;
name|text
operator|.
name|string
operator|.
name|wide_char
operator|=
name|NULL
expr_stmt|;
name|text
operator|.
name|string
operator|.
name|multi_byte
operator|=
name|NULL
expr_stmt|;
block|}
name|call_data
operator|.
name|text
operator|=
operator|&
name|text
expr_stmt|;
name|call_data
operator|.
name|caret
operator|=
operator|(
name|int
operator|)
name|reply
operator|.
name|caret
expr_stmt|;
name|call_data
operator|.
name|chg_first
operator|=
operator|(
name|int
operator|)
name|reply
operator|.
name|chg_first
expr_stmt|;
name|call_data
operator|.
name|chg_length
operator|=
operator|(
name|int
operator|)
name|reply
operator|.
name|chg_length
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|cb
operator|->
name|callback
argument_list|)
argument_list|(
name|ic
argument_list|,
name|cb
operator|->
name|client_data
argument_list|,
operator|&
name|call_data
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|_call_preedit_caret
parameter_list|(
name|ic
parameter_list|,
name|cb
parameter_list|)
name|XipIC
name|ic
decl_stmt|;
name|XIMCallback
modifier|*
name|cb
decl_stmt|;
block|{
name|XIMPreeditCaretCallbackStruct
name|call_data
decl_stmt|;
name|ximPreCaretReply
name|reply
decl_stmt|;
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|ipIMofIC
argument_list|(
name|ic
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply
argument_list|,
name|sz_ximPreCaretReply
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return;
block|}
name|call_data
operator|.
name|position
operator|=
operator|(
name|int
operator|)
name|reply
operator|.
name|position
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|reply
operator|.
name|direction
condition|)
block|{
case|case
name|XIM_CB_FW_CHAR
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMForwardChar
expr_stmt|;
break|break;
case|case
name|XIM_CB_BW_CHAR
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMBackwardChar
expr_stmt|;
break|break;
case|case
name|XIM_CB_FW_WORD
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMForwardWord
expr_stmt|;
break|break;
case|case
name|XIM_CB_BW_WORD
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMBackwardWord
expr_stmt|;
break|break;
case|case
name|XIM_CB_CARET_UP
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMCaretUp
expr_stmt|;
break|break;
case|case
name|XIM_CB_CARET_DOWN
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMCaretDown
expr_stmt|;
break|break;
case|case
name|XIM_CB_NEXT_LINE
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMNextLine
expr_stmt|;
break|break;
case|case
name|XIM_CB_PREV_LINE
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMPreviousLine
expr_stmt|;
break|break;
case|case
name|XIM_CB_LINE_START
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMLineStart
expr_stmt|;
break|break;
case|case
name|XIM_CB_LINE_END
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMLineEnd
expr_stmt|;
break|break;
case|case
name|XIM_CB_ABS_POS
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMAbsolutePosition
expr_stmt|;
break|break;
case|case
name|XIM_CB_DONT_CHANGE
case|:
name|call_data
operator|.
name|direction
operator|=
name|XIMDontChange
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|call_data
operator|.
name|style
operator|=
operator|(
name|XIMCaretStyle
operator|)
name|reply
operator|.
name|style
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|cb
operator|->
name|callback
argument_list|)
argument_list|(
name|ic
argument_list|,
name|cb
operator|->
name|client_data
argument_list|,
operator|&
name|call_data
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|_call_status_draw
parameter_list|(
name|ic
parameter_list|,
name|cb
parameter_list|)
name|XipIC
name|ic
decl_stmt|;
name|XIMCallback
modifier|*
name|cb
decl_stmt|;
block|{
name|XipIM
name|im
init|=
name|ipIMofIC
argument_list|(
name|ic
argument_list|)
decl_stmt|;
name|XIMStatusDrawCallbackStruct
name|call_data
decl_stmt|;
name|XIMText
name|text
decl_stmt|;
name|ximStatusDrawReply
name|reply
decl_stmt|;
name|XIMFeedback
name|fb
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|wc_len
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|scanned_bytes
decl_stmt|;
ifndef|#
directive|ifndef
name|X_WCHAR
name|int
name|mb_len
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply
argument_list|,
name|sz_ximStatusDrawReply
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|reply
operator|.
name|type
operator|==
name|XIM_ST_BITMAP
condition|)
block|{
name|call_data
operator|.
name|type
operator|=
name|XIMBitmapType
expr_stmt|;
name|call_data
operator|.
name|data
operator|.
name|bitmap
operator|=
operator|(
name|Pixmap
operator|)
name|reply
operator|.
name|bitmap
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
operator|(
name|int
operator|)
name|reply
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|reply
operator|.
name|encoding_is_wchar
operator|!=
name|True
condition|)
block|{
if|if
condition|(
name|length
operator|>
name|ic
operator|->
name|max_of_ct
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ct_buf
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ct_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|ic
operator|->
name|max_of_ct
operator|=
name|length
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|ct_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|Xrealloc
argument_list|(
name|ic
operator|->
name|ct_buf
argument_list|,
operator|(
name|ic
operator|->
name|max_of_ct
operator|=
name|length
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
name|ic
operator|->
name|ct_buf
argument_list|,
name|length
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|ic
operator|->
name|ct_buf
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
name|ic
operator|->
name|max_of_wc
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|wc_buf
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|wc_buf
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|ic
operator|->
name|max_of_wc
operator|=
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|wc_buf
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|Xrealloc
argument_list|(
name|ic
operator|->
name|wc_buf
argument_list|,
operator|(
name|ic
operator|->
name|max_of_wc
operator|=
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reply
operator|.
name|encoding_is_wchar
operator|!=
name|True
condition|)
block|{
name|wc_len
operator|=
name|ic
operator|->
name|max_of_wc
expr_stmt|;
ifdef|#
directive|ifdef
name|X_WCHAR
name|ret
operator|=
name|_XConvertCTToWC
argument_list|(
name|ic
operator|->
name|wc
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ic
operator|->
name|ct_buf
argument_list|,
name|length
argument_list|,
operator|(
name|wchar
operator|*
operator|)
name|ic
operator|->
name|wc_buf
argument_list|,
operator|&
name|wc_len
argument_list|,
operator|&
name|scanned_bytes
argument_list|,
operator|(
name|_State
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|mb_len
operator|=
name|length
operator|*
literal|2
expr_stmt|;
name|mbuf
operator|=
name|_XAllocScratch
argument_list|(
name|im
operator|->
name|core
operator|.
name|display
argument_list|,
name|mb_len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_XConvertCTToMB
argument_list|(
name|ic
operator|->
name|mb
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ic
operator|->
name|ct_buf
argument_list|,
name|length
argument_list|,
name|mbuf
argument_list|,
operator|&
name|mb_len
argument_list|,
operator|&
name|scanned_bytes
argument_list|,
operator|(
name|_State
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|macII
name|wc_len
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|mbuf
index|[
name|mb_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wc_len
operator|=
name|mbstowcs
argument_list|(
name|ic
operator|->
name|wc_buf
argument_list|,
name|mbuf
argument_list|,
name|ic
operator|->
name|max_of_wc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wc_len
operator|==
name|ic
operator|->
name|max_of_wc
condition|)
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ic
operator|->
name|wc_buf
argument_list|,
operator|(
name|length
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|)
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|ic
operator|->
name|wc_buf
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|wc_len
operator|=
name|length
expr_stmt|;
block|}
block|}
name|call_data
operator|.
name|type
operator|=
name|XIMTextType
expr_stmt|;
name|call_data
operator|.
name|data
operator|.
name|text
operator|=
operator|&
name|text
expr_stmt|;
name|text
operator|.
name|length
operator|=
name|wc_len
expr_stmt|;
name|fb
operator|=
operator|(
name|XIMFeedback
operator|)
name|reply
operator|.
name|feedback
expr_stmt|;
name|text
operator|.
name|feedback
operator|=
operator|&
name|fb
expr_stmt|;
name|text
operator|.
name|encoding_is_wchar
operator|=
name|True
expr_stmt|;
name|text
operator|.
name|string
operator|.
name|wide_char
operator|=
name|ic
operator|->
name|wc_buf
expr_stmt|;
block|}
call|(
name|void
call|)
argument_list|(
name|cb
operator|->
name|callback
argument_list|)
argument_list|(
name|ic
argument_list|,
name|cb
operator|->
name|client_data
argument_list|,
operator|&
name|call_data
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|_XipCallCallbacks
parameter_list|(
name|ic
parameter_list|)
name|XipIC
name|ic
decl_stmt|;
block|{
name|ICCallbacks
modifier|*
name|pre_cbs
init|=
operator|&
name|ic
operator|->
name|core
operator|.
name|preedit_attr
operator|.
name|callbacks
decl_stmt|;
name|ICCallbacks
modifier|*
name|st_cbs
init|=
operator|&
name|ic
operator|->
name|core
operator|.
name|status_attr
operator|.
name|callbacks
decl_stmt|;
name|ximNormalReply
name|reply
decl_stmt|;
name|int
name|type
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|ipIMofIC
argument_list|(
name|ic
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply
argument_list|,
name|sz_ximNormalReply
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|type
operator|=
operator|(
name|int
operator|)
name|reply
operator|.
name|detail
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|XIM_CB_PRE_START
condition|)
block|{
if|if
condition|(
name|pre_cbs
operator|->
name|start
operator|.
name|callback
condition|)
block|{
call|(
modifier|*
name|pre_cbs
operator|->
name|start
operator|.
name|callback
call|)
argument_list|(
name|ic
argument_list|,
name|pre_cbs
operator|->
name|start
operator|.
name|client_data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|XIM_CB_PRE_DONE
condition|)
block|{
if|if
condition|(
name|pre_cbs
operator|->
name|done
operator|.
name|callback
condition|)
block|{
call|(
modifier|*
name|pre_cbs
operator|->
name|done
operator|.
name|callback
call|)
argument_list|(
name|ic
argument_list|,
name|pre_cbs
operator|->
name|done
operator|.
name|client_data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|XIM_CB_PRE_DRAW
condition|)
block|{
operator|(
name|void
operator|)
name|_call_preedit_draw
argument_list|(
name|ic
argument_list|,
operator|&
operator|(
name|pre_cbs
operator|->
name|draw
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|XIM_CB_PRE_CARET
condition|)
block|{
operator|(
name|void
operator|)
name|_call_preedit_caret
argument_list|(
name|ic
argument_list|,
operator|&
operator|(
name|pre_cbs
operator|->
name|caret
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|XIM_CB_ST_START
condition|)
block|{
if|if
condition|(
name|st_cbs
operator|->
name|start
operator|.
name|callback
condition|)
block|{
call|(
modifier|*
name|st_cbs
operator|->
name|start
operator|.
name|callback
call|)
argument_list|(
name|ic
argument_list|,
name|st_cbs
operator|->
name|start
operator|.
name|client_data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|XIM_CB_ST_DONE
condition|)
block|{
if|if
condition|(
name|st_cbs
operator|->
name|done
operator|.
name|callback
condition|)
block|{
call|(
modifier|*
name|st_cbs
operator|->
name|done
operator|.
name|callback
call|)
argument_list|(
name|ic
argument_list|,
name|st_cbs
operator|->
name|done
operator|.
name|client_data
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|XIM_CB_ST_DRAW
condition|)
block|{
operator|(
name|void
operator|)
name|_call_status_draw
argument_list|(
name|ic
argument_list|,
operator|&
operator|(
name|st_cbs
operator|->
name|draw
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|Bool
name|_XipBackEndFilter
parameter_list|(
name|display
parameter_list|,
name|window
parameter_list|,
name|ev
parameter_list|,
name|client_data
parameter_list|)
name|Display
modifier|*
name|display
decl_stmt|;
name|Window
name|window
decl_stmt|;
name|XEvent
modifier|*
name|ev
decl_stmt|;
name|XPointer
name|client_data
decl_stmt|;
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|XipIC
name|ic
init|=
operator|(
name|XipIC
operator|)
name|client_data
decl_stmt|;
name|XipIM
name|im
init|=
name|ipIMofIC
argument_list|(
name|ic
argument_list|)
decl_stmt|;
name|ximEventReq
name|req
decl_stmt|;
name|ximEventReply
name|reply
decl_stmt|;
name|ximReturnReply
name|reply1
decl_stmt|;
name|KeySym
name|keysym
decl_stmt|;
name|int
name|keycode
decl_stmt|;
name|int
name|mode
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|XEvent
name|dummy_ev
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|first
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|XML
name|char
name|tmp_lc_name
index|[
literal|32
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* XML */
if|if
condition|(
operator|!
name|im
operator|||
operator|(
name|im
operator|->
name|fd
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
name|False
operator|)
return|;
comment|/*      * If key_code is 0, this key event be regarded      * as the event pushed back by this filter.      */
if|if
condition|(
name|ev
operator|->
name|xkey
operator|.
name|keycode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|_XipTypeOfNextICQueue
argument_list|(
name|ic
argument_list|)
operator|==
name|XIM_KEYSYM
operator|&&
operator|(
name|keysym
operator|=
name|_XipKeySymOfNextICQueue
argument_list|(
name|ic
argument_list|)
operator|)
operator|>
name|XK_BackSpace
condition|)
block|{
if|if
condition|(
operator|(
name|keycode
operator|=
name|XKeysymToKeycode
argument_list|(
name|display
argument_list|,
name|keysym
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ev
operator|->
name|xkey
operator|.
name|keycode
operator|=
name|keycode
expr_stmt|;
name|ev
operator|->
name|xkey
operator|.
name|state
operator|=
name|_XipStateOfNextICQueue
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|_XipFreeNextICQueue
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|False
operator|)
return|;
block|}
if|if
condition|(
name|ic
operator|->
name|out
condition|)
name|ic
operator|->
name|out
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|xany
operator|.
name|window
operator|!=
name|window
condition|)
block|{
name|ev
operator|->
name|xany
operator|.
name|window
operator|=
name|window
expr_stmt|;
block|}
name|req
operator|.
name|reqType
operator|=
name|XIM_Event
expr_stmt|;
name|req
operator|.
name|length
operator|=
name|sz_ximEventReq
operator|+
sizeof|sizeof
argument_list|(
name|XEvent
argument_list|)
expr_stmt|;
name|req
operator|.
name|xic
operator|=
name|ic
operator|->
name|icid
expr_stmt|;
if|if
condition|(
operator|(
name|_XipWriteToIM
argument_list|(
name|im
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
name|sz_ximEventReq
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|_XipWriteToIM
argument_list|(
name|im
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ev
argument_list|,
sizeof|sizeof
argument_list|(
name|XEvent
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|_XipFlushToIM
argument_list|(
name|im
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|True
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply
argument_list|,
name|sz_ximEventReply
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|reply
operator|.
name|state
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mode
operator|=
operator|(
name|int
operator|)
name|reply
operator|.
name|detail
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|XIM_NOTHING
condition|)
block|{
comment|/* 	     * The input manager filtered a event. 	     */
name|ret
operator|=
name|True
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|XIM_NOFILTER
condition|)
block|{
comment|/* 	     * The input manager didn't filter a event. 	     */
name|ret
operator|=
name|False
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|XIM_RETURN
condition|)
block|{
comment|/* 	     * The input manager returns some strings and events. 	     */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply1
argument_list|,
name|sz_ximReturnReply
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|reply1
operator|.
name|type
operator|==
name|XIM_KEYSYM
operator|||
name|reply1
operator|.
name|type
operator|==
name|XIM_STRING
condition|)
block|{
if|if
condition|(
name|_XipPutICQueue
argument_list|(
name|ic
argument_list|,
operator|(
name|short
operator|)
name|reply1
operator|.
name|type
argument_list|,
operator|(
name|int
operator|)
name|reply1
operator|.
name|length
argument_list|,
operator|(
name|KeySym
operator|)
name|reply1
operator|.
name|keysym
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ev
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dummy_ev
argument_list|,
sizeof|sizeof
argument_list|(
name|XEvent
argument_list|)
argument_list|)
expr_stmt|;
name|dummy_ev
operator|.
name|type
operator|=
name|KeyPress
expr_stmt|;
name|dummy_ev
operator|.
name|xkey
operator|.
name|state
operator|=
literal|0
expr_stmt|;
name|dummy_ev
operator|.
name|xkey
operator|.
name|keycode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|count
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|XPutBackEvent
argument_list|(
name|display
argument_list|,
operator|&
name|dummy_ev
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|first
operator|>
literal|0
condition|)
continue|continue;
name|first
operator|++
expr_stmt|;
name|ev
operator|->
name|xkey
operator|.
name|state
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|xkey
operator|.
name|keycode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_XipTypeOfNextICQueue
argument_list|(
name|ic
argument_list|)
operator|==
name|XIM_KEYSYM
operator|&&
operator|(
name|keysym
operator|=
name|_XipKeySymOfNextICQueue
argument_list|(
name|ic
argument_list|)
operator|)
operator|>
name|XK_BackSpace
condition|)
block|{
if|if
condition|(
operator|(
name|keycode
operator|=
name|XKeysymToKeycode
argument_list|(
name|display
argument_list|,
name|keysym
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ev
operator|->
name|xkey
operator|.
name|keycode
operator|=
name|keycode
expr_stmt|;
name|ev
operator|->
name|xkey
operator|.
name|state
operator|=
name|_XipStateOfNextICQueue
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|_XipFreeNextICQueue
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|XIM_CALLBACK
condition|)
block|{
comment|/* 	     * Calling callback routines. 	     */
if|if
condition|(
name|_XipCallCallbacks
argument_list|(
name|ic
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|True
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|XML
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|XIM_CH_LOCALE
condition|)
block|{
if|if
condition|(
name|_XipReadFromIM
argument_list|(
name|im
argument_list|,
name|tmp_lc_name
argument_list|,
name|reply
operator|.
name|number
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tmp_lc_name
index|[
name|reply
operator|.
name|number
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_XipChangeLocale
argument_list|(
name|ic
argument_list|,
name|tmp_lc_name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ic
operator|->
name|values
operator|.
name|ch_locale_cb
call|)
argument_list|(
name|tmp_lc_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|True
expr_stmt|;
endif|#
directive|endif
comment|/* XML */
block|}
else|else
block|{
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
end_function

end_unit

