begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: XCnvMBToCT.c,v 1.21 92/04/14 15:54:22 rws Exp $  */
end_comment

begin_comment
comment|/*  * Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,  *                      and Nippon Telegraph and Telephone Corporation  * Copyright 1991 by the Massachusetts Institute of Technology  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of OMRON, NTT Software, NTT, and M.I.T.  * not be used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission. OMRON, NTT Software,  * NTT, and M.I.T. make no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * OMRON, NTT SOFTWARE, NTT, AND M.I.T. DISCLAIM ALL WARRANTIES WITH REGARD  * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS, IN NO EVENT SHALL OMRON, NTT SOFTWARE, NTT, OR M.I.T. BE  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *   *	Authors: Li Yuhong		OMRON Corporation  *		 Hiroshi Kuribayashi	OMRON Corporation  *     */
end_comment

begin_comment
comment|/*  * Functions:  *  _XConvertMBToCT()  *  _XConvertCTToMB()  *   */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xlocaleint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_function_decl
specifier|static
name|int
name|_XConvertCTextToMB
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Bool
name|_XcwEscSetStatus
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_XcwIdGetISOState
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_XParseISOEncoding
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_XmbSetCsid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_XctIsExtendSegment
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Constant Definitions */
end_comment

begin_define
define|#
directive|define
name|HT
value|0x09
end_define

begin_comment
comment|/* horizontal tab */
end_comment

begin_define
define|#
directive|define
name|NL
value|0x0A
end_define

begin_comment
comment|/* new line */
end_comment

begin_define
define|#
directive|define
name|ESC
value|0x1B
end_define

begin_comment
comment|/* escape */
end_comment

begin_define
define|#
directive|define
name|CSI
value|0x9B
end_define

begin_comment
comment|/* control sequence introducer. */
end_comment

begin_define
define|#
directive|define
name|SPACE
value|0x20
end_define

begin_comment
comment|/* space */
end_comment

begin_define
define|#
directive|define
name|GL94MIN
value|0x21
end_define

begin_comment
comment|/* manimun of code of GL 94 charset */
end_comment

begin_define
define|#
directive|define
name|GL94MAX
value|0x7E
end_define

begin_comment
comment|/* maximun of code of GL 94 charset */
end_comment

begin_define
define|#
directive|define
name|Return
parameter_list|(
name|result
parameter_list|)
value|{                                               \         *ct_bytes = ctcnt;                                              \         *scanned_bytes = mbcnt;                                         \ 	if (state) *state = xlocale->mb_state;				\         if (ctcnt< limit)						\ 	    *ct_str = 0;
comment|/* additional service */
value|\         if (error> 0) return (error);                                  \         return (result);                                                \     }
end_define

begin_define
define|#
directive|define
name|SaveStore
parameter_list|(
name|c
parameter_list|)
value|{                                                  \         if (ctcnt>= limit) Return(BadBuffer);                          \         *ct_str++ = c;                                                  \         ctcnt++;                                                        \     }
end_define

begin_define
define|#
directive|define
name|AppendDesignation
parameter_list|(
name|state
parameter_list|)
value|{                                      \         int len = strlen(state);                                        \         if ((ctcnt + len)> limit)                                      \            Return(BadBuffer);                                           \         (void) strcpy((char *)ct_str, state);                           \         ct_str += len;                                                  \         ctcnt += len;                                                   \     }
end_define

begin_function
name|int
name|_XConvertMBToCT
parameter_list|(
name|xlocale
parameter_list|,
name|mb_str
parameter_list|,
name|mb_bytes
parameter_list|,
name|ct_str
parameter_list|,
name|ct_bytes
parameter_list|,
name|scanned_bytes
parameter_list|,
name|state
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mb_str
decl_stmt|;
name|int
name|mb_bytes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str
decl_stmt|;
name|int
modifier|*
name|ct_bytes
decl_stmt|;
name|int
modifier|*
name|scanned_bytes
decl_stmt|;
name|_State
modifier|*
name|state
decl_stmt|;
block|{
name|int
name|mbcnt
decl_stmt|,
name|ctcnt
decl_stmt|,
name|crmbcnt
decl_stmt|,
name|crctcnt
decl_stmt|;
name|_CSID
name|csid
decl_stmt|;
name|int
name|limit
decl_stmt|,
name|deslen
decl_stmt|,
name|error
decl_stmt|,
name|ret
decl_stmt|;
name|char
modifier|*
name|esc
decl_stmt|,
name|seq
index|[
name|MAXSEQUENCELENGTH
index|]
decl_stmt|,
name|c
decl_stmt|;
name|_State
name|state_sv
decl_stmt|,
name|state_ext
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str_sv
init|=
name|NULL
decl_stmt|;
name|int
name|len_sv
decl_stmt|;
if|if
condition|(
operator|!
name|xlocale
condition|)
name|xlocale
operator|=
name|_XFallBackConvert
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|&&
operator|*
name|state
operator|!=
name|XDEFAULT_STATE
condition|)
block|{
name|xlocale
operator|->
name|mb_state
operator|=
operator|*
name|state
expr_stmt|;
if|if
condition|(
name|_XmbCheck
argument_list|(
name|xlocale
argument_list|)
operator|==
name|False
condition|)
name|_Xmbinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
block|}
else|else
name|_Xmbinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|*
name|ct_bytes
expr_stmt|;
name|mbcnt
operator|=
name|ctcnt
operator|=
literal|0
expr_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|ct_state
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mb_bytes
operator|>
literal|0
operator|&&
operator|(
name|c
operator|=
operator|*
name|mb_str
operator|)
operator|!=
literal|0
condition|)
block|{
name|_CSID
name|ctGLorGR
decl_stmt|;
if|if
condition|(
operator|(
name|csid
operator|=
name|_Xmbcsid
argument_list|(
name|xlocale
argument_list|,
name|mb_str
argument_list|)
operator|)
operator|==
name|ND
condition|)
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
comment|/*          * filter control characters.          */
if|if
condition|(
name|csid
operator|==
name|C0
operator|||
name|csid
operator|==
name|C1
condition|)
block|{
name|SaveStore
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|mb_str
operator|++
operator|,
name|mb_bytes
operator|--
operator|,
name|mbcnt
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*          * skip designation sequence of state-dependent codeset.          * Warning: cannot recover the error of BadTerminate in this case.          */
if|if
condition|(
name|_Xmbtype
argument_list|(
name|xlocale
argument_list|)
operator|==
name|CDS_STATEFUL
operator|&&
operator|(
name|deslen
operator|=
name|_Xmbdlen
argument_list|(
name|xlocale
argument_list|,
name|mb_str
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|mb_str
operator|+=
name|deslen
operator|,
name|mb_bytes
operator|-=
name|deslen
operator|,
name|mbcnt
operator|+=
name|deslen
expr_stmt|;
continue|continue;
block|}
name|ctGLorGR
operator|=
name|_XmbctGLorGR
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|ctSetGLorGR
argument_list|(
name|xlocale
argument_list|,
name|ctGLorGR
argument_list|)
expr_stmt|;
name|ctSetid
argument_list|(
name|xlocale
argument_list|,
name|_Xmbctid
argument_list|(
name|xlocale
argument_list|,
name|csid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctGLorGR
operator|==
name|GL
operator|&&
name|ctGetGLid
argument_list|(
name|xlocale
argument_list|)
operator|!=
operator|(
name|state_sv
operator|&
literal|0xff
operator|)
operator|||
name|ctGLorGR
operator|==
name|GR
operator|&&
name|ctGetGRid
argument_list|(
name|xlocale
argument_list|)
operator|!=
operator|(
operator|(
name|state_sv
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
condition|)
block|{
comment|/*              * append designation of control sequence.             */
name|state_ext
operator|=
name|state_sv
expr_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|ct_state
expr_stmt|;
name|_XcwIdGetEncoding
argument_list|(
name|xlocale
argument_list|,
operator|&
name|esc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|esc
operator|+
literal|1
operator|)
operator|==
literal|0x25
condition|)
block|{
name|ct_str_sv
operator|=
name|ct_str
operator|+
literal|4
expr_stmt|;
name|len_sv
operator|=
name|strlen
argument_list|(
name|esc
argument_list|)
operator|-
literal|6
expr_stmt|;
block|}
name|AppendDesignation
argument_list|(
name|esc
argument_list|)
expr_stmt|;
block|}
comment|/*          * remainning buffer length of ct_str.          */
name|crctcnt
operator|=
name|limit
operator|-
name|ctcnt
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|_XmbDecomposeGlyphCharset
argument_list|(
name|xlocale
argument_list|,
name|mb_str
argument_list|,
name|mb_bytes
argument_list|,
name|ct_str
argument_list|,
operator|&
name|crctcnt
argument_list|,
operator|&
name|crmbcnt
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Return
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct_str_sv
condition|)
block|{
operator|*
name|ct_str_sv
operator|++
operator|=
operator|(
name|crctcnt
operator|+
name|len_sv
operator|)
operator|/
literal|128
operator|+
literal|128
expr_stmt|;
operator|*
name|ct_str_sv
operator|=
operator|(
name|crctcnt
operator|+
name|len_sv
operator|)
operator|%
literal|128
operator|+
literal|128
expr_stmt|;
name|ct_str_sv
operator|=
name|NULL
expr_stmt|;
name|xlocale
operator|->
name|ct_state
operator|=
name|state_ext
expr_stmt|;
name|state_sv
operator|=
name|state_ext
expr_stmt|;
block|}
name|error
operator|+=
name|ret
expr_stmt|;
name|mb_str
operator|+=
name|crmbcnt
operator|,
name|mb_bytes
operator|-=
name|crmbcnt
operator|,
name|mbcnt
operator|+=
name|crmbcnt
expr_stmt|;
name|ct_str
operator|+=
name|crctcnt
operator|,
name|ctcnt
operator|+=
name|crctcnt
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|_XcwCheckDefaultState
argument_list|(
name|xlocale
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|_XcwGetDefaultEncoding
argument_list|(
name|xlocale
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|AppendDesignation
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
block|}
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|Return
end_undef

begin_undef
undef|#
directive|undef
name|SaveStore
end_undef

begin_define
define|#
directive|define
name|Return
parameter_list|(
name|result
parameter_list|)
value|{                                                \         *mb_bytes = mbcnt;                                              \         *scanned_bytes = ctcnt;                                         \ 	if (state) *state = xlocale->ct_state;				\ 	if (mbcnt< limit)						\ 	    *mb_str = 0;						\         if (error> 0) return (error);                                  \         return (result);                                                \     }
end_define

begin_define
define|#
directive|define
name|SaveStore
parameter_list|(
name|c
parameter_list|)
value|{                                                  \         if (mbcnt>= limit) Return(BadBuffer);                          \         *mb_str++ = c;                                                  \         mbcnt++;                                                        \     }
end_define

begin_comment
comment|/*  * CombineCode():  *   concatenate the byte with code if the byte is valid. */
end_comment

begin_define
define|#
directive|define
name|CombineCode
parameter_list|(
name|code
parameter_list|)
value|{                                             \ 	if (tmp == 1)       byte |= 0x80;				\ 	else if (tmp == 2)  byte&= 0x7f;				\         if (byte< stateinfo.code_min || byte> stateinfo.code_max) {   \             error++;                                                    \             byte = stateinfo.code_min;                                  \         }                                                               \         code = (code<< 8) | byte;                                      \         ct_str++, ct_bytes--;                                           \         if (ct_bytes< 1)                                               \             Return(BadTerminate);                                       \         byte = *ct_str;                                                 \     }
end_define

begin_function
name|int
name|_XConvertCTToMB
parameter_list|(
name|xlocale
parameter_list|,
name|ct_str
parameter_list|,
name|ct_bytes
parameter_list|,
name|mb_str
parameter_list|,
name|mb_bytes
parameter_list|,
name|scanned_bytes
parameter_list|,
name|state
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str
decl_stmt|;
name|int
name|ct_bytes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mb_str
decl_stmt|;
name|int
modifier|*
name|mb_bytes
decl_stmt|;
name|int
modifier|*
name|scanned_bytes
decl_stmt|;
name|_State
modifier|*
name|state
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|byte
decl_stmt|;
name|int
name|mbcnt
decl_stmt|,
name|ctcnt
decl_stmt|,
name|codelen
decl_stmt|;
name|_CSID
name|csid_sv
decl_stmt|,
name|newcsid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|code
decl_stmt|,
name|mbcode
decl_stmt|,
name|len
decl_stmt|,
name|limit
decl_stmt|,
name|error
decl_stmt|;
name|_State
name|state_sv
decl_stmt|;
name|char
name|seq
index|[
literal|255
index|]
decl_stmt|;
name|ISOStateInfo
name|stateinfo
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|char
modifier|*
name|defstr
init|=
name|XDefaultString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xlocale
condition|)
name|xlocale
operator|=
name|_XFallBackConvert
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|&&
operator|*
name|state
operator|!=
name|XDEFAULT_STATE
condition|)
block|{
name|xlocale
operator|->
name|ct_state
operator|=
operator|*
name|state
expr_stmt|;
if|if
condition|(
name|_XcwIdCheck
argument_list|(
name|xlocale
argument_list|)
operator|==
name|False
condition|)
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
block|}
else|else
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|_Xmbinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|*
name|mb_bytes
expr_stmt|;
name|mbcnt
operator|=
name|ctcnt
operator|=
name|error
operator|=
literal|0
expr_stmt|;
name|csid_sv
operator|=
name|mbGetid
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|codelen
operator|=
name|_Xmblen
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|_XcwIdGetISOState
argument_list|(
name|xlocale
argument_list|,
operator|&
name|stateinfo
argument_list|)
expr_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|mb_state
expr_stmt|;
while|while
condition|(
name|ct_bytes
operator|>
literal|0
operator|&&
operator|(
name|byte
operator|=
operator|*
name|ct_str
operator|)
operator|!=
literal|0
condition|)
block|{
name|_CSID
name|ctid
decl_stmt|;
switch|switch
condition|(
name|byte
condition|)
block|{
case|case
name|HT
case|:
case|case
name|NL
case|:
name|SaveStore
argument_list|(
name|byte
argument_list|)
expr_stmt|;
name|ct_str
operator|++
operator|,
name|ct_bytes
operator|--
operator|,
name|ctcnt
operator|++
expr_stmt|;
continue|continue;
case|case
name|SPACE
case|:
comment|/* force designate ISO8859.1 to GL (Codeset 0) */
name|ctSetGLid
argument_list|(
name|xlocale
argument_list|,
name|CODESET0
argument_list|)
expr_stmt|;
goto|goto
name|_Normal_char
goto|;
case|case
name|CSI
case|:
comment|/* not supported yet */
case|case
name|ESC
case|:
comment|/* parse the control escape sequence of CT encoding. */
switch|switch
condition|(
name|_XParseISOEncoding
argument_list|(
name|ct_str
argument_list|,
name|ct_bytes
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|stateinfo
argument_list|)
condition|)
block|{
case|case
name|Success
case|:
if|if
condition|(
operator|*
operator|(
name|ct_str
operator|+
literal|1
operator|)
operator|==
literal|0x25
condition|)
block|{
comment|/* Extend segmant */
name|int
name|tmplen
init|=
name|limit
operator|-
name|mbcnt
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|_XConvertCTextToMB
argument_list|(
name|xlocale
argument_list|,
name|ct_str
argument_list|,
name|ct_bytes
argument_list|,
name|mb_str
argument_list|,
operator|&
name|tmplen
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Return
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|error
operator|+=
name|ret
expr_stmt|;
name|mb_str
operator|+=
name|tmplen
expr_stmt|;
name|mbcnt
operator|+=
name|tmplen
expr_stmt|;
name|ct_str
operator|+=
name|len
operator|,
name|ct_bytes
operator|-=
name|len
operator|,
name|ctcnt
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
comment|/*                  * In mose case the control sequence is new one, so we                  * set it to current state directly, enhance little speed                  * without no comparision.                  *                 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|seq
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ct_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|seq
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|_XcwEscSetStatus
argument_list|(
name|xlocale
argument_list|,
name|seq
argument_list|)
operator|==
name|False
condition|)
comment|/* not register encoding by X. */
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
name|ct_str
operator|+=
name|len
operator|,
name|ct_bytes
operator|-=
name|len
operator|,
name|ctcnt
operator|+=
name|len
expr_stmt|;
continue|continue;
case|case
name|BadEncoding
case|:
comment|/*                  * wrong escape sequence, the function can not recover                  * this error, return it.                 */
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
case|case
name|BadTerminate
case|:
name|Return
argument_list|(
name|BadTerminate
argument_list|)
expr_stmt|;
default|default:
comment|/* never go to here */
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
default|default:
name|_Normal_char
label|:
name|ctSetGLorGR
argument_list|(
name|xlocale
argument_list|,
name|byte
operator|&
literal|0x80
argument_list|)
expr_stmt|;
name|ctid
operator|=
name|ctGetid
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|newcsid
operator|=
name|_Xmbctidtocsid
argument_list|(
name|xlocale
argument_list|,
name|ctid
argument_list|)
operator|)
operator|==
name|ND
condition|)
block|{
comment|/* Retry one more: There are some charset which 		   can be designated GL or GR. */
name|char
modifier|*
name|esc
decl_stmt|;
name|_XcwIdGetEncoding
argument_list|(
name|xlocale
argument_list|,
operator|&
name|esc
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|seq
argument_list|,
name|esc
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
index|[
literal|1
index|]
operator|==
literal|'$'
operator|&&
name|seq
index|[
literal|3
index|]
operator|>=
literal|'A'
operator|&&
name|seq
index|[
literal|3
index|]
operator|<=
literal|'D'
condition|)
block|{
if|if
condition|(
name|seq
index|[
literal|2
index|]
operator|==
literal|'('
condition|)
block|{
name|tmp
operator|=
literal|1
expr_stmt|;
name|seq
index|[
literal|2
index|]
operator|=
literal|')'
expr_stmt|;
name|byte
operator||=
literal|0x80
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seq
index|[
literal|2
index|]
operator|==
literal|')'
condition|)
block|{
name|tmp
operator|=
literal|2
expr_stmt|;
name|seq
index|[
literal|2
index|]
operator|=
literal|'('
expr_stmt|;
name|byte
operator|&=
literal|0x7f
expr_stmt|;
block|}
else|else
block|{
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
block|}
name|_XcwEscSetStatus
argument_list|(
name|xlocale
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|ctSetGLorGR
argument_list|(
name|xlocale
argument_list|,
name|byte
operator|&
literal|0x80
argument_list|)
expr_stmt|;
name|ctid
operator|=
name|ctGetid
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|newcsid
operator|=
name|_Xmbctidtocsid
argument_list|(
name|xlocale
argument_list|,
name|ctid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newcsid
operator|==
name|ND
condition|)
block|{
comment|/* XXX BUG: if stateful encoding, need to check/add 				designate sequence of default string. 		       But current default string is NULL, so OK. :-) */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|defstr
operator|+
name|i
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|SaveStore
argument_list|(
argument|*(defstr + i)
argument_list|)
block|}
name|ct_str
operator|+=
name|stateinfo
operator|.
name|code_bytes
expr_stmt|;
name|ct_bytes
operator|-=
name|stateinfo
operator|.
name|code_bytes
expr_stmt|;
name|ctcnt
operator|+=
name|stateinfo
operator|.
name|code_bytes
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|_XmbSetCsid
argument_list|(
name|xlocale
argument_list|,
name|newcsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcsid
operator|!=
name|csid_sv
condition|)
block|{
name|int
name|mbGLorGR
decl_stmt|;
if|if
condition|(
name|_Xmbtype
argument_list|(
name|xlocale
argument_list|)
operator|==
name|CDS_STATEFUL
operator|&&
operator|(
operator|(
name|mbGLorGR
operator|=
name|mbGetGLorGR
argument_list|(
name|xlocale
argument_list|)
operator|)
operator|==
name|GL
operator|&&
name|mbGetGLid
argument_list|(
name|xlocale
argument_list|)
operator|!=
operator|(
name|state_sv
operator|&
literal|0xff
operator|)
operator|||
name|mbGLorGR
operator|==
name|GR
operator|&&
name|mbGetGRid
argument_list|(
name|xlocale
argument_list|)
operator|!=
operator|(
name|state_sv
operator|>>
literal|8
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
comment|/*                      * append designation of state-dependent codeset.                      */
name|char
modifier|*
name|dsg
decl_stmt|;
name|int
name|dslen
decl_stmt|;
name|dsg
operator|=
name|_Xmbdsg
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|dslen
operator|=
name|strlen
argument_list|(
name|dsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbcnt
operator|+
name|dslen
operator|>
name|limit
condition|)
name|Return
argument_list|(
name|BadBuffer
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mb_str
argument_list|,
name|dsg
argument_list|,
name|dslen
argument_list|)
expr_stmt|;
name|mb_str
operator|+=
name|dslen
operator|,
name|mbcnt
operator|+=
name|dslen
expr_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|mb_state
expr_stmt|;
block|}
name|csid_sv
operator|=
name|newcsid
expr_stmt|;
name|codelen
operator|=
name|_Xmblen
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|_XcwIdGetISOState
argument_list|(
name|xlocale
argument_list|,
operator|&
name|stateinfo
argument_list|)
expr_stmt|;
block|}
comment|/* get codepoint of character. */
name|code
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|stateinfo
operator|.
name|code_bytes
condition|)
block|{
case|case
literal|4
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
name|tmp
operator|==
literal|1
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|2
condition|)
name|byte
operator|&=
literal|0x7f
expr_stmt|;
if|if
condition|(
name|byte
operator|<
name|stateinfo
operator|.
name|code_min
operator|||
name|byte
operator|>
name|stateinfo
operator|.
name|code_max
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|byte
operator|=
name|stateinfo
operator|.
name|code_min
expr_stmt|;
block|}
name|code
operator|=
operator|(
name|code
operator|<<
literal|8
operator|)
operator||
name|byte
expr_stmt|;
name|ct_str
operator|++
operator|,
name|ct_bytes
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|_Xcsctombc
argument_list|(
name|xlocale
argument_list|,
name|code
argument_list|,
operator|&
name|mbcode
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|codelen
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|SaveStore
argument_list|(
operator|(
name|mbcode
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0x00FF
argument_list|)
expr_stmt|;
comment|/*              * advance the ctcnt without any error.              */
name|ctcnt
operator|+=
name|stateinfo
operator|.
name|code_bytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_Xmbtype
argument_list|(
name|xlocale
argument_list|)
operator|==
name|CDS_STATEFUL
condition|)
block|{
comment|/* 	 * add designation sequence. 	 */
name|int
name|dsglen
decl_stmt|;
name|_XmbGetDefaultEncoding
argument_list|(
name|xlocale
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|dsglen
operator|=
name|strlen
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbcnt
operator|+
name|dsglen
operator|>
name|limit
condition|)
name|Return
argument_list|(
name|BadBuffer
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mb_str
argument_list|,
name|seq
argument_list|,
name|dsglen
argument_list|)
expr_stmt|;
name|mb_str
operator|+=
name|dsglen
operator|,
name|mbcnt
operator|+=
name|dsglen
expr_stmt|;
block|}
name|_Xmbinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|Return
end_undef

begin_undef
undef|#
directive|undef
name|CombineCode
end_undef

begin_define
define|#
directive|define
name|Return
parameter_list|(
name|result
parameter_list|)
value|{                                                \         *mb_bytes = mbcnt;                                              \         *scanned_bytes = ctcnt;                                         \ 	if (mbcnt< limit)						\ 	    *mb_str = 0;						\         if (error> 0) return (error);                                  \         return (result);                                                \     }
end_define

begin_comment
comment|/*  * CombineCode():  *   concatenate the byte with code if the byte is valid. */
end_comment

begin_define
define|#
directive|define
name|CombineCode
parameter_list|(
name|code
parameter_list|)
value|{                                             \         code = (code<< 8) | byte;                                      \         ct_str++; ct_bytes--;						\         if (ct_bytes< 1)                                               \             Return(BadTerminate);                                       \         byte = *ct_str;                                                 \     }
end_define

begin_function
specifier|static
name|int
name|_XConvertCTextToMB
parameter_list|(
name|xlocale
parameter_list|,
name|ct_str
parameter_list|,
name|ct_bytes
parameter_list|,
name|mb_str
parameter_list|,
name|mb_bytes
parameter_list|,
name|scanned_bytes
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str
decl_stmt|;
name|int
name|ct_bytes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mb_str
decl_stmt|;
name|int
modifier|*
name|mb_bytes
decl_stmt|;
name|int
modifier|*
name|scanned_bytes
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|byte
decl_stmt|;
name|int
name|mbcnt
decl_stmt|,
name|ctcnt
decl_stmt|,
name|codelen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|code
decl_stmt|,
name|mbcode
decl_stmt|,
name|len
decl_stmt|,
name|limit
decl_stmt|,
name|error
decl_stmt|;
name|char
name|seq
index|[
literal|128
index|]
decl_stmt|;
name|int
name|textlen
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|_CSID
name|csid
decl_stmt|,
name|ctid
decl_stmt|;
name|_State
name|state_sv
decl_stmt|;
name|char
modifier|*
name|defstr
init|=
name|XDefaultString
argument_list|()
decl_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|ct_state
expr_stmt|;
name|limit
operator|=
operator|*
name|mb_bytes
expr_stmt|;
name|mbcnt
operator|=
name|ctcnt
operator|=
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|_XctIsExtendSegment
argument_list|(
name|xlocale
argument_list|,
name|ct_str
argument_list|,
operator|&
name|textlen
argument_list|,
operator|&
name|bytes
argument_list|)
operator|)
operator|<=
literal|0
condition|)
comment|/* not register encoding by X. */
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
name|ct_str
operator|+=
name|len
expr_stmt|;
name|ctcnt
operator|+=
name|len
expr_stmt|;
name|ct_bytes
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|ct_bytes
operator|<
name|textlen
condition|)
name|Return
argument_list|(
argument|BadTerminate
argument_list|)
comment|/* Nor enough data. What should do? */
if|if
condition|(
name|_Xmbtype
argument_list|(
name|xlocale
argument_list|)
operator|==
name|CDS_STATEFUL
condition|)
block|{
comment|/* append designation of state-dependent codeset. */
name|char
modifier|*
name|dsg
decl_stmt|;
name|int
name|dslen
decl_stmt|;
name|dsg
operator|=
name|_Xmbdsg
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|dslen
operator|=
name|strlen
argument_list|(
name|dsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbcnt
operator|+
name|dslen
operator|>
name|limit
condition|)
name|Return
argument_list|(
name|BadBuffer
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mb_str
argument_list|,
name|dsg
argument_list|,
name|dslen
argument_list|)
expr_stmt|;
name|mb_str
operator|+=
name|dslen
operator|,
name|mbcnt
operator|+=
name|dslen
expr_stmt|;
block|}
name|ctid
operator|=
name|ctGetid
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|csid
operator|=
name|_Xmbctidtocsid
argument_list|(
name|xlocale
argument_list|,
name|ctid
argument_list|)
expr_stmt|;
if|if
condition|(
name|csid
operator|==
name|ND
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|textlen
operator|/
name|bytes
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|defstr
operator|+
name|i
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|SaveStore
argument_list|(
operator|*
operator|(
name|defstr
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|++
expr_stmt|;
block|}
name|ctcnt
operator|+=
name|textlen
expr_stmt|;
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
name|_XmbSetCsid
argument_list|(
name|xlocale
argument_list|,
name|csid
argument_list|)
expr_stmt|;
name|codelen
operator|=
name|_Xmblen
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
while|while
condition|(
name|textlen
operator|>
literal|0
condition|)
block|{
comment|/* get codepoint of character. */
name|code
operator|=
literal|0
expr_stmt|;
name|byte
operator|=
operator|*
name|ct_str
expr_stmt|;
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|4
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|code
operator|=
operator|(
name|code
operator|<<
literal|8
operator|)
operator||
name|byte
expr_stmt|;
name|ct_str
operator|++
expr_stmt|;
name|ct_bytes
operator|--
expr_stmt|;
break|break;
block|}
name|textlen
operator|-=
name|bytes
expr_stmt|;
if|if
condition|(
name|_Xcsctombc
argument_list|(
name|xlocale
argument_list|,
name|code
argument_list|,
operator|&
name|mbcode
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|codelen
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|SaveStore
argument_list|(
operator|(
name|mbcode
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0x00FF
argument_list|)
expr_stmt|;
name|ctcnt
operator|+=
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|_Xmbtype
argument_list|(
name|xlocale
argument_list|)
operator|==
name|CDS_STATEFUL
condition|)
block|{
comment|/* add designation sequence. */
name|int
name|dsglen
decl_stmt|;
name|_XmbGetDefaultEncoding
argument_list|(
name|xlocale
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|dsglen
operator|=
name|strlen
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbcnt
operator|+
name|dsglen
operator|>
name|limit
condition|)
name|Return
argument_list|(
name|BadBuffer
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mb_str
argument_list|,
name|seq
argument_list|,
name|dsglen
argument_list|)
expr_stmt|;
name|mb_str
operator|+=
name|dsglen
operator|,
name|mbcnt
operator|+=
name|dsglen
expr_stmt|;
block|}
name|xlocale
operator|->
name|ct_state
operator|=
name|state_sv
expr_stmt|;
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

