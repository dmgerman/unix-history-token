begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: XCnvCTToWC.c,v 1.22 91/11/17 16:15:29 rws Exp $  */
end_comment

begin_comment
comment|/*  * Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,  *                      and Nippon Telegraph and Telephone Corporation  * Copyright 1991 by the Massachusetts Institute of Technology  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of OMRON, NTT Software, NTT, and M.I.T.  * not be used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission. OMRON, NTT Software,  * NTT, and M.I.T. make no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * OMRON, NTT SOFTWARE, NTT, AND M.I.T. DISCLAIM ALL WARRANTIES WITH REGARD  * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS, IN NO EVENT SHALL OMRON, NTT SOFTWARE, NTT, OR M.I.T. BE  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *	Authors: Li Yuhong		OMRON Corporation  *		 Hiroshi Kuribayashi	OMRON Corporation  *     */
end_comment

begin_comment
comment|/*  * This files includes 2 functions:  *   *      _XConvertCTToWC()  *      _XConvertWCToCT()  *  */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xlocaleint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include

begin_function_decl
specifier|static
name|int
name|_XConvertCTextToWC
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_XParseISOEncoding
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Bool
name|_XcwEscSetStatus
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_XwcSetCsid
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *          Function Name: _XConvertCTToWC  * */
end_comment

begin_comment
comment|/*  * Constant Definitions */
end_comment

begin_define
define|#
directive|define
name|HT
value|0x09
end_define

begin_comment
comment|/* horizontal tab */
end_comment

begin_define
define|#
directive|define
name|NL
value|0x0A
end_define

begin_comment
comment|/* new line */
end_comment

begin_define
define|#
directive|define
name|ESC
value|0x1B
end_define

begin_comment
comment|/* escape */
end_comment

begin_define
define|#
directive|define
name|CSI
value|0x9B
end_define

begin_comment
comment|/* control sequence introducer. */
end_comment

begin_define
define|#
directive|define
name|SPACE
value|0x20
end_define

begin_comment
comment|/* space */
end_comment

begin_define
define|#
directive|define
name|GL94MIN
value|0x21
end_define

begin_comment
comment|/* manimun of code of GL 94 charset */
end_comment

begin_define
define|#
directive|define
name|GL94MAX
value|0x7E
end_define

begin_comment
comment|/* maximun of code of GL 94 charset */
end_comment

begin_comment
comment|/*   * Macro Procedure Definitions */
end_comment

begin_comment
comment|/*   * Return():  *   set result values before funciton returns.  *   If there is more room for output buffer wc_str, provide additional  *    service, i.e., append WNULL at tail. */
end_comment

begin_define
define|#
directive|define
name|Return
parameter_list|(
name|result
parameter_list|)
value|{                                                \         *wc_len = wcnt;                                                 \         *scanned_bytes = ctcnt;                                         \         if (wcnt< limit) *wc_str = WNULL;                              \ 	if (state) *state = xlocale->ct_state;				\         if (error> 0) return(error);                                   \         return(result);                                                 \     }
end_define

begin_comment
comment|/*  * SaveStore():  *   store converted wchar code to buffer, and make sure no overflow. */
end_comment

begin_define
define|#
directive|define
name|SaveStore
parameter_list|(
name|wc
parameter_list|)
value|{                                                 \         if (wcnt>= limit)                                              \             Return(BadBuffer);						\         *wc_str++ = wc;                                                 \         wcnt++;                                                         \     }
end_define

begin_comment
comment|/*  * CombineCode():  *   concatenate the byte with code if the byte is valid. */
end_comment

begin_define
define|#
directive|define
name|CombineCode
parameter_list|(
name|code
parameter_list|)
value|{                                             \         if (byte< stateinfo.code_min || byte> stateinfo.code_max) {   \             error++;                                                    \             byte = stateinfo.code_min;                                  \         }                                                               \         code = (code<< 8) | byte;                                      \         ct_str++, ct_bytes--;                                           \         if (ct_bytes< 1)                                               \             Return(BadTerminate);                                       \         byte = *ct_str;                                                 \     }
end_define

begin_function
name|int
name|_XConvertCTToWC
parameter_list|(
name|xlocale
parameter_list|,
name|ct_str
parameter_list|,
name|ct_bytes
parameter_list|,
name|wc_str
parameter_list|,
name|wc_len
parameter_list|,
name|scanned_bytes
parameter_list|,
name|state
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str
decl_stmt|;
name|int
name|ct_bytes
decl_stmt|;
name|wchar
modifier|*
name|wc_str
decl_stmt|;
name|int
modifier|*
name|wc_len
decl_stmt|;
name|int
modifier|*
name|scanned_bytes
decl_stmt|;
name|_State
modifier|*
name|state
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|byte
decl_stmt|;
specifier|register
name|unsigned
name|int
name|code
decl_stmt|;
name|wchar
name|woffset
decl_stmt|;
name|int
name|wcnt
decl_stmt|,
name|ctcnt
decl_stmt|,
name|limit
decl_stmt|,
name|len
decl_stmt|;
name|ISOStateInfo
name|stateinfo
decl_stmt|;
name|char
name|seq
index|[
name|MAXSEQUENCELENGTH
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|xlocale
condition|)
name|xlocale
operator|=
name|_XFallBackConvert
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|&&
operator|*
name|state
operator|!=
name|XDEFAULT_STATE
condition|)
block|{
name|xlocale
operator|->
name|ct_state
operator|=
operator|*
name|state
expr_stmt|;
if|if
condition|(
name|_XcwIdCheck
argument_list|(
name|xlocale
argument_list|)
operator|==
name|False
condition|)
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
block|}
else|else
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|*
name|wc_len
expr_stmt|;
name|wcnt
operator|=
name|ctcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ct_bytes
operator|>
literal|0
operator|&&
operator|(
name|byte
operator|=
operator|*
name|ct_str
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|byte
condition|)
block|{
case|case
name|HT
case|:
case|case
name|NL
case|:
case|case
name|SPACE
case|:
name|SaveStore
argument_list|(
name|_Xatowc
argument_list|(
name|byte
argument_list|)
argument_list|)
expr_stmt|;
name|ct_str
operator|++
operator|,
name|ct_bytes
operator|--
operator|,
name|ctcnt
operator|++
expr_stmt|;
continue|continue;
case|case
name|CSI
case|:
comment|/* not supported yet */
case|case
name|ESC
case|:
comment|/* parse the control escape sequence of CT encoding. */
switch|switch
condition|(
name|_XParseISOEncoding
argument_list|(
name|ct_str
argument_list|,
name|ct_bytes
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|stateinfo
argument_list|)
condition|)
block|{
case|case
name|Success
case|:
if|if
condition|(
operator|*
operator|(
name|ct_str
operator|+
literal|1
operator|)
operator|==
literal|0x25
condition|)
block|{
comment|/* Extend segmant */
name|int
name|tmplen
init|=
name|limit
operator|-
name|wcnt
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|_XConvertCTextToWC
argument_list|(
name|xlocale
argument_list|,
name|ct_str
argument_list|,
name|ct_bytes
argument_list|,
name|wc_str
argument_list|,
operator|&
name|tmplen
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Return
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|wc_str
operator|+=
name|tmplen
expr_stmt|;
name|wcnt
operator|+=
name|tmplen
expr_stmt|;
name|ct_str
operator|+=
name|len
operator|,
name|ct_bytes
operator|-=
name|len
operator|,
name|ctcnt
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
comment|/*                  * In mose case the control sequence is new one, so we                   * set it to current state directly, enhance little speed                  * without no comparision.                   *                  */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|seq
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ct_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|seq
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|_XcwEscSetStatus
argument_list|(
name|xlocale
argument_list|,
name|seq
argument_list|)
operator|==
name|True
condition|)
block|{
name|ct_str
operator|+=
name|len
operator|,
name|ct_bytes
operator|-=
name|len
expr_stmt|;
name|ctcnt
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
comment|/*                  * Actually, it is not registered encoding, can not be                  * recognized by this convertor. go to next step.                 */
case|case
name|BadEncoding
case|:
comment|/*                  * wrong escape sequence, the function can not recover                  * this error, return it.                    */
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
case|case
name|BadTerminate
case|:
name|Return
argument_list|(
name|BadTerminate
argument_list|)
expr_stmt|;
default|default:
comment|/* never go to here */
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
default|default:
comment|/* get codepoint of character. */
name|ctSetGLorGR
argument_list|(
name|xlocale
argument_list|,
name|byte
operator|&
literal|0x80
argument_list|)
expr_stmt|;
name|_XcwIdGetAll
argument_list|(
name|xlocale
argument_list|,
operator|&
name|woffset
argument_list|,
operator|&
name|stateinfo
argument_list|)
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|stateinfo
operator|.
name|code_bytes
condition|)
block|{
case|case
literal|4
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
name|byte
operator|<
name|stateinfo
operator|.
name|code_min
operator|||
name|byte
operator|>
name|stateinfo
operator|.
name|code_max
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|byte
operator|=
name|stateinfo
operator|.
name|code_min
expr_stmt|;
block|}
name|code
operator|=
operator|(
name|code
operator|<<
literal|8
operator|)
operator||
name|byte
expr_stmt|;
name|ct_str
operator|++
operator|,
name|ct_bytes
operator|--
expr_stmt|;
name|code
operator|&=
literal|0x7f7f7f7f
expr_stmt|;
comment|/* MSB off */
break|break;
block|}
name|SaveStore
argument_list|(
name|woffset
operator||
name|code
argument_list|)
expr_stmt|;
comment|/*              * after no any error, then advance scanned_bytes               * "ctcnt".             */
name|ctcnt
operator|+=
name|stateinfo
operator|.
name|code_bytes
expr_stmt|;
continue|continue;
block|}
block|}
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *          Function Name: _XConvertWCToCT  * */
end_comment

begin_undef
undef|#
directive|undef
name|Return
end_undef

begin_undef
undef|#
directive|undef
name|SaveStore
end_undef

begin_define
define|#
directive|define
name|Return
parameter_list|(
name|result
parameter_list|)
value|{                                                \         *ct_bytes = ctcnt;                                              \         *scanned_len = wcnt;                                            \ 	if (ctcnt< limit)						\ 	    *ct_str = 0;						\         if (error> 0) return(error);                                   \         return(result);                                                 \     }
end_define

begin_define
define|#
directive|define
name|SaveStore
parameter_list|(
name|c
parameter_list|)
value|{                                                \        if (ctcnt>= limit) Return(BadBuffer);                           \        *ct_str++ = c;                                                   \        ctcnt++;                                                         \     }
end_define

begin_define
define|#
directive|define
name|AppendDesignation
parameter_list|(
name|state
parameter_list|)
value|{                                      \         int len = strlen(state);                                        \         if ((ctcnt + len)> limit)                                      \            Return(BadBuffer);                                           \         (void) strcpy((char *)ct_str, state);                           \         ct_str += len;                                                  \         ctcnt += len;                                                   \     }
end_define

begin_function
name|int
name|_XConvertWCToCT
parameter_list|(
name|xlocale
parameter_list|,
name|wc_str
parameter_list|,
name|wc_len
parameter_list|,
name|ct_str
parameter_list|,
name|ct_bytes
parameter_list|,
name|scanned_len
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|wchar
modifier|*
name|wc_str
decl_stmt|;
name|int
name|wc_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str
decl_stmt|;
name|int
modifier|*
name|ct_bytes
decl_stmt|;
name|int
modifier|*
name|scanned_len
decl_stmt|;
block|{
name|char
modifier|*
name|esc
decl_stmt|,
name|seq
index|[
name|MAXSEQUENCELENGTH
index|]
decl_stmt|;
name|wchar
name|woffset
decl_stmt|,
name|wc
decl_stmt|;
name|int
name|wcnt
decl_stmt|,
name|ctcnt
decl_stmt|,
name|crwcnt
decl_stmt|,
name|crctcnt
decl_stmt|,
name|limit
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|ISOStateInfo
name|stateinfo
decl_stmt|;
name|_State
name|state_sv
decl_stmt|,
name|state_ext
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str_sv
init|=
name|NULL
decl_stmt|;
name|int
name|len_sv
decl_stmt|;
name|char
modifier|*
name|defstr
init|=
name|XDefaultString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xlocale
condition|)
name|xlocale
operator|=
name|_XFallBackConvert
argument_list|()
expr_stmt|;
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|ct_state
expr_stmt|;
name|limit
operator|=
operator|*
name|ct_bytes
expr_stmt|;
name|wcnt
operator|=
name|ctcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|wc_len
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|wc
operator|=
operator|*
name|wc_str
operator|)
operator|!=
name|WNULL
operator|)
condition|)
block|{
name|_CSID
name|ctGLorGR
decl_stmt|;
comment|/*          * filter control characters.          */
if|if
condition|(
name|_Xiswcntrl
argument_list|(
name|wc
argument_list|)
condition|)
block|{
name|SaveStore
argument_list|(
name|_Xwctoa
argument_list|(
name|wc
argument_list|)
argument_list|)
expr_stmt|;
name|wc_str
operator|++
operator|,
name|wc_len
operator|--
operator|,
name|wcnt
operator|++
expr_stmt|;
continue|continue;
block|}
name|_XcwGetAll
argument_list|(
name|xlocale
argument_list|,
name|wc
argument_list|,
operator|&
name|esc
argument_list|,
operator|&
name|woffset
argument_list|,
operator|&
name|stateinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|woffset
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* XXX BUG: need to check/add designate sequence of default string. 	       But current default string is NULL, so OK. :-) */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|defstr
operator|+
name|i
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|SaveStore
argument_list|(
argument|*(defstr + i)
argument_list|)
block|}
name|error
operator|++
expr_stmt|;
name|wc_str
operator|++
operator|,
name|wc_len
operator|--
operator|,
name|wcnt
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ctGLorGR
operator|=
name|ctGetGLorGR
argument_list|(
name|xlocale
argument_list|)
operator|)
operator|==
name|GL
operator|&&
name|ctGetGLid
argument_list|(
name|xlocale
argument_list|)
operator|!=
operator|(
name|state_sv
operator|&
literal|0xff
operator|)
operator|||
name|ctGLorGR
operator|==
name|GR
operator|&&
name|ctGetGRid
argument_list|(
name|xlocale
argument_list|)
operator|!=
operator|(
operator|(
name|state_sv
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
condition|)
block|{
name|state_ext
operator|=
name|state_sv
expr_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|ct_state
expr_stmt|;
comment|/*              * append designation of control sequence.             */
if|if
condition|(
operator|*
operator|(
name|esc
operator|+
literal|1
operator|)
operator|==
literal|0x25
condition|)
block|{
name|ct_str_sv
operator|=
name|ct_str
operator|+
literal|4
expr_stmt|;
name|len_sv
operator|=
name|strlen
argument_list|(
name|esc
argument_list|)
operator|-
literal|6
expr_stmt|;
block|}
name|AppendDesignation
argument_list|(
name|esc
argument_list|)
expr_stmt|;
block|}
comment|/*           * remainning buffer length of ct_str.         */
name|crctcnt
operator|=
name|limit
operator|-
name|ctcnt
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|_XwcDecomposeGlyphCharset
argument_list|(
name|xlocale
argument_list|,
name|wc_str
argument_list|,
name|wc_len
argument_list|,
name|ct_str
argument_list|,
operator|&
name|crctcnt
argument_list|,
operator|&
name|crwcnt
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Return
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct_str_sv
condition|)
block|{
operator|*
name|ct_str_sv
operator|++
operator|=
operator|(
name|crctcnt
operator|+
name|len_sv
operator|)
operator|/
literal|128
operator|+
literal|128
expr_stmt|;
operator|*
name|ct_str_sv
operator|=
operator|(
name|crctcnt
operator|+
name|len_sv
operator|)
operator|%
literal|128
operator|+
literal|128
expr_stmt|;
name|ct_str_sv
operator|=
name|NULL
expr_stmt|;
name|xlocale
operator|->
name|ct_state
operator|=
name|state_ext
expr_stmt|;
name|state_sv
operator|=
name|state_ext
expr_stmt|;
block|}
name|error
operator|+=
name|ret
expr_stmt|;
name|wc_str
operator|+=
name|crwcnt
operator|,
name|wc_len
operator|-=
name|crwcnt
operator|,
name|wcnt
operator|+=
name|crwcnt
expr_stmt|;
name|ct_str
operator|+=
name|crctcnt
operator|,
name|ctcnt
operator|+=
name|crctcnt
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|_XcwCheckDefaultState
argument_list|(
name|xlocale
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|_XcwGetDefaultEncoding
argument_list|(
name|xlocale
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|AppendDesignation
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
block|}
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_XctIsExtendSegment
parameter_list|(
name|xlocale
parameter_list|,
name|ct_str
parameter_list|,
name|textlen
parameter_list|,
name|bytes
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str
decl_stmt|;
name|int
modifier|*
name|textlen
decl_stmt|;
name|int
modifier|*
name|bytes
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|seqlen
decl_stmt|;
name|unsigned
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|_CSID
name|csid
decl_stmt|;
name|int
name|m
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|ct_str
operator|+
literal|1
operator|)
operator|!=
literal|0x25
operator|||
operator|*
operator|(
name|ct_str
operator|+
literal|2
operator|)
operator|!=
literal|0x2f
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not CT Extend Segment */
operator|*
name|bytes
operator|=
operator|*
operator|(
name|ct_str
operator|+
literal|3
operator|)
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|bytes
operator|<
literal|0
operator|||
operator|*
name|bytes
operator|>
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not CT Extend Segment */
elseif|else
if|if
condition|(
operator|*
name|bytes
operator|==
literal|0
condition|)
comment|/* I'm not sure. Valiable octes pre char cannot convert */
operator|*
name|bytes
operator|=
literal|1
expr_stmt|;
name|text
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ct_str
operator|+
literal|6
argument_list|,
literal|0x02
argument_list|)
operator|+
literal|1
expr_stmt|;
name|m
operator|=
operator|*
operator|(
name|ct_str
operator|+
literal|4
operator|)
expr_stmt|;
name|l
operator|=
operator|*
operator|(
name|ct_str
operator|+
literal|5
operator|)
expr_stmt|;
name|seqlen
operator|=
name|text
operator|-
name|ct_str
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ct_str
operator|+
literal|6
argument_list|,
name|seqlen
operator|-
literal|6
argument_list|)
expr_stmt|;
name|name
index|[
name|seqlen
operator|-
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|csid
operator|=
name|_XcwNameGetGLorGRId
argument_list|(
name|name
argument_list|,
operator|*
operator|(
name|text
operator|+
literal|1
operator|)
operator|&
literal|0x80
argument_list|)
expr_stmt|;
name|ctSetGLorGR
argument_list|(
name|xlocale
argument_list|,
operator|*
operator|(
name|text
operator|+
literal|1
operator|)
operator|&
literal|0x80
argument_list|)
expr_stmt|;
name|ctSetid
argument_list|(
name|xlocale
argument_list|,
name|csid
argument_list|)
expr_stmt|;
operator|*
name|textlen
operator|=
operator|(
name|m
operator|-
literal|128
operator|)
operator|*
literal|128
operator|+
operator|(
name|l
operator|-
literal|128
operator|)
operator|+
literal|5
operator|-
name|seqlen
operator|+
literal|1
expr_stmt|;
comment|/* !!!!! */
return|return
operator|(
name|seqlen
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|Return
end_undef

begin_undef
undef|#
directive|undef
name|SaveStore
end_undef

begin_undef
undef|#
directive|undef
name|CombineCode
end_undef

begin_define
define|#
directive|define
name|Return
parameter_list|(
name|result
parameter_list|)
value|{                                                \         *wc_bytes = wccnt;                                              \         *scanned_bytes = ctcnt;                                         \ 	if (wccnt< limit)						\ 	    *wc_str = 0;						\         if (error> 0) return (error);                                  \         return (result);                                                \     }
end_define

begin_define
define|#
directive|define
name|SaveStore
parameter_list|(
name|wc
parameter_list|)
value|{                                                 \         if (wccnt>= limit) Return(BadBuffer);                          \         *wc_str++ = wc;                                                 \         wccnt++;                                                        \     }
end_define

begin_comment
comment|/*  * CombineCode():  *   concatenate the byte with code if the byte is valid. */
end_comment

begin_define
define|#
directive|define
name|CombineCode
parameter_list|(
name|code
parameter_list|)
value|{                                             \         code = (code<< 8) | byte;                                      \         ct_str++; ct_bytes--;						\         if (ct_bytes< 1)                                               \             Return(BadTerminate);                                       \         byte = *ct_str;                                                 \     }
end_define

begin_function
specifier|static
name|int
name|_XConvertCTextToWC
parameter_list|(
name|xlocale
parameter_list|,
name|ct_str
parameter_list|,
name|ct_bytes
parameter_list|,
name|wc_str
parameter_list|,
name|wc_bytes
parameter_list|,
name|scanned_bytes
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ct_str
decl_stmt|;
name|int
name|ct_bytes
decl_stmt|;
name|wchar
modifier|*
name|wc_str
decl_stmt|;
name|int
modifier|*
name|wc_bytes
decl_stmt|;
name|int
modifier|*
name|scanned_bytes
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|byte
decl_stmt|;
name|int
name|wccnt
decl_stmt|,
name|ctcnt
decl_stmt|;
name|int
name|code
decl_stmt|,
name|len
decl_stmt|,
name|limit
decl_stmt|,
name|error
decl_stmt|;
name|int
name|textlen
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|_State
name|state_sv
decl_stmt|;
name|wchar
name|woffset
decl_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|ct_state
expr_stmt|;
name|limit
operator|=
operator|*
name|wc_bytes
expr_stmt|;
name|wccnt
operator|=
name|ctcnt
operator|=
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|_XctIsExtendSegment
argument_list|(
name|xlocale
argument_list|,
name|ct_str
argument_list|,
operator|&
name|textlen
argument_list|,
operator|&
name|bytes
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* not register encoding by X. */
name|Return
argument_list|(
name|BadEncoding
argument_list|)
expr_stmt|;
name|ct_str
operator|+=
name|len
expr_stmt|;
name|ctcnt
operator|+=
name|len
expr_stmt|;
name|ct_bytes
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|ct_bytes
operator|<
name|textlen
condition|)
name|Return
argument_list|(
name|BadTerminate
argument_list|)
expr_stmt|;
comment|/* Nor enough data. What should do? */
name|_XcwIdGetWoffset
argument_list|(
name|xlocale
argument_list|,
operator|&
name|woffset
argument_list|)
expr_stmt|;
while|while
condition|(
name|textlen
operator|>
literal|0
condition|)
block|{
comment|/* get codepoint of character. */
name|code
operator|=
literal|0
expr_stmt|;
name|byte
operator|=
operator|*
name|ct_str
expr_stmt|;
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|4
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|CombineCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|code
operator|=
operator|(
name|code
operator|<<
literal|8
operator|)
operator||
name|byte
expr_stmt|;
name|ct_str
operator|++
operator|,
name|ct_bytes
operator|--
expr_stmt|;
name|code
operator|&=
literal|0x7f7f7f7f
expr_stmt|;
comment|/* MSB off */
break|break;
block|}
name|SaveStore
argument_list|(
name|woffset
operator||
name|code
argument_list|)
expr_stmt|;
name|textlen
operator|-=
name|bytes
expr_stmt|;
name|ctcnt
operator|+=
name|bytes
expr_stmt|;
block|}
name|xlocale
operator|->
name|ct_state
operator|=
name|state_sv
expr_stmt|;
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

