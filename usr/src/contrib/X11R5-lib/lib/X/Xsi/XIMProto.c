begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: XIMProto.c,v 1.9 91/05/07 19:27:52 rws Exp $  */
end_comment

begin_comment
comment|/*  * Copyright 1990, 1991 by OMRON Corporation  * Copyright 1991 by the Massachusetts Institute of Technology  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of OMRON and MIT not be used in  * advertising or publicity pertaining to distribution of the software without  * specific, written prior permission.  OMRON and MIT make no representations  * about the suitability of this software for any purpose.  It is provided  * "as is" without express or implied warranty.  *  * OMRON AND MIT DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO  * EVENT SHALL OMRON OR MIT BE LIABLE FOR ANY SPECIAL, INDIRECT OR  * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER  * TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.   *  *	Author:	Seiji Kuwari	OMRON Corporation  *				kuwa@omron.co.jp  *				kuwa%omron.co.jp@uunet.uu.net  */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xi18nint.h"
end_include

begin_include
include|#
directive|include
file|"XIMlibint.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
specifier|static
name|lock_err_fun
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|_XipIOErrorFunction
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|_XipDefaultIOError
parameter_list|(
name|im
parameter_list|)
name|XipIM
name|im
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XIM: fatal IO error on X Input Manager\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_XipIOError
parameter_list|(
name|im
parameter_list|)
name|XipIM
name|im
decl_stmt|;
block|{
name|LockMutex
argument_list|(
operator|&
name|lock_err_fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|_XipIOErrorFunction
condition|)
call|(
modifier|*
name|_XipIOErrorFunction
call|)
argument_list|(
name|im
argument_list|)
expr_stmt|;
else|else
name|_XipDefaultIOError
argument_list|(
name|im
argument_list|)
expr_stmt|;
name|UnlockMutex
argument_list|(
operator|&
name|lock_err_fun
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|void
argument_list|(
argument|*_XipSetIOErrorHandler(handler)
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
name|void
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|void
function_decl|(
modifier|*
name|oldhandler
function_decl|)
parameter_list|()
function_decl|;
name|LockMutex
argument_list|(
operator|&
name|lock_err_fun
argument_list|)
expr_stmt|;
name|oldhandler
operator|=
name|_XipIOErrorFunction
expr_stmt|;
if|if
condition|(
operator|!
name|oldhandler
condition|)
block|{
name|oldhandler
operator|=
name|_XipDefaultIOError
expr_stmt|;
block|}
if|if
condition|(
name|handler
operator|!=
name|NULL
condition|)
block|{
name|_XipIOErrorFunction
operator|=
name|handler
expr_stmt|;
block|}
else|else
block|{
name|_XipIOErrorFunction
operator|=
name|_XipDefaultIOError
expr_stmt|;
block|}
name|UnlockMutex
argument_list|(
operator|&
name|lock_err_fun
argument_list|)
expr_stmt|;
return|return
name|oldhandler
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|_Writen
parameter_list|(
name|im
parameter_list|,
name|num
parameter_list|)
specifier|register
name|XipIM
name|im
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
control|)
block|{
name|ret
operator|=
name|_Write
argument_list|(
name|im
operator|->
name|fd
argument_list|,
operator|&
name|im
operator|->
name|send_buf
index|[
name|i
index|]
argument_list|,
name|num
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
name|im
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|_XipIOError
argument_list|(
name|im
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|+=
name|ret
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_XipFlushToIM
parameter_list|(
name|im
parameter_list|)
specifier|register
name|XipIM
name|im
decl_stmt|;
block|{
if|if
condition|(
name|im
operator|->
name|sp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|_Writen
argument_list|(
name|im
argument_list|,
name|im
operator|->
name|sp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|im
operator|->
name|sp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_XipWriteToIM
parameter_list|(
name|im
parameter_list|,
name|p
parameter_list|,
name|num
parameter_list|)
specifier|register
name|XipIM
name|im
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|im
operator|->
name|sp
operator|+
name|num
operator|)
operator|>
name|SEND_BUF_SZ
condition|)
block|{
name|bcopy
argument_list|(
name|p
argument_list|,
operator|&
name|im
operator|->
name|send_buf
index|[
name|im
operator|->
name|sp
index|]
argument_list|,
name|SEND_BUF_SZ
operator|-
name|im
operator|->
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|_Writen
argument_list|(
name|im
argument_list|,
name|SEND_BUF_SZ
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|num
operator|-=
operator|(
name|SEND_BUF_SZ
operator|-
name|im
operator|->
name|sp
operator|)
expr_stmt|;
name|p
operator|+=
operator|(
name|SEND_BUF_SZ
operator|-
name|im
operator|->
name|sp
operator|)
expr_stmt|;
name|im
operator|->
name|sp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|p
argument_list|,
operator|&
name|im
operator|->
name|send_buf
index|[
name|im
operator|->
name|sp
index|]
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|im
operator|->
name|sp
operator|+=
name|num
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|_XipReadFromIM
parameter_list|(
name|im
parameter_list|,
name|p
parameter_list|,
name|num
parameter_list|)
specifier|register
name|XipIM
name|im
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|x
init|=
name|p
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|num
operator|>
name|im
operator|->
name|rc
condition|)
block|{
if|if
condition|(
name|im
operator|->
name|rc
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|im
operator|->
name|recv_buf
index|[
name|im
operator|->
name|rp
index|]
argument_list|,
name|x
argument_list|,
name|im
operator|->
name|rc
argument_list|)
expr_stmt|;
name|x
operator|+=
name|im
operator|->
name|rc
expr_stmt|;
name|num
operator|-=
name|im
operator|->
name|rc
expr_stmt|;
name|im
operator|->
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|im
operator|->
name|rc
operator|=
name|_Read
argument_list|(
name|im
operator|->
name|fd
argument_list|,
name|im
operator|->
name|recv_buf
argument_list|,
name|RECV_BUF_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
operator|->
name|rc
operator|<=
literal|0
condition|)
block|{
name|im
operator|->
name|rc
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|rp
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|_XipIOError
argument_list|(
name|im
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|im
operator|->
name|rp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
name|im
operator|->
name|recv_buf
index|[
name|im
operator|->
name|rp
index|]
argument_list|,
name|x
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|im
operator|->
name|rc
operator|-=
name|num
expr_stmt|;
name|im
operator|->
name|rp
operator|+=
name|num
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

end_unit

