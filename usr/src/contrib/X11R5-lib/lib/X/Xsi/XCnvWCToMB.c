begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $XConsortium: XCnvWCToMB.c,v 1.24 92/07/29 11:44:21 rws Exp $  */
end_comment

begin_comment
comment|/*  * Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,  *                      and Nippon Telegraph and Telephone Corporation  * Copyright 1991 by the Massachusetts Institute of Technology  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of OMRON, NTT Software, NTT, and M.I.T.  * not be used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission. OMRON, NTT Software,  * NTT, and M.I.T. make no representations about the suitability of this  * software for any purpose.  It is provided "as is" without express or  * implied warranty.  *  * OMRON, NTT SOFTWARE, NTT, AND M.I.T. DISCLAIM ALL WARRANTIES WITH REGARD  * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS, IN NO EVENT SHALL OMRON, NTT SOFTWARE, NTT, OR M.I.T. BE  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *	Authors: Li Yuhong		OMRON Corporation  *		 Hiroshi Kuribayashi	OMRON Coproration  *     */
end_comment

begin_comment
comment|/*  * Functions:  *  _XConvertMBToWC()  *  _XConvertWCToMB()  *   */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xlocaleint.h"
end_include

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include

begin_define
define|#
directive|define
name|ESC
value|0x1b
end_define

begin_define
define|#
directive|define
name|CSI
value|0x9b
end_define

begin_comment
comment|/*   _IsValidEscSequence()   if str is valid escape sequence returns length of it in bytes.   else if str is not valid escape sequence returns BadEncoding.   else if str has not enough data returns BadTerminate.    ISO 2022     6.3.3 Categories of escape sequence     6.3.3.1 Two-character escape sequence     ESC Fs	Fs : 06/00 to 07/15     ESC Fe	Fe : 04/00 to 05/15     ESC Fp	Fp : 03/00 to 03/14      6.3.3.2 Three-character escape sequence     ESC I F	I  : 02/00 to 02/15     ESC I Ft	Ft : 04/00 to 07/14     ESC I Fp	Fp : 03/00 to 03/15      6.3.3.3 Escape sequence having four or more characters     ESC I...I F    ISO 2375 : (I will rewrite this function after reading ISO 2375 :-)    ISO 6429     5.5 Control sequence (C1& CSI)     CSI P...P I...I F     CSI : 01/11 05/11 or 09/11     P...P Paramer Bytes, if present, consist from 03/00 to 03/15     I...I Intermediate Bytes, if present, consist from 02/00 to 02/15     F Final Byte, from 04/00 to 07/14      5.6 Independent control function     ESC Fs (same as ISO 2022) */
end_comment

begin_function
specifier|static
name|int
name|_IsValidEscSequence
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|BadTerminate
operator|)
return|;
if|if
condition|(
operator|*
name|str
operator|==
name|ESC
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|1
condition|)
comment|/* Only ESC */
return|return
operator|(
literal|1
operator|)
return|;
name|len
operator|--
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'['
condition|)
block|{
comment|/* 7bit CSI */
name|len
operator|--
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|>=
literal|0x30
operator|&&
operator|*
name|str
operator|<=
literal|0x7e
condition|)
block|{
return|return
operator|(
literal|2
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|>=
literal|0x20
operator|&&
operator|*
name|str
operator|<=
literal|0x2f
condition|)
block|{
for|for
control|(
name|i
operator|++
operator|,
name|len
operator|--
operator|,
name|str
operator|++
init|;
name|len
operator|>
literal|0
condition|;
name|str
operator|++
operator|,
name|i
operator|++
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|>=
literal|0x30
operator|&&
operator|*
name|str
operator|<=
literal|0x7e
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
operator|*
name|str
operator|<
literal|0x20
operator|||
operator|*
name|str
operator|>=
literal|0x7f
condition|)
return|return
operator|(
name|BadEncoding
operator|)
return|;
comment|/* Not valid Escape seqence */
block|}
return|return
operator|(
name|BadTerminate
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|BadEncoding
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|CSI
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|BadEncoding
operator|)
return|;
comment|/* Not Escape sequence */
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
comment|/* Only CSI */
for|for
control|(
name|i
operator|++
init|;
name|len
operator|>
literal|0
condition|;
name|str
operator|++
operator|,
name|i
operator|++
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|>=
literal|0x40
operator|&&
operator|*
name|str
operator|<=
literal|0x7e
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
operator|*
name|str
operator|<
literal|0x20
operator|||
operator|*
name|str
operator|>=
literal|0x7f
condition|)
return|return
operator|(
name|BadEncoding
operator|)
return|;
comment|/* Not valid Escape seqence */
block|}
return|return
operator|(
name|BadTerminate
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Return
parameter_list|(
name|result
parameter_list|)
value|{                                                \         *wc_len = wccnt;                                                \         *scanned_bytes = mbcnt;                                         \ 	if (state) *state = xlocale->mb_state;				\ 	if (wccnt< limit)						\ 	    *wc_str = WNULL;						\         if (error != 0) return(error);                                  \         return(result);                                                 \     }
end_define

begin_define
define|#
directive|define
name|SaveStore
parameter_list|(
name|wc
parameter_list|)
value|{                                                 \         if (wccnt>= limit) Return(BadBuffer);                          \         *wc_str++ = wc;                                                 \         wccnt++;                                                        \     }
end_define

begin_comment
comment|/*  * _XConvertMBToWC()  *   convert string encoded in the current locale to wchar string.  *   if the codeset of locale is state-dependent, the _Xmbcsid()  *   will keep the current state, so need not the argument, such as isostate  *   to remember it.   * Return Valur:  *   Success  *   BadBuffer  *   BadTerminate  *> 0        number of wrong codepoints, but recovered by function  *  */
end_comment

begin_function
name|int
name|_XConvertMBToWC
parameter_list|(
name|xlocale
parameter_list|,
name|mb_str
parameter_list|,
name|mb_bytes
parameter_list|,
name|wc_str
parameter_list|,
name|wc_len
parameter_list|,
name|scanned_bytes
parameter_list|,
name|state
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mb_str
decl_stmt|;
name|int
name|mb_bytes
decl_stmt|;
name|wchar
modifier|*
name|wc_str
decl_stmt|;
name|int
modifier|*
name|wc_len
decl_stmt|;
name|int
modifier|*
name|scanned_bytes
decl_stmt|;
name|_State
modifier|*
name|state
decl_stmt|;
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|_CSID
name|csid_sv
decl_stmt|,
name|newcsid
decl_stmt|;
name|int
name|mbcnt
decl_stmt|,
name|wccnt
decl_stmt|,
name|deslen
decl_stmt|,
name|codelen
decl_stmt|,
name|code
decl_stmt|;
name|int
name|error
decl_stmt|,
name|limit
decl_stmt|;
name|wchar
name|woffset
decl_stmt|;
if|if
condition|(
operator|!
name|xlocale
condition|)
name|xlocale
operator|=
name|_XFallBackConvert
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|&&
operator|*
name|state
operator|!=
name|XDEFAULT_STATE
condition|)
block|{
name|xlocale
operator|->
name|mb_state
operator|=
operator|*
name|state
expr_stmt|;
if|if
condition|(
name|_XmbCheck
argument_list|(
name|xlocale
argument_list|)
operator|==
name|False
condition|)
name|_Xmbinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
block|}
else|else
name|_Xmbinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|*
name|wc_len
expr_stmt|;
name|mbcnt
operator|=
name|wccnt
operator|=
name|error
operator|=
literal|0
expr_stmt|;
name|csid_sv
operator|=
name|mbGetid
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|codelen
operator|=
name|_Xmblen
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|woffset
operator|=
name|_Xmbfswf
argument_list|(
name|xlocale
argument_list|,
name|csid_sv
argument_list|)
expr_stmt|;
while|while
condition|(
name|mb_bytes
operator|>
literal|0
operator|&&
operator|(
name|c
operator|=
operator|*
name|mb_str
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|newcsid
operator|=
name|_Xmbcsid
argument_list|(
name|xlocale
argument_list|,
name|mb_str
argument_list|)
operator|)
operator|==
name|ND
condition|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|_IsValidEscSequence
argument_list|(
name|mb_str
argument_list|,
name|mb_bytes
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
name|SaveStore
argument_list|(
name|_Xatowc
argument_list|(
operator|*
name|mb_str
argument_list|)
argument_list|)
expr_stmt|;
name|mb_str
operator|++
operator|,
name|mbcnt
operator|++
operator|,
name|mb_bytes
operator|--
expr_stmt|;
block|}
continue|continue;
block|}
name|Return
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
comment|/*          * filter control characters.          */
if|if
condition|(
name|newcsid
operator|==
name|C0
operator|||
name|newcsid
operator|==
name|C1
condition|)
block|{
name|SaveStore
argument_list|(
name|_Xatowc
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|mb_str
operator|++
operator|,
name|mbcnt
operator|++
operator|,
name|mb_bytes
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/*          * skip designation sequence of state-dependent codeset.          * Warning: cannot recover the error of BadTerminate in this case.          */
if|if
condition|(
name|_Xmbtype
argument_list|(
name|xlocale
argument_list|)
operator|==
name|CDS_STATEFUL
operator|&&
operator|(
name|deslen
operator|=
name|_Xmbdlen
argument_list|(
name|xlocale
argument_list|,
name|mb_str
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|mb_str
operator|+=
name|deslen
operator|,
name|mbcnt
operator|+=
name|deslen
operator|,
name|mb_bytes
operator|-=
name|deslen
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|csid_sv
operator|!=
name|newcsid
condition|)
block|{
name|codelen
operator|=
name|_Xmblen
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|woffset
operator|=
name|_Xmbfswf
argument_list|(
name|xlocale
argument_list|,
name|newcsid
argument_list|)
expr_stmt|;
name|csid_sv
operator|=
name|newcsid
expr_stmt|;
block|}
if|if
condition|(
name|codelen
operator|>
name|mb_bytes
condition|)
name|Return
argument_list|(
name|BadTerminate
argument_list|)
expr_stmt|;
if|if
condition|(
name|_Xmbctocsc
argument_list|(
name|xlocale
argument_list|,
name|mb_str
argument_list|,
operator|&
name|code
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|++
expr_stmt|;
name|SaveStore
argument_list|(
operator|(
name|code
operator|&
literal|0x7f7f
operator|)
operator||
name|woffset
argument_list|)
expr_stmt|;
name|mb_str
operator|+=
name|codelen
operator|,
name|mbcnt
operator|+=
name|codelen
operator|,
name|mb_bytes
operator|-=
name|codelen
expr_stmt|;
block|}
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|Return
end_undef

begin_undef
undef|#
directive|undef
name|SaveStore
end_undef

begin_define
define|#
directive|define
name|Return
parameter_list|(
name|result
parameter_list|)
value|{                                                \         *mb_bytes = mbcnt;                                              \         *scanned_len = wccnt;                                           \ 	if (mbcnt< limit)						\ 	    *mb_str = 0;						\         if (error != 0) return(error);                                  \         return(result);                                                 \     }
end_define

begin_define
define|#
directive|define
name|SaveStore
parameter_list|(
name|c
parameter_list|)
value|{                                                  \         if (mbcnt>= limit) Return(BadBuffer);                          \         *mb_str++ = c;                                                  \         mbcnt++;                                                        \     }
end_define

begin_comment
comment|/*  * _XConvertWCToMB()  *   convert wchar string to the string encoded in the current locale.  *   * Return Valur:  *   Success  *   BadBuffer  *> 0        number of wrong codepoints, but recovered by function  * */
end_comment

begin_function
name|int
name|_XConvertWCToMB
parameter_list|(
name|xlocale
parameter_list|,
name|wc_str
parameter_list|,
name|wc_len
parameter_list|,
name|mb_str
parameter_list|,
name|mb_bytes
parameter_list|,
name|scanned_len
parameter_list|)
name|XLocale
name|xlocale
decl_stmt|;
name|wchar
modifier|*
name|wc_str
decl_stmt|;
name|int
name|wc_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mb_str
decl_stmt|;
name|int
modifier|*
name|mb_bytes
decl_stmt|;
name|int
modifier|*
name|scanned_len
decl_stmt|;
block|{
name|int
name|limit
decl_stmt|,
name|mbcnt
decl_stmt|,
name|wccnt
decl_stmt|;
name|_CSID
name|csid_sv
decl_stmt|,
name|newcsid
decl_stmt|;
name|int
name|code
decl_stmt|,
name|codelen
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|_State
name|state_sv
decl_stmt|;
name|wchar
name|wc
decl_stmt|,
name|woffset
decl_stmt|,
name|newwoffset
decl_stmt|;
specifier|extern
name|void
name|_XmbSetCsid
parameter_list|()
function_decl|;
name|char
modifier|*
name|defstr
init|=
name|XDefaultString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xlocale
condition|)
name|xlocale
operator|=
name|_XFallBackConvert
argument_list|()
expr_stmt|;
name|_Xmbinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|_Xctinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|*
name|mb_bytes
expr_stmt|;
name|mbcnt
operator|=
name|wccnt
operator|=
name|error
operator|=
literal|0
expr_stmt|;
name|csid_sv
operator|=
name|mbGetid
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|codelen
operator|=
name|_Xmblen
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|woffset
operator|=
name|_Xmbfswf
argument_list|(
name|xlocale
argument_list|,
name|csid_sv
argument_list|)
expr_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|mb_state
expr_stmt|;
while|while
condition|(
name|wc_len
operator|>
literal|0
operator|&&
operator|(
operator|(
name|wc
operator|=
operator|*
name|wc_str
operator|)
operator|!=
name|WNULL
operator|)
condition|)
block|{
name|_CSID
name|ctid
decl_stmt|;
if|if
condition|(
name|_Xiswcntrl
argument_list|(
name|wc
argument_list|)
condition|)
block|{
name|SaveStore
argument_list|(
name|_Xwctoa
argument_list|(
name|wc
argument_list|)
argument_list|)
expr_stmt|;
name|wc_str
operator|++
operator|,
name|wccnt
operator|++
operator|,
name|wc_len
operator|--
expr_stmt|;
continue|continue;
block|}
name|ctid
operator|=
name|_XcwGetWoffsetFromLocale
argument_list|(
name|xlocale
argument_list|,
operator|*
name|wc_str
argument_list|,
operator|&
name|newwoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctid
operator|==
name|ND
operator|||
operator|(
name|newcsid
operator|=
name|_Xmbctidtocsid
argument_list|(
name|xlocale
argument_list|,
name|ctid
argument_list|)
operator|)
operator|==
name|ND
condition|)
block|{
comment|/* XXX BUG: if stateful encoding, need to check/add 			designate sequence of default string. 	       But current default string is NULL, so OK. :-) */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|defstr
operator|+
name|i
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|SaveStore
argument_list|(
argument|*(defstr + i)
argument_list|)
block|}
name|error
operator|++
expr_stmt|;
name|wc_str
operator|++
operator|,
name|wccnt
operator|++
operator|,
name|wc_len
operator|--
expr_stmt|;
continue|continue;
block|}
name|_XmbSetCsid
argument_list|(
name|xlocale
argument_list|,
name|newcsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|csid_sv
operator|!=
name|newcsid
condition|)
block|{
name|int
name|mbGLorGR
decl_stmt|;
if|if
condition|(
name|_Xmbtype
argument_list|(
name|xlocale
argument_list|)
operator|==
name|CDS_STATEFUL
operator|&&
operator|(
operator|(
name|mbGLorGR
operator|=
name|mbGetGLorGR
argument_list|(
name|xlocale
argument_list|)
operator|)
operator|==
name|GL
operator|&&
name|mbGetGLid
argument_list|(
name|xlocale
argument_list|)
operator|!=
operator|(
name|state_sv
operator|&
literal|0xff
operator|)
operator|||
name|mbGLorGR
operator|==
name|GR
operator|&&
name|mbGetGRid
argument_list|(
name|xlocale
argument_list|)
operator|!=
operator|(
name|state_sv
operator|>>
literal|8
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
comment|/*                  * add designation sequence.                  */
name|char
modifier|*
name|dsg
decl_stmt|;
name|int
name|dsglen
decl_stmt|;
name|dsg
operator|=
name|_Xmbdsg
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|dsglen
operator|=
name|strlen
argument_list|(
name|dsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbcnt
operator|+
name|dsglen
operator|>
name|limit
condition|)
name|Return
argument_list|(
name|BadBuffer
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mb_str
argument_list|,
name|dsg
argument_list|,
name|dsglen
argument_list|)
expr_stmt|;
name|mb_str
operator|+=
name|dsglen
operator|,
name|mbcnt
operator|+=
name|dsglen
expr_stmt|;
name|state_sv
operator|=
name|xlocale
operator|->
name|mb_state
expr_stmt|;
block|}
name|codelen
operator|=
name|_Xmblen
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
name|csid_sv
operator|=
name|newcsid
expr_stmt|;
name|woffset
operator|=
name|newwoffset
expr_stmt|;
block|}
if|if
condition|(
name|_Xcsctombc
argument_list|(
name|xlocale
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|wc_str
operator|-
name|woffset
argument_list|)
argument_list|,
operator|&
name|code
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|codelen
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|SaveStore
argument_list|(
operator|(
name|code
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0x00FF
argument_list|)
expr_stmt|;
name|wc_str
operator|++
operator|,
name|wccnt
operator|++
operator|,
name|wc_len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|_Xmbtype
argument_list|(
name|xlocale
argument_list|)
operator|==
name|CDS_STATEFUL
condition|)
block|{
comment|/* 	 * add designation sequence. 	 */
name|char
name|dsg
index|[
literal|64
index|]
decl_stmt|;
name|int
name|dsglen
decl_stmt|;
name|_XmbGetDefaultEncoding
argument_list|(
name|xlocale
argument_list|,
name|dsg
argument_list|)
expr_stmt|;
name|dsglen
operator|=
name|strlen
argument_list|(
name|dsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbcnt
operator|+
name|dsglen
operator|>
name|limit
condition|)
name|Return
argument_list|(
name|BadBuffer
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mb_str
argument_list|,
name|dsg
argument_list|,
name|dsglen
argument_list|)
expr_stmt|;
name|mb_str
operator|+=
name|dsglen
operator|,
name|mbcnt
operator|+=
name|dsglen
expr_stmt|;
name|_Xmbinit
argument_list|(
name|xlocale
argument_list|)
expr_stmt|;
block|}
name|Return
argument_list|(
name|Success
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

