begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XKeyBind.c,v 11.67 92/05/19 11:23:14 converse Exp $ */
end_comment

begin_comment
comment|/* Copyright 1985, 1987, Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_comment
comment|/* Beware, here be monsters (still under construction... - JG */
end_comment

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|<X11/Xlibint.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xutil.h>
end_include

begin_define
define|#
directive|define
name|XK_MISCELLANY
end_define

begin_define
define|#
directive|define
name|XK_LATIN1
end_define

begin_define
define|#
directive|define
name|XK_LATIN2
end_define

begin_define
define|#
directive|define
name|XK_LATIN3
end_define

begin_define
define|#
directive|define
name|XK_LATIN4
end_define

begin_include
include|#
directive|include
file|<X11/keysymdef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|AllMods
value|(ShiftMask|LockMask|ControlMask| \ 		 Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask)
end_define

begin_expr_stmt
specifier|static
name|ComputeMaskFromKeytrans
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|Initialize
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|XConvertCase
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|_XKeytrans
block|{
name|struct
name|_XKeytrans
modifier|*
name|next
decl_stmt|;
comment|/* next on list */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* string to return when the time comes */
name|int
name|len
decl_stmt|;
comment|/* length of string (since NULL is legit)*/
name|KeySym
name|key
decl_stmt|;
comment|/* keysym rebound */
name|unsigned
name|int
name|state
decl_stmt|;
comment|/* modifier state */
name|KeySym
modifier|*
name|modifiers
decl_stmt|;
comment|/* modifier keysyms you want */
name|int
name|mlen
decl_stmt|;
comment|/* length of modifier list */
block|}
struct|;
end_struct

begin_function
specifier|static
name|KeySym
name|KeyCodetoKeySym
parameter_list|(
name|dpy
parameter_list|,
name|keycode
parameter_list|,
name|col
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
name|KeyCode
name|keycode
decl_stmt|;
name|int
name|col
decl_stmt|;
block|{
specifier|register
name|int
name|per
init|=
name|dpy
operator|->
name|keysyms_per_keycode
decl_stmt|;
specifier|register
name|KeySym
modifier|*
name|syms
decl_stmt|;
name|KeySym
name|lsym
decl_stmt|,
name|usym
decl_stmt|;
if|if
condition|(
operator|(
name|col
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|col
operator|>=
name|per
operator|)
operator|&&
operator|(
name|col
operator|>
literal|3
operator|)
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|keycode
operator|<
name|dpy
operator|->
name|min_keycode
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|keycode
operator|>
name|dpy
operator|->
name|max_keycode
operator|)
condition|)
return|return
name|NoSymbol
return|;
name|syms
operator|=
operator|&
name|dpy
operator|->
name|keysyms
index|[
operator|(
name|keycode
operator|-
name|dpy
operator|->
name|min_keycode
operator|)
operator|*
name|per
index|]
expr_stmt|;
if|if
condition|(
name|col
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|col
operator|>
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|per
operator|>
literal|2
operator|)
operator|&&
operator|(
name|syms
index|[
name|per
operator|-
literal|1
index|]
operator|==
name|NoSymbol
operator|)
condition|)
name|per
operator|--
expr_stmt|;
if|if
condition|(
name|per
operator|<
literal|3
condition|)
name|col
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|per
operator|<=
operator|(
name|col
operator||
literal|1
operator|)
operator|)
operator|||
operator|(
name|syms
index|[
name|col
operator||
literal|1
index|]
operator|==
name|NoSymbol
operator|)
condition|)
block|{
name|XConvertCase
argument_list|(
name|dpy
argument_list|,
name|syms
index|[
name|col
operator|&
operator|~
literal|1
index|]
argument_list|,
operator|&
name|lsym
argument_list|,
operator|&
name|usym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|col
operator|&
literal|1
operator|)
condition|)
return|return
name|lsym
return|;
elseif|else
if|if
condition|(
name|usym
operator|==
name|lsym
condition|)
return|return
name|NoSymbol
return|;
else|else
return|return
name|usym
return|;
block|}
block|}
return|return
name|syms
index|[
name|col
index|]
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_function
name|KeySym
name|XKeycodeToKeysym
parameter_list|(
name|Display
modifier|*
name|dpy
parameter_list|,
if|#
directive|if
name|NeedWidePrototypes
name|unsigned
name|int
name|kc
parameter_list|,
else|#
directive|else
name|KeyCode
name|kc
parameter_list|,
endif|#
directive|endif
name|int
name|col
parameter_list|)
else|#
directive|else
function|KeySym XKeycodeToKeysym
parameter_list|(
name|dpy
parameter_list|,
name|kc
parameter_list|,
name|col
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|KeyCode
name|kc
decl_stmt|;
name|int
name|col
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
operator|!
name|dpy
operator|->
name|keysyms
operator|)
operator|&&
operator|(
operator|!
name|Initialize
argument_list|(
name|dpy
argument_list|)
operator|)
condition|)
return|return
name|NoSymbol
return|;
return|return
name|KeyCodetoKeySym
argument_list|(
name|dpy
argument_list|,
name|kc
argument_list|,
name|col
argument_list|)
return|;
block|}
end_function

begin_function
name|KeyCode
name|XKeysymToKeycode
parameter_list|(
name|dpy
parameter_list|,
name|ks
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|KeySym
name|ks
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|dpy
operator|->
name|keysyms
operator|)
operator|&&
operator|(
operator|!
name|Initialize
argument_list|(
name|dpy
argument_list|)
operator|)
condition|)
return|return
operator|(
name|KeyCode
operator|)
literal|0
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dpy
operator|->
name|keysyms_per_keycode
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
name|dpy
operator|->
name|min_keycode
init|;
name|i
operator|<=
name|dpy
operator|->
name|max_keycode
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|KeyCodetoKeySym
argument_list|(
name|dpy
argument_list|,
operator|(
name|KeyCode
operator|)
name|i
argument_list|,
name|j
argument_list|)
operator|==
name|ks
condition|)
return|return
name|i
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|KeySym
name|XLookupKeysym
parameter_list|(
name|event
parameter_list|,
name|col
parameter_list|)
specifier|register
name|XKeyEvent
modifier|*
name|event
decl_stmt|;
name|int
name|col
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|!
name|event
operator|->
name|display
operator|->
name|keysyms
operator|)
operator|&&
operator|(
operator|!
name|Initialize
argument_list|(
name|event
operator|->
name|display
argument_list|)
operator|)
condition|)
return|return
name|NoSymbol
return|;
return|return
name|KeyCodetoKeySym
argument_list|(
name|event
operator|->
name|display
argument_list|,
name|event
operator|->
name|keycode
argument_list|,
name|col
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|InitModMap
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
block|{
specifier|register
name|XModifierKeymap
modifier|*
name|map
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|KeySym
name|sym
decl_stmt|;
specifier|register
name|struct
name|_XKeytrans
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dpy
operator|->
name|modifiermap
operator|=
name|map
operator|=
name|XGetModifierMapping
argument_list|(
name|dpy
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|dpy
operator|->
name|free_funcs
operator|->
name|modifiermap
operator|=
name|XFreeModifiermap
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|dpy
operator|->
name|keysyms
operator|)
operator|&&
operator|(
operator|!
name|Initialize
argument_list|(
name|dpy
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
comment|/* If any Lock key contains Caps_Lock, then interpret as Caps_Lock,      * else if any contains Shift_Lock, then interpret as Shift_Lock,      * else ignore Lock altogether.      */
name|dpy
operator|->
name|lock_meaning
operator|=
name|NoSymbol
expr_stmt|;
comment|/* Lock modifiers are in the second row of the matrix */
name|n
operator|=
literal|2
operator|*
name|map
operator|->
name|max_keypermod
expr_stmt|;
for|for
control|(
name|i
operator|=
name|map
operator|->
name|max_keypermod
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dpy
operator|->
name|keysyms_per_keycode
condition|;
name|j
operator|++
control|)
block|{
name|sym
operator|=
name|KeyCodetoKeySym
argument_list|(
name|dpy
argument_list|,
name|map
operator|->
name|modifiermap
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|XK_Caps_Lock
condition|)
block|{
name|dpy
operator|->
name|lock_meaning
operator|=
name|XK_Caps_Lock
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|sym
operator|==
name|XK_Shift_Lock
condition|)
block|{
name|dpy
operator|->
name|lock_meaning
operator|=
name|XK_Shift_Lock
expr_stmt|;
block|}
block|}
block|}
comment|/* Now find any Mod<n> modifier acting as the Group modifier */
name|dpy
operator|->
name|mode_switch
operator|=
literal|0
expr_stmt|;
name|n
operator|*=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
operator|*
name|map
operator|->
name|max_keypermod
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dpy
operator|->
name|keysyms_per_keycode
condition|;
name|j
operator|++
control|)
block|{
name|sym
operator|=
name|KeyCodetoKeySym
argument_list|(
name|dpy
argument_list|,
name|map
operator|->
name|modifiermap
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|XK_Mode_switch
condition|)
name|dpy
operator|->
name|mode_switch
operator||=
literal|1
operator|<<
operator|(
name|i
operator|/
name|map
operator|->
name|max_keypermod
operator|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|dpy
operator|->
name|key_bindings
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|ComputeMaskFromKeytrans
argument_list|(
name|dpy
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|XRefreshKeyboardMapping
argument_list|(
name|event
argument_list|)
specifier|register
name|XMappingEvent
operator|*
name|event
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|event
operator|->
name|request
operator|==
name|MappingKeyboard
condition|)
block|{
comment|/* XXX should really only refresh what is necessary 	 * for now, make initialize test fail 	 */
name|LockDisplay
argument_list|(
name|event
operator|->
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|display
operator|->
name|keysyms
condition|)
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|event
operator|->
name|display
operator|->
name|keysyms
argument_list|)
expr_stmt|;
name|event
operator|->
name|display
operator|->
name|keysyms
operator|=
name|NULL
expr_stmt|;
block|}
name|UnlockDisplay
argument_list|(
name|event
operator|->
name|display
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|->
name|request
operator|==
name|MappingModifier
condition|)
block|{
name|LockDisplay
argument_list|(
name|event
operator|->
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|display
operator|->
name|modifiermap
condition|)
block|{
name|XFreeModifiermap
argument_list|(
name|event
operator|->
name|display
operator|->
name|modifiermap
argument_list|)
expr_stmt|;
name|event
operator|->
name|display
operator|->
name|modifiermap
operator|=
name|NULL
expr_stmt|;
block|}
name|UnlockDisplay
argument_list|(
name|event
operator|->
name|display
argument_list|)
expr_stmt|;
comment|/* go ahead and get it now, since initialize test may not fail */
operator|(
name|void
operator|)
name|InitModMap
argument_list|(
name|event
operator|->
name|display
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|int
name|Initialize
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
block|{
name|int
name|per
decl_stmt|,
name|n
decl_stmt|;
name|KeySym
modifier|*
name|keysyms
decl_stmt|;
comment|/*       * lets go get the keysyms from the server.      */
if|if
condition|(
operator|!
name|dpy
operator|->
name|keysyms
condition|)
block|{
name|n
operator|=
name|dpy
operator|->
name|max_keycode
operator|-
name|dpy
operator|->
name|min_keycode
operator|+
literal|1
expr_stmt|;
name|keysyms
operator|=
name|XGetKeyboardMapping
argument_list|(
name|dpy
argument_list|,
operator|(
name|KeyCode
operator|)
name|dpy
operator|->
name|min_keycode
argument_list|,
name|n
argument_list|,
operator|&
name|per
argument_list|)
expr_stmt|;
comment|/* keysyms may be NULL */
if|if
condition|(
operator|!
name|keysyms
condition|)
return|return
literal|0
return|;
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|dpy
operator|->
name|keysyms
operator|=
name|keysyms
expr_stmt|;
name|dpy
operator|->
name|keysyms_per_keycode
operator|=
name|per
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dpy
operator|->
name|modifiermap
condition|)
return|return
name|InitModMap
argument_list|(
name|dpy
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|XConvertCase
parameter_list|(
name|dpy
parameter_list|,
name|sym
parameter_list|,
name|lower
parameter_list|,
name|upper
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
specifier|register
name|KeySym
name|sym
decl_stmt|;
name|KeySym
modifier|*
name|lower
decl_stmt|;
name|KeySym
modifier|*
name|upper
decl_stmt|;
block|{
operator|*
name|lower
operator|=
name|sym
expr_stmt|;
operator|*
name|upper
operator|=
name|sym
expr_stmt|;
switch|switch
condition|(
name|sym
operator|>>
literal|8
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|sym
operator|>=
name|XK_A
operator|)
operator|&&
operator|(
name|sym
operator|<=
name|XK_Z
operator|)
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_a
operator|-
name|XK_A
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|>=
name|XK_a
operator|)
operator|&&
operator|(
name|sym
operator|<=
name|XK_z
operator|)
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_a
operator|-
name|XK_A
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|>=
name|XK_Agrave
operator|)
operator|&&
operator|(
name|sym
operator|<=
name|XK_Odiaeresis
operator|)
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_agrave
operator|-
name|XK_Agrave
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|>=
name|XK_agrave
operator|)
operator|&&
operator|(
name|sym
operator|<=
name|XK_odiaeresis
operator|)
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_agrave
operator|-
name|XK_Agrave
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|>=
name|XK_Ooblique
operator|)
operator|&&
operator|(
name|sym
operator|<=
name|XK_Thorn
operator|)
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_oslash
operator|-
name|XK_Ooblique
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sym
operator|>=
name|XK_oslash
operator|)
operator|&&
operator|(
name|sym
operator|<=
name|XK_thorn
operator|)
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_oslash
operator|-
name|XK_Ooblique
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|XK_LATIN2
case|case
literal|1
case|:
comment|/* Assume the KeySym is a legal value (ignore discontinuities) */
if|if
condition|(
name|sym
operator|==
name|XK_Aogonek
condition|)
operator|*
name|lower
operator|=
name|XK_aogonek
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_Lstroke
operator|&&
name|sym
operator|<=
name|XK_Sacute
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_lstroke
operator|-
name|XK_Lstroke
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_Scaron
operator|&&
name|sym
operator|<=
name|XK_Zacute
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_scaron
operator|-
name|XK_Scaron
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_Zcaron
operator|&&
name|sym
operator|<=
name|XK_Zabovedot
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_zcaron
operator|-
name|XK_Zcaron
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|==
name|XK_aogonek
condition|)
operator|*
name|upper
operator|=
name|XK_Aogonek
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_lstroke
operator|&&
name|sym
operator|<=
name|XK_sacute
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_lstroke
operator|-
name|XK_Lstroke
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_scaron
operator|&&
name|sym
operator|<=
name|XK_zacute
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_scaron
operator|-
name|XK_Scaron
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_zcaron
operator|&&
name|sym
operator|<=
name|XK_zabovedot
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_zcaron
operator|-
name|XK_Zcaron
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_Racute
operator|&&
name|sym
operator|<=
name|XK_Tcedilla
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_racute
operator|-
name|XK_Racute
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_racute
operator|&&
name|sym
operator|<=
name|XK_tcedilla
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_racute
operator|-
name|XK_Racute
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XK_LATIN3
case|case
literal|2
case|:
comment|/* Assume the KeySym is a legal value (ignore discontinuities) */
if|if
condition|(
name|sym
operator|>=
name|XK_Hstroke
operator|&&
name|sym
operator|<=
name|XK_Hcircumflex
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_hstroke
operator|-
name|XK_Hstroke
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_Gbreve
operator|&&
name|sym
operator|<=
name|XK_Jcircumflex
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_gbreve
operator|-
name|XK_Gbreve
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_hstroke
operator|&&
name|sym
operator|<=
name|XK_hcircumflex
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_hstroke
operator|-
name|XK_Hstroke
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_gbreve
operator|&&
name|sym
operator|<=
name|XK_jcircumflex
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_gbreve
operator|-
name|XK_Gbreve
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_Cabovedot
operator|&&
name|sym
operator|<=
name|XK_Scircumflex
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_cabovedot
operator|-
name|XK_Cabovedot
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_cabovedot
operator|&&
name|sym
operator|<=
name|XK_scircumflex
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_cabovedot
operator|-
name|XK_Cabovedot
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XK_LATIN4
case|case
literal|3
case|:
comment|/* Assume the KeySym is a legal value (ignore discontinuities) */
if|if
condition|(
name|sym
operator|>=
name|XK_Rcedilla
operator|&&
name|sym
operator|<=
name|XK_Tslash
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_rcedilla
operator|-
name|XK_Rcedilla
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_rcedilla
operator|&&
name|sym
operator|<=
name|XK_tslash
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_rcedilla
operator|-
name|XK_Rcedilla
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|==
name|XK_ENG
condition|)
operator|*
name|lower
operator|=
name|XK_eng
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|==
name|XK_eng
condition|)
operator|*
name|upper
operator|=
name|XK_ENG
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_Amacron
operator|&&
name|sym
operator|<=
name|XK_Umacron
condition|)
operator|*
name|lower
operator|+=
operator|(
name|XK_amacron
operator|-
name|XK_Amacron
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|>=
name|XK_amacron
operator|&&
name|sym
operator|<=
name|XK_umacron
condition|)
operator|*
name|upper
operator|-=
operator|(
name|XK_amacron
operator|-
name|XK_Amacron
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|XTranslateKey
parameter_list|(
name|dpy
parameter_list|,
name|keycode
parameter_list|,
name|modifiers
parameter_list|,
name|modifiers_return
parameter_list|,
name|keysym_return
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
name|KeyCode
name|keycode
decl_stmt|;
specifier|register
name|unsigned
name|int
name|modifiers
decl_stmt|;
name|unsigned
name|int
modifier|*
name|modifiers_return
decl_stmt|;
name|KeySym
modifier|*
name|keysym_return
decl_stmt|;
block|{
name|int
name|per
decl_stmt|;
specifier|register
name|KeySym
modifier|*
name|syms
decl_stmt|;
name|KeySym
name|sym
decl_stmt|,
name|lsym
decl_stmt|,
name|usym
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|dpy
operator|->
name|keysyms
operator|)
operator|&&
operator|(
operator|!
name|Initialize
argument_list|(
name|dpy
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
operator|*
name|modifiers_return
operator|=
operator|(
name|ShiftMask
operator||
name|LockMask
operator|)
operator||
name|dpy
operator|->
name|mode_switch
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|keycode
operator|<
name|dpy
operator|->
name|min_keycode
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|keycode
operator|>
name|dpy
operator|->
name|max_keycode
operator|)
condition|)
block|{
operator|*
name|keysym_return
operator|=
name|NoSymbol
expr_stmt|;
return|return
literal|1
return|;
block|}
name|per
operator|=
name|dpy
operator|->
name|keysyms_per_keycode
expr_stmt|;
name|syms
operator|=
operator|&
name|dpy
operator|->
name|keysyms
index|[
operator|(
name|keycode
operator|-
name|dpy
operator|->
name|min_keycode
operator|)
operator|*
name|per
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|per
operator|>
literal|2
operator|)
operator|&&
operator|(
name|syms
index|[
name|per
operator|-
literal|1
index|]
operator|==
name|NoSymbol
operator|)
condition|)
name|per
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|per
operator|>
literal|2
operator|)
operator|&&
operator|(
name|modifiers
operator|&
name|dpy
operator|->
name|mode_switch
operator|)
condition|)
block|{
name|syms
operator|+=
literal|2
expr_stmt|;
name|per
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|modifiers
operator|&
name|ShiftMask
operator|)
operator|&&
operator|(
operator|!
operator|(
name|modifiers
operator|&
name|LockMask
operator|)
operator|||
operator|(
name|dpy
operator|->
name|lock_meaning
operator|==
name|NoSymbol
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|per
operator|==
literal|1
operator|)
operator|||
operator|(
name|syms
index|[
literal|1
index|]
operator|==
name|NoSymbol
operator|)
condition|)
name|XConvertCase
argument_list|(
name|dpy
argument_list|,
name|syms
index|[
literal|0
index|]
argument_list|,
name|keysym_return
argument_list|,
operator|&
name|usym
argument_list|)
expr_stmt|;
else|else
operator|*
name|keysym_return
operator|=
name|syms
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|modifiers
operator|&
name|LockMask
operator|)
operator|||
operator|(
name|dpy
operator|->
name|lock_meaning
operator|!=
name|XK_Caps_Lock
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|per
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|usym
operator|=
name|syms
index|[
literal|1
index|]
operator|)
operator|==
name|NoSymbol
operator|)
condition|)
name|XConvertCase
argument_list|(
name|dpy
argument_list|,
name|syms
index|[
literal|0
index|]
argument_list|,
operator|&
name|lsym
argument_list|,
operator|&
name|usym
argument_list|)
expr_stmt|;
operator|*
name|keysym_return
operator|=
name|usym
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|per
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|sym
operator|=
name|syms
index|[
literal|1
index|]
operator|)
operator|==
name|NoSymbol
operator|)
condition|)
name|sym
operator|=
name|syms
index|[
literal|0
index|]
expr_stmt|;
name|XConvertCase
argument_list|(
name|dpy
argument_list|,
name|sym
argument_list|,
operator|&
name|lsym
argument_list|,
operator|&
name|usym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|modifiers
operator|&
name|ShiftMask
operator|)
operator|&&
operator|(
name|sym
operator|!=
name|syms
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
operator|(
name|sym
operator|!=
name|usym
operator|)
operator|||
operator|(
name|lsym
operator|==
name|usym
operator|)
operator|)
condition|)
name|XConvertCase
argument_list|(
name|dpy
argument_list|,
name|syms
index|[
literal|0
index|]
argument_list|,
operator|&
name|lsym
argument_list|,
operator|&
name|usym
argument_list|)
expr_stmt|;
operator|*
name|keysym_return
operator|=
name|usym
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|keysym_return
operator|==
name|XK_VoidSymbol
condition|)
operator|*
name|keysym_return
operator|=
name|NoSymbol
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|XTranslateKeySym
parameter_list|(
name|dpy
parameter_list|,
name|symbol
parameter_list|,
name|modifiers
parameter_list|,
name|buffer
parameter_list|,
name|nbytes
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
specifier|register
name|KeySym
name|symbol
decl_stmt|;
name|unsigned
name|int
name|modifiers
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|struct
name|_XKeytrans
modifier|*
name|p
decl_stmt|;
name|int
name|length
decl_stmt|;
name|unsigned
name|long
name|hiBytes
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|symbol
condition|)
return|return
literal|0
return|;
comment|/* see if symbol rebound, if so, return that string. */
for|for
control|(
name|p
operator|=
name|dpy
operator|->
name|key_bindings
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|modifiers
operator|&
name|AllMods
operator|)
operator|==
name|p
operator|->
name|state
operator|)
operator|&&
operator|(
name|symbol
operator|==
name|p
operator|->
name|key
operator|)
condition|)
block|{
name|length
operator|=
name|p
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|nbytes
condition|)
name|length
operator|=
name|nbytes
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|string
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
block|}
comment|/* try to convert to Latin-1, handling control */
name|hiBytes
operator|=
name|symbol
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nbytes
operator|&&
operator|(
operator|(
name|hiBytes
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|hiBytes
operator|==
literal|0xFF
operator|)
operator|&&
operator|(
operator|(
operator|(
name|symbol
operator|>=
name|XK_BackSpace
operator|)
operator|&&
operator|(
name|symbol
operator|<=
name|XK_Clear
operator|)
operator|)
operator|||
operator|(
name|symbol
operator|==
name|XK_Return
operator|)
operator|||
operator|(
name|symbol
operator|==
name|XK_Escape
operator|)
operator|||
operator|(
name|symbol
operator|==
name|XK_KP_Space
operator|)
operator|||
operator|(
name|symbol
operator|==
name|XK_KP_Tab
operator|)
operator|||
operator|(
name|symbol
operator|==
name|XK_KP_Enter
operator|)
operator|||
operator|(
operator|(
name|symbol
operator|>=
name|XK_KP_Multiply
operator|)
operator|&&
operator|(
name|symbol
operator|<=
name|XK_KP_9
operator|)
operator|)
operator|||
operator|(
name|symbol
operator|==
name|XK_KP_Equal
operator|)
operator|||
operator|(
name|symbol
operator|==
name|XK_Delete
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* if X keysym, convert to ascii by grabbing low 7 bits */
if|if
condition|(
name|symbol
operator|==
name|XK_KP_Space
condition|)
name|c
operator|=
name|XK_space
operator|&
literal|0x7F
expr_stmt|;
comment|/* patch encoding botch */
elseif|else
if|if
condition|(
name|symbol
operator|==
name|XK_hyphen
condition|)
name|c
operator|=
name|XK_minus
operator|&
literal|0xFF
expr_stmt|;
comment|/* map to equiv character */
elseif|else
if|if
condition|(
name|hiBytes
operator|==
literal|0xFF
condition|)
name|c
operator|=
name|symbol
operator|&
literal|0x7F
expr_stmt|;
else|else
name|c
operator|=
name|symbol
operator|&
literal|0xFF
expr_stmt|;
comment|/* only apply Control key if it makes sense, else ignore it */
if|if
condition|(
name|modifiers
operator|&
name|ControlMask
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'@'
operator|&&
name|c
operator|<
literal|'\177'
operator|)
operator|||
name|c
operator|==
literal|' '
condition|)
name|c
operator|&=
literal|0x1F
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'2'
condition|)
name|c
operator|=
literal|'\000'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'3'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
name|c
operator|-=
operator|(
literal|'3'
operator|-
literal|'\033'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'8'
condition|)
name|c
operator|=
literal|'\177'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|c
operator|=
literal|'_'
operator|&
literal|0x1F
expr_stmt|;
block|}
name|buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|XLookupString
parameter_list|(
name|event
parameter_list|,
name|buffer
parameter_list|,
name|nbytes
parameter_list|,
name|keysym
parameter_list|,
name|status
parameter_list|)
specifier|register
name|XKeyEvent
modifier|*
name|event
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* buffer */
name|int
name|nbytes
decl_stmt|;
comment|/* space in buffer for characters */
name|KeySym
modifier|*
name|keysym
decl_stmt|;
name|XComposeStatus
modifier|*
name|status
decl_stmt|;
comment|/* not implemented */
block|{
name|unsigned
name|int
name|modifiers
decl_stmt|;
name|KeySym
name|symbol
decl_stmt|;
if|if
condition|(
operator|!
name|XTranslateKey
argument_list|(
name|event
operator|->
name|display
argument_list|,
name|event
operator|->
name|keycode
argument_list|,
name|event
operator|->
name|state
argument_list|,
operator|&
name|modifiers
argument_list|,
operator|&
name|symbol
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|keysym
condition|)
operator|*
name|keysym
operator|=
name|symbol
expr_stmt|;
comment|/* arguable whether to use (event->state& ~modifiers) here */
return|return
name|XTranslateKeySym
argument_list|(
name|event
operator|->
name|display
argument_list|,
name|symbol
argument_list|,
name|event
operator|->
name|state
argument_list|,
name|buffer
argument_list|,
name|nbytes
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_XFreeKeyBindings
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
block|{
specifier|register
name|struct
name|_XKeytrans
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|p
operator|=
name|dpy
operator|->
name|key_bindings
init|;
name|p
condition|;
name|p
operator|=
name|np
control|)
block|{
name|np
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|Xfree
argument_list|(
name|p
operator|->
name|string
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|modifiers
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|NeedFunctionPrototypes
end_if

begin_macro
name|XRebindKeysym
argument_list|(
argument|Display *dpy
argument_list|,
argument|KeySym keysym
argument_list|,
argument|KeySym *mlist
argument_list|,
argument|int nm
argument_list|,
comment|/* number of modifiers in mlist */
argument|_Xconst unsigned char *str
argument_list|,
argument|int nbytes
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_macro
name|XRebindKeysym
argument_list|(
argument|dpy
argument_list|,
argument|keysym
argument_list|,
argument|mlist
argument_list|,
argument|nm
argument_list|,
argument|str
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|KeySym
name|keysym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|KeySym
modifier|*
name|mlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of modifiers in mlist */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbytes
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|struct
name|_XKeytrans
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|nb
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|dpy
operator|->
name|keysyms
operator|)
operator|&&
operator|(
operator|!
name|Initialize
argument_list|(
name|dpy
argument_list|)
operator|)
condition|)
return|return;
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|dpy
operator|->
name|key_bindings
expr_stmt|;
name|nb
operator|=
sizeof|sizeof
argument_list|(
name|KeySym
argument_list|)
operator|*
name|nm
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|p
operator|=
operator|(
expr|struct
name|_XKeytrans
operator|*
operator|)
name|Xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_XKeytrans
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
operator|(
name|p
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nbytes
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|nbytes
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
operator|(
name|p
operator|->
name|modifiers
operator|=
operator|(
name|KeySym
operator|*
operator|)
name|Xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nb
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|nb
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|string
condition|)
name|Xfree
argument_list|(
name|p
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|modifiers
condition|)
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|modifiers
argument_list|)
expr_stmt|;
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return;
block|}
name|dpy
operator|->
name|key_bindings
operator|=
name|p
expr_stmt|;
name|dpy
operator|->
name|free_funcs
operator|->
name|key_bindings
operator|=
name|_XFreeKeyBindings
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
comment|/* chain onto list */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
name|p
operator|->
name|string
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|p
operator|->
name|len
operator|=
name|nbytes
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mlist
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|modifiers
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|keysym
expr_stmt|;
name|p
operator|->
name|mlen
operator|=
name|nm
expr_stmt|;
name|ComputeMaskFromKeytrans
argument_list|(
name|dpy
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * given a KeySym, returns the first keycode containing it, if any.  */
end_comment

begin_function
specifier|static
name|CARD8
name|FindKeyCode
parameter_list|(
name|dpy
parameter_list|,
name|code
parameter_list|)
specifier|register
name|Display
modifier|*
name|dpy
decl_stmt|;
specifier|register
name|KeySym
name|code
decl_stmt|;
block|{
specifier|register
name|KeySym
modifier|*
name|kmax
init|=
name|dpy
operator|->
name|keysyms
operator|+
operator|(
name|dpy
operator|->
name|max_keycode
operator|-
name|dpy
operator|->
name|min_keycode
operator|+
literal|1
operator|)
operator|*
name|dpy
operator|->
name|keysyms_per_keycode
decl_stmt|;
specifier|register
name|KeySym
modifier|*
name|k
init|=
name|dpy
operator|->
name|keysyms
decl_stmt|;
while|while
condition|(
name|k
operator|<
name|kmax
condition|)
block|{
if|if
condition|(
operator|*
name|k
operator|==
name|code
condition|)
return|return
operator|(
operator|(
operator|(
name|k
operator|-
name|dpy
operator|->
name|keysyms
operator|)
operator|/
name|dpy
operator|->
name|keysyms_per_keycode
operator|)
operator|+
name|dpy
operator|->
name|min_keycode
operator|)
return|;
name|k
operator|+=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * given a list of modifiers, computes the mask necessary for later matching.  * This routine must lookup the key in the Keymap and then search to see  * what modifier it is bound to, if any.  Sets the AnyModifier bit if it  * can't map some keysym to a modifier.  */
end_comment

begin_expr_stmt
specifier|static
name|ComputeMaskFromKeytrans
argument_list|(
argument|dpy
argument_list|,
argument|p
argument_list|)
name|Display
operator|*
name|dpy
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|_XKeytrans
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|CARD8
name|code
decl_stmt|;
specifier|register
name|XModifierKeymap
modifier|*
name|m
init|=
name|dpy
operator|->
name|modifiermap
decl_stmt|;
name|p
operator|->
name|state
operator|=
name|AnyModifier
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|mlen
condition|;
name|i
operator|++
control|)
block|{
comment|/* if not found, then not on current keyboard */
if|if
condition|(
operator|(
name|code
operator|=
name|FindKeyCode
argument_list|(
name|dpy
argument_list|,
name|p
operator|->
name|modifiers
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* code is now the keycode for the modifier you want */
block|{
specifier|register
name|int
name|j
init|=
name|m
operator|->
name|max_keypermod
operator|<<
literal|3
decl_stmt|;
while|while
condition|(
operator|(
operator|--
name|j
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|code
operator|!=
name|m
operator|->
name|modifiermap
index|[
name|j
index|]
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
return|return;
name|p
operator|->
name|state
operator||=
operator|(
literal|1
operator|<<
operator|(
name|j
operator|/
name|m
operator|->
name|max_keypermod
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|state
operator|&=
name|AllMods
expr_stmt|;
block|}
end_block

end_unit

