begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: XVisUtil.c,v 11.14 91/06/30 18:15:42 rws Exp $ */
end_comment

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1986	*/
end_comment

begin_comment
comment|/* Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_include
include|#
directive|include
file|"Xlibint.h"
end_include

begin_include
include|#
directive|include
file|"Xutil.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*  *	This procedure returns a list of visual information structures  *	that match the specified attributes given in the visual information   *	template.  *  *	If no visuals exist that match the specified attributes, a NULL is  *	returned.  *  *	The choices for visual_info_mask are:  *  *		VisualNoMask  *		VisualIDMask  *		VisualScreenMask  *		VisualDepthMask  *		VisualClassMask  *		VisualRedMaskMask  *		VisualGreenMaskMask  *		VisualBlueMaskMask  *		VisualColormapSizeMask  *		VisualBitsPerRGBMask  *		VisualAllMask  */
end_comment

begin_function
name|XVisualInfo
modifier|*
name|XGetVisualInfo
parameter_list|(
name|dpy
parameter_list|,
name|visual_info_mask
parameter_list|,
name|visual_info_template
parameter_list|,
name|nitems
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
specifier|register
name|long
name|visual_info_mask
decl_stmt|;
specifier|register
name|XVisualInfo
modifier|*
name|visual_info_template
decl_stmt|;
name|int
modifier|*
name|nitems
decl_stmt|;
comment|/* RETURN */
block|{
specifier|register
name|Visual
modifier|*
name|vp
decl_stmt|;
specifier|register
name|Depth
modifier|*
name|dp
decl_stmt|;
name|Screen
modifier|*
name|sp
decl_stmt|;
name|int
name|ii
decl_stmt|,
name|screen_s
decl_stmt|,
name|screen_e
decl_stmt|,
name|total
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|XVisualInfo
modifier|*
name|vip
decl_stmt|,
modifier|*
name|vip_base
decl_stmt|;
comment|/* NOTE: NO HIGH PERFORMING CODE TO BE FOUND HERE */
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
comment|/* ALLOCATE THE ORIGINAL BUFFER; REALLOCED LATER IF OVERFLOW OCCURS;      FREED AT END IF NO VISUALS ARE FOUND */
name|count
operator|=
literal|0
expr_stmt|;
name|total
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vip_base
operator|=
name|vip
operator|=
operator|(
name|XVisualInfo
operator|*
operator|)
name|Xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|XVisualInfo
argument_list|)
operator|*
name|total
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return
operator|(
name|XVisualInfo
operator|*
operator|)
name|NULL
return|;
block|}
comment|/* DETERMINE IF WE DO ALL SCREENS OR ONLY ONE */
name|screen_s
operator|=
literal|0
expr_stmt|;
name|screen_e
operator|=
name|dpy
operator|->
name|nscreens
expr_stmt|;
if|if
condition|(
name|visual_info_mask
operator|&
name|VisualScreenMask
condition|)
block|{
name|screen_s
operator|=
name|visual_info_template
operator|->
name|screen
expr_stmt|;
if|if
condition|(
name|screen_s
operator|<
literal|0
operator|||
name|screen_s
operator|>=
name|screen_e
condition|)
name|screen_e
operator|=
name|screen_s
expr_stmt|;
else|else
name|screen_e
operator|=
name|screen_s
operator|+
literal|1
expr_stmt|;
block|}
comment|/* LOOP THROUGH SCREENS */
for|for
control|(
name|ii
operator|=
name|screen_s
init|;
name|ii
operator|<
name|screen_e
condition|;
name|ii
operator|++
control|)
block|{
name|sp
operator|=
operator|(
name|Screen
operator|*
operator|)
operator|(
operator|&
name|dpy
operator|->
name|screens
index|[
name|ii
index|]
operator|)
expr_stmt|;
comment|/* LOOP THROUGH DEPTHS */
for|for
control|(
name|dp
operator|=
name|sp
operator|->
name|depths
init|;
name|dp
operator|<
operator|(
name|sp
operator|->
name|depths
operator|+
name|sp
operator|->
name|ndepths
operator|)
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|visual_info_mask
operator|&
name|VisualDepthMask
operator|)
operator|&&
operator|(
name|dp
operator|->
name|depth
operator|!=
name|visual_info_template
operator|->
name|depth
operator|)
condition|)
continue|continue;
comment|/* LOOP THROUGH VISUALS */
if|if
condition|(
name|dp
operator|->
name|visuals
condition|)
block|{
for|for
control|(
name|vp
operator|=
name|dp
operator|->
name|visuals
init|;
name|vp
operator|<
operator|(
name|dp
operator|->
name|visuals
operator|+
name|dp
operator|->
name|nvisuals
operator|)
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|visual_info_mask
operator|&
name|VisualIDMask
operator|)
operator|&&
operator|(
name|vp
operator|->
name|visualid
operator|!=
name|visual_info_template
operator|->
name|visualid
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|visual_info_mask
operator|&
name|VisualClassMask
operator|)
operator|&&
operator|(
name|vp
operator|->
name|class
operator|!=
name|visual_info_template
operator|->
name|class
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|visual_info_mask
operator|&
name|VisualRedMaskMask
operator|)
operator|&&
operator|(
name|vp
operator|->
name|red_mask
operator|!=
name|visual_info_template
operator|->
name|red_mask
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|visual_info_mask
operator|&
name|VisualGreenMaskMask
operator|)
operator|&&
operator|(
name|vp
operator|->
name|green_mask
operator|!=
name|visual_info_template
operator|->
name|green_mask
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|visual_info_mask
operator|&
name|VisualBlueMaskMask
operator|)
operator|&&
operator|(
name|vp
operator|->
name|blue_mask
operator|!=
name|visual_info_template
operator|->
name|blue_mask
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|visual_info_mask
operator|&
name|VisualColormapSizeMask
operator|)
operator|&&
operator|(
name|vp
operator|->
name|map_entries
operator|!=
name|visual_info_template
operator|->
name|colormap_size
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|visual_info_mask
operator|&
name|VisualBitsPerRGBMask
operator|)
operator|&&
operator|(
name|vp
operator|->
name|bits_per_rgb
operator|!=
name|visual_info_template
operator|->
name|bits_per_rgb
operator|)
condition|)
continue|continue;
comment|/* YEA!!! WE FOUND A GOOD ONE */
if|if
condition|(
name|count
operator|+
literal|1
operator|>
name|total
condition|)
block|{
name|XVisualInfo
modifier|*
name|old_vip_base
init|=
name|vip_base
decl_stmt|;
name|total
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vip_base
operator|=
operator|(
name|XVisualInfo
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vip_base
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|XVisualInfo
argument_list|)
operator|*
name|total
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old_vip_base
argument_list|)
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return
operator|(
name|XVisualInfo
operator|*
operator|)
name|NULL
return|;
block|}
name|vip
operator|=
operator|&
name|vip_base
index|[
name|count
index|]
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|vip
operator|->
name|visual
operator|=
name|vp
expr_stmt|;
name|vip
operator|->
name|visualid
operator|=
name|vp
operator|->
name|visualid
expr_stmt|;
name|vip
operator|->
name|screen
operator|=
name|ii
expr_stmt|;
name|vip
operator|->
name|depth
operator|=
name|dp
operator|->
name|depth
expr_stmt|;
name|vip
operator|->
name|class
operator|=
name|vp
operator|->
name|class
expr_stmt|;
name|vip
operator|->
name|red_mask
operator|=
name|vp
operator|->
name|red_mask
expr_stmt|;
name|vip
operator|->
name|green_mask
operator|=
name|vp
operator|->
name|green_mask
expr_stmt|;
name|vip
operator|->
name|blue_mask
operator|=
name|vp
operator|->
name|blue_mask
expr_stmt|;
name|vip
operator|->
name|colormap_size
operator|=
name|vp
operator|->
name|map_entries
expr_stmt|;
name|vip
operator|->
name|bits_per_rgb
operator|=
name|vp
operator|->
name|bits_per_rgb
expr_stmt|;
name|vip
operator|++
expr_stmt|;
block|}
comment|/* END OF LOOP ON VISUALS */
block|}
comment|/* END OF IF THERE ARE ANY VISUALS AT THIS DEPTH */
block|}
comment|/* END OF LOOP ON DEPTHS */
block|}
comment|/* END OF LOOP ON SCREENS */
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
operator|*
name|nitems
operator|=
name|count
expr_stmt|;
return|return
name|vip_base
return|;
block|}
name|Xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vip_base
argument_list|)
expr_stmt|;
operator|*
name|nitems
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	This procedure will return the visual information for a visual   *      that matches the specified depth and class for a screen.  Since   *	multiple visuals may exist that match the specified depth and   *	class, which visual chosen is undefined.  *  *	If a visual is found, True is returned as the function value,  *	otherwise False is returned.  */
end_comment

begin_function
name|Status
name|XMatchVisualInfo
parameter_list|(
name|dpy
parameter_list|,
name|screen
parameter_list|,
name|depth
parameter_list|,
name|class
parameter_list|,
name|visual_info
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
name|int
name|screen
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|class
decl_stmt|;
name|XVisualInfo
modifier|*
name|visual_info
decl_stmt|;
comment|/* RETURNED */
block|{
name|Visual
modifier|*
name|vp
decl_stmt|;
name|Depth
modifier|*
name|dp
decl_stmt|;
name|Screen
modifier|*
name|sp
decl_stmt|;
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|;
if|if
condition|(
name|screen
operator|<
literal|0
operator|||
name|screen
operator|>=
name|dpy
operator|->
name|nscreens
condition|)
return|return
name|False
return|;
name|LockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|(
name|Screen
operator|*
operator|)
operator|(
operator|&
name|dpy
operator|->
name|screens
index|[
name|screen
index|]
operator|)
expr_stmt|;
name|dp
operator|=
name|sp
operator|->
name|depths
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|sp
operator|->
name|ndepths
condition|;
name|ii
operator|++
control|)
block|{
comment|/* LOOK THROUGH DEPTHS FOR THE WANTED DEPTH */
if|if
condition|(
name|dp
operator|->
name|depth
operator|==
name|depth
condition|)
block|{
name|vp
operator|=
name|dp
operator|->
name|visuals
expr_stmt|;
comment|/* LOOK THROUGH VISUALS FOR THE WANTED CLASS */
comment|/* if nvisuals == 0 then vp will be NULL */
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|dp
operator|->
name|nvisuals
condition|;
name|jj
operator|++
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|class
operator|==
name|class
condition|)
block|{
name|visual_info
operator|->
name|visual
operator|=
name|vp
expr_stmt|;
name|visual_info
operator|->
name|visualid
operator|=
name|vp
operator|->
name|visualid
expr_stmt|;
name|visual_info
operator|->
name|screen
operator|=
name|screen
expr_stmt|;
name|visual_info
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|visual_info
operator|->
name|class
operator|=
name|vp
operator|->
name|class
expr_stmt|;
name|visual_info
operator|->
name|red_mask
operator|=
name|vp
operator|->
name|red_mask
expr_stmt|;
name|visual_info
operator|->
name|green_mask
operator|=
name|vp
operator|->
name|green_mask
expr_stmt|;
name|visual_info
operator|->
name|blue_mask
operator|=
name|vp
operator|->
name|blue_mask
expr_stmt|;
name|visual_info
operator|->
name|colormap_size
operator|=
name|vp
operator|->
name|map_entries
expr_stmt|;
name|visual_info
operator|->
name|bits_per_rgb
operator|=
name|vp
operator|->
name|bits_per_rgb
expr_stmt|;
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
name|vp
operator|++
expr_stmt|;
block|}
block|}
name|dp
operator|++
expr_stmt|;
block|}
name|UnlockDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
end_function

end_unit

