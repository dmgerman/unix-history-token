begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C-compiler utilities for types and variables storage layout    Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Data type for the expressions representing sizes of data types.    It is the first integer type laid out.    In C, this is int.  */
end_comment

begin_decl_stmt
name|tree
name|sizetype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An integer constant with value 0 whose type is sizetype.  */
end_comment

begin_decl_stmt
name|tree
name|size_zero_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An integer constant with value 1 whose type is sizetype.  */
end_comment

begin_decl_stmt
name|tree
name|size_one_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, this is an upper limit on alignment of structure fields.    The value is measured in bits.  */
end_comment

begin_decl_stmt
name|int
name|maximum_field_alignment
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GET_MODE_ALIGNMENT
parameter_list|(
name|MODE
parameter_list|)
define|\
value|MIN (BIGGEST_ALIGNMENT, 	   \        MAX (1, (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT)))
end_define

begin_escape
end_escape

begin_comment
comment|/* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pending_sizes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means cannot safely call expand_expr now,    so put variable sizes onto `pending_sizes' instead.  */
end_comment

begin_decl_stmt
name|int
name|immediate_size_expand
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|get_pending_sizes
parameter_list|()
block|{
name|tree
name|chain
init|=
name|pending_sizes
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Put each SAVE_EXPR into the current function.  */
for|for
control|(
name|t
operator|=
name|chain
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|SAVE_EXPR_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|pending_sizes
operator|=
literal|0
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Given a size SIZE that isn't constant, return a SAVE_EXPR    to serve as the actual size-expression for a type or decl.  */
end_comment

begin_function
name|tree
name|variable_size
parameter_list|(
name|size
parameter_list|)
name|tree
name|size
decl_stmt|;
block|{
name|size
operator|=
name|save_expr
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_bindings_p
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"variable-size type declared outside of any function"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|immediate_size_expand
condition|)
name|expand_expr
argument_list|(
name|size
argument_list|,
name|NULL_PTR
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pending_sizes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|size
argument_list|,
name|pending_sizes
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_FIXED_MODE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|MAX_FIXED_MODE_SIZE
value|GET_MODE_BITSIZE (DImode)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the machine mode to use for a nonscalar of SIZE bits.    The mode must be in class CLASS, and have exactly that many bits.    If LIMIT is nonzero, modes of wider than MAX_FIXED_MODE_SIZE will not    be used.  */
end_comment

begin_function
name|enum
name|machine_mode
name|mode_for_size
parameter_list|(
name|size
parameter_list|,
name|class
parameter_list|,
name|limit
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
name|enum
name|mode_class
name|class
decl_stmt|;
name|int
name|limit
decl_stmt|;
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|limit
operator|&&
name|size
operator|>
name|MAX_FIXED_MODE_SIZE
condition|)
return|return
name|BLKmode
return|;
comment|/* Get the last mode which has this size, in the specified class.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|class
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|size
condition|)
return|return
name|mode
return|;
return|return
name|BLKmode
return|;
block|}
end_function

begin_comment
comment|/* Return the value of VALUE, rounded up to a multiple of DIVISOR.  */
end_comment

begin_function
name|tree
name|round_up
parameter_list|(
name|value
parameter_list|,
name|divisor
parameter_list|)
name|tree
name|value
decl_stmt|;
name|int
name|divisor
decl_stmt|;
block|{
return|return
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|value
argument_list|,
name|size_int
argument_list|(
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|divisor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the size, mode and alignment of a ..._DECL node.    TYPE_DECL does need this for C++.    Note that LABEL_DECL and CONST_DECL nodes do not need this,    and FUNCTION_DECL nodes have them set up in a special (and simple) way.    Don't call layout_decl for them.     KNOWN_ALIGN is the amount of alignment we can assume this    decl has with no special effort.  It is relevant only for FIELD_DECLs    and depends on the previous fields.    All that matters about KNOWN_ALIGN is which powers of 2 divide it.    If KNOWN_ALIGN is 0, it means, "as much alignment as you like":    the record will be aligned to suit.  */
end_comment

begin_function
name|void
name|layout_decl
parameter_list|(
name|decl
parameter_list|,
name|known_align
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|unsigned
name|known_align
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|spec_size
init|=
name|DECL_FIELD_SIZE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CONST_DECL
condition|)
return|return;
if|if
condition|(
name|code
operator|!=
name|VAR_DECL
operator|&&
name|code
operator|!=
name|PARM_DECL
operator|&&
name|code
operator|!=
name|RESULT_DECL
operator|&&
name|code
operator|!=
name|FIELD_DECL
operator|&&
name|code
operator|!=
name|TYPE_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|type
operator|=
name|void_type_node
expr_stmt|;
name|spec_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Usually the size and mode come from the data type without change.  */
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|FIELD_DECL
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* This is a bit-field.  We don't know how to handle 	 them except for integers and enums, and front end should 	 never generate them otherwise.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|spec_size
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Size is specified number of bits.  */
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|size_int
argument_list|(
name|spec_size
argument_list|)
expr_stmt|;
block|}
comment|/* Force alignment required for the data type.      But if the decl itself wants greater alignment, don't override that.      Likewise, if the decl is packed, don't override it.  */
elseif|else
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|DECL_PACKED
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* See if we can use an ordinary integer mode for a bit-field.  */
comment|/* Conditions are: a fixed size that is correct for another mode      and occupying a complete byte or bytes on proper boundary.  */
if|if
condition|(
name|code
operator|==
name|FIELD_DECL
condition|)
block|{
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
condition|?
name|type
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|maximum_field_alignment
operator|!=
literal|0
condition|)
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MIN
argument_list|(
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|,
name|maximum_field_alignment
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|enum
name|machine_mode
name|xmode
init|=
name|mode_for_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|xmode
operator|!=
name|BLKmode
operator|&&
name|known_align
operator|%
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|xmode
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|xmode
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|xmode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This no longer needs to be accessed as a bit field.  */
name|DECL_BIT_FIELD
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Evaluate nonconstant size only once, either now or as soon as safe.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|variable_size
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lay out a RECORD_TYPE type (a C struct).    This means laying out the fields, determining their positions,    and computing the overall size and required alignment of the record.    Note that if you set the TYPE_ALIGN before calling this    then the struct is aligned to at least that boundary.     If the type has basetypes, you must call layout_basetypes    before calling this function.     The return value is a list of static members of the record.    They still need to be laid out.  */
end_comment

begin_function
specifier|static
name|tree
name|layout_record
parameter_list|(
name|rec
parameter_list|)
name|tree
name|rec
decl_stmt|;
block|{
specifier|register
name|tree
name|field
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|unsigned
name|record_align
init|=
name|MAX
argument_list|(
name|STRUCTURE_SIZE_BOUNDARY
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|unsigned
name|record_align
init|=
name|MAX
argument_list|(
name|BITS_PER_UNIT
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* These must be laid out *after* the record is.  */
name|tree
name|pending_statics
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Record size so far is CONST_SIZE + VAR_SIZE bits,      where CONST_SIZE is an integer      and VAR_SIZE is a tree expression.      If VAR_SIZE is null, the size is just CONST_SIZE.      Naturally we try to avoid using VAR_SIZE.  */
specifier|register
name|int
name|const_size
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|var_size
init|=
literal|0
decl_stmt|;
comment|/* Once we start using VAR_SIZE, this is the maximum alignment      that we know VAR_SIZE has.  */
specifier|register
name|int
name|var_align
init|=
name|BITS_PER_UNIT
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|rec
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
specifier|register
name|int
name|desired_align
decl_stmt|;
comment|/* If FIELD is static, then treat it like a separate variable, 	 not really like a structure field. 	 If it is a FUNCTION_DECL, it's a method. 	 In both cases, all we do is lay out the decl, 	 and we do it *after* the record is laid out.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|pending_statics
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|field
argument_list|,
name|pending_statics
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Enumerators and enum types which are local to this class need not 	 be laid out.  Likewise for initialized constant fields.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
comment|/* Lay out the field so we know what alignment it needs. 	 For KNOWN_ALIGN, pass the number of bits from start of record 	 or some divisor of it.  */
comment|/* For a packed field, use the alignment as specified, 	 disregarding what the type would want.  */
if|if
condition|(
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
name|desired_align
operator|=
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|field
argument_list|,
name|var_size
condition|?
name|var_align
else|:
name|const_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
name|desired_align
operator|=
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* Some targets (i.e. VMS) limit struct field alignment 	 to a lower boundary than alignment of variables.  */
ifdef|#
directive|ifdef
name|BIGGEST_FIELD_ALIGNMENT
name|desired_align
operator|=
name|MIN
argument_list|(
name|desired_align
argument_list|,
name|BIGGEST_FIELD_ALIGNMENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record must have at least as much alignment as any field. 	 Otherwise, the alignment of the field within the record 	 is meaningless.  */
ifndef|#
directive|ifndef
name|PCC_BITFIELD_TYPE_MATTERS
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
operator|&&
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* For these machines, a zero-length field does not 	     affect the alignment of the structure as a whole. 	     It does, however, affect the alignment of the next field 	     within the structure.  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
condition|)
name|desired_align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A named bit field of declared type `int' 	     forces the entire structure to have `int' alignment.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|type_align
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|maximum_field_alignment
operator|!=
literal|0
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|maximum_field_alignment
argument_list|)
expr_stmt|;
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|type_align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|record_align
operator|=
name|MAX
argument_list|(
name|record_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Does this field automatically have alignment it needs 	 by virtue of the fields that precede it and the record's 	 own alignment?  */
if|if
condition|(
name|const_size
operator|%
name|desired_align
operator|!=
literal|0
operator|||
operator|(
name|var_align
operator|%
name|desired_align
operator|!=
literal|0
operator|&&
name|var_size
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* No, we need to skip space before this field. 	     Bump the cumulative size to multiple of field alignment.  */
if|if
condition|(
name|var_size
operator|==
literal|0
operator|||
name|var_align
operator|%
name|desired_align
operator|==
literal|0
condition|)
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|desired_align
argument_list|)
operator|*
name|desired_align
expr_stmt|;
else|else
block|{
if|if
condition|(
name|const_size
operator|>
literal|0
condition|)
name|var_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|var_size
argument_list|,
name|size_int
argument_list|(
name|const_size
argument_list|)
argument_list|)
expr_stmt|;
name|const_size
operator|=
literal|0
expr_stmt|;
name|var_size
operator|=
name|round_up
argument_list|(
name|var_size
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
name|var_align
operator|=
name|MIN
argument_list|(
name|var_align
argument_list|,
name|desired_align
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|type_align
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|dsize
init|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|field_size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|dsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|maximum_field_alignment
operator|!=
literal|0
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|maximum_field_alignment
argument_list|)
expr_stmt|;
comment|/* A bit field may not span the unit of alignment of its type. 	     Advance to next boundary if necessary.  */
comment|/* ??? There is some uncertainty here as to what 	     should be done if type_align is less than the width of the type. 	     That can happen because the width exceeds BIGGEST_ALIGNMENT 	     or because it exceeds maximum_field_alignment.  */
if|if
condition|(
name|const_size
operator|/
name|type_align
operator|!=
operator|(
name|const_size
operator|+
name|field_size
operator|-
literal|1
operator|)
operator|/
name|type_align
condition|)
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|type_align
argument_list|)
operator|*
name|type_align
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* No existing machine description uses this parameter.    So I have made it in this aspect identical to PCC_BITFIELD_TYPE_MATTERS.  */
ifdef|#
directive|ifdef
name|BITFIELD_NBYTES_LIMITED
if|if
condition|(
name|BITFIELD_NBYTES_LIMITED
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|DECL_PACKED
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|type_align
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|dsize
init|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|field_size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|dsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|maximum_field_alignment
operator|!=
literal|0
condition|)
name|type_align
operator|=
name|MIN
argument_list|(
name|type_align
argument_list|,
name|maximum_field_alignment
argument_list|)
expr_stmt|;
comment|/* A bit field may not span the unit of alignment of its type. 	     Advance to next boundary if necessary.  */
if|if
condition|(
name|const_size
operator|/
name|type_align
operator|!=
operator|(
name|const_size
operator|+
name|field_size
operator|-
literal|1
operator|)
operator|/
name|type_align
condition|)
name|const_size
operator|=
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|type_align
argument_list|)
operator|*
name|type_align
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Size so far becomes the position of this field.  */
if|if
condition|(
name|var_size
operator|&&
name|const_size
condition|)
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|var_size
argument_list|,
name|size_int
argument_list|(
name|const_size
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var_size
condition|)
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
operator|=
name|var_size
expr_stmt|;
else|else
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
operator|=
name|size_int
argument_list|(
name|const_size
argument_list|)
expr_stmt|;
comment|/* If this field is an anonymous union, 	 give each union-member the same position as the union has.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|uelt
init|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|uelt
condition|;
name|uelt
operator|=
name|TREE_CHAIN
argument_list|(
name|uelt
argument_list|)
control|)
block|{
name|DECL_FIELD_CONTEXT
argument_list|(
name|uelt
argument_list|)
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|DECL_FIELD_BITPOS
argument_list|(
name|uelt
argument_list|)
operator|=
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now add size of this field to the size of the record.  */
block|{
specifier|register
name|tree
name|dsize
init|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|/* This can happen when we have an invalid nested struct definition, 	   such as struct j { struct j { int i; } }.  The error message is 	   printed in finish_struct.  */
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
comment|/* Do nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dsize
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|const_size
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|dsize
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|var_size
operator|==
literal|0
condition|)
name|var_size
operator|=
name|dsize
expr_stmt|;
else|else
name|var_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|var_size
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Work out the total size and alignment of the record      as one expression and store in the record type.      Round it up to a multiple of the record's alignment.  */
if|if
condition|(
name|var_size
operator|==
literal|0
condition|)
block|{
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|size_int
argument_list|(
name|const_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|const_size
condition|)
name|var_size
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|var_size
argument_list|,
name|size_int
argument_list|(
name|const_size
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|var_size
expr_stmt|;
block|}
comment|/* Determine the desired alignment.  */
ifdef|#
directive|ifdef
name|ROUND_TYPE_ALIGN
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|rec
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|,
name|record_align
argument_list|)
expr_stmt|;
else|#
directive|else
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|,
name|record_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ROUND_TYPE_SIZE
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|ROUND_TYPE_SIZE
argument_list|(
name|rec
argument_list|,
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Round the size up to be a multiple of the required alignment */
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|round_up
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|pending_statics
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lay out a UNION_TYPE type.    Lay out all the fields, set their positions to zero,    and compute the size and alignment of the union (maximum of any field).    Note that if you set the TYPE_ALIGN before calling this    then the union align is aligned to at least that boundary.  */
end_comment

begin_function
specifier|static
name|void
name|layout_union
parameter_list|(
name|rec
parameter_list|)
name|tree
name|rec
decl_stmt|;
block|{
specifier|register
name|tree
name|field
decl_stmt|;
ifdef|#
directive|ifdef
name|STRUCTURE_SIZE_BOUNDARY
name|unsigned
name|union_align
init|=
name|STRUCTURE_SIZE_BOUNDARY
decl_stmt|;
else|#
directive|else
name|unsigned
name|union_align
init|=
name|BITS_PER_UNIT
decl_stmt|;
endif|#
directive|endif
comment|/* The size of the union, based on the fields scanned so far,      is max (CONST_SIZE, VAR_SIZE).      VAR_SIZE may be null; then CONST_SIZE by itself is the size.  */
specifier|register
name|int
name|const_size
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|var_size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|rec
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
comment|/* Enums which are local to this class need not be laid out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TYPE_DECL
condition|)
continue|continue;
name|layout_decl
argument_list|(
name|field
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
operator|=
name|size_int
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Union must be at least as aligned as any field requires.  */
name|union_align
operator|=
name|MAX
argument_list|(
name|union_align
argument_list|,
name|DECL_ALIGN
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
comment|/* On the m88000, a bit field of declare type `int' 	 forces the entire union to have `int' alignment.  */
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
condition|)
name|union_align
operator|=
name|MAX
argument_list|(
name|union_align
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set union_size to max (decl_size, union_size). 	 There are more and less general ways to do this. 	 Use only CONST_SIZE unless forced to use VAR_SIZE.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|const_size
operator|=
name|MAX
argument_list|(
name|const_size
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var_size
operator|==
literal|0
condition|)
name|var_size
operator|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
name|var_size
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|var_size
argument_list|,
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the ultimate size of the union (in bytes).  */
if|if
condition|(
name|NULL
operator|==
name|var_size
condition|)
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|size_int
argument_list|(
name|CEIL
argument_list|(
name|const_size
argument_list|,
name|BITS_PER_UNIT
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|const_size
operator|==
literal|0
condition|)
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|var_size
expr_stmt|;
else|else
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|size_binop
argument_list|(
name|MAX_EXPR
argument_list|,
name|var_size
argument_list|,
name|round_up
argument_list|(
name|size_int
argument_list|(
name|const_size
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the desired alignment.  */
ifdef|#
directive|ifdef
name|ROUND_TYPE_ALIGN
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|rec
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|,
name|union_align
argument_list|)
expr_stmt|;
else|#
directive|else
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|,
name|union_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ROUND_TYPE_SIZE
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|ROUND_TYPE_SIZE
argument_list|(
name|rec
argument_list|,
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Round the size up to be a multiple of the required alignment */
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
operator|=
name|round_up
argument_list|(
name|TYPE_SIZE
argument_list|(
name|rec
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the mode, size, and alignment for TYPE.    For an array type, calculate the element separation as well.    Record TYPE on the chain of permanent or temporary types    so that dbxout will find out about it.     TYPE_SIZE of a type is nonzero if the type has been laid out already.    layout_type does nothing on such a type.     If the type is incomplete, its TYPE_SIZE remains zero.  */
end_comment

begin_function
name|void
name|layout_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|old
decl_stmt|;
name|tree
name|pending_statics
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Do nothing if type has been laid out before.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* Make sure all nodes we allocate are not momentary;      they must last past the current statement.  */
name|old
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* If we are processing a permanent type, make nodes permanent.      If processing a temporary type, make it saveable, since the      type node itself is.  This is important if the function is inline,      since its decls will get copied later.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|allocation_temporary_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
else|else
name|saveable_allocation
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|LANG_TYPE
case|:
comment|/* This kind of type is the responsibility 	 of the languge-specific code.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We pass 0 for the last arg of mode_for_size because otherwise 	 on the Apollo using long long causes a crash. 	 It seems better to use integer modes than to try to support 	 integer types with BLKmode.  */
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|?
name|MODE_COMPLEX_INT
else|:
name|MODE_COMPLEX_FLOAT
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|Pmode
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
literal|2
operator|*
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|Pmode
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
block|{
specifier|register
name|tree
name|index
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|build_pointer_type
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|/* We need to know both bounds in order to compute the size.  */
if|if
condition|(
name|index
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|index
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|index
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|tree
name|length
init|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|size_one_node
argument_list|,
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|index
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|length
argument_list|,
name|TYPE_SIZE
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now round the alignment and size, 	   using machine-dependent criteria if any.  */
ifdef|#
directive|ifdef
name|ROUND_TYPE_ALIGN
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|ROUND_TYPE_ALIGN
argument_list|(
name|type
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|element
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|#
directive|else
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|element
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ROUND_TYPE_SIZE
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|ROUND_TYPE_SIZE
argument_list|(
name|type
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
comment|/* BLKmode elements force BLKmode aggregate; 	       else extract/store fields may lose.  */
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|BLKmode
operator|||
name|TYPE_NO_FORCE_BLK
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|<
name|BIGGEST_ALIGNMENT
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|<
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
name|TYPE_NO_FORCE_BLK
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|RECORD_TYPE
case|:
name|pending_statics
operator|=
name|layout_record
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* A record which has any BLKmode members must itself be BLKmode; 	     it can't go in a register. 	     Unless the member is BLKmode only because it isn't aligned.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|int
name|bitpos
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|!
name|TYPE_NO_FORCE_BLK
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
goto|goto
name|record_lose
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
goto|goto
name|record_lose
goto|;
name|bitpos
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Must be BLKmode if any field crosses a word boundary, 		 since extract_bit_field can't handle that in registers.  */
if|if
condition|(
name|bitpos
operator|/
name|BITS_PER_WORD
operator|!=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|+
name|bitpos
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
operator|)
comment|/* But there is no problem if the field is entire words.  */
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|%
name|BITS_PER_WORD
operator|==
literal|0
condition|)
goto|goto
name|record_lose
goto|;
block|}
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If structure's known alignment is less than 	     what the scalar mode would need, and it matters, 	     then stick with BLKmode.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
operator|!
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|BIGGEST_ALIGNMENT
operator|||
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
comment|/* If this is the only reason this type is BLKmode, 		   then don't force containing types to be BLKmode.  */
name|TYPE_NO_FORCE_BLK
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
block|}
name|record_lose
label|:
empty_stmt|;
block|}
comment|/* Lay out any static members.  This is done now 	 because their type may use the record's type.  */
while|while
condition|(
name|pending_statics
condition|)
block|{
name|layout_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|pending_statics
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending_statics
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_statics
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNION_TYPE
case|:
name|layout_union
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
comment|/* If structure's known alignment is less than 	     what the scalar mode would need, and it matters, 	     then stick with BLKmode.  */
operator|&&
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|BIGGEST_ALIGNMENT
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* A union which has any BLKmode members must itself be BLKmode; 	     it can't go in a register. 	     Unless the member is BLKmode only because it isn't aligned.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|BLKmode
operator|&&
operator|!
name|TYPE_NO_FORCE_BLK
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
goto|goto
name|union_lose
goto|;
block|}
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|mode_for_size
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|union_lose
label|:
empty_stmt|;
block|}
break|break;
comment|/* Pascal types */
case|case
name|BOOLEAN_TYPE
case|:
comment|/* store one byte/boolean for now. */
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|QImode
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR_TYPE
case|:
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|QImode
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_TYPE
case|:
comment|/* The size may vary in different languages, so the language front end 	 should fill in the size.  */
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|BIGGEST_ALIGNMENT
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* end switch */
comment|/* Normally, use the alignment corresponding to the mode chosen.      However, where strict alignment is not required, avoid      over-aligning structures, since most compilers do not do this      alignment.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|(
name|STRICT_ALIGNMENT
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
operator|)
condition|)
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Evaluate nonconstant size only once, either now or as soon as safe.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|variable_size
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Also layout any other variants of the type.  */
if|if
condition|(
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|variant
decl_stmt|;
comment|/* Record layout info of this variant.  */
name|tree
name|size
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Copy it into all variants.  */
for|for
control|(
name|variant
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|variant
condition|;
name|variant
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variant
argument_list|)
control|)
block|{
name|TYPE_SIZE
argument_list|(
name|variant
argument_list|)
operator|=
name|size
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|variant
argument_list|)
operator|=
name|align
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|variant
argument_list|)
operator|=
name|mode
expr_stmt|;
block|}
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
name|resume_momentary
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and return a type for signed integers of PRECISION bits.  */
end_comment

begin_function
name|tree
name|make_signed_type
parameter_list|(
name|precision
parameter_list|)
name|int
name|precision
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|precision
expr_stmt|;
comment|/* Create the extreme values based on the number of bits.  */
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|0
condition|?
literal|0
else|:
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
argument_list|,
operator|(
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|>
literal|0
condition|?
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|>
literal|0
condition|?
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|precision
operator|-
name|HOST_BITS_PER_INT
operator|-
literal|1
operator|)
operator|)
operator|)
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Give this type's extreme values this type as their type.  */
name|TREE_TYPE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* The first type made with this or `make_unsigned_type'      is the type for size values.  */
if|if
condition|(
name|sizetype
operator|==
literal|0
condition|)
block|{
name|sizetype
operator|=
name|type
expr_stmt|;
block|}
comment|/* Lay out the type: set its alignment, size, etc.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Create and return a type for unsigned integers of PRECISION bits.  */
end_comment

begin_function
name|tree
name|make_unsigned_type
parameter_list|(
name|precision
parameter_list|)
name|int
name|precision
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|precision
expr_stmt|;
comment|/* The first type made with this or `make_signed_type'      is the type for size values.  */
if|if
condition|(
name|sizetype
operator|==
literal|0
condition|)
block|{
name|sizetype
operator|=
name|type
expr_stmt|;
block|}
name|fixup_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Set the extreme values of TYPE based on its precision in bits,    the lay it out.  Used when make_signed_type won't do    because the tree code is not INTEGER_TYPE.    E.g. for Pascal, when the -fsigned-char option is given.  */
end_comment

begin_function
name|void
name|fixup_signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
operator|(
name|precision
operator|-
name|BITS_PER_WORD
operator|>
literal|0
condition|?
literal|0
else|:
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
argument_list|,
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|precision
operator|-
name|BITS_PER_WORD
operator|-
literal|1
operator|>
literal|0
condition|?
name|precision
operator|-
name|BITS_PER_WORD
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
operator|(
name|precision
operator|-
name|BITS_PER_WORD
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
literal|1
operator|<<
operator|(
name|precision
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|precision
operator|-
name|BITS_PER_WORD
operator|-
literal|1
operator|>
literal|0
condition|?
operator|(
literal|1
operator|<<
operator|(
name|precision
operator|-
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Lay out the type: set its alignment, size, etc.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the extreme values of TYPE based on its precision in bits,    the lay it out.  This is used both in `make_unsigned_type'    and for enumeral types.  */
end_comment

begin_function
name|void
name|fixup_unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|=
name|build_int_2
argument_list|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|precision
operator|)
operator|-
literal|1
argument_list|,
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|0
condition|?
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
operator|(
name|precision
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Lay out the type: set its alignment, size, etc.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the best machine mode to use when referencing a bit field of length    BITSIZE bits starting at BITPOS.     The underlying object is known to be aligned to a boundary of ALIGN bits.    If LARGEST_MODE is not VOIDmode, it means that we should not use a mode    larger than LARGEST_MODE (usually SImode).     If no mode meets all these conditions, we return VOIDmode.  Otherwise, if    VOLATILEP is true or SLOW_BYTE_ACCESS is false, we return the smallest    mode meeting these conditions.     Otherwise (VOLATILEP is false and SLOW_BYTE_ACCESS is true), we return    the largest mode (but a mode no wider than UNITS_PER_WORD) that meets    all the conditions.  */
end_comment

begin_function
name|enum
name|machine_mode
name|get_best_mode
parameter_list|(
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|align
parameter_list|,
name|largest_mode
parameter_list|,
name|volatilep
parameter_list|)
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|align
decl_stmt|;
name|enum
name|machine_mode
name|largest_mode
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* Find the narrowest integer mode that contains the bit field.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
block|{
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|/
name|unit
operator|==
operator|(
name|bitpos
operator|+
name|bitsize
operator|-
literal|1
operator|)
operator|/
name|unit
condition|)
break|break;
block|}
if|if
condition|(
name|mode
operator|==
name|MAX_MACHINE_MODE
comment|/* It is tempting to omit the following line 	 if STRICT_ALIGNMENT is true. 	 But that is incorrect, since if the bitfield uses part of 3 bytes 	 and we use a 4-byte mode, we could get a spurious segv 	 if the extra 4th byte is past the end of memory. 	 (Though at least one Unix compiler ignores this problem: 	 that on the Sequent 386 machine.  */
operator|||
name|MIN
argument_list|(
name|unit
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|>
name|align
operator|||
operator|(
name|largest_mode
operator|!=
name|VOIDmode
operator|&&
name|unit
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|largest_mode
argument_list|)
operator|)
condition|)
return|return
name|VOIDmode
return|;
if|if
condition|(
name|SLOW_BYTE_ACCESS
operator|&&
operator|!
name|volatilep
condition|)
block|{
name|enum
name|machine_mode
name|wide_mode
init|=
name|VOIDmode
decl_stmt|,
name|tmode
decl_stmt|;
for|for
control|(
name|tmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmode
operator|!=
name|VOIDmode
condition|;
name|tmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmode
argument_list|)
control|)
block|{
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|/
name|unit
operator|==
operator|(
name|bitpos
operator|+
name|bitsize
operator|-
literal|1
operator|)
operator|/
name|unit
operator|&&
name|unit
operator|<=
name|BITS_PER_WORD
operator|&&
name|unit
operator|<=
name|MIN
argument_list|(
name|align
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
operator|&&
operator|(
name|largest_mode
operator|==
name|VOIDmode
operator|||
name|unit
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|largest_mode
argument_list|)
operator|)
condition|)
name|wide_mode
operator|=
name|tmode
expr_stmt|;
block|}
if|if
condition|(
name|wide_mode
operator|!=
name|VOIDmode
condition|)
return|return
name|wide_mode
return|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save all variables describing the current status into the structure *P.    This is used before starting a nested function.  */
end_comment

begin_function
name|void
name|save_storage_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* Need not save, since always 0 and non0 (resp.) within a function.  */
block|p->pending_sizes = pending_sizes;   p->immediate_size_expand = immediate_size_expand;
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_comment
comment|/* Restore all variables describing the current status from the structure *P.    This is used after a nested function.  */
end_comment

begin_function
name|void
name|restore_storage_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|pending_sizes = p->pending_sizes;   immediate_size_expand = p->immediate_size_expand;
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

end_unit

