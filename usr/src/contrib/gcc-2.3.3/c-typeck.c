begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Build expressions with type checking for C compiler.    Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file is part of the C front end.    It contains routines to build C expressions given their operands,    including computing the types of the result, C-specific error checks,    and some optimization.     There are also routines to build RETURN_STMT nodes and CASE_STMT nodes,    and to process initializations in declarations (since they work    like a strange sort of assignment).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mark_addressable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_for_assignment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn_for_assignment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|function_types_compatible_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|type_lists_compatible_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|self_promoting_args_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|self_promoting_type_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_target_types
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_int_sum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pointer_diff
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_sequence
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|unary_complex_lvalue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|process_init_constructor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_arguments
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_spelling
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|digest_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pedantic_lvalue_warning
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|truthvalue_conversion
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|incomplete_type_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|readonly_warning
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Do `exp = require_complete_type (exp);' to make sure exp    does not have an incomplete type.  (That includes void types.)  */
end_comment

begin_function
name|tree
name|require_complete_type
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
decl_stmt|;
comment|/* First, detect a valid value with a complete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
name|value
return|;
name|incomplete_type_error
argument_list|(
name|value
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for invalid use of an incomplete type.    VALUE is the expression that was used (or 0 if that isn't known)    and TYPE is the type that was invalid.  */
end_comment

begin_function
name|void
name|incomplete_type_error
parameter_list|(
name|value
parameter_list|,
name|type
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* Avoid duplicate error message.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|)
condition|)
name|error
argument_list|(
literal|"`%s' has an incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|retry
label|:
comment|/* We must print an error message.  Be clever about what it says.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `struct %s'"
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `union %s'"
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|errmsg
operator|=
literal|"invalid use of undefined type `enum %s'"
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
name|error
argument_list|(
literal|"invalid use of void expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"invalid use of array with unspecified bounds"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
name|errmsg
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
name|error
argument_list|(
literal|"invalid use of incomplete typedef `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a variant of TYPE which has all the type qualifiers of LIKE    as well as those of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|qualify_type
parameter_list|(
name|type
parameter_list|,
name|like
parameter_list|)
name|tree
name|type
decl_stmt|,
name|like
decl_stmt|;
block|{
name|int
name|constflag
init|=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|like
argument_list|)
decl_stmt|;
name|int
name|volflag
init|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|like
argument_list|)
decl_stmt|;
return|return
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constflag
argument_list|,
name|volflag
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the common type of two types.    We assume that comptypes has already been done and returned 1;    if that isn't so, this may crash.  In particular, we assume that qualifiers    match.     This is the type for the result of most arithmetic operations    if the operands have the given two types.  */
end_comment

begin_function
name|tree
name|common_type
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
comment|/* Save time if the two types are the same.  */
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|t1
return|;
comment|/* If one type is nonsense, use the other.  */
if|if
condition|(
name|t1
operator|==
name|error_mark_node
condition|)
return|return
name|t2
return|;
if|if
condition|(
name|t2
operator|==
name|error_mark_node
condition|)
return|return
name|t1
return|;
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
comment|/* If only one is real, use it as the result.  */
if|if
condition|(
name|code1
operator|==
name|REAL_TYPE
operator|&&
name|code2
operator|!=
name|REAL_TYPE
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|code2
operator|==
name|REAL_TYPE
operator|&&
name|code1
operator|!=
name|REAL_TYPE
condition|)
return|return
name|t2
return|;
comment|/* Both real or both integers; use the one with greater precision.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
elseif|else
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Same precision.  Prefer longs to ints even when same size.  */
if|if
condition|(
name|t1
operator|==
name|long_unsigned_type_node
operator|||
name|t2
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|t1
operator|==
name|long_integer_type_node
operator|||
name|t2
operator|==
name|long_integer_type_node
condition|)
block|{
comment|/* But preserve unsignedness from the other type, 	     since long cannot hold all the values of an unsigned int.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|long_unsigned_type_node
return|;
return|return
name|long_integer_type_node
return|;
block|}
comment|/* Otherwise prefer the unsigned one.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
else|else
return|return
name|t2
return|;
case|case
name|POINTER_TYPE
case|:
comment|/* For two pointers, do this recursively on the target type, 	 and combine the qualifiers of the two types' targets.  */
comment|/* This code was turned off; I don't know why. 	 But ANSI C specifies doing this with the qualifiers. 	 So I turned it on again.  */
block|{
name|tree
name|target
init|=
name|common_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|constp
init|=
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_pointer_type
argument_list|(
name|c_build_type_variant
argument_list|(
name|target
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
block|return build_pointer_type (common_type (TREE_TYPE (t1), TREE_TYPE (t2)));
endif|#
directive|endif
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|elt
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|elt
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Merge the element types, and have a size if either arg has one.  */
return|return
name|build_array_type
argument_list|(
name|elt
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
condition|?
name|t1
else|:
name|t2
argument_list|)
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
comment|/* Function types: prefer the one that specified arg types. 	 If both do, merge the arg types.  Also merge the return types.  */
block|{
name|tree
name|valtype
init|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|p1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|newargs
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Save space: see if the result is identical to one of the args.  */
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
condition|)
return|return
name|t1
return|;
if|if
condition|(
name|valtype
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
condition|)
return|return
name|t2
return|;
comment|/* Simple way if one arg fails to specify argument types.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|t1
argument_list|)
argument_list|)
return|;
comment|/* If both args specify argument types, we must merge the two 	   lists, argument by argument.  */
name|len
operator|=
name|list_length
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|newargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|newargs
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|newargs
argument_list|)
expr_stmt|;
name|n
operator|=
name|newargs
expr_stmt|;
for|for
control|(
init|;
name|p1
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
operator|,
name|n
operator|=
name|TREE_CHAIN
argument_list|(
name|n
argument_list|)
control|)
block|{
comment|/* A null type means arg type is not specified. 	       Take whatever the other function type has.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
comment|/* Given  wait (union {union wait *u; int *i} *) 	       and  wait (union wait *), 	       prefer  union wait *  as type of parm.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"function types not truly compatible in ANSI C"
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"function types not truly compatible in ANSI C"
argument_list|)
expr_stmt|;
goto|goto
name|parm_done
goto|;
block|}
block|}
name|TREE_VALUE
argument_list|(
name|n
argument_list|)
operator|=
name|common_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|parm_done
label|:
empty_stmt|;
block|}
return|return
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|newargs
argument_list|)
return|;
block|}
default|default:
return|return
name|t1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment    or various other operations.  Return 2 if they are compatible    but a warning may be needed if you use them together.  */
end_comment

begin_function
name|int
name|comptypes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
init|=
name|type1
decl_stmt|;
specifier|register
name|tree
name|t2
init|=
name|type2
decl_stmt|;
comment|/* Suppress errors caused by previously reported errors.  */
if|if
condition|(
name|t1
operator|==
name|t2
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
comment|/* Treat an enum type as the unsigned integer type of the same width.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t1
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|t2
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
comment|/* Different classes of types can't be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Qualifiers must match.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_READONLY
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TYPE_VOLATILE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If generating auxiliary info, allow for two different type nodes which      have essentially the same definition.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
return|return
operator|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
condition|?
literal|1
else|:
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|FUNCTION_TYPE
case|:
return|return
name|function_types_compatible_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
block|{
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|tree
name|d1
init|=
name|TYPE_DOMAIN
argument_list|(
name|t1
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|TYPE_DOMAIN
argument_list|(
name|t2
argument_list|)
decl_stmt|;
comment|/* Target types must match incl. qualifiers.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
operator|&&
literal|0
operator|==
operator|(
name|val
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Sizes must match unless one is missing or variable.  */
if|if
condition|(
name|d1
operator|==
literal|0
operator|||
name|d2
operator|==
literal|0
operator|||
name|d1
operator|==
name|d2
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|val
return|;
return|return
operator|(
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|d2
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
name|val
else|:
literal|0
operator|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
return|return
name|maybe_objc_comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TTL and TTR are pointers to types that are equivalent,    ignoring their qualifiers.  */
end_comment

begin_function
specifier|static
name|int
name|comp_target_types
parameter_list|(
name|ttl
parameter_list|,
name|ttr
parameter_list|)
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
block|{
name|int
name|val
init|=
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"types are not quite compatible"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `comptypes'.  */
end_comment

begin_comment
comment|/* Return 1 if two function types F1 and F2 are compatible.    If either type specifies no argument types,    the other must specify a fixed number of self-promoting arg types.    Otherwise, if one type specifies only the number of arguments,     the other must specify that number of self-promoting arg types.    Otherwise, the argument types must match.  */
end_comment

begin_function
specifier|static
name|int
name|function_types_compatible_p
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
name|tree
name|f1
decl_stmt|,
name|f2
decl_stmt|;
block|{
name|tree
name|args1
decl_stmt|,
name|args2
decl_stmt|;
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|val1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
operator|||
operator|(
name|val
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|args1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|f1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|f2
argument_list|)
expr_stmt|;
comment|/* An unspecified parmlist matches any specified parmlist      whose argument types don't need default promotions.  */
if|if
condition|(
name|args1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_args_p
argument_list|(
name|args2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If one of these types comes from a non-prototype fn definition, 	 compare that with the other type's arglist. 	 If they don't match, ask for a warning (but no error).  */
if|if
condition|(
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f1
argument_list|)
operator|&&
literal|1
operator|!=
name|type_lists_compatible_p
argument_list|(
name|args2
argument_list|,
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f1
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|2
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|args2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_args_p
argument_list|(
name|args1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f2
argument_list|)
operator|&&
literal|1
operator|!=
name|type_lists_compatible_p
argument_list|(
name|args1
argument_list|,
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|f2
argument_list|)
argument_list|)
condition|)
name|val
operator|=
literal|2
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* Both types have argument lists: compare them and propagate results.  */
name|val1
operator|=
name|type_lists_compatible_p
argument_list|(
name|args1
argument_list|,
name|args2
argument_list|)
expr_stmt|;
return|return
name|val1
operator|!=
literal|1
condition|?
name|val1
else|:
name|val
return|;
block|}
end_function

begin_comment
comment|/* Check two lists of types for compatibility,    returning 0 for incompatible, 1 for compatible,    or 2 for compatible with warning.  */
end_comment

begin_function
specifier|static
name|int
name|type_lists_compatible_p
parameter_list|(
name|args1
parameter_list|,
name|args2
parameter_list|)
name|tree
name|args1
decl_stmt|,
name|args2
decl_stmt|;
block|{
comment|/* 1 if no need for warning yet, 2 if warning cause has been seen.  */
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|newval
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|args1
operator|==
literal|0
operator|&&
name|args2
operator|==
literal|0
condition|)
return|return
name|val
return|;
comment|/* If one list is shorter than the other, 	 they fail to match.  */
if|if
condition|(
name|args1
operator|==
literal|0
operator|||
name|args2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* A null pointer instead of a type 	 means there is supposed to be an argument 	 but nothing is specified about what type it has. 	 So match anything that self-promotes.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|self_promoting_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|newval
operator|=
name|comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Allow  wait (union {union wait *u; int *i} *) 	     and  wait (union wait *)  to be compatible.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|memb
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|memb
decl_stmt|;
for|for
control|(
name|memb
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
argument_list|)
init|;
name|memb
condition|;
name|memb
operator|=
name|TREE_CHAIN
argument_list|(
name|memb
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|memb
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|memb
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* comptypes said ok, but record if it said to warn.  */
if|if
condition|(
name|newval
operator|>
name|val
condition|)
name|val
operator|=
name|newval
expr_stmt|;
name|args1
operator|=
name|TREE_CHAIN
argument_list|(
name|args1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TREE_CHAIN
argument_list|(
name|args2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|self_promoting_args_p
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if TYPE is not affected by default promotions.  */
end_comment

begin_function
specifier|static
name|int
name|self_promoting_type_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|signed_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|unsigned_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Compute the value of the `sizeof' operator.  */
end_comment

begin_function
name|tree
name|c_sizeof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"sizeof applied to a function type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"sizeof applied to a void type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"sizeof applied to an incomplete type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
return|return
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|c_sizeof_nowarn
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
name|size_int
argument_list|(
literal|0
argument_list|)
return|;
comment|/* Convert in case a char is more than one unit.  */
return|return
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the size to increment a pointer by.  */
end_comment

begin_function
name|tree
name|c_size_in_bytes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"arithmetic on pointer to an incomplete type"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/* Convert in case a char is more than one unit.  */
return|return
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of TYPE, measured in bytes.  */
end_comment

begin_function
name|tree
name|c_alignof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|size_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
return|return
name|size_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of EXPR, measured in bytes.  For VAR_DECL's and    FIELD_DECL's return DECL_ALIGN (which can be set from an    "aligned" __attribute__ specification).  */
end_comment

begin_function
name|tree
name|c_alignof_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
condition|)
return|return
name|size_int
argument_list|(
name|DECL_ALIGN
argument_list|(
name|expr
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`__alignof' applied to a bit-field"
argument_list|)
expr_stmt|;
return|return
name|size_int
argument_list|(
literal|1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
return|return
name|size_int
argument_list|(
name|DECL_ALIGN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|best
init|=
name|t
decl_stmt|;
name|int
name|bestalign
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|int
name|thisalign
decl_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisalign
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisalign
operator|>
name|bestalign
condition|)
name|best
operator|=
name|t
operator|,
name|bestalign
operator|=
name|thisalign
expr_stmt|;
block|}
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|best
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return either DECL or its known constant value (if it has one).  */
end_comment

begin_function
specifier|static
name|tree
name|decl_constant_value
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
comment|/* Don't change a variable array bound or initial value to a constant 	 in a place where a variable is invalid.  */
operator|&&
name|current_function_decl
operator|!=
literal|0
operator|&&
operator|!
name|pedantic
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
comment|/* This is invalid if initial value is not constant. 	 If it has either a function call, a memory reference, 	 or a variable, then re-evaluating it could give different results.  */
operator|&&
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Check for cases where this is sub-optimal, even though valid.  */
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|&&
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|BLKmode
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Perform default promotions for C data used in expressions.    Arrays and functions are converted to pointers;    enumeral types or short or char, to int.    In addition, manifest constants symbols are replaced by their values.  */
end_comment

begin_function
name|tree
name|default_conversion
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Constants can be used directly unless they're not loadable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|exp
operator|=
name|DECL_INITIAL
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Replace a nonvolatile const static variable with its value.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_READONLY
argument_list|(
name|exp
argument_list|)
operator|&&
name|DECL_MODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
name|exp
operator|=
name|decl_constant_value
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as      an lvalue.  */
comment|/* Do not use STRIP_NOPS here!  It will remove conversions from pointer      to integer and cause infinite recursion.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Normally convert enums to int,      but convert wide enums to something wider.  */
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|type
operator|=
name|type_for_size
argument_list|(
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
operator|(
name|flag_traditional
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Traditionally, unsignedness is preserved in default promotions.          Also preserve unsignedness if not really getting any wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|flag_traditional
operator|||
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
return|return
name|convert
argument_list|(
name|unsigned_type_node
argument_list|,
name|exp
argument_list|)
return|;
return|return
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|exp
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
return|return
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
specifier|register
name|tree
name|adr
decl_stmt|;
name|tree
name|restype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
return|return
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|restype
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|op1
init|=
name|default_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of non-lvalue array"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|restype
operator|=
name|c_build_type_variant
argument_list|(
name|restype
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* ??? This is not really quite correct 	     in that the type of the operand of ADDR_EXPR 	     is not the target type of the type of the ADDR_EXPR itself. 	     Question is, can this lossage be avoided?  */
name|adr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptrtype
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|exp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|TREE_CONSTANT
argument_list|(
name|adr
argument_list|)
operator|=
name|staticp
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|adr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Default would be, same as EXP.  */
return|return
name|adr
return|;
block|}
comment|/* This way is better for a COMPONENT_REF since it can 	 simplify the offset for a component.  */
name|adr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ptrtype
argument_list|,
name|adr
argument_list|)
return|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an expression to refer to the COMPONENT field of    structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|build_component_ref
parameter_list|(
name|datum
parameter_list|,
name|component
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|component
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|field
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|ref
decl_stmt|;
comment|/* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it      unless we are not to support things not strictly ANSI.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|datum
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|value
init|=
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|component
argument_list|)
argument_list|,
name|build_component_ref
argument_list|(
name|TREE_OPERAND
argument_list|(
name|datum
argument_list|,
literal|2
argument_list|)
argument_list|,
name|component
argument_list|)
argument_list|)
return|;
block|}
comment|/* See if there is a field or component with name COMPONENT.  */
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Look up component name in the structure type definition.  	 If TYPE_LANG_SPECIFIC is set, then it is a sorted array of pointers 	 to the field elements.  Use a binary search on this array to quickly 	 find the element.  Otherwise, do a linear search.  TYPE_LANG_SPECIFIC 	 will always be set for structures which have many elements.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|half
decl_stmt|;
name|tree
modifier|*
name|field_array
init|=
operator|&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|elts
index|[
literal|0
index|]
decl_stmt|;
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|top
operator|-
name|bot
operator|>
literal|1
condition|)
block|{
name|int
name|cmp
decl_stmt|;
name|half
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|field
operator|=
name|field_array
index|[
name|bot
operator|+
name|half
index|]
expr_stmt|;
name|cmp
operator|=
operator|(
name|long
operator|)
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|-
operator|(
name|long
operator|)
name|component
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|bot
operator|+=
name|half
expr_stmt|;
else|else
name|top
operator|=
name|bot
operator|+
name|half
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field_array
index|[
name|bot
index|]
argument_list|)
operator|==
name|component
condition|)
name|field
operator|=
name|field_array
index|[
name|bot
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|!=
name|component
condition|)
name|field
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|component
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|field
condition|)
block|{
name|error
argument_list|(
name|code
operator|==
name|RECORD_TYPE
condition|?
literal|"structure has no member named `%s'"
else|:
literal|"union has no member named `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|ref
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|datum
argument_list|,
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|datum
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|field
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ref
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member `%s' in something not a structure or union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|component
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression PTR for a pointer, return an expression    for the value pointed to.    ERRORSTRING is the name of the operator to appear in error messages.  */
end_comment

begin_function
name|tree
name|build_indirect_ref
parameter_list|(
name|ptr
parameter_list|,
name|errorstring
parameter_list|)
name|tree
name|ptr
decl_stmt|;
name|char
modifier|*
name|errorstring
decl_stmt|;
block|{
specifier|register
name|tree
name|pointer
init|=
name|default_conversion
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ref
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VOID_TYPE
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"dereferencing pointer to incomplete type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We *must* set TREE_READONLY when dereferencing a pointer to const, 	   so that we get the proper error message if the result is used 	   to assign to.  Also,&* is supposed to be a no-op. 	   And ANSI C seems to specify that the type of the result 	   should be the const type.  */
comment|/* A de-reference of a pointer to const is not a const.  It is valid 	   to change it via some other pointer.  */
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"invalid type argument of `%s'"
argument_list|,
name|errorstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* This handles expressions of the form "a[i]", which denotes    an array reference.     This is logically equivalent in C to *(a+i), but we may do it differently.    If A is a variable or a member, we generate a primitive ARRAY_REF.    This avoids forcing the array out of registers, and can work on    arrays that are not lvalues (for example, members of structures returned    by functions).  */
end_comment

begin_function
name|tree
name|build_array_ref
parameter_list|(
name|array
parameter_list|,
name|index
parameter_list|)
name|tree
name|array
decl_stmt|,
name|index
decl_stmt|;
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"subscript missing in array reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|array
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|tree
name|rval
decl_stmt|,
name|type
decl_stmt|;
comment|/* Subscripting with type char is likely to lose 	 on a machine where chars are signed. 	 So warn on any machine, but optionally. 	 Don't warn for unsigned char since that type is safe. 	 Don't warn for signed char because anyone who uses that 	 must have done so deliberately.  */
if|if
condition|(
name|warn_char_subscripts
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|char_type_node
condition|)
name|warning
argument_list|(
literal|"array subscript has type `char'"
argument_list|)
expr_stmt|;
comment|/* Apply default promotions *after* noticing character types.  */
name|index
operator|=
name|default_conversion
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|/* Require integer *after* promotion, for sake of enums.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* An array that is indexed by a non-constant 	 cannot be stored in a register; we must be able to do 	 address arithmetic on its address. 	 Likewise an array of elements of variable size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|array
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|array
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|array
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids subscripting `register' array"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ANSI C forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
name|tree
name|foo
init|=
name|array
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|foo
operator|=
name|TREE_OPERAND
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|foo
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|foo
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids subscripting non-lvalue array"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|array
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Array ref is const/volatile if the array elements are          or if the array is.  */
name|TREE_READONLY
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_READONLY
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
operator||
name|TREE_SIDE_EFFECTS
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|rval
argument_list|)
operator||=
operator|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
argument_list|)
comment|/* This was added by rms on 16 Nov 91. 	       It fixes  vol struct foo *a;  a->elts[1]  	       in an inline function. 	       Hope it doesn't break something else.  */
operator||
name|TREE_THIS_VOLATILE
argument_list|(
name|array
argument_list|)
operator|)
expr_stmt|;
return|return
name|require_complete_type
argument_list|(
name|fold
argument_list|(
name|rval
argument_list|)
argument_list|)
return|;
block|}
block|{
name|tree
name|ar
init|=
name|default_conversion
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|tree
name|ind
init|=
name|default_conversion
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|/* Put the integer in IND to simplify error checking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|temp
init|=
name|ar
decl_stmt|;
name|ar
operator|=
name|ind
expr_stmt|;
name|ind
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|ar
operator|==
name|error_mark_node
condition|)
return|return
name|ar
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ar
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"subscripted value is neither array nor pointer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ind
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"array subscript is not an integer"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_indirect_ref
argument_list|(
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ar
argument_list|,
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"array indexing"
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against PARAMS.  */
end_comment

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_define
define|#
directive|define
name|T_I
value|&integer_type_node
end_define

begin_define
define|#
directive|define
name|T_L
value|&long_integer_type_node
end_define

begin_define
define|#
directive|define
name|T_S
value|&short_integer_type_node
end_define

begin_define
define|#
directive|define
name|T_UI
value|&unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_UL
value|&long_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_US
value|&short_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_F
value|&float_type_node
end_define

begin_define
define|#
directive|define
name|T_D
value|&double_type_node
end_define

begin_define
define|#
directive|define
name|T_LD
value|&long_double_type_node
end_define

begin_define
define|#
directive|define
name|T_C
value|&char_type_node
end_define

begin_define
define|#
directive|define
name|T_V
value|&void_type_node
end_define

begin_define
define|#
directive|define
name|T_W
value|&wchar_type_node
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|format_chars
decl_stmt|;
name|int
name|pointer_count
decl_stmt|;
comment|/* Type of argument if no length modifier is used.  */
name|tree
modifier|*
name|nolen
decl_stmt|;
comment|/* Type of argument if length modifier for shortening is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|hlen
decl_stmt|;
comment|/* Type of argument if length modifier `l' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|llen
decl_stmt|;
comment|/* Type of argument if length modifier `L' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|bigllen
decl_stmt|;
comment|/* List of other modifier characters allowed with these options.  */
name|char
modifier|*
name|flag_chars
decl_stmt|;
block|}
name|format_char_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|format_char_info
name|print_table
index|[]
init|=
block|{
block|{
literal|"di"
block|,
literal|0
block|,
name|T_I
block|,
name|T_I
block|,
name|T_L
block|,
name|NULL
block|,
literal|"-wp0 +"
block|}
block|,
block|{
literal|"oxX"
block|,
literal|0
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UL
block|,
name|NULL
block|,
literal|"-wp0#"
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UL
block|,
name|NULL
block|,
literal|"-wp0"
block|}
block|,
block|{
literal|"feEgG"
block|,
literal|0
block|,
name|T_D
block|,
name|NULL
block|,
name|NULL
block|,
name|T_LD
block|,
literal|"-wp0 +#"
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|T_I
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
literal|"-w"
block|}
block|,
block|{
literal|"C"
block|,
literal|0
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-w"
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|T_V
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-"
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|T_I
block|,
name|T_S
block|,
name|T_L
block|,
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|format_char_info
name|scan_table
index|[]
init|=
block|{
block|{
literal|"di"
block|,
literal|1
block|,
name|T_I
block|,
name|T_S
block|,
name|T_L
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"ouxX"
block|,
literal|1
block|,
name|T_UI
block|,
name|T_US
block|,
name|T_UL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"efgEG"
block|,
literal|1
block|,
name|T_F
block|,
name|NULL
block|,
name|T_D
block|,
name|T_LD
block|,
literal|"*"
block|}
block|,
block|{
literal|"sc"
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"["
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"C"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"p"
block|,
literal|2
block|,
name|T_V
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|T_I
block|,
name|T_S
block|,
name|T_L
block|,
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|tree
name|function_ident
decl_stmt|;
comment|/* identifier such as "printf" */
name|int
name|is_scan
decl_stmt|;
comment|/* TRUE if *scanf */
name|int
name|format_num
decl_stmt|;
comment|/* number of format argument */
name|int
name|first_arg_num
decl_stmt|;
comment|/* number of first arg (zero for varargs) */
block|}
name|function_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|function_info_entries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|function_info
modifier|*
name|function_info_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record information for argument format checking.  FUNCTION_IDENT is    the identifier node for the name of the function to check (its decl    need not exist yet).  IS_SCAN is true for scanf-type format checking;    false indicates printf-style format checking.  FORMAT_NUM is the number    of the argument which is the format control string (starting from 1).    FIRST_ARG_NUM is the number of the first actual argument to check    against teh format string, or zero if no checking is not be done    (e.g. for varargs such as vfprintf).  */
end_comment

begin_function
name|void
name|record_format_info
parameter_list|(
name|function_ident
parameter_list|,
name|is_scan
parameter_list|,
name|format_num
parameter_list|,
name|first_arg_num
parameter_list|)
name|tree
name|function_ident
decl_stmt|;
name|int
name|is_scan
decl_stmt|;
name|int
name|format_num
decl_stmt|;
name|int
name|first_arg_num
decl_stmt|;
block|{
name|function_info
modifier|*
name|info
decl_stmt|;
name|function_info_entries
operator|++
expr_stmt|;
if|if
condition|(
name|function_info_table
condition|)
name|function_info_table
operator|=
operator|(
name|function_info
operator|*
operator|)
name|xrealloc
argument_list|(
name|function_info_table
argument_list|,
name|function_info_entries
operator|*
sizeof|sizeof
argument_list|(
name|function_info
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|function_info_table
operator|=
operator|(
name|function_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|function_info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|=
operator|&
name|function_info_table
index|[
name|function_info_entries
operator|-
literal|1
index|]
expr_stmt|;
name|info
operator|->
name|function_ident
operator|=
name|function_ident
expr_stmt|;
name|info
operator|->
name|is_scan
operator|=
name|is_scan
expr_stmt|;
name|info
operator|->
name|format_num
operator|=
name|format_num
expr_stmt|;
name|info
operator|->
name|first_arg_num
operator|=
name|first_arg_num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the table of functions to perform format checking on.    The ANSI functions are always checked (whether<stdio.h> is    included or not), since it is common to call printf without    including<stdio.h>.  There shouldn't be a problem with this,    since ANSI reserves these function names whether you include the    header file or not.  In any case, the checking is harmless.  */
end_comment

begin_function
name|void
name|init_format_info_table
parameter_list|()
block|{
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"printf"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"fprintf"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"sprintf"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"scanf"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"fscanf"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"sscanf"
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"vprintf"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"vfprintf"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_format_info
argument_list|(
name|get_identifier
argument_list|(
literal|"vsprintf"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|tfaff
index|[]
init|=
literal|"too few arguments for format"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    INFO points to the element of function_info_table.    PARAMS is the list of argument values.  */
end_comment

begin_function
specifier|static
name|void
name|check_format
parameter_list|(
name|info
parameter_list|,
name|params
parameter_list|)
name|function_info
modifier|*
name|info
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
name|int
name|suppressed
decl_stmt|,
name|wide
decl_stmt|,
name|precise
decl_stmt|;
name|int
name|length_char
decl_stmt|;
name|int
name|format_char
decl_stmt|;
name|int
name|format_length
decl_stmt|;
name|tree
name|format_tree
decl_stmt|;
name|tree
name|cur_param
decl_stmt|;
name|tree
name|cur_type
decl_stmt|;
name|tree
name|wanted_type
decl_stmt|;
name|char
modifier|*
name|format_chars
decl_stmt|;
name|format_char_info
modifier|*
name|fci
decl_stmt|;
specifier|static
name|char
name|message
index|[
literal|132
index|]
decl_stmt|;
name|char
name|flag_chars
index|[
literal|8
index|]
decl_stmt|;
comment|/* Skip to format argument.  If the argument isn't available, there's      no work for us to do; prototype checking will catch the problem.  */
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
condition|;
operator|++
name|arg_num
control|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|arg_num
operator|==
name|info
operator|->
name|format_num
condition|)
break|break;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
name|format_tree
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_tree
operator|==
literal|0
condition|)
return|return;
comment|/* We can only check the format if it's a string constant.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* strip coercion */
if|if
condition|(
name|format_tree
operator|==
name|null_pointer_node
condition|)
block|{
name|warning
argument_list|(
literal|"null format string"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return;
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return;
name|format_chars
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
name|format_length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_length
operator|<=
literal|1
condition|)
name|warning
argument_list|(
literal|"zero-length format string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_chars
index|[
operator|--
name|format_length
index|]
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"unterminated format string"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip to first argument to check.  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format_chars
operator|-
name|TREE_STRING_POINTER
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|format_length
condition|)
name|warning
argument_list|(
literal|"embedded `\\0' in format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
operator|&&
name|params
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"too many arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|++
operator|!=
literal|'%'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"spurious trailing `%%' in format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'%'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
continue|continue;
block|}
name|flag_chars
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|suppressed
operator|=
name|wide
operator|=
name|precise
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|is_scan
condition|)
block|{
name|suppressed
operator|=
operator|*
name|format_chars
operator|==
literal|'*'
expr_stmt|;
if|if
condition|(
name|suppressed
condition|)
operator|++
name|format_chars
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|format_chars
operator|!=
literal|0
operator|&&
name|index
argument_list|(
literal|" +#0-"
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"repeated `%c' flag in format"
argument_list|,
operator|*
name|format_chars
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* "If the space and + flags both appear,  	     the space flag will be ignored."  */
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|' '
argument_list|)
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'+'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"use of both ` ' and `+' flags in format"
argument_list|)
expr_stmt|;
comment|/* "If the 0 and - flags both appear, 	     the 0 flag will be ignored."  */
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'0'
argument_list|)
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'-'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"use of both `0' and `-' flags in format"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
name|wide
operator|=
name|TRUE
expr_stmt|;
comment|/* "...a field width...may be indicated by an asterisk. 		 In this case, an int argument supplies the field width..."  */
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
comment|/* size_t is generally not valid here. 		     It will work on most machines, because size_t and int 		     have the same mode.  But might as well warn anyway, 		     since it will fail on other machines.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"field width is not type int (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
block|{
name|wide
operator|=
name|TRUE
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'.'
condition|)
block|{
name|precise
operator|=
name|TRUE
expr_stmt|;
comment|/* "For d, i, o, u, x, and X conversions, 		 if a precision is specified, the 0 flag will be ignored. 		 For other conversions, the behavior is undefined."  */
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'0'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"precision and `0' flag both used in one %%-sequence"
argument_list|)
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|'*'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`.' not followed by `*' or digit in format"
argument_list|)
expr_stmt|;
comment|/* "...a...precision...may be indicated by an asterisk. 		 In this case, an int argument supplies the...precision."  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"field width is not type int (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'h'
operator|||
operator|*
name|format_chars
operator|==
literal|'l'
operator|||
operator|*
name|format_chars
operator|==
literal|'L'
condition|)
name|length_char
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
else|else
name|length_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|suppressed
operator|&&
name|length_char
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"use of `*' and `%c' together in format"
argument_list|,
name|length_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|format_char
operator|=
operator|*
name|format_chars
expr_stmt|;
if|if
condition|(
name|format_char
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"conversion lacks type at end of format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|format_chars
operator|++
expr_stmt|;
name|fci
operator|=
name|info
operator|->
name|is_scan
condition|?
name|scan_table
else|:
name|print_table
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|fci
operator|->
name|format_chars
operator|==
literal|0
operator|||
name|index
argument_list|(
name|fci
operator|->
name|format_chars
argument_list|,
name|format_char
argument_list|)
operator|!=
literal|0
condition|)
break|break;
operator|++
name|fci
expr_stmt|;
block|}
if|if
condition|(
name|fci
operator|->
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format_char
operator|>=
literal|040
operator|&&
name|format_char
operator|<
literal|0177
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"unknown conversion type character `%c' in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"unknown conversion type character 0x%x in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|wide
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'w'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"width used with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|precise
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'p'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"precision used with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suppressed
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'*'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"suppression of `%c' conversion in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flag_chars
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"flag `%c' used with type `%c'"
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|length_char
condition|)
block|{
default|default:
name|wanted_type
operator|=
name|fci
operator|->
name|nolen
condition|?
operator|*
operator|(
name|fci
operator|->
name|nolen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|hlen
condition|?
operator|*
operator|(
name|fci
operator|->
name|hlen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|llen
condition|?
operator|*
operator|(
name|fci
operator|->
name|llen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|bigllen
condition|?
operator|*
operator|(
name|fci
operator|->
name|bigllen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wanted_type
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"use of `%c' length character with `%c' type character"
argument_list|,
name|length_char
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/*        ** XXX -- should kvetch about stuff such as        **	{        **		const int	i;        **        **		scanf ("%d",&i);        **	}        */
comment|/* Finally. . .check type of argument against desired type!  */
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
comment|/* Check the types of any additional pointer arguments 	 that precede the "real" argument.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fci
operator|->
name|pointer_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"format argument is not a %s (arg %d)"
argument_list|,
operator|(
operator|(
name|fci
operator|->
name|pointer_count
operator|==
literal|1
operator|)
condition|?
literal|"pointer"
else|:
literal|"pointer to a pointer"
operator|)
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check the type of the "real" argument, if there's a type we want.  */
if|if
condition|(
name|i
operator|==
name|fci
operator|->
name|pointer_count
operator|&&
name|wanted_type
operator|!=
literal|0
operator|&&
name|wanted_type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
comment|/* If we want `void *', allow any pointer type. 	     (Anything else would already have got a warning.)  */
operator|&&
operator|!
operator|(
name|wanted_type
operator|==
name|void_type_node
operator|&&
name|fci
operator|->
name|pointer_count
operator|>
literal|0
operator|)
comment|/* Don't warn about differences merely in signedness.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|cur_type
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|this
decl_stmt|;
specifier|register
name|char
modifier|*
name|that
decl_stmt|;
name|this
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|wanted_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|that
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A nameless type can't possibly match what the format wants. 	     So there will be a warning for it. 	     Make up a string to describe vaguely what it is.  */
if|if
condition|(
name|that
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|that
operator|=
literal|"pointer"
expr_stmt|;
else|else
name|that
operator|=
literal|"different type"
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|this
argument_list|,
name|that
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s format, %s arg (arg %d)"
argument_list|,
name|this
argument_list|,
name|that
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a function call to function FUNCTION with parameters PARAMS.    PARAMS is a list--a chain of TREE_LIST nodes--in which the    TREE_VALUE of each node is a parameter-expression.    FUNCTION's data type may be a function type or a pointer-to-function.  */
end_comment

begin_function
name|tree
name|build_function_call
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|;
block|{
specifier|register
name|tree
name|fntype
decl_stmt|;
specifier|register
name|tree
name|coerced_params
decl_stmt|;
name|tree
name|name
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Convert anything with function type to a pointer-to-function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|name
operator|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Differs from default_conversion by not setting TREE_ADDRESSABLE 	 (because calling an inline function does not mean the function 	 needs to be separately compiled).  */
name|fntype
operator|=
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|function
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|function
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"called object is not a function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* fntype now gets the type of function pointed to.  */
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* Convert the parameters to the types declared in the      function prototype, or apply default promotions.  */
name|coerced_params
operator|=
name|convert_arguments
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|params
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Check for errors in format strings.  */
if|if
condition|(
name|warn_format
operator|&&
name|name
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* See if this function is a format function.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|function_info_entries
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|function_info_table
index|[
name|i
index|]
operator|.
name|function_ident
operator|==
name|name
condition|)
block|{
specifier|register
name|char
modifier|*
name|message
decl_stmt|;
comment|/* If so, check it.  */
name|check_format
argument_list|(
operator|&
name|function_info_table
index|[
name|i
index|]
argument_list|,
name|coerced_params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Recognize certain built-in functions so we can make tree-codes      other than CALL_EXPR.  We do this when it enables fold-const.c      to do something useful.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_FABS
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|,
name|coerced_params
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
name|result
return|;
return|return
name|require_complete_type
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the argument expressions in the list VALUES    to the types in the list TYPELIST.  The result is a list of converted    argument expressions.     If TYPELIST is exhausted, or when an element has NULL as its type,    perform the default conversions.     PARMLIST is the chain of parm decls for the function being called.    It may be 0, if that info is not available.    It is used only for generating error messages.     NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.     This is also where warnings about wrong number of args are generated.     Both VALUES and the returned value are chains of TREE_LIST nodes    with the elements of the list in the TREE_VALUE slots of those nodes.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_arguments
parameter_list|(
name|typelist
parameter_list|,
name|values
parameter_list|,
name|name
parameter_list|)
name|tree
name|typelist
decl_stmt|,
name|values
decl_stmt|,
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|typetail
decl_stmt|,
name|valtail
decl_stmt|;
specifier|register
name|tree
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
comment|/* Scan the given expressions and types, producing individual      converted arguments and pushing them on RESULT in reverse order.  */
for|for
control|(
name|valtail
operator|=
name|values
operator|,
name|typetail
operator|=
name|typelist
operator|,
name|parmnum
operator|=
literal|0
init|;
name|valtail
condition|;
name|valtail
operator|=
name|TREE_CHAIN
argument_list|(
name|valtail
argument_list|)
operator|,
name|parmnum
operator|++
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|typetail
condition|?
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|register
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|valtail
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"too many arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too many arguments to function"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here!  We do not want an enumerator with value 0 	 to convert automatically to a pointer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|val
operator|=
name|default_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|require_complete_type
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
comment|/* Formal parm type is specified by a function prototype.  */
name|tree
name|parmval
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"type of formal parameter %d is incomplete"
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|parmval
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|tree
name|parmname
decl_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
comment|/* Rather than truncating and then reextending, 		 convert directly to int, if that's the type we will want.  */
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* This turns out not to win--there's no way to write a prototype 	 for a function whose arg type is a union with no tag.  */
comment|/* Nameless union automatically casts the types it contains.  */
block|if (TREE_CODE (type) == UNION_TYPE&& TYPE_NAME (type) == 0) 		{ 		  tree field;  		  for (field = TYPE_FIELDS (type); field; 		       field = TREE_CHAIN (field)) 		    if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (field)), 				   TYPE_MAIN_VARIANT (TREE_TYPE (val)))) 		      break;  		  if (field) 		    val = build1 (CONVERT_EXPR, type, val); 		}
endif|#
directive|endif
comment|/* Optionally warn about conversions that 		 differ from the default conversions.  */
if|if
condition|(
name|warn_conversion
condition|)
block|{
name|int
name|formal_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as integer rather than floating due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as floating rather than integer due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* Warn if any argument is passed as `float', 			 since without a prototype it would be `double'.  */
if|if
condition|(
name|formal_prec
operator|==
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as `float' rather than `double' due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Detect integer changing in width or signedness.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
name|tree
name|would_have_been
init|=
name|default_conversion
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|tree
name|type1
init|=
name|TREE_TYPE
argument_list|(
name|would_have_been
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
condition|)
comment|/* No warning if function asks for enum 			   and the actual arg is that enum type.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|formal_prec
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s with different width due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|type1
argument_list|)
condition|)
empty_stmt|;
comment|/* Don't complain if the formal parameter type 			 is an enum, because we can't tell now whether 			 the value was an enum--even the same enum.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_fits_type_p
argument_list|(
name|val
argument_list|,
name|type
argument_list|)
condition|)
comment|/* Change in signedness doesn't matter 			   if a constant value is unaffected.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|int_fits_type_p
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
operator|&&
name|int_fits_type_p
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
comment|/* Change in signedness doesn't matter 			   if an enum value is unaffected.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s as unsigned due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|warn_for_assignment
argument_list|(
literal|"%s as signed due to prototype"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|parmval
operator|=
name|convert_for_assignment
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
comment|/* arg passing  */
name|name
argument_list|,
name|parmnum
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|parmval
operator|=
name|default_conversion
argument_list|(
name|parmval
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parmval
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|)
condition|)
comment|/* Convert `float' to `double'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|convert
argument_list|(
name|double_type_node
argument_list|,
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
comment|/* Convert `short' and `char' to full-size `int'.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|val
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|typetail
condition|)
name|typetail
operator|=
name|TREE_CHAIN
argument_list|(
name|typetail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typetail
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|typetail
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"too few arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too few arguments to function"
argument_list|)
expr_stmt|;
block|}
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the entry point used by the parser    for binary operators in the input.    In addition to constructing the expression,    we check for operands that were written with other binary operators    in a way that is likely to confuse the user.  */
end_comment

begin_function
name|tree
name|parser_build_binary_op
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|char
name|class
decl_stmt|;
name|char
name|class1
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|class2
init|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code1
init|=
name|ERROR_MARK
decl_stmt|;
name|enum
name|tree_code
name|code2
init|=
name|ERROR_MARK
decl_stmt|;
if|if
condition|(
name|class1
operator|==
literal|'e'
operator|||
name|class1
operator|==
literal|'1'
operator|||
name|class1
operator|==
literal|'2'
operator|||
name|class1
operator|==
literal|'<'
condition|)
name|code1
operator|=
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|class2
operator|==
literal|'e'
operator|||
name|class2
operator|==
literal|'1'
operator|||
name|class2
operator|==
literal|'2'
operator|||
name|class2
operator|==
literal|'<'
condition|)
name|code2
operator|=
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* Check for cases such as x+y<<z which users are likely      to misinterpret.  If parens are used, C_EXP_ORIGINAL_CODE      is cleared to prevent these warnings.  */
if|if
condition|(
name|warn_parentheses
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around + or - inside shift"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code2
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around&& within ||"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_IOR_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|BIT_AND_EXPR
operator|||
name|code1
operator|==
name|BIT_XOR_EXPR
operator|||
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|BIT_AND_EXPR
operator|||
name|code2
operator|==
name|BIT_XOR_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around arithmetic in operand of |"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_XOR_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|BIT_AND_EXPR
operator|||
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|BIT_AND_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around arithmetic in operand of ^"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS_EXPR
operator|||
name|code1
operator|==
name|MINUS_EXPR
operator|||
name|code2
operator|==
name|PLUS_EXPR
operator|||
name|code2
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around + or - in operand of&"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Similarly, check for cases like 1<=i<=10 that are probably errors.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|extra_warnings
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code1
argument_list|)
operator|==
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code2
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
name|warning
argument_list|(
literal|"comparisons like X<=Y<=Z do not have their mathematical meaning"
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the code that was specified in the source,      for the sake of warnings about confusing nesting.  */
if|if
condition|(
name|class
operator|==
literal|'e'
operator|||
name|class
operator|==
literal|'1'
operator|||
name|class
operator|==
literal|'2'
operator|||
name|class
operator|==
literal|'<'
condition|)
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|result
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|flag
init|=
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|result
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|C_SET_EXP_ORIGINAL_CODE
argument_list|(
name|result
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
name|flag
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Build a binary-operation expression without default conversions.    CODE is the kind of expression to build.    This function differs from `build' in several ways:    the data type of the result is computed and recorded in it,    warnings are generated if arg data types are invalid,    special handling for addition and subtraction of pointers is known,    and some optimization is done (operations on narrow ints    are done in the narrower type when that gives the same result).    Constant folding is also done before the result is returned.     Note that the operands will never have enumeral types, or function    or array types, because either they will have the default conversions    performed or they have both just been converted to some other type in which    the arithmetic is to be done.  */
end_comment

begin_function
name|tree
name|build_binary_op
parameter_list|(
name|code
parameter_list|,
name|orig_op0
parameter_list|,
name|orig_op1
parameter_list|,
name|convert_p
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|orig_op0
decl_stmt|,
name|orig_op1
decl_stmt|;
name|int
name|convert_p
decl_stmt|;
block|{
name|tree
name|type0
decl_stmt|,
name|type1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code0
decl_stmt|,
name|code1
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
comment|/* Expression code to give to the expression when it is built.      Normally this is CODE, which is what the caller asked for,      but in some special cases we change it.  */
specifier|register
name|enum
name|tree_code
name|resultcode
init|=
name|code
decl_stmt|;
comment|/* Data type in which the computation is to be performed.      In the simplest cases this is the common type of the arguments.  */
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* Nonzero means operands have already been type-converted      in whatever way is necessary.      Zero means they need to be converted to RESULT_TYPE.  */
name|int
name|converted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means after finally constructing the expression      give it this type.  Otherwise, give it type RESULT_TYPE.  */
name|tree
name|final_type
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is an operation like MIN or MAX which can      safely be computed in short if both args are promoted shorts.      Also implies COMMON.      -1 indicates a bitwise operation; this makes a difference      in the exact conditions for when it is safe to do the operation      in a narrower mode.  */
name|int
name|shorten
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a comparison operation;      if both args are promoted shorts, compare the original shorts.      Also implies COMMON.  */
name|int
name|short_compare
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this is a right-shift operation, which can be computed on the      original short and then promoted if the operand is a promoted short.  */
name|int
name|short_shift
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means set RESULT_TYPE to the common type of the args.  */
name|int
name|common
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|convert_p
condition|)
block|{
name|op0
operator|=
name|default_conversion
argument_list|(
name|orig_op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|default_conversion
argument_list|(
name|orig_op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|orig_op0
expr_stmt|;
name|op1
operator|=
name|orig_op1
expr_stmt|;
block|}
name|type0
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* The expression codes of the data types of the arguments tell us      whether the arguments are integers, floating, pointers, etc.  */
name|code0
operator|=
name|TREE_CODE
argument_list|(
name|type0
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|op1
argument_list|)
expr_stmt|;
comment|/* If an error was already reported for one of the arguments,      avoid reporting another error.  */
if|if
condition|(
name|code0
operator|==
name|ERROR_MARK
operator|||
name|code1
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
comment|/* Handle the pointer + int case.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code0
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|PLUS_EXPR
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* Subtraction of two similar pointers. 	 We must subtract them as integers, then divide by object size.  */
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
return|return
name|pointer_diff
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
return|;
comment|/* Handle pointer minus int.  Just like pointer plus int.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
return|return
name|pointer_int_sum
argument_list|(
name|MINUS_EXPR
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
else|else
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|common
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
operator|)
condition|)
name|resultcode
operator|=
name|RDIV_EXPR
expr_stmt|;
else|else
comment|/* When dividing two signed integers, you have to promote to int. 	       E.g. (short) -32868 / (short) -1 doesn't fit in a short.  */
name|shorten
operator|=
name|TREE_UNSIGNED
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|common
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If one operand is a constant, and the other is a short type 	 that has been converted to an int, 	 really do the work in the short type and then convert the 	 result to int.  If we are lucky, the constant will be 0 or 1 	 in the short type, making the entire operation go away.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type1
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|final_type
operator|=
name|result_type
expr_stmt|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|POINTER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|POINTER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
comment|/* Result of these operations is always an int, 	     but that does not mean the operands should be 	     converted to ints!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|truthvalue_conversion
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|truthvalue_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* Shift operations: result has same type as first operand; 	 always convert second operand to int. 	 Also set SHORT_SHIFT if shifting rightward.  */
case|case
name|RSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"shift count is negative"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator||
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
condition|)
name|short_shift
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Use the type of the value to be shifted. 	     This is what most traditional C compilers do.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Unless traditional, convert the shift-count to an integer, 	     regardless of size of value being shifted.  */
if|if
condition|(
operator|!
name|flag_traditional
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LSHIFT_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Use the type of the value to be shifted. 	     This is what most traditional C compilers do.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Unless traditional, convert the shift-count to an integer, 	     regardless of size of value being shifted.  */
if|if
condition|(
operator|!
name|flag_traditional
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"shift count is negative"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|op1
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|type0
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"shift count>= width of type"
argument_list|)
expr_stmt|;
block|}
comment|/* Use the type of the value to be shifted. 	     This is what most traditional C compilers do.  */
name|result_type
operator|=
name|type0
expr_stmt|;
comment|/* Unless traditional, convert the shift-count to an integer, 	     regardless of size of value being shifted.  */
if|if
condition|(
operator|!
name|flag_traditional
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Avoid converting op1 to result_type later.  */
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
comment|/* Result of comparison is always int, 	 but don't convert the args to int!  */
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|tt0
init|=
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tt1
init|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
decl_stmt|;
comment|/* Anything compares with void *.  void * compares with anything. 	     Otherwise, the targets must be the same.  */
if|if
condition|(
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|tt0
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|op0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|tt1
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|tt0
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids comparison of `void *' with function pointer"
argument_list|)
expr_stmt|;
block|}
else|else
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If args are not valid, clear out RESULT_TYPE 	   to cause an error message later.  */
name|result_type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
name|short_compare
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|comp_target_types
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"comparison of distinct pointer types lacks a cast"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids ordered comparisons of pointers to functions"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
name|op0
operator|=
name|null_pointer_node
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ordered comparison of pointer with integer zero"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|INTEGER_TYPE
operator|&&
name|code1
operator|==
name|POINTER_TYPE
condition|)
block|{
name|result_type
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|pedwarn
argument_list|(
literal|"comparison between pointer and integer"
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|converted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|code0
operator|==
name|INTEGER_TYPE
operator|||
name|code0
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|shorten
operator|||
name|common
operator|||
name|short_compare
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
comment|/* For certain operations (which identify themselves by shorten != 0) 	 if both args were extended from the same smaller type, 	 do the arithmetic in that type and then extend.  	 shorten !=0 and !=1 indicates a bitwise operation. 	 For them, this optimization is safe only if 	 both args are zero-extended or both are sign-extended. 	 Otherwise, we might change the result. 	 Eg, (short)-1 | (unsigned short)-1 is (int)-1 	 but calculated in (unsigned short) it would be (unsigned short)-1.  */
if|if
condition|(
name|shorten
condition|)
block|{
name|int
name|unsigned0
decl_stmt|,
name|unsigned1
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsigned1
argument_list|)
decl_stmt|;
comment|/* UNS is 1 if the operation to be done is an unsigned one.  */
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|result_type
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
comment|/* Handle the case that OP0 (or OP1) does not *contain* a conversion 	     but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|final_type
condition|)
name|unsigned1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */
comment|/* For bitwise operations, signedness of nominal type 	     does not matter.  Consider only how operands were extended.  */
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|uns
operator|=
name|unsigned0
expr_stmt|;
comment|/* Note that in all three cases below we refrain from optimizing 	     an unsigned operation on sign-extended args. 	     That would not be valid.  */
comment|/* Both args variable: if both extended in same way 	     from same width, do it in that width. 	     Do it unsigned if args were zero-extended.  */
if|if
condition|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|)
operator|&&
name|unsigned0
operator|==
name|unsigned1
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
condition|)
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned1
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned1
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg0
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|unsigned0
operator|||
operator|!
name|uns
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
operator|&&
operator|(
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned0
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|,
name|int_fits_type_p
argument_list|(
name|arg1
argument_list|,
name|type
argument_list|)
operator|)
condition|)
name|result_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* Shifts can be shortened if shifting right.  */
if|if
condition|(
name|short_shift
condition|)
block|{
name|int
name|unsigned_arg
decl_stmt|;
name|tree
name|arg0
init|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsigned_arg
argument_list|)
decl_stmt|;
name|final_type
operator|=
name|result_type
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|op0
operator|&&
name|final_type
operator|==
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
condition|)
name|unsigned_arg
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
comment|/* If arg is sign-extended and then unsigned-shifted, 		 we can simulate this with a signed shift in arg's type 		 only if the extended result is at least twice as wide 		 as the arg.  Otherwise, the shift could use up all the 		 ones made by sign-extension and bring in zeros. 		 We can't optimize that case at all, but in most machines 		 it never happens because available widths are 2**N.  */
operator|&&
operator|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|final_type
argument_list|)
operator|||
name|unsigned_arg
operator|||
literal|2
operator|*
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|)
condition|)
block|{
comment|/* Do an unsigned shift if the operand was zero-extended.  */
name|result_type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsigned_arg
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert value-to-be-shifted to that type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|converted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Comparison operations are shortened too but differently. 	 They identify themselves by setting short_compare = 1.  */
if|if
condition|(
name|short_compare
condition|)
block|{
comment|/* Don't write&op0, etc., because that would prevent op0 	     from being kept in a register. 	     Instead, make copies of the our local variables and 	     pass the copies by reference, then copy them back afterward.  */
name|tree
name|xop0
init|=
name|op0
decl_stmt|,
name|xop1
init|=
name|op1
decl_stmt|,
name|xresult_type
init|=
name|result_type
decl_stmt|;
name|enum
name|tree_code
name|xresultcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|val
init|=
name|shorten_compare
argument_list|(
operator|&
name|xop0
argument_list|,
operator|&
name|xop1
argument_list|,
operator|&
name|xresult_type
argument_list|,
operator|&
name|xresultcode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
name|op0
operator|=
name|xop0
operator|,
name|op1
operator|=
name|xop1
operator|,
name|result_type
operator|=
name|xresult_type
expr_stmt|;
name|resultcode
operator|=
name|xresultcode
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
block|{
name|tree
name|op0_type
init|=
name|TREE_TYPE
argument_list|(
name|orig_op0
argument_list|)
decl_stmt|;
name|tree
name|op1_type
init|=
name|TREE_TYPE
argument_list|(
name|orig_op1
argument_list|)
decl_stmt|;
name|int
name|op0_unsigned
init|=
name|TREE_UNSIGNED
argument_list|(
name|op0_type
argument_list|)
decl_stmt|;
name|int
name|op1_unsigned
init|=
name|TREE_UNSIGNED
argument_list|(
name|op1_type
argument_list|)
decl_stmt|;
comment|/* Give warnings for comparisons between signed and unsigned 		 quantities that will fail.  Do not warn if the signed quantity 		 is an unsuffixed integer literal (or some static constant 		 expression involving such literals) and it is positive. 		 Do not warn if the width of the unsigned quantity is less 		 than that of the signed quantity, since in this case all 		 values of the unsigned quantity fit in the signed quantity. 		 Do not warn if the signed type is the same size as the 		 result_type since sign extension does not cause trouble in 		 this case.  */
comment|/* Do the checking based on the original operand trees, so that 		 casts will be considered, but default promotions won't be.  */
if|if
condition|(
name|op0_unsigned
operator|!=
name|op1_unsigned
operator|&&
operator|(
operator|(
name|op0_unsigned
operator|&&
name|TYPE_PRECISION
argument_list|(
name|op0_type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|op1_type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|op0_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|INT_CST_LT
argument_list|(
name|op1
argument_list|,
name|integer_zero_node
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|op1_unsigned
operator|&&
name|TYPE_PRECISION
argument_list|(
name|op1_type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|op0_type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|op1_type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|result_type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|INT_CST_LT
argument_list|(
name|op0
argument_list|,
name|integer_zero_node
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison between signed and unsigned"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* At this point, RESULT_TYPE must be nonzero to avoid an error message.      If CONVERTED is zero, both args will be converted to type RESULT_TYPE.      Then the expression will be built.      It will be given type FINAL_TYPE if that is nonzero;      otherwise, it will be given type RESULT_TYPE.  */
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
name|binary_op_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|converted
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
name|result_type
condition|)
name|op0
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
name|result_type
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|result
init|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_type
operator|!=
literal|0
condition|)
return|return
name|convert
argument_list|(
name|final_type
argument_list|,
name|folded
argument_list|)
return|;
return|return
name|folded
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_int_sum
parameter_list|(
name|resultcode
parameter_list|,
name|ptrop
parameter_list|,
name|intop
parameter_list|)
name|enum
name|tree_code
name|resultcode
decl_stmt|;
specifier|register
name|tree
name|ptrop
decl_stmt|,
name|intop
decl_stmt|;
block|{
name|tree
name|size_exp
decl_stmt|;
specifier|register
name|tree
name|result
decl_stmt|;
specifier|register
name|tree
name|folded
decl_stmt|;
comment|/* The result is a pointer of the same type that is being added.  */
specifier|register
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer of type `void *' used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a function used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
name|size_exp
operator|=
name|c_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If what we are about to multiply by the size of the elements      contains a constant term, apply distributive law      and multiply that constant term separately.      This helps produce common subexpressions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|size_exp
argument_list|)
comment|/* If the constant comes from pointer subtraction, 	 skip this optimization--it would cause an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|enum
name|tree_code
name|subcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|int_type
init|=
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|subcode
operator|=
operator|(
name|subcode
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
comment|/* Convert both subexpression types to the type of intop, 	 because weird cases involving pointer arithmetic 	 can result in a sum or difference with different type args.  */
name|ptrop
operator|=
name|build_binary_op
argument_list|(
name|subcode
argument_list|,
name|ptrop
argument_list|,
name|convert
argument_list|(
name|int_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intop
operator|=
name|convert
argument_list|(
name|int_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer argument to a type the same size as a pointer      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|POINTER_SIZE
condition|)
name|intop
operator|=
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|intop
argument_list|)
expr_stmt|;
comment|/* Replace the integer argument      with a suitable product by the object size.  */
name|intop
operator|=
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|intop
argument_list|,
name|size_exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|result
operator|=
name|build
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|ptrop
argument_list|,
name|intop
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|ptrop
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_comment
comment|/* Return a tree for the difference of pointers OP0 and OP1.    The resulting tree has type int.  */
end_comment

begin_function
specifier|static
name|tree
name|pointer_diff
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|)
specifier|register
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|,
name|folded
decl_stmt|;
name|tree
name|restype
init|=
name|ptrdiff_type_node
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"pointer of type `void *' used in subtraction"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a function used in subtraction"
argument_list|)
expr_stmt|;
block|}
comment|/* First do the subtraction as integers;      then drop through to build the divide operator.  */
name|op0
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|restype
argument_list|,
name|op1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|c_size_in_bytes
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
comment|/* Divide by the size, in easiest possible way.  */
name|result
operator|=
name|build
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|restype
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|folded
operator|=
name|fold
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
operator|==
name|result
condition|)
name|TREE_CONSTANT
argument_list|(
name|folded
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|op0
argument_list|)
operator|&
name|TREE_CONSTANT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|folded
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct and perhaps optimize a tree representation    for a unary operation.  CODE, a tree_code, specifies the operation    and XARG is the operand.  NOCONVERT nonzero suppresses    the default promotions (such as from short to int).  */
end_comment

begin_function
name|tree
name|build_unary_op
parameter_list|(
name|code
parameter_list|,
name|xarg
parameter_list|,
name|noconvert
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg
decl_stmt|;
name|int
name|noconvert
decl_stmt|;
block|{
comment|/* No default_conversion here.  It causes trouble for ADDR_EXPR.  */
specifier|register
name|tree
name|arg
init|=
name|xarg
decl_stmt|;
specifier|register
name|tree
name|argtype
init|=
literal|0
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|typecode
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|errstring
init|=
name|NULL
decl_stmt|;
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|typecode
operator|==
name|ENUMERAL_TYPE
condition|)
name|typecode
operator|=
name|INTEGER_TYPE
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONVERT_EXPR
case|:
comment|/* This is used for unary plus, because a CONVERT_EXPR 	 is enough to prevent anybody from looking inside for 	 associativity, but won't generate any code.  */
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary plus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to unary minus"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
condition|)
name|errstring
operator|=
literal|"wrong type argument to bit-complement"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
operator|!
operator|(
name|typecode
operator|==
name|INTEGER_TYPE
operator|||
name|typecode
operator|==
name|REAL_TYPE
operator|)
condition|)
name|errstring
operator|=
literal|"wrong type argument to abs"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noconvert
condition|)
name|arg
operator|=
name|default_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
operator|&&
name|typecode
operator|!=
name|POINTER_TYPE
comment|/* These will convert to a pointer.  */
operator|&&
name|typecode
operator|!=
name|ARRAY_TYPE
operator|&&
name|typecode
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
name|errstring
operator|=
literal|"wrong type argument to unary exclamation mark"
expr_stmt|;
break|break;
block|}
name|arg
operator|=
name|truthvalue_conversion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
break|break;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
comment|/* Report invalid types.  */
if|if
condition|(
name|typecode
operator|!=
name|POINTER_TYPE
operator|&&
name|typecode
operator|!=
name|INTEGER_TYPE
operator|&&
name|typecode
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|errstring
operator|=
literal|"wrong type argument to increment"
expr_stmt|;
else|else
name|errstring
operator|=
literal|"wrong type argument to decrement"
expr_stmt|;
break|break;
block|}
block|{
specifier|register
name|tree
name|inc
decl_stmt|;
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|arg
operator|=
name|get_unwidened
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Compute the increment.  */
if|if
condition|(
name|typecode
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"wrong type argument to %s"
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
expr_stmt|;
name|inc
operator|=
name|c_sizeof_nowarn
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|inc
operator|=
name|integer_one_node
expr_stmt|;
name|inc
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|inc
argument_list|)
expr_stmt|;
comment|/* Handle incrementing a cast-expression.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
comment|/* If the real type has the same machine representation 		 as the type it is cast to, we can make better output 		 by adding directly to the inside of the cast.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|incremented
decl_stmt|,
name|modify
decl_stmt|,
name|value
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
condition|)
name|value
operator|=
name|arg
expr_stmt|;
else|else
name|value
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|incremented
operator|=
name|build
argument_list|(
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
name|PLUS_EXPR
else|:
name|MINUS_EXPR
operator|)
argument_list|,
name|argtype
argument_list|,
name|value
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|incremented
argument_list|)
operator|=
literal|1
expr_stmt|;
name|modify
operator|=
name|build_modify_expr
argument_list|(
name|arg
argument_list|,
name|NOP_EXPR
argument_list|,
name|incremented
argument_list|)
expr_stmt|;
name|value
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|modify
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
break|break;
default|default:
goto|goto
name|give_up
goto|;
block|}
name|give_up
label|:
comment|/* Complain about anything else that is not a true lvalue.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Report a read-only lvalue.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
name|readonly_warning
argument_list|(
name|arg
argument_list|,
operator|(
operator|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|)
condition|?
literal|"increment"
else|:
literal|"decrement"
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|code
condition|)
name|TREE_NO_UNUSED_WARNING
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
case|case
name|ADDR_EXPR
case|:
comment|/* Note that this operation never does default_conversion 	 regardless of NOCONVERT.  */
comment|/* Let&* cancel out to simplify resulting code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Don't let this be an lvalue.  */
if|if
condition|(
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* For&x[y], return x+y */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Handle complex lvalues (when permitted) 	 by reduction to simpler cases.  */
name|val
operator|=
name|unary_complex_lvalue
argument_list|(
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
if|#
directive|if
literal|0
comment|/* Turned off because inconsistent; 	 float f; *&(int)f = 3.4 stores in int format 	 whereas (int)f = 3.4 stores in float format.  */
comment|/* Address of a cast is just a cast of the address 	 of the operand of the cast.  */
block|switch (TREE_CODE (arg)) 	{ 	case NOP_EXPR: 	case CONVERT_EXPR: 	case FLOAT_EXPR: 	case FIX_TRUNC_EXPR: 	case FIX_FLOOR_EXPR: 	case FIX_ROUND_EXPR: 	case FIX_CEIL_EXPR: 	  if (pedantic) 	    pedwarn ("ANSI C forbids the address of a cast expression"); 	  return convert (build_pointer_type (TREE_TYPE (arg)), 			  build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), 					  0)); 	}
endif|#
directive|endif
comment|/* Allow the address of a constructor if all the elements 	 are constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
condition|)
empty_stmt|;
comment|/* Anything not already handled and not a true memory reference 	 is an error.  */
elseif|else
if|if
condition|(
name|typecode
operator|!=
name|FUNCTION_TYPE
operator|&&
operator|!
name|lvalue_or_else
argument_list|(
name|arg
argument_list|,
literal|"unary `&'"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Ordinary case; arg is a COMPONENT_REF or a decl.  */
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If the lvalue is const or volatile, 	 merge that into the type that the address will point to.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
condition|)
name|argtype
operator|=
name|c_build_type_variant
argument_list|(
name|argtype
argument_list|,
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argtype
operator|=
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_addressable
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
block|{
name|tree
name|addr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"attempt to take address of bit-field structure member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|addr
operator|=
name|convert
argument_list|(
name|argtype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|offset
init|=
name|size_binop
argument_list|(
name|EASY_DIV_EXPR
argument_list|,
name|DECL_FIELD_BITPOS
argument_list|(
name|field
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|flag
init|=
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|addr
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|argtype
argument_list|,
name|addr
argument_list|,
name|convert
argument_list|(
name|argtype
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
name|flag
expr_stmt|;
block|}
block|}
else|else
name|addr
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Address of a static or external variable or 	   file-scope function counts as a constant.  */
if|if
condition|(
name|staticp
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
if|if
condition|(
operator|!
name|errstring
condition|)
block|{
if|if
condition|(
name|argtype
operator|==
literal|0
condition|)
name|argtype
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|argtype
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* If CONVERSIONS is a conversion expression or a nested sequence of such,    convert ARG with the same conversions in the same order    and return the result.  */
end_comment

begin_endif
unit|static tree convert_sequence (conversions, arg)      tree conversions;      tree arg; {   switch (TREE_CODE (conversions))     {     case NOP_EXPR:     case CONVERT_EXPR:     case FLOAT_EXPR:     case FIX_TRUNC_EXPR:     case FIX_FLOOR_EXPR:     case FIX_ROUND_EXPR:     case FIX_CEIL_EXPR:       return convert (TREE_TYPE (conversions), 		      convert_sequence (TREE_OPERAND (conversions, 0), 					arg));      default:       return arg;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language.    Lvalues can be assigned, unless their type has TYPE_READONLY.    Lvalues can have their address taken, unless they have DECL_REGISTER.  */
end_comment

begin_function
name|int
name|lvalue_p
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
return|return
name|lvalue_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|ERROR_MARK
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if REF is an lvalue valid for this language;    otherwise, print an error message and return zero.  */
end_comment

begin_function
name|int
name|lvalue_or_else
parameter_list|(
name|ref
parameter_list|,
name|string
parameter_list|)
name|tree
name|ref
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|win
init|=
name|lvalue_p
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|error
argument_list|(
literal|"invalid lvalue in %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/* Apply unary lvalue-demanding operator CODE to the expression ARG    for certain kinds of expressions which are not really lvalues    but which we can accept as lvalues.     If ARG is not a kind of expression we can handle, return zero.  */
end_comment

begin_function
specifier|static
name|tree
name|unary_complex_lvalue
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
block|{
name|tree
name|real_result
init|=
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|pedantic_lvalue_warning
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|real_result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_result
argument_list|)
return|;
block|}
comment|/* Handle (a ? b : c) used as an "lvalue".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|pedantic_lvalue_warning
argument_list|(
name|COND_EXPR
argument_list|)
expr_stmt|;
return|return
operator|(
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_unary_op
argument_list|(
name|code
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If pedantic, warn about improper lvalue.   CODE is either COND_EXPR    COMPOUND_EXPR, or CONVERT_EXPR (for casts).  */
end_comment

begin_function
specifier|static
name|void
name|pedantic_lvalue_warning
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids use of %s expressions as lvalues"
argument_list|,
name|code
operator|==
name|COND_EXPR
condition|?
literal|"conditional"
else|:
name|code
operator|==
name|COMPOUND_EXPR
condition|?
literal|"compound"
else|:
literal|"cast"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Warn about storing in something that is `const'.  */
end_comment

begin_function
name|void
name|readonly_warning
parameter_list|(
name|arg
parameter_list|,
name|string
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|readonly_warning
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|else
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of read-only member `%s'"
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" of read-only variable `%s'"
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"%s of read-only location"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark EXP saying that we need to be able to take the    address of it; it should not be allocated in a register.    Value is 1 if successful.  */
end_comment

begin_function
name|int
name|mark_addressable
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|tree
name|x
init|=
name|exp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"global register variable `%s' used in nested function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pedwarn
argument_list|(
literal|"register variable `%s' used in nested function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"address of global register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pedwarn
argument_list|(
literal|"address of register variable `%s' requested"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|put_var_into_stack
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* drops in */
case|case
name|FUNCTION_DECL
case|:
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* poplevel deals with this now.  */
block|if (DECL_CONTEXT (x) == 0) 	  TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;
endif|#
directive|endif
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build and return a conditional expression IFEXP ? OP1 : OP2.  */
end_comment

begin_function
name|tree
name|build_conditional_expr
parameter_list|(
name|ifexp
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|ifexp
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
specifier|register
name|tree
name|type1
decl_stmt|;
specifier|register
name|tree
name|type2
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code2
decl_stmt|;
specifier|register
name|tree
name|result_type
init|=
name|NULL
decl_stmt|;
comment|/* If second operand is omitted, it is the same as the first one;      make sure it is calculated only once.  */
if|if
condition|(
name|op1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids omitting the middle term of a ?: expression"
argument_list|)
expr_stmt|;
name|ifexp
operator|=
name|op1
operator|=
name|save_expr
argument_list|(
name|ifexp
argument_list|)
expr_stmt|;
block|}
name|ifexp
operator|=
name|truthvalue_conversion
argument_list|(
name|default_conversion
argument_list|(
name|ifexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|#
directive|if
literal|0
comment|/* Produces wrong result if within sizeof.  */
comment|/* Don't promote the operands separately if they promote      the same way.  Return the unpromoted type and let the combined      value get promoted if necessary.  */
block|if (TREE_TYPE (op1) == TREE_TYPE (op2)&& TREE_CODE (TREE_TYPE (op1)) != ARRAY_TYPE&& TREE_CODE (TREE_TYPE (op1)) != ENUMERAL_TYPE&& TREE_CODE (TREE_TYPE (op1)) != FUNCTION_TYPE)     {       if (TREE_CODE (ifexp) == INTEGER_CST) 	return (integer_zerop (ifexp) ? op2 : op1);        return fold (build (COND_EXPR, TREE_TYPE (op1), ifexp, op1, op2));     }
endif|#
directive|endif
comment|/* They don't match; promote them both and then try to reconcile them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op1
operator|=
name|default_conversion
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|op2
operator|=
name|default_conversion
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
comment|/* Quickly detect the usual case where op1 and op2 have the same type      after promotion.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
name|result_type
operator|=
name|type1
expr_stmt|;
else|else
name|result_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|INTEGER_TYPE
operator|||
name|code1
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|code2
operator|==
name|INTEGER_TYPE
operator|||
name|code2
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|VOID_TYPE
operator|||
name|code2
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code1
operator|!=
name|VOID_TYPE
operator|||
name|code2
operator|!=
name|VOID_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids conditional expr with only one void side"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|void_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|comp_target_types
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
condition|)
name|result_type
operator|=
name|common_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op1
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
operator|==
name|void_type_node
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|op2
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
operator|==
name|void_type_node
condition|)
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type1
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids conditional expr between `void *' and function pointer"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|qualify_type
argument_list|(
name|type2
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pedwarn
argument_list|(
literal|"pointer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
name|result_type
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|POINTER_TYPE
operator|&&
name|code2
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op2
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op2
operator|=
name|null_pointer_node
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The spec seems to say this is permitted.  */
block|if (pedantic&& TREE_CODE (type1) == FUNCTION_TYPE) 	    pedwarn ("ANSI C forbids conditional expr between 0 and function pointer");
endif|#
directive|endif
block|}
name|result_type
operator|=
name|type1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code2
operator|==
name|POINTER_TYPE
operator|&&
name|code1
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|op1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"pointer/integer type mismatch in conditional expression"
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
name|null_pointer_node
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The spec seems to say this is permitted.  */
block|if (pedantic&& TREE_CODE (type2) == FUNCTION_TYPE) 	    pedwarn ("ANSI C forbids conditional expr between 0 and function pointer");
endif|#
directive|endif
block|}
name|result_type
operator|=
name|type2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result_type
condition|)
block|{
if|if
condition|(
name|flag_cond_mismatch
condition|)
name|result_type
operator|=
name|void_type_node
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"type mismatch in conditional expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Merge const and volatile flags of the incoming types.  */
name|result_type
operator|=
name|build_type_variant
argument_list|(
name|result_type
argument_list|,
name|TREE_READONLY
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|op2
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|op1
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|op2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_type
operator|!=
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (code1 == RECORD_TYPE || code1 == UNION_TYPE)     {       result_type = TREE_TYPE (op1);       if (TREE_CONSTANT (ifexp)) 	return (integer_zerop (ifexp) ? op2 : op1);        if (TYPE_MODE (result_type) == BLKmode) 	{ 	  register tree tempvar 	    = build_decl (VAR_DECL, NULL_TREE, result_type); 	  register tree xop1 = build_modify_expr (tempvar, op1); 	  register tree xop2 = build_modify_expr (tempvar, op2); 	  register tree result = fold (build (COND_EXPR, result_type, 					      ifexp, xop1, xop2));  	  layout_decl (tempvar, TYPE_ALIGN (result_type));
comment|/* No way to handle variable-sized objects here. 	     I fear that the entire handling of BLKmode conditional exprs 	     needs to be redone.  */
block|if (TREE_CODE (DECL_SIZE (tempvar)) != INTEGER_CST) 	    abort (); 	  DECL_RTL (tempvar) 	    = assign_stack_local (DECL_MODE (tempvar), 				  (TREE_INT_CST_LOW (DECL_SIZE (tempvar)) 				   + BITS_PER_UNIT - 1) 				  / BITS_PER_UNIT, 				  0);  	  TREE_SIDE_EFFECTS (result) 	    = TREE_SIDE_EFFECTS (ifexp) | TREE_SIDE_EFFECTS (op1) 	      | TREE_SIDE_EFFECTS (op2); 	  return build (COMPOUND_EXPR, result_type, result, tempvar); 	}     }
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ifexp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
operator|(
name|integer_zerop
argument_list|(
name|ifexp
argument_list|)
condition|?
name|op2
else|:
name|op1
operator|)
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|result_type
argument_list|,
name|ifexp
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a list of expressions, return a compound expression    that performs them all and returns the value of the last of them.  */
end_comment

begin_function
name|tree
name|build_compound_expr
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|tree
name|rest
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* If something inside inhibited lvalueness, we should not override.  */
comment|/* Consider (x, y+0), which is not an lvalue since y+0 is not.  */
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
block|if (TREE_CODE (list) == NON_LVALUE_EXPR) 	list = TREE_OPERAND (list, 0);
endif|#
directive|endif
return|return
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Convert arrays to pointers when there really is a comma operator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rest
operator|=
name|build_compound_expr
argument_list|(
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
return|return
name|rest
return|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|rest
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|,
name|rest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing a cast to type TYPE of expression EXPR.  */
end_comment

begin_function
name|tree
name|build_c_cast
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|expr
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
block|if (TREE_CODE (value) == NON_LVALUE_EXPR)     value = TREE_OPERAND (value, 0);
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies array type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cast specifies function type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids casting nonscalar to the same type"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|field
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|nvalue
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids casts to union type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
literal|""
expr_stmt|;
return|return
name|digest_init
argument_list|(
name|type
argument_list|,
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"cast to union type from type not present in union"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|otype
decl_stmt|;
comment|/* Convert functions and arrays to pointers, 	 but don't convert any other types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Optionally warn about potentially worrisome casts.  */
if|if
condition|(
name|warn_cast_qual
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"cast discards `volatile' from pointer target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"cast discards `const' from pointer target type"
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about possible alignment problems.  */
if|if
condition|(
name|STRICT_ALIGNMENT
operator|&&
name|warn_cast_align
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast increases required alignment of target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast from pointer to integer of different size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|otype
argument_list|)
if|#
directive|if
literal|0
comment|/* Don't warn about converting 0 to pointer, 	     provided the 0 was explicit--not cast or made by folding.  */
expr|&& !(TREE_CODE (value) == INTEGER_CST&& integer_zerop (value))
endif|#
directive|endif
comment|/* Don't warn about converting any constant.  */
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cast to pointer from integer of different size"
argument_list|)
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|expr
operator|&&
name|pedantic
condition|)
block|{
comment|/* If pedantic, don't let a cast be an lvalue.  */
return|return
name|non_lvalue
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build an assignment expression of lvalue LHS from value RHS.    MODIFYCODE is the code for a binary operator that we use    to combine the old value of LHS with RHS to get the new value.    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.  */
end_comment

begin_function
name|tree
name|build_modify_expr
parameter_list|(
name|lhs
parameter_list|,
name|modifycode
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|enum
name|tree_code
name|modifycode
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
name|tree
name|newrhs
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|olhstype
init|=
name|lhstype
decl_stmt|;
comment|/* Types that aren't fully specified cannot be used in assignments.  */
name|lhs
operator|=
name|require_complete_type
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* Avoid duplicate error messages from operands that had errors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|rhs
expr_stmt|;
comment|/* Handle control structure constructs used as "lvalues".  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
comment|/* Handle (a, b) used as an "lvalue".  */
case|case
name|COMPOUND_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
return|;
comment|/* Handle (a ? b : c) used as an "lvalue".  */
case|case
name|COND_EXPR
case|:
name|pedantic_lvalue_warning
argument_list|(
name|COND_EXPR
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|save_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|{
comment|/* Produce (a ? (b = rhs) : (c = rhs)) 	   except that the RHS goes through a save-expr 	   so the code to compute it is only emitted once.  */
name|tree
name|cond
init|=
name|build_conditional_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|build_modify_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|modifycode
argument_list|,
name|rhs
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Make sure the code to compute the rhs comes out 	   before the split.  */
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
comment|/* But cast it to void to avoid an "unused" error.  */
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|cond
argument_list|)
return|;
block|}
block|}
comment|/* If a binary op has been requested, combine the old LHS value with the RHS      producing the value we should actually store into the LHS.  */
if|if
condition|(
name|modifycode
operator|!=
name|NOP_EXPR
condition|)
block|{
name|lhs
operator|=
name|stabilize_reference
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|newrhs
operator|=
name|build_binary_op
argument_list|(
name|modifycode
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a cast used as an "lvalue".      We have already performed any binary operator using the value as cast.      Now convert the result to the cast type of the lhs,      and then true type of the lhs and store it there;      then convert result back to the cast type to be the value      of the assignment.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newrhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|newrhs
operator|=
name|default_conversion
argument_list|(
name|newrhs
argument_list|)
expr_stmt|;
block|{
name|tree
name|inner_lhs
init|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|result
operator|=
name|build_modify_expr
argument_list|(
name|inner_lhs
argument_list|,
name|NOP_EXPR
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|inner_lhs
argument_list|)
argument_list|,
name|convert
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pedantic_lvalue_warning
argument_list|(
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|result
argument_list|)
return|;
block|}
block|}
comment|/* Now we have handled acceptable kinds of LHS that are not truly lvalues.      Reject anything strange now.  */
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Warn about storing in something that is `const'.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|lhs
argument_list|)
operator|||
name|TYPE_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|lhstype
argument_list|)
operator|)
condition|)
name|readonly_warning
argument_list|(
name|lhs
argument_list|,
literal|"assignment"
argument_list|)
expr_stmt|;
comment|/* If storing into a structure or union member,      it has probably been given type `int'.      Compute the type that would go with      the actual amount of storage the member occupies.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storing in a field that is in actuality a short or narrower than one,      we must store in the field in its actual type.  */
if|if
condition|(
name|lhstype
operator|!=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|copy_node
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
block|}
comment|/* Convert new value to destination type.  */
name|newrhs
operator|=
name|convert_for_assignment
argument_list|(
name|lhstype
argument_list|,
name|newrhs
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newrhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|lhstype
argument_list|,
name|lhs
argument_list|,
name|newrhs
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we got the LHS in a different type for storing in,      convert the result back to the nominal type of LHS      so that the value we return always has the same type      as the LHS argument.  */
if|if
condition|(
name|olhstype
operator|==
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
return|return
name|convert_for_assignment
argument_list|(
name|olhstype
argument_list|,
name|result
argument_list|,
literal|"assignment"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert value RHS to type TYPE as preparation for an assignment    to an lvalue of type TYPE.    The real work of conversion is done by `convert'.    The purpose of this function is to generate error messages    for assignments that are not allowed in C.    ERRTYPE is a string to use in error messages:    "assignment", "return", etc.  If it is null, this is parameter passing    for a function call (and different error messages are output).  Otherwise,    it may be a name stored in the spelling stack and interpreted by    get_spelling.     FUNNAME is the name of the function being called,    as an IDENTIFIER_NODE, or null.    PARMNUM is the number of the argument, for printing in error messages.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_for_assignment
parameter_list|(
name|type
parameter_list|,
name|rhs
parameter_list|,
name|errtype
parameter_list|,
name|funname
parameter_list|,
name|parmnum
parameter_list|)
name|tree
name|type
decl_stmt|,
name|rhs
decl_stmt|;
name|char
modifier|*
name|errtype
decl_stmt|;
name|tree
name|funname
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|rhstype
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
decl_stmt|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|rhs
operator|=
name|default_conversion
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|coder
operator|=
name|TREE_CODE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|rhstype
argument_list|)
condition|)
return|return
name|rhs
return|;
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Arithmetic types all interconvert, and enum is treated like int.  */
if|if
condition|(
operator|(
name|codel
operator|==
name|INTEGER_TYPE
operator|||
name|codel
operator|==
name|REAL_TYPE
operator|||
name|codel
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
operator|)
condition|)
block|{
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* Conversions among pointers */
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rhstype
argument_list|)
decl_stmt|;
comment|/* Any non-function converts to a [const][volatile] void * 	 and vice versa; otherwise, targets must be the same. 	 Meanwhile, the lhs target must have all the qualifiers of the rhs.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|||
name|comp_target_types
argument_list|(
name|type
argument_list|,
name|rhstype
argument_list|)
operator|||
operator|(
operator|!
name|pedantic
comment|/* Unless pedantic, mix signed and unsigned.  */
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|ttl
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|ttr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"ANSI forbids %s between function pointer and `void *'"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
comment|/* Const and volatile mean something different for function types, 	     so the usual warnings are not appropriate.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TYPE_READONLY
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s discards `const' from pointer target type"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s discards `volatile' from pointer target type"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Because const and volatile on functions are restrictions 		 that say the function will not do certain things, 		 it is okay to use a const or volatile function 		 where an ordinary one is wanted, but not vice-versa.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
operator|!
name|TYPE_READONLY
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s makes `const *' function pointer from non-const"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|&&
operator|!
name|TYPE_VOLATILE
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s makes `volatile *' function pointer from non-volatile"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttl
argument_list|)
argument_list|)
operator|==
name|unsigned_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|ttr
argument_list|)
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"pointer targets in %s differ in signedness"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
else|else
name|warn_for_assignment
argument_list|(
literal|"%s from incompatible pointer type"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* An explicit constant 0 can convert to a pointer, 	 but not a 0 that results from casting or folding.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
block|{
name|warn_for_assignment
argument_list|(
literal|"%s makes pointer from integer without a cast"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
name|null_pointer_node
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|INTEGER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
name|warn_for_assignment
argument_list|(
literal|"%s makes integer from pointer without a cast"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|,
name|funname
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|rhs
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|errtype
condition|)
block|{
if|if
condition|(
name|funname
condition|)
name|error
argument_list|(
literal|"incompatible type for argument %d of `%s'"
argument_list|,
name|parmnum
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"incompatible type for argument %d of indirect function call"
argument_list|,
name|parmnum
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"incompatible types in %s"
argument_list|,
name|get_spelling
argument_list|(
name|errtype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Print a warning using MSG.    It gets OPNAME as its one parameter.    If OPNAME is null, it is replaced by "passing arg ARGNUM of `FUNCTION'".    FUNCTION and ARGNUM are handled specially if we are building an    Objective-C selector.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_assignment
parameter_list|(
name|msg
parameter_list|,
name|opname
parameter_list|,
name|function
parameter_list|,
name|argnum
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|opname
decl_stmt|;
name|tree
name|function
decl_stmt|;
name|int
name|argnum
decl_stmt|;
block|{
specifier|static
name|char
name|argstring
index|[]
init|=
literal|"passing arg %d of `%s'"
decl_stmt|;
specifier|static
name|char
name|argnofun
index|[]
init|=
literal|"passing arg %d"
decl_stmt|;
if|if
condition|(
name|opname
operator|==
literal|0
condition|)
block|{
name|tree
name|selector
init|=
name|maybe_building_objc_message_expr
argument_list|()
decl_stmt|;
if|if
condition|(
name|selector
operator|&&
name|argnum
operator|>
literal|2
condition|)
block|{
name|function
operator|=
name|selector
expr_stmt|;
name|argnum
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|function
condition|)
block|{
comment|/* Function name is known; supply it.  */
name|opname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|function
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|argstring
argument_list|)
operator|+
literal|25
comment|/*%d*/
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|opname
argument_list|,
name|argstring
argument_list|,
name|argnum
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Function name unknown (call through ptr); just give arg number.  */
name|opname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|argnofun
argument_list|)
operator|+
literal|25
comment|/*%d*/
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|opname
argument_list|,
name|argnofun
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
block|}
block|}
name|pedwarn
argument_list|(
name|msg
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if VALUE is a valid constant-valued expression    for use in initializing a static variable; one that can be an    element of a "constant" initializer.     Return null_pointer_node if the value is absolute;    if it is relocatable, return the variable that determines the relocation.    We assume that VALUE has been folded as much as possible;    therefore, we do not need to check for such things as    arithmetic-combinations of integers.  */
end_comment

begin_function
specifier|static
name|tree
name|initializer_constant_valid_p
parameter_list|(
name|value
parameter_list|,
name|endtype
parameter_list|)
name|tree
name|value
decl_stmt|;
name|tree
name|endtype
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
return|return
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|?
name|null_pointer_node
else|:
literal|0
return|;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|null_pointer_node
return|;
case|case
name|ADDR_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* Allow conversions between pointer types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between real types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow length-preserving conversions between integer types.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions between integer types only if explicit value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|inner
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner
operator|==
name|null_pointer_node
condition|)
return|return
name|null_pointer_node
return|;
return|return
literal|0
return|;
block|}
comment|/* Allow (int)&foo.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
comment|/* Allow conversions to union types if the value inside is okay.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|endtype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|<
name|POINTER_SIZE
condition|)
return|return
literal|0
return|;
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* If either term is absolute, use the other terms relocation.  */
if|if
condition|(
name|valid0
operator|==
name|null_pointer_node
condition|)
return|return
name|valid1
return|;
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
return|return
literal|0
return|;
block|}
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|endtype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|endtype
argument_list|)
operator|<
name|POINTER_SIZE
condition|)
return|return
literal|0
return|;
block|{
name|tree
name|valid0
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
name|tree
name|valid1
init|=
name|initializer_constant_valid_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|endtype
argument_list|)
decl_stmt|;
comment|/* Win if second argument is absolute.  */
if|if
condition|(
name|valid1
operator|==
name|null_pointer_node
condition|)
return|return
name|valid0
return|;
comment|/* Win if both arguments have the same relocation. 	   Then the value is absolute.  */
if|if
condition|(
name|valid0
operator|==
name|valid1
condition|)
return|return
name|null_pointer_node
return|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform appropriate conversions on the initial value of a variable,    store it in the declaration DECL,    and print any error messages that are appropriate.    If the init is invalid, store an ERROR_MARK.  */
end_comment

begin_function
name|void
name|store_init_value
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|type
decl_stmt|;
comment|/* If variable's type was invalidly declared, just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Digest the specified initializer into an expression.  */
name|value
operator|=
name|digest_init
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
name|NULL_PTR
argument_list|,
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|pedantic
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the expression if valid; else report error.  */
if|#
directive|if
literal|0
comment|/* Note that this is the only place we can detect the error      in a case such as   struct foo bar = (struct foo) { x, y };      where there is one initial value which is a constructor expression.  */
block|if (value == error_mark_node)     ;   else if (TREE_STATIC (decl)&& ! TREE_CONSTANT (value))     {       error ("initializer for static variable is not constant");       value = error_mark_node;     }   else if (TREE_STATIC (decl)&& initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)     {       error ("initializer for static variable uses complicated arithmetic");       value = error_mark_node;     }   else     {       if (pedantic&& TREE_CODE (value) == CONSTRUCTOR) 	{ 	  if (! TREE_CONSTANT (value)) 	    pedwarn ("aggregate initializer is not constant"); 	  else if (! TREE_STATIC (value)) 	    pedwarn ("aggregate initializer uses complicated arithmetic"); 	}     }
endif|#
directive|endif
comment|/* ANSI wants warnings about out-of-range constant initializers.  */
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Methods for storing and printing names for error messages.  */
end_comment

begin_comment
comment|/* Implement a spelling stack that allows components of a name to be pushed    and popped.  Each element on the stack is this structure.  */
end_comment

begin_struct
struct|struct
name|spelling
block|{
name|int
name|kind
decl_stmt|;
union|union
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SPELLING_STRING
value|1
end_define

begin_define
define|#
directive|define
name|SPELLING_MEMBER
value|2
end_define

begin_define
define|#
directive|define
name|SPELLING_BOUNDS
value|3
end_define

begin_decl_stmt
specifier|static
name|struct
name|spelling
modifier|*
name|spelling
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next stack element (unused).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|spelling
modifier|*
name|spelling_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spelling stack base.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spelling_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the spelling stack.  */
end_comment

begin_comment
comment|/* Macros to save and restore the spelling stack around push_... functions.    Alternative to SAVE_SPELLING_STACK.  */
end_comment

begin_define
define|#
directive|define
name|SPELLING_DEPTH
parameter_list|()
value|(spelling - spelling_base)
end_define

begin_define
define|#
directive|define
name|RESTORE_SPELLING_DEPTH
parameter_list|(
name|depth
parameter_list|)
value|(spelling = spelling_base + depth)
end_define

begin_comment
comment|/* Save and restore the spelling stack around arbitrary C code.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_SPELLING_DEPTH
parameter_list|(
name|code
parameter_list|)
define|\
value|{						\   int __depth = SPELLING_DEPTH ();		\   code;						\   RESTORE_SPELLING_DEPTH (__depth);		\ }
end_define

begin_comment
comment|/* Push an element on the spelling stack with type KIND and assign VALUE    to MEMBER.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_SPELLING
parameter_list|(
name|KIND
parameter_list|,
name|VALUE
parameter_list|,
name|MEMBER
parameter_list|)
define|\
value|{									\   int depth = SPELLING_DEPTH ();					\ 									\   if (depth>= spelling_size)						\     {									\       spelling_size += 10;						\       if (spelling_base == 0)						\ 	spelling_base							\ 	  = (struct spelling *) xmalloc (spelling_size * sizeof (struct spelling));	\       else								\         spelling_base							\ 	  = (struct spelling *) xrealloc (spelling_base,		\ 					  spelling_size * sizeof (struct spelling));	\       RESTORE_SPELLING_DEPTH (depth);					\     }									\ 									\   spelling->kind = (KIND);						\   spelling->MEMBER = (VALUE);						\   spelling++;								\ }
end_define

begin_comment
comment|/* Push STRING on the stack.  Printed literally.  */
end_comment

begin_function
specifier|static
name|void
name|push_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_STRING
argument_list|,
name|string
argument_list|,
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a member name on the stack.  Printed as '.' STRING.  */
end_comment

begin_function
specifier|static
name|void
name|push_member_name
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_MEMBER
argument_list|,
name|string
argument_list|,
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push an array bounds on the stack.  Printed as [BOUNDS].  */
end_comment

begin_function
specifier|static
name|void
name|push_array_bounds
parameter_list|(
name|bounds
parameter_list|)
name|int
name|bounds
decl_stmt|;
block|{
name|PUSH_SPELLING
argument_list|(
name|SPELLING_BOUNDS
argument_list|,
name|bounds
argument_list|,
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the maximum size in bytes of the printed spelling.  */
end_comment

begin_function
specifier|static
name|int
name|spelling_length
parameter_list|()
block|{
specifier|register
name|int
name|size
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|spelling
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|spelling_base
init|;
name|p
operator|<
name|spelling
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_BOUNDS
condition|)
name|size
operator|+=
literal|25
expr_stmt|;
else|else
name|size
operator|+=
name|strlen
argument_list|(
name|p
operator|->
name|u
operator|.
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Print the spelling to BUFFER and return it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|print_spelling
parameter_list|(
name|buffer
parameter_list|)
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
init|=
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|spelling
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|spelling_base
init|;
name|p
operator|<
name|spelling
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_BOUNDS
condition|)
block|{
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"[%d]"
argument_list|,
name|p
operator|->
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
name|d
operator|+=
name|strlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|kind
operator|==
name|SPELLING_MEMBER
condition|)
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p
operator|->
name|u
operator|.
name|s
init|;
operator|*
name|d
operator|=
operator|*
name|s
operator|++
condition|;
name|d
operator|++
control|)
empty_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Provide a means to pass component names derived from the spelling stack.  */
end_comment

begin_decl_stmt
name|char
name|initialization_message
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interpret the spelling of the given ERRTYPE message.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_spelling
parameter_list|(
name|errtype
parameter_list|)
name|char
modifier|*
name|errtype
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|static
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|errtype
operator|==
operator|&
name|initialization_message
condition|)
block|{
comment|/* Avoid counting chars */
specifier|static
name|char
name|message
index|[]
init|=
literal|"initialization of `%s'"
decl_stmt|;
specifier|register
name|int
name|needed
init|=
sizeof|sizeof
argument_list|(
name|message
argument_list|)
operator|+
name|spelling_length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|=
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|>
name|size
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|size
operator|=
name|needed
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|needed
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|message
argument_list|,
name|print_spelling
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
return|return
name|errtype
return|;
block|}
end_function

begin_comment
comment|/* Issue an error message for a bad initializer component.    FORMAT describes the message.  OFWHAT is the name for the component.    LOCAL is a format string for formatting the insertion of the name    into the message.     If OFWHAT is null, the component name is stored on the spelling stack.    If the component name is a null string, then LOCAL is omitted entirely.  */
end_comment

begin_function
name|void
name|error_init
parameter_list|(
name|format
parameter_list|,
name|local
parameter_list|,
name|ofwhat
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|,
decl|*
name|local
decl_stmt|,
modifier|*
name|ofwhat
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|ofwhat
operator|==
literal|0
condition|)
name|ofwhat
operator|=
name|print_spelling
argument_list|(
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|local
argument_list|)
operator|+
name|strlen
argument_list|(
name|ofwhat
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|local
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
else|else
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
name|format
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Issue a pedantic warning for a bad initializer component.    FORMAT describes the message.  OFWHAT is the name for the component.    LOCAL is a format string for formatting the insertion of the name    into the message.     If OFWHAT is null, the component name is stored on the spelling stack.    If the component name is a null string, then LOCAL is omitted entirely.  */
end_comment

begin_function
name|void
name|pedwarn_init
parameter_list|(
name|format
parameter_list|,
name|local
parameter_list|,
name|ofwhat
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|,
decl|*
name|local
decl_stmt|,
modifier|*
name|ofwhat
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|ofwhat
operator|==
literal|0
condition|)
name|ofwhat
operator|=
name|print_spelling
argument_list|(
name|alloca
argument_list|(
name|spelling_length
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|local
argument_list|)
operator|+
name|strlen
argument_list|(
name|ofwhat
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ofwhat
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|local
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
else|else
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pedwarn
argument_list|(
name|format
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Keep a pointer to the last free TREE_LIST node as we digest an initializer,    so that we can reuse it.  This is set in digest_init, and used in    process_init_constructor.     We will never keep more than one free TREE_LIST node here.  This is for    two main reasons.  First, we take elements off the old list and add them    to the new list one at a time, thus there should never be more than    one free TREE_LIST at a time, and thus even if there is, we will never    need more than one.  Secondly, to avoid dangling pointers to freed obstacks,    we want to always ensure that we have either a pointer to a valid TREE_LIST    within the current initializer, or else a pointer to null.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|free_tree_list
init|=
name|NULL_TREE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Digest the parser output INIT as an initializer for type TYPE.    Return a C expression of type TYPE to represent the initial value.     If TAIL is nonzero, it points to a variable holding a list of elements    of which INIT is the first.  We update the list stored there by    removing from the head all the elements that we use.    Normally this is only one; we use more than one element only if    TYPE is an aggregate and INIT is not a constructor.     The arguments REQUIRE_CONSTANT and CONSTRUCTOR_CONSTANT request errors    if non-constant initializers or elements are seen.  CONSTRUCTOR_CONSTANT    applies only to elements of constructors.     If OFWHAT is nonnull, it specifies what we are initializing, for error    messages.   Examples: variable name, variable.member, array[44].    If OFWHAT is null, the component name is stored on the spelling stack.  */
end_comment

begin_function
name|tree
name|digest_init
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|tail
parameter_list|,
name|require_constant
parameter_list|,
name|constructor_constant
parameter_list|,
name|ofwhat
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|require_constant
decl_stmt|,
name|constructor_constant
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ofwhat
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|element
init|=
literal|0
decl_stmt|;
name|tree
name|old_tail_contents
decl_stmt|;
comment|/* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR      tree node which has no TREE_TYPE.  */
name|int
name|raw_constructor
init|=
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|==
literal|0
decl_stmt|;
name|tree
name|inside_init
init|=
name|init
decl_stmt|;
comment|/* By default, assume we use one element from a list.      We correct this later in the cases where it is not true.       Thus, we update TAIL now to point to the next element, and save the      old value in OLD_TAIL_CONTENTS.  If we didn't actually use the first      element, then we will reset TAIL before proceeding.  FREE_TREE_LIST      is handled similarly.  */
if|if
condition|(
name|tail
condition|)
block|{
name|old_tail_contents
operator|=
operator|*
name|tail
expr_stmt|;
operator|*
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|tail
argument_list|)
expr_stmt|;
name|free_tree_list
operator|=
name|old_tail_contents
expr_stmt|;
block|}
else|else
name|free_tree_list
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|init
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
comment|/* Do not use STRIP_NOPS here.  We do not want an enumerator      whose value is 0 to count as a null pointer constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|inside_init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside_init
operator|&&
name|raw_constructor
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|inside_init
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|element
operator|=
name|TREE_VALUE
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|inside_init
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
if|if
condition|(
name|element
operator|&&
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|element
operator|=
name|TREE_OPERAND
argument_list|(
name|element
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Initialization of an array of chars from a string constant      optionally enclosed in braces.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|typ1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|typ1
operator|==
name|char_type_node
operator|||
name|typ1
operator|==
name|signed_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_char_type_node
operator|||
name|typ1
operator|==
name|unsigned_wchar_type_node
operator|||
name|typ1
operator|==
name|signed_wchar_type_node
operator|)
operator|&&
operator|(
operator|(
name|inside_init
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|||
operator|(
name|element
operator|&&
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|)
condition|)
block|{
name|tree
name|string
init|=
name|element
condition|?
name|element
else|:
name|inside_init
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"char-array%s initialized from wide string"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|typ1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"int-array%s initialized from non-wide string"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|string
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|int
name|size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Subtract 1 because it's ok to ignore the terminating null char 		 that is counted in the length of the constant.  */
if|if
condition|(
name|size
operator|<
name|TREE_STRING_LENGTH
argument_list|(
name|string
argument_list|)
operator|-
literal|1
condition|)
name|pedwarn_init
argument_list|(
literal|"initializer-string for array of chars%s is too long"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
return|return
name|string
return|;
block|}
block|}
comment|/* Any type except an array can be initialized      from an expression of the same type, optionally with braces.      For an array, this is allowed only for a string constant.  */
if|if
condition|(
name|inside_init
operator|&&
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|)
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|||
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
name|inside_init
operator|=
name|default_conversion
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error_init
argument_list|(
literal|"array%s initialized from non-constant array expression"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|optimize
operator|&&
name|TREE_READONLY
argument_list|(
name|inside_init
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|inside_init
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|inside_init
operator|=
name|decl_constant_value
argument_list|(
name|inside_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element%s is not constant"
argument_list|,
literal|" for `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element%s is not computable at load time"
argument_list|,
literal|" for `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|inside_init
return|;
block|}
if|if
condition|(
name|element
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
operator|==
name|type
operator|||
operator|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|,
name|type
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error_init
argument_list|(
literal|"array%s initialized from non-constant array expression"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"single-expression nonscalar initializer has braces"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|TREE_READONLY
argument_list|(
name|element
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|element
operator|=
name|decl_constant_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element%s is not constant"
argument_list|,
literal|" for `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
name|element
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|element
argument_list|,
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element%s is not computable at load time"
argument_list|,
literal|" for `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
name|element
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|element
return|;
block|}
comment|/* Check for initializing a union by its first field.      Such an initializer must use braces.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Find the first named field.  ANSI decided in September 1990 	 that only named fields count here.  */
while|while
condition|(
name|field
operator|&&
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"union%s with no named members cannot be initialized"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|raw_constructor
condition|)
name|result
operator|=
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|inside_init
argument_list|,
name|NULL_PTR
argument_list|,
name|require_constant
argument_list|,
name|constructor_constant
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tail
operator|!=
literal|0
condition|)
block|{
operator|*
name|tail
operator|=
name|old_tail_contents
expr_stmt|;
name|free_tree_list
operator|=
name|NULL_TREE
expr_stmt|;
name|result
operator|=
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|tail
argument_list|,
name|require_constant
argument_list|,
name|constructor_constant
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
comment|/* Handle scalar types, including conversions.  */
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|||
name|code
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|raw_constructor
condition|)
block|{
if|if
condition|(
name|element
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer for scalar%s requires one element"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
comment|/* Deal with extra levels of {...}.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer for scalar%s requires one element"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|inside_init
operator|=
name|element
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* A non-raw constructor is an actual expression.  */
block|if (TREE_CODE (inside_init) == CONSTRUCTOR) 	{ 	  error_init ("initializer for scalar%s has extra braces", 		      " `%s'", ofwhat); 	  return error_mark_node; 	}
endif|#
directive|endif
name|SAVE_SPELLING_DEPTH
argument_list|(
argument|{ 	  if (ofwhat) 	    push_string (ofwhat); 	  inside_init 	    = convert_for_assignment (type, 				      default_conversion (raw_constructor 							  ? inside_init 							  : init),&initialization_message, NULL_TREE,
literal|0
argument|); 	}
argument_list|)
empty_stmt|;
if|if
condition|(
name|require_constant
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|inside_init
argument_list|)
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element%s is not constant"
argument_list|,
literal|" for `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|require_constant
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|inside_init
argument_list|,
name|TREE_TYPE
argument_list|(
name|inside_init
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"initializer element%s is not computable at load time"
argument_list|,
literal|" for `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
name|inside_init
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|inside_init
return|;
block|}
comment|/* Come here only for records and arrays.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error_init
argument_list|(
literal|"variable-sized object%s may not be initialized"
argument_list|,
literal|" `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|||
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|raw_constructor
condition|)
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|inside_init
argument_list|,
name|NULL_PTR
argument_list|,
name|constructor_constant
argument_list|,
name|constructor_constant
argument_list|,
name|ofwhat
argument_list|)
return|;
elseif|else
if|if
condition|(
name|tail
operator|!=
literal|0
condition|)
block|{
operator|*
name|tail
operator|=
name|old_tail_contents
expr_stmt|;
name|free_tree_list
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|tail
argument_list|,
name|constructor_constant
argument_list|,
name|constructor_constant
argument_list|,
name|ofwhat
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|flag_traditional
condition|)
comment|/* Traditionally one can say `char x[100] = 0;'.  */
return|return
name|process_init_constructor
argument_list|(
name|type
argument_list|,
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULL_TREE
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|inside_init
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|constructor_constant
argument_list|,
name|constructor_constant
argument_list|,
name|ofwhat
argument_list|)
return|;
block|}
name|error_init
argument_list|(
literal|"invalid initializer%s"
argument_list|,
literal|" for `%s'"
argument_list|,
name|ofwhat
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Process a constructor for a variable of type TYPE.    The constructor elements may be specified either with INIT or with ELTS,    only one of which should be non-null.     If INIT is specified, it is a CONSTRUCTOR node which is specifically    and solely for initializing this datum.     If ELTS is specified, it is the address of a variable containing    a list of expressions.  We take as many elements as we need    from the head of the list and update the list.     In the resulting constructor, TREE_CONSTANT is set if all elts are    constant, and TREE_STATIC is set if, in addition, all elts are simple enough    constants that the assembler and linker can compute them.     The argument CONSTANT_VALUE says to print an error if either the    value or any element is not a constant.     The argument CONSTANT_ELEMENT says to print an error if an element    of an aggregate is not constant.  It does not apply to a value    which is not a constructor.       OFWHAT is a character string describing the object being initialized,    for error messages.  It might be "variable" or "variable.member"    or "variable[17].member[5]".  If OFWHAT is null, the description string    is stored on the spelling stack.  */
end_comment

begin_function
specifier|static
name|tree
name|process_init_constructor
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|,
name|elts
parameter_list|,
name|constant_value
parameter_list|,
name|constant_element
parameter_list|,
name|ofwhat
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|,
decl|*
name|elts
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|constant_value
decl_stmt|,
name|constant_element
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ofwhat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
comment|/* List of the elements of the result constructor,      in reverse order.  */
specifier|register
name|tree
name|members
init|=
name|NULL
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|int
name|allconstant
init|=
literal|1
decl_stmt|;
name|int
name|allsimple
init|=
literal|1
decl_stmt|;
name|int
name|erroneous
init|=
literal|0
decl_stmt|;
name|int
name|depth
init|=
name|SPELLING_DEPTH
argument_list|()
decl_stmt|;
if|if
condition|(
name|ofwhat
condition|)
name|push_string
argument_list|(
name|ofwhat
argument_list|)
expr_stmt|;
comment|/* Make TAIL be the list of elements to use for the initialization,      no matter how the data was given to us.  */
if|if
condition|(
name|elts
condition|)
block|{
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"aggregate has a partly bracketed initializer"
argument_list|)
expr_stmt|;
name|tail
operator|=
operator|*
name|elts
expr_stmt|;
block|}
else|else
name|tail
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Gobble as many elements as needed, and make a constructor or initial value      for each element of this aggregate.  Chain them together in result.      If there are too few, use 0 for each scalar ultimate component.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|min_index
decl_stmt|,
name|max_index
decl_stmt|;
comment|/* These are non-zero only within a range initializer.  */
name|tree
name|start_index
init|=
literal|0
decl_stmt|,
name|end_index
init|=
literal|0
decl_stmt|;
comment|/* Within a range, this is the value for the elts in the range.  */
name|tree
name|range_val
init|=
literal|0
decl_stmt|;
comment|/* Do arithmetic using double integers, but don't use fold/build, 	 because these allocate a new tree object everytime they are called, 	 thus resulting in gcc using too much memory for large 	 initializers.  */
name|union
name|tree_node
name|current_index_node
decl_stmt|,
name|members_index_node
decl_stmt|;
name|tree
name|current_index
init|=
operator|&
name|current_index_node
decl_stmt|;
name|tree
name|members_index
init|=
operator|&
name|members_index_node
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|current_index
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|members_index
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
comment|/* If we have array bounds, set our bounds from that.  Otherwise, 	 we have a lower bound of zero and an unknown upper bound.  */
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|min_index
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|max_index
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_index
operator|=
name|integer_zero_node
expr_stmt|;
name|max_index
operator|=
literal|0
expr_stmt|;
block|}
name|TREE_INT_CST_LOW
argument_list|(
name|members_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|min_index
argument_list|)
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|members_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|min_index
argument_list|)
expr_stmt|;
comment|/* Don't leave the loop based on index if the next item has an explicit 	 index value that will override it. */
for|for
control|(
name|TREE_INT_CST_LOW
argument_list|(
name|current_index
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|min_index
argument_list|)
operator|,
name|TREE_INT_CST_HIGH
argument_list|(
name|current_index
argument_list|)
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|min_index
argument_list|)
init|;
name|tail
operator|!=
literal|0
operator|||
name|end_index
condition|;
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|current_index
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|current_index
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|current_index
argument_list|)
argument_list|,
operator|&
name|TREE_INT_CST_HIGH
argument_list|(
name|current_index
argument_list|)
argument_list|)
control|)
block|{
specifier|register
name|tree
name|next1
init|=
literal|0
decl_stmt|;
comment|/* Handle the case where we are inside of a range. 	     current_index increments through the range, 	     so just keep reusing the same element of TAIL 	     until the end of the range.  */
if|if
condition|(
name|end_index
operator|!=
literal|0
condition|)
block|{
name|next1
operator|=
name|range_val
expr_stmt|;
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|current_index
argument_list|,
name|end_index
argument_list|)
condition|)
name|end_index
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this element specifies an index, 	     move to that index before storing it in the new list.  */
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|win
init|=
literal|0
decl_stmt|;
name|tree
name|index
init|=
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|NOP_EXPR
operator|)
condition|)
name|index
operator|=
name|TREE_OPERAND
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Begin a range.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|start_index
operator|=
name|TREE_PURPOSE
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|end_index
operator|=
name|TREE_PURPOSE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expose constants.  It Doesn't matter if we change 		     the mode.*/
if|if
condition|(
name|end_index
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|end_index
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|end_index
argument_list|)
operator|==
name|NOP_EXPR
operator|)
condition|)
name|end_index
operator|=
name|TREE_OPERAND
argument_list|(
name|end_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_index
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|start_index
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|start_index
argument_list|)
operator|==
name|NOP_EXPR
operator|)
condition|)
name|start_index
operator|=
name|TREE_OPERAND
argument_list|(
name|start_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|start_index
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|end_index
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
name|error
argument_list|(
literal|"field name used as index in array initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|start_index
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|end_index
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
name|error
argument_list|(
literal|"non-constant array index in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|start_index
argument_list|,
name|min_index
argument_list|)
operator|||
operator|(
name|max_index
operator|&&
name|tree_int_cst_lt
argument_list|(
name|max_index
argument_list|,
name|start_index
argument_list|)
operator|)
operator|||
name|tree_int_cst_lt
argument_list|(
name|end_index
argument_list|,
name|min_index
argument_list|)
operator|||
operator|(
name|max_index
operator|&&
name|tree_int_cst_lt
argument_list|(
name|max_index
argument_list|,
name|end_index
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"array index out of range in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|end_index
argument_list|,
name|start_index
argument_list|)
condition|)
block|{
comment|/* If the range is empty, don't initialize any elements, 			 but do reset current_index for the next initializer 			 element.  */
name|warning
argument_list|(
literal|"empty array initializer range"
argument_list|)
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|current_index
operator|=
name|end_index
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|current_index
operator|=
name|start_index
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
comment|/* See if the first element is also the last.  */
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|current_index
argument_list|,
name|end_index
argument_list|)
condition|)
name|end_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"field name used as index in array initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"non-constant array index in initializer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|index
argument_list|,
name|min_index
argument_list|)
operator|||
operator|(
name|max_index
operator|&&
name|tree_int_cst_lt
argument_list|(
name|max_index
argument_list|,
name|index
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"array index out of range in initializer"
argument_list|)
expr_stmt|;
else|else
name|current_index
operator|=
name|index
operator|,
name|win
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
block|{
comment|/* If there was an error, end the current range.  */
name|end_index
operator|=
literal|0
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|max_index
operator|&&
name|tree_int_cst_lt
argument_list|(
name|max_index
argument_list|,
name|current_index
argument_list|)
condition|)
break|break;
comment|/* Stop if we've indeed run out of elements. */
comment|/* Now digest the value specified.  */
if|if
condition|(
name|next1
operator|!=
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
comment|/* Build the element of this array, with "[]" notation.  For 		 error messages, we assume that the index fits within a 		 host int.  */
name|SAVE_SPELLING_DEPTH
argument_list|(
argument|{ 		  push_array_bounds (TREE_INT_CST_LOW (current_index)); 		  next1 = digest_init (TYPE_MAIN_VARIANT (TREE_TYPE (type)), 				       TREE_VALUE (tail),&tail1,
comment|/* Both of these are the same because 					  a value here is an elt overall.  */
argument|constant_element, constant_element, 				       NULL_PTR); 		}
argument_list|)
empty_stmt|;
if|if
condition|(
name|tail1
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|tail1
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_init
argument_list|(
literal|"non-empty initializer for array%s of empty elements"
argument_list|,
literal|" `%s'"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Just ignore what we were supposed to use.  */
name|tail1
operator|=
literal|0
expr_stmt|;
block|}
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_index
operator|!=
literal|0
condition|)
name|range_val
operator|=
name|next1
expr_stmt|;
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|,
name|TREE_TYPE
argument_list|(
name|next1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
comment|/* Now store NEXT1 in the list, I elements from the *end*. 	     Make the list longer if necessary.  */
while|while
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|current_index
argument_list|,
name|members_index
argument_list|)
condition|)
block|{
if|if
condition|(
name|free_tree_list
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|members
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|members
operator|=
name|free_tree_list
expr_stmt|;
name|free_tree_list
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|members
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|members
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|members_index
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|members_index
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|members_index
argument_list|)
argument_list|,
operator|&
name|TREE_INT_CST_HIGH
argument_list|(
name|members_index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|tree
name|temp
decl_stmt|;
name|union
name|tree_node
name|idx_node
decl_stmt|;
name|tree
name|idx
init|=
operator|&
name|idx_node
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|idx
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|temp
operator|=
name|members
expr_stmt|;
for|for
control|(
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|members_index
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|members_index
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|idx
argument_list|)
argument_list|,
operator|&
name|TREE_INT_CST_HIGH
argument_list|(
name|idx
argument_list|)
argument_list|)
init|;
name|tree_int_cst_lt
argument_list|(
name|current_index
argument_list|,
name|idx
argument_list|)
condition|;
name|add_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|idx
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|idx
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|idx
argument_list|)
argument_list|,
operator|&
name|TREE_INT_CST_HIGH
argument_list|(
name|idx
argument_list|)
argument_list|)
control|)
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
operator|=
name|next1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
specifier|register
name|tree
name|field
decl_stmt|;
name|int
name|members_length
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't leave the loop based on field just yet; see if next item 	 overrides the expected field first. */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|tail
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|next1
decl_stmt|;
comment|/* If this element specifies a field,  	     move to that field before storing it in the new list.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|win
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"index value instead of field name in structure initializer"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|temp
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|,
name|j
operator|=
literal|0
init|;
name|temp
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
operator|,
name|j
operator|++
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|temp
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
condition|)
break|break;
if|if
condition|(
name|temp
condition|)
name|field
operator|=
name|temp
operator|,
name|i
operator|=
name|j
operator|,
name|win
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no field `%s' in structure being initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|==
literal|0
condition|)
break|break;
comment|/* No more fields to init. */
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|next1
operator|=
name|integer_zero_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
comment|/* Build the name of this member, with a "." for membership.  */
name|SAVE_SPELLING_DEPTH
argument_list|(
argument|{ 		  push_member_name (IDENTIFIER_POINTER (DECL_NAME (field))); 		  next1 = digest_init (TREE_TYPE (field), 				       TREE_VALUE (tail),&tail1, 				       constant_element, constant_element, 				       NULL_PTR); 		}
argument_list|)
empty_stmt|;
if|if
condition|(
name|tail1
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|,
name|TREE_TYPE
argument_list|(
name|next1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
comment|/* Now store NEXT1 in the list, I elements from the *end*. 	     Make the list longer if necessary.  */
while|while
condition|(
name|i
operator|>=
name|members_length
condition|)
block|{
if|if
condition|(
name|free_tree_list
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|members
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|members
operator|=
name|free_tree_list
expr_stmt|;
name|free_tree_list
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|members
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|members
argument_list|)
expr_stmt|;
name|members_length
operator|++
expr_stmt|;
block|}
block|{
name|tree
name|temp
decl_stmt|;
name|int
name|j
decl_stmt|;
name|temp
operator|=
name|members
expr_stmt|;
for|for
control|(
name|j
operator|=
name|members_length
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|temp
argument_list|)
operator|=
name|next1
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|temp
argument_list|)
operator|=
name|field
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
specifier|register
name|tree
name|field
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|next1
decl_stmt|;
comment|/* Find the first named field.  ANSI decided in September 1990 	 that only named fields count here.  */
while|while
condition|(
name|field
operator|&&
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* For a union, get the initializer for 1 fld.  */
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"empty initializer for union"
argument_list|)
expr_stmt|;
name|tail
operator|=
name|build_tree_list
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this element specifies a field, initialize via that field.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|win
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
comment|/* Handle the case of a call by build_c_cast.  */
name|field
operator|=
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|,
name|win
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|error
argument_list|(
literal|"index value instead of field name in union initializer"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|temp
condition|;
name|temp
operator|=
name|TREE_CHAIN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|temp
argument_list|)
operator|==
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
condition|)
break|break;
if|if
condition|(
name|temp
condition|)
name|field
operator|=
name|temp
operator|,
name|win
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no field `%s' in union being initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|tail1
init|=
name|tail
decl_stmt|;
comment|/* Build the name of this member, with a "." for membership.  */
name|SAVE_SPELLING_DEPTH
argument_list|(
argument|{ 	      push_member_name (IDENTIFIER_POINTER (DECL_NAME (field))); 	      next1 = digest_init (TREE_TYPE (field), 				   TREE_VALUE (tail),&tail1, 				   constant_value, constant_element, NULL_PTR); 	    }
argument_list|)
empty_stmt|;
if|if
condition|(
name|tail1
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|tail1
argument_list|)
operator|!=
name|TREE_LIST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tail
operator|=
name|tail1
expr_stmt|;
block|}
else|else
block|{
name|next1
operator|=
name|error_mark_node
expr_stmt|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next1
operator|==
name|error_mark_node
condition|)
name|erroneous
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|next1
argument_list|)
condition|)
name|allconstant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|initializer_constant_valid_p
argument_list|(
name|next1
argument_list|,
name|TREE_TYPE
argument_list|(
name|next1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|allsimple
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|free_tree_list
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|members
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|field
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|free_tree_list
argument_list|)
operator|=
name|next1
expr_stmt|;
name|members
operator|=
name|free_tree_list
expr_stmt|;
name|free_tree_list
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|members
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|next1
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
comment|/* If arguments were specified as a list, just remove the ones we used.  */
if|if
condition|(
name|elts
condition|)
operator|*
name|elts
operator|=
name|tail
expr_stmt|;
comment|/* If arguments were specified as a constructor,      complain unless we used all the elements of the constructor.  */
elseif|else
if|if
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in union initializer%s"
argument_list|,
literal|" after `%s'"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pedwarn_init
argument_list|(
literal|"excess elements in aggregate initializer%s"
argument_list|,
literal|" after `%s'"
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* It might be possible to use SAVE_SPELLING_DEPTH, but I suspect that      some preprocessor somewhere won't accept that much text as an argument.      It's also likely to make debugging difficult.  */
name|RESTORE_SPELLING_DEPTH
argument_list|(
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|erroneous
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|elts
condition|)
name|result
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|type
argument_list|,
name|NULL_TREE
argument_list|,
name|nreverse
argument_list|(
name|members
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|=
name|init
expr_stmt|;
name|CONSTRUCTOR_ELTS
argument_list|(
name|result
argument_list|)
operator|=
name|nreverse
argument_list|(
name|members
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|result
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|allconstant
condition|)
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|allconstant
operator|&&
name|allsimple
condition|)
name|TREE_STATIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Expand an ASM statement with operands, handling output operands    that are not variables or INDIRECT_REFS by transforming such    cases into cases that expand_asm_operands can handle.     Arguments are same as for expand_asm_operands.  */
end_comment

begin_function
name|void
name|c_expand_asm_operands
parameter_list|(
name|string
parameter_list|,
name|outputs
parameter_list|,
name|inputs
parameter_list|,
name|clobbers
parameter_list|,
name|vol
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
name|tree
name|string
decl_stmt|,
name|outputs
decl_stmt|,
name|inputs
decl_stmt|,
name|clobbers
decl_stmt|;
name|int
name|vol
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|outputs
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* o[I] is the place that output number I should be written.  */
specifier|register
name|tree
modifier|*
name|o
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|string
operator|=
name|TREE_OPERAND
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|string
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"asm template is not a string constant"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Record the contents of OUTPUTS before it is modified.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
name|o
index|[
name|i
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Perform default conversions on array and function inputs.  */
comment|/* Don't do this for other types--      it would screw up operands expected to be in memory.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|inputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the ASM_OPERANDS insn;      store into the TREE_VALUEs of OUTPUTS some trees for      where the values were actually stored.  */
name|expand_asm_operands
argument_list|(
name|string
argument_list|,
name|outputs
argument_list|,
name|inputs
argument_list|,
name|clobbers
argument_list|,
name|vol
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Copy all the intermediate outputs into the specified outputs.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|outputs
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
name|i
index|]
operator|!=
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|expand_expr
argument_list|(
name|build_modify_expr
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
name|NOP_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
comment|/* Detect modification of read-only values. 	 (Otherwise done by build_modify_expr.)  */
else|else
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|o
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|readonly_warning
argument_list|(
name|o
index|[
name|i
index|]
argument_list|,
literal|"modification by `asm'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Those MODIFY_EXPRs could do autoincrements.  */
name|emit_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand a C `return' statement.    RETVAL is the expression for what to return,    or a null pointer for `return;' with no value.  */
end_comment

begin_function
name|void
name|c_expand_return
parameter_list|(
name|retval
parameter_list|)
name|tree
name|retval
decl_stmt|;
block|{
name|tree
name|valtype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function declared `volatile' has a `return' statement"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn_return_type
operator|&&
name|valtype
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|warning
argument_list|(
literal|"`return' with no value, in function returning non-void"
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|current_function_returns_null
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
condition|)
name|pedwarn
argument_list|(
literal|"`return' with a value, in function returning void"
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|convert_for_assignment
argument_list|(
name|valtype
argument_list|,
name|retval
argument_list|,
literal|"return"
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|res
init|=
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|res
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|res
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|expand_return
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_function_returns_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a C switch statement, testing expression EXP.    Return EXP if it is valid, an error node otherwise.  */
end_comment

begin_function
name|tree
name|c_expand_start_case
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|INTEGER_TYPE
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|code
operator|!=
name|ERROR_MARK
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|tree
name|index
decl_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_traditional
operator|&&
operator|(
name|type
operator|==
name|long_integer_type_node
operator|||
name|type
operator|==
name|long_unsigned_type_node
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"`long' switch expression not converted to `int' in ANSI C"
argument_list|)
expr_stmt|;
name|exp
operator|=
name|default_conversion
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|index
operator|=
name|get_unwidened
argument_list|(
name|exp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned, 	 because if we did, int_fits_type_p would do the wrong thing 	 when checking case values for being in range, 	 and it's too hard to do the right thing.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|index
expr_stmt|;
block|}
name|expand_start_case
argument_list|(
literal|1
argument_list|,
name|exp
argument_list|,
name|type
argument_list|,
literal|"switch statement"
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

end_unit

