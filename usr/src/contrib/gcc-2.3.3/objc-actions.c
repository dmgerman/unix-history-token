begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implement classes and message passing for Objective C.    Copyright (C) 1992 Free Software Foundation, Inc.    Author: Steve Naroff.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  *      Purpose: This module implements the Objective-C 4.0 language.  *  *      compatibility issues (with the Stepstone translator):  *  *	- does not recognize the following 3.3 constructs.  *	  @requires, @classes, @messages, = (...)  *	- methods with variable arguments must conform to ANSI standard.  *	- tagged structure definitions that appear in BOTH the interface  *	  and implementation are not allowed.  *      - public/private: all instance variables are public within the  *        context of the implementation...I consider this to be a bug in  *        the translator.  *      - statically allocated objects are not supported. the user will  *        receive an error if this service is requested.  *  *      code generation `options':  *  *      - OBJC_INT_SELECTORS, OBJC_SELECTORS_WITHOUT_LABELS, NEXT_OBJC_RUNTIME  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"objc-actions.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_comment
comment|/* The GNU run time requires the selectors in a vector    so it can store the operation numbers in them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NEXT_OBJC_RUNTIME
end_ifndef

begin_define
define|#
directive|define
name|OBJC_SELECTORS_WITHOUT_LABELS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Define the special tree codes that we use.  */
end_comment

begin_comment
comment|/* Table indexed by tree code giving a string containing a character    classifying the tree code.  Possibilities are    t, d, s, c, r,<, 1 and 2.  See objc-tree.def for details.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|TYPE,
end_define

begin_decl_stmt
name|char
modifier|*
name|objc_tree_code_type
index|[]
init|=
block|{
literal|"x"
block|,
include|#
directive|include
file|"objc-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|LENGTH,
end_define

begin_decl_stmt
name|int
name|objc_tree_code_length
index|[]
init|=
block|{
literal|0
block|,
include|#
directive|include
file|"objc-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Names of tree components.    Used for printing out the tree and error messages.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
name|char
modifier|*
name|objc_tree_code_name
index|[]
init|=
block|{
literal|"@@dummy"
block|,
include|#
directive|include
file|"objc-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_escape
end_escape

begin_comment
comment|/* Set up for use of obstacks.  */
end_comment

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* This obstack is used to accumulate the encoding of a data type.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|util_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to the beginning of obstack contents,    so we can free the whole contents.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|util_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for encode_method_def */
end_comment

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_define
define|#
directive|define
name|OBJC_VERSION
value|2
end_define

begin_define
define|#
directive|define
name|NULLT
value|(tree) 0
end_define

begin_define
define|#
directive|define
name|OBJC_ENCODE_INLINE_DEFS
value|0
end_define

begin_define
define|#
directive|define
name|OBJC_ENCODE_DONT_INLINE_DEFS
value|1
end_define

begin_comment
comment|/*** Private Interface (procedures) ***/
end_comment

begin_comment
comment|/* code generation */
end_comment

begin_function_decl
specifier|static
name|void
name|synth_module_prologue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_module_descriptor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|init_module_descriptor
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_module_entry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_objc_method_call
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_message_selector_pool
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_selector_translation_table
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_ivar_chain
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_ivar_template
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_method_template
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_private_template
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_class_template
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_category_template
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_super_template
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|synth_forward_declarations
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_ivar_lists
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_dispatch_tables
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|generate_shared_structures
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_msg_pool_reference
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|init_selector
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_keword_selector
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|synth_id_with_class_suffix
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* misc. bookkeeping */
end_comment

begin_typedef
typedef|typedef
name|struct
name|hashedEntry
modifier|*
name|hash
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|hashedAttribute
modifier|*
name|attr
typedef|;
end_typedef

begin_struct
struct|struct
name|hashedAttribute
block|{
name|attr
name|next
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hashedEntry
block|{
name|attr
name|list
decl_stmt|;
name|hash
name|next
decl_stmt|;
name|tree
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|hash_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_enter
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hash
name|hash_lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_add_attr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_method
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_instance_method_static
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_class_method_static
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|add_class
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_selector_reference
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_class_reference
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_objc_string
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* type encoding */
end_comment

begin_function_decl
specifier|static
name|void
name|encode_aggregate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_bitfield
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_field_decl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|really_start_method
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_method_with_proto
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_proto_with_proto
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_arg_type_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|expr_last
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* utilities for debugging and error diagnostics: */
end_comment

begin_function_decl
specifier|static
name|void
name|warn_with_method
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error_with_method
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error_with_ivar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_method_decl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_declaration
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_declarator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_complex_decl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adorn_decl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_interfaces
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*** Private Interface (data) ***/
end_comment

begin_comment
comment|/* reserved tag definitions: */
end_comment

begin_define
define|#
directive|define
name|TYPE_ID
value|"id"
end_define

begin_define
define|#
directive|define
name|TAG_OBJECT
value|"objc_object"
end_define

begin_define
define|#
directive|define
name|TAG_CLASS
value|"objc_class"
end_define

begin_define
define|#
directive|define
name|TAG_SUPER
value|"objc_super"
end_define

begin_define
define|#
directive|define
name|TAG_SELECTOR
value|"objc_selector"
end_define

begin_define
define|#
directive|define
name|_TAG_CLASS
value|"_objc_class"
end_define

begin_define
define|#
directive|define
name|_TAG_IVAR
value|"_objc_ivar"
end_define

begin_define
define|#
directive|define
name|_TAG_IVAR_LIST
value|"_objc_ivar_list"
end_define

begin_define
define|#
directive|define
name|_TAG_METHOD
value|"_objc_method"
end_define

begin_define
define|#
directive|define
name|_TAG_METHOD_LIST
value|"_objc_method_list"
end_define

begin_define
define|#
directive|define
name|_TAG_CATEGORY
value|"_objc_category"
end_define

begin_define
define|#
directive|define
name|_TAG_MODULE
value|"_objc_module"
end_define

begin_define
define|#
directive|define
name|_TAG_SYMTAB
value|"_objc_symtab"
end_define

begin_define
define|#
directive|define
name|_TAG_SUPER
value|"_objc_super"
end_define

begin_comment
comment|/* set by `continue_class ()' and checked by `is_public ()' */
end_comment

begin_define
define|#
directive|define
name|TREE_STATIC_TEMPLATE
parameter_list|(
name|record_type
parameter_list|)
value|(TREE_PUBLIC(record_type))
end_define

begin_define
define|#
directive|define
name|TYPED_OBJECT
parameter_list|(
name|type
parameter_list|)
define|\
value|(TREE_CODE (type) == RECORD_TYPE&& TREE_STATIC_TEMPLATE (type))
end_define

begin_comment
comment|/* some commonly used instances of "identifier_node". */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|self_id
decl_stmt|,
name|_cmd_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|self_decl
decl_stmt|,
name|_msg_decl
decl_stmt|,
name|_msgSuper_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_getClass_decl
decl_stmt|,
name|objc_getMetaClass_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|super_type
decl_stmt|,
name|selector_type
decl_stmt|,
name|id_type
decl_stmt|,
name|class_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|instance_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|interface_chain
init|=
name|NULLT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chains to manage selectors that are referenced and defined in the module */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|cls_ref_chain
init|=
name|NULLT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* classes referenced */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|sel_ref_chain
init|=
name|NULLT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* selectors referenced */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|sel_refdef_chain
init|=
name|NULLT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* selectors references& defined */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_selector_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total # of selector referenced */
end_comment

begin_comment
comment|/* hash tables to manage the global pool of method prototypes */
end_comment

begin_decl_stmt
specifier|static
name|hash
modifier|*
name|nst_method_hash_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hash
modifier|*
name|cls_method_hash_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the following are used when compiling a class implementation.  *  * implementation_template will normally be an anInterface, however if  * none exists this will be equal to implementation_context...it is  * set in start_class.  */
end_comment

begin_comment
comment|/* backend data declarations */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|_OBJC_SYMBOLS_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_OBJC_INSTANCE_VARIABLES_decl
decl_stmt|,
name|_OBJC_CLASS_VARIABLES_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_OBJC_INSTANCE_METHODS_decl
decl_stmt|,
name|_OBJC_CLASS_METHODS_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_OBJC_CLASS_decl
decl_stmt|,
name|_OBJC_METACLASS_decl
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJC_SELECTORS_WITHOUT_LABELS
end_ifdef

begin_decl_stmt
specifier|static
name|tree
name|_OBJC_SELECTOR_REFERENCES_decl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|_OBJC_MODULES_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_OBJC_STRINGS_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|implementation_context
init|=
name|NULLT
decl_stmt|,
name|implementation_template
init|=
name|NULLT
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|imp_entry
block|{
name|struct
name|imp_entry
modifier|*
name|next
decl_stmt|;
name|tree
name|imp_context
decl_stmt|;
name|tree
name|imp_template
decl_stmt|;
name|tree
name|class_decl
decl_stmt|;
comment|/* _OBJC_CLASS_<my_name>; */
name|tree
name|meta_decl
decl_stmt|;
comment|/* _OBJC_METACLASS_<my_name>; */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|imp_entry
modifier|*
name|imp_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|imp_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `@implementation' */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cat_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `@category' */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|objc_class_template
decl_stmt|,
name|objc_category_template
decl_stmt|,
name|_PRIVATE_record
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_clsSuper_ref
decl_stmt|,
name|__clsSuper_ref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_method_template
decl_stmt|,
name|objc_ivar_template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_symtab_template
decl_stmt|,
name|objc_module_template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_super_template
decl_stmt|,
name|objc_object_reference
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|objc_object_id
decl_stmt|,
name|objc_class_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|_OBJC_SUPER_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|method_context
init|=
name|NULLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|method_slot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by start_method_def */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|512
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a buffer for error diagnostics */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|tree
name|groktypename_in_parm_context
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|,
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data imported from toplev.c  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dump_base_name
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Open and close the file for outputting class declarations, if requested.  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_declaration
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|gen_declaration_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if multiple methods are seen for the same selector, but with    different argument types. */
end_comment

begin_decl_stmt
name|int
name|warn_selector
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|lang_init
parameter_list|()
block|{
comment|/* the beginning of the file is a new line; check for # */
comment|/* With luck, we discover the real source file's name from that      and put it in input_filename.  */
name|ungetc
argument_list|(
name|check_newline
argument_list|()
argument_list|,
name|finput
argument_list|)
expr_stmt|;
comment|/* If gen_declaration desired, open the output file.  */
if|if
condition|(
name|flag_gen_declaration
condition|)
block|{
name|int
name|dump_base_name_length
init|=
name|strlen
argument_list|(
name|dump_base_name
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dumpname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dump_base_name_length
operator|+
literal|7
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dumpname
argument_list|,
name|dump_base_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dumpname
argument_list|,
literal|".decl"
argument_list|)
expr_stmt|;
name|gen_declaration_file
operator|=
name|fopen
argument_list|(
name|dumpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen_declaration_file
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doing_objc_thang
condition|)
name|init_objc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_finish
parameter_list|()
block|{
if|if
condition|(
name|doing_objc_thang
condition|)
name|finish_objc
argument_list|()
expr_stmt|;
comment|/* Objective-C finalization */
if|if
condition|(
name|gen_declaration_file
condition|)
name|fclose
argument_list|(
name|gen_declaration_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_finish
parameter_list|()
block|{ }
end_function

begin_function
name|int
name|lang_decode_option
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-lang-objc"
argument_list|)
condition|)
name|doing_objc_thang
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-gen-decls"
argument_list|)
condition|)
name|flag_gen_declaration
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wselector"
argument_list|)
condition|)
name|warn_selector
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-selector"
argument_list|)
condition|)
name|warn_selector
operator|=
literal|0
expr_stmt|;
else|else
return|return
name|c_decode_option
argument_list|(
name|p
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|define_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|)
name|tree
name|declarator
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|start_decl
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULLT
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/*  * rules for statically typed objects...called from `c-typeck.comptypes'.  *  * an assignment of the form `a' = `b' is permitted if:  *  *   - `a' is of type "id".  *   - `a' and `b' are the same class type.  *   - `a' and `b' are of class types A and B such that B is a descendant  *     of A.  */
end_comment

begin_function
name|int
name|maybe_objc_comptypes
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
block|{
if|if
condition|(
name|doing_objc_thang
condition|)
return|return
name|objc_comptypes
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|objc_comptypes
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|tree
name|lhs
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
block|{
comment|/* `id' = `<class> *', `<class> *' = `id' */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_object_id
operator|&&
name|TYPED_OBJECT
argument_list|(
name|rhs
argument_list|)
operator|)
operator|||
operator|(
name|TYPED_OBJECT
argument_list|(
name|lhs
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_object_id
operator|)
condition|)
return|return
literal|1
return|;
comment|/* `id' = `Class', `Class' = `id' */
elseif|else
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_object_id
operator|&&
name|TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_class_id
operator|)
operator|||
operator|(
name|TYPE_NAME
argument_list|(
name|lhs
argument_list|)
operator|==
name|objc_class_id
operator|&&
name|TYPE_NAME
argument_list|(
name|rhs
argument_list|)
operator|==
name|objc_object_id
operator|)
condition|)
return|return
literal|1
return|;
comment|/* `<class> *' = `<class> *' */
elseif|else
if|if
condition|(
name|TYPED_OBJECT
argument_list|(
name|lhs
argument_list|)
operator|&&
name|TYPED_OBJECT
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|tree
name|lname
init|=
name|TYPE_NAME
argument_list|(
name|lhs
argument_list|)
decl_stmt|,
name|rname
init|=
name|TYPE_NAME
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|lname
operator|==
name|rname
condition|)
return|return
literal|1
return|;
else|else
block|{
comment|/* if the left hand side is a super class of the right hand side, 	     allow it... 	     */
name|tree
name|rinter
init|=
name|lookup_interface
argument_list|(
name|rname
argument_list|)
decl_stmt|;
while|while
condition|(
name|rinter
condition|)
block|{
if|if
condition|(
name|lname
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|rinter
argument_list|)
condition|)
return|return
literal|1
return|;
name|rinter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|rinter
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called from c-decl.c before all calls to rest_of_decl_compilation.  */
end_comment

begin_function
name|void
name|maybe_objc_check_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|doing_objc_thang
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|objc_check_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|static
name|int
name|alreadyWarned
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_STATIC_TEMPLATE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|alreadyWarned
condition|)
block|{
name|error
argument_list|(
literal|"GNU compiler does not support statically allocated objects"
argument_list|)
expr_stmt|;
name|alreadyWarned
operator|=
literal|1
expr_stmt|;
block|}
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' cannot be statically allocated"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* implement static typing. at this point, we know we have an interface... */
end_comment

begin_function
name|tree
name|get_static_reference
parameter_list|(
name|interface
parameter_list|)
name|tree
name|interface
decl_stmt|;
block|{
return|return
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create and push a decl for a built-in external variable or field NAME.    CODE says which.    TYPE is its data type.  */
end_comment

begin_function
specifier|static
name|tree
name|create_builtin_decl
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|VAR_DECL
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/*  *	purpose: "play" parser, creating/installing representations  *		 of the declarations that are required by Objective-C.  *  *	model:  *  *		type_spec--------->sc_spec  *		(tree_list)        (tree_list)  *		    |                  |  *		    |                  |  *		identifier_node    identifier_node  */
end_comment

begin_function
specifier|static
name|void
name|synth_module_prologue
parameter_list|()
block|{
name|tree
name|expr_decl
decl_stmt|,
name|temp_type
decl_stmt|;
comment|/* defined in `objc.h' */
name|objc_object_id
operator|=
name|get_identifier
argument_list|(
name|TAG_OBJECT
argument_list|)
expr_stmt|;
name|objc_object_reference
operator|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_object_id
argument_list|)
expr_stmt|;
name|id_type
operator|=
name|build_pointer_type
argument_list|(
name|objc_object_reference
argument_list|)
expr_stmt|;
name|objc_class_id
operator|=
name|get_identifier
argument_list|(
name|TAG_CLASS
argument_list|)
expr_stmt|;
name|class_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_class_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Declare type of selector-objects that represent an operation name.  */
ifdef|#
directive|ifdef
name|OBJC_INT_SELECTORS
comment|/* `unsigned int' */
name|selector_type
operator|=
name|unsigned_type_node
expr_stmt|;
else|#
directive|else
comment|/* `struct objc_selector *' */
name|selector_type
operator|=
name|build_pointer_type
argument_list|(
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not OBJC_INT_SELECTORS */
comment|/* struct objc_object *objc_msgSend (id, SEL, ...); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|selector_type
argument_list|,
name|NULLT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|_msg_decl
operator|=
name|builtin_function
argument_list|(
literal|"objc_msgSend"
argument_list|,
name|temp_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* struct objc_object *objc_msgSendSuper (void *, SEL, ...); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|selector_type
argument_list|,
name|NULLT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|_msgSuper_decl
operator|=
name|builtin_function
argument_list|(
literal|"objc_msgSendSuper"
argument_list|,
name|temp_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* id objc_getClass (); */
name|temp_type
operator|=
name|build_function_type
argument_list|(
name|id_type
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|objc_getClass_decl
operator|=
name|builtin_function
argument_list|(
literal|"objc_getClass"
argument_list|,
name|temp_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* id objc_getMetaClass (); */
name|objc_getMetaClass_decl
operator|=
name|builtin_function
argument_list|(
literal|"objc_getMetaClass"
argument_list|,
name|temp_type
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* extern SEL _OBJC_SELECTOR_REFERENCES[]; */
ifdef|#
directive|ifdef
name|OBJC_SELECTORS_WITHOUT_LABELS
name|_OBJC_SELECTOR_REFERENCES_decl
operator|=
name|create_builtin_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|build_array_type
argument_list|(
name|selector_type
argument_list|,
name|NULLT
argument_list|)
argument_list|,
literal|"_OBJC_SELECTOR_REFERENCES"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * custom "build_string ()" which sets TREE_TYPE!  */
end_comment

begin_function
specifier|static
name|tree
name|my_build_string
parameter_list|(
name|len
parameter_list|,
name|str
parameter_list|)
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|tree
name|aString
init|=
name|build_string
argument_list|(
name|len
argument_list|,
name|str
argument_list|)
decl_stmt|;
comment|/*    *  some code from "combine_strings ()", which is local to c-parse.y.    */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|aString
argument_list|)
operator|==
name|int_array_type_node
condition|)
name|wide_flag
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|aString
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|wide_flag
condition|?
name|integer_type_node
else|:
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|len
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|aString
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* puts string in the ".text" segment */
name|TREE_STATIC
argument_list|(
name|aString
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|aString
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take care of defining and initializing _OBJC_SYMBOLS.  */
end_comment

begin_comment
comment|/* Predefine the following data type:  	struct _objc_symtab { 		long sel_ref_cnt; 		SEL *refs; 		short cls_def_cnt; 		short cat_def_cnt; 		void *defs[cls_def_cnt + cat_def_cnt]; 	}; */
end_comment

begin_function
specifier|static
name|void
name|build_objc_symtab_template
parameter_list|()
block|{
name|tree
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|,
name|index
decl_stmt|;
name|objc_symtab_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_SYMTAB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* long sel_ref_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|long_integer_type_node
argument_list|,
literal|"sel_ref_cnt"
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* SEL *refs; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_pointer_type
argument_list|(
name|selector_type
argument_list|)
argument_list|,
literal|"refs"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* short cls_def_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|short_integer_type_node
argument_list|,
literal|"cls_def_cnt"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* short cat_def_cnt; */
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|short_integer_type_node
argument_list|,
literal|"cat_def_cnt"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* void *defs[cls_def_cnt + cat_def_cnt]; */
name|index
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|imp_count
operator|+
name|cat_count
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|create_builtin_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|build_array_type
argument_list|(
name|ptr_type_node
argument_list|,
name|index
argument_list|)
argument_list|,
literal|"defs"
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_symtab_template
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the initial value for the `defs' field of _objc_symtab.    This is a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|tree
name|init_def_list
parameter_list|()
block|{
name|tree
name|expr
decl_stmt|,
name|initlist
init|=
name|NULLT
decl_stmt|;
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
if|if
condition|(
name|imp_count
condition|)
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|impent
operator|->
name|class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cat_count
condition|)
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_TYPE
condition|)
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|impent
operator|->
name|class_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct the initial value for all of _objc_symtab.  */
end_comment

begin_function
specifier|static
name|tree
name|init_objc_symtab
parameter_list|()
block|{
name|tree
name|initlist
decl_stmt|;
comment|/* sel_ref_cnt = { ..., 5, ... } */
if|if
condition|(
name|sel_ref_chain
condition|)
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
name|max_selector_index
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* refs = { ..., _OBJC_SELECTOR_REFERENCES, ... } */
ifndef|#
directive|ifndef
name|OBJC_SELECTORS_WITHOUT_LABELS
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|sel_ref_chain
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|_OBJC_SELECTOR_REFERENCES_decl
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* cls_def_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
name|imp_count
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cat_def_cnt = { ..., 5, ... } */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
name|cat_count
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cls_def = { ..., {&Foo,&Bar, ...}, ... } */
if|if
condition|(
name|imp_count
operator|||
name|cat_count
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|init_def_list
argument_list|()
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push forward-declarations of all the categories    so that init_def_list can use them in a CONSTRUCTOR.  */
end_comment

begin_function
specifier|static
name|void
name|forward_declare_categories
parameter_list|()
block|{
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
name|tree
name|sav
init|=
name|implementation_context
decl_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_TYPE
condition|)
block|{
comment|/* Set an invisible arg to synth_id_with_class_suffix.  */
name|implementation_context
operator|=
name|impent
operator|->
name|imp_context
expr_stmt|;
name|impent
operator|->
name|class_decl
operator|=
name|create_builtin_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|objc_category_template
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|implementation_context
operator|=
name|sav
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the declaration of _OBJC_SYMBOLS, with type `strict _objc_symtab'    and initialized appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|generate_objc_symtab_decl
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|;
if|if
condition|(
operator|!
name|objc_category_template
condition|)
name|build_category_template
argument_list|()
expr_stmt|;
comment|/* forward declare categories */
if|if
condition|(
name|cat_count
condition|)
name|forward_declare_categories
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|objc_symtab_template
condition|)
name|build_objc_symtab_template
argument_list|()
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
name|_OBJC_SYMBOLS_decl
operator|=
name|start_decl
argument_list|(
name|get_identifier
argument_list|(
literal|"_OBJC_SYMBOLS"
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|objc_symtab_template
argument_list|,
name|sc_spec
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|_OBJC_SYMBOLS_decl
argument_list|,
name|init_objc_symtab
argument_list|()
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	tree_node------->tree_node----->...  *          |                |  *          | (value)        | (value)  *          |                |  *	  expr             expr  */
end_comment

begin_function
specifier|static
name|tree
name|init_module_descriptor
parameter_list|()
block|{
name|tree
name|initlist
decl_stmt|,
name|expr
decl_stmt|;
comment|/* version = { 1, ... } */
name|expr
operator|=
name|build_int_2
argument_list|(
name|OBJC_VERSION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|)
expr_stmt|;
comment|/* size = { ..., sizeof (struct objc_module), ... } */
name|expr
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|objc_module_template
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* name = { ..., "foo.m", ... } */
name|expr
operator|=
name|build_msg_pool_reference
argument_list|(
name|add_objc_string
argument_list|(
name|get_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* symtab = { ..., _OBJC_SYMBOLS, ... } */
if|if
condition|(
name|_OBJC_SYMBOLS_decl
condition|)
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|_OBJC_SYMBOLS_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the data structures to describe Objective C classes defined.    If appropriate, compile and output a setup function to initialize them.    Return a string which is the name of a function to call to initialize    the Objective C data structures for this file (and perhaps for other files    also).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_module_descriptor
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_module_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_MODULE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* long version; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"version"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* long  size; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* char  *name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_symtab *symtab; */
name|decl_specs
operator|=
name|get_identifier
argument_list|(
name|_TAG_SYMTAB
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|decl_specs
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"symtab"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_module_template
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
comment|/* create an instance of "objc_module" */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|objc_module_template
argument_list|,
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|_OBJC_MODULES_decl
operator|=
name|start_decl
argument_list|(
name|get_identifier
argument_list|(
literal|"_OBJC_MODULES"
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|_OBJC_MODULES_decl
argument_list|,
name|init_module_descriptor
argument_list|()
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
comment|/* Mark the decl to avoid "defined but not used" warning. */
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|_OBJC_MODULES_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Generate a constructor call for the module descriptor.       This code was generated by reading the grammar rules      of c-parse.y;  Therefore, it may not be the most efficient      way of generating the requisite code. */
ifndef|#
directive|ifndef
name|NEXT_OBJC_RUNTIME
block|{
name|tree
name|parms
decl_stmt|,
name|function_decl
decl_stmt|,
name|decelerator
decl_stmt|,
name|void_list_node
decl_stmt|;
name|tree
name|function_type
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|global_object_name
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* Use a global object (which is already required to be unique over        the program) rather than the file name (which imposes extra        constraints).  -- Raeburn@MIT.EDU, 10 Jan 1990.  */
comment|/* Find the name of some global object defined in this file.  */
for|for
control|(
name|t
operator|=
name|getdecls
argument_list|()
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|global_object_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If none, use the name of the file.  */
if|if
condition|(
operator|!
name|global_object_name
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|global_object_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|main_input_filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|main_input_filename
expr_stmt|;
name|q
operator|=
name|global_object_name
expr_stmt|;
comment|/* Replace any weird characters in the file name.  */
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|'_'
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make the constructor name from the name we have found.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CONSTRUCTOR_NAME_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|global_object_name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|CONSTRUCTOR_NAME_FORMAT
argument_list|,
name|global_object_name
argument_list|)
expr_stmt|;
comment|/* Declare void __objc_execClass (void*); */
name|void_list_node
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|function_type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|function_decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__objc_execClass"
argument_list|)
argument_list|,
name|function_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|function_decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|function_decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|_OBJC_MODULES_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|decelerator
operator|=
name|build_function_call
argument_list|(
name|function_decl
argument_list|,
name|parms
argument_list|)
expr_stmt|;
comment|/* void __objc_file_init () {objc_execClass(&L_OBJC_MODULES);}  */
name|start_function
argument_list|(
name|void_list_node
argument_list|,
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
comment|/* This has the format of the output 					 of get_parm_info.  */
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This should be turned back on later 	 for the systems where collect is not needed.  */
comment|/* Make these functions nonglobal        so each file can use the same name.  */
block|TREE_PUBLIC (current_function_decl) = 0;
endif|#
directive|endif
name|TREE_USED
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|assemble_external
argument_list|(
name|function_decl
argument_list|)
expr_stmt|;
name|c_expand_expr_stmt
argument_list|(
name|decelerator
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Return the name of the constructor function.  */
return|return
name|buf
return|;
block|}
else|#
directive|else
comment|/* NEXT_OBJC_RUNTIME */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* NEXT_OBJC_RUNTIME */
block|}
end_function

begin_comment
comment|/* extern const char _OBJC_STRINGS[]; */
end_comment

begin_function
specifier|static
name|void
name|generate_forward_declaration_to_string_table
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"_OBJC_STRINGS"
argument_list|)
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|_OBJC_STRINGS_decl
operator|=
name|define_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* static char _OBJC_STRINGS[] = "..."; */
end_comment

begin_function
specifier|static
name|void
name|build_message_selector_pool
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|;
name|tree
name|chain
decl_stmt|,
name|string_expr
decl_stmt|;
name|int
name|goolengthtmp
init|=
literal|0
decl_stmt|,
name|msg_pool_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|string_goo
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|expr_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"_OBJC_STRINGS"
argument_list|)
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|_OBJC_STRINGS_decl
operator|=
name|start_decl
argument_list|(
name|expr_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|sel_refdef_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
name|msg_pool_size
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|msg_pool_size
operator|++
expr_stmt|;
name|string_goo
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|msg_pool_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|string_goo
argument_list|,
name|msg_pool_size
argument_list|)
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|sel_refdef_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|strcpy
argument_list|(
name|string_goo
operator|+
name|goolengthtmp
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|goolengthtmp
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|string_expr
operator|=
name|my_build_string
argument_list|(
name|msg_pool_size
argument_list|,
name|string_goo
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|_OBJC_STRINGS_decl
argument_list|,
name|string_expr
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * synthesize the following expr: (char *)&_OBJC_STRINGS[<offset>]  *  * the cast stops the compiler from issuing the following message:  *  * grok.m: warning: initialization of non-const * pointer from const *  * grok.m: warning: initialization between incompatible pointer types  */
end_comment

begin_function
specifier|static
name|tree
name|build_msg_pool_reference
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|tree
name|expr
init|=
name|build_int_2
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|cast
decl_stmt|;
name|expr
operator|=
name|build_array_ref
argument_list|(
name|_OBJC_STRINGS_decl
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|NULLT
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OBJC_SELECTORS_WITHOUT_LABELS
end_ifndef

begin_function
specifier|static
name|tree
name|build_selector_reference
parameter_list|(
name|idx
parameter_list|)
name|int
name|idx
decl_stmt|;
block|{
name|tree
name|ref
decl_stmt|,
name|decl
decl_stmt|,
name|name
decl_stmt|,
name|ident
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|obstack
modifier|*
name|save_current_obstack
init|=
name|current_obstack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|save_rtl_obstack
init|=
name|rtl_obstack
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_SELECTOR_REFERENCES_%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* new stuff */
name|rtl_obstack
operator|=
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|ident
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ident
argument_list|)
condition|)
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|ident
argument_list|)
expr_stmt|;
comment|/* set by pushdecl() */
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|ident
argument_list|,
name|selector_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* usually called from `rest_of_decl_compilation' */
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* our `extended/custom' pushdecl in c-decl.c */
block|}
name|current_obstack
operator|=
name|save_current_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|save_rtl_obstack
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|tree
name|init_selector
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|tree
name|expr
init|=
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|selector_type
expr_stmt|;
comment|/* cast */
return|return
name|expr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_selector_translation_table
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|;
name|tree
name|chain
decl_stmt|,
name|initlist
init|=
name|NULLT
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|OBJC_SELECTORS_WITHOUT_LABELS
name|tree
name|decl
decl_stmt|,
name|var_decl
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
else|#
directive|else
comment|/* The corresponding pop_obstacks is in finish_decl,      called at the end of this function.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|chain
operator|=
name|sel_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|tree
name|expr
decl_stmt|;
ifndef|#
directive|ifndef
name|OBJC_SELECTORS_WITHOUT_LABELS
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_OBJC_SELECTOR_REFERENCES_%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
comment|/* static SEL _OBJC_SELECTOR_REFERENCES_n = ...; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|selector_type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|var_decl
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* the `decl' that is returned from start_decl is the one that we 	* forward declared in `build_selector_reference()' 	*/
name|decl
operator|=
name|start_decl
argument_list|(
name|var_decl
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expr
operator|=
name|init_selector
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* add one for the '\0' character */
name|offset
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJC_SELECTORS_WITHOUT_LABELS
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|expr
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
else|#
directive|else
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OBJC_SELECTORS_WITHOUT_LABELS
comment|/* Cause the variable and its initial value to be actually output.  */
name|DECL_EXTERNAL
argument_list|(
name|_OBJC_SELECTOR_REFERENCES_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|_OBJC_SELECTOR_REFERENCES_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* NULL terminate the list and fix the decl for output. */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|_OBJC_SELECTOR_REFERENCES_decl
argument_list|)
operator|=
operator|(
name|tree
operator|)
literal|1
expr_stmt|;
name|initlist
operator|=
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|_OBJC_SELECTOR_REFERENCES_decl
argument_list|,
name|initlist
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|add_class_reference
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|chain
operator|=
name|cls_ref_chain
condition|)
block|{
name|tree
name|tail
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return;
name|tail
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
comment|/* append to the end of the list */
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ident
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
block|}
else|else
name|cls_ref_chain
operator|=
name|perm_tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ident
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sel_ref_chain is a list whose "value" fields will be instances of  * identifier_node that represent the selector.  */
end_comment

begin_function
specifier|static
name|int
name|add_selector_reference
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
comment|/* this adds it to sel_refdef_chain, the global pool of selectors */
name|add_objc_string
argument_list|(
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|=
name|sel_ref_chain
condition|)
block|{
name|tree
name|tail
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
name|tail
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
comment|/* append to the end of the list */
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ident
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
block|}
else|else
name|sel_ref_chain
operator|=
name|perm_tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ident
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|max_selector_index
operator|++
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/*  * sel_refdef_chain is a list whose "value" fields will be instances of  * identifier_node that represent the selector. It returns the offset of  * the selector from the beginning of the _OBJC_STRINGS pool. This offset  * is typically used by "init_selector ()" during code generation.  */
end_comment

begin_function
specifier|static
name|int
name|add_objc_string
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chain
operator|=
name|sel_refdef_chain
condition|)
block|{
name|tree
name|tail
decl_stmt|;
do|do
block|{
if|if
condition|(
name|ident
operator|==
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|offset
return|;
comment|/* add one for the '\0' character */
name|offset
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|tail
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
comment|/* append to the end of the list */
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|perm_tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ident
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
block|}
else|else
name|sel_refdef_chain
operator|=
name|perm_tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ident
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_function
name|tree
name|lookup_interface
parameter_list|(
name|ident
parameter_list|)
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|interface_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
if|if
condition|(
name|ident
operator|==
name|CLASS_NAME
argument_list|(
name|chain
argument_list|)
condition|)
return|return
name|chain
return|;
block|}
return|return
name|NULLT
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|objc_copy_list
parameter_list|(
name|list
parameter_list|,
name|head
parameter_list|)
name|tree
name|list
decl_stmt|;
name|tree
modifier|*
name|head
decl_stmt|;
block|{
name|tree
name|newlist
init|=
name|NULL_TREE
decl_stmt|,
name|tail
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|tail
operator|=
name|copy_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* the following statement fixes a bug when inheriting instance 	 variables that are declared to be bitfields. finish_struct () expects 	 to find the width of the bitfield in DECL_INITIAL (), which it 	 nulls out after processing the decl of the super class...rather 	 than change the way finish_struct () works (which is risky), 	 I create the situation it expects...s.naroff (7/23/89). 	 */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|tail
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|tail
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|tail
argument_list|)
operator|=
name|build_int_2
argument_list|(
name|DECL_FIELD_SIZE
argument_list|(
name|tail
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newlist
operator|=
name|chainon
argument_list|(
name|newlist
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
operator|*
name|head
operator|=
name|newlist
expr_stmt|;
return|return
name|tail
return|;
block|}
end_function

begin_comment
comment|/* used by:  * build_private_template (), get_class_ivars (), and get_static_reference ().  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_chain
parameter_list|(
name|interface
parameter_list|)
name|tree
name|interface
decl_stmt|;
block|{
name|tree
name|my_name
decl_stmt|,
name|super_name
decl_stmt|,
name|ivar_chain
decl_stmt|;
name|my_name
operator|=
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|super_name
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
comment|/* "leaf" ivars never get copied...there is no reason to. */
name|ivar_chain
operator|=
name|CLASS_IVARS
argument_list|(
name|interface
argument_list|)
expr_stmt|;
while|while
condition|(
name|super_name
condition|)
block|{
name|tree
name|op1
decl_stmt|;
name|tree
name|super_interface
init|=
name|lookup_interface
argument_list|(
name|super_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|super_interface
condition|)
block|{
comment|/* fatal did not work with 2 args...should fix */
name|error
argument_list|(
literal|"Cannot find interface declaration for `%s', superclass of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|my_name
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|34
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|super_interface
operator|==
name|interface
condition|)
block|{
name|fatal
argument_list|(
literal|"Circular inheritance in interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|interface
operator|=
name|super_interface
expr_stmt|;
name|my_name
operator|=
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|super_name
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|op1
operator|=
name|CLASS_IVARS
argument_list|(
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
condition|)
block|{
name|tree
name|head
decl_stmt|,
name|tail
init|=
name|objc_copy_list
argument_list|(
name|op1
argument_list|,
operator|&
name|head
argument_list|)
decl_stmt|;
comment|/* prepend super class ivars...make a copy of the list, we 	   * do not want to alter the original. 	   */
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|ivar_chain
expr_stmt|;
name|ivar_chain
operator|=
name|head
expr_stmt|;
block|}
block|}
return|return
name|ivar_chain
return|;
block|}
end_function

begin_comment
comment|/*  *  struct<classname> {  *    struct objc_class *isa;  *    ...  *  };  */
end_comment

begin_function
specifier|static
name|tree
name|build_private_template
parameter_list|(
name|class
parameter_list|)
name|tree
name|class
decl_stmt|;
block|{
name|tree
name|ivar_context
decl_stmt|;
if|if
condition|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|_PRIVATE_record
operator|=
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|ivar_context
operator|=
name|TYPE_FIELDS
argument_list|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_PRIVATE_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|ivar_context
operator|=
name|build_ivar_chain
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|_PRIVATE_record
argument_list|,
name|ivar_context
argument_list|)
expr_stmt|;
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
operator|=
name|_PRIVATE_record
expr_stmt|;
comment|/* mark this record as class template - for class type checking */
name|TREE_STATIC_TEMPLATE
argument_list|(
name|_PRIVATE_record
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|instance_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|_PRIVATE_record
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|NULLT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ivar_context
return|;
block|}
end_function

begin_comment
comment|/*  *  struct objc_category {  *    char *category_name;  *    char *class_name;  *    struct objc_method_list *instance_methods;  *    struct objc_method_list *class_methods;  *  };  */
end_comment

begin_function
specifier|static
name|void
name|build_category_template
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_category_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_CATEGORY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* char *category_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"category_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *class_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"class_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *instance_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"instance_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *class_methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"class_methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_category_template
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  struct objc_class {  *    struct objc_class *isa;  *    struct objc_class *super_class;  *    char *name;  *    long version;  *    long info;  *    long instance_size;  *    struct objc_ivar_list *ivars;  *    struct objc_method_list *methods;  *    struct objc_cache *cache;  *  };  */
end_comment

begin_function
specifier|static
name|void
name|build_class_template
parameter_list|()
block|{
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_class_template
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_CLASS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_class *isa; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"isa"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_class *super_class; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|objc_class_template
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"super_class"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* char *name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long version; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"version"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long info; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"info"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* long instance_size; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"instance_size"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_ivar_list *ivars; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_IVAR_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"ivars"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method_list *methods; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"methods"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_cache *cache; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
literal|"objc_cache"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"cache"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_class_template
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * generate appropriate forward declarations for an implementation  */
end_comment

begin_function
specifier|static
name|void
name|synth_forward_declarations
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|factory_id
decl_stmt|,
name|anId
decl_stmt|;
comment|/* extern struct objc_class _OBJC_CLASS_<my_name>; */
name|anId
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CLASS"
argument_list|)
expr_stmt|;
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|objc_class_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|_OBJC_CLASS_decl
operator|=
name|define_decl
argument_list|(
name|anId
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
comment|/* extern struct objc_class _OBJC_METACLASS_<my_name>; */
name|anId
operator|=
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_METACLASS"
argument_list|)
expr_stmt|;
name|_OBJC_METACLASS_decl
operator|=
name|define_decl
argument_list|(
name|anId
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
comment|/* pre-build the following entities - for speed/convenience. */
name|anId
operator|=
name|get_identifier
argument_list|(
literal|"super_class"
argument_list|)
expr_stmt|;
name|_clsSuper_ref
operator|=
name|build_component_ref
argument_list|(
name|_OBJC_CLASS_decl
argument_list|,
name|anId
argument_list|)
expr_stmt|;
name|__clsSuper_ref
operator|=
name|build_component_ref
argument_list|(
name|_OBJC_METACLASS_decl
argument_list|,
name|anId
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|error_with_ivar
parameter_list|(
name|message
parameter_list|,
name|decl
parameter_list|,
name|rawdecl
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|rawdecl
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s `%s'\n"
argument_list|,
name|message
argument_list|,
name|gen_declaration
argument_list|(
name|rawdecl
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|USERTYPE
parameter_list|(
name|t
parameter_list|)
value|(TREE_CODE (t) == RECORD_TYPE || \ 			 TREE_CODE (t) == UNION_TYPE ||  \ 			 TREE_CODE (t) == ENUMERAL_TYPE)
end_define

begin_function
specifier|static
name|void
name|check_ivars
parameter_list|(
name|inter
parameter_list|,
name|imp
parameter_list|)
name|tree
name|inter
decl_stmt|;
name|tree
name|imp
decl_stmt|;
block|{
name|tree
name|intdecls
init|=
name|CLASS_IVARS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|impdecls
init|=
name|CLASS_IVARS
argument_list|(
name|imp
argument_list|)
decl_stmt|;
name|tree
name|rawintdecls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|rawimpdecls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|imp
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
name|intdecls
operator|==
literal|0
operator|&&
name|impdecls
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|intdecls
operator|==
literal|0
operator|||
name|impdecls
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"inconsistent instance variable specification"
argument_list|)
expr_stmt|;
break|break;
block|}
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|impdecls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|intdecls
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|impdecls
argument_list|)
condition|)
block|{
name|error_with_ivar
argument_list|(
literal|"conflicting instance variable type"
argument_list|,
name|impdecls
argument_list|,
name|rawimpdecls
argument_list|)
expr_stmt|;
name|error_with_ivar
argument_list|(
literal|"previous declaration of"
argument_list|,
name|intdecls
argument_list|,
name|rawintdecls
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* both the type and the name don't match */
block|{
name|error
argument_list|(
literal|"inconsistent instance variable specification"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_NAME
argument_list|(
name|intdecls
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|impdecls
argument_list|)
condition|)
block|{
name|error_with_ivar
argument_list|(
literal|"conflicting instance variable name"
argument_list|,
name|impdecls
argument_list|,
name|rawimpdecls
argument_list|)
expr_stmt|;
name|error_with_ivar
argument_list|(
literal|"previous declaration of"
argument_list|,
name|intdecls
argument_list|,
name|rawintdecls
argument_list|)
expr_stmt|;
block|}
name|intdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|intdecls
argument_list|)
expr_stmt|;
name|impdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|impdecls
argument_list|)
expr_stmt|;
name|rawintdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|rawintdecls
argument_list|)
expr_stmt|;
name|rawimpdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|rawimpdecls
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set super_type to the data type node for struct objc_super *,    first defining struct objc_super itself.    This needs to be done just once per compilation.  */
end_comment

begin_function
specifier|static
name|tree
name|build_super_template
parameter_list|()
block|{
name|tree
name|record
decl_stmt|,
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_SUPER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* struct objc_object *self; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|objc_object_reference
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_class *class; */
name|decl_specs
operator|=
name|get_identifier
argument_list|(
name|_TAG_CLASS
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|decl_specs
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|record
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
comment|/* `struct objc_super *' */
name|super_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|record
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|NULLT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|record
return|;
block|}
end_function

begin_comment
comment|/*  * 	struct objc_ivar {  *		char *ivar_name;  *		char *ivar_type;  *		int ivar_offset;  *	};  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_template
parameter_list|()
block|{
name|tree
name|objc_ivar_id
decl_stmt|,
name|objc_ivar_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_id
operator|=
name|get_identifier
argument_list|(
name|_TAG_IVAR
argument_list|)
expr_stmt|;
name|objc_ivar_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|objc_ivar_id
argument_list|)
expr_stmt|;
comment|/* char *ivar_name; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_name"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* char *ivar_type; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_type"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* int ivar_offset; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"ivar_offset"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_record
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_record
return|;
block|}
end_function

begin_comment
comment|/*  * 	struct {  *		int ivar_count;  *		struct objc_ivar ivar_list[ivar_count];  *	};  */
end_comment

begin_function
specifier|static
name|tree
name|build_ivar_list_template
parameter_list|(
name|list_type
parameter_list|,
name|size
parameter_list|)
name|tree
name|list_type
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|objc_ivar_list_id
decl_stmt|,
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
comment|/* int ivar_count; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"ivar_count"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* struct objc_ivar ivar_list[]; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|list_type
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"ivar_list"
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_comment
comment|/*  * 	struct {  *		int method_next;  *		int method_count;  *		struct objc_method method_list[method_count];  *	};  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_list_template
parameter_list|(
name|list_type
parameter_list|,
name|size
parameter_list|)
name|tree
name|list_type
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|objc_ivar_list_id
decl_stmt|,
name|objc_ivar_list_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|;
name|objc_ivar_list_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
comment|/* int method_next; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"method_next"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
comment|/* int method_count; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"method_count"
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* struct objc_method method_list[]; */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|list_type
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|get_identifier
argument_list|(
literal|"method_list"
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|objc_ivar_list_record
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
return|return
name|objc_ivar_list_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_ivar_list_initializer
parameter_list|(
name|field_decl
parameter_list|,
name|size
parameter_list|)
name|tree
name|field_decl
decl_stmt|;
name|int
modifier|*
name|size
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULLT
decl_stmt|;
do|do
block|{
name|int
name|offset
decl_stmt|;
comment|/* set name */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
condition|)
block|{
name|offset
operator|=
name|add_objc_string
argument_list|(
name|DECL_NAME
argument_list|(
name|field_decl
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* unnamed bit-field ivar (yuck). */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* set type */
name|encode_field_decl
argument_list|(
name|field_decl
argument_list|,
name|OBJC_ENCODE_DONT_INLINE_DEFS
argument_list|)
expr_stmt|;
name|offset
operator|=
name|add_objc_string
argument_list|(
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* set offset */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|field_decl
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
operator|(
operator|*
name|size
operator|)
operator|++
expr_stmt|;
name|field_decl
operator|=
name|TREE_CHAIN
argument_list|(
name|field_decl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|field_decl
condition|)
do|;
return|return
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_ivars_list
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|list
parameter_list|)
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_ivar_lists
parameter_list|()
block|{
name|tree
name|initlist
decl_stmt|,
name|ivar_list_template
decl_stmt|,
name|chain
decl_stmt|;
name|tree
name|cast
decl_stmt|,
name|variable_length_type
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|objc_ivar_template
condition|)
name|objc_ivar_template
operator|=
name|build_ivar_template
argument_list|()
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_IVAR_LIST
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|variable_length_type
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
comment|/* only generate class variables for the root of the inheritance      hierarchy since these will be the same for every class */
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|==
name|NULLT
operator|&&
operator|(
name|chain
operator|=
name|TYPE_FIELDS
argument_list|(
name|objc_class_template
argument_list|)
operator|)
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|initlist
operator|=
name|build_ivar_list_initializer
argument_list|(
name|chain
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|ivar_list_template
operator|=
name|build_ivar_list_template
argument_list|(
name|objc_ivar_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|_OBJC_CLASS_VARIABLES_decl
operator|=
name|generate_ivars_list
argument_list|(
name|ivar_list_template
argument_list|,
literal|"_OBJC_CLASS_VARIABLES"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cast! */
name|TREE_TYPE
argument_list|(
name|_OBJC_CLASS_VARIABLES_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|_OBJC_CLASS_VARIABLES_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|CLASS_IVARS
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|initlist
operator|=
name|build_ivar_list_initializer
argument_list|(
name|chain
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|ivar_list_template
operator|=
name|build_ivar_list_template
argument_list|(
name|objc_ivar_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|_OBJC_INSTANCE_VARIABLES_decl
operator|=
name|generate_ivars_list
argument_list|(
name|ivar_list_template
argument_list|,
literal|"_OBJC_INSTANCE_VARIABLES"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cast! */
name|TREE_TYPE
argument_list|(
name|_OBJC_INSTANCE_VARIABLES_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|_OBJC_INSTANCE_VARIABLES_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_dispatch_table_initializer
parameter_list|(
name|entries
parameter_list|,
name|size
parameter_list|)
name|tree
name|entries
decl_stmt|;
name|int
modifier|*
name|size
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULLT
decl_stmt|;
do|do
block|{
name|int
name|offset
init|=
name|add_objc_string
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|entries
argument_list|)
argument_list|)
decl_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|init_selector
argument_list|(
name|offset
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|offset
operator|=
name|add_objc_string
argument_list|(
name|METHOD_ENCODING
argument_list|(
name|entries
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|METHOD_DEFINITION
argument_list|(
name|entries
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
operator|(
operator|*
name|size
operator|)
operator|++
expr_stmt|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|entries
condition|)
do|;
return|return
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * To accomplish method prototyping without generating all kinds of  * inane warnings, the definition of the dispatch table entries were  * changed from:  *  * 	struct objc_method { SEL _cmd; id (*_imp)(); };  * to:  * 	struct objc_method { SEL _cmd; void *_imp; };  */
end_comment

begin_function
specifier|static
name|tree
name|build_method_template
parameter_list|()
block|{
name|tree
name|_SLT_record
decl_stmt|;
name|tree
name|decl_specs
decl_stmt|,
name|field_decl
decl_stmt|,
name|field_decl_chain
decl_stmt|,
name|parms
decl_stmt|;
name|_SLT_record
operator|=
name|start_struct
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_METHOD
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_INT_SELECTORS
comment|/* unsigned int _cmd; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not OBJC_INT_SELECTORS */
comment|/* struct objc_selector *_cmd; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not OBJC_INT_SELECTORS */
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl_chain
operator|=
name|field_decl
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"method_types"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
comment|/* void *_imp; */
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
literal|"_imp"
argument_list|)
argument_list|)
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|field_decl
argument_list|,
name|decl_specs
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|field_decl_chain
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
name|finish_struct
argument_list|(
name|_SLT_record
argument_list|,
name|field_decl_chain
argument_list|)
expr_stmt|;
return|return
name|_SLT_record
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|generate_dispatch_table
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|list
parameter_list|)
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|;
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|,
name|initlist
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|type
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
name|name
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|list
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_dispatch_tables
parameter_list|()
block|{
name|tree
name|initlist
decl_stmt|,
name|chain
decl_stmt|,
name|method_list_template
decl_stmt|;
name|tree
name|cast
decl_stmt|,
name|variable_length_type
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|objc_method_template
condition|)
name|objc_method_template
operator|=
name|build_method_template
argument_list|()
expr_stmt|;
name|cast
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|_TAG_METHOD_LIST
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|variable_length_type
operator|=
name|groktypename
argument_list|(
name|cast
argument_list|)
expr_stmt|;
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|initlist
operator|=
name|build_dispatch_table_initializer
argument_list|(
name|chain
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_list_template
argument_list|(
name|objc_method_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
name|_OBJC_CLASS_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_CLASS_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
comment|/* we have a category */
name|_OBJC_CLASS_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_CATEGORY_CLASS_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cast! */
name|TREE_TYPE
argument_list|(
name|_OBJC_CLASS_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|_OBJC_CLASS_METHODS_decl
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|initlist
operator|=
name|build_dispatch_table_initializer
argument_list|(
name|chain
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|method_list_template
operator|=
name|build_method_list_template
argument_list|(
name|objc_method_template
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
name|_OBJC_INSTANCE_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
comment|/* we have a category */
name|_OBJC_INSTANCE_METHODS_decl
operator|=
name|generate_dispatch_table
argument_list|(
name|method_list_template
argument_list|,
literal|"_OBJC_CATEGORY_INSTANCE_METHODS"
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* cast! */
name|TREE_TYPE
argument_list|(
name|_OBJC_INSTANCE_METHODS_decl
argument_list|)
operator|=
name|variable_length_type
expr_stmt|;
block|}
else|else
name|_OBJC_INSTANCE_METHODS_decl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|build_category_initializer
parameter_list|(
name|cat_name
parameter_list|,
name|class_name
parameter_list|,
name|instance_methods
parameter_list|,
name|class_methods
parameter_list|)
name|tree
name|cat_name
decl_stmt|;
name|tree
name|class_name
decl_stmt|;
name|tree
name|instance_methods
decl_stmt|;
name|tree
name|class_methods
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULLT
decl_stmt|,
name|expr
decl_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|cat_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|class_name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|class_methods
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|class_methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
return|return
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  struct objc_class {  *    struct objc_class *isa;  *    struct objc_class *super_class;  *    char *name;  *    long version;  *    long info;  *    long instance_size;  *    struct objc_ivar_list *ivars;  *    struct objc_method_list *methods;  *    struct objc_cache *cache;  *  };  */
end_comment

begin_function
specifier|static
name|tree
name|build_shared_structure_initializer
parameter_list|(
name|isa
parameter_list|,
name|super
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|status
parameter_list|,
name|dispatch_table
parameter_list|,
name|ivar_list
parameter_list|)
name|tree
name|isa
decl_stmt|;
name|tree
name|super
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|size
decl_stmt|;
name|int
name|status
decl_stmt|;
name|tree
name|dispatch_table
decl_stmt|;
name|tree
name|ivar_list
decl_stmt|;
block|{
name|tree
name|initlist
init|=
name|NULLT
decl_stmt|,
name|expr
decl_stmt|;
comment|/* isa = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|isa
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* super_class = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|super
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* name = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|name
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* version = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* info = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
name|status
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* instance_size = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|size
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
comment|/* objc_ivar_list = */
if|if
condition|(
operator|!
name|ivar_list
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ivar_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* objc_method_list = */
if|if
condition|(
operator|!
name|dispatch_table
condition|)
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
else|else
block|{
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|dispatch_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|expr
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
block|}
comment|/* method_cache = */
name|initlist
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|initlist
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|NULLT
argument_list|,
name|nreverse
argument_list|(
name|initlist
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */
end_comment

begin_function
specifier|static
name|void
name|generate_category
parameter_list|(
name|cat
parameter_list|)
name|tree
name|cat
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|initlist
decl_stmt|,
name|cat_name_expr
decl_stmt|,
name|class_name_expr
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|objc_category_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|synth_id_with_class_suffix
argument_list|(
literal|"_OBJC_CATEGORY"
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|add_objc_string
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|cat
argument_list|)
argument_list|)
expr_stmt|;
name|cat_name_expr
operator|=
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|add_objc_string
argument_list|(
name|CLASS_NAME
argument_list|(
name|cat
argument_list|)
argument_list|)
expr_stmt|;
name|class_name_expr
operator|=
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_category_initializer
argument_list|(
name|cat_name_expr
argument_list|,
name|class_name_expr
argument_list|,
name|_OBJC_INSTANCE_METHODS_decl
argument_list|,
name|_OBJC_CLASS_METHODS_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * static struct objc_class _OBJC_METACLASS_Foo={ ... };  * static struct objc_class _OBJC_CLASS_Foo={ ... };  */
end_comment

begin_function
specifier|static
name|void
name|generate_shared_structures
parameter_list|()
block|{
name|tree
name|sc_spec
decl_stmt|,
name|decl_specs
decl_stmt|,
name|expr_decl
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|name_expr
decl_stmt|,
name|super_expr
decl_stmt|,
name|root_expr
decl_stmt|;
name|tree
name|my_root_id
init|=
name|NULLT
decl_stmt|,
name|my_super_id
init|=
name|NULLT
decl_stmt|;
name|tree
name|cast_type
decl_stmt|,
name|initlist
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|my_super_id
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_super_id
condition|)
block|{
name|add_class_reference
argument_list|(
name|my_super_id
argument_list|)
expr_stmt|;
comment|/* compute "my_root_id" - this is required for code generation.        * the "isa" for all meta class structures points to the root of        * the inheritance hierarchy (e.g. "__Object")...        */
name|my_root_id
operator|=
name|my_super_id
expr_stmt|;
do|do
block|{
name|tree
name|my_root_int
init|=
name|lookup_interface
argument_list|(
name|my_root_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|my_root_int
operator|&&
name|CLASS_SUPER_NAME
argument_list|(
name|my_root_int
argument_list|)
condition|)
name|my_root_id
operator|=
name|CLASS_SUPER_NAME
argument_list|(
name|my_root_int
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
else|else
comment|/* no super class */
block|{
name|my_root_id
operator|=
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
block|}
name|cast_type
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|objc_class_template
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|NULLT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|add_objc_string
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
name|name_expr
operator|=
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* install class `isa' and `super' pointers at runtime */
if|if
condition|(
name|my_super_id
condition|)
block|{
name|offset
operator|=
name|add_objc_string
argument_list|(
name|my_super_id
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|super_expr
argument_list|)
operator|=
name|cast_type
expr_stmt|;
comment|/* cast! */
block|}
else|else
name|super_expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|add_objc_string
argument_list|(
name|my_root_id
argument_list|)
expr_stmt|;
name|root_expr
operator|=
name|build_msg_pool_reference
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|root_expr
argument_list|)
operator|=
name|cast_type
expr_stmt|;
comment|/* cast! */
comment|/* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */
name|sc_spec
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|objc_class_template
argument_list|,
name|sc_spec
argument_list|)
expr_stmt|;
name|decl
operator|=
name|start_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|_OBJC_METACLASS_decl
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_shared_structure_initializer
argument_list|(
name|root_expr
argument_list|,
name|super_expr
argument_list|,
name|name_expr
argument_list|,
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|objc_class_template
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
comment|/*CLS_META*/
argument_list|,
name|_OBJC_CLASS_METHODS_decl
argument_list|,
name|_OBJC_CLASS_VARIABLES_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
comment|/* static struct objc_class _OBJC_CLASS_Foo={ ... }; */
name|decl
operator|=
name|start_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|_OBJC_CLASS_decl
argument_list|)
argument_list|,
name|decl_specs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initlist
operator|=
name|build_shared_structure_initializer
argument_list|(
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|_OBJC_METACLASS_decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|super_expr
argument_list|,
name|name_expr
argument_list|,
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
comment|/*CLS_FACTORY*/
argument_list|,
name|_OBJC_INSTANCE_METHODS_decl
argument_list|,
name|_OBJC_INSTANCE_VARIABLES_decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|initlist
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|synth_id_with_class_suffix
parameter_list|(
name|preamble
parameter_list|)
name|char
modifier|*
name|preamble
decl_stmt|;
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
block|{
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|preamble
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s"
argument_list|,
name|preamble
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we have a category */
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|preamble
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|preamble
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *   usage:  *		keyworddecl:  *			selector ':' '(' typename ')' identifier  *  *   purpose:  *		transform an Objective-C keyword argument into  *		the C equivalent parameter declarator.  *  *   in:	key_name, an "identifier_node" (optional).  *		arg_type, a  "tree_list" (optional).  *		arg_name, an "identifier_node".  *  *   note:	it would be really nice to strongly type the preceding  *		arguments in the function prototype; however, then i  *		could not use the "accessor" macros defined in "tree.h".  *  *   out:	an instance of "keyword_decl".  *  */
end_comment

begin_function
name|tree
name|build_keyword_decl
parameter_list|(
name|key_name
parameter_list|,
name|arg_type
parameter_list|,
name|arg_name
parameter_list|)
name|tree
name|key_name
decl_stmt|;
name|tree
name|arg_type
decl_stmt|;
name|tree
name|arg_name
decl_stmt|;
block|{
name|tree
name|keyword_decl
decl_stmt|;
comment|/* if no type is specified, default to "id" */
if|if
condition|(
name|arg_type
operator|==
name|NULLT
condition|)
name|arg_type
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|objc_object_reference
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|NULLT
argument_list|)
argument_list|)
expr_stmt|;
name|keyword_decl
operator|=
name|make_node
argument_list|(
name|KEYWORD_DECL
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|arg_type
expr_stmt|;
name|KEYWORD_ARG_NAME
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|arg_name
expr_stmt|;
name|KEYWORD_KEY_NAME
argument_list|(
name|keyword_decl
argument_list|)
operator|=
name|key_name
expr_stmt|;
return|return
name|keyword_decl
return|;
block|}
end_function

begin_comment
comment|/*  *  given a chain of keyword_decl's, synthesize the full keyword selector.  */
end_comment

begin_function
specifier|static
name|tree
name|build_keyword_selector
parameter_list|(
name|selector
parameter_list|)
name|tree
name|selector
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|tree
name|key_chain
decl_stmt|,
name|key_name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
for|for
control|(
name|key_chain
operator|=
name|selector
init|;
name|key_chain
condition|;
name|key_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|key_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
name|key_name
operator|=
name|KEYWORD_KEY_NAME
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|key_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|len
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|key_name
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
comment|/* just a ':' arg */
name|len
operator|++
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|key_chain
operator|=
name|selector
init|;
name|key_chain
condition|;
name|key_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|key_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
name|key_name
operator|=
name|KEYWORD_KEY_NAME
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|key_name
operator|=
name|TREE_PURPOSE
argument_list|(
name|key_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_name
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|key_name
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* used for declarations and definitions */
end_comment

begin_function
name|tree
name|build_method_decl
parameter_list|(
name|code
parameter_list|,
name|ret_type
parameter_list|,
name|selector
parameter_list|,
name|add_args
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|ret_type
decl_stmt|;
name|tree
name|selector
decl_stmt|;
name|tree
name|add_args
decl_stmt|;
block|{
name|tree
name|method_decl
decl_stmt|;
comment|/* if no type is specified, default to "id" */
if|if
condition|(
name|ret_type
operator|==
name|NULLT
condition|)
name|ret_type
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|objc_object_reference
argument_list|)
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|NULLT
argument_list|)
argument_list|)
expr_stmt|;
name|method_decl
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|method_decl
argument_list|)
operator|=
name|ret_type
expr_stmt|;
comment|/*    *  if we have a keyword selector, create an identifier_node that    *  represents the full selector name (`:' included)...    */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selector
argument_list|)
operator|==
name|KEYWORD_DECL
condition|)
block|{
name|METHOD_SEL_NAME
argument_list|(
name|method_decl
argument_list|)
operator|=
name|build_keyword_selector
argument_list|(
name|selector
argument_list|)
expr_stmt|;
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|selector
expr_stmt|;
name|METHOD_ADD_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|add_args
expr_stmt|;
block|}
else|else
block|{
name|METHOD_SEL_NAME
argument_list|(
name|method_decl
argument_list|)
operator|=
name|selector
expr_stmt|;
name|METHOD_SEL_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|NULLT
expr_stmt|;
name|METHOD_ADD_ARGS
argument_list|(
name|method_decl
argument_list|)
operator|=
name|NULLT
expr_stmt|;
block|}
return|return
name|method_decl
return|;
block|}
end_function

begin_define
define|#
directive|define
name|METHOD_DEF
value|0
end_define

begin_define
define|#
directive|define
name|METHOD_REF
value|1
end_define

begin_comment
comment|/* Used by `build_message_expr' and `comp_method_types'.    Return an argument list for method METH.    CONTEXT is either METHOD_DEF or METHOD_REF,     saying whether we are trying to define a method or call one.    SUPERFLAG says this is for a send to super;     this makes a difference for the NeXT calling sequence     in which the lookup and the method call are done together.  */
end_comment

begin_function
specifier|static
name|tree
name|get_arg_type_list
parameter_list|(
name|meth
parameter_list|,
name|context
parameter_list|,
name|superflag
parameter_list|)
name|tree
name|meth
decl_stmt|;
name|int
name|context
decl_stmt|;
name|int
name|superflag
decl_stmt|;
block|{
name|tree
name|arglist
decl_stmt|,
name|akey
decl_stmt|;
ifdef|#
directive|ifdef
name|NEXT_OBJC_RUNTIME
comment|/* receiver type */
if|if
condition|(
name|superflag
condition|)
block|{
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|super_type
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|context
operator|==
name|METHOD_DEF
condition|)
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|TREE_TYPE
argument_list|(
name|self_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|id_type
argument_list|)
expr_stmt|;
block|}
comment|/* selector type - will eventually change to `int' */
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|selector_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build a list of argument types */
for|for
control|(
name|akey
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|meth
argument_list|)
init|;
name|akey
condition|;
name|akey
operator|=
name|TREE_CHAIN
argument_list|(
name|akey
argument_list|)
control|)
block|{
name|tree
name|arg_decl
init|=
name|groktypename_in_parm_context
argument_list|(
name|TREE_TYPE
argument_list|(
name|akey
argument_list|)
argument_list|)
decl_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
operator|==
operator|(
name|tree
operator|)
literal|1
condition|)
comment|/*      * we have a `, ...' immediately following the selector,      * finalize the arglist...simulate get_parm_info (0)      */
empty_stmt|;
elseif|else
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
condition|)
block|{
comment|/* we have a variable length selector */
name|tree
name|add_arg_list
init|=
name|TREE_CHAIN
argument_list|(
name|METHOD_ADD_ARGS
argument_list|(
name|meth
argument_list|)
argument_list|)
decl_stmt|;
name|chainon
argument_list|(
name|arglist
argument_list|,
name|add_arg_list
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* finalize the arglist...simulate get_parm_info (1) */
name|chainon
argument_list|(
name|arglist
argument_list|,
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|void_type_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arglist
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|check_duplicates
parameter_list|(
name|hsh
parameter_list|)
name|hash
name|hsh
decl_stmt|;
block|{
name|tree
name|meth
init|=
name|NULLT
decl_stmt|;
if|if
condition|(
name|hsh
condition|)
block|{
name|meth
operator|=
name|hsh
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|hsh
operator|->
name|list
condition|)
block|{
comment|/* we have two methods with the same name and different types */
name|attr
name|loop
decl_stmt|;
name|char
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
literal|'-'
else|:
literal|'+'
expr_stmt|;
name|warning
argument_list|(
literal|"multiple declarations for method `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
literal|"using"
argument_list|,
name|type
argument_list|,
name|meth
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|warn_with_method
argument_list|(
literal|"also found"
argument_list|,
name|type
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|meth
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|receiver_is_class_object
parameter_list|(
name|receiver
parameter_list|)
name|tree
name|receiver
decl_stmt|;
block|{
comment|/* the receiver is a function call that returns an id...    * ...check if it is a call to objc_getClass, if so, give it    * special treatment.    */
name|tree
name|exp
init|=
name|TREE_OPERAND
argument_list|(
name|receiver
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exp
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|ADDR_EXPR
operator|)
condition|)
block|{
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|exp
operator|==
name|objc_getClass_decl
condition|)
block|{
comment|/* we have a call to objc_getClass! */
name|tree
name|arg
init|=
name|TREE_OPERAND
argument_list|(
name|receiver
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
operator|&&
operator|(
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
operator|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|STRING_CST
condition|)
comment|/* finally, we have the class name */
return|return
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are currently building a message expr, this holds    the identifier of the selector of the message.  This is    used when printing warnings about argument mismatches. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|building_objc_message_expr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|maybe_building_objc_message_expr
parameter_list|()
block|{
return|return
name|building_objc_message_expr
return|;
block|}
end_function

begin_comment
comment|/* Construct an expression for sending a message.    MESS has the object to send to in TREE_PURPOSE    and the argument list (including selector) in TREE_VALUE.  */
end_comment

begin_function
name|tree
name|build_message_expr
parameter_list|(
name|mess
parameter_list|)
name|tree
name|mess
decl_stmt|;
block|{
name|tree
name|receiver
init|=
name|TREE_PURPOSE
argument_list|(
name|mess
argument_list|)
decl_stmt|;
name|tree
name|selector
decl_stmt|,
name|self_object
decl_stmt|;
name|tree
name|rtype
decl_stmt|,
name|sel_name
decl_stmt|;
name|tree
name|args
init|=
name|TREE_VALUE
argument_list|(
name|mess
argument_list|)
decl_stmt|;
name|tree
name|method_params
init|=
name|NULLT
decl_stmt|;
name|tree
name|method_prototype
init|=
name|NULLT
decl_stmt|;
name|int
name|selTransTbl_index
decl_stmt|;
name|tree
name|retval
decl_stmt|;
name|int
name|statically_typed
init|=
literal|0
decl_stmt|,
name|statically_allocated
init|=
literal|0
decl_stmt|;
name|tree
name|class_ident
init|=
literal|0
decl_stmt|;
comment|/* 1 if this is sending to the superclass.  */
name|int
name|super
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|fatal
argument_list|(
literal|"Objective-C text in C source file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
comment|/* determine receiver type */
name|rtype
operator|=
name|TREE_TYPE
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|super
operator|=
operator|(
name|TREE_TYPE
argument_list|(
name|receiver
argument_list|)
operator|==
name|super_type
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|super
condition|)
block|{
if|if
condition|(
name|TREE_STATIC_TEMPLATE
argument_list|(
name|rtype
argument_list|)
condition|)
name|statically_allocated
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rtype
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_STATIC_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
argument_list|)
condition|)
name|statically_typed
operator|=
literal|1
expr_stmt|;
comment|/* classfix -smn */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|receiver
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|rtype
operator|==
name|id_type
operator|&&
operator|(
name|class_ident
operator|=
name|receiver_is_class_object
argument_list|(
name|receiver
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|rtype
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|id_type
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|rtype
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|class_type
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"invalid receiver type `%s'"
argument_list|,
name|gen_declaration
argument_list|(
name|rtype
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|statically_allocated
condition|)
name|receiver
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|receiver
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't evaluate the receiver twice. */
name|receiver
operator|=
name|save_expr
argument_list|(
name|receiver
argument_list|)
expr_stmt|;
name|self_object
operator|=
name|receiver
expr_stmt|;
block|}
else|else
comment|/* If sending to `super', use current self as the object.  */
name|self_object
operator|=
name|self_decl
expr_stmt|;
comment|/* Obtain the full selector name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* a unary selector */
name|sel_name
operator|=
name|args
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|sel_name
operator|=
name|build_keyword_selector
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|selTransTbl_index
operator|=
name|add_selector_reference
argument_list|(
name|sel_name
argument_list|)
expr_stmt|;
comment|/* Build the parameters list for looking up the method.      These are the object itself and the selector.  */
ifndef|#
directive|ifndef
name|OBJC_SELECTORS_WITHOUT_LABELS
name|selector
operator|=
name|build_selector_reference
argument_list|(
name|selTransTbl_index
argument_list|)
expr_stmt|;
else|#
directive|else
name|selector
operator|=
name|build_array_ref
argument_list|(
name|_OBJC_SELECTOR_REFERENCES_decl
argument_list|,
name|build_int_2
argument_list|(
name|selTransTbl_index
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Build the parameter list to give to the method.  */
name|method_params
operator|=
name|NULLT
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|chain
init|=
name|args
decl_stmt|,
name|prev
init|=
name|NULLT
decl_stmt|;
comment|/* We have a keyword selector--check for comma expressions.  */
while|while
condition|(
name|chain
condition|)
block|{
name|tree
name|element
init|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
decl_stmt|;
comment|/* We have a comma expression, must collapse...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|element
expr_stmt|;
else|else
name|args
operator|=
name|element
expr_stmt|;
block|}
name|prev
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|method_params
operator|=
name|args
expr_stmt|;
block|}
comment|/* Determine operation return type.  */
if|if
condition|(
name|super_type
operator|!=
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|rtype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|super_type
argument_list|)
condition|)
block|{
name|tree
name|iface
decl_stmt|;
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
condition|)
block|{
name|iface
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|method_prototype
operator|=
name|lookup_instance_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
else|else
name|method_prototype
operator|=
name|lookup_class_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|&&
operator|!
name|method_prototype
condition|)
name|warning
argument_list|(
literal|"`%s' does not respond to `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"no super class declared in interface for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|statically_allocated
condition|)
block|{
name|tree
name|iface
init|=
name|lookup_interface
argument_list|(
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|iface
operator|&&
operator|!
operator|(
name|method_prototype
operator|=
name|lookup_instance_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"`%s' does not respond to `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|rtype
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|statically_typed
condition|)
block|{
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
decl_stmt|;
comment|/* `self' is now statically_typed...all methods should be visible        * within the context of the implementation...        */
if|if
condition|(
name|implementation_context
operator|&&
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|method_prototype
operator|=
name|lookup_instance_method_static
argument_list|(
name|implementation_template
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|implementation_template
operator|!=
name|implementation_context
condition|)
comment|/* the method is not published in the interface...check locally */
name|method_prototype
operator|=
name|lookup_method
argument_list|(
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|iface
decl_stmt|;
if|if
condition|(
name|iface
operator|=
name|lookup_interface
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
name|method_prototype
operator|=
name|lookup_instance_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|method_prototype
condition|)
name|warning
argument_list|(
literal|"`%s' does not respond to `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|ctype
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class_ident
condition|)
block|{
if|if
condition|(
name|implementation_context
operator|&&
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|class_ident
condition|)
block|{
name|method_prototype
operator|=
name|lookup_class_method_static
argument_list|(
name|implementation_template
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
operator|&&
name|implementation_template
operator|!=
name|implementation_context
condition|)
comment|/* the method is not published in the interface...check locally */
name|method_prototype
operator|=
name|lookup_method
argument_list|(
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|iface
decl_stmt|;
if|if
condition|(
name|iface
operator|=
name|lookup_interface
argument_list|(
name|class_ident
argument_list|)
condition|)
name|method_prototype
operator|=
name|lookup_class_method_static
argument_list|(
name|iface
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|warning
argument_list|(
literal|"cannot find class (factory) method."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"return type for `%s' defaults to id"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hash
name|hsh
decl_stmt|;
comment|/* we think we have an instance...loophole: extern id Object; */
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hsh
condition|)
comment|/* for various loopholes...like sending messages to self in a 	   factory context... */
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|sel_name
argument_list|)
expr_stmt|;
name|method_prototype
operator|=
name|check_duplicates
argument_list|(
name|hsh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|warning
argument_list|(
literal|"cannot find method."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"return type for `%s' defaults to id"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|sel_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Save the selector name for printing error messages.  */
name|building_objc_message_expr
operator|=
name|sel_name
expr_stmt|;
name|retval
operator|=
name|build_objc_method_call
argument_list|(
name|super
argument_list|,
name|method_prototype
argument_list|,
name|receiver
argument_list|,
name|self_object
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
expr_stmt|;
name|building_objc_message_expr
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a tree expression to send OBJECT the operation SELECTOR,    looking up the method on object LOOKUP_OBJECT (often same as OBJECT),    assuming the method has prototype METHOD_PROTOTYPE.    (That is an INSTANCE_METHOD_DECL or CLASS_METHOD_DECL.)    Use METHOD_PARAMS as list of args to pass to the method.    If SUPER_FLAG is nonzero, we look up the superclass's method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_objc_method_call
parameter_list|(
name|super_flag
parameter_list|,
name|method_prototype
parameter_list|,
name|lookup_object
parameter_list|,
name|object
parameter_list|,
name|selector
parameter_list|,
name|method_params
parameter_list|)
name|int
name|super_flag
decl_stmt|;
name|tree
name|method_prototype
decl_stmt|,
name|lookup_object
decl_stmt|,
name|object
decl_stmt|,
name|selector
decl_stmt|,
name|method_params
decl_stmt|;
block|{
name|tree
name|sender
init|=
operator|(
name|super_flag
condition|?
name|_msgSuper_decl
else|:
name|_msg_decl
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|NEXT_OBJC_RUNTIME
if|if
condition|(
operator|!
name|method_prototype
condition|)
block|{
name|method_params
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|sender
argument_list|,
name|method_params
argument_list|)
return|;
block|}
else|else
block|{
comment|/* This is a real kludge, but it is used only for the Next. 	 Clobber the data type of SENDER temporarily to accept 	 all the arguments for this operation, and to return 	 whatever this operation returns.  */
name|tree
name|arglist
init|=
name|NULLT
decl_stmt|;
name|tree
name|retval
decl_stmt|;
comment|/* Save the proper contents of SENDER's data type.  */
name|tree
name|savarg
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|savret
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Install this method's argument types.  */
name|arglist
operator|=
name|get_arg_type_list
argument_list|(
name|method_prototype
argument_list|,
name|METHOD_REF
argument_list|,
name|super_flag
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
operator|=
name|arglist
expr_stmt|;
comment|/* Install this method's return type.  */
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_prototype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call SENDER with all the parameters. 	 This will do type checking using the arg types for this method.  */
name|method_params
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|build_function_call
argument_list|(
name|sender
argument_list|,
name|method_params
argument_list|)
expr_stmt|;
comment|/* Restore SENDER's return/argument types.  */
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
operator|=
name|savarg
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|sender
argument_list|)
argument_list|)
operator|=
name|savret
expr_stmt|;
return|return
name|retval
return|;
block|}
else|#
directive|else
comment|/* not NEXT_OBJC_RUNTIME */
comment|/* This is the portable way.      First call the lookup function to get a pointer to the method,       then cast the pointer, then call it with the method arguments.  */
name|tree
name|method
decl_stmt|;
comment|/* Avoid trouble since we may evaluate each of these twice.  */
name|object
operator|=
name|save_expr
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|selector
operator|=
name|save_expr
argument_list|(
name|selector
argument_list|)
expr_stmt|;
name|method
operator|=
name|build_function_call
argument_list|(
name|sender
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|lookup_object
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|selector
argument_list|,
name|NULLT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have a method prototype, construct the data type this method needs,      and cast what we got from SENDER into a pointer to that type.  */
if|if
condition|(
name|method_prototype
condition|)
block|{
name|tree
name|arglist
init|=
name|get_arg_type_list
argument_list|(
name|method_prototype
argument_list|,
name|METHOD_REF
argument_list|,
name|super_flag
argument_list|)
decl_stmt|;
name|tree
name|valtype
init|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_prototype
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fake_function_type
init|=
name|build_function_type
argument_list|(
name|valtype
argument_list|,
name|arglist
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|fake_function_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULLT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Pass the object to the method.  */
return|return
name|build_function_call
argument_list|(
name|method
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|object
argument_list|,
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|selector
argument_list|,
name|method_params
argument_list|)
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
comment|/* not NEXT_OBJC_RUNTIME */
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|build_selector_expr
parameter_list|(
name|selnamelist
parameter_list|)
name|tree
name|selnamelist
decl_stmt|;
block|{
name|tree
name|selname
decl_stmt|;
name|int
name|selTransTbl_index
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|fatal
argument_list|(
literal|"Objective-C text in C source file"
argument_list|)
expr_stmt|;
comment|/* obtain the full selector name */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selnamelist
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
comment|/* a unary selector */
name|selname
operator|=
name|selnamelist
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|selnamelist
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|selname
operator|=
name|build_keyword_selector
argument_list|(
name|selnamelist
argument_list|)
expr_stmt|;
name|selTransTbl_index
operator|=
name|add_selector_reference
argument_list|(
name|selname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJC_SELECTORS_WITHOUT_LABELS
return|return
name|build_selector_reference
argument_list|(
name|selTransTbl_index
argument_list|)
return|;
else|#
directive|else
comment|/* synthesize a reference into the selector translation table */
return|return
name|build_array_ref
argument_list|(
name|_OBJC_SELECTOR_REFERENCES_decl
argument_list|,
name|build_int_2
argument_list|(
name|selTransTbl_index
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|tree
name|build_encode_expr
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|fatal
argument_list|(
literal|"Objective-C text in C source file"
argument_list|)
expr_stmt|;
name|encode_type
argument_list|(
name|type
argument_list|,
name|OBJC_ENCODE_INLINE_DEFS
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* null terminate string */
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
expr_stmt|;
comment|/* synthesize a string that represents the encoded struct/union */
name|result
operator|=
name|my_build_string
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|tree
name|build_ivar_reference
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|CLASS_METHOD_DECL
condition|)
name|TREE_TYPE
argument_list|(
name|self_decl
argument_list|)
operator|=
name|instance_type
expr_stmt|;
comment|/* cast */
return|return
name|build_component_ref
argument_list|(
name|build_indirect_ref
argument_list|(
name|self_decl
argument_list|,
literal|"->"
argument_list|)
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|HASH_ALLOC_LIST_SIZE
value|170
end_define

begin_define
define|#
directive|define
name|ATTR_ALLOC_LIST_SIZE
value|170
end_define

begin_define
define|#
directive|define
name|SIZEHASHTABLE
value|257
end_define

begin_define
define|#
directive|define
name|HASHFUNCTION
parameter_list|(
name|key
parameter_list|)
value|((int)key>> 2)
end_define

begin_comment
comment|/* divide by 4 */
end_comment

begin_function
specifier|static
name|void
name|hash_init
parameter_list|()
block|{
name|nst_method_hash_list
operator|=
operator|(
name|hash
operator|*
operator|)
name|xmalloc
argument_list|(
name|SIZEHASHTABLE
operator|*
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|cls_method_hash_list
operator|=
operator|(
name|hash
operator|*
operator|)
name|xmalloc
argument_list|(
name|SIZEHASHTABLE
operator|*
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nst_method_hash_list
operator|||
operator|!
name|cls_method_hash_list
condition|)
name|perror
argument_list|(
literal|"unable to allocate space in objc-tree.c"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEHASHTABLE
condition|;
name|i
operator|++
control|)
block|{
name|nst_method_hash_list
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|cls_method_hash_list
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hash_enter
parameter_list|(
name|hashlist
parameter_list|,
name|method
parameter_list|)
name|hash
modifier|*
name|hashlist
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
specifier|static
name|hash
name|hash_alloc_list
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|hash_alloc_index
init|=
literal|0
decl_stmt|;
name|hash
name|obj
decl_stmt|;
name|int
name|slot
init|=
name|HASHFUNCTION
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|%
name|SIZEHASHTABLE
decl_stmt|;
if|if
condition|(
operator|!
name|hash_alloc_list
operator|||
name|hash_alloc_index
operator|>=
name|HASH_ALLOC_LIST_SIZE
condition|)
block|{
name|hash_alloc_index
operator|=
literal|0
expr_stmt|;
name|hash_alloc_list
operator|=
operator|(
name|hash
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashedEntry
argument_list|)
operator|*
name|HASH_ALLOC_LIST_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash_alloc_list
condition|)
name|perror
argument_list|(
literal|"unable to allocate in objc-tree.c"
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
operator|&
name|hash_alloc_list
index|[
name|hash_alloc_index
operator|++
index|]
expr_stmt|;
name|obj
operator|->
name|list
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|next
operator|=
name|hashlist
index|[
name|slot
index|]
expr_stmt|;
name|obj
operator|->
name|key
operator|=
name|method
expr_stmt|;
name|hashlist
index|[
name|slot
index|]
operator|=
name|obj
expr_stmt|;
comment|/* append to front */
block|}
end_function

begin_function
specifier|static
name|hash
name|hash_lookup
parameter_list|(
name|hashlist
parameter_list|,
name|sel_name
parameter_list|)
name|hash
modifier|*
name|hashlist
decl_stmt|;
name|tree
name|sel_name
decl_stmt|;
block|{
name|hash
name|target
decl_stmt|;
name|target
operator|=
name|hashlist
index|[
name|HASHFUNCTION
argument_list|(
name|sel_name
argument_list|)
operator|%
name|SIZEHASHTABLE
index|]
expr_stmt|;
while|while
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|sel_name
operator|==
name|METHOD_SEL_NAME
argument_list|(
name|target
operator|->
name|key
argument_list|)
condition|)
return|return
name|target
return|;
name|target
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_add_attr
parameter_list|(
name|entry
parameter_list|,
name|value
parameter_list|)
name|hash
name|entry
decl_stmt|;
name|tree
name|value
decl_stmt|;
block|{
specifier|static
name|attr
name|attr_alloc_list
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|attr_alloc_index
init|=
literal|0
decl_stmt|;
name|attr
name|obj
decl_stmt|;
if|if
condition|(
operator|!
name|attr_alloc_list
operator|||
name|attr_alloc_index
operator|>=
name|ATTR_ALLOC_LIST_SIZE
condition|)
block|{
name|attr_alloc_index
operator|=
literal|0
expr_stmt|;
name|attr_alloc_list
operator|=
operator|(
name|attr
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashedAttribute
argument_list|)
operator|*
name|ATTR_ALLOC_LIST_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr_alloc_list
condition|)
name|perror
argument_list|(
literal|"unable to allocate in objc-tree.c"
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
operator|&
name|attr_alloc_list
index|[
name|attr_alloc_index
operator|++
index|]
expr_stmt|;
name|obj
operator|->
name|next
operator|=
name|entry
operator|->
name|list
expr_stmt|;
name|obj
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|entry
operator|->
name|list
operator|=
name|obj
expr_stmt|;
comment|/* append to front */
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|tree
name|lookup_method
parameter_list|(
name|mchain
parameter_list|,
name|method
parameter_list|)
name|tree
name|mchain
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
name|tree
name|key
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|key
operator|=
name|method
expr_stmt|;
else|else
name|key
operator|=
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
expr_stmt|;
while|while
condition|(
name|mchain
condition|)
block|{
if|if
condition|(
name|METHOD_SEL_NAME
argument_list|(
name|mchain
argument_list|)
operator|==
name|key
condition|)
return|return
name|mchain
return|;
name|mchain
operator|=
name|TREE_CHAIN
argument_list|(
name|mchain
argument_list|)
expr_stmt|;
block|}
return|return
name|NULLT
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_instance_method_static
parameter_list|(
name|interface
parameter_list|,
name|ident
parameter_list|)
name|tree
name|interface
decl_stmt|;
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|inter
init|=
name|interface
decl_stmt|;
name|tree
name|chain
init|=
name|CLASS_NST_METHODS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|meth
init|=
name|NULLT
decl_stmt|;
do|do
block|{
if|if
condition|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
condition|)
return|return
name|meth
return|;
if|if
condition|(
name|CLASS_CATEGORY_LIST
argument_list|(
name|inter
argument_list|)
condition|)
block|{
name|tree
name|category
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
condition|)
return|return
name|meth
return|;
if|if
condition|(
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
condition|)
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|category
condition|)
do|;
block|}
if|if
condition|(
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
condition|)
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|inter
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inter
condition|)
do|;
return|return
name|meth
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|lookup_class_method_static
parameter_list|(
name|interface
parameter_list|,
name|ident
parameter_list|)
name|tree
name|interface
decl_stmt|;
name|tree
name|ident
decl_stmt|;
block|{
name|tree
name|inter
init|=
name|interface
decl_stmt|;
name|tree
name|chain
init|=
name|CLASS_CLS_METHODS
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|tree
name|meth
init|=
name|NULLT
decl_stmt|;
do|do
block|{
if|if
condition|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
condition|)
return|return
name|meth
return|;
if|if
condition|(
name|CLASS_CATEGORY_LIST
argument_list|(
name|inter
argument_list|)
condition|)
block|{
name|tree
name|category
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|inter
argument_list|)
decl_stmt|;
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|meth
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|ident
argument_list|)
condition|)
return|return
name|meth
return|;
if|if
condition|(
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
condition|)
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|category
condition|)
do|;
block|}
if|if
condition|(
name|inter
operator|=
name|lookup_interface
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|inter
argument_list|)
argument_list|)
condition|)
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|inter
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inter
condition|)
do|;
return|return
name|meth
return|;
block|}
end_function

begin_function
name|tree
name|add_class_method
parameter_list|(
name|class
parameter_list|,
name|method
parameter_list|)
name|tree
name|class
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
name|tree
name|mth
decl_stmt|;
name|hash
name|hsh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mth
operator|=
name|lookup_method
argument_list|(
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
argument_list|,
name|method
argument_list|)
operator|)
condition|)
block|{
comment|/* put method on list in reverse order */
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
name|error
argument_list|(
literal|"duplicate definition of class method `%s'."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* check types, if different complain */
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|mth
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate declaration of class method `%s'."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|cls_method_hash_list
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* install on a global chain */
name|hash_enter
argument_list|(
name|cls_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* check types, if different add to a list */
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|hsh
operator|->
name|key
argument_list|)
condition|)
name|hash_add_attr
argument_list|(
name|hsh
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
return|return
name|method
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|add_instance_method
parameter_list|(
name|class
parameter_list|,
name|method
parameter_list|)
name|tree
name|class
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
name|tree
name|mth
decl_stmt|;
name|hash
name|hsh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mth
operator|=
name|lookup_method
argument_list|(
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
argument_list|,
name|method
argument_list|)
operator|)
condition|)
block|{
comment|/* put method on list in reverse order */
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_NST_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|method
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
name|error
argument_list|(
literal|"duplicate definition of instance method `%s'."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* check types, if different complain */
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|mth
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate declaration of instance method `%s'."
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|mth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|hsh
operator|=
name|hash_lookup
argument_list|(
name|nst_method_hash_list
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* install on a global chain */
name|hash_enter
argument_list|(
name|nst_method_hash_list
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* check types, if different add to a list */
if|if
condition|(
operator|!
name|comp_proto_with_proto
argument_list|(
name|method
argument_list|,
name|hsh
operator|->
name|key
argument_list|)
condition|)
name|hash_add_attr
argument_list|(
name|hsh
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
return|return
name|method
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|add_class
parameter_list|(
name|class
parameter_list|)
name|tree
name|class
decl_stmt|;
block|{
comment|/* put interfaces on list in reverse order */
name|TREE_CHAIN
argument_list|(
name|class
argument_list|)
operator|=
name|interface_chain
expr_stmt|;
name|interface_chain
operator|=
name|class
expr_stmt|;
return|return
name|interface_chain
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_category
parameter_list|(
name|class
parameter_list|,
name|category
parameter_list|)
name|tree
name|class
decl_stmt|;
name|tree
name|category
decl_stmt|;
block|{
comment|/* put categories on list in reverse order */
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLASS_CATEGORY_LIST
argument_list|(
name|class
argument_list|)
operator|=
name|category
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called after parsing each instance variable declaration. Necessary to  * preserve typedefs and implement public/private...  */
end_comment

begin_function
name|tree
name|add_instance_variable
parameter_list|(
name|class
parameter_list|,
name|public
parameter_list|,
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|width
parameter_list|)
name|tree
name|class
decl_stmt|;
name|int
name|public
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
name|tree
name|width
decl_stmt|;
block|{
name|tree
name|field_decl
decl_stmt|,
name|raw_decl
decl_stmt|;
name|raw_decl
operator|=
name|build_tree_list
argument_list|(
name|declspecs
comment|/*purpose*/
argument_list|,
name|declarator
comment|/*value*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
condition|)
name|chainon
argument_list|(
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
argument_list|,
name|raw_decl
argument_list|)
expr_stmt|;
else|else
name|CLASS_RAW_IVARS
argument_list|(
name|class
argument_list|)
operator|=
name|raw_decl
expr_stmt|;
name|field_decl
operator|=
name|grokfield
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* overload the public attribute, it is not used for FIELD_DECL's */
if|if
condition|(
name|public
condition|)
name|TREE_PUBLIC
argument_list|(
name|field_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
condition|)
name|chainon
argument_list|(
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
argument_list|,
name|field_decl
argument_list|)
expr_stmt|;
else|else
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
operator|=
name|field_decl
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|tree
name|is_ivar
parameter_list|(
name|decl_chain
parameter_list|,
name|ident
parameter_list|)
name|tree
name|decl_chain
decl_stmt|;
name|tree
name|ident
decl_stmt|;
block|{
for|for
control|(
init|;
name|decl_chain
condition|;
name|decl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_chain
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl_chain
argument_list|)
operator|==
name|ident
condition|)
return|return
name|decl_chain
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* we have an instance variable reference, check to see if it is public...*/
end_comment

begin_function
name|int
name|is_public
parameter_list|(
name|expr
parameter_list|,
name|identifier
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_STATIC_TEMPLATE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl
operator|=
name|is_ivar
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|identifier
argument_list|)
condition|)
block|{
comment|/* important difference between the Stepstone translator: 		  		 all instance variables should be public within the context 		 of the implementation... 		 */
if|if
condition|(
name|implementation_context
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
operator|&&
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CATEGORY_TYPE
operator|&&
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|1
return|;
name|error
argument_list|(
literal|"instance variable `%s' is declared private"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|implementation_context
operator|&&
operator|(
name|basetype
operator|==
name|objc_object_reference
operator|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|_PRIVATE_record
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
block|{
name|warning
argument_list|(
literal|"static access to object of type `id'"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"please change to type `%s *'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* implement @defs (<classname>) within struct bodies. */
end_comment

begin_function
name|tree
name|get_class_ivars
parameter_list|(
name|interface
parameter_list|)
name|tree
name|interface
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|fatal
argument_list|(
literal|"Objective-C text in C source file"
argument_list|)
expr_stmt|;
return|return
name|build_ivar_chain
argument_list|(
name|interface
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|get_class_reference
parameter_list|(
name|interface
parameter_list|)
name|tree
name|interface
decl_stmt|;
block|{
name|tree
name|params
decl_stmt|;
name|add_class_reference
argument_list|(
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|interface
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|objc_getClass_decl
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* make sure all entries in "chain" are also in "list" */
end_comment

begin_function
specifier|static
name|void
name|check_methods
parameter_list|(
name|chain
parameter_list|,
name|list
parameter_list|,
name|mtype
parameter_list|)
name|tree
name|chain
decl_stmt|;
name|tree
name|list
decl_stmt|;
name|int
name|mtype
decl_stmt|;
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
operator|!
name|lookup_method
argument_list|(
name|list
argument_list|,
name|chain
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|CATEGORY_TYPE
condition|)
name|warning
argument_list|(
literal|"incomplete implementation of category `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|warning
argument_list|(
literal|"method definition for `%c%s' not found"
argument_list|,
name|mtype
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the class CLASS_NAME is defined    CODE says which kind of thing CLASS_NAME ought to be.    It can be INTERFACE_TYPE, IMPLEMENTATION_TYPE, PROTOCOL_TYPE    or CATEGORY_TYPE.     If CODE is INTERFACE_TYPE, we also do a push_obstacks_nochange    whose matching pop is in continue_class.  */
end_comment

begin_function
name|tree
name|start_class
parameter_list|(
name|code
parameter_list|,
name|class_name
parameter_list|,
name|super_name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|class_name
decl_stmt|;
name|tree
name|super_name
decl_stmt|;
block|{
name|tree
name|class
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTERFACE_TYPE
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|fatal
argument_list|(
literal|"Objective-C text in C source file"
argument_list|)
expr_stmt|;
name|class
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
operator|=
name|class_name
expr_stmt|;
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
operator|=
name|super_name
expr_stmt|;
name|CLASS_CLS_METHODS
argument_list|(
name|class
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* pre-build the following entities - for speed/convenience. */
if|if
condition|(
operator|!
name|self_id
condition|)
name|self_id
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_cmd_id
condition|)
name|_cmd_id
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objc_super_template
condition|)
name|objc_super_template
operator|=
name|build_super_template
argument_list|()
expr_stmt|;
name|method_slot
operator|=
literal|0
expr_stmt|;
comment|/* reset for multiple classes per file */
name|implementation_context
operator|=
name|class
expr_stmt|;
comment|/* lookup the interface for this implementation. */
if|if
condition|(
operator|!
operator|(
name|implementation_template
operator|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|add_class
argument_list|(
name|implementation_template
operator|=
name|implementation_context
argument_list|)
expr_stmt|;
block|}
comment|/* if a super class has been specified in the implementation, 	 insure it conforms to the one specified in the interface */
if|if
condition|(
name|super_name
operator|&&
operator|(
name|super_name
operator|!=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"conflicting super class name `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"previous declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|INTERFACE_TYPE
condition|)
block|{
if|if
condition|(
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"duplicate interface declaration for class `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PROTOCOL_TYPE
condition|)
block|{
name|tree
name|class_category_is_assoc_with
decl_stmt|;
comment|/* for a category, class_name is really the name of the class that 	 the following set of methods will be associated with...we must 	 find the interface so that can derive the objects template */
if|if
condition|(
operator|!
operator|(
name|class_category_is_assoc_with
operator|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|add_category
argument_list|(
name|class_category_is_assoc_with
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CATEGORY_TYPE
condition|)
block|{
comment|/* pre-build the following entities - for speed/convenience. */
if|if
condition|(
operator|!
name|self_id
condition|)
name|self_id
operator|=
name|get_identifier
argument_list|(
literal|"self"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_cmd_id
condition|)
name|_cmd_id
operator|=
name|get_identifier
argument_list|(
literal|"_cmd"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objc_super_template
condition|)
name|objc_super_template
operator|=
name|build_super_template
argument_list|()
expr_stmt|;
name|method_slot
operator|=
literal|0
expr_stmt|;
comment|/* reset for multiple classes per file */
name|implementation_context
operator|=
name|class
expr_stmt|;
comment|/* for a category, class_name is really the name of the class that 	 the following set of methods will be associated with...we must 	 find the interface so that can derive the objects template */
if|if
condition|(
operator|!
operator|(
name|implementation_template
operator|=
name|lookup_interface
argument_list|(
name|class_name
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find interface declaration for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|class
return|;
block|}
end_function

begin_function
name|tree
name|continue_class
parameter_list|(
name|class
parameter_list|)
name|tree
name|class
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_TYPE
condition|)
block|{
name|struct
name|imp_entry
modifier|*
name|impEntry
decl_stmt|;
name|tree
name|ivar_context
decl_stmt|;
comment|/* check consistency of the instance variables. */
if|if
condition|(
name|CLASS_IVARS
argument_list|(
name|class
argument_list|)
condition|)
name|check_ivars
argument_list|(
name|implementation_template
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* code generation */
name|ivar_context
operator|=
name|build_private_template
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|objc_class_template
condition|)
name|build_class_template
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|impEntry
operator|=
operator|(
expr|struct
name|imp_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|imp_entry
argument_list|)
argument_list|)
operator|)
condition|)
name|perror
argument_list|(
literal|"unable to allocate in objc-tree.c"
argument_list|)
expr_stmt|;
name|impEntry
operator|->
name|next
operator|=
name|imp_list
expr_stmt|;
name|impEntry
operator|->
name|imp_context
operator|=
name|class
expr_stmt|;
name|impEntry
operator|->
name|imp_template
operator|=
name|implementation_template
expr_stmt|;
name|synth_forward_declarations
argument_list|()
expr_stmt|;
name|impEntry
operator|->
name|class_decl
operator|=
name|_OBJC_CLASS_decl
expr_stmt|;
name|impEntry
operator|->
name|meta_decl
operator|=
name|_OBJC_METACLASS_decl
expr_stmt|;
comment|/* append to front and increment count */
name|imp_list
operator|=
name|impEntry
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
name|imp_count
operator|++
expr_stmt|;
else|else
name|cat_count
operator|++
expr_stmt|;
return|return
name|ivar_context
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|INTERFACE_TYPE
condition|)
block|{
name|tree
name|record
init|=
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
condition|)
block|{
name|finish_struct
argument_list|(
name|record
argument_list|,
name|build_ivar_chain
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|CLASS_STATIC_TEMPLATE
argument_list|(
name|class
argument_list|)
operator|=
name|record
expr_stmt|;
comment|/* mark this record as a class template - for static typing */
name|TREE_STATIC_TEMPLATE
argument_list|(
name|record
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULLT
return|;
block|}
else|else
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/*  * this is called once we see the "@end" in an interface/implementation.  */
end_comment

begin_function
name|void
name|finish_class
parameter_list|(
name|class
parameter_list|)
name|tree
name|class
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* all code generation is done in finish_objc */
if|if
condition|(
name|implementation_template
operator|!=
name|implementation_context
condition|)
block|{
comment|/* ensure that all method listed in the interface contain bodies! */
name|check_methods
argument_list|(
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|check_methods
argument_list|(
name|CLASS_NST_METHODS
argument_list|(
name|implementation_template
argument_list|)
argument_list|,
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|CATEGORY_TYPE
condition|)
block|{
name|tree
name|category
init|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|implementation_template
argument_list|)
decl_stmt|;
comment|/* find the category interface from the class it is associated with */
while|while
condition|(
name|category
condition|)
block|{
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|class
argument_list|)
operator|==
name|CLASS_SUPER_NAME
argument_list|(
name|category
argument_list|)
condition|)
break|break;
name|category
operator|=
name|CLASS_CATEGORY_LIST
argument_list|(
name|category
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|category
condition|)
block|{
comment|/* ensure that all method listed in the interface contain bodies! */
name|check_methods
argument_list|(
name|CLASS_CLS_METHODS
argument_list|(
name|category
argument_list|)
argument_list|,
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
name|check_methods
argument_list|(
name|CLASS_NST_METHODS
argument_list|(
name|category
argument_list|)
argument_list|,
name|CLASS_NST_METHODS
argument_list|(
name|implementation_context
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|class
argument_list|)
operator|==
name|INTERFACE_TYPE
condition|)
block|{
name|tree
name|decl_specs
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|/* extern struct objc_object *_<my_name>; */
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"_%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|objc_object_reference
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|define_decl
argument_list|(
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|get_identifier
argument_list|(
name|string
argument_list|)
argument_list|)
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* "Encode" a data type into a string, whichg rows  in util_obstack.    ??? What is the FORMAT?  Someone please document this!  */
end_comment

begin_comment
comment|/* Encode a pointer type.  */
end_comment

begin_function
specifier|static
name|void
name|encode_pointer
parameter_list|(
name|type
parameter_list|,
name|format
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|tree
name|pointer_to
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer_to
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|pointer_to
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|pointer_to
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|pointer_to
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_OBJECT
argument_list|)
operator|==
literal|0
operator|)
comment|/* '@' */
operator|||
name|TREE_STATIC_TEMPLATE
argument_list|(
name|pointer_to
argument_list|)
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_CLASS
argument_list|)
operator|==
literal|0
condition|)
comment|/* '#' */
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|OBJC_INT_SELECTORS
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_SELECTOR
argument_list|)
operator|==
literal|0
condition|)
comment|/* ':' */
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* OBJC_INT_SELECTORS */
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointer_to
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_MODE
argument_list|(
name|pointer_to
argument_list|)
operator|==
name|QImode
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* we have a type that does not get special treatment... */
comment|/* NeXT extension */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
name|encode_type
argument_list|(
name|pointer_to
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_array
parameter_list|(
name|type
parameter_list|,
name|format
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|tree
name|anIntCst
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|array_of
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
comment|/* An incomplete array is treated like a pointer.  */
if|if
condition|(
name|anIntCst
operator|==
name|NULL
condition|)
block|{
comment|/* split for obvious reasons.  North-Keys 30 Mar 1991 */
name|encode_pointer
argument_list|(
name|type
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"[%d"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|anIntCst
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|array_of
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|encode_type
argument_list|(
name|array_of
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|encode_aggregate
parameter_list|(
name|type
parameter_list|,
name|format
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
block|{
name|int
name|have_pointer
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
operator|>
literal|0
operator|&&
operator|*
operator|(
name|obstack_next_free
argument_list|(
operator|&
name|util_obstack
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'^'
condition|)
name|have_pointer
operator|=
literal|1
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* we have an untagged structure or a typedef */
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_pointer
operator|||
name|format
operator|==
name|OBJC_ENCODE_DONT_INLINE_DEFS
condition|)
block|{
comment|/* we have a pointer 	       or we don't want the details.  */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
name|encode_field_decl
argument_list|(
name|fields
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|UNION_TYPE
case|:
block|{
name|int
name|have_pointer
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obstack_object_size
argument_list|(
operator|&
name|util_obstack
argument_list|)
operator|>
literal|0
operator|&&
operator|*
operator|(
name|obstack_next_free
argument_list|(
operator|&
name|util_obstack
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'^'
condition|)
name|have_pointer
operator|=
literal|1
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_pointer
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* we have an untagged structure or a typedef */
block|{
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_pointer
operator|||
name|format
operator|==
name|OBJC_ENCODE_DONT_INLINE_DEFS
condition|)
block|{
comment|/* we have a pointer 	       or we don't want the details.  */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
name|encode_field_decl
argument_list|(
name|fields
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ENUMERAL_TYPE
case|:
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  support bitfields, the current version of Objective-C does not support  *  them. the string will consist of one or more "b:n"'s where n is an  *  integer describing the width of the bitfield. Currently, classes in  *  the kit implement a method "-(char *)describeBitfieldStruct:" that  *  simulates this...if they do not implement this method, the archiver  *  assumes the bitfield is 16 bits wide (padded if necessary) and packed  *  according to the GNU compiler. After looking at the "kit", it appears  *  that all classes currently rely on this default behavior, rather than  *  hand generating this string (which is tedious).  */
end_comment

begin_function
specifier|static
name|void
name|encode_bitfield
parameter_list|(
name|width
parameter_list|,
name|format
parameter_list|)
name|int
name|width
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"b%d"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	format will be:  *  *	OBJC_ENCODE_INLINE_DEFS or OBJC_ENCODE_DONT_INLINE_DEFS  */
end_comment

begin_function
specifier|static
name|void
name|encode_type
parameter_list|(
name|type
parameter_list|,
name|format
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* unsigned integer types */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|QImode
condition|)
comment|/* 'C' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|HImode
condition|)
comment|/* 'S' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SImode
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|long_unsigned_type_node
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
comment|/* 'L' */
else|else
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
comment|/* 'I' */
block|}
block|}
else|else
comment|/* signed integer types */
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|QImode
condition|)
comment|/* 'c' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|HImode
condition|)
comment|/* 's' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SImode
condition|)
comment|/* 'i' */
block|{
if|if
condition|(
name|type
operator|==
name|long_integer_type_node
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
comment|/* 'l' */
else|else
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
comment|/* 'i' */
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* floating point types */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|SFmode
condition|)
comment|/* 'f' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|TFmode
condition|)
comment|/* 'd' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
comment|/* 'v' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'v'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
name|encode_array
argument_list|(
name|type
argument_list|,
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
name|encode_pointer
argument_list|(
name|type
argument_list|,
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|encode_aggregate
argument_list|(
name|type
argument_list|,
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
comment|/* '?' */
name|obstack_1grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_field_decl
parameter_list|(
name|field_decl
parameter_list|,
name|format
parameter_list|)
name|tree
name|field_decl
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field_decl
argument_list|)
condition|)
name|encode_bitfield
argument_list|(
name|DECL_FIELD_SIZE
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|else
name|encode_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field_decl
argument_list|)
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|tree
name|expr_last
parameter_list|(
name|complex_expr
parameter_list|)
name|tree
name|complex_expr
decl_stmt|;
block|{
name|tree
name|next
decl_stmt|;
if|if
condition|(
name|complex_expr
condition|)
while|while
condition|(
name|next
operator|=
name|TREE_OPERAND
argument_list|(
name|complex_expr
argument_list|,
literal|0
argument_list|)
condition|)
name|complex_expr
operator|=
name|next
expr_stmt|;
return|return
name|complex_expr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The selector of the current method,    or NULL if we aren't compiling a method.  */
end_comment

begin_function
name|tree
name|maybe_objc_method_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|method_context
condition|)
return|return
name|METHOD_SEL_NAME
argument_list|(
name|method_context
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Transform a method definition into a function definition as follows:  *  *  - synthesize the first two arguments, "self" and "_cmd".  */
end_comment

begin_function
name|void
name|start_method_def
parameter_list|(
name|method
parameter_list|)
name|tree
name|method
decl_stmt|;
block|{
name|tree
name|decl_specs
decl_stmt|;
comment|/* required to implement _msgSuper () */
name|method_context
operator|=
name|method
expr_stmt|;
name|_OBJC_SUPER_decl
operator|=
name|NULLT
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* must be called BEFORE "start_function ()" */
comment|/* generate prototype declarations for arguments..."new-style" */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|_PRIVATE_record
argument_list|)
expr_stmt|;
else|else
comment|/* really a `struct objc_class *'...however we allow people to        assign to self...which changes its type midstream.        */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|objc_object_reference
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|decl_specs
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|self_id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_INT_SELECTORS
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|decl_specs
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|decl_specs
argument_list|,
name|_cmd_id
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not OBJC_INT_SELECTORS */
name|decl_specs
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|xref_tag
argument_list|(
name|RECORD_TYPE
argument_list|,
name|get_identifier
argument_list|(
name|TAG_SELECTOR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|decl_specs
argument_list|,
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|NULLT
argument_list|,
name|_cmd_id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not OBJC_INT_SELECTORS */
comment|/* generate argument declarations if a keyword_decl */
if|if
condition|(
name|METHOD_SEL_ARGS
argument_list|(
name|method
argument_list|)
condition|)
block|{
name|tree
name|arglist
init|=
name|METHOD_SEL_ARGS
argument_list|(
name|method
argument_list|)
decl_stmt|;
do|do
block|{
name|tree
name|arg_spec
init|=
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|arg_decl
init|=
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_decl
condition|)
block|{
name|tree
name|last_expr
init|=
name|expr_last
argument_list|(
name|arg_decl
argument_list|)
decl_stmt|;
comment|/* unite the abstract decl with its name */
name|TREE_OPERAND
argument_list|(
name|last_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|KEYWORD_ARG_NAME
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|arg_spec
argument_list|,
name|arg_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* unhook...restore the abstract declarator */
name|TREE_OPERAND
argument_list|(
name|last_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|NULLT
expr_stmt|;
block|}
else|else
name|push_parm_decl
argument_list|(
name|build_tree_list
argument_list|(
name|arg_spec
argument_list|,
name|KEYWORD_ARG_NAME
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|arglist
condition|)
do|;
block|}
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
operator|>
operator|(
name|tree
operator|)
literal|1
condition|)
block|{
comment|/* we have a variable length selector - in "prototype" format */
name|tree
name|akey
init|=
name|TREE_PURPOSE
argument_list|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|akey
condition|)
block|{
comment|/* this must be done prior to calling pushdecl (). pushdecl () is 	   * going to change our chain on us... 	   */
name|tree
name|nextkey
init|=
name|TREE_CHAIN
argument_list|(
name|akey
argument_list|)
decl_stmt|;
name|pushdecl
argument_list|(
name|akey
argument_list|)
expr_stmt|;
name|akey
operator|=
name|nextkey
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|error_with_method
parameter_list|(
name|message
parameter_list|,
name|mtype
parameter_list|,
name|method
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
name|mtype
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|method
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s `%c%s'\n"
argument_list|,
name|message
argument_list|,
name|mtype
argument_list|,
name|gen_method_decl
argument_list|(
name|method
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|warn_with_method
parameter_list|(
name|message
parameter_list|,
name|mtype
parameter_list|,
name|method
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
name|mtype
decl_stmt|;
name|tree
name|method
decl_stmt|;
block|{
name|count_error
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|method
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s `%c%s'\n"
argument_list|,
name|message
argument_list|,
name|mtype
argument_list|,
name|gen_method_decl
argument_list|(
name|method
argument_list|,
name|errbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return 1 if `method' is consistent with `proto' */
end_comment

begin_function
specifier|static
name|int
name|comp_method_with_proto
parameter_list|(
name|method
parameter_list|,
name|proto
parameter_list|)
name|tree
name|method
decl_stmt|,
name|proto
decl_stmt|;
block|{
specifier|static
name|tree
name|function_type
init|=
literal|0
decl_stmt|;
comment|/* create a function_type node once */
if|if
condition|(
operator|!
name|function_type
condition|)
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|function_type
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
block|}
comment|/* install argument types - normally set by "build_function_type ()". */
name|TYPE_ARG_TYPES
argument_list|(
name|function_type
argument_list|)
operator|=
name|get_arg_type_list
argument_list|(
name|proto
argument_list|,
name|METHOD_DEF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* install return type */
name|TREE_TYPE
argument_list|(
name|function_type
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|METHOD_DEFINITION
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|,
name|function_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* return 1 if `proto1' is consistent with `proto2' */
end_comment

begin_function
specifier|static
name|int
name|comp_proto_with_proto
parameter_list|(
name|proto1
parameter_list|,
name|proto2
parameter_list|)
name|tree
name|proto1
decl_stmt|,
name|proto2
decl_stmt|;
block|{
specifier|static
name|tree
name|function_type1
init|=
literal|0
decl_stmt|,
name|function_type2
init|=
literal|0
decl_stmt|;
comment|/* create a couple function_type node's once */
if|if
condition|(
operator|!
name|function_type1
condition|)
block|{
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|function_type1
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|function_type2
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
block|}
comment|/* install argument types - normally set by "build_function_type ()". */
name|TYPE_ARG_TYPES
argument_list|(
name|function_type1
argument_list|)
operator|=
name|get_arg_type_list
argument_list|(
name|proto1
argument_list|,
name|METHOD_REF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|function_type2
argument_list|)
operator|=
name|get_arg_type_list
argument_list|(
name|proto2
argument_list|,
name|METHOD_REF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* install return type */
name|TREE_TYPE
argument_list|(
name|function_type1
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|proto1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function_type2
argument_list|)
operator|=
name|groktypename
argument_list|(
name|TREE_TYPE
argument_list|(
name|proto2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|comptypes
argument_list|(
name|function_type1
argument_list|,
name|function_type2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  - generate an identifier for the function. the format is "_n_cls",  *    where 1<= n<= nMethods, and cls is the name the implementation we  *    are processing.  *  - install the return type from the method declaration.  *  - if we have a prototype, check for type consistency.  */
end_comment

begin_function
specifier|static
name|void
name|really_start_method
parameter_list|(
name|method
parameter_list|,
name|parmlist
parameter_list|)
name|tree
name|method
decl_stmt|,
name|parmlist
decl_stmt|;
block|{
name|tree
name|sc_spec
decl_stmt|,
name|ret_spec
decl_stmt|,
name|ret_decl
decl_stmt|,
name|decl_specs
decl_stmt|;
name|tree
name|method_decl
decl_stmt|,
name|method_id
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* synth the storage class& assemble the return type */
name|sc_spec
operator|=
name|tree_cons
argument_list|(
name|NULLT
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
name|ret_spec
operator|=
name|TREE_PURPOSE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|decl_specs
operator|=
name|chainon
argument_list|(
name|sc_spec
argument_list|,
name|ret_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* Make sure this is big enough for any plausible method label.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|50
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_GEN_METHOD_LABEL
name|OBJC_GEN_METHOD_LABEL
argument_list|(
name|buf
argument_list|,
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_%d_%s"
argument_list|,
operator|++
name|method_slot
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* we have a category */
block|{
comment|/* Make sure this is big enough for any plausible method label.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|50
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_GEN_METHOD_LABEL
name|OBJC_GEN_METHOD_LABEL
argument_list|(
name|buf
argument_list|,
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_%d_%s_%s"
argument_list|,
operator|++
name|method_slot
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|method_id
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|method_decl
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|method_id
argument_list|,
name|parmlist
argument_list|,
name|NULLT
argument_list|)
expr_stmt|;
comment|/* check the declarator portion of the return type for the method */
if|if
condition|(
name|ret_decl
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
condition|)
block|{
comment|/*        * unite the complex decl (specified in the abstract decl) with the        * function decl just synthesized...(int *), (int (*)()), (int (*)[]).        */
name|tree
name|save_expr
init|=
name|expr_last
argument_list|(
name|ret_decl
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|save_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|method_decl
expr_stmt|;
name|method_decl
operator|=
name|ret_decl
expr_stmt|;
comment|/* fool the parser into thinking it is starting a function */
name|start_function
argument_list|(
name|decl_specs
argument_list|,
name|method_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unhook...this has the effect of restoring the abstract declarator */
name|TREE_OPERAND
argument_list|(
name|save_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|NULLT
expr_stmt|;
block|}
else|else
block|{
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
operator|=
name|method_decl
expr_stmt|;
comment|/* fool the parser into thinking it is starting a function */
name|start_function
argument_list|(
name|decl_specs
argument_list|,
name|method_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unhook...this has the effect of restoring the abstract declarator */
name|TREE_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
operator|=
name|NULLT
expr_stmt|;
block|}
name|METHOD_DEFINITION
argument_list|(
name|method
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* check consistency...start_function (), pushdecl (), duplicate_decls (). */
if|if
condition|(
name|implementation_template
operator|!=
name|implementation_context
condition|)
block|{
name|tree
name|chain
decl_stmt|,
name|proto
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|chain
operator|=
name|CLASS_NST_METHODS
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
else|else
name|chain
operator|=
name|CLASS_CLS_METHODS
argument_list|(
name|implementation_template
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|=
name|lookup_method
argument_list|(
name|chain
argument_list|,
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|comp_method_with_proto
argument_list|(
name|method
argument_list|,
name|proto
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: In method `%s'\n"
argument_list|,
name|input_filename
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
block|{
name|error_with_method
argument_list|(
literal|"conflicting types for"
argument_list|,
literal|'-'
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|error_with_method
argument_list|(
literal|"previous declaration of"
argument_list|,
literal|'-'
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_with_method
argument_list|(
literal|"conflicting types for"
argument_list|,
literal|'+'
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|error_with_method
argument_list|(
literal|"previous declaration of"
argument_list|,
literal|'+'
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * the following routine is always called...this "architecture" is to  * accommodate "old-style" variable length selectors.  *  *	- a:a b:b // prototype  ; id c; id d; // old-style  */
end_comment

begin_function
name|void
name|continue_method_def
parameter_list|()
block|{
name|tree
name|parmlist
decl_stmt|;
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|method_context
argument_list|)
operator|==
operator|(
name|tree
operator|)
literal|1
condition|)
comment|/*      * we have a `, ...' immediately following the selector.      */
name|parmlist
operator|=
name|get_parm_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|parmlist
operator|=
name|get_parm_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* place a `void_at_end' */
comment|/* set self_decl from the first argument...this global is used by    * build_ivar_reference ().build_indirect_ref ().    */
name|self_decl
operator|=
name|TREE_PURPOSE
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* must be called BEFORE "start_function ()" */
name|really_start_method
argument_list|(
name|method_context
argument_list|,
name|parmlist
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
comment|/* must be called AFTER "start_function ()" */
block|}
end_function

begin_function
name|void
name|add_objc_decls
parameter_list|()
block|{
if|if
condition|(
operator|!
name|_OBJC_SUPER_decl
condition|)
name|_OBJC_SUPER_decl
operator|=
name|start_decl
argument_list|(
name|get_identifier
argument_list|(
name|_TAG_SUPER
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|objc_super_template
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this prevents `unused variable' warnings when compiling with `-Wall' */
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|_OBJC_SUPER_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	_n_Method (id self, SEL sel, ...)  *	{  *		struct objc_super _S;  *  *		_msgSuper ((_S.self = self, _S.class = _cls,&_S), ...);  *	}  */
end_comment

begin_function
name|tree
name|get_super_receiver
parameter_list|()
block|{
if|if
condition|(
name|method_context
condition|)
block|{
name|tree
name|super_expr
decl_stmt|,
name|super_expr_list
decl_stmt|;
comment|/* set receiver to self */
name|super_expr
operator|=
name|build_component_ref
argument_list|(
name|_OBJC_SUPER_decl
argument_list|,
name|self_id
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_modify_expr
argument_list|(
name|super_expr
argument_list|,
name|NOP_EXPR
argument_list|,
name|self_decl
argument_list|)
expr_stmt|;
name|super_expr_list
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|super_expr
argument_list|)
expr_stmt|;
comment|/* set class to begin searching */
name|super_expr
operator|=
name|build_component_ref
argument_list|(
name|_OBJC_SUPER_decl
argument_list|,
name|get_identifier
argument_list|(
literal|"class"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* [_cls, __cls]Super are "pre-built" in synth_foward_declarations () */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|super_expr
operator|=
name|build_modify_expr
argument_list|(
name|super_expr
argument_list|,
name|NOP_EXPR
argument_list|,
name|_clsSuper_ref
argument_list|)
expr_stmt|;
else|else
name|super_expr
operator|=
name|build_modify_expr
argument_list|(
name|super_expr
argument_list|,
name|NOP_EXPR
argument_list|,
name|__clsSuper_ref
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* we have a category... */
block|{
name|tree
name|params
decl_stmt|,
name|super_name
init|=
name|CLASS_SUPER_NAME
argument_list|(
name|implementation_template
argument_list|)
decl_stmt|;
name|tree
name|funcCall
decl_stmt|;
if|if
condition|(
operator|!
name|super_name
condition|)
comment|/* Barf if super used in a category of Object. */
block|{
name|error
argument_list|(
literal|"no super class declared in interface for `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|implementation_template
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|add_class_reference
argument_list|(
name|super_name
argument_list|)
expr_stmt|;
name|params
operator|=
name|build_tree_list
argument_list|(
name|NULLT
argument_list|,
name|my_build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|super_name
argument_list|)
operator|+
literal|1
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|super_name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|method_context
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
condition|)
name|funcCall
operator|=
name|build_function_call
argument_list|(
name|objc_getClass_decl
argument_list|,
name|params
argument_list|)
expr_stmt|;
else|else
name|funcCall
operator|=
name|build_function_call
argument_list|(
name|objc_getMetaClass_decl
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* cast! */
name|TREE_TYPE
argument_list|(
name|funcCall
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|_clsSuper_ref
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_modify_expr
argument_list|(
name|super_expr
argument_list|,
name|NOP_EXPR
argument_list|,
name|funcCall
argument_list|)
expr_stmt|;
block|}
name|chainon
argument_list|(
name|super_expr_list
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|super_expr
argument_list|)
argument_list|)
expr_stmt|;
name|super_expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|_OBJC_SUPER_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|super_expr_list
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|super_expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_compound_expr
argument_list|(
name|super_expr_list
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"[super ...] must appear in a method context"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|encode_method_def
parameter_list|(
name|func_decl
parameter_list|)
name|tree
name|func_decl
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|stack_size
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|tree
name|result
decl_stmt|;
comment|/* return type */
name|encode_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|func_decl
argument_list|)
argument_list|)
argument_list|,
name|OBJC_ENCODE_DONT_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* stack size */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|func_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
name|stack_size
operator|+=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|stack_size
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* argument types */
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|func_decl
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|int
name|offset_in_bytes
decl_stmt|;
comment|/* type */
name|encode_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|OBJC_ENCODE_DONT_INLINE_DEFS
argument_list|)
expr_stmt|;
comment|/* compute offset */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* ??? Here we assume that the parm address is indexed 	      off the frame pointer or arg pointer. 	      If that is not true, we produce meaningless results, 	      but do not crash.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset_in_bytes
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset_in_bytes
operator|=
literal|0
expr_stmt|;
comment|/* This is the case where the parm is passed as an int or double 	      and it is converted to a char, short or float and stored back 	      in the parmlist.  In this case, describe the parm 	      with the variable's declared type, and adjust the address 	      if the least significant bytes (which we are using) are not 	      the first ones.  */
if|#
directive|if
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
condition|)
name|offset_in_bytes
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|offset_in_bytes
operator|=
literal|0
expr_stmt|;
comment|/* The "+ 4" is a total hack to account for the return pc and          saved fp on the 68k.  We should redefine this format! */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|offset_in_bytes
operator|+
literal|8
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|get_identifier
argument_list|(
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|util_obstack
argument_list|,
name|util_firstobj
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|finish_method_def
parameter_list|()
block|{
name|METHOD_ENCODING
argument_list|(
name|method_context
argument_list|)
operator|=
name|encode_method_def
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* this must be done AFTER finish_function, since the optimizer may      find "may be used before set" errors.  */
name|method_context
operator|=
name|NULLT
expr_stmt|;
comment|/* required to implement _msgSuper () */
block|}
end_function

begin_function
name|int
name|lang_report_error_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|method_context
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In method `%s'\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_complex_decl
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code to convert a decl node into text for a declaration in C.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|adorn_decl
parameter_list|(
name|decl
parameter_list|,
name|str
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|anIntCst
init|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|anIntCst
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|anIntCst
init|=
name|TYPE_SIZE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|array_of
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"[%d]"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|anIntCst
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|array_of
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|tree
name|chain
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* a list of types */
name|strcat
argument_list|(
name|str
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
while|while
condition|(
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|gen_declaration
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
operator|!=
name|void_type_node
condition|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|str
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gen_declarator
parameter_list|(
name|decl
parameter_list|,
name|buf
parameter_list|,
name|name
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|decl
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|int
name|wrap
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|CALL_EXPR
case|:
block|{
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we have a pointer to a function or array...(*)(), (*)[] */
if|if
condition|(
operator|(
name|code
operator|==
name|ARRAY_REF
operator|||
name|code
operator|==
name|CALL_EXPR
operator|)
operator|&&
operator|(
name|op
operator|&&
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|INDIRECT_REF
operator|)
condition|)
name|wrap
operator|=
literal|1
expr_stmt|;
name|str
operator|=
name|gen_declarator
argument_list|(
name|op
argument_list|,
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap
condition|)
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
name|adorn_decl
argument_list|(
name|decl
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
block|{
name|str
operator|=
name|strcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* this clause is done iteratively...rather than recursively */
do|do
block|{
name|op
operator|=
name|is_complex_decl
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
else|:
name|NULLT
expr_stmt|;
name|adorn_decl
argument_list|(
name|decl
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* we have a pointer to a function or array...(*)(), (*)[] */
if|if
condition|(
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|)
operator|&&
operator|(
name|op
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|is_complex_decl
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
else|:
name|NULLT
expr_stmt|;
block|}
do|while
condition|(
name|decl
operator|&&
operator|(
name|code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
do|;
break|break;
block|}
case|case
name|IDENTIFIER_NODE
case|:
comment|/* will only happen if we are processing a "raw" expr-decl. */
return|return
name|strcpy
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
return|return
name|str
return|;
block|}
else|else
comment|/* we have an abstract declarator or a _DECL node */
block|{
return|return
name|strcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gen_declspecs
parameter_list|(
name|declspecs
parameter_list|,
name|buf
parameter_list|,
name|raw
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|raw
decl_stmt|;
block|{
if|if
condition|(
name|raw
condition|)
block|{
name|tree
name|chain
decl_stmt|;
for|for
control|(
name|chain
operator|=
name|declspecs
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|tree
name|aspec
init|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|aspec
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|aspec
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged struct"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|aspec
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged union"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|aspec
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|aspec
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|aspec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"untagged enum"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|declspecs
argument_list|)
condition|)
block|{
comment|/* type specifiers */
case|case
name|INTEGER_TYPE
case|:
comment|/* signed integer types */
if|if
condition|(
name|declspecs
operator|==
name|short_integer_type_node
condition|)
comment|/* 's' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"short int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|integer_type_node
condition|)
comment|/* 'i' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|long_integer_type_node
condition|)
comment|/* 'l' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"long int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|signed_char_type_node
operator|||
comment|/* 'c' */
name|declspecs
operator|==
name|char_type_node
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"char "
argument_list|)
expr_stmt|;
comment|/* unsigned integer types */
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|short_unsigned_type_node
condition|)
comment|/* 'S' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned short "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|unsigned_type_node
condition|)
comment|/* 'I' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned int "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|long_unsigned_type_node
condition|)
comment|/* 'L' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned long "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|unsigned_char_type_node
condition|)
comment|/* 'C' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"unsigned char "
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
comment|/* floating point types */
if|if
condition|(
name|declspecs
operator|==
name|float_type_node
condition|)
comment|/* 'f' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"float "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|double_type_node
condition|)
comment|/* 'd' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"double "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|==
name|long_double_type_node
condition|)
comment|/* 'd' */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"long double "
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
operator|!
name|TREE_STATIC_TEMPLATE
argument_list|(
name|declspecs
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNION_TYPE
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|declspecs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VOID_TYPE
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"void "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gen_declaration
parameter_list|(
name|atype_or_adecl
parameter_list|,
name|buf
parameter_list|)
name|tree
name|atype_or_adecl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
name|declbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|declspecs
decl_stmt|;
comment|/* "identifier_node", "record_type" */
name|tree
name|declarator
decl_stmt|;
comment|/* "array_ref", "indirect_ref", "call_expr"... */
comment|/* we have a "raw", abstract declarator (typename) */
name|declarator
operator|=
name|TREE_VALUE
argument_list|(
name|atype_or_adecl
argument_list|)
expr_stmt|;
name|declspecs
operator|=
name|TREE_PURPOSE
argument_list|(
name|atype_or_adecl
argument_list|)
expr_stmt|;
name|gen_declspecs
argument_list|(
name|declspecs
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|gen_declarator
argument_list|(
name|declarator
argument_list|,
name|declbuf
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|atype
decl_stmt|;
name|tree
name|declspecs
decl_stmt|;
comment|/* "integer_type", "real_type", "record_type"... */
name|tree
name|declarator
decl_stmt|;
comment|/* "array_type", "function_type", "pointer_type". */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|atype
operator|=
name|TREE_TYPE
argument_list|(
name|atype_or_adecl
argument_list|)
expr_stmt|;
else|else
name|atype
operator|=
name|atype_or_adecl
expr_stmt|;
comment|/* assume we have a *_type node */
if|if
condition|(
name|is_complex_decl
argument_list|(
name|atype
argument_list|)
condition|)
block|{
name|tree
name|chain
decl_stmt|;
comment|/* get the declaration specifier...it is at the end of the list */
name|declarator
operator|=
name|chain
operator|=
name|atype
expr_stmt|;
do|do
name|chain
operator|=
name|TREE_TYPE
argument_list|(
name|chain
argument_list|)
expr_stmt|;
comment|/* not TREE_CHAIN (chain); */
do|while
condition|(
name|is_complex_decl
argument_list|(
name|chain
argument_list|)
condition|)
do|;
name|declspecs
operator|=
name|chain
expr_stmt|;
block|}
else|else
block|{
name|declspecs
operator|=
name|atype
expr_stmt|;
name|declarator
operator|=
name|NULLT
expr_stmt|;
block|}
name|gen_declspecs
argument_list|(
name|declspecs
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|atype_or_adecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|declarator
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|gen_declarator
argument_list|(
name|declarator
argument_list|,
name|declbuf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|atype_or_adecl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|atype_or_adecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|gen_declarator
argument_list|(
name|declarator
argument_list|,
name|declbuf
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RAW_TYPESPEC
parameter_list|(
name|meth
parameter_list|)
value|(TREE_VALUE (TREE_PURPOSE (TREE_TYPE (meth))))
end_define

begin_function
specifier|static
name|char
modifier|*
name|gen_method_decl
parameter_list|(
name|method
parameter_list|,
name|buf
parameter_list|)
name|tree
name|method
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|tree
name|chain
decl_stmt|;
if|if
condition|(
name|RAW_TYPESPEC
argument_list|(
name|method
argument_list|)
operator|!=
name|objc_object_reference
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|TREE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|chain
operator|=
name|METHOD_SEL_ARGS
argument_list|(
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
condition|)
block|{
comment|/* we have a chain of keyword_decls */
do|do
block|{
if|if
condition|(
name|KEYWORD_KEY_NAME
argument_list|(
name|chain
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|KEYWORD_KEY_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAW_TYPESPEC
argument_list|(
name|chain
argument_list|)
operator|!=
name|objc_object_reference
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|TREE_TYPE
argument_list|(
name|chain
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|KEYWORD_ARG_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
operator|==
operator|(
name|tree
operator|)
literal|1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ..."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
condition|)
block|{
comment|/* we have a tree list node as generate by `get_parm_info ()' */
name|chain
operator|=
name|TREE_PURPOSE
argument_list|(
name|METHOD_ADD_ARGS
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
comment|/* know we have a chain of parm_decls */
while|while
condition|(
name|chain
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|chain
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* we have a unary selector */
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|method
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|gen_prototype
parameter_list|(
name|fp
parameter_list|,
name|decl
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
comment|/* we have a function definition - generate prototype */
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|decl
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s;\n"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  debug info...  */
end_comment

begin_function
specifier|static
name|void
name|dump_interface
parameter_list|(
name|fp
parameter_list|,
name|chain
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|tree
name|chain
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|char
modifier|*
name|my_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ivar_decls
init|=
name|CLASS_RAW_IVARS
argument_list|(
name|chain
argument_list|)
decl_stmt|;
name|tree
name|nst_methods
init|=
name|CLASS_NST_METHODS
argument_list|(
name|chain
argument_list|)
decl_stmt|;
name|tree
name|cls_methods
init|=
name|CLASS_CLS_METHODS
argument_list|(
name|chain
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n@interface %s"
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_SUPER_NAME
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|char
modifier|*
name|super_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|chain
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" : %s\n"
argument_list|,
name|super_name
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivar_decls
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s;\n"
argument_list|,
name|gen_declaration
argument_list|(
name|ivar_decls
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ivar_decls
operator|=
name|TREE_CHAIN
argument_list|(
name|ivar_decls
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ivar_decls
condition|)
do|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nst_methods
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"- %s;\n"
argument_list|,
name|gen_method_decl
argument_list|(
name|nst_methods
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|nst_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|nst_methods
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cls_methods
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"+ %s;\n"
argument_list|,
name|gen_method_decl
argument_list|(
name|cls_methods
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cls_methods
operator|=
name|TREE_CHAIN
argument_list|(
name|cls_methods
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n@end"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_objc
parameter_list|()
block|{
comment|/* Add the special tree codes of Objective C to the tables.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|util_obstack
argument_list|)
expr_stmt|;
name|util_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|util_obstack
argument_list|)
expr_stmt|;
name|tree_code_type
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_type
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|LAST_OBJC_TREE_CODE
argument_list|)
expr_stmt|;
name|tree_code_length
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|LAST_OBJC_TREE_CODE
argument_list|)
expr_stmt|;
name|tree_code_name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_name
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|LAST_OBJC_TREE_CODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|objc_tree_code_type
argument_list|,
name|tree_code_type
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
operator|(
operator|(
operator|(
name|int
operator|)
name|LAST_OBJC_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|objc_tree_code_length
argument_list|,
name|tree_code_length
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
operator|(
operator|(
operator|(
name|int
operator|)
name|LAST_OBJC_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|objc_tree_code_name
argument_list|,
name|tree_code_name
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
operator|(
operator|(
operator|(
name|int
operator|)
name|LAST_OBJC_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|errbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|BUFSIZE
argument_list|)
expr_stmt|;
name|hash_init
argument_list|()
expr_stmt|;
name|synth_module_prologue
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|finish_objc
parameter_list|()
block|{
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
name|tree
name|chain
decl_stmt|;
name|generate_forward_declaration_to_string_table
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJC_PROLOGUE
name|OBJC_PROLOGUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|implementation_context
operator|||
name|sel_refdef_chain
condition|)
name|generate_objc_symtab_decl
argument_list|()
expr_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
block|{
name|implementation_context
operator|=
name|impent
operator|->
name|imp_context
expr_stmt|;
name|implementation_template
operator|=
name|impent
operator|->
name|imp_template
expr_stmt|;
name|_OBJC_CLASS_decl
operator|=
name|impent
operator|->
name|class_decl
expr_stmt|;
name|_OBJC_METACLASS_decl
operator|=
name|impent
operator|->
name|meta_decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|implementation_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
block|{
comment|/* all of the following reference the string pool...  */
name|generate_ivar_lists
argument_list|()
expr_stmt|;
name|generate_dispatch_tables
argument_list|()
expr_stmt|;
name|generate_shared_structures
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|generate_dispatch_tables
argument_list|()
expr_stmt|;
name|generate_category
argument_list|(
name|implementation_context
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are using an array of selectors, we must always      finish up the array decl even if no selectors were used.  */
ifndef|#
directive|ifndef
name|OBJC_SELECTORS_WITHOUT_LABELS
if|if
condition|(
name|sel_ref_chain
condition|)
endif|#
directive|endif
name|build_selector_translation_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|implementation_context
operator|||
name|sel_refdef_chain
condition|)
block|{
comment|/* Arrange for Objc data structures to be initialized at run time.  */
name|char
modifier|*
name|init_name
init|=
name|build_module_descriptor
argument_list|()
decl_stmt|;
if|if
condition|(
name|init_name
condition|)
name|assemble_constructor
argument_list|(
name|init_name
argument_list|)
expr_stmt|;
block|}
comment|/* dump the string table last */
if|if
condition|(
name|sel_refdef_chain
condition|)
block|{
name|build_message_selector_pool
argument_list|()
expr_stmt|;
block|}
comment|/* dump the class references...this forces the appropriate classes      to be linked into the executable image, preserving unix archive      semantics...this can be removed when we move to a more dynamically      linked environment      */
for|for
control|(
name|chain
operator|=
name|cls_ref_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
name|handle_class_ref
argument_list|(
name|chain
argument_list|)
expr_stmt|;
for|for
control|(
name|impent
operator|=
name|imp_list
init|;
name|impent
condition|;
name|impent
operator|=
name|impent
operator|->
name|next
control|)
name|handle_impent
argument_list|(
name|impent
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If GAS has such a bug, let's fix it.  */
comment|/*** this fixes a gross bug in the assembler...it `expects' #APP to have    *** a matching #NO_APP, or it crashes (sometimes). app_disable () will    *** insure this is the case. 5/19/89, s.naroff.    ***/
block|if (cls_ref_chain || imp_list)     app_disable ();
endif|#
directive|endif
if|if
condition|(
name|flag_gen_declaration
condition|)
block|{
name|add_class
argument_list|(
name|implementation_context
argument_list|)
expr_stmt|;
name|dump_interface
argument_list|(
name|gen_declaration_file
argument_list|,
name|implementation_context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_selector
condition|)
block|{
name|int
name|slot
decl_stmt|;
comment|/* Run through the selector hash tables and print a warning for any          selector which has multiple methods. */
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|SIZEHASHTABLE
condition|;
name|slot
operator|++
control|)
block|{
name|hash
name|hsh
decl_stmt|;
for|for
control|(
name|hsh
operator|=
name|cls_method_hash_list
index|[
name|slot
index|]
init|;
name|hsh
condition|;
name|hsh
operator|=
name|hsh
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hsh
operator|->
name|list
condition|)
block|{
name|tree
name|meth
init|=
name|hsh
operator|->
name|key
decl_stmt|;
name|char
name|type
init|=
operator|(
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
literal|'-'
else|:
literal|'+'
decl_stmt|;
name|attr
name|loop
decl_stmt|;
name|warning
argument_list|(
literal|"potential selector conflict for method `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
literal|"found"
argument_list|,
name|type
argument_list|,
name|meth
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|warn_with_method
argument_list|(
literal|"found"
argument_list|,
name|type
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|SIZEHASHTABLE
condition|;
name|slot
operator|++
control|)
block|{
name|hash
name|hsh
decl_stmt|;
for|for
control|(
name|hsh
operator|=
name|nst_method_hash_list
index|[
name|slot
index|]
init|;
name|hsh
condition|;
name|hsh
operator|=
name|hsh
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hsh
operator|->
name|list
condition|)
block|{
name|tree
name|meth
init|=
name|hsh
operator|->
name|key
decl_stmt|;
name|char
name|type
init|=
operator|(
name|TREE_CODE
argument_list|(
name|meth
argument_list|)
operator|==
name|INSTANCE_METHOD_DECL
operator|)
condition|?
literal|'-'
else|:
literal|'+'
decl_stmt|;
name|attr
name|loop
decl_stmt|;
name|warning
argument_list|(
literal|"potential selector conflict for method `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|METHOD_SEL_NAME
argument_list|(
name|meth
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warn_with_method
argument_list|(
literal|"found"
argument_list|,
name|type
argument_list|,
name|meth
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|hsh
operator|->
name|list
init|;
name|loop
condition|;
name|loop
operator|=
name|loop
operator|->
name|next
control|)
name|warn_with_method
argument_list|(
literal|"found"
argument_list|,
name|type
argument_list|,
name|loop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of finish_objc.  */
end_comment

begin_macro
name|handle_class_ref
argument_list|(
argument|chain
argument_list|)
end_macro

begin_decl_stmt
name|tree
name|chain
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"__objc_class_name_%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a decl for this name, so we can use its address in a tree.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|string
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make following constant read-only (why not)?  */
name|text_section
argument_list|()
expr_stmt|;
comment|/* Output a constant to reference this address.  */
name|output_constant
argument_list|(
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_type_node
argument_list|,
name|decl
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|string_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|handle_impent
argument_list|(
argument|impent
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|imp_entry
modifier|*
name|impent
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|implementation_context
operator|=
name|impent
operator|->
name|imp_context
expr_stmt|;
name|implementation_template
operator|=
name|impent
operator|->
name|imp_template
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|IMPLEMENTATION_TYPE
condition|)
block|{
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"__objc_class_name_%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_global
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
operator|==
name|CATEGORY_TYPE
condition|)
block|{
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
comment|/* Do the same for categories.  Even though no references to these 	  symbols are generated automatically by the compiler, it gives 	  you a handle to pull them into an archive by hand. */
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"__objc_category_name_%s_%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|CLASS_SUPER_NAME
argument_list|(
name|impent
operator|->
name|imp_context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_global
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|assemble_label
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|objc_debug
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|256
argument_list|)
decl_stmt|;
block|{
comment|/* dump function prototypes */
name|tree
name|loop
init|=
name|_OBJC_MODULES_decl
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\nfunction prototypes:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|loop
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|loop
argument_list|)
condition|)
block|{
comment|/* we have a function definition - generate prototype */
name|bzero
argument_list|(
name|errbuf
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|gen_declaration
argument_list|(
name|loop
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s;\n"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
name|loop
operator|=
name|TREE_CHAIN
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
block|{
comment|/* dump global chains */
name|tree
name|loop
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|hash
name|hashlist
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEHASHTABLE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hashlist
operator|=
name|nst_method_hash_list
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\nnst_method_hash_list[%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-%s;\n"
argument_list|,
name|gen_method_decl
argument_list|(
name|hashlist
operator|->
name|key
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|hashlist
operator|=
name|hashlist
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|hashlist
condition|)
do|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEHASHTABLE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hashlist
operator|=
name|cls_method_hash_list
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\ncls_method_hash_list[%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"-%s;\n"
argument_list|,
name|gen_method_decl
argument_list|(
name|hashlist
operator|->
name|key
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|hashlist
operator|=
name|hashlist
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|hashlist
condition|)
do|;
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nsel_refdef_chain:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|sel_refdef_chain
init|;
name|loop
condition|;
name|loop
operator|=
name|TREE_CHAIN
argument_list|(
name|loop
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(index: %4d offset: %4d) %s\n"
argument_list|,
name|index
argument_list|,
name|offset
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|loop
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* add one for the '\0' character */
name|offset
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|loop
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n (max_selector_index: %4d.\n"
argument_list|,
name|max_selector_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_lang_statistics
parameter_list|()
block|{ }
end_function

end_unit

