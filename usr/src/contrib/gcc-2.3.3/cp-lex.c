begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Seperate lexical analyzer for GNU C++.    Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file is the lexical analyzer for GNU C++.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GATHER_STATISTICS
argument_list|)
operator|||
name|defined
argument_list|(
name|SPEW_DEBUG
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|YYDEBUG
end_undef

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-lex.h"
end_include

begin_include
include|#
directive|include
file|"cp-parse.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needed for VAX.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|jmp_buf
name|toplevel
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|expression_obstack
decl_stmt|,
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|get_directive_line
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* In c-common.c */
end_comment

begin_comment
comment|/* Given a file name X, return the nondirectory portion.    Keep in mind that X can be computed more than once.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FILE_NAME_NONDIRECTORY
end_ifndef

begin_define
define|#
directive|define
name|FILE_NAME_NONDIRECTORY
parameter_list|(
name|X
parameter_list|)
define|\
value|(rindex (X, '/') != 0 ? rindex (X, '/') + 1 : X)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|extract_interface_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|yyerror
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This obstack is needed to hold text.  It is not safe to use    TOKEN_BUFFER because `check_newline' calls `yylex'.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|inline_text_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inline_text_firstobj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|end_of_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|first_token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|token_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? Don't really know where this goes yet.  */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_include
include|#
directive|include
file|"cp-input.c"
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|void
name|put_back
parameter_list|(
comment|/* int */
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|input_redirected
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|feed_input
parameter_list|(
comment|/* char *, int, struct obstack * */
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Holds translations from TREE_CODEs to operator name strings,    i.e., opname_tab[PLUS_EXPR] == "+".  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|opname_tab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|assignop_tab
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the lookahead symbol		*/
end_comment

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the semantic value of the		*/
end_comment

begin_comment
comment|/*  lookahead symbol			*/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|YYLTYPE yylloc;
comment|/*  location data for the lookahead	*/
end_comment

begin_comment
comment|/*  symbol				*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.    yylex must look this up to detect typedefs, which get token type TYPENAME,    so it is left around in case the identifier is not a typedef but is    used in a context which makes it a reference to a variable.  */
end_comment

begin_decl_stmt
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The elements of `ridpointers' are identifier nodes    for the reserved type names and storage classes.    It is indexed by a RID_... value.  */
end_comment

begin_decl_stmt
name|tree
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We may keep statistics about how long which files took to compile.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|header_time
decl_stmt|,
name|body_time
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|get_time_identifier
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|tree
name|filename_times
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|this_filename_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For implementing #pragma unit.  */
end_comment

begin_decl_stmt
name|tree
name|current_unit_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_unit_language
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array for holding counts of the numbers of tokens seen.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|token_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Textual definition used for default functions.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|default_def
index|[]
init|=
literal|"{}"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    TYPE_QUALS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers.     We return an INDIRECT_REF whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|type_quals
parameter_list|,
name|target
parameter_list|)
name|tree
name|type_quals
decl_stmt|,
name|target
decl_stmt|;
block|{
if|if
condition|(
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `*'"
argument_list|)
expr_stmt|;
name|target
operator|=
name|build_parse_node
argument_list|(
name|INDIRECT_REF
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|type_quals
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Return something to represent absolute declarators containing a&.    TARGET is the absolute declarator that the& contains.    TYPE_QUALS is a list of modifiers such as const or volatile    to apply to the reference type, represented as identifiers.     We return an ADDR_EXPR whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_reference_declarator
parameter_list|(
name|type_quals
parameter_list|,
name|target
parameter_list|)
name|tree
name|type_quals
decl_stmt|,
name|target
decl_stmt|;
block|{
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare references to references"
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare pointers to references"
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `&'"
argument_list|)
expr_stmt|;
block|}
name|target
operator|=
name|build_parse_node
argument_list|(
name|ADDR_EXPR
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
operator|=
name|type_quals
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build names and nodes for overloaded operators.  */
end_comment

begin_decl_stmt
name|tree
name|ansi_opname
index|[
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ansi_assopname
index|[
name|LAST_CPLUS_TREE_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|operator_name_string
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|opname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
operator|+
literal|2
decl_stmt|;
name|tree
modifier|*
name|opname_table
decl_stmt|;
name|int
name|i
decl_stmt|,
name|assign
decl_stmt|;
comment|/* Works for builtin and user defined types.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'a'
operator|&&
name|opname
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|opname
operator|+=
literal|1
expr_stmt|;
name|assign
operator|=
literal|1
expr_stmt|;
name|opname_table
operator|=
name|ansi_assopname
expr_stmt|;
block|}
else|else
block|{
name|assign
operator|=
literal|0
expr_stmt|;
name|opname_table
operator|=
name|ansi_opname
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
name|IDENTIFIER_POINTER
argument_list|(
name|opname_table
index|[
name|i
index|]
argument_list|)
index|[
literal|2
operator|+
name|assign
index|]
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
name|IDENTIFIER_POINTER
argument_list|(
name|opname_table
index|[
name|i
index|]
argument_list|)
index|[
literal|3
operator|+
name|assign
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|LAST_CPLUS_TREE_CODE
condition|)
return|return
literal|"<invalid operator>"
return|;
if|if
condition|(
name|assign
condition|)
return|return
name|assignop_tab
index|[
name|i
index|]
return|;
else|else
return|return
name|opname_tab
index|[
name|i
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|interface_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not current file is only for 				   interface definitions.  */
end_comment

begin_decl_stmt
name|int
name|interface_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not we know this class 				   to behave according to #pragma interface.  */
end_comment

begin_comment
comment|/* lexical analyzer */
end_comment

begin_comment
comment|/* File used for outputting assembler code.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE_SIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|INT_TYPE_SIZE
end_ifdef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes in a wide character.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR_BYTES
value|(WCHAR_TYPE_SIZE / BITS_PER_UNIT)
end_define

begin_decl_stmt
specifier|static
name|int
name|maxtoken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current nominal length of token buffer.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|token_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to token buffer. 				   Actual allocated length is maxtoken + 2.  */
end_comment

begin_include
include|#
directive|include
file|"cp-hash.h"
end_include

begin_escape
end_escape

begin_function_decl
name|int
name|check_newline
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero tells yylex to ignore \ in string constants.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_escape_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|skip_white_space
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|tree
name|get_time_identifier
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|time_identifier
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"file "
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|buf
operator|+
literal|5
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|+
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|time_identifier
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|time_identifier
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|time_identifier
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|time_identifier
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|time_identifier
argument_list|)
operator|=
name|filename_times
expr_stmt|;
name|filename_times
operator|=
name|time_identifier
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
name|time_identifier
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
endif|#
directive|endif
specifier|static
name|int
name|my_get_run_time
parameter_list|()
block|{
name|int
name|old_quiet_flag
init|=
name|quiet_flag
decl_stmt|;
name|int
name|this_time
decl_stmt|;
name|quiet_flag
operator|=
literal|0
expr_stmt|;
name|this_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|quiet_flag
operator|=
name|old_quiet_flag
expr_stmt|;
return|return
name|this_time
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table indexed by tree code giving a string containing a character    classifying the tree code.  Possibilities are    t, d, s, c, r,<, 1 and 2.  See cp-tree.def for details.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|TYPE,
end_define

begin_decl_stmt
name|char
modifier|*
name|cplus_tree_code_type
index|[]
init|=
block|{
literal|"x"
block|,
include|#
directive|include
file|"cp-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|LENGTH,
end_define

begin_decl_stmt
name|int
name|cplus_tree_code_length
index|[]
init|=
block|{
literal|0
block|,
include|#
directive|include
file|"cp-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Names of tree components.    Used for printing out the tree and error messages.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
name|char
modifier|*
name|cplus_tree_code_name
index|[]
init|=
block|{
literal|"@@dummy"
block|,
include|#
directive|include
file|"cp-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_escape
end_escape

begin_comment
comment|/* toplev.c needs to call these.  */
end_comment

begin_function
name|void
name|lang_init
parameter_list|()
block|{
comment|/* the beginning of the file is a new line; check for # */
comment|/* With luck, we discover the real source file's name from that      and put it in input_filename.  */
name|put_back
argument_list|(
name|check_newline
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_gnu_xref
condition|)
name|GNU_xref_begin
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_finish
parameter_list|()
block|{
specifier|extern
name|int
name|errorcount
decl_stmt|,
name|sorrycount
decl_stmt|;
if|if
condition|(
name|flag_gnu_xref
condition|)
name|GNU_xref_end
argument_list|(
name|errorcount
operator|+
name|sorrycount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_filename_times
parameter_list|()
block|{
name|this_filename_time
operator|=
name|get_time_identifier
argument_list|(
literal|"<top level>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|header_time
operator|=
literal|0
expr_stmt|;
name|body_time
operator|=
name|my_get_run_time
argument_list|()
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|=
name|body_time
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Change by Bryan Boreham, Kewill, Thu Jul 27 09:46:05 1989.    Stuck this hack in to get the files open correctly; this is called    in place of init_lex if we are an unexec'd binary.    */
end_comment

begin_function
name|void
name|reinit_lang_specific
parameter_list|()
block|{
name|init_filename_times
argument_list|()
expr_stmt|;
name|reinit_search_statistics
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_lex
parameter_list|()
block|{
specifier|extern
name|int
modifier|*
name|init_parse
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|decl_printable_name
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|lang_printable_name
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
comment|/* Initialize the lookahead machinery.  */
name|init_spew
argument_list|()
expr_stmt|;
comment|/* Make identifier nodes long enough for the language-specific slots.  */
name|set_identifier_size
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_identifier
argument_list|)
argument_list|)
expr_stmt|;
name|decl_printable_name
operator|=
name|lang_printable_name
expr_stmt|;
name|init_cplus_expand
argument_list|()
expr_stmt|;
name|tree_code_type
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_type
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
name|tree_code_length
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
name|tree_code_name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_name
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cplus_tree_code_type
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tree_code_type
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
argument_list|,
operator|(
name|LAST_CPLUS_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cplus_tree_code_length
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tree_code_length
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
argument_list|,
operator|(
name|LAST_CPLUS_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cplus_tree_code_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tree_code_name
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
argument_list|,
operator|(
name|LAST_CPLUS_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|opname_tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opname_tab
argument_list|,
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|assignop_tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|assignop_tab
argument_list|,
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ansi_opname
index|[
literal|0
index|]
operator|=
name|get_identifier
argument_list|(
literal|"<invalid operator>"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|LAST_CPLUS_TREE_CODE
condition|;
name|i
operator|++
control|)
block|{
name|ansi_opname
index|[
name|i
index|]
operator|=
name|ansi_opname
index|[
literal|0
index|]
expr_stmt|;
name|ansi_assopname
index|[
name|i
index|]
operator|=
name|ansi_opname
index|[
literal|0
index|]
expr_stmt|;
block|}
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ml"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aml"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__md"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__amd"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__mi"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ami"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__rs"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ars"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ne"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|GT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__gt"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|GT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|GE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ge"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|GE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__or"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aor"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_ANDIF_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aa"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_ANDIF_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__nt"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__pp"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__as"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|NOP_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPOUND_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__cm"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPOUND_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__dv"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__adv"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__pl"
argument_list|)
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__pl"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__apl"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ls"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__als"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EQ_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__eq"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|EQ_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__lt"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__le"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|LE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__ad"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aad"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__er"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__aer"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_assopname
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_ORIF_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__oo"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TRUTH_ORIF_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__co"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__mm"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|=
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__rf"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MEMBER_REF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__rm"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MEMBER_REF
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__cl"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__vc"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__nw"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__dl"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__op"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This is not true: these operators are not defined in ANSI,      but we need them anyway.  */
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__mn"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__mx"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__cn"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|METHOD_CALL_EXPR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__wr"
argument_list|)
expr_stmt|;
name|IDENTIFIER_OPNAME_P
argument_list|(
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|METHOD_CALL_EXPR
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init_method
argument_list|()
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|inline_text_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start it at 0, because check_newline is called at the very beginning      and will increment it to 1.  */
name|lineno
operator|=
literal|0
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|maxtoken
operator|=
literal|40
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
operator|=
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"float"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"double"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"short"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
operator|=
name|get_identifier
argument_list|(
literal|"long"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"unsigned"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"signed"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|=
name|get_identifier
argument_list|(
literal|"const"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"volatile"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|=
name|get_identifier
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|=
name|get_identifier
argument_list|(
literal|"static"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
operator|=
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"typedef"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
operator|=
name|get_identifier
argument_list|(
literal|"register"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C++ extensions. These are probably not correctly named. */
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"__wchar_t"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|class_type_node
operator|=
name|build_int_2
argument_list|(
name|class_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|class_type_node
argument_list|)
operator|=
name|class_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CLASS
index|]
operator|=
name|class_type_node
expr_stmt|;
name|record_type_node
operator|=
name|build_int_2
argument_list|(
name|record_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|record_type_node
argument_list|)
operator|=
name|record_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RECORD
index|]
operator|=
name|record_type_node
expr_stmt|;
name|union_type_node
operator|=
name|build_int_2
argument_list|(
name|union_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|union_type_node
argument_list|)
operator|=
name|union_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNION
index|]
operator|=
name|union_type_node
expr_stmt|;
name|enum_type_node
operator|=
name|build_int_2
argument_list|(
name|enum_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|enum_type_node
argument_list|)
operator|=
name|enum_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ENUM
index|]
operator|=
name|enum_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
operator|=
name|get_identifier
argument_list|(
literal|"virtual"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
operator|=
name|get_identifier
argument_list|(
literal|"friend"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PUBLIC
index|]
operator|=
name|get_identifier
argument_list|(
literal|"public"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PUBLIC
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PUBLIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PRIVATE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"private"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PRIVATE
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PRIVATE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PROTECTED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"protected"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PROTECTED
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_PROTECTED
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Exception handling extensions.  */
name|exception_type_node
operator|=
name|build_int_2
argument_list|(
name|exception_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exception_type_node
argument_list|)
operator|=
name|exception_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXCEPTION
index|]
operator|=
name|exception_type_node
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|=
literal|"->"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MEMBER_REF
index|]
operator|=
literal|"->*"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|METHOD_CALL_EXPR
index|]
operator|=
literal|"->()"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
literal|"(unary *)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
operator|=
literal|"[]"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|=
literal|"="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|=
literal|"new"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|=
literal|"delete"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
operator|=
literal|"... ? ... : ..."
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
operator|=
literal|"()"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
literal|"+"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
literal|"-"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
literal|"*"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
literal|"/"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
literal|"(floor /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
literal|"(round /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
literal|"%"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|=
literal|"(ceiling %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|=
literal|"(floor %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|=
literal|"(round %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
literal|"-"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
operator|=
literal|"<?"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
operator|=
literal|">?"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ABS_EXPR
index|]
operator|=
literal|"abs"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FFS_EXPR
index|]
operator|=
literal|"ffs"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
literal|"<<"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
literal|">>"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
literal|"|"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
literal|"^"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
literal|"&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_ANDTC_EXPR
index|]
operator|=
literal|"&~"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
operator|=
literal|"~"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_ANDIF_EXPR
index|]
operator|=
literal|"&&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_ORIF_EXPR
index|]
operator|=
literal|"||"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_AND_EXPR
index|]
operator|=
literal|"strict&&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_OR_EXPR
index|]
operator|=
literal|"strict ||"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
operator|=
literal|"!"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LT_EXPR
index|]
operator|=
literal|"<"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LE_EXPR
index|]
operator|=
literal|"<="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|GT_EXPR
index|]
operator|=
literal|">"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|GE_EXPR
index|]
operator|=
literal|">="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|EQ_EXPR
index|]
operator|=
literal|"=="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NE_EXPR
index|]
operator|=
literal|"!="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|IN_EXPR
index|]
operator|=
literal|"in"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|SET_LE_EXPR
index|]
operator|=
literal|"subset"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CARD_EXPR
index|]
operator|=
literal|"#"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|RANGE_EXPR
index|]
operator|=
literal|".."
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
literal|"(unary +)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
literal|"(unary&)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
operator|=
literal|"--"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
operator|=
literal|"++"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|=
literal|"--"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|=
literal|"++"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COMPOUND_EXPR
index|]
operator|=
literal|","
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|NOP_EXPR
index|]
operator|=
literal|"="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
literal|"+="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
literal|"+="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
literal|"-="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
literal|"-="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
literal|"*="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
literal|"*="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
literal|"/="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|EXACT_DIV_EXPR
index|]
operator|=
literal|"(exact /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
literal|"(ceiling /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
literal|"(floor /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
literal|"(round /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
literal|"%="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|=
literal|"(ceiling %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|=
literal|"(floor %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|=
literal|"(round %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
operator|=
literal|"<?="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
operator|=
literal|">?="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
literal|"<<="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
literal|">>="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
literal|"|="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
literal|"^="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
literal|"&="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
literal|"&="
expr_stmt|;
name|init_filename_times
argument_list|()
expr_stmt|;
define|#
directive|define
name|UNSET_RESERVED_WORD
parameter_list|(
name|STRING
parameter_list|)
define|\
value|do { is_reserved_word (STRING, sizeof (STRING) - 1)->name = ""; } while (0)
if|if
condition|(
name|flag_ansi_exceptions
condition|)
name|flag_handle_exceptions
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|flag_ansi_exceptions
condition|)
block|{
name|UNSET_RESERVED_WORD
argument_list|(
literal|"catch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_handle_exceptions
condition|)
block|{
comment|/* Easiest way to not recognize exception 	 handling extensions...  */
name|UNSET_RESERVED_WORD
argument_list|(
literal|"all"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"except"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"exception"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"raise"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"raises"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"reraise"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"try"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"throw"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_ansi_exceptions
condition|)
block|{
comment|/* Easiest way to not recognize exception 	 handling extensions...  */
name|UNSET_RESERVED_WORD
argument_list|(
literal|"exception"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"all"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"except"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"raise"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"raises"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"reraise"
argument_list|)
expr_stmt|;
name|is_reserved_word
argument_list|(
literal|"try"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"try"
argument_list|)
operator|-
literal|1
argument_list|)
operator|->
name|token
operator|=
name|ANSI_TRY
expr_stmt|;
name|is_reserved_word
argument_list|(
literal|"throw"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"throw"
argument_list|)
operator|-
literal|1
argument_list|)
operator|->
name|token
operator|=
name|ANSI_THROW
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flag_gc
operator|||
name|flag_dossier
operator|)
condition|)
block|{
name|UNSET_RESERVED_WORD
argument_list|(
literal|"classof"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"headof"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_no_asm
condition|)
name|UNSET_RESERVED_WORD
argument_list|(
literal|"asm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_no_asm
operator|||
name|flag_traditional
condition|)
name|UNSET_RESERVED_WORD
argument_list|(
literal|"typeof"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SOS
name|UNSET_RESERVED_WORD
argument_list|(
literal|"dynamic"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|token_count
operator|=
name|init_parse
argument_list|()
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_parse_for_function
parameter_list|()
block|{
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
ifdef|#
directive|ifdef
name|__GNUC__
name|__inline
endif|#
directive|endif
name|void
name|yyprint
parameter_list|(
name|file
parameter_list|,
name|yychar
parameter_list|,
name|yylval
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|yychar
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|yychar
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|TYPENAME
case|:
case|case
name|TYPESPEC
case|:
case|case
name|PTYPENAME
case|:
case|case
name|IDENTIFIER_DEFN
case|:
case|case
name|TYPENAME_DEFN
case|:
case|case
name|PTYPENAME_DEFN
case|:
case|case
name|TYPENAME_COLON
case|:
case|case
name|TYPENAME_ELLIPSIS
case|:
case|case
name|SCOPED_TYPENAME
case|:
case|case
name|SCSPEC
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
name|print_id
label|:
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|224
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AGGR
case|:
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|class_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `class'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|record_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `struct'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|union_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `union'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yylval
operator|.
name|ttype
operator|==
name|enum_type_node
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `enum'"
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|80
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_PARSED_CLASS_DECL
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
argument_list|,
literal|225
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|print_id
goto|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reduce_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|token_count
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REDUCE_LENGTH
value|(sizeof (yyr2) / sizeof (yyr2[0]))
end_define

begin_define
define|#
directive|define
name|TOKEN_LENGTH
value|(256 + sizeof (yytname) / sizeof (yytname[0]))
end_define

begin_function
name|int
modifier|*
name|init_parse
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|reduce_count
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|REDUCE_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reduce_count
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|REDUCE_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|reduce_count
operator|+=
literal|1
expr_stmt|;
name|token_count
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|TOKEN_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|token_count
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
name|TOKEN_LENGTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|token_count
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|token_count
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_function
name|void
name|yyhook
parameter_list|(
name|yyn
parameter_list|)
name|int
name|yyn
decl_stmt|;
block|{
name|reduce_count
index|[
name|yyn
index|]
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|reduce_cmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
return|return
name|reduce_count
index|[
operator|*
name|q
index|]
operator|-
name|reduce_count
index|[
operator|*
name|p
index|]
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|token_cmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|int
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
return|return
name|token_count
index|[
operator|*
name|q
index|]
operator|-
name|token_count
index|[
operator|*
name|p
index|]
return|;
block|}
end_block

begin_function
name|void
name|print_parse_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
name|int
name|i
decl_stmt|;
name|int
name|maxlen
init|=
name|REDUCE_LENGTH
decl_stmt|;
name|unsigned
modifier|*
name|sorted
decl_stmt|;
if|if
condition|(
name|reduce_count
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TOKEN_LENGTH
operator|>
name|REDUCE_LENGTH
condition|)
name|maxlen
operator|=
name|TOKEN_LENGTH
expr_stmt|;
name|sorted
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|maxlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKEN_LENGTH
condition|;
name|i
operator|++
control|)
name|sorted
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|TOKEN_LENGTH
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|token_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOKEN_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
name|sorted
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|token_count
index|[
name|index
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|token_count
index|[
name|index
index|]
operator|<
name|token_count
index|[
operator|-
literal|1
index|]
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"token %d, `%s', count = %d\n"
argument_list|,
name|index
argument_list|,
name|yytname
index|[
name|YYTRANSLATE
argument_list|(
name|index
argument_list|)
index|]
argument_list|,
name|token_count
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REDUCE_LENGTH
condition|;
name|i
operator|++
control|)
name|sorted
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|REDUCE_LENGTH
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|reduce_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REDUCE_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
name|sorted
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reduce_count
index|[
name|index
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|reduce_count
index|[
name|index
index|]
operator|<
name|reduce_count
index|[
operator|-
literal|1
index|]
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rule %d, line %d, count = %d\n"
argument_list|,
name|index
argument_list|,
name|yyrline
index|[
name|index
index|]
argument_list|,
name|reduce_count
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Sets the value of the 'yydebug' variable to VALUE.    This is a function so we don't have to have YYDEBUG defined    in order to build the compiler.  */
end_comment

begin_function
name|void
name|set_yydebug
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
name|yydebug
operator|=
name|value
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"YYDEBUG not defined."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPEW_DEBUG
end_ifdef

begin_function
specifier|const
name|char
modifier|*
name|debug_yytranslate
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
return|return
name|yytname
index|[
name|YYTRANSLATE
argument_list|(
name|value
argument_list|)
index|]
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Functions and data structures for #pragma interface.     `#pragma implementation' means that the main file being compiled    is considered to implement (provide) the classes that appear in    its main body.  I.e., if this is file "foo.cc", and class `bar'    is defined in "foo.cc", then we say that "foo.cc implements bar".     All main input files "implement" themselves automagically.     `#pragma interface' means that unless this file (of the form "foo.h"    is not presently being included by file "foo.cc", the    CLASSTYPE_INTERFACE_ONLY bit gets set.  The effect is that none    of the vtables nor any of the inline functions defined in foo.h    will ever be output.     There are cases when we want to link files such as "defs.h" and    "main.cc".  In this case, we give "defs.h" a `#pragma interface',    and "main.cc" has `#pragma implementation "defs.h"'.  */
end_comment

begin_struct
struct|struct
name|impl_files
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|impl_files
modifier|*
name|impl_file_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function to load global variables with interface    information.  */
end_comment

begin_function
name|void
name|extract_interface_info
parameter_list|()
block|{
name|tree
name|fileinfo
init|=
name|get_time_identifier
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|fileinfo
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
name|interface_only
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if S and T are not considered part of an    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|interface_strcmp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Set the interface/implementation bits for this scope.  */
name|struct
name|impl_files
modifier|*
name|ifiles
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|;
name|s
operator|=
name|FILE_NAME_NONDIRECTORY
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|ifiles
operator|=
name|impl_file_chain
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|t1
init|=
name|ifiles
operator|->
name|filename
decl_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|t1
operator|||
operator|*
name|s1
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
operator|&&
operator|*
name|s1
operator|!=
literal|0
condition|)
name|s1
operator|++
operator|,
name|t1
operator|++
expr_stmt|;
comment|/* A match.  */
if|if
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
condition|)
return|return
literal|0
return|;
comment|/* Don't get faked out by xxx.yyy.cc vs xxx.zzz.cc.  */
if|if
condition|(
name|index
argument_list|(
name|s1
argument_list|,
literal|'.'
argument_list|)
operator|||
name|index
argument_list|(
name|t1
argument_list|,
literal|'.'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
operator|||
name|s1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|t1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
comment|/* A match.  */
return|return
literal|0
return|;
block|}
comment|/* No matches.  */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|set_typedecl_interface_info
parameter_list|(
name|prev
parameter_list|,
name|vars
parameter_list|)
name|tree
name|prev
decl_stmt|,
name|vars
decl_stmt|;
block|{
name|tree
name|id
init|=
name|get_time_identifier
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|vars
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fileinfo
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|vars
argument_list|)
decl_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_strcmp
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|vars
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_vardecl_interface_info
parameter_list|(
name|prev
parameter_list|,
name|vars
parameter_list|)
name|tree
name|prev
decl_stmt|,
name|vars
decl_stmt|;
block|{
name|tree
name|type
init|=
name|DECL_CONTEXT
argument_list|(
name|vars
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
condition|)
name|set_typedecl_interface_info
argument_list|(
name|prev
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|vars
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|vars
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from the top level: if there are any pending inlines to    do, set up to process them now.  */
end_comment

begin_function
name|void
name|do_pending_inlines
parameter_list|()
block|{
name|struct
name|pending_inline
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
comment|/* Reverse the pending inline functions, since      they were cons'd instead of appended.  */
for|for
control|(
name|t
operator|=
name|pending_inlines
init|;
name|t
condition|;
name|t
operator|=
name|tail
control|)
block|{
name|t
operator|->
name|deja_vu
operator|=
literal|1
expr_stmt|;
name|tail
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|t
expr_stmt|;
block|}
comment|/* Reset to zero so that if the inline functions we are currently      processing define inline functions of their own, that is handled      correctly.  ??? This hasn't been checked in a while.  */
name|pending_inlines
operator|=
literal|0
expr_stmt|;
comment|/* Now start processing the first inline function.  */
name|t
operator|=
name|prev
expr_stmt|;
name|my_friendly_assert
argument_list|(
operator|(
name|t
operator|->
name|parm_vec
operator|==
name|NULL_TREE
operator|)
operator|==
operator|(
name|t
operator|->
name|bindings
operator|==
name|NULL_TREE
operator|)
argument_list|,
literal|226
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|parm_vec
condition|)
name|push_template_decls
argument_list|(
name|t
operator|->
name|parm_vec
argument_list|,
name|t
operator|->
name|bindings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|feed_input
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|len
argument_list|,
name|t
operator|->
name|can_free
condition|?
operator|&
name|inline_text_obstack
else|:
literal|0
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|t
operator|->
name|lineno
expr_stmt|;
if|#
directive|if
literal|0
block|if (input_filename != t->filename) 	{ 	  input_filename = t->filename;
comment|/* Get interface/implementation back in sync.  */
block|extract_interface_info (); 	}
else|#
directive|else
name|input_filename
operator|=
name|t
operator|->
name|filename
expr_stmt|;
name|interface_unknown
operator|=
name|t
operator|->
name|interface
operator|==
literal|1
expr_stmt|;
name|interface_only
operator|=
name|t
operator|->
name|interface
operator|==
literal|0
expr_stmt|;
endif|#
directive|endif
name|yychar
operator|=
name|PRE_PARSED_FUNCTION_DECL
expr_stmt|;
block|}
comment|/* Pass back a handle on the rest of the inline functions, so that they      can be processed later.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_tree_list
argument_list|(
operator|(
name|tree
operator|)
name|t
argument_list|,
name|t
operator|->
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_default_inline
operator|&&
name|t
operator|->
name|fndecl
comment|/* If we're working from a template, don't change 	 the `inline' state.  */
operator|&&
name|t
operator|->
name|parm_vec
operator|==
name|NULL_TREE
condition|)
name|DECL_INLINE
argument_list|(
name|t
operator|->
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|t
operator|->
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|pending_input
modifier|*
name|to_be_restored
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nextchar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|process_next_inline
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|struct
name|pending_inline
modifier|*
name|i
init|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|my_friendly_assert
argument_list|(
operator|(
name|i
operator|->
name|parm_vec
operator|==
name|NULL_TREE
operator|)
operator|==
operator|(
name|i
operator|->
name|bindings
operator|==
name|NULL_TREE
operator|)
argument_list|,
literal|227
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|parm_vec
condition|)
name|pop_template_decls
argument_list|(
name|i
operator|->
name|parm_vec
argument_list|,
name|i
operator|->
name|bindings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|i
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|!=
name|END_OF_SAVED_INPUT
condition|)
block|{
name|error
argument_list|(
literal|"parse error at end of saved function text"
argument_list|)
expr_stmt|;
comment|/* restore_pending_input will abort unless yychar is either        * END_OF_SAVED_INPUT or YYEMPTY; since we already know we're        * hosed, feed back YYEMPTY.        *  We also need to discard nextchar, since that may have gotten        * set as well.        */
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
if|if
condition|(
name|to_be_restored
operator|==
literal|0
condition|)
name|my_friendly_abort
argument_list|(
literal|123
argument_list|)
expr_stmt|;
name|restore_pending_input
argument_list|(
name|to_be_restored
argument_list|)
expr_stmt|;
name|to_be_restored
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|i
operator|->
name|fndecl
operator|!=
name|NULL_TREE
condition|)
block|{
name|my_friendly_assert
argument_list|(
operator|(
name|i
operator|->
name|parm_vec
operator|==
name|NULL_TREE
operator|)
operator|==
operator|(
name|i
operator|->
name|bindings
operator|==
name|NULL_TREE
operator|)
argument_list|,
literal|228
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|parm_vec
condition|)
name|push_template_decls
argument_list|(
name|i
operator|->
name|parm_vec
argument_list|,
name|i
operator|->
name|bindings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|feed_input
argument_list|(
name|i
operator|->
name|buf
argument_list|,
name|i
operator|->
name|len
argument_list|,
name|i
operator|->
name|can_free
condition|?
operator|&
name|inline_text_obstack
else|:
literal|0
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|i
operator|->
name|lineno
expr_stmt|;
name|input_filename
operator|=
name|i
operator|->
name|filename
expr_stmt|;
name|yychar
operator|=
name|PRE_PARSED_FUNCTION_DECL
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build_tree_list
argument_list|(
operator|(
name|tree
operator|)
name|i
argument_list|,
name|i
operator|->
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_default_inline
comment|/* If we're working from a template, don't change 	     the `inline' state.  */
operator|&&
name|i
operator|->
name|parm_vec
operator|==
name|NULL_TREE
condition|)
name|DECL_INLINE
argument_list|(
name|i
operator|->
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|i
operator|->
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|interface_unknown
operator|=
name|i
operator|->
name|interface
operator|==
literal|1
expr_stmt|;
name|interface_only
operator|=
name|i
operator|->
name|interface
operator|==
literal|0
expr_stmt|;
block|}
else|else
name|extract_interface_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Since inline methods can refer to text which has not yet been seen,    we store the text of the method in a structure which is placed in the    DECL_PENDING_INLINE_INFO field of the FUNCTION_DECL.    After parsing the body of the class definition, the FUNCTION_DECL's are    scanned to see which ones have this field set.  Those are then digested    one at a time.     This function's FUNCTION_DECL will have a bit set in its common so    that we know to watch out for it.  */
end_comment

begin_function
name|void
name|consume_string
parameter_list|(
name|this_obstack
parameter_list|)
specifier|register
name|struct
name|obstack
modifier|*
name|this_obstack
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids newline in string constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\"'
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|nextyychar
init|=
name|YYEMPTY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|YYSTYPE
name|nextyylval
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pending_input
block|{
name|int
name|nextchar
decl_stmt|,
name|yychar
decl_stmt|,
name|nextyychar
decl_stmt|,
name|eof
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|,
name|nextyylval
decl_stmt|;
name|struct
name|obstack
name|token_obstack
decl_stmt|;
name|int
name|first_token
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|pending_input
modifier|*
name|save_pending_input
parameter_list|()
block|{
name|struct
name|pending_input
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|pending_input
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_input
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|nextchar
operator|=
name|nextchar
expr_stmt|;
name|p
operator|->
name|yychar
operator|=
name|yychar
expr_stmt|;
name|p
operator|->
name|nextyychar
operator|=
name|nextyychar
expr_stmt|;
name|p
operator|->
name|yylval
operator|=
name|yylval
expr_stmt|;
name|p
operator|->
name|nextyylval
operator|=
name|nextyylval
expr_stmt|;
name|p
operator|->
name|eof
operator|=
name|end_of_file
expr_stmt|;
name|yychar
operator|=
name|nextyychar
operator|=
name|YYEMPTY
expr_stmt|;
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|first_token
operator|=
name|first_token
expr_stmt|;
name|p
operator|->
name|token_obstack
operator|=
name|token_obstack
expr_stmt|;
name|first_token
operator|=
literal|0
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|token_obstack
argument_list|)
expr_stmt|;
name|end_of_file
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|restore_pending_input
parameter_list|(
name|p
parameter_list|)
name|struct
name|pending_input
modifier|*
name|p
decl_stmt|;
block|{
name|my_friendly_assert
argument_list|(
name|nextchar
operator|==
operator|-
literal|1
argument_list|,
literal|229
argument_list|)
expr_stmt|;
name|nextchar
operator|=
name|p
operator|->
name|nextchar
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|yychar
operator|==
name|YYEMPTY
operator|||
name|yychar
operator|==
name|END_OF_SAVED_INPUT
argument_list|,
literal|230
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|p
operator|->
name|yychar
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|nextyychar
operator|==
name|YYEMPTY
argument_list|,
literal|231
argument_list|)
expr_stmt|;
name|nextyychar
operator|=
name|p
operator|->
name|nextyychar
expr_stmt|;
name|yylval
operator|=
name|p
operator|->
name|yylval
expr_stmt|;
name|nextyylval
operator|=
name|p
operator|->
name|nextyylval
expr_stmt|;
name|first_token
operator|=
name|p
operator|->
name|first_token
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|token_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|token_obstack
operator|=
name|p
operator|->
name|token_obstack
expr_stmt|;
name|end_of_file
operator|=
name|p
operator|->
name|eof
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return next non-whitespace input character, which may come    from `finput', or from `nextchar'.  */
end_comment

begin_function
specifier|static
name|int
name|yynextch
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|nextchar
expr_stmt|;
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
return|return
name|skip_white_space
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Unget character CH from the input stream.    If RESCAN is non-zero, then we want to `see' this    character as the next input token.  */
end_comment

begin_function
name|void
name|yyungetc
parameter_list|(
name|ch
parameter_list|,
name|rescan
parameter_list|)
name|int
name|ch
decl_stmt|;
name|int
name|rescan
decl_stmt|;
block|{
comment|/* Unget a character from the input stream.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
operator|||
name|rescan
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|put_back
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|nextchar
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|my_friendly_assert
argument_list|(
name|nextyychar
operator|==
name|YYEMPTY
argument_list|,
literal|232
argument_list|)
expr_stmt|;
name|nextyychar
operator|=
name|yychar
expr_stmt|;
name|nextyylval
operator|=
name|yylval
expr_stmt|;
name|yychar
operator|=
name|ch
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function stores away the text for an inline function that should    be processed later.  It decides how much later, and may need to move    the info between obstacks; therefore, the caller should not refer to    the T parameter after calling this function.     This function also stores the list of template-parameter bindings that    will be needed for expanding the template, if any.  */
end_comment

begin_function
specifier|static
name|void
name|store_pending_inline
parameter_list|(
name|decl
parameter_list|,
name|t
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
block|{
specifier|extern
name|int
name|processing_template_defn
decl_stmt|;
name|int
name|delay_to_eof
init|=
literal|0
decl_stmt|;
name|struct
name|pending_inline
modifier|*
modifier|*
name|inlines
decl_stmt|;
name|t
operator|->
name|fndecl
operator|=
name|decl
expr_stmt|;
comment|/* Default: compile right away, and no extra bindings are needed.  */
name|t
operator|->
name|parm_vec
operator|=
name|t
operator|->
name|bindings
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|processing_template_defn
condition|)
block|{
name|tree
name|type
init|=
name|current_class_type
decl_stmt|;
comment|/* Assumption: In this (possibly) nested class sequence, only 	 one name will have template parms.  */
while|while
condition|(
name|type
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|tmpl
init|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpl
condition|)
block|{
name|t
operator|->
name|parm_vec
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|->
name|parm_vec
expr_stmt|;
name|t
operator|->
name|bindings
operator|=
name|TREE_VALUE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|my_friendly_assert
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|current_class_type
argument_list|,
literal|233
argument_list|)
expr_stmt|;
comment|/* Inline functions can be compiled immediately.  Other functions 	     will be output separately, so if we're in interface-only mode, 	     punt them now, or output them now if we're doing implementations 	     and we know no overrides will exist.  Otherwise, we delay until 	     end-of-file, to see if the definition is really required.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* delay_to_eof == 0 */
empty_stmt|;
elseif|else
if|if
condition|(
name|current_class_type
operator|&&
operator|!
name|interface_unknown
condition|)
block|{
if|if
condition|(
name|interface_only
condition|)
block|{
if|#
directive|if
literal|0
block|print_node_brief (stderr, "\ndiscarding text for ", decl, 0);
endif|#
directive|endif
if|if
condition|(
name|t
operator|->
name|can_free
condition|)
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|t
operator|->
name|buf
argument_list|)
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Don't delay the processing of virtual functions.  */
elseif|else
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|delay_to_eof
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|58
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delay_to_eof
condition|)
block|{
specifier|extern
name|struct
name|pending_inline
modifier|*
name|pending_template_expansions
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|can_free
condition|)
block|{
name|char
modifier|*
name|free_to
init|=
name|t
operator|->
name|buf
decl_stmt|;
name|t
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|obstack_copy
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|free_to
argument_list|)
expr_stmt|;
block|}
name|inlines
operator|=
operator|&
name|pending_template_expansions
expr_stmt|;
name|t
operator|->
name|can_free
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|inlines
operator|=
operator|&
name|pending_inlines
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* Because we use obstacks, we must process these in precise order.  */
name|t
operator|->
name|next
operator|=
operator|*
name|inlines
expr_stmt|;
operator|*
name|inlines
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|reinit_parse_for_block
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|reinit_parse_for_method
parameter_list|(
name|yychar
parameter_list|,
name|decl
parameter_list|)
name|int
name|yychar
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|starting_filename
init|=
name|input_filename
decl_stmt|;
name|reinit_parse_for_block
argument_list|(
name|yychar
argument_list|,
operator|&
name|inline_text_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|void_type_node
operator|||
operator|(
name|current_class_type
operator|&&
name|TYPE_REDEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|)
condition|)
block|{
comment|/* Happens when we get two declarations of the same 	 function in the same scope.  */
name|char
modifier|*
name|buf
init|=
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
decl_stmt|;
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|t
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|t
operator|->
name|lineno
operator|=
name|starting_lineno
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|starting_filename
expr_stmt|;
name|t
operator|->
name|token
operator|=
name|YYEMPTY
expr_stmt|;
name|t
operator|->
name|can_free
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|deja_vu
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|interface
operator|=
operator|(
operator|(
name|interface_unknown
operator|||
name|processing_template_defn
operator|)
condition|?
literal|1
else|:
operator|(
name|interface_only
condition|?
literal|0
else|:
literal|2
operator|)
operator|)
expr_stmt|;
name|store_pending_inline
argument_list|(
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Consume a block -- actually, a method or template definition beginning    with `:' or `{' -- and save it away on the specified obstack.     Argument IS_TEMPLATE indicates which set of error messages should be    output if something goes wrong.  This should really be cleaned up somehow,    without loss of clarity.  */
end_comment

begin_function
name|void
name|reinit_parse_for_block
parameter_list|(
name|yychar
parameter_list|,
name|obstackp
parameter_list|,
name|is_template
parameter_list|)
name|int
name|yychar
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
name|int
name|is_template
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
literal|0
decl_stmt|;
name|int
name|blev
init|=
literal|1
decl_stmt|;
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|starting_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|look_for_semicolon
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|yychar
operator|==
literal|'{'
condition|)
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yychar
operator|==
literal|'='
condition|)
block|{
name|look_for_semicolon
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|yychar
operator|!=
literal|':'
operator|&&
operator|(
name|yychar
operator|!=
name|RETURN
operator|||
name|is_template
operator|)
condition|)
block|{
name|yyerror
argument_list|(
name|is_template
condition|?
literal|"parse error in template specification"
else|:
literal|"parse error in method specification"
argument_list|)
expr_stmt|;
name|yychar
operator|=
literal|'{'
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
name|int
name|this_lineno
init|=
name|lineno
decl_stmt|;
name|c
operator|=
name|yynextch
argument_list|()
expr_stmt|;
comment|/* Don't lose our cool if there are lots of comments.  */
if|if
condition|(
name|lineno
operator|==
name|this_lineno
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|lineno
operator|-
name|this_lineno
operator|<
literal|10
comment|/* + strlen (input_filename) */
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|lineno
operator|-
name|this_lineno
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n# %d \""
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
name|input_filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* strings must be read differently than text.  */
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
block|{
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|consume_string
argument_list|(
name|obstackp
argument_list|)
expr_stmt|;
name|c
operator|=
name|yynextch
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|>
literal|' '
condition|)
comment|/* ASCII dependent! */
block|{
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
goto|goto
name|main_loop
goto|;
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
name|consume_string
argument_list|(
name|obstackp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
name|error
argument_list|(
name|is_template
condition|?
literal|"template body missing"
else|:
literal|"function body for constructor missing"
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|,
literal|"end of file read inside definition"
argument_list|)
expr_stmt|;
block|}
block|}
name|main_loop
label|:
while|while
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
name|int
name|this_lineno
init|=
name|lineno
decl_stmt|;
name|c
operator|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Don't lose our cool if there are lots of comments.  */
if|if
condition|(
name|lineno
operator|-
name|this_lineno
condition|)
if|if
condition|(
name|lineno
operator|-
name|this_lineno
operator|==
literal|1
condition|)
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n# %d \""
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|obstackp
argument_list|,
name|input_filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|>
literal|' '
condition|)
block|{
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|blev
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|blev
operator|--
expr_stmt|;
if|if
condition|(
name|blev
operator|==
literal|0
operator|&&
operator|!
name|look_for_semicolon
condition|)
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
name|consume_string
argument_list|(
name|obstackp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
operator|&&
name|look_for_semicolon
operator|&&
name|blev
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|obstack_1grow
argument_list|(
name|obstackp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a default function named NAME for type TYPE.    KIND says what to build.     When KIND == 0, build default destructor.    When KIND == 1, build virtual destructor.    When KIND == 2, build default constructor.    When KIND == 3, build default X(const X&) constructor.    When KIND == 4, build default X(X&) constructor.  */
end_comment

begin_function
name|tree
name|cons_up_default_function
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
name|int
name|kind
decl_stmt|;
block|{
specifier|extern
name|tree
name|void_list_node
decl_stmt|,
name|constructor_name
argument_list|()
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|declspecs
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|args
decl_stmt|;
name|tree
name|argtype
decl_stmt|;
name|name
operator|=
name|constructor_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
comment|/* Destructors.  */
case|case
literal|1
case|:
name|declspecs
operator|=
name|build_decl_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
argument_list|)
expr_stmt|;
comment|/* Fall through...  */
case|case
literal|0
case|:
name|name
operator|=
name|build_parse_node
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Fall through...  */
case|case
literal|2
case|:
comment|/* Default constructor.  */
name|args
operator|=
name|void_list_node
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through...  */
case|case
literal|4
case|:
name|argtype
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|hash_tree_chain
argument_list|(
name|argtype
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
literal|"arg"
argument_list|)
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|59
argument_list|)
expr_stmt|;
block|}
name|fn
operator|=
name|start_method
argument_list|(
name|declspecs
argument_list|,
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|void_type_node
condition|)
return|return
name|fn
return|;
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|{
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|buf
operator|=
name|default_def
expr_stmt|;
name|t
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|t
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|t
operator|->
name|token
operator|=
name|YYEMPTY
expr_stmt|;
name|t
operator|->
name|can_free
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|deja_vu
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|interface
operator|=
operator|(
operator|(
name|interface_unknown
operator|||
name|processing_template_defn
operator|)
condition|?
literal|1
else|:
operator|(
name|interface_only
condition|?
literal|0
else|:
literal|2
operator|)
operator|)
expr_stmt|;
name|store_pending_inline
argument_list|(
name|fn
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* We make this declaration private (static in the C sense).  */
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|finish_method
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|fn
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Show that this function was generated by the compiler.  */
name|DECL_SOURCE_LINE
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Heuristic to tell whether the user is missing a semicolon    after a struct or enum declaration.  Emit an error message    if we know the user has blown it.  */
end_comment

begin_function
name|void
name|check_for_missing_semicolon
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|>
literal|255
operator|&&
name|yychar
operator|!=
name|IDENTIFIER
operator|&&
name|yychar
operator|!=
name|TYPENAME
condition|)
block|{
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"semicolon missing after %s declaration"
argument_list|,
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|?
literal|"enum"
else|:
literal|"struct"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"semicolon missing after declaration of `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Could probably also hack cases where class { ... } f (); appears.  */
name|clear_anon_tags
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|note_got_semicolon
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|my_friendly_abort
argument_list|(
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|note_list_got_semicolon
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|note_got_semicolon
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|clear_anon_tags
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If C is not whitespace, return C.    Otherwise skip whitespace and return first nonwhite char read.  */
end_comment

begin_function
specifier|static
name|int
name|skip_white_space
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|c
operator|=
name|check_newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|"stray '\\' in program"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make the token buffer longer, preserving the data in it.    P should point to just beyond the last valid character in the old buffer.    The value we return is a pointer to the new buffer    at a place corresponding to P.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extend_token_buffer
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|offset
init|=
name|p
operator|-
name|token_buffer
decl_stmt|;
name|maxtoken
operator|=
name|maxtoken
operator|*
literal|2
operator|+
literal|10
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|token_buffer
argument_list|,
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|token_buffer
operator|+
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|get_last_nonwhite_on_line
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* At the beginning of a line, increment the line number    and process any #-directive on this line.    If the line is a #-directive, read the entire line and return a newline.    Otherwise, return the line's first non-whitespace character.  */
end_comment

begin_function
name|int
name|check_newline
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|token
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
comment|/* Read first nonwhite char on the line.  */
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
if|if
condition|(
name|c
operator|!=
literal|'#'
condition|)
block|{
comment|/* If not #, return it so caller will use it.  */
return|return
name|c
return|;
block|}
comment|/* Read first nonwhite char after the `#'.  */
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
comment|/* If a letter follows, then if the word here is `line', skip      it and ignore it; otherwise, ignore the line, with an error      if the word isn't `pragma'.  */
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'r'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'g'
operator|&&
name|getch
argument_list|()
operator|==
literal|'m'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
condition|)
block|{
comment|/* Read first nonwhite char after the `#pragma'.  */
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'v'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'b'
operator|&&
name|getch
argument_list|()
operator|==
literal|'l'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
comment|/* More follows: it must be a string constant (class name).  */
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #pragma vtable"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
if|if
condition|(
name|write_virtuals
operator|!=
literal|2
condition|)
block|{
name|warning
argument_list|(
literal|"use `+e2' option to enable #pragma vtable"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|pending_vtables
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
argument_list|,
name|pending_vtables
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|<
literal|0
condition|)
name|nextchar
operator|=
name|getch
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextchar
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|warning
argument_list|(
literal|"trailing characters ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* More follows: it must be a string constant (unit name).  */
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #pragma unit"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|current_unit_name
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
name|current_unit_language
operator|=
name|current_lang_name
expr_stmt|;
if|if
condition|(
name|nextchar
operator|<
literal|0
condition|)
name|nextchar
operator|=
name|getch
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextchar
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|warning
argument_list|(
literal|"trailing characters ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
name|tree
name|fileinfo
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|get_time_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|)
decl_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'r'
operator|&&
name|getch
argument_list|()
operator|==
literal|'f'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'c'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* read to newline.  */
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|write_virtuals
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|tree
name|fi
decl_stmt|;
comment|/* If this is zero at this point, then we are 			     auto-implementing.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
name|filename
operator|=
name|FILE_NAME_NONDIRECTORY
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|fi
operator|=
name|get_time_identifier
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fi
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|fi
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|fi
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Get default.  */
name|impl_file_chain
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|impl_file_chain
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|impl_file_chain
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|interface_only
operator|=
name|interface_strcmp
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
literal|0
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
operator|&&
name|getch
argument_list|()
operator|==
literal|'p'
operator|&&
name|getch
argument_list|()
operator|==
literal|'l'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'m'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'o'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|char
modifier|*
name|main_filename
init|=
name|main_input_filename
condition|?
name|main_input_filename
else|:
name|input_filename
decl_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid `#pragma implementation'"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|main_filename
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
block|}
name|main_filename
operator|=
name|FILE_NAME_NONDIRECTORY
argument_list|(
name|main_filename
argument_list|)
expr_stmt|;
comment|/* read to newline.  */
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|==
literal|3
condition|)
block|{
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
while|while
condition|(
name|ifiles
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifiles
operator|->
name|filename
argument_list|,
name|main_filename
argument_list|)
condition|)
break|break;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|ifiles
operator|==
literal|0
condition|)
block|{
name|ifiles
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
name|main_filename
expr_stmt|;
name|ifiles
operator|->
name|next
operator|=
name|impl_file_chain
expr_stmt|;
name|impl_file_chain
operator|=
name|ifiles
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|main_input_filename
operator|!=
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|main_input_filename
argument_list|,
name|input_filename
argument_list|)
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|input_filename
argument_list|,
name|main_filename
argument_list|)
condition|)
block|{
name|write_virtuals
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
name|impl_file_chain
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|impl_file_chain
operator|->
name|filename
operator|=
name|main_filename
expr_stmt|;
name|impl_file_chain
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"`#pragma implementation' can only appear at top-level"
argument_list|)
expr_stmt|;
name|interface_only
operator|=
literal|0
expr_stmt|;
comment|/* We make this non-zero so that we infer decl linkage 			 in the impl file only for variables first declared 			 in the interface file.  */
name|interface_unknown
operator|=
literal|1
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|skipline
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'f'
operator|&&
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|)
operator|&&
operator|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|)
condition|)
name|dwarfout_define
argument_list|(
name|lineno
argument_list|,
name|get_directive_line
argument_list|(
name|finput
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'d'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'f'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|)
operator|&&
operator|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|)
condition|)
name|dwarfout_undef
argument_list|(
name|lineno
argument_list|,
name|get_directive_line
argument_list|(
name|finput
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
goto|goto
name|linenum
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'d'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
endif|#
directive|endif
comment|/* #ident.  The pedantic warning is now in cccp.c.  */
comment|/* Here we have just seen `#ident '. 		 A string constant should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* If no argument, ignore the line.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #ident"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Skip the rest of this line.  */
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'w'
operator|&&
name|getch
argument_list|()
operator|==
literal|'w'
operator|&&
name|getch
argument_list|()
operator|==
literal|'o'
operator|&&
name|getch
argument_list|()
operator|==
literal|'r'
operator|&&
name|getch
argument_list|()
operator|==
literal|'l'
operator|&&
name|getch
argument_list|()
operator|==
literal|'d'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* Used to test incremental compilation.  */
name|sorry
argument_list|(
literal|"#pragma newworld"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
name|error
argument_list|(
literal|"undefined or invalid # directive"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|linenum
label|:
comment|/* Here we have either `#line' or `#<nonletter>'.      In either case, it should be a line number; a digit should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* If the # is the only nonwhite char on the line,      just ignore it.  Check the new newline.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
comment|/* Something follows the #; read a token.  */
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
name|int
name|used_up
init|=
literal|0
decl_stmt|;
comment|/* subtract one, because it is the following line that 	 gets the specified number */
name|int
name|l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|-
literal|1
decl_stmt|;
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* No more: store the line number and check following line.  */
name|lineno
operator|=
name|l
expr_stmt|;
return|return
name|c
return|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* More follows: it must be a string constant (filename).  */
comment|/* Read the string constant, but don't treat \ as special.  */
name|ignore_escape_flag
operator|=
literal|1
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
name|ignore_escape_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #line"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
comment|/* Changing files again.  This means currently collected time 	 is charged against header time, and body time starts back 	 at 0.  */
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|int
name|this_time
init|=
name|my_get_run_time
argument_list|()
decl_stmt|;
name|tree
name|time_identifier
init|=
name|get_time_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
decl_stmt|;
name|header_time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|this_filename_time
operator|=
name|time_identifier
expr_stmt|;
name|body_time
operator|=
name|this_time
expr_stmt|;
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_note_source
argument_list|()
expr_stmt|;
name|input_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|input_filename
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|l
expr_stmt|;
name|GNU_xref_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
comment|/* Each change of file name 	 reinitializes whether we are now in a system header.  */
name|in_system_header
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
block|{
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
if|if
condition|(
name|ifiles
condition|)
block|{
while|while
condition|(
name|ifiles
operator|->
name|next
condition|)
name|ifiles
operator|=
name|ifiles
operator|->
name|next
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
name|FILE_NAME_NONDIRECTORY
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
block|}
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|==
literal|3
condition|)
name|walk_vtables
argument_list|(
name|set_typedecl_interface_info
argument_list|,
name|set_vardecl_interface_info
argument_list|)
expr_stmt|;
block|}
name|extract_interface_info
argument_list|()
expr_stmt|;
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_switch_source
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
name|used_up
operator|=
literal|0
expr_stmt|;
comment|/* `1' after file name means entering new file. 	 `2' after file name means just left a file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Pushing to a new file.  */
name|struct
name|file_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
decl_stmt|;
name|input_file_stack
operator|->
name|line
operator|=
name|old_lineno
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|input_file_stack
operator|=
name|p
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_start_new_source_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
name|used_up
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_push_source
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* Popping out of a file.  */
if|if
condition|(
name|input_file_stack
operator|->
name|next
condition|)
block|{
name|struct
name|file_stack
modifier|*
name|p
init|=
name|input_file_stack
decl_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_pop_source
argument_list|()
expr_stmt|;
name|input_file_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_resume_previous_source_file
argument_list|(
name|input_file_stack
operator|->
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
block|}
else|else
name|error
argument_list|(
literal|"#-lines for entering and leaving files don't match"
argument_list|)
expr_stmt|;
name|used_up
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_switch_source
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have handled a `1' or a `2', 	 see if there is another number to read.  */
if|if
condition|(
name|used_up
condition|)
block|{
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_switch_source
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|token
operator|=
name|real_yylex
argument_list|()
expr_stmt|;
name|used_up
operator|=
literal|0
expr_stmt|;
block|}
comment|/* `3' after file name means this is a system header file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|3
condition|)
name|in_system_header
operator|=
literal|1
expr_stmt|;
comment|/* If NEXTCHAR is not end of line, we don't care what it is.  */
if|if
condition|(
name|nextchar
operator|==
literal|'\n'
condition|)
return|return
literal|'\n'
return|;
block|}
else|else
name|error
argument_list|(
literal|"invalid #-line"
argument_list|)
expr_stmt|;
comment|/* skip the rest of this line.  */
name|skipline
label|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|isalnum
parameter_list|(
name|char
parameter_list|)
value|(char>= 'a' ? char<= 'z' : char>= '0' ? char<= '9' || (char>= 'A'&& char<= 'Z') : 0)
end_define

begin_define
define|#
directive|define
name|isdigit
parameter_list|(
name|char
parameter_list|)
value|(char>= '0'&& char<= '9')
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENDFILE
value|-1
end_define

begin_comment
comment|/* token that represents end-of-file */
end_comment

begin_comment
comment|/* Read an escape sequence, returning its equivalent as a character,    or store 1 in *ignore_ptr if it is backslash-newline.  */
end_comment

begin_function
specifier|static
name|int
name|readescape
parameter_list|(
name|ignore_ptr
parameter_list|)
name|int
modifier|*
name|ignore_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
name|getch
argument_list|()
decl_stmt|;
specifier|register
name|int
name|code
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
name|unsigned
name|firstdig
decl_stmt|;
name|int
name|nonnull
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"the meaning of `\\x' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nonnull
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|code
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
operator|||
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|firstdig
operator|=
name|code
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonnull
condition|)
name|error
argument_list|(
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* Digits are all 0's.  Ok.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
name|count
operator|>
literal|1
operator|&&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
operator|<=
name|firstdig
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"hex escape out of range"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|count
operator|++
operator|<
literal|3
operator|)
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|8
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
return|return
name|c
return|;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
operator|*
name|ignore_ptr
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'a'
case|:
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"the meaning of `\\a' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
return|return
name|TARGET_BELL
return|;
case|case
literal|'v'
case|:
return|return
name|TARGET_VT
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"non-ANSI-standard escape sequence, `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|033
return|;
case|case
literal|'?'
case|:
return|return
name|c
return|;
comment|/* `\(', etc, are used at beginning of line to avoid confusing Emacs.  */
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"unknown escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|pedwarn
argument_list|(
literal|"unknown escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"unknown escape sequence: `\\' followed by char code 0x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Value is 1 if we should try to make the next identifier look like a    typename (when it may be a local variable or a class variable).    Value is 0 if we treat this name in a default fashion.    Value is -1 if we must not see a type name.  */
end_comment

begin_decl_stmt
name|int
name|looking_for_typename
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dont_see_typename
parameter_list|()
block|{
name|looking_for_typename
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|TYPENAME
operator|||
name|yychar
operator|==
name|PTYPENAME
condition|)
block|{
name|yychar
operator|=
name|IDENTIFIER
expr_stmt|;
name|lastiddecl
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function_decl
specifier|extern
name|__inline
name|int
name|identifier_type
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|__inline
endif|#
directive|endif
name|int
name|identifier_type
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|PTYPENAME
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return
name|IDENTIFIER
return|;
return|return
name|TYPENAME
return|;
block|}
end_function

begin_function
name|void
name|see_typename
parameter_list|()
block|{
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|IDENTIFIER
condition|)
block|{
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag_labels_ok
condition|)
name|lastiddecl
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
block|}
else|else
name|yychar
operator|=
name|identifier_type
argument_list|(
name|lastiddecl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|do_identifier
parameter_list|(
name|token
parameter_list|)
specifier|register
name|tree
name|token
decl_stmt|;
block|{
specifier|register
name|tree
name|id
init|=
name|lastiddecl
decl_stmt|;
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
comment|/* Scope class declarations before global      declarations.  */
if|if
condition|(
name|id
operator|==
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|token
argument_list|)
operator|&&
name|current_class_type
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|current_class_type
argument_list|)
operator|!=
name|UNINSTANTIATED_P_TYPE
condition|)
block|{
comment|/* Could be from one of the base classes.  */
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
comment|/* We have already generated the error message. 	   But we still want to return this value.  */
name|id
operator|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|token
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|id
operator|=
name|field
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|my_friendly_abort
argument_list|(
literal|61
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"invalid use of member `%s' from base class `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|id
return|;
block|}
block|}
if|if
condition|(
operator|!
name|id
operator|||
name|id
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|error_mark_node
operator|&&
name|current_class_type
operator|!=
name|NULL_TREE
condition|)
block|{
name|id
operator|=
name|lookup_nested_field
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|/* In lookup_nested_field(), we marked this so we can gracefully 	     leave this whole mess.  */
if|if
condition|(
name|id
operator|&&
name|id
operator|!=
name|error_mark_node
operator|&&
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|id
return|;
block|}
if|if
condition|(
name|yychar
operator|==
literal|'('
operator|||
name|yychar
operator|==
name|LEFT_RIGHT
condition|)
block|{
name|id
operator|=
name|implicitly_declare
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`%s' undeclared, outside of functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|token
argument_list|)
operator|!=
name|error_mark_node
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|token
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
specifier|extern
name|int
name|undeclared_variable_notice
decl_stmt|;
name|error
argument_list|(
literal|"`%s' undeclared (first use this function)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|undeclared_variable_notice
condition|)
block|{
name|error
argument_list|(
literal|"(Each undeclared identifier is reported only once"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"for each function it appears in.)"
argument_list|)
expr_stmt|;
name|undeclared_variable_notice
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|id
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Prevent repeated error messages.  */
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|token
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|token
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* TREE_USED is set in `hack_identifier'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|token
argument_list|)
operator|==
name|id
condition|)
block|{
comment|/* Check visibility.  */
name|enum
name|visibility_type
name|visibility
init|=
name|compute_visibility
argument_list|(
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
name|error_with_decl
argument_list|(
name|id
argument_list|,
literal|"enum `%s' is private"
argument_list|)
expr_stmt|;
comment|/* protected is OK, since it's an enum of `this'.  */
block|}
name|id
operator|=
name|DECL_INITIAL
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
name|id
operator|=
name|hack_identifier
argument_list|(
name|id
argument_list|,
name|token
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
name|tree
name|identifier_typedecl_value
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|,
name|type
decl_stmt|;
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
define|#
directive|define
name|do
parameter_list|(
name|X
parameter_list|)
define|\
value|{ \     t = (X); \     if (t&& TREE_CODE (t) == TYPE_DECL&& TREE_TYPE (t) == type) \       return t; \   }
do|do
operator|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|node
argument_list|)
operator|)
expr_stmt|;
do|do (IDENTIFIER_CLASS_VALUE (node
block|)
end_function

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_do
do|do
operator|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|node
argument_list|)
operator|)
expr_stmt|;
undef|#
directive|undef
name|do
comment|/* Will this one ever happen?  */
do|if (TYPE_NAME (type
end_do

begin_return
unit|))
return|return
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
return|;
end_return

begin_expr_stmt
name|my_friendly_abort
argument_list|(
literal|62
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  struct
name|try_type
end_macro

begin_block
block|{
name|tree
modifier|*
name|node_var
decl_stmt|;
name|char
name|unsigned_flag
decl_stmt|;
name|char
name|long_flag
decl_stmt|;
name|char
name|long_long_flag
decl_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|try_type
name|type_sequence
index|[]
init|=
block|{
block|{
operator|&
name|integer_type_node
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|&
name|unsigned_type_node
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|&
name|long_integer_type_node
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
operator|&
name|long_unsigned_type_node
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
operator|&
name|long_long_integer_type_node
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
operator|&
name|long_long_unsigned_type_node
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|real_yylex
parameter_list|()
block|{
name|tree
name|tmp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|value
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|dollar_seen
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* Effectively do c = skip_white_space (c)      but do it faster in the usual cases.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* Call skip_white_space so we can warn if appropriate.  */
case|case
literal|'\n'
case|:
case|case
literal|'/'
case|:
case|case
literal|'\\'
case|:
name|c
operator|=
name|skip_white_space
argument_list|(
name|c
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|found_nonwhite
goto|;
block|}
name|found_nonwhite
label|:
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  yylloc.first_line = lineno; */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|end_of_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|input_redirected
argument_list|()
condition|)
name|value
operator|=
name|END_OF_SAVED_INPUT
expr_stmt|;
elseif|else
if|if
condition|(
name|do_pending_expansions
argument_list|()
condition|)
comment|/* this will set yychar for us */
return|return
name|yychar
return|;
else|else
name|value
operator|=
name|ENDFILE
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|dollars_in_ident
condition|)
block|{
name|dollar_seen
operator|=
literal|1
expr_stmt|;
goto|goto
name|letter
goto|;
block|}
name|value
operator|=
literal|'$'
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'L'
case|:
comment|/* Capital L may start a wide-string or wide-character constant.  */
block|{
specifier|register
name|int
name|c
init|=
name|getch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|char_constant
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|string_constant
goto|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'_'
case|:
name|letter
label|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
if|if
condition|(
name|input
operator|==
literal|0
condition|)
block|{
comment|/* We know that `token_buffer' can hold at least on char, 	       so we install C immediately. 	       We may have to read the value in `putback_char', so call 	       `getch' once.  */
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* Make this run fast.  We know that we are reading straight 	       from FINPUT in this case (since identifiers cannot straddle 	       input sources.  */
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
operator|!
name|dollars_in_ident
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We know that `token_buffer' can hold at least on char, 	       so we install C immediately.  */
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
operator|!
name|dollars_in_ident
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
name|IDENTIFIER
expr_stmt|;
name|yylval
operator|.
name|itype
operator|=
literal|0
expr_stmt|;
comment|/* Try to recognize a keyword.  Uses minimum-perfect hash function */
block|{
specifier|register
name|struct
name|resword
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|=
name|is_reserved_word
argument_list|(
name|token_buffer
argument_list|,
name|p
operator|-
name|token_buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rid
condition|)
block|{
name|tree
name|old_ttype
init|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|ptr
operator|->
name|rid
index|]
decl_stmt|;
comment|/* If this provides a type for us, then revert lexical 		     state to standard state.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_ttype
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|old_ttype
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|old_ttype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
name|AGGR
operator|||
name|ptr
operator|->
name|token
operator|==
name|ENUM
condition|)
name|looking_for_typename
operator|=
literal|1
expr_stmt|;
comment|/* Check if this is a language-type declaration. 		     Just glimpse the next non-white character.  */
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'"'
condition|)
block|{
comment|/* We are looking at a string.  Complain 			 if the token before the string is no `extern'. 			  			 Could cheat some memory by placing this string 			 on the temporary_, instead of the saveable_ 			 obstack.  */
if|if
condition|(
name|ptr
operator|->
name|rid
operator|!=
name|RID_EXTERN
condition|)
name|error
argument_list|(
literal|"invalid modifier `%s' for language string"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|real_yylex
argument_list|()
expr_stmt|;
name|value
operator|=
name|EXTERN_LANG_STRING
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ptr
operator|->
name|token
operator|==
name|VISSPEC
condition|)
block|{
switch|switch
condition|(
name|ptr
operator|->
name|rid
condition|)
block|{
case|case
name|RID_PUBLIC
case|:
name|yylval
operator|.
name|itype
operator|=
name|visibility_public
expr_stmt|;
break|break;
case|case
name|RID_PRIVATE
case|:
name|yylval
operator|.
name|itype
operator|=
name|visibility_private
expr_stmt|;
break|break;
case|case
name|RID_PROTECTED
case|:
name|yylval
operator|.
name|itype
operator|=
name|visibility_protected
expr_stmt|;
break|break;
default|default:
name|my_friendly_abort
argument_list|(
literal|63
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|yylval
operator|.
name|ttype
operator|=
name|old_ttype
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|int
operator|)
name|ptr
operator|->
name|token
expr_stmt|;
block|}
block|}
comment|/* If we did not find a keyword, look for an identifier 	   (or a typename).  */
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
operator|||
name|value
operator|==
name|TYPESPEC
condition|)
name|GNU_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
condition|)
block|{
name|tmp
operator|=
name|get_identifier
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/* Make sure that user does not collide with our internal 	       naming scheme.  */
if|if
condition|(
name|JOINER
operator|==
literal|'$'
operator|&&
name|dollar_seen
operator|&&
operator|(
name|THIS_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|VPTR_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|DESTRUCTOR_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|VTABLE_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|TEMP_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|ANON_AGGRNAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|ANON_PARMNAME_P
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"identifier name `%s' conflicts with GNU C++ internal naming strategy"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yylval
operator|.
name|ttype
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|NEW
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
block|{
name|looking_for_typename
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|NEW
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
break|break;
case|case
literal|'.'
case|:
block|{
specifier|register
name|int
name|c1
init|=
name|getch
argument_list|()
decl_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'*'
condition|)
block|{
name|value
operator|=
name|DOT_STAR
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|c1
operator|==
literal|'.'
condition|)
block|{
name|c1
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'.'
condition|)
block|{
name|token_buffer
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
name|token_buffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ELLIPSIS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextchar
operator|=
name|c1
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|RANGE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c1
argument_list|)
condition|)
block|{
name|put_back
argument_list|(
name|c1
argument_list|)
expr_stmt|;
goto|goto
name|resume_numerical_scan
goto|;
block|}
name|nextchar
operator|=
name|c1
expr_stmt|;
name|value
operator|=
literal|'.'
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
comment|/* Optimize for most frequent case.  */
block|{
specifier|register
name|int
name|c1
init|=
name|getch
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c1
argument_list|)
operator|&&
name|c1
operator|!=
literal|'.'
condition|)
block|{
comment|/* Terminate string.  */
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|integer_one_node
expr_stmt|;
name|nextchar
operator|=
name|c1
expr_stmt|;
name|value
operator|=
name|CONSTANT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|put_back
argument_list|(
name|c1
argument_list|)
expr_stmt|;
block|}
comment|/* fall through... */
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|resume_numerical_scan
label|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|largest_digit
init|=
literal|0
decl_stmt|;
name|int
name|numdigits
init|=
literal|0
decl_stmt|;
comment|/* for multi-precision arithmetic, 	   we store only 8 live bits in each short.  */
name|short
name|shorts
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
enum|enum
name|anon1
block|{
name|NOT_FLOAT
block|,
name|AFTER_POINT
block|,
name|TOO_MANY_POINTS
block|}
name|floatflag
init|=
name|NOT_FLOAT
enum|;
name|p
operator|=
name|token_buffer
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|MAX_SHORTS
condition|;
name|count
operator|++
control|)
name|shorts
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
block|}
comment|/* Leading 0 forces octal unless the 0 is the only digit.  */
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
block|}
else|else
name|numdigits
operator|++
expr_stmt|;
block|}
comment|/* Read all the digits-and-decimal-points.  */
while|while
condition|(
name|c
operator|==
literal|'.'
operator|||
operator|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'l'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'L'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'u'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'U'
operator|)
operator|&&
operator|(
name|floatflag
operator|==
name|NOT_FLOAT
operator|||
operator|(
operator|(
name|c
operator|!=
literal|'f'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'F'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|16
condition|)
name|error
argument_list|(
literal|"floating constant may not be in radix 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|floatflag
operator|==
name|AFTER_POINT
condition|)
block|{
name|error
argument_list|(
literal|"malformed floating constant"
argument_list|)
expr_stmt|;
name|floatflag
operator|=
name|TOO_MANY_POINTS
expr_stmt|;
block|}
else|else
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* Accept '.' as the start of a floating-point number 		   only when it is followed by a digit. 		   Otherwise, unread the following non-digit 		   and use the '.' as a structural token.  */
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
literal|2
operator|&&
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|ELLIPSIS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextchar
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|RANGE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextchar
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
literal|'.'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* It is not a decimal point. 		   It should be a digit (perhaps a hex digit).  */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|<=
literal|10
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
operator|~
literal|040
operator|)
operator|==
literal|'E'
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
break|break;
comment|/* start of exponent */
block|}
name|error
argument_list|(
literal|"nondigits in number and not hexadecimal"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
name|largest_digit
condition|)
name|largest_digit
operator|=
name|c
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|MAX_SHORTS
condition|;
name|count
operator|++
control|)
block|{
name|shorts
index|[
name|count
index|]
operator|*=
name|base
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|shorts
index|[
name|count
index|]
operator|+=
operator|(
name|shorts
index|[
name|count
operator|-
literal|1
index|]
operator|>>
literal|8
operator|)
expr_stmt|;
name|shorts
index|[
name|count
operator|-
literal|1
index|]
operator|&=
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|shorts
index|[
literal|0
index|]
operator|+=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|shorts
index|[
name|MAX_SHORTS
operator|-
literal|1
index|]
operator|>=
literal|1
operator|<<
literal|8
operator|||
name|shorts
index|[
name|MAX_SHORTS
operator|-
literal|1
index|]
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|overflow
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numdigits
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"numeric constant with no digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|largest_digit
operator|>=
name|base
condition|)
name|error
argument_list|(
literal|"numeric constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
comment|/* Remove terminating char from the token buffer and delimit the string */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|floatflag
operator|!=
name|NOT_FLOAT
condition|)
block|{
name|tree
name|type
init|=
name|double_type_node
decl_stmt|;
name|char
name|f_seen
init|=
literal|0
decl_stmt|;
name|char
name|l_seen
init|=
literal|0
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
comment|/* Read explicit exponent if any, and put it in tokenbuf.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"floating constant exponent has no digits"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Convert string to a double, checking for overflow.  */
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"floating constant out of range"
argument_list|)
expr_stmt|;
name|value
operator|=
name|dconst0
expr_stmt|;
block|}
else|else
block|{
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ERANGE
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|&&
operator|!
name|flag_traditional
condition|)
block|{
name|char
modifier|*
name|p1
init|=
name|token_buffer
decl_stmt|;
comment|/* Check for "0.0" and variants; 		   SunOS 4 spuriously returns ERANGE for them.  */
while|while
condition|(
operator|*
name|p1
operator|==
literal|'0'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
block|{
name|p1
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|'0'
condition|)
name|p1
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p1
operator|==
literal|'e'
operator|||
operator|*
name|p1
operator|==
literal|'E'
condition|)
block|{
comment|/* with significand==0, ignore the exponent */
name|p1
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|!=
literal|0
condition|)
name|p1
operator|++
expr_stmt|;
block|}
comment|/* ERANGE is also reported for underflow, 		   so test the value to distinguish overflow from that.  */
if|if
condition|(
operator|*
name|p1
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|>
literal|1.0
operator|||
name|value
operator|<
operator|-
literal|1.0
operator|)
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `double'"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Read the suffixes to choose a data type.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'f'
operator|||
name|c
operator|==
literal|'F'
condition|)
block|{
if|if
condition|(
name|f_seen
condition|)
name|error
argument_list|(
literal|"two `f's in floating constant"
argument_list|)
expr_stmt|;
name|f_seen
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|float_type_node
expr_stmt|;
name|value
operator|=
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|l_seen
condition|)
name|error
argument_list|(
literal|"two `l's in floating constant"
argument_list|)
expr_stmt|;
name|l_seen
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|long_double_type_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"garbage at end of number"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
comment|/* Create a node with determined type and value.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|int
name|spec_unsigned
init|=
literal|0
decl_stmt|;
name|int
name|spec_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_long_long
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|spec_unsigned
condition|)
name|error
argument_list|(
literal|"two `u's in integer constant"
argument_list|)
expr_stmt|;
name|spec_unsigned
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|spec_long
condition|)
block|{
if|if
condition|(
name|spec_long_long
condition|)
name|error
argument_list|(
literal|"three `l's in integer constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids long long integer constants"
argument_list|)
expr_stmt|;
name|spec_long_long
operator|=
literal|1
expr_stmt|;
block|}
name|spec_long
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"garbage at end of number"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
name|put_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* ??? This code assumes that everything but long long is 32-bits. 	       Probably this code needs to be replaced with code similar 	       to that in c-lex.c, but I don't want to do it. -- RK.  */
if|if
condition|(
operator|(
name|overflow
operator|||
name|shorts
index|[
literal|7
index|]
operator|||
name|shorts
index|[
literal|6
index|]
operator|||
name|shorts
index|[
literal|5
index|]
operator|||
name|shorts
index|[
literal|4
index|]
operator|)
operator|&&
operator|!
name|spec_long_long
condition|)
name|warning
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
comment|/* If it won't fit in a signed long long, make it unsigned. 	       We can't distinguish based on the tree node because 	       any integer constant fits any long long type.  */
if|if
condition|(
name|shorts
index|[
literal|7
index|]
operator|>=
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|spec_unsigned
operator|=
literal|1
expr_stmt|;
comment|/* This is simplified by the fact that our constant 	       is always positive.  */
name|high
operator|=
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SHORTS
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|high
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|shorts
index|[
name|i
operator|+
name|MAX_SHORTS
operator|/
literal|2
index|]
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
name|low
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|shorts
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
block|}
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Find the first allowable type that the value fits in.  */
block|type = 0; 	    for (i = 0; i< sizeof (type_sequence) / sizeof (type_sequence[0]); 		 i++) 	      if (!(spec_long&& !type_sequence[i].long_flag)&& !(spec_long_long&& !type_sequence[i].long_long_flag)&& !(spec_unsigned&& !type_sequence[i].unsigned_flag)
comment|/* A hex or octal constant traditionally is unsigned.  */
block|&& !(base != 10&& flag_traditional&& !type_sequence[i].unsigned_flag)
comment|/* A decimal constant can't be unsigned int 		     unless explicitly specified.  */
block|&& !(base == 10&& !spec_unsigned&& *type_sequence[i].node_var == unsigned_type_node)) 		if (int_fits_type_p (yylval.ttype, *type_sequence[i].node_var)) 		  { 		    type = *type_sequence[i].node_var; 		    break; 		  } 	    if (flag_traditional&& type == long_unsigned_type_node&& !spec_unsigned) 	      type = long_integer_type_node; 	       	    if (type == 0) 	      { 		type = long_long_integer_type_node; 		warning ("integer constant out of range"); 	      }
comment|/* Warn about some cases where the type of a given constant 	       changes from traditional C to ANSI C.  */
block|if (warn_traditional) 	      { 		tree other_type = 0;
comment|/* This computation is the same as the previous one 		   except that flag_traditional is used backwards.  */
block|for (i = 0; i< sizeof (type_sequence) / sizeof (type_sequence[0]); 		     i++) 		  if (!(spec_long&& !type_sequence[i].long_flag)&& !(spec_long_long&& !type_sequence[i].long_long_flag)&& !(spec_unsigned&& !type_sequence[i].unsigned_flag)
comment|/* A hex or octal constant traditionally is unsigned.  */
block|&& !(base != 10&& !flag_traditional&& !type_sequence[i].unsigned_flag)
comment|/* A decimal constant can't be unsigned int 			 unless explicitly specified.  */
block|&& !(base == 10&& !spec_unsigned&& *type_sequence[i].node_var == unsigned_type_node)) 		    if (int_fits_type_p (yylval.ttype, *type_sequence[i].node_var)) 		      { 			other_type = *type_sequence[i].node_var; 			break; 		      } 		if (!flag_traditional&& type == long_unsigned_type_node&& !spec_unsigned) 		  type = long_integer_type_node; 	       		if (other_type != 0&& other_type != type) 		  { 		    if (flag_traditional) 		      warning ("type of integer constant would be different without -traditional"); 		    else 		      warning ("type of integer constant would be different with -traditional"); 		  } 	      }
else|#
directive|else
comment|/* 1 */
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|!
name|spec_unsigned
operator|&&
operator|!
operator|(
name|flag_traditional
operator|&&
name|base
operator|!=
literal|10
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (warn_traditional&& base != 10) 		  warning ("small nondecimal constant becomes signed in ANSI C++");
endif|#
directive|endif
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|(
name|base
operator|!=
literal|10
operator|||
name|spec_unsigned
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
block|{
comment|/* Nondecimal constants try unsigned even in traditional C.  */
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
operator|!
name|spec_long_long
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_integer_type_node
argument_list|)
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long_long
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_unsigned_type_node
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (warn_traditional&& !spec_unsigned) 		  warning ("large integer constant becomes unsigned in ANSI C++");
endif|#
directive|endif
if|if
condition|(
name|flag_traditional
operator|&&
operator|!
name|spec_unsigned
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
else|else
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_long_integer_type_node
argument_list|)
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (warn_traditional&& !spec_unsigned) 		  warning ("large nondecimal constant is unsigned in ANSI C++");
endif|#
directive|endif
if|if
condition|(
name|flag_traditional
operator|&&
operator|!
name|spec_unsigned
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
else|else
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
name|warning
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|type
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'\''
case|:
name|char_constant
label|:
block|{
specifier|register
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|num_chars
init|=
literal|0
decl_stmt|;
name|unsigned
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
if|if
condition|(
name|wide_flag
condition|)
block|{
name|width
operator|=
name|WCHAR_TYPE_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|max_chars
operator|=
name|MB_CUR_MAX
expr_stmt|;
else|#
directive|else
name|max_chars
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|max_chars
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|/
name|width
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tryagain
label|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readescape
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
goto|goto
name|tryagain
goto|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
operator|)
name|c
operator|>=
operator|(
literal|1
operator|<<
name|width
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids newline in character constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
name|num_chars
operator|++
expr_stmt|;
if|if
condition|(
name|num_chars
operator|>
name|maxtoken
operator|-
literal|4
condition|)
name|extend_token_buffer
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|token_buffer
index|[
name|num_chars
index|]
operator|=
name|c
expr_stmt|;
comment|/* Merge character into result; ignore excess chars.  */
if|if
condition|(
name|num_chars
operator|<
name|max_chars
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|c
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
block|}
block|}
name|token_buffer
index|[
name|num_chars
operator|+
literal|1
index|]
operator|=
literal|'\''
expr_stmt|;
name|token_buffer
index|[
name|num_chars
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"malformatted character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"empty character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|>
name|max_chars
condition|)
block|{
name|num_chars
operator|=
name|max_chars
expr_stmt|;
name|error
argument_list|(
literal|"character constant too long"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_chars
operator|!=
literal|1
operator|&&
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* If char type is signed, sign-extend the constant.  */
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
name|int
name|num_bits
init|=
name|num_chars
operator|*
name|width
decl_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|char_type_node
argument_list|)
operator|||
operator|(
operator|(
name|result
operator|>>
operator|(
name|num_bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator|&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator||
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_chars
operator|<=
literal|1
condition|)
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_type_node
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Set the initial shift state and convert the next sequence.  */
name|result
operator|=
literal|0
expr_stmt|;
comment|/* In all locales L'\0' is zero and mbtowc will return zero, 	       so don't use it.  */
if|if
condition|(
name|num_chars
operator|>
literal|1
operator|||
operator|(
name|num_chars
operator|==
literal|1
operator|&&
name|token_buffer
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|wchar_t
name|wc
decl_stmt|;
operator|(
name|void
operator|)
name|mbtowc
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|,
name|num_chars
argument_list|)
operator|==
name|num_chars
condition|)
name|result
operator|=
name|wc
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|wchar_type_node
expr_stmt|;
block|}
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'"'
case|:
name|string_constant
label|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|p
operator|=
name|token_buffer
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
comment|/* ignore_escape_flag is set for reading the filename in #line.  */
if|if
condition|(
operator|!
name|ignore_escape_flag
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readescape
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
goto|goto
name|skipnewline
goto|;
if|if
condition|(
operator|!
name|wide_flag
operator|&&
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|<
name|HOST_BITS_PER_INT
operator|&&
name|c
operator|>=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C++ forbids newline in string constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|skipnewline
label|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|"Unterminated string"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* We have read the entire constant. 	   Construct a STRING_CST for the result.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
comment|/* If this is a L"..." wide-string, convert the multibyte string 	       to a wide character string.  */
name|char
modifier|*
name|widep
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|p
operator|-
name|token_buffer
operator|)
operator|*
name|WCHAR_BYTES
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|len
operator|=
name|mbstowcs
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|widep
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|,
name|p
operator|-
name|token_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|len
operator|>=
operator|(
name|p
operator|-
name|token_buffer
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"Ignoring invalid multibyte string"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
name|widep
operator|+
operator|(
name|len
operator|*
name|WCHAR_BYTES
operator|)
argument_list|,
name|WCHAR_BYTES
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
union|union
block|{
name|long
name|l
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|u
union|;
name|int
name|big_endian
decl_stmt|;
name|char
modifier|*
name|wp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* Determine whether host is little or big endian.  */
name|u
operator|.
name|l
operator|=
literal|1
expr_stmt|;
name|big_endian
operator|=
name|u
operator|.
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|wp
operator|=
name|widep
operator|+
operator|(
name|big_endian
condition|?
name|WCHAR_BYTES
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|widep
argument_list|,
operator|(
name|p
operator|-
name|token_buffer
operator|)
operator|*
name|WCHAR_BYTES
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|token_buffer
operator|+
literal|1
init|;
name|cp
operator|<
name|p
condition|;
name|cp
operator|++
control|)
operator|*
name|wp
operator|=
operator|*
name|cp
operator|,
name|wp
operator|+=
name|WCHAR_BYTES
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|token_buffer
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
name|WCHAR_BYTES
argument_list|,
name|widep
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|wchar_array_type_node
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
name|p
operator|-
name|token_buffer
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
break|break;
block|}
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
block|{
specifier|register
name|int
name|c1
decl_stmt|;
name|combine
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|yylval
operator|.
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|yylval
operator|.
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|yylval
operator|.
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|RSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|yylval
operator|.
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|yylval
operator|.
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
block|}
name|token_buffer
index|[
literal|1
index|]
operator|=
name|c1
operator|=
name|getch
argument_list|()
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'>'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|GE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'!'
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|NE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'='
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|value
operator|=
name|ASSIGN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|c1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|value
operator|=
name|PLUSPLUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'-'
case|:
name|value
operator|=
name|MINUSMINUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'&'
case|:
name|value
operator|=
name|ANDAND
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'|'
case|:
name|value
operator|=
name|OROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'<'
case|:
name|c
operator|=
name|LSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
case|case
literal|'>'
case|:
name|c
operator|=
name|RSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|c1
operator|==
literal|'>'
operator|)
condition|)
block|{
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'('
condition|)
block|{
name|int
name|next_c
init|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_c
operator|==
literal|')'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|value
operator|=
name|POINTSAT_LEFT_RIGHT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|put_back
argument_list|(
name|next_c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextchar
operator|==
literal|'*'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|value
operator|=
name|POINTSAT_STAR
expr_stmt|;
block|}
else|else
name|value
operator|=
name|POINTSAT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'?'
operator|&&
operator|(
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'>'
operator|)
condition|)
block|{
name|token_buffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|c1
operator|=
name|getch
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
operator|(
name|c
operator|==
literal|'<'
condition|?
name|MIN_EXPR
else|:
name|MAX_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
block|{
comment|/*<?= or>?= expression.  */
name|token_buffer
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
name|value
operator|=
name|ASSIGN
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|MIN_MAX
expr_stmt|;
name|nextchar
operator|=
name|c1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
name|error
argument_list|(
literal|"use of `operator %s' is not standard C++"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextchar
operator|=
name|c1
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
literal|':'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|SCOPE
expr_stmt|;
name|yylval
operator|.
name|itype
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
literal|':'
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* Don't make yyparse think this is eof.  */
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'('
case|:
comment|/* try, weakly, to handle casts to pointers to functions.  */
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'*'
condition|)
block|{
name|int
name|next_c
init|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_c
operator|==
literal|')'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|PAREN_STAR_PAREN
expr_stmt|;
block|}
else|else
block|{
name|put_back
argument_list|(
name|next_c
argument_list|)
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nextchar
operator|==
literal|')'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|NULL_TREE
expr_stmt|;
name|value
operator|=
name|LEFT_RIGHT
expr_stmt|;
block|}
else|else
name|value
operator|=
name|c
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|c
expr_stmt|;
block|}
name|done
label|:
comment|/*  yylloc.last_line = lineno; */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|token_count
index|[
name|value
index|]
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|d_kind
block|,
name|t_kind
block|,
name|s_kind
block|,
name|r_kind
block|,
name|e_kind
block|,
name|c_kind
block|,
name|id_kind
block|,
name|op_id_kind
block|,
name|perm_list_kind
block|,
name|temp_list_kind
block|,
name|vec_kind
block|,
name|x_kind
block|,
name|lang_decl
block|,
name|lang_type
block|,
name|all_kinds
block|}
name|tree_node_kind
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|int
name|tree_node_counts
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tree_node_sizes
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tree_node_kind_names
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place to save freed lang_decls which were allocated on the    permanent_obstack.  @@ Not currently used.  */
end_comment

begin_decl_stmt
name|tree
name|free_lang_decl_chain
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|build_lang_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
else|else
comment|/* Could be that saveable is permanent and current is not.  */
name|obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
if|if
condition|(
name|free_lang_decl_chain
operator|&&
name|obstack
operator|==
operator|&
name|permanent_obstack
condition|)
block|{
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|free_lang_decl_chain
expr_stmt|;
name|free_lang_decl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|free_lang_decl_chain
argument_list|)
expr_stmt|;
block|}
else|else
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
name|LANG_DECL_PERMANENT
argument_list|(
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
argument_list|)
operator|=
name|obstack
operator|==
operator|&
name|permanent_obstack
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|LANG_DECL_PERMANENT
argument_list|(
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
argument_list|)
operator|==
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
argument_list|,
literal|234
argument_list|)
expr_stmt|;
name|DECL_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|=
name|lang_cplusplus
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_AUTO_OVERLOAD
if|if
condition|(
name|code
operator|==
name|FUNCTION_DECL
operator|&&
name|name
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|TREE_OVERLOADED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|=
name|lang_c
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|64
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|if (code == TYPE_DECL)     {       tree id;       id = get_identifier (build_overload_name (type, 1, 1));       DECL_ASSEMBLER_NAME (t) = id;     }
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_lang_field_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|if (code == TYPE_DECL)     {       tree id;       id = get_identifier (build_overload_name (type, 1, 1));       DECL_ASSEMBLER_NAME (t) = id;     }
endif|#
directive|endif
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
else|else
name|my_friendly_assert
argument_list|(
name|obstack
operator|==
operator|&
name|permanent_obstack
argument_list|,
literal|235
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|copy_lang_decl
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pi
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|make_lang_type
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|make_node
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
comment|/* Set up some flags that give proper default behavior.  */
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
else|else
name|my_friendly_assert
argument_list|(
name|obstack
operator|==
operator|&
name|permanent_obstack
argument_list|,
literal|236
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_type
operator|*
operator|)
name|pi
expr_stmt|;
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
operator|=
name|make_binfo
argument_list|(
name|integer_zero_node
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CLASSTYPE_BINFO_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_BINFO
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure this is laid out, for ease of use later.      In the presence of parse errors, the normal was of assuring      this might not ever get executed, so we lay it out *immediately*.  */
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|copy_decl_lang_specific
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|int
modifier|*
name|old
init|=
operator|(
name|int
operator|*
operator|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
else|else
name|my_friendly_assert
argument_list|(
name|obstack
operator|==
operator|&
name|permanent_obstack
argument_list|,
literal|237
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|pi
index|[
name|i
index|]
operator|=
name|old
index|[
name|i
index|]
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dump_time_statistics
parameter_list|()
block|{
specifier|register
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
name|int
name|this_time
init|=
name|my_get_run_time
argument_list|()
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"header files (total)"
argument_list|,
name|header_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"main file (total)"
argument_list|,
name|this_time
operator|-
name|body_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ratio = %g : 1\n"
argument_list|,
operator|(
name|double
operator|)
name|header_time
operator|/
call|(
name|double
call|)
argument_list|(
name|this_time
operator|-
name|body_time
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|filename_times
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
for|for
control|(
name|decl
operator|=
name|prev
init|;
name|decl
condition|;
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|)
control|)
name|print_time
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compiler_error
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|,
name|v2
decl_stmt|;
comment|/* @@also used as pointer */
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|"%s (compiler error)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compiler_error_with_decl
parameter_list|(
name|decl
parameter_list|,
name|s
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|lang_printable_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
literal|"((anonymous))"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (compiler error)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|yyerror
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|extern
name|int
name|end_of_file
decl_stmt|;
specifier|extern
name|int
name|input_redirected
parameter_list|()
function_decl|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* We can't print string and character constants well      because the token_buffer contains the result of processing escapes.  */
if|if
condition|(
name|end_of_file
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|input_redirected
argument_list|()
condition|?
literal|" at end of saved text"
else|:
literal|" at end of input"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" at null character"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before string constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|<
literal|040
operator|||
operator|(
name|unsigned
name|char
operator|)
name|token_buffer
index|[
literal|0
index|]
operator|>=
literal|0177
condition|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|" before character 0%o"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|token_buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

