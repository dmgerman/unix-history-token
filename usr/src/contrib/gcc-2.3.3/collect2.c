begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Collect static initialization info into data structures    that can be traversed by C++ initialization and finalization    routines.     Copyright (C) 1992 Free Software Foundation, Inc.    Contributed by Chris Smith (csmith@convex.com).    Heavily modified by Michael Meissner (meissner@osf.org),    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Build tables of static constructors and destructors and run ld. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COLLECT
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_define
define|#
directive|define
name|generic
value|char
end_define

begin_define
define|#
directive|define
name|const
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|generic
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On MSDOS, write temp files in current dir    because there's no place else we can expect to use.  */
end_comment

begin_if
if|#
directive|if
name|__MSDOS__
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|P_tmpdir
end_ifndef

begin_define
define|#
directive|define
name|P_tmpdir
value|"./"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* On certain systems, we have code that works by scanning the object file    directly.  But this code uses system-specific header files and library    functions, so turn it off in a cross-compiler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_undef
undef|#
directive|undef
name|OBJECT_FORMAT_COFF
end_undef

begin_undef
undef|#
directive|undef
name|OBJECT_FORMAT_ROSE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we can't use a special method, use the ordinary one:    run nm to find what symbols are present.    In a cross-compiler, this means you need a cross nm,    but that isn't quite as unpleasant as special headers.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_COFF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_ROSE
argument_list|)
end_if

begin_define
define|#
directive|define
name|OBJECT_FORMAT_NONE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UMAX
end_ifdef

begin_include
include|#
directive|include
file|<sgs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_define
define|#
directive|define
name|ISCOFF
parameter_list|(
name|magic
parameter_list|)
define|\
value|((magic) == U802WRMAGIC || (magic) == U802ROMAGIC || (magic) == U802TOCMAGIC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Many versions of ldfcn.h define these.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FREAD
end_undef

begin_undef
undef|#
directive|undef
name|FWRITE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ldfcn.h>
end_include

begin_comment
comment|/* Mips-news overrides this macro.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_ISCOFF
end_ifndef

begin_define
define|#
directive|define
name|MY_ISCOFF
parameter_list|(
name|X
parameter_list|)
value|ISCOFF (X)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_COFF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ROSE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|_OSF_SOURCE
end_ifdef

begin_define
define|#
directive|define
name|USE_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_format.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_header.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_vals.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ROSE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_NONE
end_ifdef

begin_comment
comment|/* Default flags to pass to nm.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NM_FLAGS
end_ifndef

begin_define
define|#
directive|define
name|NM_FLAGS
value|"-p"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_NONE */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Linked lists of constructor and destructor names. */
end_comment

begin_struct
struct|struct
name|id
block|{
name|struct
name|id
modifier|*
name|next
decl_stmt|;
name|int
name|sequence
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|head
block|{
name|struct
name|id
modifier|*
name|first
decl_stmt|;
name|struct
name|id
modifier|*
name|last
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Enumeration giving which pass this is for scanning the program file.  */
end_comment

begin_enum
enum|enum
name|pass
block|{
name|PASS_FIRST
block|,
comment|/* without constructors */
name|PASS_SECOND
comment|/* with constructors linked in */
block|}
enum|;
end_enum

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_SIGLIST
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -v */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -r */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strip_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -s */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -debug */
end_comment

begin_decl_stmt
specifier|static
name|int
name|temp_filename_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of temp_filename */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of temp filenames */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|c_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.c for constructor/destructor list. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|o_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.o for constructor/destructor list. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of nm */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strip_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of strip */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|constructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of constructors found */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|destructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of destructors found */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_prog_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fork_execute
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_wait
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_c_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|my_exit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handler
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_unlink
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|choose_temp_base
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|generic
modifier|*
name|xcalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|generic
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DUP2
end_ifdef

begin_macro
name|dup2
argument_list|(
argument|oldfd
argument_list|,
argument|newfd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|oldfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fdtmp
index|[
literal|256
index|]
decl_stmt|;
name|int
name|fdx
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|oldfd
operator|==
name|newfd
condition|)
return|return
literal|0
return|;
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|oldfd
argument_list|)
operator|)
operator|!=
name|newfd
condition|)
comment|/* good enough for low fd's */
name|fdtmp
index|[
name|fdx
operator|++
index|]
operator|=
name|fd
expr_stmt|;
while|while
condition|(
name|fdx
operator|>
literal|0
condition|)
name|close
argument_list|(
name|fdtmp
index|[
operator|--
name|fdx
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|my_strerror
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|e
operator|>
literal|0
operator|&&
name|e
operator|<
name|sys_nerr
condition|)
return|return
name|sys_errlist
index|[
name|e
index|]
return|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Unknown error %d"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete tempfiles and exit function.  */
end_comment

begin_function
specifier|static
name|void
name|my_exit
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|c_file
operator|!=
literal|0
operator|&&
name|c_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_file
operator|!=
literal|0
operator|&&
name|o_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Die when sys call fails. */
end_comment

begin_function
specifier|static
name|void
name|fatal_perror
parameter_list|(
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|my_strerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just die. */
end_comment

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write error message.  */
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In case obstack is linked in, and abort is defined to fancy_abort,    provide a default entry.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"internal error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|handler
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
name|c_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|generic
modifier|*
name|xcalloc
parameter_list|(
name|size1
parameter_list|,
name|size2
parameter_list|)
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
block|{
name|generic
modifier|*
name|ptr
init|=
operator|(
name|generic
operator|*
operator|)
name|calloc
argument_list|(
name|size1
argument_list|,
name|size2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
return|return
name|ptr
return|;
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|generic
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|generic
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|generic
modifier|*
name|ptr
init|=
operator|(
name|generic
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
return|return
name|ptr
return|;
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|generic
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of a string INPUT with size SIZE.  */
end_comment

begin_function
name|char
modifier|*
name|savestring
parameter_list|(
name|input
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|input
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|output
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|input
argument_list|,
name|output
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|output
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decide whether the given symbol is:    a constructor (1), a destructor (2), or neither (0).  */
end_comment

begin_function
specifier|static
name|int
name|is_ctor_dtor
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
struct|struct
name|names
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|two_underscores
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|names
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|orig_s
init|=
name|s
decl_stmt|;
specifier|static
name|struct
name|names
name|special
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|NO_DOLLAR_IN_LABEL
block|{
literal|"GLOBAL_.I."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_.I."
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL_.D."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_.D."
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"GLOBAL_$I$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_$I$"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL_$D$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_$I$"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CFRONT_LOSSAGE
comment|/* Don't collect cfront initialization functions. 			 cfront has its own linker procedure to collect them; 			 if collect2 gets them too, they get collected twice 			 when the cfront procedure is run and the compiler used 			 for linking happens to be GCC.  */
block|{
literal|"sti__"
block|,
sizeof|sizeof
argument_list|(
literal|"sti__"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"std__"
block|,
sizeof|sizeof
argument_list|(
literal|"std__"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|1
block|}
block|,
endif|#
directive|endif
comment|/* CFRONT_LOSSAGE */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|s
operator|)
operator|==
literal|'_'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|orig_s
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
operator|&
name|special
index|[
literal|0
index|]
init|;
name|p
operator|->
name|len
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|p
operator|->
name|two_underscores
operator|||
operator|(
operator|(
name|s
operator|-
name|orig_s
operator|)
operator|>=
literal|2
operator|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
operator|->
name|ret
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a string to use as the base of all temporary file names.    It is substituted for %g.  */
end_comment

begin_function
specifier|static
name|void
name|choose_temp_base
parameter_list|()
block|{
name|char
modifier|*
name|base
init|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|base
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|P_tmpdir
if|if
condition|(
name|access
argument_list|(
name|P_tmpdir
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|==
literal|0
condition|)
name|base
operator|=
name|P_tmpdir
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|base
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
literal|"/usr/tmp"
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|==
literal|0
condition|)
name|base
operator|=
literal|"/usr/tmp/"
expr_stmt|;
else|else
name|base
operator|=
literal|"/tmp/"
expr_stmt|;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|temp_filename
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"/ccXXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|temp_filename
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp_filename
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
operator|+
name|len
argument_list|,
literal|"ccXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|temp_filename_length
operator|=
name|strlen
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main program. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|outfile
init|=
literal|"a.out"
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
name|char
modifier|*
name|ld_file_name
decl_stmt|;
name|char
modifier|*
name|c_file_name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
modifier|*
name|c_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|c_ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld1_argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld1
init|=
name|ld1_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld2_argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
operator|+
literal|5
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld2
init|=
name|ld2_argv
decl_stmt|;
name|int
name|first_file
decl_stmt|;
name|int
name|num_c_args
init|=
name|argc
operator|+
literal|7
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|clen
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|1
expr_stmt|;
name|vflag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|' '
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'m'
condition|)
name|num_c_args
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
name|q
operator|++
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|c_ptr
operator|=
name|c_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|num_c_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"no arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|/* Try to discover a valid linker/assembler/nm/strip to use.  */
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
literal|"ld"
argument_list|)
operator|-
literal|1
condition|)
block|{
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|len
operator|-
sizeof|sizeof
argument_list|(
literal|"ld"
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"ld"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prefix
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prefix
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|p
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|prefix
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STANDARD_EXEC_PREFIX
elseif|else
if|if
condition|(
name|access
argument_list|(
name|STANDARD_EXEC_PREFIX
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|prefix
operator|=
name|STANDARD_EXEC_PREFIX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD_EXEC_PREFIX
elseif|else
if|if
condition|(
name|access
argument_list|(
name|MD_EXEC_PREFIX
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|prefix
operator|=
name|MD_EXEC_PREFIX
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|access
argument_list|(
literal|"/usr/ccs/gcc"
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|prefix
operator|=
literal|"/usr/ccs/gcc/"
expr_stmt|;
elseif|else
if|if
condition|(
name|access
argument_list|(
literal|"/usr/ccs/bin"
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|prefix
operator|=
literal|"/usr/ccs/bin/"
expr_stmt|;
else|else
name|prefix
operator|=
literal|"/bin/"
expr_stmt|;
block|}
name|clen
operator|=
name|len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STANDARD_BIN_PREFIX
if|if
condition|(
name|clen
operator|<
sizeof|sizeof
argument_list|(
name|STANDARD_BIN_PREFIX
argument_list|)
operator|-
literal|1
condition|)
name|clen
operator|=
sizeof|sizeof
argument_list|(
name|STANDARD_BIN_PREFIX
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STANDARD_EXEC_PREFIX
if|if
condition|(
name|clen
operator|<
sizeof|sizeof
argument_list|(
name|STANDARD_EXEC_PREFIX
argument_list|)
operator|-
literal|1
condition|)
name|clen
operator|=
sizeof|sizeof
argument_list|(
name|STANDARD_EXEC_PREFIX
argument_list|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate enough string space for the longest possible pathnames.  */
name|ld_file_name
operator|=
name|xcalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"real-ld"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nm_file_name
operator|=
name|xcalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"gnm"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strip_file_name
operator|=
name|xcalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"gstrip"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Determine the full path name of the ld program to use.  */
name|bcopy
argument_list|(
name|prefix
argument_list|,
name|ld_file_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ld_file_name
operator|+
name|len
argument_list|,
literal|"real-ld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|ld_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|ld_file_name
operator|+
name|len
argument_list|,
literal|"gld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|ld_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|ld_file_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_LD_FILE_NAME
name|ld_file_name
operator|=
name|REAL_LD_FILE_NAME
expr_stmt|;
else|#
directive|else
name|ld_file_name
operator|=
operator|(
name|access
argument_list|(
literal|"/usr/bin/ld"
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|?
literal|"/usr/bin/ld"
else|:
literal|"/bin/ld"
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Determine the full path name of the C compiler to use.  */
name|c_file_name
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC"
argument_list|)
expr_stmt|;
comment|/* If this is absolute, it must be a file that exists.      If it is relative, it must be something that execvp was able to find.      Either way, we can pass it to execvp and find the same executable.  */
if|if
condition|(
name|c_file_name
operator|==
literal|0
condition|)
block|{
name|c_file_name
operator|=
name|xcalloc
argument_list|(
name|clen
operator|+
sizeof|sizeof
argument_list|(
literal|"gcc"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|prefix
argument_list|,
name|c_file_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|c_file_name
operator|+
name|len
argument_list|,
literal|"gcc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|c_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|STANDARD_BIN_PREFIX
name|strcpy
argument_list|(
name|c_file_name
argument_list|,
name|STANDARD_BIN_PREFIX
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|c_file_name
argument_list|,
literal|"gcc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|c_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|STANDARD_EXEC_PREFIX
name|strcpy
argument_list|(
name|c_file_name
argument_list|,
name|STANDARD_EXEC_PREFIX
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|c_file_name
argument_list|,
literal|"gcc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|c_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|strcpy
argument_list|(
name|c_file_name
argument_list|,
literal|"gcc"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Determine the full path name of the nm to use.  */
name|bcopy
argument_list|(
name|prefix
argument_list|,
name|nm_file_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nm_file_name
operator|+
name|len
argument_list|,
literal|"nm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|nm_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|nm_file_name
operator|+
name|len
argument_list|,
literal|"gnm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|nm_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|nm_file_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_NM_FILE_NAME
name|nm_file_name
operator|=
name|REAL_NM_FILE_NAME
expr_stmt|;
else|#
directive|else
name|nm_file_name
operator|=
operator|(
name|access
argument_list|(
literal|"/usr/bin/nm"
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|?
literal|"/usr/bin/nm"
else|:
literal|"/bin/nm"
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Determine the full pathname of the strip to use.  */
name|bcopy
argument_list|(
name|prefix
argument_list|,
name|strip_file_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|strip_file_name
operator|+
name|len
argument_list|,
literal|"strip"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|strip_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|strip_file_name
operator|+
name|len
argument_list|,
literal|"gstrip"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|strip_file_name
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|strip_file_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_STRIP_FILE_NAME
name|strip_file_name
operator|=
name|REAL_STRIP_FILE_NAME
expr_stmt|;
else|#
directive|else
name|strip_file_name
operator|=
operator|(
name|access
argument_list|(
literal|"/usr/bin/strip"
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|?
literal|"/usr/bin/strip"
else|:
literal|"/bin/strip"
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
literal|"ld"
expr_stmt|;
comment|/* Make temp file names. */
name|choose_temp_base
argument_list|()
expr_stmt|;
name|c_file
operator|=
name|xcalloc
argument_list|(
name|temp_filename_length
operator|+
sizeof|sizeof
argument_list|(
literal|".c"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|o_file
operator|=
name|xcalloc
argument_list|(
name|temp_filename_length
operator|+
sizeof|sizeof
argument_list|(
literal|".o"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|c_file
argument_list|,
literal|"%s.c"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|o_file
argument_list|,
literal|"%s.o"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|c_file_name
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-c"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-o"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|o_file
expr_stmt|;
comment|/* !!! When GCC calls collect2,      it does not know whether it is calling collect2 or ld.      So collect2 cannot meaningfully understand any options      except those ld understands.      If you propose to make GCC pass some other option,      just imagine what will happen if ld is really ld!!!  */
comment|/* Parse arguments.  Remember output file spec, pass the rest to ld. */
comment|/* After the first file, put in the c++ rt0.  */
name|first_file
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|arg
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-debug"
argument_list|)
condition|)
block|{
name|debug
operator|=
literal|1
expr_stmt|;
name|vflag
operator|=
literal|1
expr_stmt|;
name|ld1
operator|--
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
name|outfile
operator|=
operator|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|?
name|argv
index|[
literal|1
index|]
else|:
operator|&
name|arg
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|rflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* We must strip after the nm run, otherwise C++ linking 		     won't work.  Thus we strip in the second ld run, or 		     else with strip if there is no second ld run.  */
name|strip_flag
operator|=
literal|1
expr_stmt|;
name|ld1
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|vflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|first_file
operator|&&
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|arg
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".o"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|first_file
operator|=
literal|0
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
block|}
block|}
comment|/* Get any options that the upper GCC wants to pass to the sub-GCC.  */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|' '
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'m'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
operator|*
name|c_ptr
operator|++
operator|=
name|savestring
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
name|q
operator|++
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
operator|*
name|c_ptr
operator|++
operator|=
name|c_file
expr_stmt|;
operator|*
name|c_ptr
operator|=
operator|*
name|ld1
operator|=
operator|*
name|ld2
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2 version %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"prefix              = %s\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld_file_name        = %s\n"
argument_list|,
name|ld_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_file_name         = %s\n"
argument_list|,
name|c_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nm_file_name        = %s\n"
argument_list|,
name|nm_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_file              = %s\n"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"o_file              = %s\n"
argument_list|,
name|o_file
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_GCC_OPTIONS = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_GCC         = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COMPILER_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COMPILER_PATH       = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"LIBRARY_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LIBRARY_PATH        = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Load the program, searching all libraries.      Examine the namelist with nm and search it for static constructors      and destructors to call.      Write the constructor and destructor tables to a .s file and reload. */
name|fork_execute
argument_list|(
name|ld_file_name
argument_list|,
name|ld1_argv
argument_list|)
expr_stmt|;
comment|/* If -r, don't build the constructor or destructor list, just return now.  */
if|if
condition|(
name|rflag
condition|)
return|return
literal|0
return|;
name|scan_prog_file
argument_list|(
name|outfile
argument_list|,
name|PASS_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d constructor(s) found\n"
argument_list|,
name|constructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d destructor(s)  found\n"
argument_list|,
name|destructors
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constructors
operator|.
name|number
operator|==
literal|0
operator|&&
name|destructors
operator|.
name|number
operator|==
literal|0
condition|)
block|{
comment|/* Strip now if it was requested on the command line.  */
if|if
condition|(
name|strip_flag
condition|)
block|{
name|char
modifier|*
modifier|*
name|strip_argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|strip_argv
index|[
literal|0
index|]
operator|=
literal|"strip"
expr_stmt|;
name|strip_argv
index|[
literal|1
index|]
operator|=
name|outfile
expr_stmt|;
name|strip_argv
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|fork_execute
argument_list|(
name|strip_file_name
argument_list|,
name|strip_argv
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|outf
operator|=
name|fopen
argument_list|(
name|c_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"%s"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|write_c_file
argument_list|(
name|outf
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|outf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"closing %s"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== outfile = %s, c_file = %s\n"
argument_list|,
name|outfile
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|write_c_file
argument_list|(
name|stderr
argument_list|,
literal|"stderr"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"========== end of c_file\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Assemble the constructor and destructor tables.      Link the tables in with the rest of the program. */
name|fork_execute
argument_list|(
name|c_file_name
argument_list|,
name|c_argv
argument_list|)
expr_stmt|;
name|fork_execute
argument_list|(
name|ld_file_name
argument_list|,
name|ld2_argv
argument_list|)
expr_stmt|;
comment|/* Let scan_prog_file do any final mods (OSF/rose needs this for      constructors/destructors in shared libraries.  */
name|scan_prog_file
argument_list|(
name|outfile
argument_list|,
name|PASS_SECOND
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for a process to finish, and exit if a non-zero status is found. */
end_comment

begin_function
specifier|static
name|void
name|do_wait
parameter_list|(
name|prog
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|int
name|sig
init|=
name|status
operator|&
literal|0x7F
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|sig
operator|!=
operator|-
literal|1
operator|&&
name|sig
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_SYS_SIGLIST
name|error
argument_list|(
literal|"%s terminated with signal %d %s"
argument_list|,
name|prog
argument_list|,
name|sig
argument_list|,
operator|(
name|status
operator|&
literal|0200
operator|)
condition|?
literal|", core dumped"
else|:
literal|""
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"%s terminated with signal %d [%s]%s"
argument_list|,
name|prog
argument_list|,
name|sig
argument_list|,
name|sys_siglist
index|[
name|sig
index|]
argument_list|,
operator|(
name|status
operator|&
literal|0200
operator|)
condition|?
literal|", core dumped"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|my_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|(
operator|(
name|status
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
operator|&&
name|ret
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s returned %d exit status"
argument_list|,
name|prog
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fork and execute a program, and wait for the reply.  */
end_comment

begin_function
specifier|static
name|void
name|fork_execute
parameter_list|(
name|prog
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
name|vflag
operator|||
name|debug
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|argv
index|[
literal|1
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal_perror
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
comment|/* child context */
block|{
name|execvp
argument_list|(
name|prog
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"executing %s"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
block|}
name|do_wait
argument_list|(
name|prog
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unlink a file unless we are debugging.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_unlink
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|debug
condition|)
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[Leaving %s]\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a name to a linked list.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_list
parameter_list|(
name|head_ptr
parameter_list|,
name|name
parameter_list|)
name|struct
name|head
modifier|*
name|head_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|id
modifier|*
name|newid
init|=
operator|(
expr|struct
name|id
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newid
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|static
name|long
name|sequence_number
init|=
literal|0
decl_stmt|;
name|newid
operator|->
name|sequence
operator|=
operator|++
name|sequence_number
expr_stmt|;
name|strcpy
argument_list|(
name|newid
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_ptr
operator|->
name|first
condition|)
name|head_ptr
operator|->
name|last
operator|->
name|next
operator|=
name|newid
expr_stmt|;
else|else
name|head_ptr
operator|->
name|first
operator|=
name|newid
expr_stmt|;
name|head_ptr
operator|->
name|last
operator|=
name|newid
expr_stmt|;
name|head_ptr
operator|->
name|number
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write: `prefix', the names on list LIST, `suffix'.  */
end_comment

begin_function
specifier|static
name|void
name|write_list
parameter_list|(
name|stream
parameter_list|,
name|prefix
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%sx%d,\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|sequence
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_list_with_asm
parameter_list|(
name|stream
parameter_list|,
name|prefix
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%sx%d asm (\"%s\");\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|sequence
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the constructor/destructor tables. */
end_comment

begin_function
specifier|static
name|void
name|write_c_file
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Write the tables as C code  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"typedef void entry_pt();\n\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nentry_pt * __CTOR_LIST__[] = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t(entry_pt *) %d,\n"
argument_list|,
name|constructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nentry_pt * __DTOR_LIST__[] = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t(entry_pt *) %d,\n"
argument_list|,
name|destructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt __main;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"entry_pt *__main_reference = __main;\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_NONE
end_ifdef

begin_comment
comment|/* Generic version to scan the name list of the loaded program for    the symbols g++ uses for static constructors and destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|void
function_decl|(
modifier|*
name|int_handler
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|quit_handler
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|nm_argv
index|[
literal|4
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|pipe_fd
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
if|if
condition|(
name|which_pass
operator|!=
name|PASS_FIRST
condition|)
return|return;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"nm"
expr_stmt|;
if|if
condition|(
name|NM_FLAGS
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|NM_FLAGS
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|prog_name
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipe_fd
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|inf
operator|=
name|fdopen
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
comment|/* Trace if needed.  */
if|if
condition|(
name|vflag
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|nm_file_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|nm_argv
index|[
literal|1
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Spawn child nm on pipe */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal_perror
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
comment|/* child context */
block|{
comment|/* setup stdout */
if|if
condition|(
name|dup2
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"dup2 (%d, 1)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|nm_file_name
argument_list|,
name|nm_argv
argument_list|)
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"executing %s"
argument_list|,
name|nm_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Parent context from here on.  */
name|int_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|quit_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnm output with constructors/destructors.\n"
argument_list|)
expr_stmt|;
comment|/* Read each line of nm output.  */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|inf
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|int
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* If it contains a constructor or destructor name, add the name 	 to the appropriate list. */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|(
name|ch
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'_'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
operator|||
name|ch
operator|==
literal|'\n'
condition|)
continue|continue;
name|name
operator|=
name|p
expr_stmt|;
comment|/* Find the end of the symbol name. 	 Don't include `|', because Encore nm can tack that on the end.  */
for|for
control|(
name|end
operator|=
name|p
init|;
operator|(
name|ch2
operator|=
operator|*
name|end
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|ch2
argument_list|)
operator|&&
name|ch2
operator|!=
literal|'|'
condition|;
name|end
operator|++
control|)
continue|continue;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|inf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fclose of pipe"
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|nm_file_name
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quit_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_NONE */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * COFF specific stuff.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax + SYMHEADER(X).iextMax)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMR
end_define

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
value|((X).st == stProc&& (X).sc == scText)
end_define

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|(1)
end_define

begin_define
define|#
directive|define
name|GCC_SYMZERO
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax)
end_define

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
value|(PSYMTAB(X) != 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(HEADER(ldptr).f_nsyms)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMENT
end_define

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
define|\
value|(((X).n_sclass == C_EXT)&& \         (((X).n_type& N_TMASK) == (DT_NON<< N_BTSHFT) || \          ((X).n_type& N_TMASK) == (DT_FCN<< N_BTSHFT)))
end_define

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|((X).n_numaux+1)
end_define

begin_define
define|#
directive|define
name|GCC_SYMZERO
parameter_list|(
name|X
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|ldgetname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* COFF version to scan the name list of the loaded program for    the symbols g++ uses for static constructors and destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|LDFILE
modifier|*
name|ldptr
init|=
name|NULL
decl_stmt|;
name|int
name|sym_index
decl_stmt|,
name|sym_count
decl_stmt|;
if|if
condition|(
name|which_pass
operator|!=
name|PASS_FIRST
condition|)
return|return;
if|if
condition|(
operator|(
name|ldptr
operator|=
name|ldopen
argument_list|(
name|prog_name
argument_list|,
name|ldptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: can't open as COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MY_ISCOFF
argument_list|(
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_magic
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: not a COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCC_CHECK_HDR
argument_list|(
name|ldptr
argument_list|)
condition|)
block|{
name|sym_count
operator|=
name|GCC_SYMBOLS
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
name|sym_index
operator|=
name|GCC_SYMZERO
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|sym_index
operator|<
name|sym_count
condition|)
block|{
name|GCC_SYMENT
name|symbol
decl_stmt|;
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|sym_index
argument_list|,
operator|&
name|symbol
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|sym_index
operator|+=
name|GCC_SYMINC
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCC_OK_SYMBOL
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|symbol
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* should never happen */
ifdef|#
directive|ifdef
name|_AIX
comment|/* All AIX function names begin with a dot. */
if|if
condition|(
operator|*
name|name
operator|++
operator|!=
literal|'.'
condition|)
continue|continue;
endif|#
directive|endif
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsec=%d class=%d type=%s%o %s\n"
argument_list|,
name|symbol
operator|.
name|n_scnum
argument_list|,
name|symbol
operator|.
name|n_sclass
argument_list|,
operator|(
name|symbol
operator|.
name|n_type
condition|?
literal|"0"
else|:
literal|""
operator|)
argument_list|,
name|symbol
operator|.
name|n_type
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tiss = %5d, value = %5d, index = %5d, name = %s\n"
argument_list|,
name|symbol
operator|.
name|iss
argument_list|,
name|symbol
operator|.
name|value
argument_list|,
name|symbol
operator|.
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
operator|(
name|void
operator|)
name|ldclose
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_COFF */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * OSF/rose specific stuff.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ROSE
end_ifdef

begin_comment
comment|/* Union of the various load commands */
end_comment

begin_typedef
typedef|typedef
union|union
name|load_union
block|{
name|ldc_header_t
name|hdr
decl_stmt|;
comment|/* common header */
name|load_cmd_map_command_t
name|map
decl_stmt|;
comment|/* map indexing other load cmds */
name|interpreter_command_t
name|iprtr
decl_stmt|;
comment|/* interpreter pathname */
name|strings_command_t
name|str
decl_stmt|;
comment|/* load commands strings section */
name|region_command_t
name|region
decl_stmt|;
comment|/* region load command */
name|reloc_command_t
name|reloc
decl_stmt|;
comment|/* relocation section */
name|package_command_t
name|pkg
decl_stmt|;
comment|/* package load command */
name|symbols_command_t
name|sym
decl_stmt|;
comment|/* symbol sections */
name|entry_command_t
name|ent
decl_stmt|;
comment|/* program start section */
name|gen_info_command_t
name|info
decl_stmt|;
comment|/* object information */
name|func_table_command_t
name|func
decl_stmt|;
comment|/* function constructors/destructors */
block|}
name|load_union_t
typedef|;
end_typedef

begin_comment
comment|/* Structure to point to load command and data section in memory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|load_all
block|{
name|load_union_t
modifier|*
name|load
decl_stmt|;
comment|/* load command */
name|char
modifier|*
name|section
decl_stmt|;
comment|/* pointer to section */
block|}
name|load_all_t
typedef|;
end_typedef

begin_comment
comment|/* Structure to contain information about a file mapped into memory.  */
end_comment

begin_struct
struct|struct
name|file_info
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of map */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* filename */
name|long
name|size
decl_stmt|;
comment|/* size of the file */
name|long
name|rounded_size
decl_stmt|;
comment|/* size rounded to page boundary */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|rw
decl_stmt|;
comment|/* != 0 if opened read/write */
name|int
name|use_mmap
decl_stmt|;
comment|/* != 0 if mmap'ed */
block|}
struct|;
end_struct

begin_function_decl
specifier|extern
name|int
name|decode_mach_o_hdr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|encode_mach_o_hdr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bad_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_load_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_func_table
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_info
modifier|*
name|read_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_file
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* OSF/rose specific version to scan the name list of the loaded    program for the symbols g++ uses for static constructors and    destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|char
modifier|*
name|obj
decl_stmt|;
name|mo_header_t
name|hdr
decl_stmt|;
name|load_all_t
modifier|*
name|load_array
decl_stmt|;
name|load_all_t
modifier|*
name|load_end
decl_stmt|;
name|load_all_t
modifier|*
name|load_cmd
decl_stmt|;
name|int
name|symbol_load_cmds
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_syms
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|str_sect
decl_stmt|;
name|struct
name|file_info
modifier|*
name|obj_file
decl_stmt|;
name|int
name|prog_fd
decl_stmt|;
name|mo_lcid_t
name|cmd_strings
init|=
operator|-
literal|1
decl_stmt|;
name|symbol_info_t
modifier|*
name|main_sym
init|=
literal|0
decl_stmt|;
name|int
name|rw
init|=
operator|(
name|which_pass
operator|!=
name|PASS_FIRST
operator|)
decl_stmt|;
name|prog_fd
operator|=
name|open
argument_list|(
name|prog_name
argument_list|,
operator|(
name|rw
operator|)
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog_fd
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"can't read %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|obj_file
operator|=
name|read_file
argument_list|(
name|prog_name
argument_list|,
name|prog_fd
argument_list|,
name|rw
argument_list|)
expr_stmt|;
name|obj
operator|=
name|obj_file
operator|->
name|start
expr_stmt|;
name|status
operator|=
name|decode_mach_o_hdr
argument_list|(
name|obj
argument_list|,
name|MO_SIZEOF_RAW_HDR
argument_list|,
name|MOH_HEADER_VERSION
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|MO_HDR_CONV_SUCCESS
condition|)
name|bad_header
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* Do some basic sanity checks.  Note we explicitly use the big endian magic number,      since the hardware will automatically swap bytes for us on loading little endian      integers.  */
ifndef|#
directive|ifndef
name|CROSS_COMPILE
if|if
condition|(
name|hdr
operator|.
name|moh_magic
operator|!=
name|MOH_MAGIC_MSB
operator|||
name|hdr
operator|.
name|moh_header_version
operator|!=
name|MOH_HEADER_VERSION
operator|||
name|hdr
operator|.
name|moh_byte_order
operator|!=
name|OUR_BYTE_ORDER
operator|||
name|hdr
operator|.
name|moh_data_rep_id
operator|!=
name|OUR_DATA_REP_ID
operator|||
name|hdr
operator|.
name|moh_cpu_type
operator|!=
name|OUR_CPU_TYPE
operator|||
name|hdr
operator|.
name|moh_cpu_subtype
operator|!=
name|OUR_CPU_SUBTYPE
operator|||
name|hdr
operator|.
name|moh_vendor_type
operator|!=
name|OUR_VENDOR_TYPE
condition|)
block|{
name|fatal
argument_list|(
literal|"incompatibilities between object file& expected values"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
name|print_header
argument_list|(
operator|&
name|hdr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
name|load_end
operator|=
name|load_array
operator|=
operator|(
name|load_all_t
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|load_all_t
argument_list|)
argument_list|,
name|hdr
operator|.
name|moh_n_load_cmds
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Build array of load commands, calculating the offsets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
decl_stmt|;
comment|/* load command header */
name|load_cmd
operator|=
name|load_end
operator|++
expr_stmt|;
name|load_hdr
operator|=
operator|(
name|load_union_t
operator|*
operator|)
operator|(
name|obj
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* If modifying the program file, copy the header.  */
if|if
condition|(
name|rw
condition|)
block|{
name|load_union_t
modifier|*
name|ptr
init|=
operator|(
name|load_union_t
operator|*
operator|)
name|xmalloc
argument_list|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|generic
operator|*
operator|)
name|load_hdr
argument_list|,
operator|(
name|generic
operator|*
operator|)
name|ptr
argument_list|,
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|)
expr_stmt|;
name|load_hdr
operator|=
name|ptr
expr_stmt|;
comment|/* null out old command map, because we will rewrite at the end.  */
if|if
condition|(
name|ptr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_CMD_MAP
condition|)
block|{
name|cmd_strings
operator|=
name|ptr
operator|->
name|map
operator|.
name|lcm_ld_cmd_strings
expr_stmt|;
name|ptr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|=
name|LDC_UNDEFINED
expr_stmt|;
block|}
block|}
name|load_cmd
operator|->
name|load
operator|=
name|load_hdr
expr_stmt|;
if|if
condition|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
operator|>
literal|0
condition|)
name|load_cmd
operator|->
name|section
operator|=
name|obj
operator|+
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_load_command
argument_list|(
name|load_hdr
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
expr_stmt|;
block|}
comment|/* If the last command is the load command map and is not undefined,      decrement the count of load commands.  */
if|if
condition|(
name|rw
operator|&&
name|load_end
index|[
operator|-
literal|1
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_UNDEFINED
condition|)
block|{
name|load_end
operator|--
expr_stmt|;
name|hdr
operator|.
name|moh_n_load_cmds
operator|--
expr_stmt|;
block|}
comment|/* Go through and process each symbol table section.  */
name|symbol_load_cmds
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|load_cmd
operator|=
name|load_array
init|;
name|load_cmd
operator|<
name|load_end
condition|;
name|load_cmd
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
init|=
name|load_cmd
operator|->
name|load
decl_stmt|;
if|if
condition|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_SYMBOLS
condition|)
block|{
name|symbol_load_cmds
operator|++
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|char
modifier|*
name|kind
init|=
literal|"unknown"
decl_stmt|;
switch|switch
condition|(
name|load_hdr
operator|->
name|sym
operator|.
name|symc_kind
condition|)
block|{
case|case
name|SYMC_IMPORTS
case|:
name|kind
operator|=
literal|"imports"
expr_stmt|;
break|break;
case|case
name|SYMC_DEFINED_SYMBOLS
case|:
name|kind
operator|=
literal|"defined"
expr_stmt|;
break|break;
case|case
name|SYMC_STABS
case|:
name|kind
operator|=
literal|"stabs"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nProcessing symbol table #%d, offset = 0x%.8lx, kind = %s\n"
argument_list|,
name|symbol_load_cmds
argument_list|,
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|load_hdr
operator|->
name|sym
operator|.
name|symc_kind
operator|!=
name|SYMC_DEFINED_SYMBOLS
condition|)
continue|continue;
name|str_sect
operator|=
name|load_array
index|[
name|load_hdr
operator|->
name|sym
operator|.
name|symc_strings_section
index|]
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|str_sect
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"string section missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_cmd
operator|->
name|section
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"section pointer missing"
argument_list|)
expr_stmt|;
name|num_syms
operator|=
name|load_hdr
operator|->
name|sym
operator|.
name|symc_nentries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
name|symbol_info_t
modifier|*
name|sym
init|=
operator|(
operator|(
name|symbol_info_t
operator|*
operator|)
name|load_cmd
operator|->
name|section
operator|)
operator|+
name|i
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|sym
operator|->
name|si_name
operator|.
name|symbol_name
operator|+
name|str_sect
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
continue|continue;
if|if
condition|(
name|rw
condition|)
block|{
name|char
modifier|*
name|n
init|=
name|name
decl_stmt|;
while|while
condition|(
operator|*
name|n
operator|==
literal|'_'
condition|)
operator|++
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|n
operator|!=
literal|'m'
operator|||
operator|(
name|n
operator|-
name|name
operator|)
operator|<
literal|2
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"main"
argument_list|)
condition|)
continue|continue;
name|main_sym
operator|=
name|sym
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttype = 0x%.4x, sc = 0x%.2x, flags = 0x%.8x, name = %.30s\n"
argument_list|,
name|sym
operator|->
name|si_type
argument_list|,
name|sym
operator|->
name|si_sc_type
argument_list|,
name|sym
operator|->
name|si_flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|symbol_load_cmds
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"no symbol table found"
argument_list|)
expr_stmt|;
comment|/* Update the program file now, rewrite header and load commands.  At present,      we assume that there is enough space after the last load command to insert      one more.  Since the first section written out is page aligned, and the      number of load commands is small, this is ok for the present.  */
if|if
condition|(
name|rw
condition|)
block|{
name|load_union_t
modifier|*
name|load_map
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|cmd_strings
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"no cmd_strings found"
argument_list|)
expr_stmt|;
comment|/* Add __main to initializer list. 	 If we are building a program instead of a shared library, don't 	 do anything, since in the current version, you cannot do mallocs 	 and such in the constructors.  */
if|if
condition|(
name|main_sym
operator|!=
operator|(
name|symbol_info_t
operator|*
operator|)
literal|0
operator|&&
operator|(
operator|(
name|hdr
operator|.
name|moh_flags
operator|&
name|MOH_EXECABLE_F
operator|)
operator|==
literal|0
operator|)
condition|)
name|add_func_table
argument_list|(
operator|&
name|hdr
argument_list|,
name|load_array
argument_list|,
name|main_sym
argument_list|,
name|FNTC_INITIALIZATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUpdating header and load commands.\n\n"
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|moh_n_load_cmds
operator|++
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|load_cmd_map_command_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|mo_offset_t
argument_list|)
operator|*
operator|(
name|hdr
operator|.
name|moh_n_load_cmds
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Create new load command map.  */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"load command map, %d cmds, new size %ld.\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|.
name|moh_n_load_cmds
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|load_map
operator|=
operator|(
name|load_union_t
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|ldc_header
operator|.
name|ldci_cmd_type
operator|=
name|LDC_CMD_MAP
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|ldc_header
operator|.
name|ldci_cmd_size
operator|=
name|size
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|lcm_ld_cmd_strings
operator|=
name|cmd_strings
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|lcm_nentries
operator|=
name|hdr
operator|.
name|moh_n_load_cmds
expr_stmt|;
name|load_array
index|[
name|hdr
operator|.
name|moh_n_load_cmds
operator|-
literal|1
index|]
operator|.
name|load
operator|=
name|load_map
expr_stmt|;
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_map
operator|->
name|map
operator|.
name|lcm_map
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_CMD_MAP
condition|)
name|hdr
operator|.
name|moh_load_map_cmd_off
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_size
expr_stmt|;
block|}
name|hdr
operator|.
name|moh_sizeofcmds
operator|=
name|offset
operator|-
name|MO_SIZEOF_RAW_HDR
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_header
argument_list|(
operator|&
name|hdr
argument_list|)
expr_stmt|;
comment|/* Write header */
name|status
operator|=
name|encode_mach_o_hdr
argument_list|(
operator|&
name|hdr
argument_list|,
name|obj
argument_list|,
name|MO_SIZEOF_RAW_HDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|MO_HDR_CONV_SUCCESS
condition|)
name|bad_header
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"writing load commands.\n\n"
argument_list|)
expr_stmt|;
comment|/* Write load commands */
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
init|=
name|load_array
index|[
name|i
index|]
operator|.
name|load
decl_stmt|;
name|size_t
name|size
init|=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_load_command
argument_list|(
name|load_hdr
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|generic
operator|*
operator|)
name|load_hdr
argument_list|,
operator|(
name|generic
operator|*
operator|)
operator|(
name|obj
operator|+
name|offset
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
block|}
block|}
name|end_file
argument_list|(
name|obj_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|prog_fd
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"closing %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a function table to the load commands to call a function    on initiation or termination of the process.  */
end_comment

begin_function
specifier|static
name|void
name|add_func_table
parameter_list|(
name|hdr_p
parameter_list|,
name|load_array
parameter_list|,
name|sym
parameter_list|,
name|type
parameter_list|)
name|mo_header_t
modifier|*
name|hdr_p
decl_stmt|;
comment|/* pointer to global header */
name|load_all_t
modifier|*
name|load_array
decl_stmt|;
comment|/* array of ptrs to load cmds */
name|symbol_info_t
modifier|*
name|sym
decl_stmt|;
comment|/* pointer to symbol entry */
name|int
name|type
decl_stmt|;
comment|/* fntc_type value */
block|{
comment|/* Add a new load command.  */
name|int
name|num_cmds
init|=
operator|++
name|hdr_p
operator|->
name|moh_n_load_cmds
decl_stmt|;
name|int
name|load_index
init|=
name|num_cmds
operator|-
literal|1
decl_stmt|;
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|func_table_command_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|mo_addr_t
argument_list|)
decl_stmt|;
name|load_union_t
modifier|*
name|ptr
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|load_all_t
modifier|*
name|load_cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Set the unresolved address bit in the header to force the loader to be      used, since kernel exec does not call the initialization functions.  */
name|hdr_p
operator|->
name|moh_flags
operator||=
name|MOH_UNRESOLVED_F
expr_stmt|;
name|load_cmd
operator|=
operator|&
name|load_array
index|[
name|load_index
index|]
expr_stmt|;
name|load_cmd
operator|->
name|load
operator|=
name|ptr
expr_stmt|;
name|load_cmd
operator|->
name|section
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Fill in func table load command.  */
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_cmd_type
operator|=
name|LDC_FUNC_TABLE
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_cmd_size
operator|=
name|size
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_section_off
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_section_len
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_type
operator|=
name|type
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_nentries
operator|=
literal|1
expr_stmt|;
comment|/* copy address, turn it from abs. address to (region,offset) if necessary.  */
comment|/* Is the symbol already expressed as (region, offset)?  */
if|if
condition|(
operator|(
name|sym
operator|->
name|si_flags
operator|&
name|SI_ABSOLUTE_VALUE_F
operator|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_lcid
operator|=
name|sym
operator|->
name|si_value
operator|.
name|def_val
operator|.
name|adr_lcid
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
operator|=
name|sym
operator|->
name|si_value
operator|.
name|def_val
operator|.
name|adr_sctoff
expr_stmt|;
block|}
comment|/* If not, figure out which region it's in.  */
else|else
block|{
name|mo_vm_addr_t
name|addr
init|=
name|sym
operator|->
name|si_value
operator|.
name|abs_val
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|load_index
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_REGION
condition|)
block|{
name|region_command_t
modifier|*
name|region_ptr
init|=
operator|&
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|region
decl_stmt|;
if|if
condition|(
operator|(
name|region_ptr
operator|->
name|regc_flags
operator|&
name|REG_ABS_ADDR_F
operator|)
operator|!=
literal|0
operator|&&
name|addr
operator|>=
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
operator|&&
name|addr
operator|<=
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
operator|+
name|region_ptr
operator|->
name|regc_vm_size
condition|)
block|{
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
literal|0
index|]
operator|.
name|adr_lcid
operator|=
name|i
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
literal|0
index|]
operator|.
name|adr_sctoff
operator|=
name|addr
operator|-
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
expr_stmt|;
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fatal
argument_list|(
literal|"could not convert 0x%l.8x into a region"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s function, region %d, offset = %ld (0x%.8lx)\n"
argument_list|,
operator|(
name|type
operator|==
name|FNTC_INITIALIZATION
operator|)
condition|?
literal|"init"
else|:
literal|"term"
argument_list|,
operator|(
name|int
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_lcid
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the global header for an OSF/rose object.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|hdr_ptr
parameter_list|)
name|mo_header_t
modifier|*
name|hdr_ptr
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nglobal header:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_magic            = 0x%.8lx\n"
argument_list|,
name|hdr_ptr
operator|->
name|moh_magic
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_major_version    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_major_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_minor_version    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_minor_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_header_version   = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_header_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_max_page_size    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_max_page_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_byte_order       = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_byte_order
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_data_rep_id      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_data_rep_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_cpu_type         = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_cpu_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_cpu_subtype      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_cpu_subtype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_vendor_type      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_vendor_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_load_map_cmd_off = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_load_map_cmd_off
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_first_cmd_off    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_first_cmd_off
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_sizeofcmds       = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_sizeofcmds
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmon_n_load_cmds      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_n_load_cmds
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_flags            = 0x%.8lx"
argument_list|,
operator|(
name|long
operator|)
name|hdr_ptr
operator|->
name|moh_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_RELOCATABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", relocatable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_LINKABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", linkable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_EXECABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", execable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_EXECUTABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", executable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_UNRESOLVED_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", unresolved"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a short summary of a load command.  */
end_comment

begin_function
specifier|static
name|void
name|print_load_command
parameter_list|(
name|load_hdr
parameter_list|,
name|offset
parameter_list|,
name|number
parameter_list|)
name|load_union_t
modifier|*
name|load_hdr
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
name|mo_long_t
name|type
init|=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
decl_stmt|;
name|char
modifier|*
name|type_str
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LDC_UNDEFINED
case|:
name|type_str
operator|=
literal|"UNDEFINED"
expr_stmt|;
break|break;
case|case
name|LDC_CMD_MAP
case|:
name|type_str
operator|=
literal|"CMD_MAP"
expr_stmt|;
break|break;
case|case
name|LDC_INTERPRETER
case|:
name|type_str
operator|=
literal|"INTERPRETER"
expr_stmt|;
break|break;
case|case
name|LDC_STRINGS
case|:
name|type_str
operator|=
literal|"STRINGS"
expr_stmt|;
break|break;
case|case
name|LDC_REGION
case|:
name|type_str
operator|=
literal|"REGION"
expr_stmt|;
break|break;
case|case
name|LDC_RELOC
case|:
name|type_str
operator|=
literal|"RELOC"
expr_stmt|;
break|break;
case|case
name|LDC_PACKAGE
case|:
name|type_str
operator|=
literal|"PACKAGE"
expr_stmt|;
break|break;
case|case
name|LDC_SYMBOLS
case|:
name|type_str
operator|=
literal|"SYMBOLS"
expr_stmt|;
break|break;
case|case
name|LDC_ENTRY
case|:
name|type_str
operator|=
literal|"ENTRY"
expr_stmt|;
break|break;
case|case
name|LDC_FUNC_TABLE
case|:
name|type_str
operator|=
literal|"FUNC_TABLE"
expr_stmt|;
break|break;
case|case
name|LDC_GEN_INFO
case|:
name|type_str
operator|=
literal|"GEN_INFO"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cmd %2d, sz: 0x%.2lx, coff: 0x%.3lx, doff: 0x%.6lx, dlen: 0x%.6lx"
argument_list|,
name|number
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_str
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: unknown (%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|LDC_REGION
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: %s\n"
argument_list|,
name|type_str
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|region
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|load_hdr
operator|->
name|region
operator|.
name|regc_usage_type
condition|)
block|{
case|case
name|REG_TEXT_T
case|:
name|region
operator|=
literal|", .text"
expr_stmt|;
break|break;
case|case
name|REG_DATA_T
case|:
name|region
operator|=
literal|", .data"
expr_stmt|;
break|break;
case|case
name|REG_BSS_T
case|:
name|region
operator|=
literal|", .bss"
expr_stmt|;
break|break;
case|case
name|REG_GLUE_T
case|:
name|region
operator|=
literal|", .glue"
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|REG_RDATA_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_SDATA_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_SBSS_T
argument_list|)
comment|/*mips*/
case|case
name|REG_RDATA_T
case|:
name|region
operator|=
literal|", .rdata"
expr_stmt|;
break|break;
case|case
name|REG_SDATA_T
case|:
name|region
operator|=
literal|", .sdata"
expr_stmt|;
break|break;
case|case
name|REG_SBSS_T
case|:
name|region
operator|=
literal|", .sbss"
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: %s, vaddr: 0x%.8lx, vlen: 0x%.6lx%s\n"
argument_list|,
name|type_str
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|region
operator|.
name|regc_vm_addr
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|region
operator|.
name|regc_vm_size
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fatal error when {en,de}code_mach_o_header fails.  */
end_comment

begin_function
specifier|static
name|void
name|bad_header
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|char
modifier|*
name|msg
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|MO_ERROR_BAD_MAGIC
case|:
name|msg
operator|=
literal|"bad magic number"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_BAD_HDR_VERS
case|:
name|msg
operator|=
literal|"bad header version"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_BAD_RAW_HDR_VERS
case|:
name|msg
operator|=
literal|"bad raw header version"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_BUF2SML
case|:
name|msg
operator|=
literal|"raw header buffer too small"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_OLD_RAW_HDR_FILE
case|:
name|msg
operator|=
literal|"old raw header file"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_UNSUPPORTED_VERS
case|:
name|msg
operator|=
literal|"unsupported version"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"unknown {de,en}code_mach_o_hdr return value %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a file into a memory buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|file_info
modifier|*
name|read_file
parameter_list|(
name|name
parameter_list|,
name|fd
parameter_list|,
name|rw
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* filename */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|rw
decl_stmt|;
comment|/* read/write */
block|{
name|struct
name|stat
name|stat_pkt
decl_stmt|;
name|struct
name|file_info
modifier|*
name|p
init|=
operator|(
expr|struct
name|file_info
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_info
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
specifier|static
name|int
name|page_size
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stat_pkt
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fstat %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|stat_pkt
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|rounded_size
operator|=
name|stat_pkt
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|p
operator|->
name|rw
operator|=
name|rw
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mmap %s, %s\n"
argument_list|,
name|name
argument_list|,
operator|(
name|rw
operator|)
condition|?
literal|"read/write"
else|:
literal|"read-only"
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_size
operator|==
literal|0
condition|)
name|page_size
operator|=
name|sysconf
argument_list|(
name|_SC_PAGE_SIZE
argument_list|)
expr_stmt|;
name|p
operator|->
name|rounded_size
operator|=
operator|(
operator|(
name|p
operator|->
name|size
operator|+
name|page_size
operator|-
literal|1
operator|)
operator|/
name|page_size
operator|)
operator|*
name|page_size
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|rw
operator|)
condition|?
name|p
operator|->
name|rounded_size
else|:
name|p
operator|->
name|size
argument_list|,
operator|(
name|rw
operator|)
condition|?
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator|)
else|:
name|PROT_READ
argument_list|,
name|MAP_FILE
operator||
name|MAP_VARIABLE
operator||
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|start
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|p
operator|->
name|start
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|p
operator|->
name|use_mmap
operator|=
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* USE_MMAP */
block|{
name|long
name|len
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"read %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|use_mmap
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|xmalloc
argument_list|(
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"lseek to 0 on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
operator|->
name|start
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"read %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|p
operator|->
name|size
condition|)
name|fatal
argument_list|(
literal|"read %ld bytes, expected %ld, from %s"
argument_list|,
name|len
argument_list|,
name|p
operator|->
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do anything necessary to write a file back from memory.  */
end_comment

begin_function
specifier|static
name|void
name|end_file
parameter_list|(
name|ptr
parameter_list|)
name|struct
name|file_info
modifier|*
name|ptr
decl_stmt|;
comment|/* file information block */
block|{
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|ptr
operator|->
name|use_mmap
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rw
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"msync %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|msync
argument_list|(
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|rounded_size
argument_list|,
name|MS_ASYNC
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"msync %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"munmap %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|munmap
argument_list|(
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|size
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"munmap %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USE_MMAP */
block|{
if|if
condition|(
name|ptr
operator|->
name|rw
condition|)
block|{
name|long
name|len
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"write %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|ptr
operator|->
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"lseek to 0 on %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|ptr
operator|->
name|fd
argument_list|,
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"read %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|ptr
operator|->
name|size
condition|)
name|fatal
argument_list|(
literal|"wrote %ld bytes, expected %ld, to %s"
argument_list|,
name|len
argument_list|,
name|ptr
operator|->
name|size
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|generic
operator|*
operator|)
name|ptr
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|generic
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ROSE */
end_comment

end_unit

