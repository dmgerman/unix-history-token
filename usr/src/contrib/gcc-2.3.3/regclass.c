begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compute register class preferences for pseudo-registers.    Copyright (C) 1987, 1988, 1991, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains two passes of the compiler: reg_scan and reg_class.    It also defines some tables of information about the hardware registers    and a function init_reg_sets to initialize the tables.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_MOVE_COST
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_MOVE_COST
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MEMORY_MOVE_COST
end_ifndef

begin_define
define|#
directive|define
name|MEMORY_MOVE_COST
parameter_list|(
name|x
parameter_list|)
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we have auto-increment or auto-decrement and we can have secondary    reloads, we are not allowed to use classes requiring secondary    reloads for psuedos auto-incremented since reload can't handle it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|)
operator|||
name|defined
argument_list|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|)
end_if

begin_define
define|#
directive|define
name|FORBIDDEN_INC_DEC_CLASSES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Register tables used by many passes.  */
end_comment

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are fixed use (stack pointer, pc, frame pointer, etc.).    These are the registers that cannot be used to allocate    a pseudo reg whose life does not cross calls.  */
end_comment

begin_decl_stmt
name|char
name|fixed_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|fixed_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data for initializing the above.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|initial_fixed_regs
index|[]
init|=
name|FIXED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are fixed use or are clobbered by function calls.    These are the registers that cannot be used to allocate    a pseudo reg whose life crosses calls.  */
end_comment

begin_decl_stmt
name|char
name|call_used_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|call_used_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data for initializing the above.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|initial_call_used_regs
index|[]
init|=
name|CALL_USED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers that are    fixed use -- i.e. in fixed_regs -- or a function value return register    or STRUCT_VALUE_REGNUM or STATIC_CHAIN_REGNUM.  These are the    registers that cannot hold quantities across calls even if we are    willing to save and restore them.  */
end_comment

begin_decl_stmt
name|char
name|call_fixed_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|call_fixed_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of non-fixed registers.  */
end_comment

begin_decl_stmt
name|int
name|n_non_fixed_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are being used for global register decls.    These must be exempt from ordinary flow analysis    and are also considered fixed.  */
end_comment

begin_decl_stmt
name|char
name|global_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of register numbers in the order in which to try to use them.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
end_ifdef

begin_decl_stmt
name|int
name|reg_alloc_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
name|REG_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For each reg class, a HARD_REG_SET saying which registers are in it.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|reg_class_contents
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same information, but as an array of ints.  We copy from these    ints to the table above.  This is done so that the tm.h files do    not have to be aware of the wordsize for machines with<= 64 regs.  */
end_comment

begin_define
define|#
directive|define
name|N_REG_INTS
define|\
value|((FIRST_PSEUDO_REGISTER + (HOST_BITS_PER_INT - 1)) / HOST_BITS_PER_INT)
end_define

begin_decl_stmt
specifier|static
name|int
name|int_reg_class_contents
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_INTS
index|]
init|=
name|REG_CLASS_CONTENTS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, number of regs it contains.  */
end_comment

begin_decl_stmt
name|int
name|reg_class_size
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, table listing all the containing classes.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_superclasses
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, table listing all the classes contained in it.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_subclasses
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each pair of reg classes,    a largest reg class contained in their union.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_subunion
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each pair of reg classes,    the smallest reg class containing their union.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_superunion
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array containing all of the register names */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reg_names
index|[]
init|=
name|REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, gives number of times (REG n) is set or clobbered.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.     This information applies to both hard registers and pseudo registers,    unlike much of the information above.  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|reg_n_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum cost of moving from a register in one class to a register in    another class.  Based on REGISTER_MOVE_COST.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|move_cost
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but here we don't have to move if the first index is a subset    of the second so in that case the cost is zero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|may_move_cost
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
end_ifdef

begin_comment
comment|/* These are the classes that regs which are auto-incremented or decremented    cannot be put in.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forbidden_inc_dec_class
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, is non-zero if (REG n) is used in an auto-inc or auto-dec    context.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|in_inc_dec
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FORBIDDEN_INC_DEC_CLASSES */
end_comment

begin_comment
comment|/* Function called only once to initialize the above data on reg usage.    Once this is done, various switches may override.  */
end_comment

begin_function
name|void
name|init_reg_sets
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* First copy the register information from the initial int form into      the regsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|int_reg_class_contents
index|[
name|i
index|]
index|[
name|j
operator|/
name|HOST_BITS_PER_INT
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|HOST_BITS_PER_INT
operator|)
operator|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|initial_fixed_regs
argument_list|,
name|fixed_regs
argument_list|,
sizeof|sizeof
name|fixed_regs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|initial_call_used_regs
argument_list|,
name|call_used_regs
argument_list|,
sizeof|sizeof
name|call_used_regs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|global_regs
argument_list|,
sizeof|sizeof
name|global_regs
argument_list|)
expr_stmt|;
comment|/* Compute number of hard regs in each class.  */
name|bzero
argument_list|(
name|reg_class_size
argument_list|,
sizeof|sizeof
name|reg_class_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|reg_class_size
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* Initialize the table of subunions.      reg_class_subunion[I][J] gets the largest-numbered reg-class      that is contained in the union of classes I and J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|c
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|N_REG_CLASSES
condition|;
name|k
operator|++
control|)
block|{
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|c
argument_list|,
name|subclass1
argument_list|)
expr_stmt|;
continue|continue;
name|subclass1
label|:
comment|/* keep the largest subclass */
comment|/* SPEE 900308 */
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|i
index|]
index|[
name|j
index|]
index|]
argument_list|,
name|subclass2
argument_list|)
expr_stmt|;
name|reg_class_subunion
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|k
expr_stmt|;
name|subclass2
label|:
empty_stmt|;
block|}
block|}
block|}
comment|/* Initialize the table of superunions.      reg_class_superunion[I][J] gets the smallest-numbered reg-class      containing the union of classes I and J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|c
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|N_REG_CLASSES
condition|;
name|k
operator|++
control|)
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|superclass
argument_list|)
expr_stmt|;
name|superclass
label|:
name|reg_class_superunion
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|k
expr_stmt|;
block|}
block|}
comment|/* Initialize the tables of subclasses and superclasses of each reg class.      First clear the whole table, then add the elements as they are found.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|reg_class_superclasses
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LIM_REG_CLASSES
expr_stmt|;
name|reg_class_subclasses
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LIM_REG_CLASSES
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|NO_REGS
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|,
name|subclass
argument_list|)
expr_stmt|;
continue|continue;
name|subclass
label|:
comment|/* Reg class I is a subclass of J. 	     Add J to the table of superclasses of I.  */
name|p
operator|=
operator|&
name|reg_class_superclasses
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|j
expr_stmt|;
comment|/* Add I to the table of superclasses of J.  */
name|p
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|i
expr_stmt|;
block|}
block|}
comment|/* Initialize the move cost table.  Find every subset of each class      and take the maximum cost of moving any subset to any other.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|int
name|cost
init|=
name|i
operator|==
name|j
condition|?
literal|2
else|:
name|REGISTER_MOVE_COST
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|enum
name|reg_class
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
for|for
control|(
name|p2
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
init|;
operator|*
name|p2
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p2
operator|++
control|)
if|if
condition|(
operator|*
name|p2
operator|!=
name|i
condition|)
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|REGISTER_MOVE_COST
argument_list|(
name|i
argument_list|,
operator|*
name|p2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
operator|&
name|reg_class_subclasses
index|[
name|i
index|]
index|[
literal|0
index|]
init|;
operator|*
name|p1
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
name|j
condition|)
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|REGISTER_MOVE_COST
argument_list|(
operator|*
name|p1
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p2
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
init|;
operator|*
name|p2
operator|!=
name|LIM_REG_CLASSES
condition|;
name|p2
operator|++
control|)
if|if
condition|(
operator|*
name|p1
operator|!=
operator|*
name|p2
condition|)
name|cost
operator|=
name|MAX
argument_list|(
name|cost
argument_list|,
name|REGISTER_MOVE_COST
argument_list|(
operator|*
name|p1
argument_list|,
operator|*
name|p2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|move_cost
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cost
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
name|may_move_cost
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|cost
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* After switches have been processed, which perhaps alter    `fixed_regs' and `call_used_regs', convert them to HARD_REG_SETs.  */
end_comment

begin_function
name|void
name|init_reg_sets_1
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* This macro allows the fixed or call-used registers      to depend on target flags.  */
ifdef|#
directive|ifdef
name|CONDITIONAL_REGISTER_USAGE
name|CONDITIONAL_REGISTER_USAGE
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|warning
argument_list|(
literal|"call-clobbered register used for global register variable"
argument_list|)
expr_stmt|;
name|fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Prevent saving/restoring of this reg.  */
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Initialize "constant" tables.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|fixed_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fixed_regs
argument_list|,
name|call_fixed_regs
argument_list|,
sizeof|sizeof
name|call_fixed_regs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCT_VALUE_REGNUM
name|call_fixed_regs
index|[
name|STRUCT_VALUE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
name|call_fixed_regs
index|[
name|STATIC_CHAIN_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|n_non_fixed_regs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|i
argument_list|)
condition|)
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|n_non_fixed_regs
operator|++
expr_stmt|;
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_fixed_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Specify the usage characteristics of the register named NAME.    It should be a fixed register if FIXED and a    call-used register if CALL_USED.  */
end_comment

begin_function
name|void
name|fix_register
parameter_list|(
name|name
parameter_list|,
name|fixed
parameter_list|,
name|call_used
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fixed
decl_stmt|,
name|call_used
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Decode the name and update the primary form of      the register info.  */
if|if
condition|(
operator|(
name|i
operator|=
name|decode_reg_name
argument_list|(
name|name
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|fixed_regs
index|[
name|i
index|]
operator|=
name|fixed
expr_stmt|;
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_used
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"unknown register name: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Now the data and code for the `regclass' pass, which happens    just before local-alloc.  */
end_comment

begin_comment
comment|/* The `costs' struct records the cost of using a hard register of each class    and of using memory for each pseudo.  We use this data to set up    register class preferences.  */
end_comment

begin_struct
struct|struct
name|costs
block|{
name|int
name|cost
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|mem_cost
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record the cost of each class for each pseudo.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|costs
modifier|*
name|costs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the same data by operand number, accumulated for each alternative    in an insn.  The contribution to a pseudo is that of the minimum-cost    alternative.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|costs
name|op_costs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (enum reg_class) prefclass[R] is the preferred class for pseudo number R.    This is available after `regclass' is run.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prefclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* altclass[R] is a register class that we should use for allocating    pseudo number R if no register in the preferred class is available.    If no register in this class is available, memory is preferred.     It might appear to be more general to have a bitmask of classes here,    but since it is recommended that there be a class corresponding to the    union of most major pair of classes, that generality is not required.      This is available after `regclass' is run.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|altclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the depth of loops that we are in.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Account for the fact that insns within a loop are executed very commonly,    but don't keep doing this as loops go too deep.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_cost
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|copy_cost
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_reg_classes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_address_regs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return the reg_class in which pseudo reg number REGNO is best allocated.    This function is sometimes called before the info has been computed.    When that happens, just return GENERAL_REGS, which is innocuous.  */
end_comment

begin_function
name|enum
name|reg_class
name|reg_preferred_class
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|prefclass
operator|==
literal|0
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
operator|(
expr|enum
name|reg_class
operator|)
name|prefclass
index|[
name|regno
index|]
return|;
block|}
end_function

begin_function
name|enum
name|reg_class
name|reg_alternate_class
parameter_list|(
name|regno
parameter_list|)
block|{
if|if
condition|(
name|prefclass
operator|==
literal|0
condition|)
return|return
name|ALL_REGS
return|;
return|return
operator|(
expr|enum
name|reg_class
operator|)
name|altclass
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* This prevents dump_flow_info from losing if called    before regclass is run.  */
end_comment

begin_function
name|void
name|regclass_init
parameter_list|()
block|{
name|prefclass
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is a pass of the compiler that scans all instructions    and calculates the preferred class for each pseudo-register.    This information can be accessed later by calling `reg_preferred_class'.    This pass comes just before local register allocation.  */
end_comment

begin_function
name|void
name|regclass
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|costs
name|init_cost
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|costs
operator|=
operator|(
expr|struct
name|costs
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|costs
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
name|in_inc_dec
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
comment|/* Initialize information about which register classes can be used for      pseudos that are auto-incremented or auto-decremented.  It would      seem better to put this in init_reg_sets, but we need to be able      to allocate rtx, which we can't do that early.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|r
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|m
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|REGNO
argument_list|(
name|r
argument_list|)
operator|=
name|j
expr_stmt|;
for|for
control|(
name|m
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|m
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|m
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|m
operator|)
operator|+
literal|1
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|BASE_REG_CLASS
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|BASE_REG_CLASS
argument_list|,
name|m
argument_list|,
name|r
argument_list|)
operator|!=
name|NO_REGS
operator|)
endif|#
directive|endif
condition|)
name|forbidden_inc_dec_class
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* FORBIDDEN_INC_DEC_CLASSES */
name|init_cost
operator|.
name|mem_cost
operator|=
literal|10000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|init_cost
operator|.
name|cost
index|[
name|i
index|]
operator|=
literal|10000
expr_stmt|;
comment|/* Normally we scan the insns once and determine the best class to use for      each register.  However, if -fexpensive_optimizations are on, we do so      twice, the second time using the tentative best classes to guide the      selection.  */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
name|flag_expensive_optimizations
condition|;
name|pass
operator|++
control|)
block|{
comment|/* Zero out our accumulation of the cost of each class for each reg.  */
name|bzero
argument_list|(
name|costs
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|costs
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
name|bzero
argument_list|(
name|in_inc_dec
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|loop_depth
operator|=
literal|0
operator|,
name|loop_cost
operator|=
literal|1
expr_stmt|;
comment|/* Scan the instructions and record each time it would 	 save code to put a certain register in a certain class.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|modes
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|nalternatives
decl_stmt|;
name|int
name|noperands
decl_stmt|;
comment|/* Show that an insn inside a loop is likely to be executed three 	     times more than insns outside a loop.  This is much more agressive 	     than the assumptions made elsewhere and is being tried as an 	     experiment.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
operator|,
name|loop_cost
operator|=
literal|1
operator|<<
operator|(
literal|2
operator|*
name|MIN
argument_list|(
name|loop_depth
argument_list|,
literal|5
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
operator|,
name|loop_cost
operator|=
literal|1
operator|<<
operator|(
literal|2
operator|*
name|MIN
argument_list|(
name|loop_depth
argument_list|,
literal|5
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|decode_asm_operands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|recog_operand
argument_list|,
name|NULL_PTR
argument_list|,
name|constraints
argument_list|,
name|modes
argument_list|)
expr_stmt|;
name|nalternatives
operator|=
operator|(
name|noperands
operator|==
literal|0
condition|?
literal|0
else|:
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|constraints
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|insn_code_number
init|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|nalternatives
operator|=
name|insn_n_alternatives
index|[
name|insn_code_number
index|]
expr_stmt|;
name|noperands
operator|=
name|insn_n_operands
index|[
name|insn_code_number
index|]
expr_stmt|;
comment|/* If this insn loads a parameter from its stack slot, then 		     it represents a savings, rather than a cost, if the 		     parameter is stored in memory.  Record this fact.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|costs
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
index|]
operator|.
name|mem_cost
operator|-=
operator|(
name|MEMORY_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|*
name|loop_cost
operator|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|loop_cost
operator|*
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Improve handling of two-address insns such as 		     (set X (ashift CONST Y)) where CONST must be made to 		     match X. Change it into two insns: (set X CONST) 		     (set X (ashift X Y)).  If we left this for reloading, it 		     would probably get three insns because X and Y might go 		     in the same place. This prevents X and Y from receiving 		     the same hard reg.  		     We can only do this if the modes of operands 0 and 1 		     (which might not be the same) are tieable and we only need 		     do this during our first pass.  */
if|if
condition|(
name|pass
operator|==
literal|0
operator|&&
name|optimize
operator|&&
name|noperands
operator|>=
literal|3
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|recog_operand
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|recog_operand
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|recog_operand
index|[
literal|2
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|insn_operand_mode
index|[
name|insn_code_number
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|previnsn
init|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|gen_lowpart
argument_list|(
name|insn_operand_mode
index|[
name|insn_code_number
index|]
index|[
literal|1
index|]
argument_list|,
name|recog_operand
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|newinsn
init|=
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|dest
argument_list|,
name|recog_operand
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* If this insn was the start of a basic block, 			 include the new insn in that block. 			 We need not check for code_label here; 			 while a basic block can start with a code_label, 			 INSN could not be at the beginning of that block.  */
if|if
condition|(
name|previnsn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|previnsn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
if|if
condition|(
name|insn
operator|==
name|basic_block_head
index|[
name|b
index|]
condition|)
name|basic_block_head
index|[
name|b
index|]
operator|=
name|newinsn
expr_stmt|;
block|}
comment|/* This makes one more setting of new insns's dest. */
name|reg_n_sets
index|[
name|REGNO
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|)
index|]
operator|++
expr_stmt|;
operator|*
name|recog_operand_loc
index|[
literal|1
index|]
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|insn_n_dups
index|[
name|insn_code_number
index|]
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|recog_dup_num
index|[
name|i
index|]
operator|==
literal|1
condition|)
operator|*
name|recog_dup_loc
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|newinsn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is setting a pseudo from another pseudo or the 		     sum of a pseudo and a constant integer and the other 		     pseudo is known to be a pointer, set the destination to 		     be a pointer as well.  		     Likewise if it is setting the destination from an address 		     or from a value equivalent to an address or to the sum of 		     an address and something else. 		      		     But don't do any of this if the pseudo corresponds to 		     a user variable since it should have already been set 		     as a pointer based on the type.  		     There is no point in doing this during our second 		     pass since not enough should have changed.  */
if|if
condition|(
name|pass
operator|==
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|REG_USERVAR_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
operator|!
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|LO_SUM
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|HIGH
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|LO_SUM
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|)
condition|)
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|constraints
index|[
name|i
index|]
operator|=
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
expr_stmt|;
name|modes
index|[
name|i
index|]
operator|=
name|insn_operand_mode
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* If we get here, we are set up to record the costs of all the 		 operands for this insn.  Start by initializing the costs. 		 Then handle any address registers.  Finally record the desired 		 classes for any pseudos, doing it twice if some pair of 		 operands are commutative.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|op_costs
index|[
name|i
index|]
operator|=
name|init_cost
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|SUBREG_REG
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|loop_cost
operator|*
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
name|record_address_regs
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|loop_cost
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for commutative in a separate loop so everything will 		 have been initialized.  Don't bother doing anything if the 		 second operand is a constant since that is the case 		 for which the constraints should have been written.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|recog_operand
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|xconstraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Handle commutative operands by swapping the constraints. 		       We assume the modes are the same.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|noperands
condition|;
name|j
operator|++
control|)
name|xconstraints
index|[
name|j
index|]
operator|=
name|constraints
index|[
name|j
index|]
expr_stmt|;
name|xconstraints
index|[
name|i
index|]
operator|=
name|constraints
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|xconstraints
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
name|record_reg_classes
argument_list|(
name|nalternatives
argument_list|,
name|noperands
argument_list|,
name|recog_operand
argument_list|,
name|modes
argument_list|,
name|xconstraints
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|record_reg_classes
argument_list|(
name|nalternatives
argument_list|,
name|noperands
argument_list|,
name|recog_operand
argument_list|,
name|modes
argument_list|,
name|constraints
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Now add the cost for each operand to the total costs for 		 its register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|struct
name|costs
modifier|*
name|p
init|=
operator|&
name|costs
index|[
name|regno
index|]
decl_stmt|,
modifier|*
name|q
init|=
operator|&
name|op_costs
index|[
name|i
index|]
decl_stmt|;
name|p
operator|->
name|mem_cost
operator|+=
name|q
operator|->
name|mem_cost
operator|*
name|loop_cost
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
name|p
operator|->
name|cost
index|[
name|j
index|]
operator|+=
name|q
operator|->
name|cost
index|[
name|j
index|]
operator|*
name|loop_cost
expr_stmt|;
block|}
block|}
block|}
comment|/* Now for each register look at how desirable each class is 	 and find which class is preferred.  Store that in 	 `prefclass[REGNO]'.  Record in `altclass[REGNO]' the largest register 	 class any of whose registers is better than memory.  */
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|prefclass
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
name|altclass
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|best_cost
init|=
operator|(
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_INT
operator|-
literal|2
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|enum
name|reg_class
name|best
init|=
name|ALL_REGS
decl_stmt|,
name|alt
init|=
name|NO_REGS
decl_stmt|;
comment|/* This is an enum reg_class, but we call it an int 	     to save lots of casts.  */
specifier|register
name|int
name|class
decl_stmt|;
specifier|register
name|struct
name|costs
modifier|*
name|p
init|=
operator|&
name|costs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|class
operator|=
operator|(
name|int
operator|)
name|ALL_REGS
operator|-
literal|1
init|;
name|class
operator|>
literal|0
condition|;
name|class
operator|--
control|)
block|{
comment|/* Ignore classes that are too small for this operand or 		 invalid for a operand that was auto-incremented.  */
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
name|reg_class_size
index|[
name|class
index|]
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
operator|||
operator|(
name|in_inc_dec
index|[
name|i
index|]
operator|&&
name|forbidden_inc_dec_class
index|[
name|class
index|]
operator|)
endif|#
directive|endif
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|<
name|best_cost
condition|)
block|{
name|best_cost
operator|=
name|p
operator|->
name|cost
index|[
name|class
index|]
expr_stmt|;
name|best
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|==
name|best_cost
condition|)
name|best
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|best
index|]
index|[
name|class
index|]
expr_stmt|;
block|}
comment|/* Record the alternate register class; i.e., a class for which 	     every register in it is better than using memory.  If adding a 	     class would make a smaller class (i.e., no union of just those 	     classes exists), skip that class.  The major unions of classes 	     should be provided as a register class.  Don't do this if we 	     will be doing it again later.  */
if|if
condition|(
name|pass
operator|==
literal|1
operator|||
operator|!
name|flag_expensive_optimizations
condition|)
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|cost
index|[
name|class
index|]
operator|<
name|p
operator|->
name|mem_cost
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|alt
index|]
index|[
name|class
index|]
index|]
operator|>
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|alt
index|]
operator|)
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
operator|&&
operator|!
operator|(
name|in_inc_dec
index|[
name|i
index|]
operator|&&
name|forbidden_inc_dec_class
index|[
name|class
index|]
operator|)
endif|#
directive|endif
condition|)
name|alt
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|alt
index|]
index|[
name|class
index|]
expr_stmt|;
comment|/* If we don't add any classes, nothing to try.  */
if|if
condition|(
name|alt
operator|==
name|best
condition|)
name|alt
operator|=
operator|(
name|int
operator|)
name|NO_REGS
expr_stmt|;
comment|/* We cast to (int) because (char) hits bugs in some compilers.  */
name|prefclass
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|best
expr_stmt|;
name|altclass
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|alt
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REGISTER_CONSTRAINTS */
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
end_ifdef

begin_comment
comment|/* Record the cost of using memory or registers of various classes for    the operands in INSN.     N_ALTS is the number of alternatives.     N_OPS is the number of operands.     OPS is an array of the operands.     MODES are the modes of the operands, in case any are VOIDmode.     CONSTRAINTS are the constraints to use for the operands.  This array    is modified by this procedure.     This procedure works alternative by alternative.  For each alternative    we assume that we will be able to allocate all pseudos to their ideal    register class and calculate the cost of using that alternative.  Then    we compute for each operand that is a pseudo-register, the cost of     having the pseudo allocated to each register class and using it in that    alternative.  To this cost is added the cost of the alternative.     The cost of each class for this insn is its lowest cost among all the    alternatives.  */
end_comment

begin_function
specifier|static
name|void
name|record_reg_classes
parameter_list|(
name|n_alts
parameter_list|,
name|n_ops
parameter_list|,
name|ops
parameter_list|,
name|modes
parameter_list|,
name|constraints
parameter_list|,
name|insn
parameter_list|)
name|int
name|n_alts
decl_stmt|;
name|int
name|n_ops
decl_stmt|;
name|rtx
modifier|*
name|ops
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|modes
decl_stmt|;
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|alt
decl_stmt|;
enum|enum
name|op_type
block|{
name|OP_READ
block|,
name|OP_WRITE
block|,
name|OP_READ_WRITE
block|}
name|op_types
index|[
name|MAX_RECOG_OPERANDS
index|]
enum|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* By default, each operand is an input operand.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
name|op_types
index|[
name|i
index|]
operator|=
name|OP_READ
expr_stmt|;
comment|/* Process each alternative, each time minimizing an operand's cost with      the cost for each operand in that alternative.  */
for|for
control|(
name|alt
operator|=
literal|0
init|;
name|alt
operator|<
name|n_alts
condition|;
name|alt
operator|++
control|)
block|{
name|struct
name|costs
name|this_op_costs
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|alt_fail
init|=
literal|0
decl_stmt|;
name|int
name|alt_cost
init|=
literal|0
decl_stmt|;
name|enum
name|reg_class
name|classes
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|class
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|op
init|=
name|ops
index|[
name|i
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|modes
index|[
name|i
index|]
decl_stmt|;
name|int
name|allows_mem
init|=
literal|0
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* If this operand has no constraints at all, we can conclude  	     nothing about it since anything is valid.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|this_op_costs
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
name|this_op_costs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* If this alternative is only relevant when this operand 	     matches a previous operand, we do different things depending 	     on whether this operand is a pseudo-reg or not.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'0'
operator|+
name|i
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|','
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|j
operator|=
name|p
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|classes
index|[
name|i
index|]
operator|=
name|classes
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If this matches the other operand, we have no added 		     cost.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|,
name|op
argument_list|)
condition|)
empty_stmt|;
comment|/* If we can't put the other operand into a register, this 		     alternative can't be used.  */
elseif|else
if|if
condition|(
name|classes
index|[
name|j
index|]
operator|==
name|NO_REGS
condition|)
name|alt_fail
operator|=
literal|1
expr_stmt|;
comment|/* Otherwise, add to the cost of this alternative the cost 		     to copy this operand to the register used for the other 		     operand.  */
else|else
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* This op is a pseudo but the one it matches is not.  */
comment|/* If we can't put the other operand into a register, this 		     alternative can't be used.  */
if|if
condition|(
name|classes
index|[
name|j
index|]
operator|==
name|NO_REGS
condition|)
name|alt_fail
operator|=
literal|1
expr_stmt|;
comment|/* Otherwise, add to the cost of this alternative the cost 		     to copy the other operand to the register used for this 		     operand.  */
else|else
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|ops
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The costs of this operand are the same as that of the 		     other operand.  However, if we cannot tie them, this 		     alternative needs to do a copy, which is one 		     instruction.  */
name|this_op_costs
index|[
name|i
index|]
operator|=
name|this_op_costs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|op
argument_list|)
condition|)
name|alt_cost
operator|+=
literal|2
expr_stmt|;
comment|/* This is in place of ordinary cost computation 		     for this operand.  */
continue|continue;
block|}
block|}
comment|/* Scan all the constraint letters.  See if the operand matches 	     any of the constraints.  Collect the valid register classes 	     and see if this operand accepts memory.  */
name|classes
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
name|op_types
index|[
name|i
index|]
operator|=
name|OP_WRITE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|op_types
index|[
name|i
index|]
operator|=
name|OP_READ_WRITE
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* Ignore the next letter for this pass.  */
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
case|case
literal|'?'
case|:
case|case
literal|'!'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'p'
case|:
break|break;
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
case|case
literal|'V'
case|:
comment|/* It doesn't seem worth distingishing between offsettable 		   and non-offsettable addresses here.  */
name|allows_mem
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Match any floating double constant, but only if 		   we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|win
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|op
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'g'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|op
argument_list|)
operator|)
endif|#
directive|endif
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
name|allows_mem
operator|=
literal|1
expr_stmt|;
case|case
literal|'r'
case|:
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
default|default:
name|classes
index|[
name|i
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
block|}
name|constraints
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
comment|/* How we account for this operand now depends on whether it is  a 	     pseudo register or not.  If it is, we first check if any 	     register classes are valid.  If not, we ignore this alternative, 	     since we want to assume that all pseudos get allocated for 	     register preferencing.  If some register class is valid, compute 	     the costs of moving the pseudo into that class.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|NO_REGS
condition|)
name|alt_fail
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|this_op_costs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|class
index|]
operator|=
name|may_move_cost
index|[
name|class
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
expr_stmt|;
comment|/* If the alternative actually allows memory, make things 		     a bit cheaper since we won't need an extra insn to 		     load it.  */
name|pp
operator|->
name|mem_cost
operator|=
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|)
operator|-
name|allows_mem
expr_stmt|;
comment|/* If we have assigned a class to this register in our 		     first pass, add a cost to this alternative corresponding 		     to what we would add if this register were not in the 		     appropriate class.  */
if|if
condition|(
name|prefclass
condition|)
name|alt_cost
operator|+=
name|may_move_cost
index|[
name|prefclass
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
index|]
index|[
operator|(
name|int
operator|)
name|classes
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
block|}
comment|/* Otherwise, if this alternative wins, either because we 	     have already determined that or if we have a hard register of 	     the proper class, there is no cost for this alternative.  */
elseif|else
if|if
condition|(
name|win
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|op
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* If registers are valid, the cost of this alternative includes 	     copying the object to and/or from a register.  */
elseif|else
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|!=
name|NO_REGS
condition|)
block|{
if|if
condition|(
name|op_types
index|[
name|i
index|]
operator|!=
name|OP_WRITE
condition|)
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_types
index|[
name|i
index|]
operator|!=
name|OP_READ
condition|)
name|alt_cost
operator|+=
name|copy_cost
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The only other way this alternative can be used is if this is a 	     constant that could be placed into memory.  */
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
name|allows_mem
condition|)
name|alt_cost
operator|+=
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|alt_fail
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|alt_fail
condition|)
continue|continue;
comment|/* Finally, update the costs with the information we've calculated 	 about this alternative.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|ops
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|op_costs
index|[
name|i
index|]
decl_stmt|,
modifier|*
name|qq
init|=
operator|&
name|this_op_costs
index|[
name|i
index|]
decl_stmt|;
name|int
name|scale
init|=
literal|1
operator|+
operator|(
name|op_types
index|[
name|i
index|]
operator|==
name|OP_READ_WRITE
operator|)
decl_stmt|;
name|pp
operator|->
name|mem_cost
operator|=
name|MIN
argument_list|(
name|pp
operator|->
name|mem_cost
argument_list|,
operator|(
name|qq
operator|->
name|mem_cost
operator|+
name|alt_cost
operator|)
operator|*
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|class
index|]
operator|=
name|MIN
argument_list|(
name|pp
operator|->
name|cost
index|[
name|class
index|]
argument_list|,
operator|(
name|qq
operator|->
name|cost
index|[
name|class
index|]
operator|+
name|alt_cost
operator|)
operator|*
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the cost of loading X into (if TO_P is non-zero) or from (if    TO_P is zero) a register of class CLASS in mode MODE.     X must not be a pseudo.  */
end_comment

begin_function
specifier|static
name|int
name|copy_cost
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|class
parameter_list|,
name|to_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|to_p
decl_stmt|;
block|{
name|enum
name|reg_class
name|secondary_class
init|=
name|NO_REGS
decl_stmt|;
comment|/* If X is a SCRATCH, there is actually nothing to move since we are      assuming optimal allocation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|0
return|;
comment|/* Get the class we will actually use for a reload.  */
name|class
operator|=
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|x
argument_list|,
name|class
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
comment|/* If we need a secondary reload (we assume here that we are using       the secondary reload as an intermediate, not a scratch register), the      cost is that to load the input into the intermediate register, then      to copy them.  We use a special value of TO_P to avoid recursion.  */
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
if|if
condition|(
name|to_p
operator|==
literal|1
condition|)
name|secondary_class
operator|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
operator|!
name|to_p
condition|)
name|secondary_class
operator|=
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|secondary_class
operator|!=
name|NO_REGS
condition|)
return|return
operator|(
name|move_cost
index|[
operator|(
name|int
operator|)
name|secondary_class
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|+
name|copy_cost
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|secondary_class
argument_list|,
literal|2
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_SECONDARY_RELOADS */
comment|/* For memory, use the memory move cost, for (hard) registers, use the      cost to move between the register classes, and use 2 for everything      else (constants).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|||
name|class
operator|==
name|NO_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
name|move_cost
index|[
operator|(
name|int
operator|)
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
return|;
else|else
comment|/* If this is a constant, we may eventually want to call rtx_cost here.  */
return|return
literal|2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the pseudo registers we must reload into hard registers    in a subexpression of a memory address, X.     CLASS is the class that the register needs to be in and is either    BASE_REG_CLASS or INDEX_REG_CLASS.     SCALE is twice the amount to multiply the cost by (it is twice so we    can represent half-cost adjustments).  */
end_comment

begin_function
specifier|static
name|void
name|record_address_regs
parameter_list|(
name|x
parameter_list|,
name|class
parameter_list|,
name|scale
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|scale
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|PLUS
case|:
comment|/* When we have an address that is a sum, 	 we must determine whether registers are "base" or "index" regs. 	 If there is a sum of two registers, we must choose one to be 	 the "base".  Luckily, we can use the REGNO_POINTER_FLAG 	 to make a good choice most of the time.  We only need to do this 	 on machines that can have two registers in an address and where 	 the base and index register classes are different.  	 ??? This code used to set REGNO_POINTER_FLAG in some cases, but 	 that seems bogus since it should only be set when we are sure 	 the register is being used as a pointer.  */
block|{
name|rtx
name|arg0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|arg1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
comment|/* Look inside subregs.  */
if|if
condition|(
name|code0
operator|==
name|SUBREG
condition|)
name|arg0
operator|=
name|SUBREG_REG
argument_list|(
name|arg0
argument_list|)
operator|,
name|code0
operator|=
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|SUBREG
condition|)
name|arg1
operator|=
name|SUBREG_REG
argument_list|(
name|arg1
argument_list|)
operator|,
name|code1
operator|=
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* If this machine only allows one register per address, it must 	   be in the first operand.  */
if|if
condition|(
name|MAX_REGS_PER_ADDRESS
operator|==
literal|1
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If index and base registers are the same on this machine, just 	   record registers in any non-constant operands.  We assume here, 	   as well as in the tests below, that all addresses are in  	   canonical form.  */
elseif|else
if|if
condition|(
name|INDEX_REG_CLASS
operator|==
name|BASE_REG_CLASS
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|arg1
argument_list|)
condition|)
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/* If the second operand is a constant integer, it doesn't change 	   what class the first operand must be.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|||
name|code1
operator|==
name|CONST_DOUBLE
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If the second operand is a symbolic constant, the first operand 	   must be an index register.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|CONST
operator|||
name|code1
operator|==
name|LABEL_REF
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* If this the sum of two registers where the first is known to be a  	   pointer, it must be a base register with the second an index.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
operator|&&
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/* If this is the sum of two registers and neither is known to 	   be a pointer, count equal chances that each might be a base 	   or index register.  This case should be rare.  */
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
operator|&&
operator|!
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
operator|!
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* In all other cases, the first operand is an index and the 	   second is the base.  */
else|else
block|{
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
comment|/* Double the importance of a pseudo register that is incremented 	 or decremented, since it would take two extra insns 	 if it ends up in the wrong place.  If the operand is a pseudo, 	 show it is being used in an INC_DEC context.  */
ifdef|#
directive|ifdef
name|FORBIDDEN_INC_DEC_CLASSES
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|in_inc_dec
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|class
argument_list|,
literal|2
operator|*
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
block|{
specifier|register
name|struct
name|costs
modifier|*
name|pp
init|=
operator|&
name|costs
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pp
operator|->
name|mem_cost
operator|+=
operator|(
name|MEMORY_MOVE_COST
argument_list|(
name|Pmode
argument_list|)
operator|*
name|scale
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|pp
operator|->
name|cost
index|[
name|i
index|]
operator|+=
operator|(
name|may_move_cost
index|[
name|i
index|]
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|*
name|scale
operator|)
operator|/
literal|2
expr_stmt|;
block|}
break|break;
default|default:
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|class
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REGISTER_CONSTRAINTS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This is the `regscan' pass of the compiler, run just before cse    and again just before loop.     It finds the first and last use of each pseudo-register    and records them in the vectors regno_first_uid, regno_last_uid    and counts the number of sets in the vector reg_n_sets.     REPEAT is nonzero the second time this is called.  */
end_comment

begin_comment
comment|/* Indexed by pseudo register number, gives uid of first insn using the reg    (as of the time reg_scan is called).  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|regno_first_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by pseudo register number, gives uid of last insn using the reg    (as of the time reg_scan is called).  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|regno_last_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the number of registers we used when we allocated the above two    tables.  If we are called again with more than this, we must re-allocate    the tables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|highest_regno_in_uid_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of parallel sets and clobbers in any insn in this fn.    Always at least 3, since the combiner could put that many togetherm    and we want this to remain correct for all the remaining passes.  */
end_comment

begin_decl_stmt
name|int
name|max_parallel
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|reg_scan_mark_refs
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|reg_scan
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|repeat
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|repeat
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|repeat
operator|||
name|nregs
operator|>
name|highest_regno_in_uid_map
condition|)
block|{
comment|/* Leave some spare space in case more regs are allocated.  */
name|highest_regno_in_uid_map
operator|=
name|nregs
operator|+
name|nregs
operator|/
literal|20
expr_stmt|;
name|regno_first_uid
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|highest_regno_in_uid_map
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|regno_last_uid
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|highest_regno_in_uid_map
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_sets
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|highest_regno_in_uid_map
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|regno_first_uid
argument_list|,
name|highest_regno_in_uid_map
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regno_last_uid
argument_list|,
name|highest_regno_in_uid_map
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_n_sets
argument_list|,
name|highest_regno_in_uid_map
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|max_parallel
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|max_parallel
condition|)
name|max_parallel
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_scan_mark_refs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reg_scan_mark_refs
parameter_list|(
name|x
parameter_list|,
name|uid
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|uid
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|dest
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|REG
case|:
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|regno_last_uid
index|[
name|regno
index|]
operator|=
name|uid
expr_stmt|;
if|if
condition|(
name|regno_first_uid
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|regno_first_uid
index|[
name|regno
index|]
operator|=
name|uid
expr_stmt|;
block|}
break|break;
case|case
name|SET
case|:
comment|/* Count a set of the destination if it is a register.  */
for|for
control|(
name|dest
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTEND
condition|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|reg_n_sets
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|++
expr_stmt|;
comment|/* ... fall through ... */
default|default:
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|uid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
operator|&&
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|reg_scan_mark_refs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if C1 is a subset of C2, i.e., if every register in C1    is also in C2.  */
end_comment

begin_function
name|int
name|reg_class_subset_p
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
specifier|register
name|enum
name|reg_class
name|c1
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|c2
decl_stmt|;
block|{
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c2
operator|==
name|ALL_REGS
condition|)
name|win
label|:
return|return
literal|1
return|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if there is a register that is in both C1 and C2.  */
end_comment

begin_function
name|int
name|reg_classes_intersect_p
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
specifier|register
name|enum
name|reg_class
name|c1
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|c2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
endif|#
directive|endif
name|HARD_REG_SET
name|c
decl_stmt|;
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c1
operator|==
name|ALL_REGS
operator|||
name|c2
operator|==
name|ALL_REGS
condition|)
return|return
literal|1
return|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|NO_REGS
index|]
argument_list|,
name|lose
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|lose
label|:
return|return
literal|0
return|;
block|}
end_function

end_unit

