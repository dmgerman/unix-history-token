begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to perform peephole optimizations.    Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|read_rtx
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* While tree-walking an instruction pattern, we keep a chain    of these `struct link's to record how to get down to the    current position.  In each one, POS is the operand number,    and if the operand is a vector VEC is the element number.    VEC is -1 if the operand is not a vector.  */
end_comment

begin_struct
struct|struct
name|link
block|{
name|struct
name|link
modifier|*
name|next
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|vecelt
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|match_rtx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_exp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of operands used in current peephole definition.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Peephole optimizations get insn codes just like insn patterns.    Count them so we know the code of the define_peephole we are handling.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|print_path
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_code
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
specifier|static
name|void
name|gen_peephole
parameter_list|(
name|peep
parameter_list|)
name|rtx
name|peep
decl_stmt|;
block|{
name|int
name|ninsns
init|=
name|XVECLEN
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|n_operands
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"  insn = ins1;\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("  want_jump = 0;\n");
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ninsns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  do { insn = NEXT_INSN (insn);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       if (insn == 0) goto L%d; }\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  while (GET_CODE (insn) == NOTE\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t || (GET_CODE (insn) == INSN\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t&& (GET_CODE (PATTERN (insn)) == USE\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)));\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (GET_CODE (insn) == CODE_LABEL\n\       || GET_CODE (insn) == BARRIER)\n    goto L%d;\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf ("  if (GET_CODE (insn) == JUMP_INSN)\n");       printf ("    want_jump = JUMP_LABEL (insn);\n");
endif|#
directive|endif
name|printf
argument_list|(
literal|"  pat = PATTERN (insn);\n"
argument_list|)
expr_stmt|;
comment|/* Walk the insn's pattern, remembering at all times the path 	 down to the walking point.  */
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
comment|/* We get this far if the pattern matches.      Now test the extra condition.  */
if|if
condition|(
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|1
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  if (! (%s)) goto L%d;\n"
argument_list|,
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
comment|/* If that matches, construct new pattern and put it in the first insn.      This new pattern will never be matched.      It exists only so that insn-extract can get the operands back.      So use a simple regular form: a PARALLEL containing a vector      of all the operands.  */
name|printf
argument_list|(
literal|"  PATTERN (ins1) = gen_rtx (PARALLEL, VOIDmode, gen_rtvec_v (%d, operands));\n"
argument_list|,
name|n_operands
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("  if (want_jump&& GET_CODE (ins1) != JUMP_INSN)\n");   printf ("    {\n");   printf ("      rtx insn2 = emit_jump_insn_before (PATTERN (ins1), ins1);\n");   printf ("      delete_insn (ins1);\n");   printf ("      ins1 = ins2;\n");   printf ("    }\n");
endif|#
directive|endif
comment|/* Record this define_peephole's insn code in the insn,      as if it had been recognized to match this.  */
name|printf
argument_list|(
literal|"  INSN_CODE (ins1) = %d;\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
comment|/* Delete the remaining insns.  */
if|if
condition|(
name|ninsns
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"  delete_for_peephole (NEXT_INSN (ins1), insn);\n"
argument_list|)
expr_stmt|;
comment|/* See reload1.c for insertion of NOTE which guarantees that this      cannot be zero.  */
name|printf
argument_list|(
literal|"  return NEXT_INSN (insn);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" L%d:\n\n"
argument_list|,
name|insn_code_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|match_rtx
parameter_list|(
name|x
parameter_list|,
name|path
parameter_list|,
name|fail_label
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|link
modifier|*
name|path
decl_stmt|;
name|int
name|fail_label
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|struct
name|link
name|link
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MATCH_OPERAND
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>=
name|n_operands
condition|)
name|n_operands
operator|=
literal|1
operator|+
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  operands[%d] = x;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  if (! %s (x, %smode)) goto L%d;\n"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_DUP
case|:
case|case
name|MATCH_PAR_DUP
case|:
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (!rtx_equal_p (operands[%d], x)) goto L%d;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
return|return;
case|case
name|MATCH_OP_DUP
case|:
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (GET_CODE (operands[%d]) != GET_CODE (x)\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      || GET_MODE (operands[%d]) != GET_MODE (x)) goto L%d;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  operands[%d] = x;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|pos
operator|=
name|i
expr_stmt|;
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MATCH_OPERATOR
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>=
name|n_operands
condition|)
name|n_operands
operator|=
literal|1
operator|+
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  operands[%d] = x;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  if (! %s (x, %smode)) goto L%d;\n"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|pos
operator|=
name|i
expr_stmt|;
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MATCH_PARALLEL
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|>=
name|n_operands
condition|)
name|n_operands
operator|=
literal|1
operator|+
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (GET_CODE (x) != PARALLEL) goto L%d;\n"
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  operands[%d] = x;\n"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|&&
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"  if (! %s (x, %smode)) goto L%d;\n"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|vecelt
operator|=
name|i
expr_stmt|;
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|ADDRESS
case|:
name|match_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|path
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (GET_CODE (x) != "
argument_list|)
expr_stmt|;
name|print_code
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|") goto L%d;\n"
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
name|printf
argument_list|(
literal|"  if (GET_MODE (x) != %smode) goto L%d;\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
name|link
operator|.
name|next
operator|=
name|path
expr_stmt|;
name|link
operator|.
name|vecelt
operator|=
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|.
name|pos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|match_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"  if (XVECLEN (x, %d) != %d) goto L%d;\n"
argument_list|,
name|i
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|link
operator|.
name|vecelt
operator|=
name|j
expr_stmt|;
name|match_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
operator|&
name|link
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
block|{
comment|/* Make sure that at run time `x' is the RTX we want to test.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  if (XINT (x, %d) != %d) goto L%d;\n"
argument_list|,
name|i
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'w'
condition|)
block|{
comment|/* Make sure that at run time `x' is the RTX we want to test.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
name|printf
argument_list|(
literal|"  if (XWINT (x, %d) != %d) goto L%d;\n"
argument_list|,
name|i
argument_list|,
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"  if (XWINT (x, %d) != %ld) goto L%d;\n"
argument_list|,
name|i
argument_list|,
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
comment|/* Make sure that at run time `x' is the RTX we want to test.  */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  x = "
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  if (strcmp (XSTR (x, %d), \"%s\")) goto L%d;\n"
argument_list|,
name|i
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|fail_label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a PATH, representing a path down the instruction's    pattern from the root to a certain point, output code to    evaluate to the rtx at that point.  */
end_comment

begin_function
specifier|static
name|void
name|print_path
parameter_list|(
name|path
parameter_list|)
name|struct
name|link
modifier|*
name|path
decl_stmt|;
block|{
if|if
condition|(
name|path
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"pat"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|path
operator|->
name|vecelt
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"XVECEXP ("
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d, %d)"
argument_list|,
name|path
operator|->
name|pos
argument_list|,
name|path
operator|->
name|vecelt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"XEXP ("
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|path
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d)"
argument_list|,
name|path
operator|->
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_code
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|>=
literal|'a'
operator|&&
operator|*
name|p1
operator|<=
literal|'z'
condition|)
name|putchar
argument_list|(
operator|*
name|p1
operator|+
literal|'A'
operator|-
literal|'a'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genpeep: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genpeep'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extern rtx peep_operand[];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define operands peep_operand\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rtx\npeephole (ins1)\n     rtx ins1;\n{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx insn, x, pat;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int i;\n\n"
argument_list|)
expr_stmt|;
comment|/* Early out: no peepholes for insns followed by barriers.  */
name|printf
argument_list|(
literal|"  if (NEXT_INSN (ins1)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&& GET_CODE (NEXT_INSN (ins1)) == BARRIER)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    return 0;\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
block|{
name|gen_peephole
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|insn_code_number
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
block|{
name|insn_code_number
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"  return 0;\n}\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_opno
operator|==
operator|-
literal|1
condition|)
name|max_opno
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"rtx peep_operand[%d];\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

