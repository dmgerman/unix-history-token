begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fold a constant sub-tree into a single node for C-compiler    Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*@@ Fix lossage on folding division of big integers.  */
end_comment

begin_comment
comment|/*@@ This file should be rewritten to use an arbitrary precision   @@ representation for "struct tree_int_cst" and "struct tree_real_cst".   @@ Perhaps the routines could also be used for bc/dc, and made a lib.   @@ The routines that translate from the ap rep should   @@ warn if precision et. al. is lost.   @@ This would also make life easier when this technology is used   @@ for cross-compilers.  */
end_comment

begin_comment
comment|/* The entry points in this file are fold, size_int and size_binop.     fold takes a tree as argument and returns a simplified tree.     size_binop takes a tree code for an arithmetic operation    and two operands that are trees, and produces a tree for the    result, assuming the type comes from `sizetype'.     size_int takes an integer value, and creates a tree constant    with type from `sizetype'.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* Handle floating overflow for `const_binop'.  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|float_error
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|lshift_double
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rshift_double
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lrotate_double
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rrotate_double
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|const_binop
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|BRANCH_COST
end_ifndef

begin_define
define|#
directive|define
name|BRANCH_COST
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Yield nonzero if a signed left shift of A by B bits overflows.  */
end_comment

begin_define
define|#
directive|define
name|left_shift_overflows
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)  !=  ((a)<< (b))>> (b))
end_define

begin_comment
comment|/* Yield nonzero if A and B have the same sign.  */
end_comment

begin_define
define|#
directive|define
name|same_sign
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) ^ (b)>= 0)
end_define

begin_comment
comment|/* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.    Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.    Then this yields nonzero if overflow occurred during the addition.    Overflow occurs if A and B have the same sign, but A and SUM differ in sign.    Use `^' to test whether signs differ, and `< 0' to isolate the sign.  */
end_comment

begin_define
define|#
directive|define
name|overflow_sum_sign
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|sum
parameter_list|)
value|((~((a) ^ (b))& ((a) ^ (sum)))< 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.    We do that by representing the two-word integer as MAX_SHORTS shorts,    with only 8 bits stored in each short, as a positive number.  */
end_comment

begin_comment
comment|/* Unpack a two-word integer into MAX_SHORTS shorts.    LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.    SHORTS points to the array of shorts.  */
end_comment

begin_function
specifier|static
name|void
name|encode
parameter_list|(
name|shorts
parameter_list|,
name|low
parameter_list|,
name|hi
parameter_list|)
name|short
modifier|*
name|shorts
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|hi
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SHORTS
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|shorts
index|[
name|i
index|]
operator|=
operator|(
name|low
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shorts
index|[
name|i
operator|+
name|MAX_SHORTS
operator|/
literal|2
index|]
operator|=
operator|(
name|hi
operator|>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pack an array of MAX_SHORTS shorts into a two-word integer.    SHORTS points to the array of shorts.    The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */
end_comment

begin_function
specifier|static
name|void
name|decode
parameter_list|(
name|shorts
parameter_list|,
name|low
parameter_list|,
name|hi
parameter_list|)
name|short
modifier|*
name|shorts
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|low
decl_stmt|,
decl|*
name|hi
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|lv
init|=
literal|0
decl_stmt|,
name|hv
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SHORTS
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|lv
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|shorts
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
name|hv
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|shorts
index|[
name|i
operator|+
name|MAX_SHORTS
operator|/
literal|2
index|]
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
block|}
operator|*
name|low
operator|=
name|lv
operator|,
operator|*
name|hi
operator|=
name|hv
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make the integer constant T valid for its type    by setting to 0 or 1 all the bits in the constant    that don't belong in the type.  */
end_comment

begin_function
specifier|static
name|void
name|force_fit_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|prec
operator|=
name|POINTER_SIZE
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|&=
operator|~
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
comment|/* If it's a signed type and value's sign bit is set, extend the sign.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|prec
operator|!=
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|?
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|)
else|:
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Value is negative: 	 set to 1 all the bits that are outside this type's precision.  */
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator||=
operator|(
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add two doubleword integers with doubleword result.    Each argument is given as two `HOST_WIDE_INT' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.    We use the 8-shorts representation internally.  */
end_comment

begin_function
name|int
name|add_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|l2
parameter_list|,
name|h2
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|l2
decl_stmt|,
name|h2
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
name|short
name|arg1
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
name|short
name|arg2
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
specifier|register
name|int
name|carry
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|arg2
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SHORTS
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|+
name|arg2
index|[
name|i
index|]
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
name|carry
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
return|return
name|overflow_sum_sign
argument_list|(
name|h1
argument_list|,
name|h2
argument_list|,
operator|*
name|hv
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Negate a doubleword integer with doubleword result.    Return nonzero if the operation overflows, assuming it's signed.    The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.    We use the 8-shorts representation internally.  */
end_comment

begin_function
name|int
name|neg_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|h1
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
block|{
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
operator|*
name|hv
operator|=
operator|-
name|h1
expr_stmt|;
return|return
name|same_sign
argument_list|(
name|h1
argument_list|,
operator|*
name|hv
argument_list|)
return|;
block|}
else|else
block|{
operator|*
name|lv
operator|=
operator|-
name|l1
expr_stmt|;
operator|*
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Multiply two doubleword integers with doubleword result.    Return nonzero if the operation overflows, assuming it's signed.    Each argument is given as two `HOST_WIDE_INT' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.    We use the 8-shorts representation internally.  */
end_comment

begin_function
name|int
name|mul_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|l2
parameter_list|,
name|h2
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|l2
decl_stmt|,
name|h2
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
name|short
name|arg1
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
name|short
name|arg2
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
name|short
name|prod
index|[
name|MAX_SHORTS
operator|*
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|carry
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|HOST_WIDE_INT
name|toplow
decl_stmt|,
name|tophigh
decl_stmt|,
name|neglow
decl_stmt|,
name|neghigh
decl_stmt|;
comment|/* These cases are used extensively, arising from pointer combinations.  */
if|if
condition|(
name|h2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|l2
operator|==
literal|2
condition|)
block|{
name|int
name|overflow
init|=
name|left_shift_overflows
argument_list|(
name|h1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|temp
init|=
name|l1
operator|+
name|l1
decl_stmt|;
operator|*
name|hv
operator|=
operator|(
name|h1
operator|<<
literal|1
operator|)
operator|+
operator|(
name|temp
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|temp
expr_stmt|;
return|return
name|overflow
return|;
block|}
if|if
condition|(
name|l2
operator|==
literal|4
condition|)
block|{
name|int
name|overflow
init|=
name|left_shift_overflows
argument_list|(
name|h1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|temp
init|=
name|l1
operator|+
name|l1
decl_stmt|;
name|h1
operator|=
operator|(
name|h1
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|temp
operator|<
name|l1
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|l1
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|h1
operator|+=
operator|(
name|temp
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|temp
expr_stmt|;
operator|*
name|hv
operator|=
name|h1
expr_stmt|;
return|return
name|overflow
return|;
block|}
if|if
condition|(
name|l2
operator|==
literal|8
condition|)
block|{
name|int
name|overflow
init|=
name|left_shift_overflows
argument_list|(
name|h1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|temp
init|=
name|l1
operator|+
name|l1
decl_stmt|;
name|h1
operator|=
operator|(
name|h1
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|temp
operator|<
name|l1
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|l1
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|h1
operator|+=
operator|(
name|temp
operator|<
name|l1
operator|)
operator|<<
literal|1
expr_stmt|;
name|l1
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|h1
operator|+=
operator|(
name|temp
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|temp
expr_stmt|;
operator|*
name|hv
operator|=
name|h1
expr_stmt|;
return|return
name|overflow
return|;
block|}
block|}
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|arg2
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|prod
argument_list|,
sizeof|sizeof
name|prod
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SHORTS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_SHORTS
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|i
operator|+
name|j
expr_stmt|;
name|carry
operator|=
name|arg1
index|[
name|i
index|]
operator|*
name|arg2
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|carry
condition|)
block|{
name|carry
operator|+=
name|prod
index|[
name|k
index|]
expr_stmt|;
name|prod
index|[
name|k
index|]
operator|=
name|carry
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
name|decode
argument_list|(
name|prod
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
comment|/* This ignores 				   prod[MAX_SHORTS] -> prod[MAX_SHORTS*2-1] */
comment|/* Check for overflow by calculating the top half of the answer in full;      it should agree with the low half's sign bit.  */
name|decode
argument_list|(
name|prod
operator|+
name|MAX_SHORTS
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
if|if
condition|(
name|h1
operator|<
literal|0
condition|)
block|{
name|neg_double
argument_list|(
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|neglow
argument_list|,
operator|&
name|neghigh
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|neglow
argument_list|,
name|neghigh
argument_list|,
name|toplow
argument_list|,
name|tophigh
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h2
operator|<
literal|0
condition|)
block|{
name|neg_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|&
name|neglow
argument_list|,
operator|&
name|neghigh
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|neglow
argument_list|,
name|neghigh
argument_list|,
name|toplow
argument_list|,
name|tophigh
argument_list|,
operator|&
name|toplow
argument_list|,
operator|&
name|tophigh
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|hv
operator|<
literal|0
condition|?
operator|~
operator|(
name|toplow
operator|&
name|tophigh
operator|)
else|:
name|toplow
operator||
name|tophigh
operator|)
operator|!=
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Shift the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Shift right if COUNT is negative.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Return nonzero if the arithmetic shift overflows, assuming it's signed.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|int
name|lshift_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|,
name|arith
parameter_list|)
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|h1
decl_stmt|;
name|int
name|count
decl_stmt|,
name|prec
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|arith
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|arg1
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|,
name|overflow
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|-
name|count
argument_list|,
name|prec
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|arith
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|prec
condition|)
name|count
operator|=
name|prec
expr_stmt|;
name|overflow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SHORTS
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|<<
literal|1
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
name|carry
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
name|overflow
operator||=
name|carry
operator|^
operator|(
name|arg1
index|[
literal|7
index|]
operator|>>
literal|7
operator|)
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
return|return
name|overflow
return|;
block|}
end_block

begin_comment
comment|/* Shift the doubleword integer in L1, H1 right by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|rshift_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|,
name|arith
parameter_list|)
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|count
decl_stmt|,
name|prec
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|arith
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|arg1
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|prec
condition|)
name|count
operator|=
name|prec
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|carry
operator|=
name|arith
operator|&&
name|arg1
index|[
literal|7
index|]
operator|>>
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MAX_SHORTS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|carry
operator|<<=
literal|8
expr_stmt|;
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
operator|(
name|carry
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Rotate the doubldword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Rotate right if COUNT is negative.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|lrotate_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|count
decl_stmt|,
name|prec
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
name|short
name|arg1
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|-
name|count
argument_list|,
name|prec
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
return|return;
block|}
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|prec
condition|)
name|count
operator|=
name|prec
expr_stmt|;
name|carry
operator|=
name|arg1
index|[
name|MAX_SHORTS
operator|-
literal|1
index|]
operator|>>
literal|7
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SHORTS
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|<<
literal|1
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
name|carry
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Rotate the doubleword integer in L1, H1 left by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */
end_comment

begin_function
name|void
name|rrotate_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|HOST_WIDE_INT
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|count
decl_stmt|,
name|prec
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
name|short
name|arg1
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|prec
condition|)
name|count
operator|=
name|prec
expr_stmt|;
name|carry
operator|=
name|arg1
index|[
literal|0
index|]
operator|&
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|MAX_SHORTS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|carry
operator|<<=
literal|8
expr_stmt|;
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
operator|(
name|carry
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN    for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).    CODE is a tree code for a kind of division, one of    TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR    or EXACT_DIV_EXPR    It controls how the quotient is rounded to a integer.    Return nonzero if the operation overflows.    UNS nonzero says do unsigned division.  */
end_comment

begin_function
specifier|static
name|int
name|div_and_round_double
parameter_list|(
name|code
parameter_list|,
name|uns
parameter_list|,
name|lnum_orig
parameter_list|,
name|hnum_orig
parameter_list|,
name|lden_orig
parameter_list|,
name|hden_orig
parameter_list|,
name|lquo
parameter_list|,
name|hquo
parameter_list|,
name|lrem
parameter_list|,
name|hrem
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|uns
decl_stmt|;
name|HOST_WIDE_INT
name|lnum_orig
decl_stmt|,
name|hnum_orig
decl_stmt|;
comment|/* num == numerator == dividend */
name|HOST_WIDE_INT
name|lden_orig
decl_stmt|,
name|hden_orig
decl_stmt|;
comment|/* den == denominator == divisor */
name|HOST_WIDE_INT
modifier|*
name|lquo
decl_stmt|,
decl|*
name|hquo
decl_stmt|,
modifier|*
name|lrem
decl_stmt|,
modifier|*
name|hrem
decl_stmt|;
end_function

begin_block
block|{
name|int
name|quo_neg
init|=
literal|0
decl_stmt|;
name|short
name|num
index|[
name|MAX_SHORTS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* extra element for scaling.  */
name|short
name|den
index|[
name|MAX_SHORTS
index|]
decl_stmt|,
name|quo
index|[
name|MAX_SHORTS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|work
decl_stmt|;
specifier|register
name|int
name|carry
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lnum
init|=
name|lnum_orig
decl_stmt|;
name|HOST_WIDE_INT
name|hnum
init|=
name|hnum_orig
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lden
init|=
name|lden_orig
decl_stmt|;
name|HOST_WIDE_INT
name|hden
init|=
name|hden_orig
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|hden
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lden
operator|==
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* calculate quotient sign and convert operands to unsigned.  */
if|if
condition|(
operator|!
name|uns
condition|)
block|{
if|if
condition|(
name|hnum
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
comment|/* (minimum integer) / (-1) is the only overflow case.  */
if|if
condition|(
name|neg_double
argument_list|(
name|lnum
argument_list|,
name|hnum
argument_list|,
operator|&
name|lnum
argument_list|,
operator|&
name|hnum
argument_list|)
operator|&&
operator|(
name|lden
operator|&
name|hden
operator|)
operator|==
operator|-
literal|1
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|lden
argument_list|,
operator|&
name|hden
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
operator|&&
name|hden
operator|==
literal|0
condition|)
block|{
comment|/* single precision */
operator|*
name|hquo
operator|=
operator|*
name|hrem
operator|=
literal|0
expr_stmt|;
operator|*
name|lquo
operator|=
name|lnum
operator|/
name|lden
expr_stmt|;
comment|/* rounds toward zero since positive args */
goto|goto
name|finish_up
goto|;
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
condition|)
block|{
comment|/* trivial case: dividend< divisor */
comment|/* hden != 0 already checked.  */
operator|*
name|hquo
operator|=
operator|*
name|lquo
operator|=
literal|0
expr_stmt|;
operator|*
name|hrem
operator|=
name|hnum
expr_stmt|;
operator|*
name|lrem
operator|=
name|lnum
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
name|bzero
argument_list|(
name|quo
argument_list|,
sizeof|sizeof
name|quo
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|num
argument_list|,
sizeof|sizeof
name|num
argument_list|)
expr_stmt|;
comment|/* to zero 9th element */
name|bzero
argument_list|(
name|den
argument_list|,
sizeof|sizeof
name|den
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|num
argument_list|,
name|lnum
argument_list|,
name|hnum
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|den
argument_list|,
name|lden
argument_list|,
name|hden
argument_list|)
expr_stmt|;
comment|/* This code requires more than just hden == 0.      We also have to require that we don't need more than three bytes      to hold CARRY.  If we ever did need four bytes to hold it, we      would lose part of it when computing WORK on the next round.  */
if|if
condition|(
name|hden
operator|==
literal|0
operator|&&
operator|(
operator|(
name|lden
operator|<<
literal|8
operator|)
operator|>>
literal|8
operator|)
operator|==
name|lden
condition|)
block|{
comment|/* simpler algorithm */
comment|/* hnum != 0 already checked.  */
for|for
control|(
name|i
operator|=
name|MAX_SHORTS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
index|]
operator|+
operator|(
name|carry
operator|<<
literal|8
operator|)
expr_stmt|;
name|quo
index|[
name|i
index|]
operator|=
name|work
operator|/
name|lden
expr_stmt|;
name|carry
operator|=
name|work
operator|%
name|lden
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* full double precision, 				   with thanks to Don Knuth's 				   "Seminumerical Algorithms".  */
define|#
directive|define
name|BASE
value|256
name|int
name|quo_est
decl_stmt|,
name|scale
decl_stmt|,
name|num_hi_sig
decl_stmt|,
name|den_hi_sig
decl_stmt|,
name|quo_hi_sig
decl_stmt|;
comment|/* Find the highest non-zero divisor digit.  */
for|for
control|(
name|i
operator|=
name|MAX_SHORTS
operator|-
literal|1
init|;
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|den_hi_sig
operator|=
name|i
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
name|MAX_SHORTS
operator|-
literal|1
init|;
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|num
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|num_hi_sig
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|quo_hi_sig
operator|=
name|num_hi_sig
operator|-
name|den_hi_sig
operator|+
literal|1
expr_stmt|;
comment|/* Insure that the first digit of the divisor is at least BASE/2.        This is required by the quotient digit estimation algorithm.  */
name|scale
operator|=
name|BASE
operator|/
operator|(
name|den
index|[
name|den_hi_sig
index|]
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|1
condition|)
block|{
comment|/* scale divisor and dividend */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_SHORTS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|num
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|num
index|[
name|i
index|]
operator|=
name|work
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|num
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|num_hi_sig
operator|=
name|i
expr_stmt|;
block|}
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_SHORTS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|den
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|den
index|[
name|i
index|]
operator|=
name|work
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|den_hi_sig
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Main loop */
for|for
control|(
name|i
operator|=
name|quo_hi_sig
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* guess the next quotient digit, quo_est, by dividing the first 	 two remaining dividend digits by the high order quotient digit. 	 quo_est is never low and is at most 2 high.  */
name|int
name|num_hi
decl_stmt|;
comment|/* index of highest remaining dividend digit */
name|num_hi
operator|=
name|i
operator|+
name|den_hi_sig
expr_stmt|;
name|work
operator|=
operator|(
name|num
index|[
name|num_hi
index|]
operator|*
name|BASE
operator|)
operator|+
operator|(
name|num_hi
operator|>
literal|0
condition|?
name|num
index|[
name|num_hi
operator|-
literal|1
index|]
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|num
index|[
name|num_hi
index|]
operator|!=
name|den
index|[
name|den_hi_sig
index|]
condition|)
block|{
name|quo_est
operator|=
name|work
operator|/
name|den
index|[
name|den_hi_sig
index|]
expr_stmt|;
block|}
else|else
block|{
name|quo_est
operator|=
name|BASE
operator|-
literal|1
expr_stmt|;
block|}
comment|/* refine quo_est so it's usually correct, and at most one high.   */
while|while
condition|(
operator|(
name|den
index|[
name|den_hi_sig
operator|-
literal|1
index|]
operator|*
name|quo_est
operator|)
operator|>
operator|(
operator|(
operator|(
name|work
operator|-
operator|(
name|quo_est
operator|*
name|den
index|[
name|den_hi_sig
index|]
operator|)
operator|)
operator|*
name|BASE
operator|)
operator|+
operator|(
operator|(
name|num_hi
operator|-
literal|1
operator|)
operator|>
literal|0
condition|?
name|num
index|[
name|num_hi
operator|-
literal|2
index|]
else|:
literal|0
operator|)
operator|)
condition|)
name|quo_est
operator|--
expr_stmt|;
comment|/* Try QUO_EST as the quotient digit, by multiplying the          divisor by QUO_EST and subtracting from the remaining dividend. 	 Keep in mind that QUO_EST is the I - 1st digit.  */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|int
name|digit
decl_stmt|;
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
operator|-
literal|1
index|]
operator|-
operator|(
name|quo_est
operator|*
name|den
index|[
name|j
index|]
operator|)
operator|+
name|carry
expr_stmt|;
name|digit
operator|=
name|work
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|digit
operator|<
literal|0
condition|)
block|{
name|digit
operator|+=
name|BASE
expr_stmt|;
name|carry
operator|--
expr_stmt|;
block|}
name|num
index|[
name|i
operator|+
name|j
operator|-
literal|1
index|]
operator|=
name|digit
expr_stmt|;
block|}
comment|/* if quo_est was high by one, then num[i] went negative and 	 we need to correct things.  */
if|if
condition|(
name|num
index|[
name|num_hi
index|]
operator|<
literal|0
condition|)
block|{
name|quo_est
operator|--
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
comment|/* add divisor back in */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
operator|-
literal|1
index|]
operator|+
name|den
index|[
name|j
index|]
operator|+
name|carry
expr_stmt|;
if|if
condition|(
name|work
operator|>
name|BASE
condition|)
block|{
name|work
operator|-=
name|BASE
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|carry
operator|=
literal|0
expr_stmt|;
block|}
name|num
index|[
name|i
operator|+
name|j
operator|-
literal|1
index|]
operator|=
name|work
expr_stmt|;
block|}
name|num
index|[
name|num_hi
index|]
operator|+=
name|carry
expr_stmt|;
block|}
comment|/* store the quotient digit.  */
name|quo
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|quo_est
expr_stmt|;
block|}
block|}
name|decode
argument_list|(
name|quo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
name|finish_up
label|:
comment|/* if result is negative, make it so.  */
if|if
condition|(
name|quo_neg
condition|)
name|neg_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
comment|/* compute trial remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
comment|/* round toward zero */
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* for this one, it shouldn't matter */
return|return
name|overflow
return|;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
comment|/* round toward negative infinity */
if|if
condition|(
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio< 0&& rem != 0 */
block|{
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
comment|/* round toward positive infinity */
if|if
condition|(
operator|!
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio> 0&& rem != 0 */
block|{
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
break|break;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
comment|/* round to closest integer */
block|{
name|HOST_WIDE_INT
name|labs_rem
init|=
operator|*
name|lrem
decl_stmt|,
name|habs_rem
init|=
operator|*
name|hrem
decl_stmt|;
name|HOST_WIDE_INT
name|labs_den
init|=
name|lden
decl_stmt|,
name|habs_den
init|=
name|hden
decl_stmt|,
name|ltwice
decl_stmt|,
name|htwice
decl_stmt|;
comment|/* get absolute values */
if|if
condition|(
operator|*
name|hrem
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
operator|&
name|labs_rem
argument_list|,
operator|&
name|habs_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|labs_den
argument_list|,
operator|&
name|habs_den
argument_list|)
expr_stmt|;
comment|/* if (2 * abs (lrem)>= abs (lden)) */
name|mul_double
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|labs_rem
argument_list|,
name|habs_rem
argument_list|,
operator|&
name|ltwice
argument_list|,
operator|&
name|htwice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|habs_den
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|htwice
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|habs_den
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|htwice
operator|)
operator|&&
operator|(
operator|(
name|HOST_WIDE_INT
name|unsigned
operator|)
name|labs_den
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|ltwice
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|hquo
operator|<
literal|0
condition|)
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
else|else
comment|/* quo = quo + 1; */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|overflow
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* compute true remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
return|return
name|overflow
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Effectively truncate a real value to represent    the nearest possible value in a narrower mode.    The result is actually represented in the same data type as the argument,    but its value is usually different.  */
end_comment

begin_function
name|REAL_VALUE_TYPE
name|real_value_truncate
parameter_list|(
name|mode
parameter_list|,
name|arg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|REAL_VALUE_TYPE
name|arg
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__STDC__
comment|/* Make sure the value is actually stored in memory before we turn off      the handler.  */
specifier|volatile
endif|#
directive|endif
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|,
name|old_handler
decl_stmt|;
name|int
name|handled
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"floating overflow"
argument_list|)
expr_stmt|;
return|return
name|dconst0
return|;
block|}
name|handled
operator|=
name|push_float_handler
argument_list|(
name|handler
argument_list|,
name|old_handler
argument_list|)
expr_stmt|;
name|value
operator|=
name|REAL_VALUE_TRUNCATE
argument_list|(
name|mode
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pop_float_handler
argument_list|(
name|handled
argument_list|,
name|old_handler
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
end_if

begin_comment
comment|/* Check for infinity in an IEEE double precision number.  */
end_comment

begin_function
name|int
name|target_isinf
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
comment|/* The IEEE 64-bit double format.  */
union|union
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
struct|struct
block|{
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
decl_stmt|;
block|}
name|little_endian
struct|;
struct|struct
block|{
name|unsigned
name|mantissa2
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
block|}
name|big_endian
struct|;
block|}
name|u
union|;
name|u
operator|.
name|d
operator|=
name|dconstm1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|big_endian
operator|.
name|sign
operator|==
literal|1
condition|)
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|big_endian
operator|.
name|exponent
operator|==
literal|2047
operator|&&
name|u
operator|.
name|big_endian
operator|.
name|mantissa1
operator|==
literal|0
operator|&&
name|u
operator|.
name|big_endian
operator|.
name|mantissa2
operator|==
literal|0
operator|)
return|;
block|}
else|else
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|little_endian
operator|.
name|exponent
operator|==
literal|2047
operator|&&
name|u
operator|.
name|little_endian
operator|.
name|mantissa1
operator|==
literal|0
operator|&&
name|u
operator|.
name|little_endian
operator|.
name|mantissa2
operator|==
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Check whether an IEEE double precision number is a NaN.  */
end_comment

begin_function
name|int
name|target_isnan
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
comment|/* The IEEE 64-bit double format.  */
union|union
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
struct|struct
block|{
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
decl_stmt|;
block|}
name|little_endian
struct|;
struct|struct
block|{
name|unsigned
name|mantissa2
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
block|}
name|big_endian
struct|;
block|}
name|u
union|;
name|u
operator|.
name|d
operator|=
name|dconstm1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|big_endian
operator|.
name|sign
operator|==
literal|1
condition|)
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|big_endian
operator|.
name|exponent
operator|==
literal|2047
operator|&&
operator|(
name|u
operator|.
name|big_endian
operator|.
name|mantissa1
operator|!=
literal|0
operator|||
name|u
operator|.
name|big_endian
operator|.
name|mantissa2
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
else|else
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
operator|(
name|u
operator|.
name|little_endian
operator|.
name|exponent
operator|==
literal|2047
operator|&&
operator|(
name|u
operator|.
name|little_endian
operator|.
name|mantissa1
operator|!=
literal|0
operator|||
name|u
operator|.
name|little_endian
operator|.
name|mantissa2
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Check for a negative IEEE double precision number.  */
end_comment

begin_function
name|int
name|target_negative
parameter_list|(
name|x
parameter_list|)
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
block|{
comment|/* The IEEE 64-bit double format.  */
union|union
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
struct|struct
block|{
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
decl_stmt|;
block|}
name|little_endian
struct|;
struct|struct
block|{
name|unsigned
name|mantissa2
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
block|}
name|big_endian
struct|;
block|}
name|u
union|;
name|u
operator|.
name|d
operator|=
name|dconstm1
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|big_endian
operator|.
name|sign
operator|==
literal|1
condition|)
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
name|u
operator|.
name|big_endian
operator|.
name|sign
return|;
block|}
else|else
block|{
name|u
operator|.
name|d
operator|=
name|x
expr_stmt|;
return|return
name|u
operator|.
name|little_endian
operator|.
name|sign
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Target not IEEE */
end_comment

begin_comment
comment|/* Let's assume other float formats don't have infinity.    (This can be overridden by redefining REAL_VALUE_ISINF.)  */
end_comment

begin_macro
name|target_isinf
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Let's assume other float formats don't have NaNs.    (This can be overridden by redefining REAL_VALUE_ISNAN.)  */
end_comment

begin_macro
name|target_isnan
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Let's assume other float formats don't have minus zero.    (This can be overridden by redefining REAL_VALUE_NEGATIVE.)  */
end_comment

begin_macro
name|target_negative
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|REAL_VALUE_TYPE
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|x
operator|<
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Target not IEEE */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Split a tree IN into a constant and a variable part    that could be combined with CODE to make IN.    CODE must be a commutative arithmetic operation.    Store the constant part into *CONP and the variable in&VARP.    Return 1 if this was done; zero means the tree IN did not decompose    this way.     If CODE is PLUS_EXPR we also split trees that use MINUS_EXPR.    Therefore, we must tell the caller whether the variable part    was subtracted.  We do this by storing 1 or -1 into *VARSIGNP.    The value stored is the coefficient for the variable term.    The constant term we return should always be added;    we negate it if necessary.  */
end_comment

begin_function
specifier|static
name|int
name|split_tree
parameter_list|(
name|in
parameter_list|,
name|code
parameter_list|,
name|varp
parameter_list|,
name|conp
parameter_list|,
name|varsignp
parameter_list|)
name|tree
name|in
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
modifier|*
name|varp
decl_stmt|,
decl|*
name|conp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|varsignp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tree
name|outtype
init|=
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
decl_stmt|;
operator|*
name|varp
operator|=
literal|0
expr_stmt|;
operator|*
name|conp
operator|=
literal|0
expr_stmt|;
comment|/* Strip any conversions that don't change the machine mode.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|in
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
comment|/* We can associate addition and subtraction together 	     (even though the C standard doesn't say so) 	     for integers because the value is not affected. 	     For reals, the value might be affected, so we can't.  */
operator|&&
operator|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|||
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PLUS_EXPR
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
block|{
operator|*
name|conp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|varp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|outtype
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
operator|!=
name|outtype
condition|)
operator|*
name|varp
operator|=
name|convert
argument_list|(
name|outtype
argument_list|,
operator|*
name|varp
argument_list|)
expr_stmt|;
operator|*
name|varsignp
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|conp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|varp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|varsignp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|outtype
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
operator|!=
name|outtype
condition|)
operator|*
name|varp
operator|=
name|convert
argument_list|(
name|outtype
argument_list|,
operator|*
name|varp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
comment|/* If operation is subtraction and constant is second, 		 must negate it to get an additive constant. 		 And this cannot be done unless it is a manifest constant. 		 It could also be the address of a static variable. 		 We cannot negate that, so give up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|conp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* Subtracting from integer_zero_node loses for long long.  */
operator|*
name|conp
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|conp
argument_list|)
argument_list|,
operator|*
name|conp
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|conp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|varp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|outtype
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
operator|!=
name|outtype
condition|)
operator|*
name|varp
operator|=
name|convert
argument_list|(
name|outtype
argument_list|,
operator|*
name|varp
argument_list|)
expr_stmt|;
operator|*
name|varsignp
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Combine two constants NUM and ARG2 under operation CODE    to produce a new constant.    We assume ARG1 and ARG2 have the same data type,    or at least are the same kind of constant and the same machine mode.  */
end_comment

begin_function
specifier|static
name|tree
name|const_binop
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|HOST_WIDE_INT
name|int1l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
specifier|register
name|HOST_WIDE_INT
name|int1h
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|int2l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|int2h
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|hi
decl_stmt|;
name|HOST_WIDE_INT
name|garbagel
decl_stmt|,
name|garbageh
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Propagate overflow flags from operands; also record new overflow.  */
name|int
name|overflow
init|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BIT_IOR_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
operator||
name|int2l
argument_list|,
name|int1h
operator||
name|int2h
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
operator|^
name|int2l
argument_list|,
name|int1h
operator|^
name|int2h
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
operator|&
name|int2l
argument_list|,
name|int1h
operator|&
name|int2h
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_ANDTC_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
operator|&
operator|~
name|int2l
argument_list|,
name|int1h
operator|&
operator|~
name|int2h
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LSHIFT_EXPR
case|:
name|overflow
operator|=
name|lshift_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|!
name|uns
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|RROTATE_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LROTATE_EXPR
case|:
name|lrotate_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|int1h
operator|==
literal|0
condition|)
block|{
name|int2l
operator|+=
name|int1l
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2l
operator|<
name|int1l
condition|)
block|{
name|hi
operator|=
name|int2h
operator|++
expr_stmt|;
name|overflow
operator|=
operator|!
name|same_sign
argument_list|(
name|hi
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build_int_2
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int2h
operator|==
literal|0
condition|)
block|{
name|int1l
operator|+=
name|int2l
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1l
operator|<
name|int2l
condition|)
block|{
name|hi
operator|=
name|int1h
operator|++
expr_stmt|;
name|overflow
operator|=
operator|!
name|same_sign
argument_list|(
name|hi
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
block|}
name|overflow
operator|=
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
block|}
name|neg_double
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|low
argument_list|,
name|hi
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|overflow
operator|=
name|overflow_sum_sign
argument_list|(
name|hi
argument_list|,
name|int2h
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
comment|/* Optimize simple cases.  */
if|if
condition|(
name|int1h
operator|==
literal|0
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|temp
decl_stmt|;
switch|switch
condition|(
name|int1l
condition|)
block|{
case|case
literal|0
case|:
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
case|case
literal|1
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
case|case
literal|2
case|:
name|overflow
operator|=
name|left_shift_overflows
argument_list|(
name|int2h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|int2l
operator|+
name|int2l
expr_stmt|;
name|int2h
operator|=
operator|(
name|int2h
operator|<<
literal|1
operator|)
operator|+
operator|(
name|temp
operator|<
name|int2l
operator|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|temp
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
if|#
directive|if
literal|0
comment|/* This code can lose carries.  */
block|case 3: 		  temp = int2l + int2l + int2l; 		  int2h = int2h * 3 + (temp< int2l); 		  t = build_int_2 (temp, int2h); 		  goto got_it;
endif|#
directive|endif
case|case
literal|4
case|:
name|overflow
operator|=
name|left_shift_overflows
argument_list|(
name|int2h
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|temp
operator|=
name|int2l
operator|+
name|int2l
expr_stmt|;
name|int2h
operator|=
operator|(
name|int2h
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|temp
operator|<
name|int2l
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|int2l
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|int2h
operator|+=
operator|(
name|temp
operator|<
name|int2l
operator|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|temp
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
case|case
literal|8
case|:
name|overflow
operator|=
name|left_shift_overflows
argument_list|(
name|int2h
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|temp
operator|=
name|int2l
operator|+
name|int2l
expr_stmt|;
name|int2h
operator|=
operator|(
name|int2h
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|temp
operator|<
name|int2l
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|int2l
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|int2h
operator|+=
operator|(
name|temp
operator|<
name|int2l
operator|)
operator|<<
literal|1
expr_stmt|;
name|int2l
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|int2h
operator|+=
operator|(
name|temp
operator|<
name|int2l
operator|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|temp
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|int2h
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|int2l
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int2l
operator|==
literal|1
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|overflow
operator|=
name|mul_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* This is a shortcut for a common special case. 	     It reduces the number of tree nodes generated 	     and saves time.  */
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|>
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|==
name|sizetype
operator|&&
name|int1h
operator|==
literal|0
operator|&&
name|int1l
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CEIL_DIV_EXPR
condition|)
name|int1l
operator|+=
name|int2l
operator|-
literal|1
expr_stmt|;
return|return
name|size_int
argument_list|(
name|int1l
operator|/
name|int2l
argument_list|)
return|;
block|}
case|case
name|ROUND_DIV_EXPR
case|:
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|1
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int1l
operator|==
name|int2l
operator|&&
name|int1h
operator|==
name|int2h
condition|)
block|{
if|if
condition|(
operator|(
name|int1l
operator||
name|int1h
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|overflow
operator|=
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
name|overflow
operator|=
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|uns
condition|)
block|{
name|low
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1h
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2h
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1h
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2h
operator|)
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1l
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2l
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
operator|(
operator|(
name|int1h
operator|<
name|int2h
operator|)
operator|||
operator|(
operator|(
name|int1h
operator|==
name|int2h
operator|)
operator|&&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int1l
operator|<
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|int2l
operator|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|low
operator|==
operator|(
name|code
operator|==
name|MIN_EXPR
operator|)
condition|)
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_int_2
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|got_it
label|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|overflow
expr_stmt|;
return|return
name|t
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
specifier|register
name|REAL_VALUE_TYPE
name|d1
decl_stmt|;
specifier|register
name|REAL_VALUE_TYPE
name|d2
decl_stmt|;
specifier|register
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|d1
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|float_error
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"floating overflow in constant expression"
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
name|set_float_handler
argument_list|(
name|float_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_ARITHMETIC
argument_list|(
name|value
argument_list|,
name|code
argument_list|,
name|d1
argument_list|,
name|d2
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|value
operator|=
name|d1
operator|+
name|d2
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|value
operator|=
name|d1
operator|-
name|d2
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|value
operator|=
name|d1
operator|*
name|d2
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|d2
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|d1
operator|/
name|d2
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|value
operator|=
name|MIN
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|value
operator|=
name|MAX
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
name|t
operator|=
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
specifier|register
name|tree
name|r1
init|=
name|TREE_REALPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|i1
init|=
name|TREE_IMAGPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|r2
init|=
name|TREE_REALPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|i2
init|=
name|TREE_IMAGPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
block|{
specifier|register
name|tree
name|magsquared
init|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r2
argument_list|,
name|r2
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i2
argument_list|,
name|i2
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_complex
argument_list|(
name|const_binop
argument_list|(
name|RDIV_EXPR
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
argument_list|)
argument_list|,
name|magsquared
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|RDIV_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|)
argument_list|)
argument_list|,
name|magsquared
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an INTEGER_CST with value V and type from `sizetype'.  */
end_comment

begin_function
name|tree
name|size_int
parameter_list|(
name|number
parameter_list|)
name|unsigned
name|int
name|number
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
comment|/* Type-size nodes already made for small sizes.  */
specifier|static
name|tree
name|size_table
index|[
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|number
operator|>=
literal|0
operator|&&
name|number
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|+
literal|1
operator|&&
name|size_table
index|[
name|number
index|]
operator|!=
literal|0
condition|)
return|return
name|size_table
index|[
name|number
index|]
return|;
if|if
condition|(
name|number
operator|>=
literal|0
operator|&&
name|number
operator|<
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|+
literal|1
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
comment|/* Make this a permanent node.  */
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|size_table
index|[
name|number
index|]
operator|=
name|t
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|sizetype
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Combine operands OP1 and OP2 with arithmetic operation CODE.    CODE is a tree code.  Data type is taken from `sizetype',    If the operands are constant, so is the result.  */
end_comment

begin_function
name|tree
name|size_binop
parameter_list|(
name|code
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
block|{
comment|/* Handle the special case of two integer constants faster.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* And some specific cases even faster than that.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|arg0
return|;
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|arg1
return|;
comment|/* Handle general case of two integer constants.  */
return|return
name|const_binop
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
if|if
condition|(
name|arg0
operator|==
name|error_mark_node
operator|||
name|arg1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|sizetype
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given T, a tree representing type conversion of ARG1, a constant,    return a constant tree representing the result of conversion.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert
parameter_list|(
name|t
parameter_list|,
name|arg1
parameter_list|)
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|tree
name|arg1
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Given an integer constant, make new constant with new type, 	     appropriately sign-extended or truncated.  */
name|t
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Carry forward overflow indication unless truncating.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
name|REAL_VALUE_TYPE
name|l
init|=
name|real_value_from_int_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|,
name|x
init|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
decl_stmt|,
name|u
init|=
name|real_value_from_int_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* See if X will be in range after truncation towards 0. 	     To compensate for truncation, move the bounds away from 0, 	     but reject if X exactly equals the adjusted bounds.  */
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_ARITHMETIC
argument_list|(
name|l
argument_list|,
name|MINUS_EXPR
argument_list|,
name|l
argument_list|,
name|dconst1
argument_list|)
expr_stmt|;
name|REAL_ARITHMETIC
argument_list|(
name|u
argument_list|,
name|PLUS_EXPR
argument_list|,
name|u
argument_list|,
name|dconst1
argument_list|)
expr_stmt|;
else|#
directive|else
name|l
operator|--
expr_stmt|;
name|u
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|REAL_VALUES_LESS
argument_list|(
name|l
argument_list|,
name|x
argument_list|)
operator|&&
name|REAL_VALUES_LESS
argument_list|(
name|x
argument_list|,
name|u
argument_list|)
operator|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"real constant out of range for integer conversion"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|HOST_WIDE_INT
name|half_word
init|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
decl_stmt|;
name|d
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|high
operator|=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
name|d
operator|/
name|half_word
operator|/
name|half_word
argument_list|)
expr_stmt|;
name|d
operator|-=
operator|(
name|REAL_VALUE_TYPE
operator|)
name|high
operator|*
name|half_word
operator|*
name|half_word
expr_stmt|;
if|if
condition|(
name|d
operator|>=
operator|(
name|REAL_VALUE_TYPE
operator|)
name|half_word
operator|*
name|half_word
operator|/
literal|2
condition|)
block|{
name|low
operator|=
name|d
operator|-
operator|(
name|REAL_VALUE_TYPE
operator|)
name|half_word
operator|*
name|half_word
operator|/
literal|2
expr_stmt|;
name|low
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
name|low
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
name|d
expr_stmt|;
if|if
condition|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|REAL_VALUE_TO_INT
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|build_real_from_int_cst
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|float_error
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"floating overflow in constant expression"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
name|set_float_handler
argument_list|(
name|float_error
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|real_value_truncate
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an expr equal to X but certainly not valid as an lvalue.  */
end_comment

begin_function
name|tree
name|non_lvalue
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
comment|/* These things are certainly not lvalues.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRING_CST
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|x
return|;
name|result
operator|=
name|build1
argument_list|(
name|NON_LVALUE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a tree comparison code, return the code that is the logical inverse    of the given code.  It is not safe to do this for floating-point    comparisons, except for NE_EXPR and EQ_EXPR.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|invert_tree_comparison
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|NE_EXPR
return|;
case|case
name|NE_EXPR
case|:
return|return
name|EQ_EXPR
return|;
case|case
name|GT_EXPR
case|:
return|return
name|LE_EXPR
return|;
case|case
name|GE_EXPR
case|:
return|return
name|LT_EXPR
return|;
case|case
name|LT_EXPR
case|:
return|return
name|GE_EXPR
return|;
case|case
name|LE_EXPR
case|:
return|return
name|GT_EXPR
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar, but return the comparison that results if the operands are    swapped.  This is safe for floating-point.  */
end_comment

begin_function
specifier|static
name|enum
name|tree_code
name|swap_tree_comparison
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
return|return
name|code
return|;
case|case
name|GT_EXPR
case|:
return|return
name|LT_EXPR
return|;
case|case
name|GE_EXPR
case|:
return|return
name|LE_EXPR
return|;
case|case
name|LT_EXPR
case|:
return|return
name|GT_EXPR
return|;
case|case
name|LE_EXPR
case|:
return|return
name|GE_EXPR
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if two operands are necessarily equal.    If ONLY_CONST is non-zero, only return non-zero for constants.    This function tests whether the operands are indistinguishable;    it does not test whether they are equal using C's == operation.    The distinction is important for IEEE floating point, because    (1) -0.0 and 0.0 are distinguishable, but -0.0==0.0, and    (2) two NaNs may be indistinguishable, but NaN!=NaN.  */
end_comment

begin_function
name|int
name|operand_equal_p
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|,
name|only_const
parameter_list|)
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|int
name|only_const
decl_stmt|;
block|{
comment|/* If both types don't have the same signedness, then we can't consider      them equal.  We must check this before the STRIP_NOPS calls      because they may change the signedness of the arguments.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|STRIP_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.      We don't care about side effects in that case because the SAVE_EXPR      takes care of that for us.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|arg0
operator|==
name|arg1
condition|)
return|return
operator|!
name|only_const
return|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Detect when real constants are equal.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
operator|!
name|bcmp
argument_list|(
operator|&
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|&
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|only_const
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|arg0
operator|==
name|arg1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This is needed for conversions and for COMPONENT_REF.      Might as well play it safe and always test this.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* Two conversions are equal only if signedness and modes match.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'<'
case|:
case|case
literal|'2'
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
literal|'r'
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
return|return
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|BIT_FIELD_REF
case|:
return|return
operator|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar to operand_equal_p, but see if ARG0 might have been made by    shorten_compare from ARG1 when ARG1 was being compared with OTHER.      When in doubt, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|operand_equal_for_comparison_p
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|,
name|other
parameter_list|)
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|tree
name|other
decl_stmt|;
block|{
name|int
name|unsignedp1
decl_stmt|,
name|unsignedpo
decl_stmt|;
name|tree
name|primarg1
decl_stmt|,
name|primother
decl_stmt|;
name|int
name|correct_width
decl_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
return|return
literal|0
return|;
comment|/* Duplicate what shorten_compare does to ARG1 and see if that gives the      actual comparison operand, ARG0.       First throw away any conversions to wider types      already present in the operands.  */
name|primarg1
operator|=
name|get_narrower
argument_list|(
name|arg1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
name|primother
operator|=
name|get_narrower
argument_list|(
name|other
argument_list|,
operator|&
name|unsignedpo
argument_list|)
expr_stmt|;
name|correct_width
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp1
operator|==
name|unsignedpo
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primarg1
argument_list|)
argument_list|)
operator|<
name|correct_width
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primother
argument_list|)
argument_list|)
operator|<
name|correct_width
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primarg1
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primarg1
argument_list|)
argument_list|)
argument_list|,
name|primarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|primarg1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if ARG is an expression that is either a comparison or is performing    arithmetic on comparisons.  The comparisons must only be comparing    two different values, which will be stored in *CVAL1 and *CVAL2; if    they are non-zero it means that some operands have already been found.    No variables may be used anywhere else in the expression except in the    comparisons.     If this is true, return 1.  Otherwise, return zero.  */
end_comment

begin_function
specifier|static
name|int
name|twoval_comparison_p
parameter_list|(
name|arg
parameter_list|,
name|cval1
parameter_list|,
name|cval2
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|tree
modifier|*
name|cval1
decl_stmt|,
decl|*
name|cval2
decl_stmt|;
end_function

begin_block
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|char
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* We can handle some of the 'e' cases here.  */
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
operator|(
name|code
operator|==
name|TRUTH_NOT_EXPR
operator|||
operator|(
name|code
operator|==
name|SAVE_EXPR
operator|&&
name|SAVE_EXPR_RTL
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|class
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|COMPOUND_EXPR
operator|)
condition|)
name|class
operator|=
literal|'2'
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
return|;
case|case
literal|'2'
case|:
return|return
operator|(
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
operator|)
return|;
case|case
literal|'c'
case|:
return|return
literal|1
return|;
case|case
literal|'e'
case|:
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
return|return
operator|(
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
operator|&&
name|twoval_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
case|case
literal|'<'
case|:
comment|/* First see if we can handle the first operand, then the second.  For 	 the second operand, we know *CVAL1 can't be zero.  It must be that 	 one side of the comparison is each of the values; test for the 	 case where this isn't true by failing if the two operands 	 are the same.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|cval1
operator|==
literal|0
condition|)
operator|*
name|cval1
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cval2
operator|==
literal|0
condition|)
operator|*
name|cval2
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cval2
operator|==
literal|0
condition|)
operator|*
name|cval2
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
operator|*
name|cval2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ARG is a tree that is known to contain just arithmetic operations and    comparisons.  Evaluate the operations in the tree substituting NEW0 for    any occurrence of OLD0 as an operand of a comparison and likewise for    NEW1 and OLD1.  */
end_comment

begin_function
specifier|static
name|tree
name|eval_subst
parameter_list|(
name|arg
parameter_list|,
name|old0
parameter_list|,
name|new0
parameter_list|,
name|old1
parameter_list|,
name|new1
parameter_list|)
name|tree
name|arg
decl_stmt|;
name|tree
name|old0
decl_stmt|,
name|new0
decl_stmt|,
name|old1
decl_stmt|,
name|new1
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|char
name|class
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* We can handle some of the 'e' cases here.  */
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|class
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
literal|'e'
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|)
condition|)
name|class
operator|=
literal|'2'
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'1'
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|'2'
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
literal|'e'
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SAVE_EXPR
case|:
return|return
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|,
name|eval_subst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|,
name|old0
argument_list|,
name|new0
argument_list|,
name|old1
argument_list|,
name|new1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
case|case
literal|'<'
case|:
block|{
name|tree
name|arg0
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We need to check both for exact equality and tree equality.  The 	   former will be true if the operand has a side-effect.  In that 	   case, we know the operand occurred exactly once.  */
if|if
condition|(
name|arg0
operator|==
name|old0
operator|||
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|old0
argument_list|,
literal|0
argument_list|)
condition|)
name|arg0
operator|=
name|new0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg0
operator|==
name|old1
operator|||
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|old1
argument_list|,
literal|0
argument_list|)
condition|)
name|arg0
operator|=
name|new1
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|old0
operator|||
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|old0
argument_list|,
literal|0
argument_list|)
condition|)
name|arg1
operator|=
name|new0
expr_stmt|;
elseif|else
if|if
condition|(
name|arg1
operator|==
name|old1
operator|||
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|old1
argument_list|,
literal|0
argument_list|)
condition|)
name|arg1
operator|=
name|new1
expr_stmt|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|arg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the case when the result of an expression is RESULT    converted to TYPE and OMITTED was previously an operand of the expression    but is now not needed (e.g., we folded OMITTED * 0).     If OMITTED has side effects, we must evaluate it.  Otherwise, just do    the conversion of RESULT to TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|omit_one_operand
parameter_list|(
name|type
parameter_list|,
name|result
parameter_list|,
name|omitted
parameter_list|)
name|tree
name|type
decl_stmt|,
name|result
decl_stmt|,
name|omitted
decl_stmt|;
block|{
name|tree
name|t
init|=
name|convert
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|omitted
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|omitted
argument_list|,
name|t
argument_list|)
return|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a simplified tree node for the truth-negation of ARG.  This    never alters ARG itself.  We assume that ARG is an operation that    returns a truth value (0 or 1).  */
end_comment

begin_function
name|tree
name|invert_truthvalue
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* If this is a comparison, we can simply invert it, except for      floating-point non-equality comparisons, in which case we just      enclose a TRUTH_NOT_EXPR around what we have.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|code
operator|!=
name|NE_EXPR
operator|&&
name|code
operator|!=
name|EQ_EXPR
condition|)
return|return
name|build1
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
return|;
else|else
return|return
name|build
argument_list|(
name|invert_tree_comparison
argument_list|(
name|code
argument_list|)
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_AND_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_OR_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_OR_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_AND_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ORIF_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
return|return
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
return|return
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|type
argument_list|,
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
operator|!
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a bit-wise operation CODE applied to ARG0 and ARG1, see if both    operands are another bit-wise operation with a common input.  If so,    distribute the bit operations to save an operation and possibly two if    constants are involved.  For example, convert    	(A | B)& (A | C) into A | (B& C)    Further simplification will occur if B and C are constants.     If this optimization cannot be done, 0 will be returned.  */
end_comment

begin_function
specifier|static
name|tree
name|distribute_bit_expr
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
block|{
name|tree
name|common
decl_stmt|;
name|tree
name|left
decl_stmt|,
name|right
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|BIT_IOR_EXPR
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|common
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|type
argument_list|,
name|common
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER    starting at BITPOS.  The field is unsigned if UNSIGNEDP is non-zero.  */
end_comment

begin_function
specifier|static
name|tree
name|make_bit_field_ref
parameter_list|(
name|inner
parameter_list|,
name|type
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|unsignedp
parameter_list|)
name|tree
name|inner
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|result
init|=
name|build
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|type
argument_list|,
name|inner
argument_list|,
name|size_int
argument_list|(
name|bitsize
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|bitpos
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|result
argument_list|)
operator|=
name|unsignedp
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Optimize a bit-field compare.     There are two cases:  First is a compare against a constant and the    second is a comparison of two items where the fields are at the same    bit position relative to the start of a chunk (byte, halfword, word)    large enough to contain it.  In these cases we can avoid the shift    implicit in bitfield extractions.     For constants, we emit a compare of the shifted constant with the    BIT_AND_EXPR of a mask and a byte, halfword, or word of the operand being    compared.  For two fields at the same position, we do the ANDs with the    similar mask and compare the result of the ANDs.     CODE is the comparison code, known to be either NE_EXPR or EQ_EXPR.    COMPARE_TYPE is the type of the comparison, and LHS and RHS    are the left and right operands of the comparison, respectively.     If the optimization described above can be done, we return the resulting    tree.  Otherwise we return zero.  */
end_comment

begin_function
specifier|static
name|tree
name|optimize_bit_field_compare
parameter_list|(
name|code
parameter_list|,
name|compare_type
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|compare_type
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
block|{
name|int
name|lbitpos
decl_stmt|,
name|lbitsize
decl_stmt|,
name|rbitpos
decl_stmt|,
name|rbitsize
decl_stmt|;
name|int
name|lnbitpos
decl_stmt|,
name|lnbitsize
decl_stmt|,
name|rnbitpos
decl_stmt|,
name|rnbitsize
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|tree
name|signed_type
decl_stmt|,
name|unsigned_type
decl_stmt|;
name|int
name|const_p
init|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|INTEGER_CST
decl_stmt|;
name|enum
name|machine_mode
name|lmode
decl_stmt|,
name|rmode
decl_stmt|,
name|lnmode
decl_stmt|,
name|rnmode
decl_stmt|;
name|int
name|lunsignedp
decl_stmt|,
name|runsignedp
decl_stmt|;
name|int
name|lvolatilep
init|=
literal|0
decl_stmt|,
name|rvolatilep
init|=
literal|0
decl_stmt|;
name|tree
name|linner
decl_stmt|,
name|rinner
decl_stmt|;
name|tree
name|mask
decl_stmt|;
name|tree
name|offset
decl_stmt|;
comment|/* Get all the information about the extractions being done.  If the bit size      if the same as the size of the underlying object, we aren't doing an      extraction at all and so can do nothing.  */
name|linner
operator|=
name|get_inner_reference
argument_list|(
name|lhs
argument_list|,
operator|&
name|lbitsize
argument_list|,
operator|&
name|lbitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|lmode
argument_list|,
operator|&
name|lunsignedp
argument_list|,
operator|&
name|lvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|lmode
argument_list|)
operator|||
name|lbitsize
operator|<
literal|0
operator|||
name|offset
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|const_p
condition|)
block|{
comment|/* If this is not a constant, we can only do something if bit positions, 	sizes, and signedness are the same.   */
name|rinner
operator|=
name|get_inner_reference
argument_list|(
name|rhs
argument_list|,
operator|&
name|rbitsize
argument_list|,
operator|&
name|rbitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|rmode
argument_list|,
operator|&
name|runsignedp
argument_list|,
operator|&
name|rvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbitpos
operator|!=
name|rbitpos
operator|||
name|lbitsize
operator|!=
name|rbitsize
operator|||
name|lunsignedp
operator|!=
name|runsignedp
operator|||
name|offset
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* See if we can find a mode to refer to this field.  We should be able to,      but fail if we can't.  */
name|lnmode
operator|=
name|get_best_mode
argument_list|(
name|lbitsize
argument_list|,
name|lbitpos
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|linner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|lvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Set signed and unsigned types of the precision of this mode for the      shifts below.  */
name|signed_type
operator|=
name|type_for_mode
argument_list|(
name|lnmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsigned_type
operator|=
name|type_for_mode
argument_list|(
name|lnmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|const_p
condition|)
block|{
name|rnmode
operator|=
name|get_best_mode
argument_list|(
name|rbitsize
argument_list|,
name|rbitpos
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|rinner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|rvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
block|}
comment|/* Compute the bit position and size for the new reference and our offset      within it. If the new reference is the same size as the original, we      won't optimize anything, so return zero.  */
name|lnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|lnmode
argument_list|)
expr_stmt|;
name|lnbitpos
operator|=
name|lbitpos
operator|&
operator|~
operator|(
name|lnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|lbitpos
operator|-=
name|lnbitpos
expr_stmt|;
if|if
condition|(
name|lnbitsize
operator|==
name|lbitsize
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|const_p
condition|)
block|{
name|rnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|rnmode
argument_list|)
expr_stmt|;
name|rnbitpos
operator|=
name|rbitpos
operator|&
operator|~
operator|(
name|rnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|rbitpos
operator|-=
name|rnbitpos
expr_stmt|;
if|if
condition|(
name|rnbitsize
operator|==
name|rbitsize
condition|)
return|return
literal|0
return|;
block|}
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|lbitpos
operator|=
name|lnbitsize
operator|-
name|lbitsize
operator|-
name|lbitpos
expr_stmt|;
endif|#
directive|endif
comment|/* Make the mask to be used against the extracted field.  */
name|mask
operator|=
name|convert
argument_list|(
name|unsigned_type
argument_list|,
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|lnbitsize
operator|-
name|lbitsize
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|lnbitsize
operator|-
name|lbitsize
operator|-
name|lbitpos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|const_p
condition|)
comment|/* If not comparing with constant, just rework the comparison        and return.  */
return|return
name|build
argument_list|(
name|code
argument_list|,
name|compare_type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|linner
argument_list|,
name|unsigned_type
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|rinner
argument_list|,
name|unsigned_type
argument_list|,
name|rnbitsize
argument_list|,
name|rnbitpos
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
return|;
comment|/* Otherwise, we are handling the constant case. See if the constant is too      big for the field.  Warn and return a tree of for 0 (false) if so.  We do      this not only for its own sake, but to avoid having to test for this      error case below.  If we didn't, we might generate wrong code.       For unsigned fields, the constant shifted right by the field length should      be all zero.  For signed fields, the high-order bits should agree with       the sign bit.  */
if|if
condition|(
name|lunsignedp
condition|)
block|{
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|unsigned_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitsize
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %s due to width of bitfield"
argument_list|,
name|code
operator|==
name|NE_EXPR
condition|?
literal|"one"
else|:
literal|"zero"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|compare_type
argument_list|,
operator|(
name|code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|tree
name|tem
init|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|signed_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitsize
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|integer_all_onesp
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"comparison is always %s due to width of bitfield"
argument_list|,
name|code
operator|==
name|NE_EXPR
condition|?
literal|"one"
else|:
literal|"zero"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|compare_type
argument_list|,
operator|(
name|code
operator|==
name|NE_EXPR
condition|?
name|integer_one_node
else|:
name|integer_zero_node
operator|)
argument_list|)
return|;
block|}
block|}
comment|/* Single-bit compares should always be against zero.  */
if|if
condition|(
name|lbitsize
operator|==
literal|1
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
name|code
operator|=
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
expr_stmt|;
name|rhs
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
block|}
comment|/* Make a new bitfield reference, shift the constant over the      appropriate number of bits and mask it with the computed mask      (in case this was a signed field).  If we changed it, make a new one.  */
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|linner
argument_list|,
name|unsigned_type
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|fold
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|unsigned_type
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|lbitpos
argument_list|)
argument_list|)
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|compare_type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|unsigned_type
argument_list|,
name|lhs
argument_list|,
name|mask
argument_list|)
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine for fold_truthop: decode a field reference.     If EXP is a comparison reference, we return the innermost reference.     *PBITSIZE is set to the number of bits in the reference, *PBITPOS is    set to the starting bit number.     If the innermost field can be completely contained in a mode-sized    unit, *PMODE is set to that mode.  Otherwise, it is set to VOIDmode.     *PVOLATILEP is set to 1 if the any expression encountered is volatile;    otherwise it is not changed.     *PUNSIGNEDP is set to the signedness of the field.     *PMASK is set to the mask used.  This is either contained in a    BIT_AND_EXPR or derived from the width of the field.     Return 0 if this is not a component reference or is one that we can't    do anything with.  */
end_comment

begin_function
specifier|static
name|tree
name|decode_field_reference
parameter_list|(
name|exp
parameter_list|,
name|pbitsize
parameter_list|,
name|pbitpos
parameter_list|,
name|pmode
parameter_list|,
name|punsignedp
parameter_list|,
name|pvolatilep
parameter_list|,
name|pmask
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
modifier|*
name|pbitsize
decl_stmt|,
decl|*
name|pbitpos
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|punsignedp
decl_stmt|,
modifier|*
name|pvolatilep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
modifier|*
name|pmask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|mask
init|=
literal|0
decl_stmt|;
name|tree
name|inner
decl_stmt|;
name|tree
name|offset
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
name|mask
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|mask
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|BIT_FIELD_REF
condition|)
return|return
literal|0
return|;
name|inner
operator|=
name|get_inner_reference
argument_list|(
name|exp
argument_list|,
name|pbitsize
argument_list|,
name|pbitpos
argument_list|,
operator|&
name|offset
argument_list|,
name|pmode
argument_list|,
name|punsignedp
argument_list|,
name|pvolatilep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pbitsize
operator|<
literal|0
operator|||
name|offset
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|tree
name|unsigned_type
init|=
name|type_for_size
argument_list|(
operator|*
name|pbitsize
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type
argument_list|)
decl_stmt|;
name|mask
operator|=
name|convert
argument_list|(
name|unsigned_type
argument_list|,
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
operator|*
name|pbitsize
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mask
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
operator|*
name|pbitsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|pmask
operator|=
name|mask
expr_stmt|;
return|return
name|inner
return|;
block|}
end_block

begin_comment
comment|/* Return non-zero if MASK represents a mask of SIZE ones in the low-order    bit positions.  */
end_comment

begin_function
specifier|static
name|int
name|all_ones_mask_p
parameter_list|(
name|mask
parameter_list|,
name|size
parameter_list|)
name|tree
name|mask
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|mask
argument_list|)
decl_stmt|;
name|int
name|precision
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|operand_equal_p
argument_list|(
name|mask
argument_list|,
name|const_binop
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
operator|~
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|precision
operator|-
name|size
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for fold_truthop: determine if an operand is simple enough    to be evaluated unconditionally.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
endif|#
directive|endif
specifier|static
name|int
name|simple_operand_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* Strip any conversions that don't change the machine mode.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|DECL_NONLOCAL
argument_list|(
name|exp
argument_list|)
comment|/* Don't regard global variables as simple.  They may be 		 allocated in ways unknown to the compiler (shared memory, 		 #pragma weak, etc).  */
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|exp
argument_list|)
comment|/* Loading a static variable is unduly expensive, but global 		 registers aren't expensive.  */
operator|&&
operator|(
operator|!
name|TREE_STATIC
argument_list|(
name|exp
argument_list|)
operator|||
name|DECL_REGISTER
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine for fold_truthop: try to optimize a range test.     For example, "i>= 2&& i =< 9" can be done as "(unsigned) (i - 2)<= 7".     JCODE is the logical combination of the two terms.  It is TRUTH_AND_EXPR    (representing TRUTH_ANDIF_EXPR and TRUTH_AND_EXPR) or TRUTH_OR_EXPR    (representing TRUTH_ORIF_EXPR and TRUTH_OR_EXPR).  TYPE is the type of    the result.     VAR is the value being tested.  LO_CODE and HI_CODE are the comparison    operators comparing VAR to LO_CST and HI_CST.  LO_CST is known to be no    larger than HI_CST (they may be equal).     We return the simplified tree or 0 if no optimization is possible.  */
end_comment

begin_function
name|tree
name|range_test
parameter_list|(
name|jcode
parameter_list|,
name|type
parameter_list|,
name|lo_code
parameter_list|,
name|hi_code
parameter_list|,
name|var
parameter_list|,
name|lo_cst
parameter_list|,
name|hi_cst
parameter_list|)
name|enum
name|tree_code
name|jcode
decl_stmt|,
name|lo_code
decl_stmt|,
name|hi_code
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|var
decl_stmt|,
name|lo_cst
decl_stmt|,
name|hi_cst
decl_stmt|;
block|{
name|tree
name|utype
decl_stmt|;
name|enum
name|tree_code
name|rcode
decl_stmt|;
comment|/* See if this is a range test and normalize the constant terms.  */
if|if
condition|(
name|jcode
operator|==
name|TRUTH_AND_EXPR
condition|)
block|{
switch|switch
condition|(
name|lo_code
condition|)
block|{
case|case
name|NE_EXPR
case|:
comment|/* See if we have VAR != CST&& VAR != CST+1.  */
if|if
condition|(
operator|!
operator|(
name|hi_code
operator|==
name|NE_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|hi_cst
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|lo_cst
argument_list|)
operator|==
literal|1
operator|&&
name|tree_int_cst_equal
argument_list|(
name|integer_one_node
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|hi_cst
argument_list|,
name|lo_cst
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|rcode
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|hi_code
operator|==
name|LT_EXPR
condition|)
name|hi_cst
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|hi_cst
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hi_code
operator|!=
name|LE_EXPR
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lo_code
operator|==
name|GT_EXPR
condition|)
name|lo_cst
operator|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|lo_cst
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* We now have VAR>= LO_CST&& VAR<= HI_CST.  */
name|rcode
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|lo_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
comment|/* See if we have VAR == CST || VAR == CST+1.  */
if|if
condition|(
operator|!
operator|(
name|hi_code
operator|==
name|EQ_EXPR
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|hi_cst
argument_list|)
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|lo_cst
argument_list|)
operator|==
literal|1
operator|&&
name|tree_int_cst_equal
argument_list|(
name|integer_one_node
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|hi_cst
argument_list|,
name|lo_cst
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|rcode
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|hi_code
operator|==
name|GE_EXPR
condition|)
name|hi_cst
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|hi_cst
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hi_code
operator|!=
name|GT_EXPR
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lo_code
operator|==
name|LE_EXPR
condition|)
name|lo_cst
operator|=
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|lo_cst
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
comment|/* We now have VAR< LO_CST || VAR> HI_CST.  */
name|rcode
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
comment|/* When normalizing, it is possible to both increment the smaller constant      and decrement the larger constant.  See if they are still ordered.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|hi_cst
argument_list|,
name|lo_cst
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Fail if VAR isn't an integer.  */
name|utype
operator|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|utype
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|utype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
return|return
literal|0
return|;
comment|/* The range test is invalid if subtracting the two constants results      in overflow.  This can happen in traditional mode.  */
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|hi_cst
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|lo_cst
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|utype
argument_list|)
condition|)
block|{
name|utype
operator|=
name|unsigned_type
argument_list|(
name|utype
argument_list|)
expr_stmt|;
name|var
operator|=
name|convert
argument_list|(
name|utype
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|lo_cst
operator|=
name|convert
argument_list|(
name|utype
argument_list|,
name|lo_cst
argument_list|)
expr_stmt|;
name|hi_cst
operator|=
name|convert
argument_list|(
name|utype
argument_list|,
name|hi_cst
argument_list|)
expr_stmt|;
block|}
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|rcode
argument_list|,
name|utype
argument_list|,
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|utype
argument_list|,
name|var
argument_list|,
name|lo_cst
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|hi_cst
argument_list|,
name|lo_cst
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find ways of folding logical expressions of LHS and RHS:    Try to merge two comparisons to the same innermost item.    Look for range tests like "ch>= '0'&& ch<= '9'".    Look for combinations of simple terms on machines with expensive branches    and evaluate the RHS unconditionally.     For example, if we have p->a == 2&& p->b == 4 and we can make an    object large enough to span both A and B, we can do this with a comparison    against the object ANDed with the a mask.     If we have p->a == q->a&& p->b == q->b, we may be able to use bit masking    operations to do this with one comparison.     We check for both normal comparisons and the BIT_AND_EXPRs made this by    function and the one above.     CODE is the logical operation being done.  It can be TRUTH_ANDIF_EXPR,    TRUTH_AND_EXPR, TRUTH_ORIF_EXPR, or TRUTH_OR_EXPR.     TRUTH_TYPE is the type of the logical operand and LHS and RHS are its    two operands.     We return the simplified tree or 0 if no optimization is possible.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_truthop
parameter_list|(
name|code
parameter_list|,
name|truth_type
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|truth_type
decl_stmt|,
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
block|{
comment|/* If this is the "or" of two comparisons, we can do something if we      the comparisons are NE_EXPR.  If this is the "and", we can do something      if the comparisons are EQ_EXPR.  I.e.,       	(a->b == 2&& a->c == 4) can become (a->new == NEW).       WANTED_CODE is this operation code.  For single bit fields, we can      convert EQ_EXPR to NE_EXPR so we need not reject the "wrong"      comparison for one-bit fields.  */
name|enum
name|tree_code
name|wanted_code
decl_stmt|;
name|enum
name|tree_code
name|lcode
decl_stmt|,
name|rcode
decl_stmt|;
name|tree
name|ll_arg
decl_stmt|,
name|lr_arg
decl_stmt|,
name|rl_arg
decl_stmt|,
name|rr_arg
decl_stmt|;
name|tree
name|ll_inner
decl_stmt|,
name|lr_inner
decl_stmt|,
name|rl_inner
decl_stmt|,
name|rr_inner
decl_stmt|;
name|int
name|ll_bitsize
decl_stmt|,
name|ll_bitpos
decl_stmt|,
name|lr_bitsize
decl_stmt|,
name|lr_bitpos
decl_stmt|;
name|int
name|rl_bitsize
decl_stmt|,
name|rl_bitpos
decl_stmt|,
name|rr_bitsize
decl_stmt|,
name|rr_bitpos
decl_stmt|;
name|int
name|xll_bitpos
decl_stmt|,
name|xlr_bitpos
decl_stmt|,
name|xrl_bitpos
decl_stmt|,
name|xrr_bitpos
decl_stmt|;
name|int
name|lnbitsize
decl_stmt|,
name|lnbitpos
decl_stmt|,
name|rnbitsize
decl_stmt|,
name|rnbitpos
decl_stmt|;
name|int
name|ll_unsignedp
decl_stmt|,
name|lr_unsignedp
decl_stmt|,
name|rl_unsignedp
decl_stmt|,
name|rr_unsignedp
decl_stmt|;
name|enum
name|machine_mode
name|ll_mode
decl_stmt|,
name|lr_mode
decl_stmt|,
name|rl_mode
decl_stmt|,
name|rr_mode
decl_stmt|;
name|enum
name|machine_mode
name|lnmode
decl_stmt|,
name|rnmode
decl_stmt|;
name|tree
name|ll_mask
decl_stmt|,
name|lr_mask
decl_stmt|,
name|rl_mask
decl_stmt|,
name|rr_mask
decl_stmt|;
name|tree
name|l_const
decl_stmt|,
name|r_const
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|result
decl_stmt|;
name|int
name|first_bit
decl_stmt|,
name|end_bit
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
comment|/* Start by getting the comparison codes and seeing if this looks like      a range test.  Fail if anything is volatile.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|lhs
argument_list|)
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
literal|0
return|;
name|lcode
operator|=
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|lcode
argument_list|)
operator|!=
literal|'<'
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|rcode
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|code
operator|=
operator|(
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
operator|||
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|)
condition|?
name|TRUTH_AND_EXPR
else|:
name|TRUTH_OR_EXPR
operator|)
expr_stmt|;
name|ll_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lr_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rl_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rr_arg
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lr_arg
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|rr_arg
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|operand_equal_p
argument_list|(
name|ll_arg
argument_list|,
name|rl_arg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|lr_arg
argument_list|,
name|rr_arg
argument_list|)
condition|)
name|result
operator|=
name|range_test
argument_list|(
name|code
argument_list|,
name|truth_type
argument_list|,
name|lcode
argument_list|,
name|rcode
argument_list|,
name|ll_arg
argument_list|,
name|lr_arg
argument_list|,
name|rr_arg
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|range_test
argument_list|(
name|code
argument_list|,
name|truth_type
argument_list|,
name|rcode
argument_list|,
name|lcode
argument_list|,
name|ll_arg
argument_list|,
name|rr_arg
argument_list|,
name|lr_arg
argument_list|)
expr_stmt|;
comment|/* If this isn't a range test, it also isn't a comparison that 	 can be merged.  However, it wins to evaluate the RHS unconditionally 	 on machines with expensive branches.   */
if|if
condition|(
name|result
operator|==
literal|0
operator|&&
name|BRANCH_COST
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ll_arg
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|ll_arg
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
comment|/* Avoid evaluating the variable part twice.  */
name|ll_arg
operator|=
name|save_expr
argument_list|(
name|ll_arg
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|build
argument_list|(
name|lcode
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|ll_arg
argument_list|,
name|lr_arg
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|build
argument_list|(
name|rcode
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|ll_arg
argument_list|,
name|rr_arg
argument_list|)
expr_stmt|;
block|}
return|return
name|build
argument_list|(
name|code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
return|return
name|result
return|;
block|}
comment|/* If the RHS can be evaluated unconditionally and its operands are      simple, it wins to evaluate the RHS unconditionally on machines      with expensive branches.  In this case, this isn't a comparison      that can be merged.  */
comment|/* @@ I'm not sure it wins on the m88110 to do this if the comparisons      are with zero (tmw).  */
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|simple_operand_p
argument_list|(
name|rl_arg
argument_list|)
operator|&&
name|simple_operand_p
argument_list|(
name|rr_arg
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
comment|/* See if the comparisons can be merged.  Then get all the parameters for      each side.  */
if|if
condition|(
operator|(
name|lcode
operator|!=
name|EQ_EXPR
operator|&&
name|lcode
operator|!=
name|NE_EXPR
operator|)
operator|||
operator|(
name|rcode
operator|!=
name|EQ_EXPR
operator|&&
name|rcode
operator|!=
name|NE_EXPR
operator|)
condition|)
return|return
literal|0
return|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|ll_inner
operator|=
name|decode_field_reference
argument_list|(
name|ll_arg
argument_list|,
operator|&
name|ll_bitsize
argument_list|,
operator|&
name|ll_bitpos
argument_list|,
operator|&
name|ll_mode
argument_list|,
operator|&
name|ll_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|ll_mask
argument_list|)
expr_stmt|;
name|lr_inner
operator|=
name|decode_field_reference
argument_list|(
name|lr_arg
argument_list|,
operator|&
name|lr_bitsize
argument_list|,
operator|&
name|lr_bitpos
argument_list|,
operator|&
name|lr_mode
argument_list|,
operator|&
name|lr_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|lr_mask
argument_list|)
expr_stmt|;
name|rl_inner
operator|=
name|decode_field_reference
argument_list|(
name|rl_arg
argument_list|,
operator|&
name|rl_bitsize
argument_list|,
operator|&
name|rl_bitpos
argument_list|,
operator|&
name|rl_mode
argument_list|,
operator|&
name|rl_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|rl_mask
argument_list|)
expr_stmt|;
name|rr_inner
operator|=
name|decode_field_reference
argument_list|(
name|rr_arg
argument_list|,
operator|&
name|rr_bitsize
argument_list|,
operator|&
name|rr_bitpos
argument_list|,
operator|&
name|rr_mode
argument_list|,
operator|&
name|rr_unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
operator|&
name|rr_mask
argument_list|)
expr_stmt|;
comment|/* It must be true that the inner operation on the lhs of each      comparison must be the same if we are to be able to do anything.      Then see if we have constants.  If not, the same must be true for      the rhs's.  */
if|if
condition|(
name|volatilep
operator|||
name|ll_inner
operator|==
literal|0
operator|||
name|rl_inner
operator|==
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|ll_inner
argument_list|,
name|rl_inner
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lr_arg
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|rr_arg
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|l_const
operator|=
name|lr_arg
operator|,
name|r_const
operator|=
name|rr_arg
expr_stmt|;
elseif|else
if|if
condition|(
name|lr_inner
operator|==
literal|0
operator|||
name|rr_inner
operator|==
literal|0
operator|||
operator|!
name|operand_equal_p
argument_list|(
name|lr_inner
argument_list|,
name|rr_inner
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|l_const
operator|=
name|r_const
operator|=
literal|0
expr_stmt|;
comment|/* If either comparison code is not correct for our logical operation,      fail.  However, we can convert a one-bit comparison against zero into      the opposite comparison against that bit being set in the field.  */
name|wanted_code
operator|=
operator|(
name|code
operator|==
name|TRUTH_AND_EXPR
condition|?
name|EQ_EXPR
else|:
name|NE_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|lcode
operator|!=
name|wanted_code
condition|)
block|{
if|if
condition|(
name|l_const
operator|&&
name|integer_zerop
argument_list|(
name|l_const
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|ll_mask
argument_list|)
condition|)
name|l_const
operator|=
name|ll_mask
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|rcode
operator|!=
name|wanted_code
condition|)
block|{
if|if
condition|(
name|r_const
operator|&&
name|integer_zerop
argument_list|(
name|r_const
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|rl_mask
argument_list|)
condition|)
name|r_const
operator|=
name|rl_mask
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
comment|/* See if we can find a mode that contains both fields being compared on      the left.  If we can't, fail.  Otherwise, update all constants and masks      to be relative to a field of that size.  */
name|first_bit
operator|=
name|MIN
argument_list|(
name|ll_bitpos
argument_list|,
name|rl_bitpos
argument_list|)
expr_stmt|;
name|end_bit
operator|=
name|MAX
argument_list|(
name|ll_bitpos
operator|+
name|ll_bitsize
argument_list|,
name|rl_bitpos
operator|+
name|rl_bitsize
argument_list|)
expr_stmt|;
name|lnmode
operator|=
name|get_best_mode
argument_list|(
name|end_bit
operator|-
name|first_bit
argument_list|,
name|first_bit
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|ll_inner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|lnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|lnmode
argument_list|)
expr_stmt|;
name|lnbitpos
operator|=
name|first_bit
operator|&
operator|~
operator|(
name|lnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|type
operator|=
name|type_for_size
argument_list|(
name|lnbitsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xll_bitpos
operator|=
name|ll_bitpos
operator|-
name|lnbitpos
operator|,
name|xrl_bitpos
operator|=
name|rl_bitpos
operator|-
name|lnbitpos
expr_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|xll_bitpos
operator|=
name|lnbitsize
operator|-
name|xll_bitpos
operator|-
name|ll_bitsize
expr_stmt|;
name|xrl_bitpos
operator|=
name|lnbitsize
operator|-
name|xrl_bitpos
operator|-
name|rl_bitsize
expr_stmt|;
endif|#
directive|endif
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|ll_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xll_bitpos
argument_list|)
argument_list|)
expr_stmt|;
name|rl_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|rl_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrl_bitpos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the constants are interpreted as unsigned, so we      don't have sign bits outside the range of their type.  */
if|if
condition|(
name|l_const
condition|)
block|{
name|l_const
operator|=
name|convert
argument_list|(
name|unsigned_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|l_const
argument_list|)
argument_list|)
argument_list|,
name|l_const
argument_list|)
expr_stmt|;
name|l_const
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|l_const
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xll_bitpos
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_const
condition|)
block|{
name|r_const
operator|=
name|convert
argument_list|(
name|unsigned_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|r_const
argument_list|)
argument_list|)
argument_list|,
name|r_const
argument_list|)
expr_stmt|;
name|r_const
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|r_const
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrl_bitpos
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the right sides are not constant, do the same for it.  Also,      disallow this optimization if a size or signedness mismatch occurs      between the left and right sides.  */
if|if
condition|(
name|l_const
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ll_bitsize
operator|!=
name|lr_bitsize
operator|||
name|rl_bitsize
operator|!=
name|rr_bitsize
operator|||
name|ll_unsignedp
operator|!=
name|lr_unsignedp
operator|||
name|rl_unsignedp
operator|!=
name|rr_unsignedp
comment|/* Make sure the two fields on the right 	     correspond to the left without being swapped.  */
operator|||
name|ll_bitpos
operator|-
name|rl_bitpos
operator|!=
name|lr_bitpos
operator|-
name|rr_bitpos
condition|)
return|return
literal|0
return|;
name|first_bit
operator|=
name|MIN
argument_list|(
name|lr_bitpos
argument_list|,
name|rr_bitpos
argument_list|)
expr_stmt|;
name|end_bit
operator|=
name|MAX
argument_list|(
name|lr_bitpos
operator|+
name|lr_bitsize
argument_list|,
name|rr_bitpos
operator|+
name|rr_bitsize
argument_list|)
expr_stmt|;
name|rnmode
operator|=
name|get_best_mode
argument_list|(
name|end_bit
operator|-
name|first_bit
argument_list|,
name|first_bit
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|lr_inner
argument_list|)
argument_list|)
argument_list|,
name|word_mode
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnmode
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
name|rnbitsize
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|rnmode
argument_list|)
expr_stmt|;
name|rnbitpos
operator|=
name|first_bit
operator|&
operator|~
operator|(
name|rnbitsize
operator|-
literal|1
operator|)
expr_stmt|;
name|xlr_bitpos
operator|=
name|lr_bitpos
operator|-
name|rnbitpos
operator|,
name|xrr_bitpos
operator|=
name|rr_bitpos
operator|-
name|rnbitpos
expr_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|xlr_bitpos
operator|=
name|rnbitsize
operator|-
name|xlr_bitpos
operator|-
name|lr_bitsize
expr_stmt|;
name|xrr_bitpos
operator|=
name|rnbitsize
operator|-
name|xrr_bitpos
operator|-
name|rr_bitsize
expr_stmt|;
endif|#
directive|endif
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|lr_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xlr_bitpos
argument_list|)
argument_list|)
expr_stmt|;
name|rr_mask
operator|=
name|const_binop
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|rr_mask
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|xrr_bitpos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a mask that corresponds to both fields being compared. 	 Do this for both items being compared.  If the masks agree, 	 we can do this by masking both and comparing the masked 	 results.  */
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|)
expr_stmt|;
name|lr_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|lr_mask
argument_list|,
name|rr_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand_equal_p
argument_list|(
name|ll_mask
argument_list|,
name|lr_mask
argument_list|,
literal|0
argument_list|)
operator|&&
name|lnbitsize
operator|==
name|rnbitsize
condition|)
block|{
name|lhs
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|type
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
name|ll_unsignedp
operator|||
name|rl_unsignedp
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|make_bit_field_ref
argument_list|(
name|lr_inner
argument_list|,
name|type
argument_list|,
name|rnbitsize
argument_list|,
name|rnbitpos
argument_list|,
name|lr_unsignedp
operator|||
name|rr_unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|lnbitsize
argument_list|)
condition|)
block|{
name|lhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|lhs
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|rhs
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
block|}
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
return|;
block|}
comment|/* There is still another way we can do something:  If both pairs of 	 fields being compared are adjacent, we may be able to make a wider 	 field containing them both.  */
if|if
condition|(
operator|(
name|ll_bitsize
operator|+
name|ll_bitpos
operator|==
name|rl_bitpos
operator|&&
name|lr_bitsize
operator|+
name|lr_bitpos
operator|==
name|rr_bitpos
operator|)
operator|||
operator|(
name|ll_bitpos
operator|==
name|rl_bitpos
operator|+
name|rl_bitsize
operator|&&
name|lr_bitpos
operator|==
name|rr_bitpos
operator|+
name|rr_bitsize
operator|)
condition|)
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|type
argument_list|,
name|ll_bitsize
operator|+
name|rl_bitsize
argument_list|,
name|MIN
argument_list|(
name|ll_bitpos
argument_list|,
name|rl_bitpos
argument_list|)
argument_list|,
name|ll_unsignedp
argument_list|)
argument_list|,
name|make_bit_field_ref
argument_list|(
name|lr_inner
argument_list|,
name|type
argument_list|,
name|lr_bitsize
operator|+
name|rr_bitsize
argument_list|,
name|MIN
argument_list|(
name|lr_bitpos
argument_list|,
name|rr_bitpos
argument_list|)
argument_list|,
name|lr_unsignedp
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
comment|/* Handle the case of comparisons with constants.  If there is something in      common between the masks, those bits of the constants must be the same.      If not, the condition is always false.  Test for this to avoid generating      incorrect code below.  */
name|result
operator|=
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|result
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|result
argument_list|,
name|l_const
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|result
argument_list|,
name|r_const
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|wanted_code
operator|==
name|NE_EXPR
condition|)
block|{
name|warning
argument_list|(
literal|"`or' of unmatched not-equal tests is always 1"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|truth_type
argument_list|,
name|integer_one_node
argument_list|)
return|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`and' of mutually exclusive equal-tests is always zero"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|truth_type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
comment|/* Construct the expression we will return.  First get the component      reference we will make.  Unless the mask is all ones the width of      that field, perform the mask operation.  Then compare with the      merged constant.  */
name|result
operator|=
name|make_bit_field_ref
argument_list|(
name|ll_inner
argument_list|,
name|type
argument_list|,
name|lnbitsize
argument_list|,
name|lnbitpos
argument_list|,
name|ll_unsignedp
operator|||
name|rl_unsignedp
argument_list|)
expr_stmt|;
name|ll_mask
operator|=
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|ll_mask
argument_list|,
name|rl_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_ones_mask_p
argument_list|(
name|ll_mask
argument_list|,
name|lnbitsize
argument_list|)
condition|)
name|result
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|result
argument_list|,
name|ll_mask
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|wanted_code
argument_list|,
name|truth_type
argument_list|,
name|result
argument_list|,
name|const_binop
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|l_const
argument_list|,
name|r_const
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform constant folding and related simplification of EXPR.    The related simplifications include x*1 => x, x*0 => 0, etc.,    and application of the associative law.    NOP_EXPR conversions may be removed freely (as long as we    are careful not to change the C type of the overall expression)    We cannot simplify through a CONVERT_EXPR, FIX_EXPR or FLOAT_EXPR,    but we can constant-fold them if they have constant operands.  */
end_comment

begin_function
name|tree
name|fold
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|expr
decl_stmt|;
name|tree
name|t1
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
specifier|register
name|int
name|kind
decl_stmt|;
name|int
name|invert
decl_stmt|;
comment|/* WINS will be nonzero when the switch is done      if all operands are constant.  */
name|int
name|wins
init|=
literal|1
decl_stmt|;
comment|/* Return right away if already constant.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CONST_DECL
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
return|;
return|return
name|t
return|;
block|}
name|kind
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|FLOAT_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
block|{
comment|/* Special case for conversion ops that can have fixed point args.  */
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't use STRIP_NOPS, because signedness of argument type matters.  */
if|if
condition|(
name|arg0
operator|!=
literal|0
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|REAL_CST
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
condition|)
comment|/* Note that TREE_CONSTANT isn't enough: 	   static var addresses are constant but we can't 	   do arithmetic on them.  */
name|wins
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
literal|'e'
operator|||
name|kind
operator|==
literal|'<'
operator|||
name|kind
operator|==
literal|'1'
operator|||
name|kind
operator|==
literal|'2'
operator|||
name|kind
operator|==
literal|'r'
condition|)
block|{
specifier|register
name|int
name|len
init|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
continue|continue;
comment|/* Valid for CALL_EXPR, at least.  */
comment|/* Strip any conversions that don't change the mode.  */
name|STRIP_NOPS
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|INTEGER_CST
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REAL_CST
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
condition|)
comment|/* Note that TREE_CONSTANT isn't enough: 	       static var addresses are constant but we can't 	       do arithmetic on them.  */
name|wins
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|arg0
operator|=
name|op
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|arg1
operator|=
name|op
expr_stmt|;
block|}
block|}
comment|/* If this is a commutative operation, and ARG0 is a constant, move it      to ARG1 to reduce the number of tests below.  */
if|if
condition|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MULT_EXPR
operator|||
name|code
operator|==
name|MIN_EXPR
operator|||
name|code
operator|==
name|MAX_EXPR
operator|||
name|code
operator|==
name|BIT_IOR_EXPR
operator|||
name|code
operator|==
name|BIT_XOR_EXPR
operator|||
name|code
operator|==
name|BIT_AND_EXPR
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|)
condition|)
block|{
name|tem
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|tem
expr_stmt|;
block|}
comment|/* Now WINS is set as described above,      ARG0 is the first operand of EXPR,      and ARG1 is the second operand (if it has more than one operand).       First check for cases where an arithmetic operation is applied to a      compound, conditional, or comparison operation.  Push the arithmetic      operation inside the compound or conditional to see if any folding      can then be done.  Convert comparison to conditional for this purpose.      The also optimizes non-constant cases that used to be done in      expand_expr.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this was a conversion, and all we did was to move into 	     inside the COND_EXPR, bring it back out.  Then return so we 	     don't get into an infinite recursion loop taking the conversion 	     out and then back in.  */
if|if
condition|(
operator|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|code
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|t
operator|=
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|tree
name|test
decl_stmt|,
name|true_value
decl_stmt|,
name|false_value
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|test
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|true_value
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|false_value
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|test
operator|=
name|arg1
expr_stmt|;
name|true_value
operator|=
name|integer_one_node
expr_stmt|;
name|false_value
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|arg0
operator|=
name|save_expr
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|test
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|test
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|true_value
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|false_value
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|test
argument_list|)
return|;
else|else
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|test
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|tree
name|test
decl_stmt|,
name|true_value
decl_stmt|,
name|false_value
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|test
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|true_value
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|false_value
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|test
operator|=
name|arg0
expr_stmt|;
name|true_value
operator|=
name|integer_one_node
expr_stmt|;
name|false_value
operator|=
name|integer_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|arg1
operator|=
name|save_expr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|test
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|test
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|true_value
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|false_value
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|convert
argument_list|(
name|void_type_node
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|test
argument_list|)
return|;
else|else
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|test
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
return|return
name|t
return|;
case|case
name|CONST_DECL
case|:
return|return
name|fold
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
comment|/* Other kinds of FIX are not handled properly by fold_convert.  */
comment|/* Two conversions in a row are not needed unless: 	 - the intermediate type is narrower than both initial and final, or 	 - the intermediate type and innermost type differ in signedness, 	   and the outermost type is wider than the intermediate, or 	 - the initial type is a pointer type and the precisions of the 	   intermediate and final types differ, or 	 - the final type is a pointer type and the precisions of the  	  initial and intermediate types differ.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|==
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
comment|/* Detect assigning a bitfield.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't leave an assignment inside a conversion 	     unless assigning a bitfield.  */
name|tree
name|prev
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* First do the assignment, then return converted constant.  */
name|t
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|prev
argument_list|,
name|fold
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
if|if
condition|(
operator|!
name|wins
condition|)
block|{
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|fold_convert
argument_list|(
name|t
argument_list|,
name|arg0
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* This loses on&"foo"[0].  */
block|case ARRAY_REF: 	{ 	  int i;
comment|/* Fold an expression like: "foo"[2] */
block|if (TREE_CODE (arg0) == STRING_CST&& TREE_CODE (arg1) == INTEGER_CST&& !TREE_INT_CST_HIGH (arg1)&& (i = TREE_INT_CST_LOW (arg1))< TREE_STRING_LENGTH (arg0)) 	    { 	      t = build_int_2 (TREE_STRING_POINTER (arg0)[i], 0); 	      TREE_TYPE (t) = TREE_TYPE (TREE_TYPE (arg0)); 	      force_fit_type (t); 	    } 	}       return t;
endif|#
directive|endif
comment|/* 0 */
case|case
name|RANGE_EXPR
case|:
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|wins
expr_stmt|;
return|return
name|t
return|;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|overflow
init|=
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|overflow
operator||
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Convert - (a - b) to (b - a) for non-floating-point.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
return|return
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|overflow
init|=
name|neg_double
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|REAL_VALUE_NEGATIVE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ABS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|t
operator|=
name|build_int_2
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|PLUS_EXPR
case|:
comment|/* A + (-B) -> A - B */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* If we are adding two BIT_AND_EXPR's, both of which are and'ing 	     with a constant, and the two constants have no bits in common, 	     we should treat this as a BIT_IOR_EXPR since this may produce more 	     simplifications.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|const_binop
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
goto|goto
name|bit_ior
goto|;
block|}
block|}
comment|/* In IEEE floating point, x+0 may not equal x.  */
elseif|else
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
name|associate
label|:
comment|/* In most languages, can't associate operations on floats 	 through parentheses.  Rather than remember where the parentheses 	 were, we don't associate floats at all.  It shouldn't matter much.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
goto|goto
name|binary
goto|;
comment|/* The varsign == -1 cases happen only for addition and subtraction. 	 It says that the arg that was split was really CON minus VAR. 	 The rest of the code applies to all associative operations.  */
if|if
condition|(
operator|!
name|wins
condition|)
block|{
name|tree
name|var
decl_stmt|,
name|con
decl_stmt|;
name|int
name|varsign
decl_stmt|;
if|if
condition|(
name|split_tree
argument_list|(
name|arg0
argument_list|,
name|code
argument_list|,
operator|&
name|var
argument_list|,
operator|&
name|con
argument_list|,
operator|&
name|varsign
argument_list|)
condition|)
block|{
if|if
condition|(
name|varsign
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* EXPR is (CON-VAR) +- ARG1.  */
comment|/* If it is + and VAR==ARG1, return just CONST.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|var
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|)
return|;
comment|/* Otherwise return (CON +- ARG1) - VAR.  */
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|MINUS_EXPR
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|var
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* EXPR is (VAR+CON) +- ARG1.  */
comment|/* If it is - and VAR==ARG1, return just CONST.  */
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|var
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|)
return|;
comment|/* Otherwise return VAR +- (ARG1 +- CON).  */
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|tem
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|con
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|tem
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
operator|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|var
argument_list|)
return|;
comment|/* If we have x +/- (c - d) [c an explicit integer] 		     change it to x -/+ (d - c) since if d is relocatable 		     then the latter can be a single immediate insn 		     and the former cannot.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|tem1
init|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|tem1
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
operator|(
name|code
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
if|if
condition|(
name|split_tree
argument_list|(
name|arg1
argument_list|,
name|code
argument_list|,
operator|&
name|var
argument_list|,
operator|&
name|con
argument_list|,
operator|&
name|varsign
argument_list|)
condition|)
block|{
comment|/* EXPR is ARG0 +- (CON +- VAR).  */
if|if
condition|(
name|varsign
operator|==
operator|-
literal|1
condition|)
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
operator|(
name|code
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|var
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If VAR and ARG0 cancel, return just CON or -CON.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|)
return|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|con
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|var
argument_list|)
return|;
return|return
name|t
return|;
block|}
block|}
name|binary
label|:
if|#
directive|if
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|t
return|;
endif|#
directive|endif
comment|/* REAL_IS_NOT_DOUBLE, and no REAL_ARITHMETIC */
if|if
condition|(
name|wins
condition|)
name|t1
operator|=
name|const_binop
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* The return value should always have 	     the same type as the original expression.  */
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
return|return
name|t
return|;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|wins
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
block|}
comment|/* Convert A - (-B) to A + B.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NEGATE_EXPR
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
condition|)
block|{
comment|/* Except with IEEE floating point, 0-x equals -x.  */
if|if
condition|(
operator|!
name|wins
operator|&&
name|real_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* Except with IEEE floating point, x-0 equals x.  */
if|if
condition|(
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Fold&x -&x.  This can happen from&x.foo -&x.  	     This is unsafe for certain floats even in non-IEEE formats. 	     In IEEE, it is unsafe because it does wrong for NaNs. 	     Also note that operand_equal_p is always false if an operand 	     is volatile.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
goto|goto
name|associate
goto|;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* (a * (1<< b)) is (a<< b)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|/* x*0 is 0, except for IEEE floating point.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* In IEEE floating point, x*1 is not equivalent to x for snans. 	     However, ANSI says we can drop signals, 	     so we can do this anyway.  */
if|if
condition|(
name|real_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* x*2 is x+x */
if|if
condition|(
operator|!
name|wins
operator|&&
name|real_twop
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|tree
name|arg
init|=
name|save_expr
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
return|return
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
return|;
block|}
block|}
goto|goto
name|associate
goto|;
case|case
name|BIT_IOR_EXPR
case|:
name|bit_ior
label|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
name|t1
operator|=
name|distribute_bit_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
goto|goto
name|associate
goto|;
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|BIT_AND_EXPR
case|:
name|bit_and
label|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
name|t1
operator|=
name|distribute_bit_expr
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
comment|/* Simplify ((int)c& 0x377) into (int)c, if c is unsigned char.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|BITS_PER_WORD
operator|&&
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|BITS_PER_WORD
operator|&&
name|prec
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|associate
goto|;
case|case
name|BIT_ANDTC_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|arg1
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
goto|goto
name|bit_and
goto|;
block|}
goto|goto
name|binary
goto|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* If we have ((a * C1) / C2) and C1 % C2 == 0, we can replace this with 	 (a * (C1/C2).  Also look for when we have a SAVE_EXPR in 	 between.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|>
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|==
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|%
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
block|{
name|tree
name|new_op
init|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|new_op
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_op
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|>
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|%
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
name|new_op
init|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|new_op
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_op
argument_list|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
ifndef|#
directive|ifndef
name|REAL_INFINITY
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
goto|goto
name|binary
goto|;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
goto|goto
name|binary
goto|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
argument_list|)
return|;
comment|/* Since negative shift count is not well-defined, 	 don't try to compute it in the compiler.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|arg1
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
return|return
name|t
return|;
goto|goto
name|binary
goto|;
case|case
name|MIN_EXPR
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|arg0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|arg0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
comment|/* Note that the operand of this must be an int 	 and its values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language, 	 but we don't handle values other than 1 correctly yet.)  */
return|return
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant zero, return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
case|case
name|TRUTH_AND_EXPR
case|:
comment|/* If either arg is constant true, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|arg0
argument_list|)
return|;
comment|/* Both known to be zero => return zero.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|arg0
return|;
name|truth_andor
label|:
comment|/* Check for the possibility of merging component references.  If our 	 lhs is another similar operation, try to merge its rhs with our 	 rhs.  Then try to merge our lhs and rhs.  */
if|if
condition|(
name|optimize
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|code
condition|)
block|{
name|tem
operator|=
name|fold_truthop
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
block|}
name|tem
operator|=
name|fold_truthop
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
return|return
name|tem
return|;
block|}
return|return
name|t
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or true. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant true, return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
case|case
name|TRUTH_OR_EXPR
case|:
comment|/* If either arg is constant zero, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|non_lvalue
argument_list|(
name|arg0
argument_list|)
return|;
comment|/* Both known to be true => return true.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|arg0
return|;
goto|goto
name|truth_andor
goto|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
comment|/* If one arg is a constant integer, put it last.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Convert foo++ == CONST into ++foo == CONST + INCR. 	 First, see if one arg is constant; find the constant arg 	 and the other one.  */
block|{
name|tree
name|constop
init|=
literal|0
decl_stmt|,
name|varop
decl_stmt|;
name|tree
modifier|*
name|constoploc
decl_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
condition|)
name|constoploc
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|,
name|constop
operator|=
name|arg1
operator|,
name|varop
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
condition|)
name|constoploc
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|,
name|constop
operator|=
name|arg0
operator|,
name|varop
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|constop
operator|&&
name|TREE_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|POSTINCREMENT_EXPR
condition|)
block|{
comment|/* This optimization is invalid for ordered comparisons 	       if CONST+INCR overflows or if foo+incr might overflow. 	       This optimization is invalid for floating point due to rounding. 	       For pointer types we assume overflow doesn't happen.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|)
condition|)
block|{
name|tree
name|newconst
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|constop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_SET_CODE
argument_list|(
name|varop
argument_list|,
name|PREINCREMENT_EXPR
argument_list|)
expr_stmt|;
operator|*
name|constoploc
operator|=
name|newconst
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|constop
operator|&&
name|TREE_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|)
condition|)
block|{
name|tree
name|newconst
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|,
name|constop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_SET_CODE
argument_list|(
name|varop
argument_list|,
name|PREDECREMENT_EXPR
argument_list|)
expr_stmt|;
operator|*
name|constoploc
operator|=
name|newconst
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
block|}
comment|/* Change X>= CST to X> (CST - 1) if CST is positive.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|arg1
argument_list|,
name|integer_one_node
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
block|}
block|}
comment|/* If this is an EQ or NE comparison with zero and ARG0 is 	 (1<< foo)& bar, convert it to (bar>> foo)& 1.  Both require 	 two operations, but the latter can be done in one less insn 	 one machine that have only two-operand insns or on which a 	 constant cannot be the first operand.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LSHIFT_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is an NE comparison of zero with an AND of one, remove the 	 comparison since the AND will give the correct value.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* If we have (A& C) == C where C is a power of 2, convert this into 	 (A& C) != 0.  Similarly for NE_EXPR.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|integer_pow2p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|code
operator|==
name|EQ_EXPR
condition|?
name|NE_EXPR
else|:
name|EQ_EXPR
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|integer_zero_node
argument_list|)
return|;
comment|/* Simplify comparison of something with itself.  (For IEEE 	 floating-point, we can only do some of these simplifications.)  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LE_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
comment|/* For NE, we can only do this simplification if integer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
break|break;
comment|/* ... fall through ... */
case|case
name|GT_EXPR
case|:
case|case
name|LT_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
comment|/* An unsigned comparison against 0 can be simplified.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|NE_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|NE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|EQ_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|integer_type_node
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
return|return
name|omit_one_operand
argument_list|(
name|integer_type_node
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
block|}
block|}
comment|/* If we are comparing an expression that just has comparisons 	 of two integer values, arithmetic expressions of those comparisons, 	 and constants, we can simplify it.  There are only three cases 	 to check: the two values can either be equal, the first can be 	 greater, or the second can be greater.  Fold the expression for 	 those three values.  Since each value must be 0 or 1, we have 	 eight possibilities, each of which corresponds to the constant 0 	 or 1 or one of the six possible comparisons.  	 This handles common cases like (a> b) == 0 but also handles 	 expressions like  ((x> y) - (y> x))> 0, which supposedly 	 occur in macroized code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|tree
name|cval1
init|=
literal|0
decl_stmt|,
name|cval2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|twoval_comparison_p
argument_list|(
name|arg0
argument_list|,
operator|&
name|cval1
argument_list|,
operator|&
name|cval2
argument_list|)
comment|/* Don't handle degenerate cases here; they should already 		 have been handled anyway.  */
operator|&&
name|cval1
operator|!=
literal|0
operator|&&
name|cval2
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CONSTANT
argument_list|(
name|cval1
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|cval2
argument_list|)
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|!
name|operand_equal_p
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval2
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|maxval
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|minval
init|=
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cval1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We can't just pass T to eval_subst in case cval1 or cval2 		 was the same as ARG1.  */
name|tree
name|high_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|maxval
argument_list|,
name|cval2
argument_list|,
name|minval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|equal_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|maxval
argument_list|,
name|cval2
argument_list|,
name|maxval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|low_result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|eval_subst
argument_list|(
name|arg0
argument_list|,
name|cval1
argument_list|,
name|minval
argument_list|,
name|cval2
argument_list|,
name|maxval
argument_list|)
argument_list|,
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* All three of these results should be 0 or 1.  Confirm they 		 are.  Then use those values to select the proper code 		 to use.  */
if|if
condition|(
operator|(
name|integer_zerop
argument_list|(
name|high_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|high_result
argument_list|)
operator|)
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|equal_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|equal_result
argument_list|)
operator|)
operator|&&
operator|(
name|integer_zerop
argument_list|(
name|low_result
argument_list|)
operator|||
name|integer_onep
argument_list|(
name|low_result
argument_list|)
operator|)
condition|)
block|{
comment|/* Make a 3-bit mask with the high-order bit being the 		     value for `>', the next for '=', and the low for '<'.  */
switch|switch
condition|(
operator|(
name|integer_onep
argument_list|(
name|high_result
argument_list|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|integer_onep
argument_list|(
name|equal_result
argument_list|)
operator|*
literal|2
operator|)
operator|+
name|integer_onep
argument_list|(
name|low_result
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Always false.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|,
name|arg0
argument_list|)
return|;
case|case
literal|1
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|code
operator|=
name|NE_EXPR
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Always true.  */
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|integer_one_node
argument_list|,
name|arg0
argument_list|)
return|;
block|}
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|cval1
argument_list|,
name|cval2
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/* If this is a comparison of a field, we may be able to simplify it.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|BIT_FIELD_REF
operator|)
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
comment|/* Handle the constant case even without -O 		  to make sure the warnings are given.  */
operator|&&
operator|(
name|optimize
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|t1
operator|=
name|optimize_bit_field_compare
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t1
condition|?
name|t1
else|:
name|t
return|;
block|}
comment|/* From here on, the only cases we handle are when the result is 	 known to be a constant.  	 To compute GT, swap the arguments and do LT. 	 To compute GE, do LT and invert the result. 	 To compute LE, swap the arguments, do LT and invert the result. 	 To compute NE, do EQ and invert the result.  	 Therefore, the code below must handle only EQ and LT.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
condition|)
block|{
name|tem
operator|=
name|arg0
operator|,
name|arg0
operator|=
name|arg1
operator|,
name|arg1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Note that it is safe to invert for real values here because we 	 will check below in the one case that it matters.  */
name|invert
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NE_EXPR
operator|||
name|code
operator|==
name|GE_EXPR
condition|)
block|{
name|invert
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|invert_tree_comparison
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Compute a result for LT or EQ if args permit; 	 otherwise return T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|?
name|INT_CST_LT_UNSIGNED
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
else|:
name|INT_CST_LT
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Assume a nonexplicit constant cannot equal an explicit one, 	 since such code would be undefined anyway. 	 Exception: on sysvr4, using #pragma weak, 	 a label can come out as 0.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|arg0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|code
operator|==
name|EQ_EXPR
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Two real constants can be compared explicitly.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
comment|/* If either operand is a NaN, the result is false with two 	     exceptions: First, an NE_EXPR is true on NaNs, but that case 	     is already handled correctly since we will be inverting the 	     result for NE_EXPR.  Second, if we had inverted a LE_EXPR 	     or a GE_EXPR into a LT_EXPR, we must return true so that it 	     will be inverted into false.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|REAL_VALUE_ISNAN
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
name|invert
operator|&&
name|code
operator|==
name|LT_EXPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
name|t1
operator|=
name|build_int_2
argument_list|(
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t1
operator|=
name|build_int_2
argument_list|(
name|REAL_VALUES_LESS
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t1
operator|==
name|NULL_TREE
condition|)
return|return
name|t
return|;
if|if
condition|(
name|invert
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|^=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t1
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
operator|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|omit_one_operand
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* If the second operand is zero, invert the comparison and swap 	 the second and third operands.  Likewise if the second operand 	 is constant and the third is not or if the third operand is 	 equivalent to the first operand of the comparison.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|||
operator|(
name|TREE_CONSTANT
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* See if this can be inverted.  If it can't, possibly because 	     it was a floating-point inequality comparison, don't do 	     anything.  */
name|tem
operator|=
name|invert_truthvalue
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|TRUTH_NOT_EXPR
condition|)
block|{
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|tem
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we have A op B ? A : C, we may be able to convert this to a 	 simpler expression, depending on the operation and the values 	 of B and C.  IEEE floating point prevents this though, 	 because A or B might be -0.0 or a NaN.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
operator|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
operator|)
operator|&&
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|arg2
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|comp_code
init|=
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
comment|/* If we have A op 0 ? A : -A, this is A, -A, abs (A), or abs (-A), 	     depending on the comparison operation.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|NEGATE_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|ABS_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is A != 0 ? A : 0, this is simply A.  For ==, it is 	     always zero.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
if|if
condition|(
name|comp_code
operator|==
name|NE_EXPR
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|comp_code
operator|==
name|EQ_EXPR
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
comment|/* If this is A op B ? A : B, this is either A, B, min (A, B), 	     or max (A, B), depending on the operation.  */
if|if
condition|(
name|operand_equal_for_comparison_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg2
argument_list|)
return|;
case|case
name|NE_EXPR
case|:
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|LE_EXPR
case|:
case|case
name|LT_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
case|case
name|GE_EXPR
case|:
case|case
name|GT_EXPR
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
block|}
comment|/* If this is A op C1 ? A : C2 with C1 and C2 constant integers, 	     we might still be able to simplify this.  For example, 	     if C1 is one less or one more than C2, this might have started 	     out as a MIN or MAX and been transformed by this function. 	     Only good for INTEGER_TYPE, because we need TYPE_MAX_VALUE.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|INTEGER_CST
condition|)
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
comment|/* We can replace A with C1 in this case.  */
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
comment|/* If C1 is C2 + 1, this is min(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|LE_EXPR
case|:
comment|/* If C1 is C2 - 1, this is min(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MIN_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GT_EXPR
case|:
comment|/* If C1 is C2 - 1, this is max(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|GE_EXPR
case|:
comment|/* If C1 is C2 + 1, this is max(A, C2).  */
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|arg2
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|const_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|arg2
argument_list|,
name|integer_one_node
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MAX_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|)
return|;
break|break;
block|}
block|}
comment|/* Convert A ? 1 : 0 to simply A.  */
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
comment|/* If we try to convert TREE_OPERAND (t, 0) to our type, the 	     call to fold will try to move the conversion inside  	     a COND, which will recurse.  In that case, the COND_EXPR 	     is probably the best choice, so leave it alone.  */
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* Look for expressions of the form A& 2 ? 2 : 0.  The result of this 	 operation is simply A& 2.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NE_EXPR
operator|&&
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|integer_pow2p
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BIT_AND_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|arg1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|t
return|;
case|case
name|COMPOUND_EXPR
case|:
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
return|return
name|t
return|;
default|default:
return|return
name|t
return|;
block|}
comment|/* switch (code) */
block|}
end_function

end_unit

