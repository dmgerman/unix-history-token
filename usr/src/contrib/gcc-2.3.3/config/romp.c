begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on ROMP.    Copyright (C) 1990, 1991, 1992 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_function_decl
specifier|static
name|int
name|unsigned_comparisons_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_loadsave_fpregs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_fpops
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_fpops
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the insn using CC0 set by INSN does not contain    any unsigned tests applied to the condition codes.     Based on `next_insn_tests_no_inequality' in recog.c.  */
end_comment

begin_function
name|int
name|next_insn_tests_no_unsigned
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|next
init|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|cc0_rtx
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
operator|!
name|unsigned_comparisons_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unsigned_comparisons_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
return|return
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|cc0_rtx
operator|)
return|;
block|}
name|len
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|unsigned_comparisons_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|unsigned_comparisons_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the condition code from the insn.  Look mostly at the first    byte of the machine-specific insn description information.     cc_state.value[12] refer to two possible values that might correspond    to the CC.  We only store register values.  */
end_comment

begin_macro
name|update_cc
argument_list|(
argument|body
argument_list|,
argument|insn
argument_list|)
end_macro

begin_decl_stmt
name|rtx
name|body
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|get_attr_cc
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CC_NONE
case|:
comment|/* Insn does not affect the CC at all.  */
break|break;
case|case
name|CC_CHANGE0
case|:
comment|/* Insn doesn't affect the CC but does modify operand[0], known to be 	 a register.  */
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CC_COPY1TO0
case|:
comment|/* Insn copies operand[1] to operand[0], both registers, but doesn't          affect the CC.  */
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|,
name|recog_operand
index|[
literal|1
index|]
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|,
name|recog_operand
index|[
literal|1
index|]
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|CC_CLOBBER
case|:
comment|/* Insn clobbers CC. */
name|CC_STATUS_INIT
expr_stmt|;
break|break;
case|case
name|CC_SETS
case|:
comment|/* Insn sets CC to recog_operand[0], but overflow is impossible.  */
name|CC_STATUS_INIT
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|CC_COMPARE
case|:
comment|/* Insn is a compare which sets the CC fully.  Update CC_STATUS for this 	 compare and mark whether the test will be signed or unsigned.  */
block|{
specifier|register
name|rtx
name|p
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|PARALLEL
condition|)
name|p
operator|=
name|XVECEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|cc_status
operator|.
name|flags
operator||=
name|CC_NO_OVERFLOW
expr_stmt|;
if|if
condition|(
operator|!
name|next_insn_tests_no_unsigned
argument_list|(
name|insn
argument_list|)
condition|)
name|cc_status
operator|.
name|flags
operator||=
name|CC_UNSIGNED
expr_stmt|;
block|}
break|break;
case|case
name|CC_TBIT
case|:
comment|/* Insn sets T bit if result is non-zero.  Next insn must be branch. */
name|CC_STATUS_INIT
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|=
name|CC_IN_TB
operator||
name|CC_NOT_NEGATIVE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return 1 if a previous compare needs to be re-issued.  This will happen    if two compares tested the same objects, but one was signed and the    other unsigned.  OP is the comparison operation being performed.  */
end_comment

begin_function
name|int
name|restore_compare_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
operator|)
operator|&&
operator|!
operator|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_UNSIGNED
operator|)
operator|)
operator|||
operator|(
operator|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LT
operator|)
operator|&&
operator|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_UNSIGNED
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Generate the (long) string corresponding to an inline multiply insn.     Note that `r10' does not refer to the register r10, but rather to the     SCR used as the MQ.  */
end_comment

begin_function
name|char
modifier|*
name|output_in_line_mul
parameter_list|()
block|{
specifier|static
name|char
name|insns
index|[
literal|200
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|insns
argument_list|,
literal|"s %0,%0\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|insns
argument_list|,
literal|"\tmts r10,%1\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|strcat
argument_list|(
name|insns
argument_list|,
literal|"\tm %0,%2\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|insns
argument_list|,
literal|"\tmfs r10,%0"
argument_list|)
expr_stmt|;
return|return
name|insns
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP is a memory reference with an offset from a register within    the range specified.  The offset must also be a multiple of the size of the    mode.  */
end_comment

begin_function
specifier|static
name|int
name|memory_offset_in_range_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|offset
operator|-=
operator|(
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|-
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* We must now have either (mem (reg (x)), (mem (plus (reg (x)) (c))),      or a constant pool address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now use the actual mode and get the address.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
name|offset
operator|=
name|get_pool_offset
argument_list|(
name|op
argument_list|)
operator|+
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|!
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|offset
operator|>=
name|low
operator|&&
name|offset
operator|<=
name|high
operator|&&
operator|(
name|offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for a memory reference insn that can    only reference indirect through a register.   */
end_comment

begin_function
name|int
name|zero_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|memory_offset_in_range_p
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for a `short' memory reference insn. */
end_comment

begin_function
name|int
name|short_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|memory_offset_in_range_p
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|15
operator|*
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a memory reference involving a symbolic constant    that is not in the constant pool. */
end_comment

begin_function
name|int
name|symbolic_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|constant_pool_address_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|romp_symbolic_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|&&
name|romp_symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a constant pool reference to the current function.  */
end_comment

begin_function
name|int
name|current_function_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|strcmp
argument_list|(
name|current_function_name
argument_list|,
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this function is known to have a null epilogue.  */
end_comment

begin_function
name|int
name|null_epilogue
parameter_list|()
block|{
return|return
operator|(
name|reload_completed
operator|&&
name|first_reg_to_save
argument_list|()
operator|==
literal|16
operator|&&
operator|!
name|romp_pushes_stack
argument_list|()
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP is the address of a location in the constant pool.  */
end_comment

begin_function
name|int
name|constant_pool_address_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|romp_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
operator|!
name|op
operator|->
name|integrated
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a valid constant for the ROMP.  */
end_comment

begin_function
name|int
name|constant_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|PLUS
case|:
case|case
name|CONST
case|:
return|return
name|romp_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
call|(
name|unsigned
name|int
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|<
literal|0x10000
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a constant integer valid for the ROMP or a    register.  If a register, it must be in the proper mode unless MODE is    VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|constant_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a register or ANY constant integer.  */
end_comment

begin_function
name|int
name|reg_or_any_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or a valid D-type operand. */
end_comment

begin_function
name|int
name|reg_or_D_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|<
literal|0x10000
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or an item that can be    used as the operand of an SI add insn.  */
end_comment

begin_function
name|int
name|reg_or_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|reg_or_D_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|romp_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or an item that can be    used as the operand of a ROMP logical AND insn.  */
end_comment

begin_function
name|int
name|reg_or_and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|reg_or_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0xffff
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xffff0000
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a register or memory operand.  */
end_comment

begin_function
name|int
name|reg_or_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or a memory operand that is    not symbolic.  */
end_comment

begin_function
name|int
name|reg_or_nonsymb_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|symbolic_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this operand is valid for the ROMP.  This is any operand except    certain constant integers.  */
end_comment

begin_function
name|int
name|romp_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|constant_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is (reg:mode 0).  */
end_comment

begin_function
name|int
name|reg_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is (reg:mode 15).  */
end_comment

begin_function
name|int
name|reg_15_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
literal|15
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if this is a binary floating-point operation.  */
end_comment

begin_function
name|int
name|float_binary
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SFmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DFmode
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
return|return
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if this is a unary floating-point operation.  */
end_comment

begin_function
name|int
name|float_unary
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SFmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DFmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ABS
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a valid floating-point conversion that can be done    as part of an operation by the RT floating-point routines.  */
end_comment

begin_function
name|int
name|float_conversion
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|FLOAT_TRUNCATE
case|:
return|return
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|SFmode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|DFmode
return|;
case|case
name|FLOAT_EXTEND
case|:
return|return
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|DFmode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SFmode
return|;
case|case
name|FLOAT
case|:
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|DFmode
operator|)
operator|)
return|;
case|case
name|FIX
case|:
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* Byte number (const/8) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%B value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Low order 16 bits of constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%L value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Null or "16" depending on whether the constant is greater than 16. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|16
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"16"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* For shifts: 's' will have given the half.  Just give the amount 	 within 16.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%S value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|15
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* The number of a single bit set or cleared, mod 16.  Note that the ROMP 	 numbers bits with the high-order bit 31.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%b value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
literal|31
operator|-
name|i
operator|)
operator|%
literal|16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
literal|31
operator|-
name|i
operator|)
operator|%
literal|16
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%b value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* "l" or "u" depending on which half of the constant is zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%h value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%h value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Upper or lower half, depending on which half is zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%H value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%H value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* Write two characters: 		'lo'	if the high order part is all ones 		'lz'	if the high order part is all zeros 		'uo'	if the low order part is all ones 		'uz'	if the low order part is all zeros         */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%z value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lz"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xffff0000
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"lo"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"uz"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0xffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"uo"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%z value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* Upper or lower half, depending on which is non-zero or not 	 all ones.  Must be consistent with 'z' above.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%Z value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xffff0000
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0xffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%Z value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Same as 'z', except the trailing 'o' or 'z' is not written.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%k value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xffff0000
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0xffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%k value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Similar to 's', except that we write 'h' or 'u'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%k value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|16
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* For memory operations, write 's' if the operand is a short 	 memory operand.  */
if|if
condition|(
name|short_memory_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Like 'M', but check for zero memory offset.  */
if|if
condition|(
name|zero_memory_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* Write low-order part of DImode or DFmode.  Supported for MEM 	 and REG only.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|print_operand
argument_list|(
name|file
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Offset in constant pool for constant pool address.  */
if|if
condition|(
operator|!
name|constant_pool_address_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|get_pool_offset
argument_list|(
name|x
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
else|else
comment|/* Must be (const (plus (symbol_ref) (const_int))) */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|get_pool_offset
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
literal|12
operator|+
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* Branch opcode.  Check for condition in test bit for eq/ne.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_IN_TB
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ntb"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"eq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_IN_TB
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"tb"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ne"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"h"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|LTU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"he"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"le"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%j value"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'J'
case|:
comment|/* Reversed branch opcode.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_IN_TB
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"tb"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ne"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_IN_TB
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ntb"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"eq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"le"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|LTU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"he"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"h"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%j value"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
comment|/* Output nothing.  Used as delimiter in, e.g., "mc%B1%.3 " */
break|break;
case|case
literal|'#'
case|:
comment|/* Output 'x' if this insn has a delay slot, else nothing.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|current_function_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r14"
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the function    prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/*  Return the first register that is required to be saved. 16 if none.  */
end_comment

begin_function
name|int
name|first_reg_to_save
parameter_list|()
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|6
init|;
name|first_reg
operator|<=
literal|15
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
condition|)
break|break;
comment|/* If we think that we do not have to save r14, see if it will be used      to be sure.  */
if|if
condition|(
name|first_reg
operator|>
literal|14
operator|&&
name|romp_using_r14
argument_list|()
condition|)
name|first_reg
operator|=
literal|14
expr_stmt|;
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Compute the size of the save area in the stack, including the space for    the first four incoming arguments.  */
end_comment

begin_function
name|int
name|romp_sa_size
parameter_list|()
block|{
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We have the 4 words corresponding to the arguments passed in registers,      4 reserved words, space for static chain, general register save area,      and floating-point save area.  */
name|size
operator|=
literal|4
operator|+
literal|4
operator|+
literal|1
operator|+
operator|(
literal|16
operator|-
name|first_reg_to_save
argument_list|()
operator|)
expr_stmt|;
comment|/* The documentation says we have to leave 18 words in the save area if      any floating-point registers at all are saved, not the three words      per register you might otherwise expect.  */
for|for
control|(
name|i
operator|=
literal|2
operator|+
operator|(
name|TARGET_FP_REGS
operator|!=
literal|0
operator|)
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|17
index|]
condition|)
block|{
name|size
operator|+=
literal|18
expr_stmt|;
break|break;
block|}
return|return
name|size
operator|*
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this function makes calls or has fp operations    (which are really calls).  */
end_comment

begin_function
name|int
name|romp_makes_calls
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_FP
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this function will use r14 as a pointer to its    constant pool.  */
end_comment

begin_function
name|int
name|romp_using_r14
parameter_list|()
block|{
comment|/* If we are debugging, profiling, have a non-empty constant pool, or      call a function, we need r14.  */
return|return
operator|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|||
name|profile_flag
operator|||
name|get_pool_size
argument_list|()
operator|!=
literal|0
operator|||
name|romp_makes_calls
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this function needs to push space on the stack.  */
end_comment

begin_function
name|int
name|romp_pushes_stack
parameter_list|()
block|{
comment|/* We need to push the stack if a frame pointer is needed (because the      stack might be dynamically adjusted), if we are debugging, if the      total required size is more than 100 bytes, or if we make calls.  */
return|return
operator|(
name|frame_pointer_needed
operator|||
name|write_symbols
operator|!=
name|NO_DEBUG
operator|||
operator|(
name|romp_sa_size
argument_list|()
operator|+
name|get_frame_size
argument_list|()
operator|)
operator|>
literal|100
operator|||
name|romp_makes_calls
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write function prologue.     We compute the size of the fixed area required as follows:     We always allocate 4 words for incoming arguments, 4 word reserved, 1    word for static link, as many words as required for general register    save area, plus 2 words for each FP reg 2-7 that must be saved.  */
end_comment

begin_function
name|void
name|output_prolog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|first_reg
decl_stmt|;
name|int
name|reg_save_offset
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|fp_save
init|=
name|size
operator|+
name|current_function_outgoing_args_size
decl_stmt|;
name|init_fpops
argument_list|()
expr_stmt|;
comment|/* Add in fixed size plus output argument area.  */
name|size
operator|+=
name|romp_sa_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
expr_stmt|;
comment|/* Compute first register to save and perform the save operation if anything      needs to be saved.  */
name|first_reg
operator|=
name|first_reg_to_save
argument_list|()
expr_stmt|;
name|reg_save_offset
operator|=
operator|-
operator|(
literal|4
operator|+
literal|4
operator|+
literal|1
operator|+
operator|(
literal|16
operator|-
name|first_reg
operator|)
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|first_reg
operator|==
literal|15
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst r15,%d(r1)\n"
argument_list|,
name|reg_save_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_reg
operator|<
literal|16
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstm r%d,%d(r1)\n"
argument_list|,
name|first_reg
argument_list|,
name|reg_save_offset
argument_list|)
expr_stmt|;
comment|/* Set up pointer to data area if it is needed.  */
if|if
condition|(
name|romp_using_r14
argument_list|()
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcas r14,r0,r0\n"
argument_list|)
expr_stmt|;
comment|/* Set up frame pointer if needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcal r13,-%d(r1)\n"
argument_list|,
name|romp_sa_size
argument_list|()
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/* Push stack if neeeded.  There are a couple of ways of doing this.  */
if|if
condition|(
name|romp_pushes_stack
argument_list|()
condition|)
block|{
if|if
condition|(
name|size
operator|>=
literal|32768
condition|)
block|{
if|if
condition|(
name|size
operator|>=
literal|65536
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcau r0,%d(r0)\n"
argument_list|,
name|size
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\toil r0,r0,%d\n"
argument_list|,
name|size
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcal16 r0,%d(r0)\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\ts r1,r0\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcal r1,-%d(r1)\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Save floating-point registers.  */
name|output_loadsave_fpregs
argument_list|(
name|file
argument_list|,
name|USE
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|fp_save
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_function
name|void
name|output_epilog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|first_reg
init|=
name|first_reg_to_save
argument_list|()
decl_stmt|;
name|int
name|pushes_stack
init|=
name|romp_pushes_stack
argument_list|()
decl_stmt|;
name|int
name|reg_save_offset
init|=
operator|-
operator|(
operator|(
literal|16
operator|-
name|first_reg
operator|)
operator|+
literal|1
operator|+
literal|4
operator|+
literal|4
operator|)
operator|*
literal|4
decl_stmt|;
name|int
name|total_size
init|=
operator|(
name|size
operator|+
name|romp_sa_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|)
decl_stmt|;
name|int
name|fp_save
init|=
name|size
operator|+
name|current_function_outgoing_args_size
decl_stmt|;
name|int
name|long_frame
init|=
name|total_size
operator|>=
literal|32768
decl_stmt|;
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|int
name|write_code
init|=
literal|1
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
comment|/* words of arguments */
name|tree
name|argptr
decl_stmt|;
for|for
control|(
name|argptr
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|argptr
condition|;
name|argptr
operator|=
name|TREE_CHAIN
argument_list|(
name|argptr
argument_list|)
control|)
name|nargs
operator|+=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|argptr
argument_list|)
argument_list|)
argument_list|)
operator|+
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
operator|)
expr_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write anything except      the trace table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|write_code
operator|=
literal|0
expr_stmt|;
comment|/* Restore floating-point registers.  */
if|if
condition|(
name|write_code
condition|)
name|output_loadsave_fpregs
argument_list|(
name|file
argument_list|,
name|CLOBBER
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|fp_save
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we push the stack and do not have size> 32K, adjust the register      save location to the current position of sp.  Otherwise, if long frame,      restore sp from fp.  */
if|if
condition|(
name|pushes_stack
operator|&&
operator|!
name|long_frame
condition|)
name|reg_save_offset
operator|+=
name|total_size
expr_stmt|;
elseif|else
if|if
condition|(
name|long_frame
operator|&&
name|write_code
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcal r1,%d(r13)\n"
argument_list|,
name|romp_sa_size
argument_list|()
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/* Restore registers.  */
if|if
condition|(
name|first_reg
operator|==
literal|15
operator|&&
name|write_code
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tl r15,%d(r1)\n"
argument_list|,
name|reg_save_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_reg
operator|<
literal|16
operator|&&
name|write_code
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlm r%d,%d(r1)\n"
argument_list|,
name|first_reg
argument_list|,
name|reg_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_reg
operator|==
literal|16
condition|)
name|first_reg
operator|=
literal|0
expr_stmt|;
comment|/* Handle popping stack, if needed and write debug table entry.  */
if|if
condition|(
name|pushes_stack
condition|)
block|{
if|if
condition|(
name|write_code
condition|)
block|{
if|if
condition|(
name|long_frame
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbr r15\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbrx r15\n\tcal r1,%d(r1)\n"
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long 0x%x\n"
argument_list|,
literal|0xdf07df08
operator|+
name|first_reg
operator|*
literal|0x10
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|15
condition|)
name|nargs
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x%xd, 53\n"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.short 0x%x100\n"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|write_code
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbr r15\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long 0xdf02df00\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Output any pending floating-point operations.  */
name|output_fpops
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For the ROMP we need to make new SYMBOL_REFs for the actual name of a    called routine.  To keep them unique we maintain a hash table of all    that have been created so far.  */
end_comment

begin_struct
struct|struct
name|symref_hashent
block|{
name|rtx
name|symref
decl_stmt|;
comment|/* Created SYMBOL_REF rtx.  */
name|struct
name|symref_hashent
modifier|*
name|next
decl_stmt|;
comment|/* Next with same hash code.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SYMHASHSIZE
value|151
end_define

begin_define
define|#
directive|define
name|HASHBITS
value|65535
end_define

begin_comment
comment|/* Define the hash table itself.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symref_hashent
modifier|*
name|symref_hash_table
index|[
name|SYMHASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a name (allocatable in temporary storage), return a SYMBOL_REF    for the name.  The rtx is allocated from the current rtl_obstack, while    the name string is allocated from the permanent obstack.  */
end_comment

begin_function
name|rtx
name|get_symref
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
init|=
name|name
decl_stmt|;
name|unsigned
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|struct
name|symref_hashent
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|last_p
decl_stmt|;
comment|/* Compute the hash code for the string.  */
while|while
condition|(
operator|*
name|sp
condition|)
name|hash
operator|=
operator|(
name|hash
operator|<<
literal|4
operator|)
operator|+
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* Search for a matching entry in the hash table, keeping track of the      insertion location as we do so.  */
name|hash
operator|=
operator|(
name|hash
operator|&
name|HASHBITS
operator|)
operator|%
name|SYMHASHSIZE
expr_stmt|;
for|for
control|(
name|last_p
operator|=
operator|&
name|symref_hash_table
index|[
name|hash
index|]
operator|,
name|p
operator|=
operator|*
name|last_p
init|;
name|p
condition|;
name|last_p
operator|=
operator|&
name|p
operator|->
name|next
operator|,
name|p
operator|=
operator|*
name|last_p
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|XSTR
argument_list|(
name|p
operator|->
name|symref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* If couldn't find matching SYMBOL_REF, make a new one.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
comment|/* Ensure SYMBOL_REF will stay around.  */
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|p
operator|=
operator|*
name|last_p
operator|=
operator|(
expr|struct
name|symref_hashent
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symref_hashent
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|symref
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
return|return
name|p
operator|->
name|symref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate the precision of a floating-point operation.     We merge conversions from integers and between floating-point modes into    the insn.  However, this must not effect the desired precision of the    insn.  The RT floating-point system uses the widest of the operand modes.    If this should be a double-precision insn, ensure that one operand    passed to the floating-point processor has double mode.     Note that since we don't check anything if the mode is single precision,    it, strictly speaking, isn't necessary to call this for those insns.    However, we do so in case something else needs to be checked in the    future.     This routine returns 1 if the operation is OK.  */
end_comment

begin_function
name|int
name|check_precision
parameter_list|(
name|opmode
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|enum
name|machine_mode
name|opmode
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
if|if
condition|(
name|opmode
operator|==
name|SFmode
condition|)
return|return
literal|1
return|;
comment|/* If operand is not a conversion from an integer mode or an extension from      single-precision, it must be a double-precision value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|FLOAT_EXTEND
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|op2
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|FLOAT_EXTEND
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Floating-point on the RT is done by creating an operation block in the data    area that describes the operation.  If two floating-point operations are the    same in a single function, they can use the same block.     These routines are responsible for managing these blocks.  */
end_comment

begin_comment
comment|/* Structure to describe a floating-point operation.  */
end_comment

begin_struct
struct|struct
name|fp_op
block|{
name|struct
name|fp_op
modifier|*
name|next_same_hash
decl_stmt|;
comment|/* Next op with same hash code. */
name|struct
name|fp_op
modifier|*
name|next_in_mem
decl_stmt|;
comment|/* Next op in memory. */
name|int
name|mem_offset
decl_stmt|;
comment|/* Offset from data area.  */
name|short
name|size
decl_stmt|;
comment|/* Size of block in bytes.  */
name|short
name|noperands
decl_stmt|;
comment|/* Number of operands in block.  */
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
comment|/* RTL for operands. */
name|enum
name|rtx_code
name|opcode
decl_stmt|;
comment|/* Operation being performed.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Size of hash table.  */
end_comment

begin_define
define|#
directive|define
name|FP_HASH_SIZE
value|101
end_define

begin_comment
comment|/* Hash table of floating-point operation blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fp_op
modifier|*
name|fp_hash_table
index|[
name|FP_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First floating-point block in data area.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fp_op
modifier|*
name|first_fpop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last block in data area so far.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fp_op
modifier|*
name|last_fpop_in_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutine number in file, to get unique "LF" labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|subr_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current word offset in data area (includes header and any constant pool). */
end_comment

begin_decl_stmt
name|int
name|data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute hash code for an RTX used in floating-point.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_rtx
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|hash
init|=
operator|(
operator|(
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|<<
literal|10
operator|)
operator|+
operator|(
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|<<
literal|20
operator|)
operator|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|hash
operator|+=
name|hash_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'u'
condition|)
name|hash
operator|+=
operator|(
name|int
operator|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
name|hash
operator|+=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
name|hash
operator|+=
operator|(
name|int
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an operation code and up to three operands, return a character string    corresponding to the code to emit to branch to a floating-point operation    block.  INSN is provided to see if the delay slot has been filled or not.     A new floating-point operation block is created if this operation has not    been seen before.  */
end_comment

begin_function
name|char
modifier|*
name|output_fpop
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|,
name|insn
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|static
name|char
name|outbuf
index|[
literal|40
index|]
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|,
name|hash0
decl_stmt|,
name|hash1
decl_stmt|,
name|hash2
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|fp_op
modifier|*
name|fpop
decl_stmt|,
modifier|*
name|last_fpop
decl_stmt|;
name|int
name|dyadic
init|=
operator|(
name|op2
operator|!=
literal|0
operator|)
decl_stmt|;
name|enum
name|machine_mode
name|opmode
decl_stmt|;
name|int
name|noperands
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|unsigned
name|int
name|tem_hash
decl_stmt|;
name|int
name|fr0_avail
init|=
literal|0
decl_stmt|;
comment|/* Compute hash code for each operand.  If the operation is commutative,      put the one with the smaller hash code first.  This will make us see      more operations as identical.  */
name|hash0
operator|=
name|op0
condition|?
name|hash_rtx
argument_list|(
name|op0
argument_list|)
else|:
literal|0
expr_stmt|;
name|hash1
operator|=
name|op1
condition|?
name|hash_rtx
argument_list|(
name|op1
argument_list|)
else|:
literal|0
expr_stmt|;
name|hash2
operator|=
name|op2
condition|?
name|hash_rtx
argument_list|(
name|op2
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|hash0
operator|>
name|hash1
operator|&&
name|code
operator|==
name|EQ
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|tem_hash
operator|=
name|hash0
expr_stmt|;
name|hash0
operator|=
name|hash1
expr_stmt|;
name|hash1
operator|=
name|tem_hash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hash1
operator|>
name|hash2
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MULT
operator|)
condition|)
block|{
name|tem
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|op2
expr_stmt|;
name|op2
operator|=
name|tem
expr_stmt|;
name|tem_hash
operator|=
name|hash1
expr_stmt|;
name|hash1
operator|=
name|hash2
expr_stmt|;
name|hash2
operator|=
name|tem_hash
expr_stmt|;
block|}
comment|/* If operation is commutative and the first and third operands are equal,      swap the second and third operands.  Note that we must consider two      operands equal if they are the same register even if different modes.  */
if|if
condition|(
name|op2
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MULT
operator|)
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op2
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|op2
argument_list|)
operator|)
operator|)
condition|)
block|{
name|tem
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|op2
expr_stmt|;
name|op2
operator|=
name|tem
expr_stmt|;
name|tem_hash
operator|=
name|hash1
expr_stmt|;
name|hash1
operator|=
name|hash2
expr_stmt|;
name|hash2
operator|=
name|tem_hash
expr_stmt|;
block|}
comment|/* If the first and second operands are the same, merge them.  Don't do this      for SFmode or SImode in general registers because this triggers a bug in      the RT fp code.  */
if|if
condition|(
name|op1
operator|&&
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|GE
operator|&&
name|code
operator|!=
name|SET
operator|&&
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|SFmode
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|SImode
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|op1
operator|=
name|op2
expr_stmt|;
name|op2
operator|=
literal|0
expr_stmt|;
block|}
name|noperands
operator|=
literal|1
operator|+
operator|(
name|op1
operator|!=
literal|0
operator|)
operator|+
operator|(
name|op2
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Compute hash code for entire expression and see if operation block      already exists.  */
name|hash
operator|=
operator|(
operator|(
name|int
operator|)
name|code
operator|<<
literal|13
operator|)
operator|+
operator|(
name|hash0
operator|<<
literal|2
operator|)
operator|+
operator|(
name|hash1
operator|<<
literal|1
operator|)
operator|+
name|hash2
expr_stmt|;
name|hash
operator|%=
name|FP_HASH_SIZE
expr_stmt|;
for|for
control|(
name|fpop
operator|=
name|fp_hash_table
index|[
name|hash
index|]
operator|,
name|last_fpop
operator|=
literal|0
init|;
name|fpop
condition|;
name|last_fpop
operator|=
name|fpop
operator|,
name|fpop
operator|=
name|fpop
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|fpop
operator|->
name|opcode
operator|==
name|code
operator|&&
name|noperands
operator|==
name|fpop
operator|->
name|noperands
operator|&&
operator|(
name|op0
operator|==
literal|0
operator|||
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|fpop
operator|->
name|ops
index|[
literal|0
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|op1
operator|==
literal|0
operator|||
name|rtx_equal_p
argument_list|(
name|op1
argument_list|,
name|fpop
operator|->
name|ops
index|[
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|op2
operator|==
literal|0
operator|||
name|rtx_equal_p
argument_list|(
name|op2
argument_list|,
name|fpop
operator|->
name|ops
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
goto|goto
name|win
goto|;
comment|/* We have never seen this operation before.  */
name|fpop
operator|=
operator|(
expr|struct
name|fp_op
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fp_op
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
operator|->
name|mem_offset
operator|=
name|data_offset
expr_stmt|;
name|fpop
operator|->
name|opcode
operator|=
name|code
expr_stmt|;
name|fpop
operator|->
name|noperands
operator|=
name|noperands
expr_stmt|;
name|fpop
operator|->
name|ops
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|fpop
operator|->
name|ops
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|fpop
operator|->
name|ops
index|[
literal|2
index|]
operator|=
name|op2
expr_stmt|;
comment|/* Compute the size using the rules in Appendix A of the RT Linkage      Convention (4.3/RT-PSD:5) manual.  These rules are a bit ambiguous,      but if we guess wrong, it will effect only efficiency, not correctness. */
comment|/* Size = 24 + 32 for each non-fp (or fr7) */
name|size
operator|=
literal|24
expr_stmt|;
if|if
condition|(
name|op0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|||
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
literal|23
operator|)
condition|)
name|size
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|||
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|==
literal|23
operator|)
condition|)
name|size
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|op2
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|||
name|REGNO
argument_list|(
name|op2
argument_list|)
operator|==
literal|23
operator|)
condition|)
name|size
operator|+=
literal|32
expr_stmt|;
comment|/* Size + 12 for each conversion.  First get operation mode.  */
if|if
condition|(
operator|(
name|op0
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|DFmode
operator|)
operator|||
operator|(
name|op1
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|DFmode
operator|)
operator|||
operator|(
name|op2
operator|&&
name|GET_MODE
argument_list|(
name|op2
argument_list|)
operator|==
name|DFmode
operator|)
condition|)
name|opmode
operator|=
name|DFmode
expr_stmt|;
else|else
name|opmode
operator|=
name|SFmode
expr_stmt|;
if|if
condition|(
name|op0
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|opmode
condition|)
name|size
operator|+=
literal|12
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|opmode
condition|)
name|size
operator|+=
literal|12
expr_stmt|;
if|if
condition|(
name|op2
operator|&&
name|GET_MODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|opmode
condition|)
name|size
operator|+=
literal|12
expr_stmt|;
comment|/* 12 more if first and third operand types not the same. */
if|if
condition|(
name|op2
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|op2
argument_list|)
condition|)
name|size
operator|+=
literal|12
expr_stmt|;
comment|/* CMP and CMPT need additional.  Also, compute size of save/restore here. */
if|if
condition|(
name|code
operator|==
name|EQ
condition|)
name|size
operator|+=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GE
condition|)
name|size
operator|+=
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|USE
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
comment|/* 34 + 24 for each additional register plus 8 if fr7 saved.  (We          call it 36 because we need to keep the block length a multiple 	 of four.  */
name|size
operator|=
literal|36
operator|-
literal|24
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|&
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
name|i
operator|)
operator|)
condition|)
name|size
operator|+=
literal|24
operator|+
literal|8
operator|*
operator|(
name|i
operator|==
literal|7
operator|)
expr_stmt|;
block|}
comment|/* We provide no general-purpose scratch registers.  */
name|size
operator|+=
literal|16
expr_stmt|;
comment|/* No floating-point scratch registers are provided.  Compute extra      length due to this.  This logic is that shown in the referenced      appendix.  */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|op2
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op2
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|op0
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|!=
literal|17
operator|)
operator|&&
operator|(
name|op1
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|!=
literal|17
operator|)
operator|&&
operator|(
name|op2
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op2
argument_list|)
operator|!=
literal|17
operator|)
condition|)
name|fr0_avail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dyadic
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|size
operator|+=
name|fr0_avail
condition|?
literal|64
else|:
literal|112
expr_stmt|;
elseif|else
if|if
condition|(
name|fpop
operator|->
name|noperands
operator|==
literal|2
operator|&&
name|i
operator|==
literal|1
condition|)
name|size
operator|+=
name|fr0_avail
condition|?
literal|0
else|:
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|fpop
operator|->
name|noperands
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|op2
argument_list|)
condition|)
if|#
directive|if
literal|1
comment|/* This triggers a bug on the RT. */
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|size
operator|+=
name|fr0_avail
condition|?
literal|0
else|:
literal|64
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
operator|&&
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op2
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|size
operator|+=
name|fr0_avail
condition|?
literal|64
else|:
literal|112
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|size
operator|+=
name|fr0_avail
condition|?
literal|0
else|:
literal|64
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|USE
operator|&&
name|code
operator|!=
name|CLOBBER
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
condition|)
name|size
operator|+=
literal|64
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_FULL_FP_BLOCKS
condition|)
block|{
comment|/* If we are not to pad the blocks, just compute its actual length.  */
name|size
operator|=
literal|12
expr_stmt|;
comment|/* Header + opcode */
if|if
condition|(
name|code
operator|==
name|USE
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|op0
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|op1
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|op2
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* If in the middle of a word, round.  */
if|if
condition|(
name|size
operator|%
name|UNITS_PER_WORD
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
comment|/* Handle any immediates.  */
if|if
condition|(
name|code
operator|!=
name|USE
operator|&&
name|code
operator|!=
name|CLOBBER
operator|&&
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|REG
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|op2
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|REG
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|USE
operator|&&
name|code
operator|!=
name|CLOBBER
operator|&&
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|DFmode
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|op1
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|DFmode
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|op2
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op2
argument_list|)
operator|==
name|DFmode
condition|)
name|size
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Done with size computation!  Chain this in. */
name|fpop
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|data_offset
operator|+=
name|size
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|fpop
operator|->
name|next_in_mem
operator|=
literal|0
expr_stmt|;
name|fpop
operator|->
name|next_same_hash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_fpop_in_mem
condition|)
name|last_fpop_in_mem
operator|->
name|next_in_mem
operator|=
name|fpop
expr_stmt|;
else|else
name|first_fpop
operator|=
name|fpop
expr_stmt|;
name|last_fpop_in_mem
operator|=
name|fpop
expr_stmt|;
if|if
condition|(
name|last_fpop
condition|)
name|last_fpop
operator|->
name|next_same_hash
operator|=
name|fpop
expr_stmt|;
else|else
name|fp_hash_table
index|[
name|hash
index|]
operator|=
name|fpop
expr_stmt|;
name|win
label|:
comment|/* FPOP describes the operation to be performed.  Return a string to branch      to it.  */
if|if
condition|(
name|fpop
operator|->
name|mem_offset
operator|<
literal|32768
operator|/
name|UNITS_PER_WORD
condition|)
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"cal r15,%d(r14)\n\tbalr%s r15,r15"
argument_list|,
name|fpop
operator|->
name|mem_offset
operator|*
name|UNITS_PER_WORD
argument_list|,
name|dbr_sequence_length
argument_list|()
condition|?
literal|"x"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"get r15,$L%dF%d\n\tbalr%s r15,r15"
argument_list|,
name|subr_number
argument_list|,
name|fpop
operator|->
name|mem_offset
operator|*
name|UNITS_PER_WORD
argument_list|,
name|dbr_sequence_length
argument_list|()
condition|?
literal|"x"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|outbuf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If necessary, output a floating-point operation to save or restore all    floating-point registers.     file is the file to write the operation to, CODE is USE for save, CLOBBER    for restore, and ADDR is the address of the same area, as RTL.  */
end_comment

begin_function
specifier|static
name|void
name|output_loadsave_fpregs
parameter_list|(
name|file
parameter_list|,
name|code
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|mask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|+
operator|(
name|TARGET_FP_REGS
operator|!=
literal|0
operator|)
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|17
index|]
condition|)
name|mask
operator||=
literal|1
operator|<<
operator|(
literal|7
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|output_fpop
argument_list|(
name|code
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|mask
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output any floating-point operations at the end of the routine.  */
end_comment

begin_function
specifier|static
name|void
name|output_fpops
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|struct
name|fp_op
modifier|*
name|fpop
decl_stmt|;
specifier|register
name|int
name|size_so_far
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|immed
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|first_fpop
operator|==
literal|0
condition|)
return|return;
name|data_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|fpop
operator|=
name|first_fpop
init|;
name|fpop
condition|;
name|fpop
operator|=
name|fpop
operator|->
name|next_in_mem
control|)
block|{
if|if
condition|(
name|fpop
operator|->
name|mem_offset
operator|<
literal|32768
operator|/
name|UNITS_PER_WORD
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"# data area offset = %d\n"
argument_list|,
name|fpop
operator|->
name|mem_offset
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"L%dF%d:\n"
argument_list|,
name|subr_number
argument_list|,
name|fpop
operator|->
name|mem_offset
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcas r0,r15,r0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long FPGLUE\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fpop
operator|->
name|opcode
condition|)
block|{
case|case
name|USE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x1d\t# STOREM\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x0f\t# LOADM\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x00\t# ABS\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x02\t# ADD\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x07\t# CMP\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x08\t# CMPT\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x0c\t# DIV\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x14\t# MOVE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x15\t# MUL\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x16\t# NEG\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQRT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x1c\t# SQRT\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x1e\t# SUB\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte %d\n"
argument_list|,
name|fpop
operator|->
name|noperands
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.short 0x8001\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fpop
operator|->
name|ops
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|fpop
operator|->
name|ops
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|fpop
operator|->
name|ops
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|17
operator|)
operator|&&
operator|(
name|fpop
operator|->
name|ops
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|fpop
operator|->
name|ops
index|[
literal|1
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|fpop
operator|->
name|ops
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|17
operator|)
operator|&&
operator|(
name|fpop
operator|->
name|ops
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|fpop
operator|->
name|ops
index|[
literal|2
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|fpop
operator|->
name|ops
index|[
literal|2
index|]
argument_list|)
operator|!=
literal|17
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte %d, 0x80\n"
argument_list|,
name|fpop
operator|->
name|size
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte %d, 0\n"
argument_list|,
name|fpop
operator|->
name|size
argument_list|)
expr_stmt|;
name|size_so_far
operator|=
literal|12
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fpop
operator|->
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|int
name|opbyte
decl_stmt|;
specifier|register
name|char
modifier|*
name|desc0
decl_stmt|;
name|char
name|desc1
index|[
literal|50
index|]
decl_stmt|;
name|immed
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
case|case
name|VOIDmode
case|:
name|desc0
operator|=
literal|"int"
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
name|desc0
operator|=
literal|"float"
expr_stmt|;
name|type
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|desc0
operator|=
literal|"double"
expr_stmt|;
name|type
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|strcpy
argument_list|(
name|desc1
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|+=
literal|0x10
expr_stmt|;
name|opbyte
operator|=
name|REGNO
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|)
operator|-
literal|17
expr_stmt|;
block|}
else|else
block|{
name|type
operator|+=
literal|0x00
expr_stmt|;
name|opbyte
operator|=
name|REGNO
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|3
condition|)
name|opbyte
operator|=
operator|(
name|opbyte
operator|<<
literal|4
operator|)
operator|+
name|opbyte
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|MEM
case|:
name|type
operator|+=
literal|0x30
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|immed
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|opbyte
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|immed
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
name|sprintf
argument_list|(
name|desc1
argument_list|,
literal|"%d(%s)"
argument_list|,
name|INTVAL
argument_list|(
name|immed
index|[
name|i
index|]
argument_list|)
argument_list|,
name|reg_names
index|[
name|opbyte
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|desc1
argument_list|,
literal|"<memory> (%s)"
argument_list|,
name|reg_names
index|[
name|opbyte
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|opbyte
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|immed
index|[
name|i
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|sprintf
argument_list|(
name|desc1
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|opbyte
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|immed
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|fpop
operator|->
name|ops
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opbyte
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|desc1
argument_list|,
literal|"<memory>"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
name|type
operator|+=
literal|0x20
expr_stmt|;
name|opbyte
operator|=
literal|0
expr_stmt|;
name|immed
index|[
name|i
index|]
operator|=
name|fpop
operator|->
name|ops
index|[
name|i
index|]
expr_stmt|;
name|desc1
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|desc1
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Save/restore is special.  */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|fpop
operator|->
name|opcode
operator|==
name|USE
operator|||
name|fpop
operator|->
name|opcode
operator|==
name|CLOBBER
operator|)
condition|)
name|type
operator|=
literal|0xff
operator|,
name|opbyte
operator|=
name|INTVAL
argument_list|(
name|fpop
operator|->
name|ops
index|[
literal|0
index|]
argument_list|)
operator|,
name|immed
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0x%x,0x%x # (%s) %s\n"
argument_list|,
name|type
argument_list|,
name|opbyte
argument_list|,
name|desc0
argument_list|,
name|desc1
argument_list|)
expr_stmt|;
name|size_so_far
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* If in the middle of a word, round.  */
if|if
condition|(
name|size_so_far
operator|%
name|UNITS_PER_WORD
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.space 2\n"
argument_list|)
expr_stmt|;
name|size_so_far
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fpop
operator|->
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|immed
index|[
name|i
index|]
condition|)
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|immed
index|[
name|i
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
case|case
name|VOIDmode
case|:
name|size_so_far
operator|+=
literal|4
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long "
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|immed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|size_so_far
operator|+=
literal|4
expr_stmt|;
case|case
name|SFmode
case|:
name|size_so_far
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|immed
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|union
name|real_extract
name|u
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|immed
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|immed
index|[
name|i
index|]
argument_list|)
operator|==
name|DFmode
condition|)
name|ASM_OUTPUT_DOUBLE
argument_list|(
name|file
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_FLOAT
argument_list|(
name|file
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size_so_far
operator|!=
name|fpop
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|TARGET_FULL_FP_BLOCKS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.space %d\n"
argument_list|,
name|fpop
operator|->
name|size
operator|-
name|size_so_far
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Update for next subroutine.  */
name|subr_number
operator|++
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize floating-point operation table.  */
end_comment

begin_function
specifier|static
name|void
name|init_fpops
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|first_fpop
operator|=
name|last_fpop_in_mem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FP_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|fp_hash_table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

