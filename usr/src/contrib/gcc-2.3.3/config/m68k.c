begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Motorola 68000 family.    Copyright (C) 1987 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Some output-actions in m68k.md need these.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Needed for use_return_insn.  */
end_comment

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_SUN_FPA
end_ifdef

begin_comment
comment|/* Index into this array by (register number>> 3) to find the    smallest class which contains that register.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|regno_reg_class
index|[]
init|=
block|{
name|DATA_REGS
block|,
name|ADDR_REGS
block|,
name|FP_REGS
block|,
name|LO_FPA_REGS
block|,
name|LO_FPA_REGS
block|,
name|FPA_REGS
block|,
name|FPA_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined SUPPORT_SUN_FPA */
end_comment

begin_comment
comment|/* This flag is used to communicate between movhi and ASM_OUTPUT_CASE_END,    if SGS_SWITCH_TABLE.  */
end_comment

begin_decl_stmt
name|int
name|switch_table_difference_label_flag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|find_addr_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
name|legitimize_pic_address
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Emit a (use pic_offset_table_rtx) if we used PIC relocation in the     function at any time during the compilation process.  In the future     we should try and eliminate the USE if we can easily determine that     all PIC references were deleted from the current function.  That would     save an address register */
end_comment

begin_macro
name|finalize_pic
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This function generates the assembly code for function entry.    STREAM is a stdio stream to output the code to.    SIZE is an int: how many units of temporary storage to allocate.    Refer to the array `regs_ever_live' to determine which registers    to save; `regs_ever_live[I]' is nonzero if register number I    is ever used in the function.  This function is responsible for    knowing which registers should not be saved even if used.  */
end_comment

begin_comment
comment|/* Note that the order of the bit mask for fmovem is the opposite    of the order for movem!  */
end_comment

begin_function
name|void
name|output_function_prologue
parameter_list|(
name|stream
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|num_saved_regs
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
name|int
name|fsize
init|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* Adding negative number is faster on the 68040.  */
if|if
condition|(
name|fsize
operator|<
literal|0x8000
operator|&&
operator|!
name|TARGET_68040
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tlink.w %s,%0I%d\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
operator|-
name|fsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tlink %s,%0I%d\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
operator|-
name|fsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|TARGET_68020
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tlink.l %s,%0I%d\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
operator|-
name|fsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tlink %s,%0I%d\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
operator|-
name|fsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tlink.w %s,%0I0\n\tadd.l %0I%d,%Rsp\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
operator|-
name|fsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tlink %s,%0I0\n\taddl %0I%d,%Rsp\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
operator|-
name|fsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|fsize
condition|)
block|{
comment|/* Adding negative number is faster on the 68040.  */
if|if
condition|(
name|fsize
operator|+
literal|4
operator|<
literal|0x8000
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tadd.w %0I%d,%Rsp\n"
argument_list|,
operator|-
operator|(
name|fsize
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\taddw %0I%d,%Rsp\n"
argument_list|,
operator|-
operator|(
name|fsize
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tadd.l %0I%d,%Rsp\n"
argument_list|,
operator|-
operator|(
name|fsize
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\taddl %0I%d,%Rsp\n"
argument_list|,
operator|-
operator|(
name|fsize
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|SUPPORT_SUN_FPA
for|for
control|(
name|regno
operator|=
literal|24
init|;
name|regno
operator|<
literal|56
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfpmovd %s,-(%Rsp)\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfpmoved %s,%Rsp@-\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
for|for
control|(
name|regno
operator|=
literal|16
init|;
name|regno
operator|<
literal|24
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|mask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|-
literal|16
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfmovm %0I0x%x,-(%Rsp)\n"
argument_list|,
name|mask
operator|&
literal|0xff
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfmovem %0I0x%x,%Rsp@-\n"
argument_list|,
name|mask
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|mask
operator||=
literal|1
operator|<<
operator|(
literal|15
operator|-
name|regno
operator|)
expr_stmt|;
name|num_saved_regs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|FRAME_POINTER_REGNUM
operator|)
operator|)
expr_stmt|;
name|num_saved_regs
operator|--
expr_stmt|;
block|}
if|#
directive|if
name|NEED_PROBE
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ttstl sp@(%d)\n"
argument_list|,
name|NEED_PROBE
operator|-
name|num_saved_regs
operator|*
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|num_saved_regs
operator|<=
literal|2
condition|)
block|{
comment|/* Store each separately in the same order moveml uses.          Using two movel instructions instead of a single moveml          is about 15% faster for the 68020 and 68030 at no expense          in code size */
name|int
name|i
decl_stmt|;
comment|/* Undo the work from above. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
ifdef|#
directive|ifdef
name|MOTOROLA
literal|"\t%Omove.l %s,-(%Rsp)\n"
argument_list|,
else|#
directive|else
literal|"\tmovel %s,%Rsp@-\n"
argument_list|,
endif|#
directive|endif
name|reg_names
index|[
literal|15
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovm.l %0I0x%x,-(%Rsp)\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmoveml %0I0x%x,%Rsp@-\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%Omove.l %0I__GLOBAL_OFFSET_TABLE_, %s\n"
argument_list|,
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tlea.l (%Rpc,%s.l),%s\n"
argument_list|,
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovel %0I__GLOBAL_OFFSET_TABLE_, %s\n"
argument_list|,
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tlea %Rpc@(0,%s:l),%s\n"
argument_list|,
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if this function's epilogue can be output as RTL.  */
end_comment

begin_function
name|int
name|use_return_insn
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|||
name|get_frame_size
argument_list|()
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Copied from output_function_epilogue ().  We should probably create a      separate layout routine to perform the common work.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function generates the assembly code for function exit,    on machines that need it.  Args are same as for FUNCTION_PROLOGUE.     The function epilogue should not depend on the current stack pointer!    It should use the frame pointer only, if there is a frame pointer.    This is mandatory because of alloca; we also take advantage of it to    omit stack adjustments before returning.  */
end_comment

begin_function
name|void
name|output_function_epilogue
parameter_list|(
name|stream
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|,
name|fmask
decl_stmt|;
specifier|register
name|int
name|nregs
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|foffset
decl_stmt|,
name|fpoffset
decl_stmt|;
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
name|int
name|fsize
init|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
decl_stmt|;
name|int
name|big
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write any code.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* Output just a no-op so that debuggers don't get confused 	 about which function the pc is in at this address.  */
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_EXTRA_EPILOGUE
name|FUNCTION_EXTRA_EPILOGUE
argument_list|(
name|stream
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nregs
operator|=
literal|0
expr_stmt|;
name|fmask
operator|=
literal|0
expr_stmt|;
name|fpoffset
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_SUN_FPA
for|for
control|(
name|regno
operator|=
literal|24
init|;
name|regno
operator|<
literal|56
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|nregs
operator|++
expr_stmt|;
name|fpoffset
operator|=
name|nregs
operator|*
literal|8
expr_stmt|;
endif|#
directive|endif
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|16
init|;
name|regno
operator|<
literal|24
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|nregs
operator|++
expr_stmt|;
name|fmask
operator||=
literal|1
operator|<<
operator|(
literal|23
operator|-
name|regno
operator|)
expr_stmt|;
block|}
name|foffset
operator|=
name|fpoffset
operator|+
name|nregs
operator|*
literal|12
expr_stmt|;
name|nregs
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|regs_ever_live
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|nregs
operator|++
expr_stmt|;
name|mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
name|offset
operator|=
name|foffset
operator|+
name|nregs
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|fsize
operator|>=
literal|0x8000
operator|&&
name|frame_pointer_needed
operator|&&
operator|(
name|mask
operator|||
name|fmask
operator|||
name|fpoffset
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%Omove.l %0I%d,%Ra0\n"
argument_list|,
operator|-
name|fsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovel %0I%d,%Ra0\n"
argument_list|,
operator|-
name|fsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fsize
operator|=
literal|0
operator|,
name|big
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nregs
operator|<=
literal|2
condition|)
block|{
comment|/* Restore each separately in the same order moveml does.          Using two movel instructions instead of a single moveml          is about 15% faster for the 68020 and 68030 at no expense          in code size. */
name|int
name|i
decl_stmt|;
comment|/* Undo the work from above. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|big
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%Omove.l -%d(%s,%Ra0.l),%s\n"
argument_list|,
name|offset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovel %s@(-%d,%Ra0:l),%s\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|offset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%Omove.l (%Rsp)+,%s\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovel %Rsp@+,%s\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%Omove.l -%d(%s),%s\n"
argument_list|,
name|offset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovel %s@(-%d),%s\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|offset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|offset
operator|=
name|offset
operator|-
literal|4
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
condition|)
block|{
if|if
condition|(
name|big
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovm.l -%d(%s,%Ra0.l),%0I0x%x\n"
argument_list|,
name|offset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmoveml %s@(-%d,%Ra0:l),%0I0x%x\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|offset
operator|+
name|fsize
argument_list|,
name|mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovm.l (%Rsp)+,%0I0x%x\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmoveml %Rsp@+,%0I0x%x\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmovm.l -%d(%s),%0I0x%x\n"
argument_list|,
name|offset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tmoveml %s@(-%d),%0I0x%x\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|offset
operator|+
name|fsize
argument_list|,
name|mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|fmask
condition|)
block|{
if|if
condition|(
name|big
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfmovm -%d(%s,%Ra0.l),%0I0x%x\n"
argument_list|,
name|foffset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfmovem %s@(-%d,%Ra0:l),%0I0x%x\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|foffset
operator|+
name|fsize
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfmovm (%Rsp)+,%0I0x%x\n"
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfmovem %Rsp@+,%0I0x%x\n"
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfmovm -%d(%s),%0I0x%x\n"
argument_list|,
name|foffset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfmovem %s@(-%d),%0I0x%x\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|foffset
operator|+
name|fsize
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|fpoffset
operator|!=
literal|0
condition|)
for|for
control|(
name|regno
operator|=
literal|55
init|;
name|regno
operator|>=
literal|24
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|big
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfpmovd -%d(%s,%Ra0.l), %s\n"
argument_list|,
name|fpoffset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfpmoved %s@(-%d,%Ra0:l), %s\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|fpoffset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfpmovd (%Rsp)+,%s\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfpmoved %Rsp@+, %s\n"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfpmovd -%d(%s), %s\n"
argument_list|,
name|fpoffset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tfpmoved %s@(-%d), %s\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|fpoffset
operator|+
name|fsize
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fpoffset
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tunlk %s\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
condition|)
block|{
if|if
condition|(
name|fsize
operator|+
literal|4
operator|<
literal|0x8000
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tadd.w %0I%d,%Rsp\n"
argument_list|,
name|fsize
operator|+
literal|4
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\taddw %0I%d,%Rsp\n"
argument_list|,
name|fsize
operator|+
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tadd.l %0I%d,%Rsp\n"
argument_list|,
name|fsize
operator|+
literal|4
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\taddl %0I%d,%Rsp\n"
argument_list|,
name|fsize
operator|+
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|current_function_pops_args
condition|)
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"\trtd %0I%d\n"
argument_list|,
name|current_function_pops_args
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\trts\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar to general_operand, but exclude stack_pointer_rtx.  */
end_comment

begin_function
name|int
name|not_sp_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|!=
name|stack_pointer_rtx
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if X is a valid comparison operator for the dbcc     instruction.       Note it rejects floating point comparison operators.    (In the future we could use Fdbcc).     It also rejects some comparisons when CC_NO_OVERFLOW is set.  */
end_comment

begin_function
name|int
name|valid_dbcc_comparison_p
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* We could add support for these in the future */
if|if
condition|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_IN_68881
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GTU
case|:
case|case
name|LTU
case|:
case|case
name|GEU
case|:
case|case
name|LEU
case|:
return|return
literal|1
return|;
comment|/* Reject some when CC_NO_OVERFLOW is set.  This may be over          conservative */
case|case
name|GT
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|LE
case|:
return|return
operator|!
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_NO_OVERFLOW
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Output a dbCC; jCC sequence.  Note we do not handle the     floating point version of this sequence (Fdbcc).  We also    do not handle alternative conditions when CC_NO_OVERFLOW is    set.  It is assumed that valid_dbcc_comparison_p will kick    those out before we get here.  */
end_comment

begin_macro
name|output_dbcc_and_branch
argument_list|(
argument|operands
argument_list|)
end_macro

begin_decl_stmt
name|rtx
modifier|*
name|operands
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dbeq %0,%l1\n\tjbeq %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dbeq %0,%l1\n\tjeq %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NE
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dbne %0,%l1\n\tjbne %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dbne %0,%l1\n\tjne %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GT
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dbgt %0,%l1\n\tjbgt %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dbgt %0,%l1\n\tjgt %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GTU
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dbhi %0,%l1\n\tjbhi %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dbhi %0,%l1\n\tjhi %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LT
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dblt %0,%l1\n\tjblt %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dblt %0,%l1\n\tjlt %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LTU
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dbcs %0,%l1\n\tjbcs %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dbcs %0,%l1\n\tjcs %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GE
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dbge %0,%l1\n\tjbge %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dbge %0,%l1\n\tjge %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GEU
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dbcc %0,%l1\n\tjbcc %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dbcc %0,%l1\n\tjcc %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LE
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dble %0,%l1\n\tjble %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dble %0,%l1\n\tjle %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LEU
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"dbls %0,%l1\n\tjbls %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"dbls %0,%l1\n\tjls %l2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If the decrement is to be done in SImode, then we have      to compensate for the fact that dbcc decrements in HImode. */
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|output_asm_insn
argument_list|(
literal|"clr%.w %0\n\tsubq%.l %#1,%0\n\tjbpl %l1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
name|output_asm_insn
argument_list|(
literal|"clr%.w %0\n\tsubq%.l %#1,%0\n\tjpl %l1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|HImode
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|output_btst
parameter_list|(
name|operands
parameter_list|,
name|countop
parameter_list|,
name|dataop
parameter_list|,
name|insn
parameter_list|,
name|signpos
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
name|countop
decl_stmt|,
name|dataop
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|signpos
decl_stmt|;
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|countop
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|dataop
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|countop
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|register
name|int
name|count
init|=
name|INTVAL
argument_list|(
name|countop
argument_list|)
decl_stmt|;
comment|/* If COUNT is bigger than size of storage unit in use, 	 advance to the containing unit of same size.  */
if|if
condition|(
name|count
operator|>
name|signpos
condition|)
block|{
name|int
name|offset
init|=
operator|(
name|count
operator|&
operator|~
name|signpos
operator|)
operator|/
literal|8
decl_stmt|;
name|count
operator|=
name|count
operator|&
name|signpos
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|dataop
operator|=
name|adj_offsettable_operand
argument_list|(
name|dataop
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|signpos
condition|)
name|cc_status
operator|.
name|flags
operator|=
name|CC_NOT_POSITIVE
operator||
name|CC_Z_IN_NOT_N
expr_stmt|;
else|else
name|cc_status
operator|.
name|flags
operator|=
name|CC_NOT_NEGATIVE
operator||
name|CC_Z_IN_NOT_N
expr_stmt|;
comment|/* These three statements used to use next_insns_test_no... 	 but it appears that this should do the same job.  */
if|if
condition|(
name|count
operator|==
literal|31
operator|&&
name|next_insn_tests_no_inequality
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|"tst%.l %1"
return|;
if|if
condition|(
name|count
operator|==
literal|15
operator|&&
name|next_insn_tests_no_inequality
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|"tst%.w %1"
return|;
if|if
condition|(
name|count
operator|==
literal|7
operator|&&
name|next_insn_tests_no_inequality
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|"tst%.b %1"
return|;
name|cc_status
operator|.
name|flags
operator|=
name|CC_NOT_NEGATIVE
expr_stmt|;
block|}
return|return
literal|"btst %0,%1"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
if|#
directive|if
literal|0
comment|/* Deleted, with corresponding change in m68k.h, 	 so as to fit the specs.  No CONST_DOUBLE is ever symbolic.  */
block|case CONST_DOUBLE:       return GET_MODE (op) == mode;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already    position-independent, we return ORIG.  Newly generated    position-independent addresses go to REG.  If we need more    than one register, we lose.       An address is legitimized by making an indirect reference    through the Global Offset Table with the name of the symbol    used as an offset.       The assembler and linker are responsible for placing the     address of the symbol in the GOT.  The function prologue    is responsible for initializing a5 to the starting address    of the GOT.     The assembler is also responsible for translating a symbol name    into a constant displacement from the start of the GOT.       A quick example may make things a little clearer:     When not generating PIC code to store the value 12345 into _foo    we would generate the following code:  	movel #12345, _foo     When generating PIC two transformations are made.  First, the compiler    loads the address of foo into a register.  So the first transformation makes:  	lea	_foo, a0 	movel   #12345, a0@     The code in movsi will intercept the lea instruction and call this    routine which will transform the instructions into:  	movel   a5@(_foo:w), a0 	movel   #12345, a0@         That (in a nutshell) is how *all* symbol and label references are     handled.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|,
name|reg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|pic_ref
init|=
name|orig
decl_stmt|;
comment|/* First handle a simple SYMBOL_REF or LABEL_REF */
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
comment|/* Make sure this is CONST has not already been legitimized */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* legitimize both operands of the PLUS */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|orig
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|orig
argument_list|)
expr_stmt|;
comment|/* Likewise, should we set special REG_NOTEs here?  */
block|}
return|return
name|pic_ref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SUPPORT_SUN_FPA
if|if
condition|(
name|FPA_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|FPA_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|"fpmoves %1,%0"
return|;
endif|#
directive|endif
if|if
condition|(
name|DATA_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|128
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
operator|-
literal|128
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MOTOROLA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CRDS
argument_list|)
return|return
literal|"moveq%.l %1,%0"
return|;
else|#
directive|else
return|return
literal|"moveq %1,%0"
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|!=
name|const0_rtx
condition|)
return|return
literal|"move%.l %1,%0"
return|;
if|if
condition|(
operator|!
name|ADDRESS_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|"clr%.l %0"
return|;
return|return
literal|"sub%.l %0,%0"
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype0
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype0
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype1
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype1
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If one operand is decrementing and one is incrementing      decrement the former register explicitly      and change that operand into ordinary indexing.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|optype1
operator|==
name|POPOP
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"subq%.l %#8,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
block|}
if|if
condition|(
name|optype0
operator|==
name|POPOP
operator|&&
name|optype1
operator|==
name|PUSHOP
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"subq%.l %#8,%1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
block|}
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
name|split_double
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If insn is effectively movd N(sp),-(sp) then we will do the      high word first.  We should use the adjusted operand 1 (which is N+4(sp))      for the low word as well, to compensate for the first decrement of sp.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
comment|/* If one or both operands autodecrementing,      do the two words, high-numbered first.  */
comment|/* Likewise,  the first move would clobber the source of the second one,      do them in the other order.  This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|||
name|optype1
operator|==
name|PUSHOP
operator|||
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addql %#4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addql %#4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"subql %#4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"subql %#4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addql %#4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addql %#4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"subql %#4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"subql %#4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store in cc_status the expressions that the condition codes will    describe after execution of an instruction whose pattern is EXP.    Do not alter them if the instruction would not alter the cc's.  */
end_comment

begin_comment
comment|/* On the 68000, all the insns to store in an address register fail to    set the cc's.  However, in some cases these instructions can make it    possibly invalid to use the saved cc's.  In those cases we clear out    some or all of the saved cc's so they won't be used.  */
end_comment

begin_macro
name|notice_update_cc
argument_list|(
argument|exp
argument_list|,
argument|insn
argument_list|)
end_macro

begin_decl_stmt
name|rtx
name|exp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|insn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* If the cc is being set from the fpa and the expression is not an      explicit floating point test instruction (which has code to deal with      this), reinit the CC.  */
if|if
condition|(
operator|(
operator|(
name|cc_status
operator|.
name|value1
operator|&&
name|FPA_REG_P
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|)
operator|||
operator|(
name|cc_status
operator|.
name|value2
operator|&&
name|FPA_REG_P
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ADDRESS_REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|SET_DEST
argument_list|(
name|exp
argument_list|)
operator|!=
name|cc0_rtx
operator|&&
operator|(
name|FP_REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|FIX
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|FLOAT_TRUNCATE
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|FLOAT_EXTEND
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
comment|/* A pair of move insns doesn't produce a useful overall cc.  */
elseif|else
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|!
name|FP_REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|!=
name|pc_rtx
condition|)
block|{
name|cc_status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|ADDRESS_REG_P
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|CC_STATUS_INIT
expr_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|pc_rtx
condition|)
block|{
name|cc_status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
name|ADDRESS_REG_P
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|==
name|QImode
condition|)
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|cc_status
operator|.
name|value1
operator|&&
name|FPA_REG_P
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
case|case
name|NEG
case|:
case|case
name|ASHIFT
case|:
case|case
name|LSHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|cc_status
operator|.
name|flags
operator||=
name|CC_NO_OVERFLOW
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
comment|/* (SET r1 (ZERO_EXTEND r2)) on this machine 	   ends with a move insn moving r2 in r2's mode. 	   Thus, the cc's are set for r2. 	   This can set N bit spuriously. */
name|cc_status
operator|.
name|flags
operator||=
name|CC_NOT_NEGATIVE
expr_stmt|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|==
name|REG
operator|&&
name|cc_status
operator|.
name|value2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cc_status
operator|.
name|value1
operator|&&
name|FP_REG_P
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|)
operator|||
operator|(
name|cc_status
operator|.
name|value2
operator|&&
name|FP_REG_P
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|(
name|cc_status
operator|.
name|value1
operator|&&
name|FPA_REG_P
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|)
operator|||
operator|(
name|cc_status
operator|.
name|value2
operator|&&
name|FPA_REG_P
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|)
operator|)
condition|)
name|cc_status
operator|.
name|flags
operator|=
name|CC_IN_68881
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
name|char
modifier|*
name|output_move_const_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SUPPORT_SUN_FPA
if|if
condition|(
name|TARGET_FPA
operator|&&
name|FPA_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|code
init|=
name|standard_sun_fpa_constant_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"fpmove%%.d %%%%%d,%%0"
argument_list|,
name|code
operator|&
literal|0x1ff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
literal|"fpmove%.d %1,%0"
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|int
name|code
init|=
name|standard_68881_constant_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"fmovecr %%#0x%x,%%0"
argument_list|,
name|code
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
literal|"fmove%.d %1,%0"
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|output_move_const_single
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SUPPORT_SUN_FPA
if|if
condition|(
name|TARGET_FPA
condition|)
block|{
name|int
name|code
init|=
name|standard_sun_fpa_constant_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"fpmove%%.s %%%%%d,%%0"
argument_list|,
name|code
operator|&
literal|0x1ff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
literal|"fpmove%.s %1,%0"
return|;
block|}
else|else
endif|#
directive|endif
comment|/* defined SUPPORT_SUN_FPA */
block|{
name|int
name|code
init|=
name|standard_68881_constant_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"fmovecr %%#0x%x,%%0"
argument_list|,
name|code
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
literal|"fmove%.s %f1,%0"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if X, a CONST_DOUBLE, has a value that we can get    from the "fmovecr" instruction.    The value, anded with 0xff, gives the code to use in fmovecr    to get the desired constant.  */
end_comment

begin_comment
comment|/* ??? This code should be fixed for cross-compilation. */
end_comment

begin_function
name|int
name|standard_68881_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|double
name|d
decl_stmt|;
comment|/* fmovecr must be emulated on the 68040, so it shouldn't be used at all. */
if|if
condition|(
name|TARGET_68040
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
if|if
condition|(
operator|!
name|flag_pretend_float
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
return|return
literal|0x0f
return|;
comment|/* Note: there are various other constants available      but it is a nuisance to put in their values here.  */
if|if
condition|(
name|d
operator|==
literal|1
condition|)
return|return
literal|0x32
return|;
if|if
condition|(
name|d
operator|==
literal|10
condition|)
return|return
literal|0x33
return|;
if|if
condition|(
name|d
operator|==
literal|100
condition|)
return|return
literal|0x34
return|;
if|if
condition|(
name|d
operator|==
literal|10000
condition|)
return|return
literal|0x35
return|;
if|if
condition|(
name|d
operator|==
literal|1e8
condition|)
return|return
literal|0x36
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|d
operator|==
literal|1e16
condition|)
return|return
literal|0x37
return|;
comment|/* larger powers of ten in the constants ram are not used      because they are not equal to a `double' C constant.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is a floating-point constant, return the logarithm of X base 2,    or 0 if X is not a power of 2.  */
end_comment

begin_function
name|int
name|floating_exact_log2
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|double
name|d
decl_stmt|,
name|d1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
if|if
condition|(
operator|!
name|flag_pretend_float
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|>
literal|0
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|d1
operator|=
literal|1.0
operator|,
name|i
operator|=
literal|0
init|;
name|d1
operator|<
name|d
condition|;
name|d1
operator|*=
literal|2.0
operator|,
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|d
operator|==
name|d1
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_SUN_FPA
end_ifdef

begin_comment
comment|/* Return nonzero if X, a CONST_DOUBLE, has a value that we can get    from the Sun FPA's constant RAM.    The value returned, anded with 0x1ff, gives the code to use in fpmove    to get the desired constant. */
end_comment

begin_define
define|#
directive|define
name|S_E
value|(2.718281745910644531)
end_define

begin_define
define|#
directive|define
name|D_E
value|(2.718281828459045091)
end_define

begin_define
define|#
directive|define
name|S_PI
value|(3.141592741012573242)
end_define

begin_define
define|#
directive|define
name|D_PI
value|(3.141592653589793116)
end_define

begin_define
define|#
directive|define
name|S_SQRT2
value|(1.414213538169860840)
end_define

begin_define
define|#
directive|define
name|D_SQRT2
value|(1.414213562373095145)
end_define

begin_define
define|#
directive|define
name|S_LOG2ofE
value|(1.442695021629333496)
end_define

begin_define
define|#
directive|define
name|D_LOG2ofE
value|(1.442695040888963387)
end_define

begin_define
define|#
directive|define
name|S_LOG2of10
value|(3.321928024291992188)
end_define

begin_define
define|#
directive|define
name|D_LOG2of10
value|(3.321928024887362182)
end_define

begin_define
define|#
directive|define
name|S_LOGEof2
value|(0.6931471824645996094)
end_define

begin_define
define|#
directive|define
name|D_LOGEof2
value|(0.6931471805599452862)
end_define

begin_define
define|#
directive|define
name|S_LOGEof10
value|(2.302585124969482442)
end_define

begin_define
define|#
directive|define
name|D_LOGEof10
value|(2.302585092994045901)
end_define

begin_define
define|#
directive|define
name|S_LOG10of2
value|(0.3010300099849700928)
end_define

begin_define
define|#
directive|define
name|D_LOG10of2
value|(0.3010299956639811980)
end_define

begin_define
define|#
directive|define
name|S_LOG10ofE
value|(0.4342944920063018799)
end_define

begin_define
define|#
directive|define
name|D_LOG10ofE
value|(0.4342944819032518167)
end_define

begin_comment
comment|/* This code should be fixed for cross-compilation. */
end_comment

begin_function
name|int
name|standard_sun_fpa_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|double
name|d
decl_stmt|;
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
if|if
condition|(
operator|!
name|flag_pretend_float
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0.0
condition|)
return|return
literal|0x200
return|;
comment|/* 0 once 0x1ff is anded with it */
if|if
condition|(
name|d
operator|==
literal|1.0
condition|)
return|return
literal|0xe
return|;
if|if
condition|(
name|d
operator|==
literal|0.5
condition|)
return|return
literal|0xf
return|;
if|if
condition|(
name|d
operator|==
operator|-
literal|1.0
condition|)
return|return
literal|0x10
return|;
if|if
condition|(
name|d
operator|==
literal|2.0
condition|)
return|return
literal|0x11
return|;
if|if
condition|(
name|d
operator|==
literal|3.0
condition|)
return|return
literal|0xB1
return|;
if|if
condition|(
name|d
operator|==
literal|4.0
condition|)
return|return
literal|0x12
return|;
if|if
condition|(
name|d
operator|==
literal|8.0
condition|)
return|return
literal|0x13
return|;
if|if
condition|(
name|d
operator|==
literal|0.25
condition|)
return|return
literal|0x15
return|;
if|if
condition|(
name|d
operator|==
literal|0.125
condition|)
return|return
literal|0x16
return|;
if|if
condition|(
name|d
operator|==
literal|10.0
condition|)
return|return
literal|0x17
return|;
if|if
condition|(
name|d
operator|==
operator|-
operator|(
literal|1.0
operator|/
literal|2.0
operator|)
condition|)
return|return
literal|0x2E
return|;
comment|/*  * Stuff that looks different if it's single or double  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|S_E
condition|)
return|return
literal|0x8
return|;
if|if
condition|(
name|d
operator|==
operator|(
literal|2
operator|*
name|S_PI
operator|)
condition|)
return|return
literal|0x9
return|;
if|if
condition|(
name|d
operator|==
name|S_PI
condition|)
return|return
literal|0xA
return|;
if|if
condition|(
name|d
operator|==
operator|(
name|S_PI
operator|/
literal|2.0
operator|)
condition|)
return|return
literal|0xB
return|;
if|if
condition|(
name|d
operator|==
name|S_SQRT2
condition|)
return|return
literal|0xC
return|;
if|if
condition|(
name|d
operator|==
operator|(
literal|1.0
operator|/
name|S_SQRT2
operator|)
condition|)
return|return
literal|0xD
return|;
comment|/* Large powers of 10 in the constant  	 ram are not used because they are 	 not equal to a C double constant  */
if|if
condition|(
name|d
operator|==
operator|-
operator|(
name|S_PI
operator|/
literal|2.0
operator|)
condition|)
return|return
literal|0x27
return|;
if|if
condition|(
name|d
operator|==
name|S_LOG2ofE
condition|)
return|return
literal|0x28
return|;
if|if
condition|(
name|d
operator|==
name|S_LOG2of10
condition|)
return|return
literal|0x29
return|;
if|if
condition|(
name|d
operator|==
name|S_LOGEof2
condition|)
return|return
literal|0x2A
return|;
if|if
condition|(
name|d
operator|==
name|S_LOGEof10
condition|)
return|return
literal|0x2B
return|;
if|if
condition|(
name|d
operator|==
name|S_LOG10of2
condition|)
return|return
literal|0x2C
return|;
if|if
condition|(
name|d
operator|==
name|S_LOG10ofE
condition|)
return|return
literal|0x2D
return|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|==
name|D_E
condition|)
return|return
literal|0x8
return|;
if|if
condition|(
name|d
operator|==
operator|(
literal|2
operator|*
name|D_PI
operator|)
condition|)
return|return
literal|0x9
return|;
if|if
condition|(
name|d
operator|==
name|D_PI
condition|)
return|return
literal|0xA
return|;
if|if
condition|(
name|d
operator|==
operator|(
name|D_PI
operator|/
literal|2.0
operator|)
condition|)
return|return
literal|0xB
return|;
if|if
condition|(
name|d
operator|==
name|D_SQRT2
condition|)
return|return
literal|0xC
return|;
if|if
condition|(
name|d
operator|==
operator|(
literal|1.0
operator|/
name|D_SQRT2
operator|)
condition|)
return|return
literal|0xD
return|;
comment|/* Large powers of 10 in the constant  	 ram are not used because they are 	 not equal to a C double constant  */
if|if
condition|(
name|d
operator|==
operator|-
operator|(
name|D_PI
operator|/
literal|2.0
operator|)
condition|)
return|return
literal|0x27
return|;
if|if
condition|(
name|d
operator|==
name|D_LOG2ofE
condition|)
return|return
literal|0x28
return|;
if|if
condition|(
name|d
operator|==
name|D_LOG2of10
condition|)
return|return
literal|0x29
return|;
if|if
condition|(
name|d
operator|==
name|D_LOGEof2
condition|)
return|return
literal|0x2A
return|;
if|if
condition|(
name|d
operator|==
name|D_LOGEof10
condition|)
return|return
literal|0x2B
return|;
if|if
condition|(
name|d
operator|==
name|D_LOG10of2
condition|)
return|return
literal|0x2C
return|;
if|if
condition|(
name|d
operator|==
name|D_LOG10ofE
condition|)
return|return
literal|0x2D
return|;
block|}
return|return
literal|0x0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* define SUPPORT_SUN_FPA */
end_comment

begin_escape
end_escape

begin_comment
comment|/* A C compound statement to output to stdio stream STREAM the    assembler syntax for an instruction operand X.  X is an RTL    expression.     CODE is a value that can be used to specify one of several ways    of printing the operand.  It is used when identical operands    must be printed differently depending on the context.  CODE    comes from the `%' specification that was used to request    printing of the operand.  If the specification was just `%DIGIT'    then CODE is 0; if the specification was `%LTR DIGIT' then CODE    is the ASCII code for LTR.     If X is a register, this macro should print the register's name.    The names can be found in an array `reg_names' whose type is    `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.     When the machine description has a specification `%PUNCT' (a `%'    followed by a punctuation character), this macro is called with    a null pointer for X and the punctuation character for CODE.     The m68k specific codes are:     '.' for dot needed in Motorola-style opcode names.    '-' for an operand pushing on the stack:        sp@-, -(sp) or -(%sp) depending on the style of syntax.    '+' for an operand pushing on the stack:        sp@+, (sp)+ or (%sp)+ depending on the style of syntax.    '@' for a reference to the top word on the stack:        sp@, (sp) or (%sp) depending on the style of syntax.    '#' for an immediate operand prefix (# in MIT and Motorola syntax        but& in SGS syntax).    '!' for the cc register (used in an `and to cc' insn).    '$' for the letter `s' in an op code, but only on the 68040.    '&' for the letter `d' in an op code, but only on the 68040.     'b' for byte insn (no effect, on the Sun; this is for the ISI).    'd' to force memory addressing to be absolute, not relative.    'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)    'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather        than directly).  Second part of 'y' below.    'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),        or print pair of registers as rx:ry.    'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs        CONST_DOUBLE's as SunFPA constant RAM registers if        possible, so it should not be used except for the SunFPA.     */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|op
parameter_list|,
name|letter
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* file to write to */
name|rtx
name|op
decl_stmt|;
comment|/* operand to print */
name|int
name|letter
decl_stmt|;
comment|/* %<letter> or 0 */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|letter
operator|==
literal|'.'
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'#'
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%0I"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'-'
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"-(%Rsp)"
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%Rsp@-"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'+'
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"(%Rsp)+"
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%Rsp@+"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'@'
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"(%Rsp)"
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%Rsp@"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'!'
condition|)
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%Rfpcr"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|TARGET_68040_ONLY
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
name|TARGET_68040_ONLY
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
literal|16
operator|&&
operator|(
name|letter
operator|==
literal|'y'
operator|||
name|letter
operator|==
literal|'x'
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
operator|==
literal|'d'
operator|&&
operator|!
name|TARGET_68020
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0x8000
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
operator|-
literal|0x8000
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":l"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SUPPORT_SUN_FPA
elseif|else
if|if
condition|(
operator|(
name|letter
operator|==
literal|'y'
operator|||
name|letter
operator|==
literal|'w'
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|i
operator|=
name|standard_sun_fpa_constant_p
argument_list|(
name|op
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%%%d"
argument_list|,
name|i
operator|&
literal|0x1ff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|double
name|d
decl_stmt|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|u1
union|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|u1
operator|.
name|f
operator|=
name|d
expr_stmt|;
name|PRINT_OPERAND_PRINT_FLOAT
argument_list|(
name|letter
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DImode
condition|)
block|{
name|double
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DOUBLE_OPERAND
argument_list|(
name|file
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%0I"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C compound statement to output to stdio stream STREAM the    assembler syntax for an instruction operand that is a memory    reference whose address is ADDR.  ADDR is an RTL expression.     Note that this contains a kludge that knows that the only reason    we have an address (plus (label_ref...) (reg...)) when not generating    PIC code is in the insn before a tablejump, and we know that m68k.md    generates a label LInnn: on such an insn.     It is possible for PIC to generate a (plus (label_ref...) (reg...))    and we handle that just like we would a (plus (symbol_ref...) (reg...)).     Some SGS assemblers have a bug such that "Lnnn-LInnn-2.b(pc,d0.l*2)"    fails to assemble.  Luckily "Lnnn(pc,d0.l*2)" produces the results    we want.  This difference can be accommodated by using an assembler    define such "LDnnn" to be either "Lnnn-LInnn-2.b", "Lnnn", or any other    string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END    macro.  See m68ksgs.h for an example; for versions without the bug.     They also do not like things like "pea 1.w", so we simple leave off    the .w on small constants.      This routine is responsible for distinguishing between -fpic and -fPIC     style relocations in an address.  When generating -fpic code the    offset is output in word mode (eg movel a5@(_foo:w), a0).  When generating    -fPIC code the offset is output in long mode (eg movel a5@(_foo:l), a0) */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
specifier|register
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|breg
decl_stmt|,
name|ireg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s@"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|PRE_DEC
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s@-"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|POST_INC
case|:
ifdef|#
directive|ifdef
name|MOTOROLA
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)+"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s@+"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|PLUS
case|:
name|reg1
operator|=
name|reg2
operator|=
name|ireg
operator|=
name|breg
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
block|{
if|if
condition|(
name|reg1
operator|==
literal|0
condition|)
block|{
name|reg1
operator|=
name|addr
expr_stmt|;
block|}
else|else
block|{
name|reg2
operator|=
name|addr
expr_stmt|;
block|}
name|addr
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* for OLD_INDEXING */
block|else if (GET_CODE (addr) == PLUS) 	  { 	    if (GET_CODE (XEXP (addr, 0)) == REG) 	      { 		reg2 = XEXP (addr, 0); 		addr = XEXP (addr, 1); 	      } 	    else if (GET_CODE (XEXP (addr, 1)) == REG) 	      { 		reg2 = XEXP (addr, 1); 		addr = XEXP (addr, 0); 	      } 	  }
endif|#
directive|endif
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|addr
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg1
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|MULT
operator|)
operator|)
operator|||
operator|(
name|reg2
operator|!=
literal|0
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|reg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|breg
operator|=
name|reg2
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|!=
literal|0
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
argument_list|)
condition|)
block|{
name|breg
operator|=
name|reg1
expr_stmt|;
name|ireg
operator|=
name|reg2
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|&&
name|breg
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|ireg
operator|==
name|pic_offset_table_rtx
operator|)
condition|)
block|{
name|int
name|scale
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
ifdef|#
directive|ifdef
name|SGS
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%LLD%d(%Rpc,%s.w"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%LL%d-%LLI%d.b(%Rpc,%s.w"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%Rpc@(%LL%d-%LLI%d-2:b,%s:w"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
ifdef|#
directive|ifdef
name|SGS
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%LLD%d(%Rpc,%s.l"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%LL%d-%LLI%d.b(%Rpc,%s.l"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%Rpc@(%LL%d-%LLI%d-2:b,%s:l"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|putc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|breg
operator|!=
literal|0
operator|&&
name|ireg
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|breg
operator|==
name|pic_offset_table_rtx
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
ifdef|#
directive|ifdef
name|SGS
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%LLD%d(%Rpc,%s.l"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%LL%d-%LLI%d.b(%Rpc,%s.l"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%Rpc@(%LL%d-%LLI%d-2:b,%s:l"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|||
name|breg
operator|!=
literal|0
condition|)
block|{
name|int
name|scale
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|breg
operator|==
literal|0
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_pic
operator|&&
name|addr
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MOTOROLA
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag_pic
operator|==
literal|1
operator|)
operator|&&
operator|(
name|breg
operator|==
name|pic_offset_table_rtx
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag_pic
operator|==
literal|2
operator|)
operator|&&
operator|(
name|breg
operator|==
name|pic_offset_table_rtx
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".l"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ireg
operator|!=
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s@("
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag_pic
operator|==
literal|1
operator|)
operator|&&
operator|(
name|breg
operator|==
name|pic_offset_table_rtx
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag_pic
operator|==
literal|2
operator|)
operator|&&
operator|(
name|breg
operator|==
name|pic_offset_table_rtx
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":l"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
literal|0
operator|&&
name|ireg
operator|!=
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s.w"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:w"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|ireg
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s.l"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:l"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|putc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|reg1
operator|==
name|pic_offset_table_rtx
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
ifdef|#
directive|ifdef
name|SGS
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%LLD%d(%Rpc,%s.l)"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg1
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%LL%d-%LLI%d.b(%Rpc,%s.l)"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg1
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%Rpc@(%LL%d-%LLI%d-2:b,%s:l)"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg1
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* FALL-THROUGH (is this really what we want? */
default|default:
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|<
literal|0x8000
operator|&&
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|>=
operator|-
literal|0x8000
condition|)
block|{
ifdef|#
directive|ifdef
name|MOTOROLA
ifdef|#
directive|ifdef
name|SGS
comment|/* Many SGS assemblers croak on size specifiers for constants. */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d.w"
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d:w"
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

end_unit

