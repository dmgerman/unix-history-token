begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Sun SPARC.    Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_comment
comment|/* Global variables for machine-dependent things.  */
end_comment

begin_comment
comment|/* Save the operands last given to a compare for use when we    generate a scc or bcc insn.  */
end_comment

begin_decl_stmt
name|rtx
name|sparc_compare_op0
decl_stmt|,
name|sparc_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We may need an epilogue if we spill too many registers.    If this is non-zero, then we branch here for the epilogue.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|leaf_label
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
end_ifdef

begin_comment
comment|/* Vector to say how input registers are mapped to output    registers.  FRAME_POINTER_REGNUM cannot be remapped by    this function to eliminate it.  You must use -fomit-frame-pointer    to get that.  */
end_comment

begin_decl_stmt
name|char
name|leaf_reg_remap
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|14
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|15
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|leaf_reg_backmap
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|14
block|,
literal|31
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Global variables set by FUNCTION_PROLOGUE.  */
end_comment

begin_comment
comment|/* Size of frame.  Need to know this to emit return insns from    leaf procedures.  */
end_comment

begin_decl_stmt
name|int
name|apparent_fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|actual_fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of where we pretend to think the frame pointer points.    Normally, this is "%fp", but if we are in a leaf procedure,    this is "%sp+something".  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|frame_base_name
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|find_addr_reg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return non-zero only if OP is a register of mode MODE,    or const0_rtx.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP can appear as the dest of a RESTORE insn.  */
end_comment

begin_function
name|int
name|restore_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
literal|8
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PC-relative call insn on SPARC is independent of `memory_operand'.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|call_operand_address
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
comment|/* This clause seems to be irrelevant.  */
case|case
name|CONST_DOUBLE
case|:
return|return
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a symbolic memory    operand of mode MODE.  */
end_comment

begin_function
name|int
name|symbolic_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|HIGH
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or a memory operand that is    not symbolic.  */
end_comment

begin_function
name|int
name|reg_or_nonsymb_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|symbolic_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sparc_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|SMALL_INT
argument_list|(
name|op
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|move_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|arith_double_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
operator|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|move_pic_label
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Special case for PIC.  */
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The rtx for the global offset table which is a special form    that *is* a position independent symbolic constant.  */
end_comment

begin_decl_stmt
name|rtx
name|pic_pc_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ensure that we are not using patterns that are not OK with PIC.  */
end_comment

begin_function
name|int
name|check_pic
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
switch|switch
condition|(
name|flag_pic
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|pic_pc_rtx
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
literal|2
case|:
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if X is an address which needs a temporary register when     reloaded while generating PIC code.  */
end_comment

begin_function
name|int
name|pic_address_needs_scratch
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
comment|/* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|memop
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is EQ or NE.  */
end_comment

begin_function
name|int
name|eq_or_neq
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator, but not an EQ, NE, GEU,    or LTU for non-floating-point.  We handle those specially.  */
end_comment

begin_function
name|int
name|normal_comp_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPEmode
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|code
operator|!=
name|NE
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|GEU
operator|&&
name|code
operator|!=
name|LTU
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator.  This allows the use of    MATCH_OPERATOR to recognize all the branch insns.  */
end_comment

begin_function
name|int
name|noov_compare_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CC_NOOVmode
condition|)
comment|/* These are the only branches which work with CC_NOOVmode.  */
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a SIGN_EXTEND or ZERO_EXTEND operation.  */
end_comment

begin_function
name|int
name|extend_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ZERO_EXTEND
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is an operator of mode MODE which can set    the condition codes explicitly.  We do not include PLUS and MINUS    because these require CC_NOOVmode, which we handle explicitly.  */
end_comment

begin_function
name|int
name|cc_arithop
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|XOR
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is an operator of mode MODE which can bitwise    complement its second operand and set the condition codes explicitly.  */
end_comment

begin_function
name|int
name|cc_arithopn
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* XOR is not here because combine canonicalizes (xor (not ...) ...)      and (xor ... (not ...)) to (not (xor ...)).   */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return truth value of whether OP can be used as an operands in a three    address arithmetic insn (such as add %o1,7,%l2) of mode MODE.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a register or a CONST_DOUBLE.  */
end_comment

begin_function
name|int
name|arith_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|+
literal|0x1000
argument_list|)
operator|<
literal|0x2000
operator|&&
operator|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x1000
operator|)
operator|==
literal|0x1000
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x1000
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x1000
argument_list|)
operator|<
literal|0x2000
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in three-address insns.  */
end_comment

begin_function
name|int
name|small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a call-clobbered register.  */
end_comment

begin_function
name|int
name|clobbered_register
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* X and Y are two things to compare using CODE.  Emit the compare insn and    return the rtx for register 0 in the proper mode.  */
end_comment

begin_function
name|rtx
name|gen_compare_reg
parameter_list|(
name|code
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx
argument_list|(
name|COMPARE
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if a return peephole merging return with    setting of output register is ok.  */
end_comment

begin_function
name|int
name|leaf_return_peephole_ok
parameter_list|()
block|{
return|return
operator|(
name|actual_fsize
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL can go into the function epilogue's    delay slot.  SLOT is the slot we are trying to fill.  */
end_comment

begin_function
name|int
name|eligible_for_epilogue_delay
parameter_list|(
name|trial
parameter_list|,
name|slot
parameter_list|)
name|rtx
name|trial
decl_stmt|;
name|int
name|slot
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|this_function_name
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|src
decl_stmt|;
if|if
condition|(
name|slot
operator|>=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* In the case of a true leaf function, anything can go into the delay slot.      A delay slot only exists however if the frame size is zero, otherwise      we will put an insn to adjust the stack after the return.  */
if|if
condition|(
name|leaf_function
condition|)
block|{
if|if
condition|(
name|leaf_return_peephole_ok
argument_list|()
condition|)
return|return
operator|(
name|get_attr_in_uncond_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_BRANCH_DELAY_TRUE
operator|)
return|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise, only operations which can be done in tandem with      a `restore' insn can go into the delay slot.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|>=
literal|32
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|<
literal|24
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|arith_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
return|;
if|if
condition|(
name|arith_double_operand
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|arith_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MINUS
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|small_int
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MINUS
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|&&
name|arith_double_operand
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DImode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|short_branch
parameter_list|(
name|uid1
parameter_list|,
name|uid2
parameter_list|)
name|int
name|uid1
decl_stmt|,
name|uid2
decl_stmt|;
block|{
name|unsigned
name|int
name|delta
init|=
name|insn_addresses
index|[
name|uid1
index|]
operator|-
name|insn_addresses
index|[
name|uid2
index|]
decl_stmt|;
if|if
condition|(
name|delta
operator|+
literal|1024
operator|<
literal|2048
condition|)
return|return
literal|1
return|;
comment|/* warning ("long branch, distance %d", delta); */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if REG is not used after INSN.    We assume REG is a reload reg, and therefore does    not live past labels or calls or jumps.  */
end_comment

begin_function
name|int
name|reg_unused_after
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|,
name|prev_code
init|=
name|UNKNOWN
decl_stmt|;
while|while
condition|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|in_src
init|=
name|set
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|&&
name|in_src
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|set
operator|==
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already position-independent,    we return ORIG.  Newly generated position-independent addresses go into a    reg.  This is REG if non zero, otherwise we allocate register(s) as    necessary.  If this is called during reload, and we need a second temp    register, then we use SCRATCH, which is provided via the    SECONDARY_INPUT_RELOAD_CLASS mechanism.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|,
name|scratch
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|scratch
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|rtx
name|pic_ref
decl_stmt|,
name|address
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
comment|/* If not during reload, allocate another temp reg here for loading 	     in the address, so that these instructions can be optimized 	     properly.  */
name|rtx
name|temp_reg
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
comment|/* Must put the SYMBOL_REF inside an UNSPEC here so that cse 	     won't get confused into thinking that these two instructions 	     are loading in the true address of the symbol.  If in the 	     future a PIC rtx exists, that should be used instead.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|temp_reg
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|UNSPEC
argument_list|,
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|orig
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|temp_reg
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|temp_reg
argument_list|,
name|gen_rtx
argument_list|(
name|UNSPEC
argument_list|,
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|orig
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|temp_reg
expr_stmt|;
block|}
else|else
name|address
operator|=
name|orig
expr_stmt|;
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
comment|/* Put a REG_EQUAL note on this insn, so that it can be optimized 	 by loop.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|orig
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* We can't create any new registers during reload, so use the 	     SCRATCH reg provided by the reload_insi pattern.  */
elseif|else
if|if
condition|(
name|scratch
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|scratch
expr_stmt|;
block|}
else|else
comment|/* If we reach here, then the SECONDARY_INPUT_RELOAD_CLASS 	       macro needs to be adjusted so that a scratch reg is provided 	       for this address.  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Set up PIC-specific rtl.  This should not cause any insns    to be emitted.  */
end_comment

begin_function
name|void
name|initialize_pic
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Emit special PIC prologues and epilogues.  */
end_comment

begin_function
name|void
name|finalize_pic
parameter_list|()
block|{
comment|/* The table we use to reference PIC data.  */
name|rtx
name|global_offset_table
decl_stmt|;
comment|/* Labels to get the PC in the prologue of this function.  */
name|rtx
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|int
name|orig_flag_pic
init|=
name|flag_pic
decl_stmt|;
if|if
condition|(
name|current_function_uses_pic_offset_table
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|abort
argument_list|()
expr_stmt|;
name|flag_pic
operator|=
literal|0
expr_stmt|;
name|l1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|l2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|l1
argument_list|)
expr_stmt|;
comment|/* Note that we pun calls and jumps here!  */
name|emit_jump_insn
argument_list|(
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|l2
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|15
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|l2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|l2
argument_list|)
expr_stmt|;
comment|/* Initialize every time through, since we can't easily      know this to be permanent.  */
name|global_offset_table
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|pic_pc_rtx
operator|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|global_offset_table
argument_list|,
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|l1
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|pic_pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|pic_pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|15
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, "!#PROLOGUE# 1")); */
name|LABEL_PRESERVE_P
argument_list|(
name|l1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|LABEL_PRESERVE_P
argument_list|(
name|l2
argument_list|)
operator|=
literal|1
expr_stmt|;
name|flag_pic
operator|=
name|orig_flag_pic
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Need to emit this whether or not we obey regdecls,      since setjmp/longjmp can cause life info to screw up.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For the SPARC, REG and REG+CONST is cost 0, REG+REG is cost 1,    and addresses involving symbolic constants are cost 2.     We make REG+REG slightly more expensive because it might keep    a register live for longer than we might like.     PIC addresses are very expensive.     It is no coincidence that this has the same structure    as GO_IF_LEGITIMATE_ADDRESS.  */
end_comment

begin_function
name|int
name|sparc_address_cost
parameter_list|(
name|X
parameter_list|)
name|rtx
name|X
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* Handled before calling here.  */
block|if (GET_CODE (X) == REG)     { return 1; }
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|X
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|X
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|X
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|X
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|X
argument_list|)
operator|==
name|HIGH
condition|)
return|return
literal|2
return|;
return|return
literal|4
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].     Return 1 if we have written out everything that needs to be done to    do the move.  Otherwise, return 0 and the caller will emit the move    normally.     SCRATCH_REG if non zero can be used as a scratch register for the move    operation.  It is provided by a SECONDARY_RELOAD_* macro if needed.  */
end_comment

begin_function
name|int
name|emit_move_sequence
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|,
name|scratch_reg
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|scratch_reg
decl_stmt|;
block|{
specifier|register
name|rtx
name|operand0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|operand1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
comment|/* Handle most common case first: storing into a register.  */
if|if
condition|(
name|register_operand
argument_list|(
name|operand0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|operand1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|arith_double_operand
argument_list|(
name|operand1
argument_list|,
name|DImode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|HIGH
operator|&&
name|GET_MODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|DImode
operator|)
comment|/* Only `general_operands' can come here, so MEM is ok.  */
operator|||
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Run this case quickly.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand0
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|||
name|operand1
operator|==
name|const0_rtx
condition|)
block|{
comment|/* Run this case quickly.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|reload_in_progress
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|validize_mem
argument_list|(
name|operand0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operand1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Simplify the source if we need to.  Must handle DImode HIGH operators      here because such a move needs a clobber added.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|HIGH
operator|&&
name|immediate_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|HIGH
operator|&&
name|GET_MODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|DImode
operator|)
condition|)
block|{
if|if
condition|(
name|flag_pic
operator|&&
name|symbolic_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|temp_reg
init|=
name|reload_in_progress
condition|?
name|operand0
else|:
literal|0
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|,
name|temp_reg
argument_list|,
name|scratch_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_INT
condition|?
operator|(
operator|!
name|SMALL_INT
argument_list|(
name|operand1
argument_list|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|operand1
argument_list|)
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
operator|)
else|:
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|?
operator|!
name|arith_double_operand
argument_list|(
name|operand1
argument_list|,
name|DImode
argument_list|)
else|:
literal|1
operator|)
condition|)
block|{
comment|/* For DImode values, temp must be operand0 because of the way 	     HI and LO_SUM work.  The LO_SUM operator only copies half of 	     the LSW from the dest of the HI operator.  If the LO_SUM dest is 	     not the same as the HI dest, then the MSW of the LO_SUM dest will 	     never be set.  	     ??? The real problem here is that the ...(HI:DImode pattern emits 	     multiple instructions, and the ...(LO_SUM:DImode pattern emits 	     one instruction.  This fails, because the compiler assumes that 	     LO_SUM copies all bits of the first operand to its dest.  Better 	     would be to have the HI pattern emit one instruction and the 	     LO_SUM pattern multiple instructions.  Even better would be 	     to use four rtl insns.  */
name|rtx
name|temp
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
name|mode
operator|==
name|DImode
operator|)
condition|?
name|operand0
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|mode
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|flag_pic
condition|)
block|{
comment|/* The procedure for doing this involves using a call instruction to 	 get the pc into o7.  We need to indicate this explicitly because 	 the tablejump pattern assumes that it can use this value also.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
literal|15
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now have insn-emit do whatever it normally does.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|"st %r1,%0"
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"ld %1,%0"
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
union|union
name|float_extract
block|{
name|float
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|v
union|;
comment|/* Must be SFmode, otherwise this doesn't make sense.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|SFmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|v
operator|.
name|f
operator|=
name|REAL_VALUE_TRUNCATE
argument_list|(
name|SFmode
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
name|i
operator|=
name|v
operator|.
name|i
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|i
argument_list|,
literal|'I'
argument_list|)
condition|)
return|return
literal|"mov %1,%0"
return|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|&
literal|0x000003FF
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi %%hi(%a1),%0\n\tor %0,%%lo(%a1),%0"
return|;
else|else
return|return
literal|"sethi %%hi(%a1),%0"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|'I'
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/* If all low order 10 bits are clear, then we only need a single 	 sethi insn to load the constant.  */
if|if
condition|(
operator|(
name|i
operator|&
literal|0x000003FF
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi %%hi(%a1),%0\n\tor %0,%%lo(%a1),%0"
return|;
else|else
return|return
literal|"sethi %%hi(%a1),%0"
return|;
block|}
comment|/* Operand 1 must be a register, or a 'I' type CONST_INT.  */
return|return
literal|"mov %1,%0"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if it is OK to assume that the given memory operand is    aligned at least to a 8-byte boundary.  This should only be called    for memory accesses whose size is 8 bytes or larger.  */
end_comment

begin_function
name|int
name|mem_aligned_8
parameter_list|(
name|mem
parameter_list|)
specifier|register
name|rtx
name|mem
decl_stmt|;
block|{
specifier|register
name|rtx
name|addr
decl_stmt|;
specifier|register
name|rtx
name|base
decl_stmt|;
specifier|register
name|rtx
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* It's gotta be a MEM! */
name|addr
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Now that all misaligned double parms are copied on function entry,      we can assume any 64-bit object is 64-bit aligned.  */
comment|/* See what register we use in the address.  */
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|addr
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* If it's the stack or frame pointer, check offset alignment.      We can have improper alignment in the function entry code.  */
if|if
condition|(
name|base
operator|&&
operator|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|else
comment|/* Anything else, we know is properly aligned.  */
return|return
literal|1
return|;
else|#
directive|else
comment|/* If the operand is known to have been allocated in static storage, then      it must be aligned.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
literal|1
return|;
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|addr
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
comment|/* Trust round enough offsets from the stack or frame pointer.      If TARGET_HOPE_ALIGN, trust round enough offset from any register.      If it is obviously unaligned, don't ever return true.  */
if|if
condition|(
name|base
operator|&&
operator|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|TARGET_HOPE_ALIGN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* Otherwise, we can assume that an access is aligned if it is to an      aggregate.  Also, if TARGET_HOPE_ALIGN, then assume everything that isn't      obviously unaligned is aligned.  */
elseif|else
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|||
name|TARGET_HOPE_ALIGN
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* An obviously unaligned address.  */
return|return
literal|0
return|;
block|}
end_function

begin_enum
enum|enum
name|optype
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
enum|;
end_enum

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  This is very similar to the following    output_move_quad function.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|enum
name|optype
name|optype0
decl_stmt|;
specifier|register
name|enum
name|optype
name|optype1
decl_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|;
name|rtx
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op0
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
operator|||
operator|(
name|optype0
operator|==
name|MEM
operator|&&
name|optype1
operator|==
name|MEM
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Set up in LATEHALF the operands to use for the      high-numbered (least significant) word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
name|split_double
argument_list|(
name|op1
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
comment|/* Easy case: try moving both words at once.  Check for moving between      an even/odd register pair and a memory location.  */
if|if
condition|(
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|optype1
operator|!=
name|CNSTOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|optype0
operator|!=
name|REGOP
operator|&&
name|optype0
operator|!=
name|CNSTOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|register
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|mem
operator|=
name|op1
expr_stmt|;
else|else
name|mem
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|mem_aligned_8
argument_list|(
name|mem
argument_list|)
condition|)
return|return
operator|(
name|mem
operator|==
name|op1
condition|?
literal|"ldd %1,%0"
else|:
literal|"std %1,%0"
operator|)
return|;
block|}
comment|/* If the first move would clobber the source of the second one,      do them in the other order.  */
comment|/* Overlapping registers.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Loading into a register which overlaps a register used in the address.  */
elseif|else
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
comment|/* ??? This fails if the address is a double register address, each 	 of which is clobbered by operand 0.  */
comment|/* Do the late half first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Then clobber.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to perform a quadword move insn    with operands OPERANDS.  This is very similar to the preceding    output_move_double function.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_quad
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|enum
name|optype
name|optype0
decl_stmt|;
specifier|register
name|enum
name|optype
name|optype1
decl_stmt|;
name|rtx
name|wordpart
index|[
literal|4
index|]
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|;
name|rtx
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op0
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op1
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
operator|||
operator|(
name|optype0
operator|==
name|MEM
operator|&&
name|optype1
operator|==
name|MEM
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the later words.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Set up in wordpart the operands to use for each word of the arguments.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op0
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
block|}
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|op1
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
comment|/* This case isn't implemented yet, because there is no internal 	 representation for quad-word constants, and there is no split_quad 	 function.  */
if|#
directive|if
literal|0
block|split_quad (op1,&wordpart[0][1],&wordpart[1][1],&wordpart[2][1],&wordpart[3][1]);
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|wordpart
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|wordpart
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|wordpart
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
block|}
comment|/* Easy case: try moving the quad as two pairs.  Check for moving between      an even/odd register pair and a memory location.  */
comment|/* ??? Should also handle the case of non-offsettable addresses here.      We can at least do the first pair as a ldd/std, and then do the third      and fourth words individually.  */
if|if
condition|(
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|OFFSOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|optype0
operator|==
name|OFFSOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|mem
operator|=
name|op1
expr_stmt|;
else|else
name|mem
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|mem_aligned_8
argument_list|(
name|mem
argument_list|)
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|mem
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|op1
condition|)
return|return
literal|"ldd %1,%0;ldd %2,%S0"
return|;
else|else
return|return
literal|"std %1,%0;std %S1,%2"
return|;
block|}
block|}
comment|/* If the first move would clobber the source of the second one,      do them in the other order.  */
comment|/* Overlapping registers.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|3
index|]
argument_list|)
operator|||
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|||
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|wordpart
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Do fourth word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Do the third word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Do the second word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Do lowest-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/* Loading into a register which overlaps a register used in the address.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
comment|/* ??? Not implemented yet.  This is a bit complicated, because we 	 must load which ever part overlaps the address last.  If the address 	 is a double-reg address, then there are two parts which need to 	 be done last, which is impossible.  We would need a scratch register 	 in that case.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Normal case: move the four words in lowest to higest address order.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at the second word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do the second word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at the third word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do the third word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at the fourth word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,0x4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do the fourth word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|wordpart
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|wordpart
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0xc,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"add %0,-0xc,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to perform a doubleword move insn with operands    OPERANDS, one of which must be a floating point register.  */
end_comment

begin_function
name|char
modifier|*
name|output_fp_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|"fmovs %1,%0\n\tfmovs %R1,%R0"
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"std %1,[%@-8]\n\tldd [%@-8],%0"
return|;
else|else
return|return
literal|"st %R1,[%@-4]\n\tst %1,[%@-8]\n\tldd [%@-8],%0"
return|;
block|}
else|else
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"std %1,[%@-8]\n\tldd [%@-8],%0"
return|;
else|else
return|return
literal|"std %1,[%@-8]\n\tld [%@-4],%R0\n\tld [%@-8],%0"
return|;
block|}
else|else
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output assembler code to perform a quadword move insn with operands    OPERANDS, one of which must be a floating point register.  */
end_comment

begin_function
name|char
modifier|*
name|output_fp_move_quad
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
literal|"fmovs %1,%0\n\tfmovs %R1,%R0\n\tfmovs %S1,%S0\n\tfmovs %T1,%T0"
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"std %1,[%@-8]\n\tldd [%@-8],%0\n\tstd %S1,[%@-8]\n\tldd [%@-8],%S0"
return|;
else|else
return|return
literal|"st %R1,[%@-4]\n\tst %1,[%@-8]\n\tldd [%@-8],%0\n\tst %T1,[%@-4]\n\tst %S1,[%@-8]\n\tldd [%@-8],%S0"
return|;
block|}
else|else
return|return
name|output_move_quad
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|"std %1,[%@-8]\n\tldd [%@-8],%0\n\tstd %S1,[%@-8]\n\tldd [%@-8],%S0"
return|;
else|else
return|return
literal|"std %S1,[%@-8]\n\tld [%@-4],%T0\n\tld [%@-8],%S0\n\tstd %1,[%@-8]\n\tld [%@-4],%R0\n\tld [%@-8],%0"
return|;
block|}
else|else
return|return
name|output_move_quad
argument_list|(
name|operands
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* We absolutely can not fudge the frame pointer here, because the 	 frame pointer must always be 8 byte aligned.  It also confuses 	 debuggers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_sized_memop
parameter_list|(
name|opname
parameter_list|,
name|mode
parameter_list|,
name|signedp
parameter_list|)
name|char
modifier|*
name|opname
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|signedp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|ld_size_suffix_u
index|[]
init|=
block|{
literal|"ub"
block|,
literal|"uh"
block|,
literal|""
block|,
literal|"?"
block|,
literal|"d"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|ld_size_suffix_s
index|[]
init|=
block|{
literal|"sb"
block|,
literal|"sh"
block|,
literal|""
block|,
literal|"?"
block|,
literal|"d"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|st_size_suffix
index|[]
init|=
block|{
literal|"b"
block|,
literal|"h"
block|,
literal|""
block|,
literal|"?"
block|,
literal|"d"
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|opnametab
decl_stmt|,
modifier|*
name|modename
decl_stmt|;
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'l'
condition|)
if|if
condition|(
name|signedp
condition|)
name|opnametab
operator|=
name|ld_size_suffix_s
expr_stmt|;
else|else
name|opnametab
operator|=
name|ld_size_suffix_u
expr_stmt|;
else|else
name|opnametab
operator|=
name|st_size_suffix
expr_stmt|;
name|modename
operator|=
name|opnametab
index|[
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>>
literal|1
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s%s"
argument_list|,
name|opname
argument_list|,
name|modename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|output_move_with_extension
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|HImode
condition|)
name|output_asm_insn
argument_list|(
literal|"sll %2,0x10,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|QImode
condition|)
name|output_asm_insn
argument_list|(
literal|"sll %2,0x18,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load the address specified by OPERANDS[3] into the register    specified by OPERANDS[0].     OPERANDS[3] may be the result of a sum, hence it could either be:     (1) CONST    (2) REG    (2) REG + CONST_INT    (3) REG + REG + CONST_INT    (4) REG + REG  (special case of 3).     Note that (3) is not a legitimate address.    All cases are handled here.  */
end_comment

begin_function
name|void
name|output_load_address
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"set %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"mov %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|offset
expr_stmt|;
name|offset
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
comment|/* Operand is (PLUS (REG) (REG)).  */
name|base
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|operands
index|[
literal|6
index|]
operator|=
name|base
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"add %6,%7,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"set %7,%0\n\tadd %0,%6,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|operands
index|[
literal|6
index|]
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|8
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|SMALL_INT
argument_list|(
name|offset
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"add %6,%7,%0\n\tadd %0,%8,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"set %8,%0\n\tadd %0,%6,%0\n\tadd %0,%7,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code to place a size count SIZE in register REG.    ALIGN is the size of the unit of transfer.     Because block moves are pipelined, we don't include the    first element in the transfer of SIZE to REG.  */
end_comment

begin_function
specifier|static
name|void
name|output_size_for_block_move
parameter_list|(
name|size
parameter_list|,
name|reg
parameter_list|,
name|align
parameter_list|)
name|rtx
name|size
decl_stmt|,
name|reg
decl_stmt|;
name|rtx
name|align
decl_stmt|;
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|reg
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|size
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|align
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|REG
condition|)
name|output_asm_insn
argument_list|(
literal|"sub %1,%2,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|else
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"set %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to perform a block move.     OPERANDS[0] is the destination.    OPERANDS[1] is the source.    OPERANDS[2] is the size.    OPERANDS[3] is the alignment safe to use.    OPERANDS[4] is a register we can safely clobber as a temp.  */
end_comment

begin_function
name|char
modifier|*
name|output_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* A vector for our computed operands.  Note that load_output_address      makes use of (and can clobber) up to the 8th element of this vector.  */
name|rtx
name|xoperands
index|[
literal|10
index|]
decl_stmt|;
name|rtx
name|zoperands
index|[
literal|10
index|]
decl_stmt|;
specifier|static
name|int
name|movstrsi_label
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|temp1
init|=
name|operands
index|[
literal|4
index|]
decl_stmt|;
name|rtx
name|sizertx
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|alignrtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|align
init|=
name|INTVAL
argument_list|(
name|alignrtx
argument_list|)
decl_stmt|;
name|char
name|label3
index|[
literal|30
index|]
decl_stmt|,
name|label5
index|[
literal|30
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|temp1
expr_stmt|;
comment|/* We can't move more than this many bytes at a time because we have only      one register, %g1, to move them through.  */
if|if
condition|(
name|align
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|align
operator|=
name|UNITS_PER_WORD
expr_stmt|;
name|alignrtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
comment|/* We consider 8 ld/st pairs, for a total of 16 inline insns to be      reasonable here.  (Actually will emit a maximum of 18 inline insns for      the case of size == 31 and align == 4).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|sizertx
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|sizertx
argument_list|)
operator|/
name|align
operator|)
operator|<=
literal|8
operator|&&
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|plus_constant_for_output
argument_list|(
name|xoperands
index|[
literal|0
index|]
argument_list|,
name|INTVAL
argument_list|(
name|sizertx
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|plus_constant_for_output
argument_list|(
name|xoperands
index|[
literal|1
index|]
argument_list|,
name|INTVAL
argument_list|(
name|sizertx
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|INTVAL
argument_list|(
name|sizertx
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* We will store different integers into this particular RTX.  */
name|xoperands
index|[
literal|2
index|]
operator|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|xoperands
index|[
literal|2
index|]
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
comment|/* This case is currently not handled.  Abort instead of generating 	 bad code.  */
if|if
condition|(
name|align
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|>=
literal|4
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|>>
literal|2
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|2
index|]
argument_list|)
operator|=
operator|(
name|i
operator|<<
literal|2
operator|)
operator|+
name|offset
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld [%a1+%2],%%g1\n\tst %%g1,[%a0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
operator|(
name|size
operator|&
operator|~
literal|0x3
operator|)
expr_stmt|;
name|size
operator|=
name|size
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
literal|""
return|;
block|}
if|if
condition|(
name|align
operator|>=
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|>>
literal|1
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|2
index|]
argument_list|)
operator|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
name|offset
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"lduh [%a1+%2],%%g1\n\tsth %%g1,[%a0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
operator|(
name|size
operator|&
operator|~
literal|0x1
operator|)
expr_stmt|;
name|size
operator|=
name|size
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
literal|""
return|;
block|}
if|if
condition|(
name|align
operator|>=
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|2
index|]
argument_list|)
operator|=
name|i
operator|+
name|offset
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldub [%a1+%2],%%g1\n\tstb %%g1,[%a0+%2]"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
comment|/* We should never reach here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If the size isn't known to be a multiple of the alignment,      we have to do it in smaller pieces.  If we could determine that      the size was a multiple of 2 (or whatever), we could be smarter      about this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|sizertx
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|align
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|size
init|=
name|INTVAL
argument_list|(
name|sizertx
argument_list|)
decl_stmt|;
while|while
condition|(
name|size
operator|%
name|align
condition|)
name|align
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|!=
name|INTVAL
argument_list|(
name|alignrtx
argument_list|)
condition|)
name|alignrtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|4
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|5
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label3
argument_list|,
literal|"Lm"
argument_list|,
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label5
argument_list|,
literal|"Lm"
argument_list|,
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is the size of the transfer.  Emit code to decrement the size      value by ALIGN, and store the result in the temp1 register.  */
name|output_size_for_block_move
argument_list|(
name|sizertx
argument_list|,
name|temp1
argument_list|,
name|alignrtx
argument_list|)
expr_stmt|;
comment|/* Must handle the case when the size is zero or negative, so the first thing      we do is compare the size against zero, and only copy bytes if it is      zero or greater.  Note that we have already subtracted off the alignment      once, so we must copy 1 alignment worth of bytes if the size is zero      here.       The SUN assembler complains about labels in branch delay slots, so we      do this before outputting the load address, so that there will always      be a harmless insn between the branch here and the next label emitted      below.  */
block|{
name|char
name|pattern
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|pattern
argument_list|,
literal|"cmp %%2,0\n\tbl %s"
argument_list|,
operator|&
name|label5
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|pattern
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
name|zoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|zoperands
index|[
literal|3
index|]
operator|=
name|plus_constant_for_output
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|output_load_address
argument_list|(
name|zoperands
argument_list|)
expr_stmt|;
comment|/* ??? This might be much faster if the loops below were preconditioned      and unrolled.       That is, at run time, copy enough bytes one at a time to ensure that the      target and source addresses are aligned to the the largest possible      alignment.  Then use a preconditioned unrolled loop to copy say 16      bytes at a time.  Then copy bytes one at a time until finish the rest.  */
comment|/* Output the first label separately, so that it is spaced properly.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"Lm"
argument_list|,
name|INTVAL
argument_list|(
name|xoperands
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|char
name|pattern
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|ld_suffix
init|=
operator|(
name|align
operator|==
literal|1
operator|)
condition|?
literal|"ub"
else|:
operator|(
name|align
operator|==
literal|2
operator|)
condition|?
literal|"uh"
else|:
literal|""
decl_stmt|;
specifier|register
name|char
modifier|*
name|st_suffix
init|=
operator|(
name|align
operator|==
literal|1
operator|)
condition|?
literal|"b"
else|:
operator|(
name|align
operator|==
literal|2
operator|)
condition|?
literal|"h"
else|:
literal|""
decl_stmt|;
name|sprintf
argument_list|(
name|pattern
argument_list|,
literal|"ld%s [%%1+%%2],%%%%g1\n\tsubcc %%2,%%4,%%2\n\tbge %s\n\tst%s %%%%g1,[%%0+%%2]\n%s:"
argument_list|,
name|ld_suffix
argument_list|,
operator|&
name|label3
index|[
literal|1
index|]
argument_list|,
name|st_suffix
argument_list|,
operator|&
name|label5
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|pattern
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output reasonable peephole for set-on-condition-code insns.    Note that these insns assume a particular way of defining    labels.  Therefore, *both* sparc.h and this function must    be changed if a new syntax is needed.    */
end_comment

begin_function
name|char
modifier|*
name|output_scc_insn
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|100
index|]
decl_stmt|;
name|rtx
name|label
init|=
literal|0
decl_stmt|,
name|next
init|=
name|insn
decl_stmt|;
name|int
name|need_label
init|=
literal|0
decl_stmt|;
comment|/* Try doing a jump optimization which jump.c can't do for us      because we did not expose that setcc works by using branches.       If this scc insn is followed by an unconditional branch, then have      the jump insn emitted here jump to that location, instead of to      the end of the scc sequence as usual.  */
do|do
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|label
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
break|break;
block|}
do|while
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
do|;
comment|/* If we are in a sequence, and the following insn is a sequence also,      then just following the current insn's next field will take us to the      first insn of the next sequence, which is the wrong place.  We don't      want to optimize with a branch that has had its delay slot filled.      Avoid this by verifying that NEXT_INSN (PREV_INSN (next)) == next      which fails only if NEXT is such a branch.  */
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|next
argument_list|)
operator|&&
operator|(
operator|!
name|final_sequence
operator|||
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|next
operator|)
condition|)
name|label
operator|=
name|JUMP_LABEL
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* If not optimizing, jump label fields are not set.  To be safe, always      check here to whether label is still zero.  */
if|if
condition|(
name|label
operator|==
literal|0
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|need_label
operator|=
literal|1
expr_stmt|;
block|}
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|label
expr_stmt|;
comment|/* If we are in a delay slot, assume it is the delay slot of an fpcc      insn since our type isn't allowed anywhere else.  */
comment|/* ??? Fpcc instructions no longer have delay slots, so this code is      probably obsolete.  */
comment|/* The fastest way to emit code for this is an annulled branch followed      by two move insns.  This will take two cycles if the branch is taken,      and three cycles if the branch is not taken.       However, if we are in the delay slot of another branch, this won't work,      because we can't put a branch in the delay slot of another branch.      The above sequence would effectively take 3 or 4 cycles respectively      since a no op would have be inserted between the two branches.      In this case, we want to emit a move, annulled branch, and then the      second move.  This sequence always takes 3 cycles, and hence is faster      when we are in a branch delay slot.  */
if|if
condition|(
name|final_sequence
condition|)
block|{
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"mov 0,%0\n\t"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|output_cbranch
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n\tmov 1,%0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|string
argument_list|,
name|output_cbranch
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n\tmov 1,%0\n\tmov 0,%0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_label
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n%l2:"
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Vectors to keep interesting information about registers where    it can easily be got.  */
end_comment

begin_comment
comment|/* Modes for condition codes.  */
end_comment

begin_define
define|#
directive|define
name|C_MODES
define|\
value|((1<< (int) CCmode) | (1<< (int) CC_NOOVmode)	\    | (1<< (int) CCFPmode) | (1<< (int) CCFPEmode))
end_define

begin_comment
comment|/* Modes for single-word (and smaller) quantities.  */
end_comment

begin_define
define|#
directive|define
name|S_MODES
define|\
value|(~C_MODES						\& ~ ((1<< (int) DImode) | (1<< (int) TImode)	\       | (1<< (int) DFmode) | (1<< (int) TFmode)))
end_define

begin_comment
comment|/* Modes for double-word (and smaller) quantities.  */
end_comment

begin_define
define|#
directive|define
name|D_MODES
define|\
value|(~C_MODES					\& ~ ((1<< (int) TImode) | (1<< (int) TFmode)))
end_define

begin_comment
comment|/* Modes for quad-word quantities.  */
end_comment

begin_define
define|#
directive|define
name|T_MODES
value|(~C_MODES)
end_define

begin_comment
comment|/* Modes for single-float quantities.  We must allow any single word or    smaller quantity.  This is because the fix/float conversion instructions    take integer inputs/outputs from the float registers.  */
end_comment

begin_define
define|#
directive|define
name|SF_MODES
value|(S_MODES)
end_define

begin_comment
comment|/* Modes for double-float quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_MODES
value|(SF_MODES | (1<< (int) DFmode) | (1<< (int) SCmode))
end_define

begin_comment
comment|/* Modes for quad-float quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_MODES
value|(DF_MODES | (1<< (int) TFmode) | (1<< (int) DCmode))
end_define

begin_comment
comment|/* Value is 1 if register/mode pair is acceptable on sparc.    The funny mixture of D and T modes is because integer operations    do not specially operate on tetra quantities, so non-quad-aligned    registers can hold quadword quantities (except %o4 and %i4 because    they cross fixed registers.  */
end_comment

begin_decl_stmt
name|int
name|hard_regno_mode_ok
index|[]
init|=
block|{
name|C_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|,
name|TF_MODES
block|,
name|SF_MODES
block|,
name|DF_MODES
block|,
name|SF_MODES
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|int
name|save_regs
parameter_list|(
name|file
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|,
name|n_fregs
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|n_fregs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstd %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_fregs
argument_list|)
operator|,
name|n_fregs
operator|+=
literal|2
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_fregs
argument_list|)
operator|,
name|n_fregs
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s+%d]\n"
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_fregs
argument_list|)
operator|,
name|n_fregs
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|n_fregs
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|int
name|restore_regs
parameter_list|(
name|file
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|base
parameter_list|,
name|offset
parameter_list|,
name|n_fregs
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|low
init|;
name|i
operator|<
name|high
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldd [%s+%d], %s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_fregs
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
operator|,
name|n_fregs
operator|+=
literal|2
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld [%s+%d],%s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_fregs
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
operator|,
name|n_fregs
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld [%s+%d],%s\n"
argument_list|,
name|base
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|n_fregs
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|,
name|n_fregs
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|n_fregs
return|;
block|}
end_function

begin_comment
comment|/* Static variables we want to share between prologue and epilogue.  */
end_comment

begin_comment
comment|/* Number of live floating point registers needed to be saved.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_fregs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if any floating point register was ever used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fregs_ever_live
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|compute_frame_size
parameter_list|(
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
name|int
name|fregs_ever_live
init|=
literal|0
decl_stmt|;
name|int
name|n_fregs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|int
name|outgoing_args_size
init|=
operator|(
name|current_function_outgoing_args_size
operator|+
name|REG_PARM_STACK_SPACE
argument_list|(
name|current_function_decl
argument_list|)
operator|)
decl_stmt|;
name|apparent_fsize
operator|=
operator|(
operator|(
name|size
operator|)
operator|+
literal|7
operator|-
name|STARTING_FRAME_OFFSET
operator|)
operator|&
operator|-
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|+=
literal|2
control|)
name|fregs_ever_live
operator||=
name|regs_ever_live
index|[
name|i
index|]
operator||
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|&&
name|fregs_ever_live
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
name|n_fregs
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Set up values for use in `function_epilogue'.  */
name|num_fregs
operator|=
name|n_fregs
expr_stmt|;
name|apparent_fsize
operator|+=
operator|(
name|outgoing_args_size
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|leaf_function
operator|&&
name|n_fregs
operator|==
literal|0
operator|&&
name|apparent_fsize
operator|==
operator|(
name|REG_PARM_STACK_SPACE
argument_list|(
name|current_function_decl
argument_list|)
operator|-
name|STARTING_FRAME_OFFSET
operator|)
condition|)
name|apparent_fsize
operator|=
literal|0
expr_stmt|;
name|actual_fsize
operator|=
name|apparent_fsize
operator|+
name|n_fregs
operator|*
literal|4
expr_stmt|;
comment|/* Make sure nothing can clobber our register windows.      If a SAVE must be done, or there is a stack-local variable,      the register window area must be allocated.  */
if|if
condition|(
name|leaf_function
operator|==
literal|0
operator|||
name|size
operator|>
literal|0
condition|)
name|actual_fsize
operator|+=
operator|(
literal|16
operator|*
name|UNITS_PER_WORD
operator|)
operator|+
literal|8
expr_stmt|;
return|return
name|actual_fsize
return|;
block|}
end_function

begin_comment
comment|/* Output code for the function prologue.  */
end_comment

begin_function
name|void
name|output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
if|if
condition|(
name|leaf_function
condition|)
name|frame_base_name
operator|=
literal|"%sp+80"
expr_stmt|;
else|else
name|frame_base_name
operator|=
literal|"%fp"
expr_stmt|;
comment|/* Need to use actual_fsize, since we are also allocating      space for our callee (and our own register save area).  */
name|actual_fsize
operator|=
name|compute_frame_size
argument_list|(
name|size
argument_list|,
name|leaf_function
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t!#PROLOGUE# 0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_fsize
operator|==
literal|0
condition|)
comment|/* do nothing.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
block|{
if|if
condition|(
operator|!
name|leaf_function
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave %%sp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
comment|/* For frames in the range 4097..8192, we can use just two insns.  */
if|if
condition|(
operator|!
name|leaf_function
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave %%sp,-4096,%%sp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,-4096,%%sp\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,-%d,%%sp\n"
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|leaf_function
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi %%hi(-%d),%%g1\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor %%g1,%%lo(-%d),%%g1\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsave %%sp,%%g1,%%sp\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi %%hi(-%d),%%g1\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor %%g1,%%lo(-%d),%%g1\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %%sp,%%g1,%%sp\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If doing anything with PIC, do it now.  */
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t!#PROLOGUE# 1\n"
argument_list|)
expr_stmt|;
comment|/* Figure out where to save any special registers.  */
if|if
condition|(
name|num_fregs
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|n_fregs
init|=
name|num_fregs
decl_stmt|;
if|if
condition|(
operator|!
name|leaf_function
condition|)
name|offset
operator|=
operator|-
name|apparent_fsize
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|&&
operator|!
name|leaf_function
condition|)
name|n_fregs
operator|=
name|save_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|frame_base_name
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|leaf_function
condition|)
name|n_fregs
operator|=
name|save_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|,
name|frame_base_name
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
condition|)
name|save_regs
argument_list|(
name|file
argument_list|,
literal|32
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|frame_base_name
argument_list|,
name|offset
argument_list|,
name|n_fregs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|62
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst %s,[%s-16]\n\tst %s,[%s-12]\n"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|frame_base_name
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|frame_base_name
argument_list|)
expr_stmt|;
name|leaf_label
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|leaf_function
operator|&&
name|actual_fsize
operator|!=
literal|0
condition|)
block|{
comment|/* warning ("leaf procedure with frame size %d", actual_fsize); */
if|if
condition|(
operator|!
name|TARGET_EPILOGUE
condition|)
name|leaf_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output code for the function epilogue.  */
end_comment

begin_function
name|void
name|output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
name|int
name|n_fregs
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|leaf_label
condition|)
block|{
name|emit_label_after
argument_list|(
name|leaf_label
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_fregs
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|n_fregs
init|=
name|num_fregs
decl_stmt|;
if|if
condition|(
operator|!
name|leaf_function
condition|)
name|offset
operator|=
operator|-
name|apparent_fsize
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|&&
operator|!
name|leaf_function
condition|)
name|n_fregs
operator|=
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|frame_base_name
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|leaf_function
condition|)
name|n_fregs
operator|=
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|,
name|frame_base_name
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
condition|)
name|restore_regs
argument_list|(
name|file
argument_list|,
literal|32
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|frame_base_name
argument_list|,
name|offset
argument_list|,
name|n_fregs
argument_list|)
expr_stmt|;
block|}
comment|/* Work out how to skip the caller's unimp instruction if required.  */
if|if
condition|(
name|leaf_function
condition|)
name|ret
operator|=
operator|(
name|current_function_returns_struct
condition|?
literal|"jmp %o7+12"
else|:
literal|"retl"
operator|)
expr_stmt|;
else|else
name|ret
operator|=
operator|(
name|current_function_returns_struct
condition|?
literal|"jmp %i7+12"
else|:
literal|"ret"
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_EPILOGUE
operator|||
name|leaf_label
condition|)
block|{
name|int
name|old_target_epilogue
init|=
name|TARGET_EPILOGUE
decl_stmt|;
name|target_flags
operator|&=
operator|~
name|old_target_epilogue
expr_stmt|;
if|if
condition|(
operator|!
name|leaf_function
condition|)
block|{
comment|/* If we wound up with things in our delay slot, flush them here.  */
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
block|{
name|rtx
name|insn
init|=
name|emit_jump_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|RETURN
argument_list|,
name|VOIDmode
argument_list|)
argument_list|,
name|get_last_insn
argument_list|()
argument_list|)
decl_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n\trestore\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* All of the following cases are for leaf functions.  */
elseif|else
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
block|{
comment|/* eligible_for_epilogue_delay_slot ensures that if this is a 	     leaf function, then we will only have insn in the delay slot 	     if the frame size is zero, thus no adjust for the stack is 	     needed here.  */
if|if
condition|(
name|actual_fsize
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\n\tsub %%sp,-%d,%%sp\n"
argument_list|,
name|ret
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %%sp,-4096,%%sp\n\t%s\n\tsub %%sp,-%d,%%sp\n"
argument_list|,
name|ret
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi %%hi(%d),%%g1\n\t%s\n\tadd %%sp,%%g1,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsethi %%hi(%d),%%g1\n\tor %%g1,%%lo(%d),%%g1\n\t%s\n\tadd %%sp,%%g1,%%sp\n"
argument_list|,
name|actual_fsize
argument_list|,
name|actual_fsize
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|old_target_epilogue
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the string to output a conditional branch to LABEL, which is    the operand number of the label.  OP is the conditional expression.  The    mode of register 0 says what kind of comparison we made.     REVERSED is non-zero if we should reverse the sense of the comparison.     ANNUL is non-zero if we should generate an annulling branch.     NOOP is non-zero if we have to follow this branch by a noop.  */
end_comment

begin_function
name|char
modifier|*
name|output_cbranch
parameter_list|(
name|op
parameter_list|,
name|label
parameter_list|,
name|reversed
parameter_list|,
name|annul
parameter_list|,
name|noop
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|label
decl_stmt|;
name|int
name|reversed
decl_stmt|,
name|annul
decl_stmt|,
name|noop
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|20
index|]
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|static
name|char
name|labelno
index|[]
init|=
literal|" %lX"
decl_stmt|;
comment|/* ??? FP branches can not be preceded by another floating point insn.      Because there is currently no concept of pre-delay slots, we can fix      this only by always emitting a nop before a floating point branch.  */
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"nop\n\t"
argument_list|)
expr_stmt|;
comment|/* If not floating-point or if EQ or NE, we can just reverse the code.  */
if|if
condition|(
name|reversed
operator|&&
operator|(
operator|(
name|mode
operator|!=
name|CCFPmode
operator|&&
name|mode
operator|!=
name|CCFPEmode
operator|)
operator|||
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
operator|,
name|reversed
operator|=
literal|0
expr_stmt|;
comment|/* Start by writing the branch condition.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbne"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bne"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbe"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"be"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbul"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbge"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CC_NOOVmode
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bpos"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bge"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbule"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbg"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bg"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbug"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fble"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"ble"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPEmode
condition|)
block|{
if|if
condition|(
name|reversed
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbuge"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"fbl"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CC_NOOVmode
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bneg"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bl"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bgeu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bgu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"bleu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"blu"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Now add the annulling, the label, and a possible noop.  */
if|if
condition|(
name|annul
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|",a"
argument_list|)
expr_stmt|;
name|labelno
index|[
literal|3
index|]
operator|=
name|label
operator|+
literal|'0'
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
if|if
condition|(
name|noop
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to return from a function.  */
end_comment

begin_function
name|char
modifier|*
name|output_return
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|leaf_label
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|leaf_label
expr_stmt|;
return|return
literal|"b,a %l0"
return|;
block|}
elseif|else
if|if
condition|(
name|leaf_function
condition|)
block|{
comment|/* If we didn't allocate a frame pointer for the current function, 	 the stack pointer might have been adjusted.  Output code to 	 restore it now.  */
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
comment|/* Use sub of negated value in first two cases instead of add to 	 allow actual_fsize == 4096.  */
if|if
condition|(
name|actual_fsize
operator|<=
literal|4096
condition|)
block|{
if|if
condition|(
name|current_function_returns_struct
condition|)
return|return
literal|"jmp %%o7+12\n\tsub %%sp,-%0,%%sp"
return|;
else|else
return|return
literal|"retl\n\tsub %%sp,-%0,%%sp"
return|;
block|}
elseif|else
if|if
condition|(
name|actual_fsize
operator|<=
literal|8192
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|actual_fsize
operator|-
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_returns_struct
condition|)
return|return
literal|"sub %%sp,-4096,%%sp\n\tjmp %%o7+12\n\tsub %%sp,-%0,%%sp"
return|;
else|else
return|return
literal|"sub %%sp,-4096,%%sp\n\tretl\n\tsub %%sp,-%0,%%sp"
return|;
block|}
elseif|else
if|if
condition|(
name|current_function_returns_struct
condition|)
block|{
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi %%hi(%a0),%%g1\n\tor %%g1,%%lo(%a0),%%g1\n\tjmp %%o7+12\n\tadd %%sp,%%g1,%%sp"
return|;
else|else
return|return
literal|"sethi %%hi(%a0),%%g1\n\tjmp %%o7+12\n\tadd %%sp,%%g1,%%sp"
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|actual_fsize
operator|&
literal|0x3ff
operator|)
operator|!=
literal|0
condition|)
return|return
literal|"sethi %%hi(%a0),%%g1\n\tor %%g1,%%lo(%a0),%%g1\n\tretl\n\tadd %%sp,%%g1,%%sp"
return|;
else|else
return|return
literal|"sethi %%hi(%a0),%%g1\n\tretl\n\tadd %%sp,%%g1,%%sp"
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|current_function_returns_struct
condition|)
return|return
literal|"jmp %%i7+12\n\trestore"
return|;
else|else
return|return
literal|"ret\n\trestore"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Leaf functions and non-leaf functions have different needs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_leaf_alloc_order
index|[]
init|=
name|REG_LEAF_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_nonleaf_alloc_order
index|[]
init|=
name|REG_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_alloc_orders
index|[]
init|=
block|{
name|reg_leaf_alloc_order
block|,
name|reg_nonleaf_alloc_order
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|order_regs_for_local_alloc
parameter_list|()
block|{
specifier|static
name|int
name|last_order_nonleaf
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|15
index|]
operator|!=
name|last_order_nonleaf
condition|)
block|{
name|last_order_nonleaf
operator|=
operator|!
name|last_order_nonleaf
expr_stmt|;
name|bcopy
argument_list|(
name|reg_alloc_orders
index|[
name|last_order_nonleaf
index|]
argument_list|,
name|reg_alloc_order
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Machine dependent routines for the branch probability, arc profiling    code.  */
end_comment

begin_comment
comment|/* The label used by the arc profiling code.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|profiler_label
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_arc_profiler
parameter_list|()
block|{
comment|/* Generate and save a copy of this so it can be shared.  */
name|profiler_label
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"*LPBX2"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_arc_profiler
parameter_list|(
name|arcno
parameter_list|,
name|insert_after
parameter_list|)
name|int
name|arcno
decl_stmt|;
name|rtx
name|insert_after
decl_stmt|;
block|{
name|rtx
name|profiler_target_addr
init|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|profiler_label
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|4
operator|*
name|arcno
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|profiler_reg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|address_reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|mem_ref
decl_stmt|;
name|insert_after
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|address_reg
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|profiler_target_addr
argument_list|)
argument_list|)
argument_list|,
name|insert_after
argument_list|)
expr_stmt|;
name|mem_ref
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|address_reg
argument_list|,
name|profiler_target_addr
argument_list|)
argument_list|)
expr_stmt|;
name|insert_after
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|profiler_reg
argument_list|,
name|mem_ref
argument_list|)
argument_list|,
name|insert_after
argument_list|)
expr_stmt|;
name|insert_after
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|profiler_reg
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|profiler_reg
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
argument_list|,
name|insert_after
argument_list|)
expr_stmt|;
comment|/* This is the same rtx as above, but it is not legal to share this rtx.  */
name|mem_ref
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|address_reg
argument_list|,
name|profiler_target_addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|mem_ref
argument_list|,
name|profiler_reg
argument_list|)
argument_list|,
name|insert_after
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.    This makes them candidates for using ldd and std insns.      Note reg1 and reg2 *must* be hard registers.  To be sure we will    abort if we are passed pseudo registers.  */
end_comment

begin_function
name|int
name|registers_ok_for_ldd_peep
parameter_list|(
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* Should never happen.  */
if|if
condition|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|>
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO
argument_list|(
name|reg2
argument_list|)
operator|>
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|%
literal|2
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg2
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if addr1 and addr2 are suitable for use in an ldd or     std insn.     This can only happen when addr1 and addr2 are consecutive memory    locations (addr1 + 4 == addr2).  addr1 must also be aligned on a     64 bit boundary (addr1 % 8 == 0).       We know %sp and %fp are kept aligned on a 64 bit boundary.  Other    registers are assumed to *never* be properly aligned and are     rejected.     Knowing %sp and %fp are kept aligned on a 64 bit boundary, we     need only check that the offset for addr1 % 8 == 0.  */
end_comment

begin_function
name|int
name|addrs_ok_for_ldd_peep
parameter_list|(
name|addr1
parameter_list|,
name|addr2
parameter_list|)
name|rtx
name|addr1
decl_stmt|,
name|addr2
decl_stmt|;
block|{
name|int
name|reg1
decl_stmt|,
name|offset1
decl_stmt|;
comment|/* Extract a register number and offset (if used) from the first addr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* If not a REG, return zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offset must be constant!  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
else|else
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
comment|/* This was a simple (mem (reg)) expression.  Offset is 0.  */
name|offset1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure the second address is a (mem (plus (reg) (const_int).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr2
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* Only %fp and %sp are allowed.  Additionally both addresses must      use the same register.  */
if|if
condition|(
name|reg1
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|reg1
operator|!=
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg1
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The first offset must be evenly divisible by 8 to ensure the       address is 64 bit aligned.  */
if|if
condition|(
name|offset1
operator|%
literal|8
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* The offset for the second addr must be 4 more than the first addr.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|offset1
operator|+
literal|4
condition|)
return|return
literal|0
return|;
comment|/* All the tests passed.  addr1 and addr2 are valid for ldd and std      instructions.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if reg is a pseudo, or is the first register in     a hard register pair.  This makes it a candidate for use in    ldd and std insns.  */
end_comment

begin_function
name|int
name|register_ok_for_ldd
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
comment|/* We might have been passed a SUBREG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|%
literal|2
operator|==
literal|0
operator|)
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print operand X (an rtx) in assembler syntax to file FILE.    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.    For `%' followed by punctuation, CODE is the punctuation and X is null.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* Output a 'nop' if there's nothing for the delay slot.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\tnop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'*'
case|:
comment|/* Output an annul flag if there's nothing for the delay slot and we 	 are optimizing.  This is always used with '(' below.  */
comment|/* Sun OS 4.1.1 dbx can't handle an annulled unconditional branch; 	 this is a dbx bug.  So, we only do this when optimizing.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
operator|&&
name|optimize
condition|)
name|fputs
argument_list|(
literal|",a"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'('
case|:
comment|/* Output a 'nop' if there's nothing for the delay slot and we are 	 not optimizing.  This is always used with '*' above.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|optimize
condition|)
name|fputs
argument_list|(
literal|"\n\tnop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Y'
case|:
comment|/* Adjust the operand to take into account a RESTORE operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
literal|8
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
literal|24
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
literal|32
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
literal|16
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'@'
case|:
comment|/* Print out what we are using as the frame pointer.  This might 	 be %fp, or might be %sp+offset.  */
name|fputs
argument_list|(
name|frame_base_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
comment|/* Print out the second register name of a register pair or quad. 	 I.e., R (%o0) => %o1.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* Print out the third register name of a register quad. 	 I.e., S (%o0) => %o2.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* Print out the fourth register name of a register quad. 	 I.e., T (%o0) => %o3.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
comment|/* Print the operand's address only.  */
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
comment|/* In this case we need a register.  Use %g0 if the 	 operand is const0_rtx.  */
if|if
condition|(
name|x
operator|==
name|const0_rtx
operator|||
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"%g0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
case|case
literal|'A'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"or"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"and"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
case|case
literal|'B'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|fputs
argument_list|(
literal|"orn"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fputs
argument_list|(
literal|"andn"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fputs
argument_list|(
literal|"xnor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
case|case
literal|'b'
case|:
block|{
comment|/* Print a sign-extended character.  */
name|int
name|i
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|i
operator|&
literal|0x80
condition|)
name|i
operator||=
literal|0xffffff00
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|0
case|:
comment|/* Do nothing special.  */
break|break;
default|default:
comment|/* Undocumented flag.  */
name|output_operand_lossage
argument_list|(
literal|"invalid operand output code"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|fputc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* Poor Sun assembler doesn't understand absolute addressing.  */
name|fputs
argument_list|(
literal|"%g0+"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|HIGH
condition|)
block|{
name|fputs
argument_list|(
literal|"%hi("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LO_SUM
condition|)
block|{
name|print_operand
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"+%lo("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%u"
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function outputs assembler code for VALUE to FILE, where VALUE is    a 64 bit (DImode) value.  */
end_comment

begin_comment
comment|/* ??? If there is a 64 bit counterpart to .word that the assembler    understands, then using that would simply this code greatly.  */
end_comment

begin_function
name|void
name|output_double_int
parameter_list|(
name|file
parameter_list|,
name|value
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|value
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|)
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Addresses are only 32 bits.  */
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|file
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|long
name|sparc_type_code
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|qualifiers
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|shift
init|=
literal|6
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|qualifiers
return|;
case|case
name|ARRAY_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|3
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|2
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|2
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|2
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|qualifiers
operator||=
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|2
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|8
operator|)
return|;
case|case
name|UNION_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|9
operator|)
return|;
case|case
name|ENUMERAL_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|10
operator|)
return|;
case|case
name|VOID_TYPE
case|:
return|return
operator|(
name|qualifiers
operator||
literal|16
operator|)
return|;
case|case
name|INTEGER_TYPE
case|:
comment|/* Carefully distinguish all the standard types of C, 	     without messing up if the language is not C. 	     Note that we check only for the names that contain spaces; 	     other names might occur by coincidence in other languages.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned char"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|12
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"signed char"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|2
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"unsigned int"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|14
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short int"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|3
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"short unsigned int"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|13
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long int"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|5
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long unsigned int"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|15
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long int"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|5
operator|)
return|;
comment|/* Who knows? */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long long unsigned int"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|15
operator|)
return|;
comment|/* Who knows? */
block|}
comment|/* Most integer types will be sorted out above, however, for the 	     sake of special `array index' integer types, the following code 	     is also provided.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|INT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|14
else|:
literal|4
operator|)
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|15
else|:
literal|5
operator|)
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_LONG_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|15
else|:
literal|5
operator|)
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|SHORT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|13
else|:
literal|3
operator|)
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|CHAR_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|12
else|:
literal|2
operator|)
operator|)
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|REAL_TYPE
case|:
comment|/* Carefully distinguish all the standard types of C, 	     without messing up if the language is not C.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"long double"
argument_list|)
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
comment|/* Who knows? */
block|}
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|DOUBLE_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|FLOAT_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|6
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|LONG_DOUBLE_TYPE_SIZE
condition|)
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
comment|/* Who knows? */
name|abort
argument_list|()
expr_stmt|;
case|case
name|COMPLEX_TYPE
case|:
comment|/* GNU Fortran COMPLEX type.  */
comment|/* ??? We need to dinguish between double and float complex types, 	     but I don't know how yet because I can't reach this code from 	     existing front-ends.  */
return|return
operator|(
name|qualifiers
operator||
literal|7
operator|)
return|;
comment|/* Who knows? */
case|case
name|CHAR_TYPE
case|:
comment|/* GNU Pascal CHAR type.  Not used in C.  */
case|case
name|BOOLEAN_TYPE
case|:
comment|/* GNU Fortran BOOLEAN type.  */
case|case
name|FILE_TYPE
case|:
comment|/* GNU Pascal FILE type.  */
case|case
name|STRING_TYPE
case|:
comment|/* GNU Fortran STRING type. */
case|case
name|LANG_TYPE
case|:
comment|/* ? */
name|abort
argument_list|()
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* Not a type! */
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines to support a flat (single) register window calling    convention.  */
end_comment

begin_comment
comment|/* Single-register window sparc stack frames look like:               Before call		        After call         +-----------------------+	+-----------------------+    high |			|       |      			|    mem. |		        |	|			|         |  caller's temps.    	|       |  caller's temps.    	| 	|       		|       |       	        |         +-----------------------+	+-----------------------+  	|       		|	|		        |         |  arguments on stack.  |	|  arguments on stack.  | 	|       		|FP+92->|			|         +-----------------------+	+-----------------------+  	|  6 words to save     	|	|  6 words to save	| 	|  arguments passed	|	|  arguments passed	| 	|  in registers, even	|	|  in registers, even	|  SP+68->|  if not passed.       |FP+68->|  if not passed.	| 	+-----------------------+       +-----------------------+ 	| 1 word struct addr	|FP+64->| 1 word struct addr	| 	+-----------------------+       +-----------------------+ 	|			|	|			| 	| 16 word reg save area	|	| 16 word reg save area |     SP->|			|   FP->|			| 	+-----------------------+	+-----------------------+ 					| 4 word area for	| 				 FP-16->| fp/alu reg moves	| 					+-----------------------+ 					|			| 					|  local variables	| 					|			| 					+-----------------------+ 					|		        |                                         |  fp register save     | 					|			| 					+-----------------------+ 					|		        |                                         |  gp register save     |                                         |       		| 					+-----------------------+ 					|			|                                         |  alloca allocations   |         				|			| 					+-----------------------+ 					|			|                                         |  arguments on stack   |         			 SP+92->|		        | 					+-----------------------+                                         |  6 words to save      | 					|  arguments passed     |                                         |  in registers, even   |    low                           SP+68->|  if not passed.       |    memory        			+-----------------------+ 				 SP+64->| 1 word struct addr	| 					+-----------------------+ 					|			| 					I 16 word reg save area | 				    SP->|			| 					+-----------------------+  */
end_comment

begin_comment
comment|/* Structure to be filled in by sparc_frw_compute_frame_size with register    save masks, and offsets for the current function.  */
end_comment

begin_struct
struct|struct
name|sparc_frame_info
block|{
name|unsigned
name|long
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up.  */
name|unsigned
name|long
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up.  */
name|unsigned
name|long
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up.  */
name|unsigned
name|long
name|extra_size
decl_stmt|;
comment|/* # bytes of extra gunk.  */
name|unsigned
name|int
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs.  */
name|unsigned
name|int
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs.  */
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* Mask of saved gp registers.  */
name|unsigned
name|long
name|fmask
decl_stmt|;
comment|/* Mask of saved fp registers.  */
name|unsigned
name|long
name|gp_sp_offset
decl_stmt|;
comment|/* Offset from new sp to store gp regs.  */
name|unsigned
name|long
name|fp_sp_offset
decl_stmt|;
comment|/* Offset from new sp to store fp regs.  */
name|int
name|initialized
decl_stmt|;
comment|/* Nonzero if frame size already calculated.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Current frame information calculated by sparc_frw_compute_frame_size.  */
end_comment

begin_decl_stmt
name|struct
name|sparc_frame_info
name|current_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero structure to initialize current_frame_info.  */
end_comment

begin_decl_stmt
name|struct
name|sparc_frame_info
name|zero_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tell prologue and epilogue if register REGNO should be saved / restored.  */
end_comment

begin_define
define|#
directive|define
name|MUST_SAVE_REGISTER
parameter_list|(
name|regno
parameter_list|)
define|\
value|((regs_ever_live[regno]&& !call_used_regs[regno])		\   || (regno == FRAME_POINTER_REGNUM&& frame_pointer_needed)	\   || (regno == 15&& regs_ever_live[15]))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SPARC_STACK_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|STACK_BYTES
value|(STACK_BOUNDARY / 8)
end_define

begin_define
define|#
directive|define
name|SPARC_STACK_ALIGN
parameter_list|(
name|X
parameter_list|)
value|(((X) + STACK_BYTES -  1)& -STACK_BYTES)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the bytes needed to compute the frame pointer from the current    stack pointer.  */
end_comment

begin_function
name|unsigned
name|long
name|sparc_frw_compute_frame_size
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
comment|/* # of var. bytes allocated.  */
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|total_size
decl_stmt|;
comment|/* # bytes that the entire frame takes up.  */
name|unsigned
name|long
name|var_size
decl_stmt|;
comment|/* # bytes that variables take up.  */
name|unsigned
name|long
name|args_size
decl_stmt|;
comment|/* # bytes that outgoing arguments take up.  */
name|unsigned
name|long
name|extra_size
decl_stmt|;
comment|/* # extra bytes.  */
name|unsigned
name|int
name|gp_reg_size
decl_stmt|;
comment|/* # bytes needed to store gp regs.  */
name|unsigned
name|int
name|fp_reg_size
decl_stmt|;
comment|/* # bytes needed to store fp regs.  */
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* Mask of saved gp registers.  */
name|unsigned
name|long
name|fmask
decl_stmt|;
comment|/* Mask of saved fp registers.  */
comment|/* This is the size of the 16 word reg save area, 1 word struct addr      area, and 4 word fp/alu register copy area.  */
name|extra_size
operator|=
operator|-
name|STARTING_FRAME_OFFSET
operator|+
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|var_size
operator|=
name|size
expr_stmt|;
comment|/* Also include the size needed for the 6 parameter registers.  */
name|args_size
operator|=
name|current_function_outgoing_args_size
operator|+
literal|24
expr_stmt|;
name|total_size
operator|=
name|var_size
operator|+
name|args_size
operator|+
name|extra_size
expr_stmt|;
name|gp_reg_size
operator|=
literal|0
expr_stmt|;
name|fp_reg_size
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|fmask
operator|=
literal|0
expr_stmt|;
comment|/* Calculate space needed for gp registers.  */
for|for
control|(
name|regno
operator|=
literal|1
init|;
name|regno
operator|<=
literal|31
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|regno
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
name|MUST_SAVE_REGISTER
argument_list|(
name|regno
operator|+
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|gp_reg_size
operator|%
literal|8
operator|!=
literal|0
condition|)
name|gp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|gp_reg_size
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|mask
operator||=
literal|3
operator|<<
name|regno
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
else|else
block|{
name|gp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
block|}
block|}
comment|/* Add extra word in case we have to align the space to a double word      boundary.  */
if|if
condition|(
name|gp_reg_size
operator|!=
literal|0
condition|)
name|gp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Calculate space needed for fp registers.  */
for|for
control|(
name|regno
operator|=
literal|32
init|;
name|regno
operator|<=
literal|63
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|fp_reg_size
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|fmask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|-
literal|32
operator|)
expr_stmt|;
block|}
block|}
name|total_size
operator|+=
name|gp_reg_size
operator|+
name|fp_reg_size
expr_stmt|;
if|if
condition|(
name|total_size
operator|==
name|extra_size
condition|)
name|total_size
operator|=
name|extra_size
operator|=
literal|0
expr_stmt|;
name|total_size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
comment|/* Save other computed information.  */
name|current_frame_info
operator|.
name|total_size
operator|=
name|total_size
expr_stmt|;
name|current_frame_info
operator|.
name|var_size
operator|=
name|var_size
expr_stmt|;
name|current_frame_info
operator|.
name|args_size
operator|=
name|args_size
expr_stmt|;
name|current_frame_info
operator|.
name|extra_size
operator|=
name|extra_size
expr_stmt|;
name|current_frame_info
operator|.
name|gp_reg_size
operator|=
name|gp_reg_size
expr_stmt|;
name|current_frame_info
operator|.
name|fp_reg_size
operator|=
name|fp_reg_size
expr_stmt|;
name|current_frame_info
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|current_frame_info
operator|.
name|fmask
operator|=
name|fmask
expr_stmt|;
name|current_frame_info
operator|.
name|initialized
operator|=
name|reload_completed
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|unsigned
name|long
name|offset
init|=
name|args_size
decl_stmt|;
if|if
condition|(
name|extra_size
condition|)
name|offset
operator|+=
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gp_sp_offset
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|fmask
condition|)
block|{
name|unsigned
name|long
name|offset
init|=
name|args_size
operator|+
name|gp_reg_size
decl_stmt|;
if|if
condition|(
name|extra_size
condition|)
name|offset
operator|+=
name|FIRST_PARM_OFFSET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|fp_sp_offset
operator|=
name|offset
expr_stmt|;
block|}
comment|/* Ok, we're done.  */
return|return
name|total_size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Common code to save/restore registers.  */
end_comment

begin_function
name|void
name|sparc_frw_save_restore
parameter_list|(
name|file
parameter_list|,
name|word_op
parameter_list|,
name|doubleword_op
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* Stream to write to.  */
name|char
modifier|*
name|word_op
decl_stmt|;
comment|/* Operation to do for one word.  */
name|char
modifier|*
name|doubleword_op
decl_stmt|;
comment|/* Operation to do for doubleword.  */
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
name|current_frame_info
operator|.
name|mask
decl_stmt|;
name|unsigned
name|long
name|fmask
init|=
name|current_frame_info
operator|.
name|fmask
decl_stmt|;
name|unsigned
name|long
name|gp_offset
decl_stmt|;
name|unsigned
name|long
name|fp_offset
decl_stmt|;
name|unsigned
name|long
name|max_offset
decl_stmt|;
name|char
modifier|*
name|base_reg
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
operator|&&
name|fmask
operator|==
literal|0
condition|)
return|return;
name|base_reg
operator|=
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
expr_stmt|;
name|gp_offset
operator|=
name|current_frame_info
operator|.
name|gp_sp_offset
expr_stmt|;
name|fp_offset
operator|=
name|current_frame_info
operator|.
name|fp_sp_offset
expr_stmt|;
name|max_offset
operator|=
operator|(
name|gp_offset
operator|>
name|fp_offset
operator|)
condition|?
name|gp_offset
else|:
name|fp_offset
expr_stmt|;
comment|/* Deal with calling functions with a large structure.  */
if|if
condition|(
name|max_offset
operator|>=
literal|4096
condition|)
block|{
name|char
modifier|*
name|temp
init|=
literal|"%g2"
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %ld,%s\n"
argument_list|,
name|max_offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%s\n"
argument_list|,
name|temp
argument_list|,
name|base_reg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|base_reg
operator|=
name|temp
expr_stmt|;
name|gp_offset
operator|=
name|max_offset
operator|-
name|gp_offset
expr_stmt|;
name|fp_offset
operator|=
name|max_offset
operator|-
name|fp_offset
expr_stmt|;
block|}
comment|/* Save registers starting from high to low.  The debuggers prefer      at least the return register be stored at func+4, and also it      allows us not to need a nop in the epilog if at least one      register is reloaded in addition to return address.  */
if|if
condition|(
name|mask
operator|||
name|frame_pointer_needed
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|1
init|;
name|regno
operator|<=
literal|31
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1L
operator|<<
name|regno
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|frame_pointer_needed
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|regno
operator|&
literal|0x1
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|mask
operator|&
operator|(
literal|1L
operator|<<
name|regno
operator|+
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|gp_offset
operator|%
literal|8
operator|!=
literal|0
condition|)
name|gp_offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s %s,[%s+%d]\n"
argument_list|,
name|doubleword_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|gp_offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s [%s+%d],%s\n"
argument_list|,
name|doubleword_op
argument_list|,
name|base_reg
argument_list|,
name|gp_offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|gp_offset
operator|+=
literal|2
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s %s,[%s+%d]\n"
argument_list|,
name|word_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|gp_offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s [%s+%d],%s\n"
argument_list|,
name|word_op
argument_list|,
name|base_reg
argument_list|,
name|gp_offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|gp_offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fmask
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|32
init|;
name|regno
operator|<=
literal|63
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fmask
operator|&
operator|(
literal|1L
operator|<<
operator|(
name|regno
operator|-
literal|32
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|word_op
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s %s,[%s+%d]\n"
argument_list|,
name|word_op
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|base_reg
argument_list|,
name|gp_offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s [%s+%d],%s\n"
argument_list|,
name|word_op
argument_list|,
name|base_reg
argument_list|,
name|gp_offset
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|fp_offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the stack and frame (if desired) for the function.  */
end_comment

begin_function
name|void
name|sparc_frw_output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|ignored
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|tsize
decl_stmt|;
name|char
modifier|*
name|sp_str
init|=
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
name|frame_base_name
operator|=
operator|(
operator|!
name|frame_pointer_needed
operator|)
condition|?
literal|"%sp+80"
else|:
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t!#PROLOGUE# 0\n"
argument_list|)
expr_stmt|;
name|size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|tsize
operator|=
operator|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|?
name|sparc_frw_compute_frame_size
argument_list|(
name|size
argument_list|)
else|:
name|current_frame_info
operator|.
name|total_size
operator|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tsize
operator|<=
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%d,%s\t\t!# vars= %d, regs= %d/%d, args = %d, extra= %d\n"
argument_list|,
name|sp_str
argument_list|,
name|tsize
argument_list|,
name|sp_str
argument_list|,
name|current_frame_info
operator|.
name|var_size
argument_list|,
name|current_frame_info
operator|.
name|gp_reg_size
operator|/
literal|4
argument_list|,
name|current_frame_info
operator|.
name|fp_reg_size
operator|/
literal|8
argument_list|,
name|current_function_outgoing_args_size
argument_list|,
name|current_frame_info
operator|.
name|extra_size
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %d,%s\n\tsub\t%s,%s,%s\t\t!# vars= %d, regs= %d/%d, args = %d, sfo= %d\n"
argument_list|,
name|tsize
argument_list|,
literal|"%g1"
argument_list|,
name|sp_str
argument_list|,
literal|"%g1"
argument_list|,
name|sp_str
argument_list|,
name|current_frame_info
operator|.
name|var_size
argument_list|,
name|current_frame_info
operator|.
name|gp_reg_size
operator|/
literal|4
argument_list|,
name|current_frame_info
operator|.
name|fp_reg_size
operator|/
literal|8
argument_list|,
name|current_function_outgoing_args_size
argument_list|,
name|current_frame_info
operator|.
name|extra_size
argument_list|)
expr_stmt|;
block|}
name|sparc_frw_save_restore
argument_list|(
name|file
argument_list|,
literal|"st"
argument_list|,
literal|"std"
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|tsize
operator|<=
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%d,%s\t!# set up frame pointer\n"
argument_list|,
name|sp_str
argument_list|,
name|tsize
argument_list|,
name|frame_base_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%s\t!# set up frame pointer\n"
argument_list|,
name|sp_str
argument_list|,
literal|"%g1"
argument_list|,
name|frame_base_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any necessary cleanup after a function to restore stack, frame,    and regs. */
end_comment

begin_function
name|void
name|sparc_frw_output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|ignored1
parameter_list|,
name|ignored2
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|FILE
modifier|*
name|asm_out_data_file
decl_stmt|,
modifier|*
name|asm_out_file
decl_stmt|;
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
name|int
name|tsize
decl_stmt|;
name|char
modifier|*
name|sp_str
init|=
name|reg_names
index|[
name|STACK_POINTER_REGNUM
index|]
decl_stmt|;
name|char
modifier|*
name|t1_str
init|=
literal|"%g1"
decl_stmt|;
name|rtx
name|epilogue_delay
init|=
name|current_function_epilogue_delay_list
decl_stmt|;
name|int
name|noepilogue
init|=
name|FALSE
decl_stmt|;
name|int
name|load_nop
init|=
name|FALSE
decl_stmt|;
name|int
name|load_only_r15
decl_stmt|;
comment|/* The epilogue does not depend on any registers, but the stack      registers, so we assume that if we have 1 pending nop, it can be      ignored, and 2 it must be filled (2 nops occur for integer      multiply and divide).  */
name|size
operator|=
name|SPARC_STACK_ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|tsize
operator|=
operator|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|?
name|sparc_frw_compute_frame_size
argument_list|(
name|size
argument_list|)
else|:
name|current_frame_info
operator|.
name|total_size
operator|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|==
literal|0
operator|&&
name|epilogue_delay
operator|==
literal|0
condition|)
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write any code 	 because a jump (aka return) was put there.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|noepilogue
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noepilogue
condition|)
block|{
comment|/* In the reload sequence, we don't need to fill the load delay 	 slots for most of the loads, also see if we can fill the final 	 delay slot if not otherwise filled by the reload sequence.  */
if|if
condition|(
name|tsize
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tset %d,%s\n"
argument_list|,
name|tsize
argument_list|,
name|t1_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|char
modifier|*
name|fp_str
init|=
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
decl_stmt|;
if|if
condition|(
name|tsize
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%s,%s\t\t!# sp not trusted  here\n"
argument_list|,
name|fp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%d,%s\t\t!# sp not trusted  here\n"
argument_list|,
name|fp_str
argument_list|,
name|tsize
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
block|}
name|sparc_frw_save_restore
argument_list|(
name|file
argument_list|,
literal|"ld"
argument_list|,
literal|"ldd"
argument_list|)
expr_stmt|;
name|load_only_r15
operator|=
operator|(
name|current_frame_info
operator|.
name|mask
operator|==
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|&&
name|current_frame_info
operator|.
name|fmask
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|current_function_returns_struct
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp %%o7+12\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tretl\n"
argument_list|)
expr_stmt|;
comment|/* If the only register saved is the return address, we need a 	 nop, unless we have an instruction to put into it.  Otherwise 	 we don't since reloading multiple registers doesn't reference 	 the register being loaded.  */
if|if
condition|(
name|epilogue_delay
condition|)
block|{
if|if
condition|(
name|tsize
condition|)
name|abort
argument_list|()
expr_stmt|;
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|epilogue_delay
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsize
operator|>
literal|4095
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%s\n"
argument_list|,
name|sp_str
argument_list|,
name|t1_str
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tsize
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%d,%s\n"
argument_list|,
name|sp_str
argument_list|,
name|tsize
argument_list|,
name|sp_str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Reset state info for each function.  */
name|current_frame_info
operator|=
name|zero_frame_info
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the number of delay slots needed for the function epilogue.     On the sparc, we need a slot if either no stack has been allocated,    or the only register saved is the return register.  */
end_comment

begin_function
name|int
name|sparc_frw_epilogue_delay_slots
parameter_list|()
block|{
if|if
condition|(
operator|!
name|current_frame_info
operator|.
name|initialized
condition|)
operator|(
name|void
operator|)
name|sparc_frw_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|mask
operator|==
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|&&
name|current_frame_info
operator|.
name|fmask
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true is TRIAL is a valid insn for the epilogue delay slot.    Any single length instruction which doesn't reference the stack or frame    pointer is OK.  */
end_comment

begin_function
name|int
name|sparc_frw_eligible_for_epilogue_delay
parameter_list|(
name|trial
parameter_list|,
name|slot
parameter_list|)
name|rtx
name|trial
decl_stmt|;
name|int
name|slot
decl_stmt|;
block|{
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|==
literal|1
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

