begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output routines for GCC for ARM/RISCiX.    Copyright (C) 1991 Free Software Foundation, Inc.    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)    	      and Martin Simmons (@harleqn.co.uk).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_comment
comment|/* The maximum number of insns skipped which will be conditionalised if    possible.  */
end_comment

begin_define
define|#
directive|define
name|MAX_INSNS_SKIPPED
value|5
end_define

begin_comment
comment|/* Some function declarations.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|output_multi_immediate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|arm_output_asm_insn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|arm_increase_location
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we    must report the mode of the memory reference from PRINT_OPERAND to    PRINT_OPERAND_ADDRESS.  */
end_comment

begin_decl_stmt
name|int
name|output_memory_reference_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the prologue must setup `fp'.  */
end_comment

begin_decl_stmt
name|int
name|current_function_anonymous_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location counter of .text segment.  */
end_comment

begin_decl_stmt
name|int
name|arm_text_location
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A hash table is used to store text segment labels and their associated    offset from the start of the text segment.  */
end_comment

begin_struct
struct|struct
name|label_offset
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|label_offset
modifier|*
name|cdr
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LABEL_HASH_SIZE
value|257
end_define

begin_decl_stmt
specifier|static
name|struct
name|label_offset
modifier|*
name|offset_table
index|[
name|LABEL_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an explanation of these variables, see final_prescan_insn below.  */
end_comment

begin_decl_stmt
name|int
name|arm_ccfsm_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_current_cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|arm_target_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_target_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arm_condition_codes
index|[]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return the number of mov instructions needed to get the constant VALUE into    a register.  */
end_comment

begin_function
name|int
name|arm_const_nmoves
parameter_list|(
name|value
parameter_list|)
specifier|register
name|int
name|value
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
condition|;
name|i
operator|++
operator|,
name|value
operator|&=
operator|~
literal|0xff
control|)
while|while
condition|(
operator|(
name|value
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
name|value
operator|=
operator|(
name|value
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|3
operator|)
operator|<<
literal|30
operator|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* arm_const_nmoves */
end_comment

begin_comment
comment|/* Return TRUE if int I is a valid immediate ARM constant.  */
end_comment

begin_function
name|int
name|const_ok_for_arm
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|unsigned
name|int
name|mask
init|=
operator|~
literal|0xFF
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|i
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|2
operator|)
operator||
operator|(
name|mask
operator|>>
operator|(
literal|32
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|mask
operator|!=
operator|~
literal|0xFF
condition|)
do|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* const_ok_for_arm */
end_comment

begin_comment
comment|/* Return TRUE if rtx X is a valid immediate FPU constant. */
end_comment

begin_function
name|int
name|const_double_rtx_ok_for_fpu
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|double
name|d
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|d
operator|=
name|u
operator|.
name|d
expr_stmt|;
return|return
operator|(
name|d
operator|==
literal|0.0
operator|||
name|d
operator|==
literal|1.0
operator|||
name|d
operator|==
literal|2.0
operator|||
name|d
operator|==
literal|3.0
operator|||
name|d
operator|==
literal|4.0
operator|||
name|d
operator|==
literal|5.0
operator|||
name|d
operator|==
literal|0.5
operator|||
name|d
operator|==
literal|10.0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* const_double_rtx_ok_for_fpu */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Predicates for `match_operand' and `match_operator'.  */
end_comment

begin_comment
comment|/* Return TRUE for valid operands for the rhs of an ARM instruction.  */
end_comment

begin_function
name|int
name|arm_rhs_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* arm_rhs_operand */
end_comment

begin_comment
comment|/* Return TRUE for valid operands for the rhs of an FPU instruction.  */
end_comment

begin_function
name|int
name|fpu_rhs_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|(
name|const_double_rtx_ok_for_fpu
argument_list|(
name|op
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fpu_rhs_operand */
end_comment

begin_comment
comment|/* Return nonzero if OP is a constant power of two.  */
end_comment

begin_function
name|int
name|power_of_two_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|value
init|=
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
name|value
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
operator|(
name|value
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* power_of_two_operand */
end_comment

begin_comment
comment|/* Return TRUE for a valid operand of a DImode operation.    Either: REG, CONST_DOUBLE or MEM(offsettable).    Note that this disallows MEM(REG+REG).  */
end_comment

begin_function
name|int
name|di_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|MEM
case|:
return|return
operator|(
name|memory_address_p
argument_list|(
name|DImode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|offsettable_address_p
argument_list|(
name|FALSE
argument_list|,
name|DImode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* di_operand */
end_comment

begin_comment
comment|/* Return TRUE for valid index operands. */
end_comment

begin_function
name|int
name|index_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|abs
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
literal|4096
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* index_operand */
end_comment

begin_comment
comment|/* Return TRUE for arithmetic operators which can be combined with a multiply    (shift).  */
end_comment

begin_function
name|int
name|shiftable_operator
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
else|else
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|||
name|code
operator|==
name|AND
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* shiftable_operator */
end_comment

begin_comment
comment|/* Return TRUE for shift operators. */
end_comment

begin_function
name|int
name|shift_operator
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
else|else
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|LSHIFT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* shift_operator */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Routines to output assembly language.  */
end_comment

begin_comment
comment|/* Output the operands of a LDM/STM instruction to STREAM.    MASK is the ARM register set mask of which only bits 0-15 are important.    INSTR is the possibly suffixed base register.  HAT unequals zero if a hat    must follow the register list.  */
end_comment

begin_function
name|void
name|print_multi_reg
parameter_list|(
name|stream
parameter_list|,
name|instr
parameter_list|,
name|mask
parameter_list|,
name|hat
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|instr
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|hat
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|not_first
init|=
name|FALSE
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, {"
argument_list|,
name|instr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|not_first
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|not_first
operator|=
name|TRUE
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}%s\n"
argument_list|,
name|hat
condition|?
literal|"^"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print_multi_reg */
end_comment

begin_comment
comment|/* Output a 'call' insn. */
end_comment

begin_function
name|char
modifier|*
name|output_call
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle calls to lr using ip (which may be clobbered in subr anyway). */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
literal|14
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, lr"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|arm_output_asm_insn
argument_list|(
literal|"mov\tlr, pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"mov\tpc, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_call */
end_comment

begin_comment
comment|/* Output a move from arm registers to an fpu registers.    OPERANDS[0] is an fpu register.    OPERANDS[1] is the first registers of an arm register pair.  */
end_comment

begin_function
name|char
modifier|*
name|output_mov_double_fpu_from_arm
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
literal|12
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"stmfd\tsp!, {%0, %1}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"ldfd\t%0, [sp], #8"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_mov_double_fpu_from_arm */
end_comment

begin_comment
comment|/* Output a move from an fpu register to arm registers.    OPERANDS[0] is the first registers of an arm register pair.    OPERANDS[1] is an fpu register.  */
end_comment

begin_function
name|char
modifier|*
name|output_mov_double_arm_from_fpu
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
literal|12
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"stfd\t%1, [sp, #-8]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"ldmfd\tsp!, {%0, %1}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_mov_double_arm_from_fpu */
end_comment

begin_comment
comment|/* Output a move between double words.    It must be REG<-REG, REG<-CONST_DOUBLE, REG<-CONST_INT, REG<-MEM    or MEM<-REG and all MEMs must be offsettable addresses.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|otherops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|int
name|reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|otherops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|1
operator|+
name|reg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|reg1
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg1
operator|==
literal|12
condition|)
name|abort
argument_list|()
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|1
operator|+
name|reg1
argument_list|)
expr_stmt|;
comment|/* Ensure the second source is not overwritten */
if|if
condition|(
name|reg0
operator|==
literal|1
operator|+
name|reg1
condition|)
block|{
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
condition|)
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Handle the simple case where address is [r, #0] more 		 efficient.  */
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"ldmia\t%1, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Take care of overlapping base/data reg.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|arm_output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arm_output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Constraints should prevent this */
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MEM
operator|&&
name|code1
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
literal|12
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"stmia\t%0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|otherops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|1
operator|+
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"str\t%1, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
literal|"str\t%1, %0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Constraints should prevent this */
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_move_double */
end_comment

begin_comment
comment|/* Output an arbitrary MOV reg, #n.    OPERANDS[0] is a register.  OPERANDS[1] is a const_int.  */
end_comment

begin_function
name|char
modifier|*
name|output_mov_immediate
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
block|{
name|int
name|n
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|int
name|n_ones
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Try to use one MOV */
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|n
argument_list|)
condition|)
return|return
operator|(
name|arm_output_asm_insn
argument_list|(
literal|"mov\t%0, %1"
argument_list|,
name|operands
argument_list|)
operator|)
return|;
comment|/* Try to use one MVN */
if|if
condition|(
name|const_ok_for_arm
argument_list|(
operator|~
name|n
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|~
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|arm_output_asm_insn
argument_list|(
literal|"mvn\t%0, %1"
argument_list|,
name|operands
argument_list|)
operator|)
return|;
block|}
comment|/* If all else fails, make it out of ORRs or BICs as appropriate. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n
operator|&
literal|1
operator|<<
name|i
condition|)
name|n_ones
operator|++
expr_stmt|;
if|if
condition|(
name|n_ones
operator|>
literal|16
condition|)
comment|/* Shorter to use MVN with BIC in this case. */
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"mvn\t%0, %1"
argument_list|,
literal|"bic\t%0, %0, %1"
argument_list|,
literal|1
argument_list|,
operator|~
name|n
argument_list|)
expr_stmt|;
else|else
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"mov\t%0, %1"
argument_list|,
literal|"orr\t%0, %0, %1"
argument_list|,
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_mov_immediate */
end_comment

begin_comment
comment|/* Output an ADD r, s, #n where n may be too big for one instruction.  If    adding zero to one register, output nothing.  */
end_comment

begin_function
name|char
modifier|*
name|output_add_immediate
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
block|{
name|int
name|n
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"sub\t%0, %1, %2"
argument_list|,
literal|"sub\t%0, %0, %2"
argument_list|,
literal|2
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
else|else
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"add\t%0, %1, %2"
argument_list|,
literal|"add\t%0, %0, %2"
argument_list|,
literal|2
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_add_immediate */
end_comment

begin_comment
comment|/* Output a multiple immediate operation.    OPERANDS is the vector of operands referred to in the output patterns.    INSTR1 is the output pattern to use for the first constant.    INSTR2 is the output pattern to use for subsequent constants.    IMMED_OP is the index of the constant slot in OPERANDS.    N is the constant value.  */
end_comment

begin_function
name|char
modifier|*
name|output_multi_immediate
parameter_list|(
name|operands
parameter_list|,
name|instr1
parameter_list|,
name|instr2
parameter_list|,
name|immed_op
parameter_list|,
name|n
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|char
modifier|*
name|instr1
decl_stmt|,
decl|*
name|instr2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|immed_op
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|operands
index|[
name|immed_op
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
name|instr1
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Quick and easy output */
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|instr
init|=
name|instr1
decl_stmt|;
comment|/* Note that n is never zero here (which would give no output) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
condition|)
block|{
name|operands
index|[
name|immed_op
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|n
operator|&
operator|(
literal|255
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
name|arm_output_asm_insn
argument_list|(
name|instr
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|instr
operator|=
name|instr2
expr_stmt|;
name|i
operator|+=
literal|6
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_block

begin_comment
comment|/* output_multi_immediate */
end_comment

begin_comment
comment|/* Return the appropriate ARM instruction for the operation code.    The returned result should not be overwritten.  OP is the rtx of the    operation.  SHIFT_FIRST_ARG is TRUE if the first argument of the operator    was shifted.  */
end_comment

begin_function
name|char
modifier|*
name|arithmetic_instr
parameter_list|(
name|op
parameter_list|,
name|shift_first_arg
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
return|return
operator|(
literal|"add"
operator|)
return|;
case|case
name|MINUS
case|:
if|if
condition|(
name|shift_first_arg
condition|)
return|return
operator|(
literal|"rsb"
operator|)
return|;
else|else
return|return
operator|(
literal|"sub"
operator|)
return|;
case|case
name|IOR
case|:
return|return
operator|(
literal|"orr"
operator|)
return|;
case|case
name|XOR
case|:
return|return
operator|(
literal|"eor"
operator|)
return|;
case|case
name|AND
case|:
return|return
operator|(
literal|"and"
operator|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|""
operator|)
return|;
comment|/* stupid cc */
block|}
end_function

begin_comment
comment|/* arithmetic_instr */
end_comment

begin_comment
comment|/* Ensure valid constant shifts and return the appropriate shift mnemonic    for the operation code.  The returned result should not be overwritten.    OP is the rtx code of the shift.    SHIFT_PTR points to the shift size operand.  */
end_comment

begin_function
name|char
modifier|*
name|shift_instr
parameter_list|(
name|op
parameter_list|,
name|shift_ptr
parameter_list|)
name|enum
name|rtx_code
name|op
decl_stmt|;
name|rtx
modifier|*
name|shift_ptr
decl_stmt|;
block|{
name|int
name|min_shift
init|=
literal|0
decl_stmt|;
name|int
name|max_shift
init|=
literal|31
decl_stmt|;
name|char
modifier|*
name|mnem
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|ASHIFT
case|:
name|mnem
operator|=
literal|"asl"
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
name|mnem
operator|=
literal|"lsl"
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|mnem
operator|=
literal|"asr"
expr_stmt|;
name|max_shift
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|mnem
operator|=
literal|"lsr"
expr_stmt|;
name|max_shift
operator|=
literal|32
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|shift_ptr
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|shift
init|=
name|INTVAL
argument_list|(
operator|*
name|shift_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|shift
operator|<
name|min_shift
condition|)
operator|*
name|shift_ptr
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|>
name|max_shift
condition|)
operator|*
name|shift_ptr
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|max_shift
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mnem
operator|)
return|;
block|}
end_function

begin_comment
comment|/* shift_instr */
end_comment

begin_comment
comment|/* Obtain the shift from the POWER of two. */
end_comment

begin_function
name|int
name|int_log2
parameter_list|(
name|power
parameter_list|)
name|unsigned
name|int
name|power
decl_stmt|;
block|{
name|int
name|shift
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|(
literal|1
operator|<<
name|shift
operator|)
operator|&
name|power
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|shift
operator|>
literal|31
condition|)
name|abort
argument_list|()
expr_stmt|;
name|shift
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|shift
operator|)
return|;
block|}
end_function

begin_comment
comment|/* int_log2 */
end_comment

begin_comment
comment|/* Output an arithmetic instruction which may set the condition code.    OPERANDS[0] is the destination register.    OPERANDS[1] is the arithmetic operator expression.    OPERANDS[2] is the left hand argument.    OPERANDS[3] is the right hand argument.    CONST_FIRST_ARG is TRUE if the first argument of the operator was constant.    SET_COND is TRUE when the condition code should be set.  */
end_comment

begin_function
name|char
modifier|*
name|output_arithmetic
parameter_list|(
name|operands
parameter_list|,
name|const_first_arg
parameter_list|,
name|set_cond
parameter_list|)
name|rtx
name|operands
index|[
literal|4
index|]
decl_stmt|;
name|int
name|const_first_arg
decl_stmt|;
name|int
name|set_cond
decl_stmt|;
block|{
name|char
name|mnemonic
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|instr
init|=
name|arithmetic_instr
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|const_first_arg
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|mnemonic
argument_list|,
literal|"%s%s\t%%0, %%2, %%3"
argument_list|,
name|instr
argument_list|,
name|set_cond
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|arm_output_asm_insn
argument_list|(
name|mnemonic
argument_list|,
name|operands
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_arithmetic */
end_comment

begin_comment
comment|/* Output an arithmetic instruction with a shift.    OPERANDS[0] is the destination register.    OPERANDS[1] is the arithmetic operator expression.    OPERANDS[2] is the unshifted register.    OPERANDS[3] is the shift operator expression.    OPERANDS[4] is the shifted register.    OPERANDS[5] is the shift constant or register.    SHIFT_FIRST_ARG is TRUE if the first argument of the operator was shifted.    SET_COND is TRUE when the condition code should be set.  */
end_comment

begin_function
name|char
modifier|*
name|output_arithmetic_with_shift
parameter_list|(
name|operands
parameter_list|,
name|shift_first_arg
parameter_list|,
name|set_cond
parameter_list|)
name|rtx
name|operands
index|[
literal|6
index|]
decl_stmt|;
name|int
name|shift_first_arg
decl_stmt|;
name|int
name|set_cond
decl_stmt|;
block|{
name|char
name|mnemonic
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|instr
init|=
name|arithmetic_instr
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|shift_first_arg
argument_list|)
decl_stmt|;
name|char
modifier|*
name|condbit
init|=
name|set_cond
condition|?
literal|"s"
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|shift
init|=
name|shift_instr
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|,
operator|&
name|operands
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|mnemonic
argument_list|,
literal|"%s%s\t%%0, %%2, %%4, %s %%5"
argument_list|,
name|instr
argument_list|,
name|condbit
argument_list|,
name|shift
argument_list|)
expr_stmt|;
return|return
operator|(
name|arm_output_asm_insn
argument_list|(
name|mnemonic
argument_list|,
name|operands
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_arithmetic_with_shift */
end_comment

begin_comment
comment|/* Output an arithmetic instruction with a power of two multiplication.    OPERANDS[0] is the destination register.    OPERANDS[1] is the arithmetic operator expression.    OPERANDS[2] is the unmultiplied register.    OPERANDS[3] is the multiplied register.    OPERANDS[4] is the constant multiple (power of two).    SHIFT_FIRST_ARG is TRUE if the first arg of the operator was multiplied.  */
end_comment

begin_function
name|char
modifier|*
name|output_arithmetic_with_immediate_multiply
parameter_list|(
name|operands
parameter_list|,
name|shift_first_arg
parameter_list|)
name|rtx
name|operands
index|[
literal|5
index|]
decl_stmt|;
name|int
name|shift_first_arg
decl_stmt|;
block|{
name|char
name|mnemonic
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|instr
init|=
name|arithmetic_instr
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|shift_first_arg
argument_list|)
decl_stmt|;
name|int
name|shift
init|=
name|int_log2
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|mnemonic
argument_list|,
literal|"%s\t%%0, %%2, %%3, asl#%d"
argument_list|,
name|instr
argument_list|,
name|shift
argument_list|)
expr_stmt|;
return|return
operator|(
name|arm_output_asm_insn
argument_list|(
name|mnemonic
argument_list|,
name|operands
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_arithmetic_with_immediate_multiply */
end_comment

begin_comment
comment|/* Output a move with a shift.    OP is the shift rtx code.    OPERANDS[0] = destination register.    OPERANDS[1] = source register.    OPERANDS[2] = shift constant or register.  */
end_comment

begin_function
name|char
modifier|*
name|output_shifted_move
parameter_list|(
name|op
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|op
decl_stmt|;
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
block|{
name|char
name|mnemonic
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|mnemonic
argument_list|,
literal|"mov\t%%0, %%1"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|mnemonic
argument_list|,
literal|"mov\t%%0, %%1, %s %%2"
argument_list|,
name|shift_instr
argument_list|(
name|op
argument_list|,
operator|&
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|arm_output_asm_insn
argument_list|(
name|mnemonic
argument_list|,
name|operands
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* output_shifted_move */
end_comment

begin_comment
comment|/* Output a .ascii pseudo-op, keeping track of lengths.  This is because    /bin/as is horribly restrictive.  */
end_comment

begin_function
name|void
name|output_ascii_pseudo_op
parameter_list|(
name|stream
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|len_so_far
init|=
literal|1000
decl_stmt|;
name|int
name|chars_so_far
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|len_so_far
operator|>
literal|50
condition|)
block|{
if|if
condition|(
name|chars_so_far
condition|)
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.ascii\t\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|=
literal|0
expr_stmt|;
name|arm_increase_location
argument_list|(
name|chars_so_far
argument_list|)
expr_stmt|;
name|chars_so_far
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|4
expr_stmt|;
block|}
name|chars_so_far
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|arm_increase_location
argument_list|(
name|chars_so_far
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output_ascii_pseudo_op */
end_comment

begin_escape
end_escape

begin_function
name|void
name|output_prologue
parameter_list|(
name|f
parameter_list|,
name|frame_size
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|frame_size
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|,
name|live_regs_mask
init|=
literal|0
decl_stmt|,
name|code_size
init|=
literal|0
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
comment|/* Nonzero if the `fp' (argument pointer) register is needed.  */
name|int
name|fp_needed
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if we must stuff some register arguments onto the stack as if      they were passed there.  */
name|int
name|store_arg_regs
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t@ args = %d, pretend = %d, frame = %d\n"
argument_list|,
name|current_function_args_size
argument_list|,
name|current_function_pretend_args_size
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t@ frame_pointer_needed = %d, current_function_anonymous_args = %d\n"
argument_list|,
name|frame_pointer_needed
argument_list|,
name|current_function_anonymous_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_pretend_args_size
operator|||
name|current_function_args_size
operator|||
name|frame_pointer_needed
operator|||
name|current_function_anonymous_args
operator|||
name|TARGET_APCS
condition|)
name|fp_needed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_function_anonymous_args
operator|&&
name|current_function_pretend_args_size
condition|)
name|store_arg_regs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|4
init|;
name|reg
operator|<
literal|10
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
condition|)
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
if|if
condition|(
name|fp_needed
condition|)
block|{
name|live_regs_mask
operator||=
literal|0xD800
expr_stmt|;
comment|/* The following statement is probably redundant now 	 because the frame pointer is recorded in regs_ever_live.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tmov\tip, sp\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regs_ever_live
index|[
literal|14
index|]
condition|)
name|live_regs_mask
operator||=
literal|0x4000
expr_stmt|;
comment|/* If CURRENT_FUNCTION_PRETEND_ARGS_SIZE, adjust the stack pointer to make      room.  If also STORE_ARG_REGS store the argument registers involved in      the created slot (this is for stdarg and varargs).  */
if|if
condition|(
name|current_function_pretend_args_size
condition|)
block|{
if|if
condition|(
name|store_arg_regs
condition|)
block|{
name|int
name|arg_size
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|current_function_pretend_args_size
operator|<=
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|3
operator|,
name|arg_size
operator|=
name|current_function_pretend_args_size
init|;
name|arg_size
operator|>
literal|0
condition|;
name|reg
operator|--
operator|,
name|arg_size
operator|-=
literal|4
control|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"stmfd\tsp!"
argument_list|,
name|mask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|live_regs_mask
condition|)
block|{
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"stmfd\tsp!"
argument_list|,
name|live_regs_mask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|reg
operator|=
literal|23
init|;
name|reg
operator|>
literal|19
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstfe\t%s, [sp, #-12]!\n"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|fp_needed
condition|)
block|{
comment|/* Make `fp' point to saved value of `pc'. */
name|operands
index|[
literal|0
index|]
operator|=
name|arg_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
operator|(
literal|4
operator|+
name|current_function_pretend_args_size
operator|)
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\trfp, sp\n"
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|frame_size
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|frame_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
name|arm_increase_location
argument_list|(
name|code_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output_prologue */
end_comment

begin_function
name|void
name|output_epilogue
parameter_list|(
name|f
parameter_list|,
name|frame_size
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|frame_size
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|,
name|live_regs_mask
init|=
literal|0
decl_stmt|,
name|code_size
init|=
literal|0
decl_stmt|,
name|fp_needed
init|=
literal|0
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|current_function_pretend_args_size
operator|||
name|current_function_args_size
operator|||
name|frame_pointer_needed
operator|||
name|current_function_anonymous_args
operator|||
name|TARGET_APCS
condition|)
name|fp_needed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|4
init|;
name|reg
operator|<
literal|10
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
condition|)
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
if|if
condition|(
name|fp_needed
condition|)
block|{
name|live_regs_mask
operator||=
literal|0xA800
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regs_ever_live
index|[
literal|14
index|]
condition|)
name|live_regs_mask
operator||=
literal|0x4000
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|20
init|;
name|reg
operator|<
literal|24
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldfe\t%s, [%s], #12\n"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|frame_pointer_needed
condition|?
literal|"rfp"
else|:
literal|"sp"
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|fp_needed
condition|)
block|{
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmea\tfp"
argument_list|,
name|live_regs_mask
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Restore stack pointer if necessary.  */
if|if
condition|(
name|frame_size
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
operator|==
literal|0
operator|&&
name|regs_ever_live
index|[
literal|14
index|]
condition|)
block|{
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\tsp!"
argument_list|,
operator|(
name|live_regs_mask
operator|&
operator|~
literal|0x4000
operator|)
operator||
literal|0x8000
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|live_regs_mask
condition|)
block|{
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\tsp!"
argument_list|,
name|live_regs_mask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\tmovs\tpc, lr\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|code_size
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|arm_increase_location
argument_list|(
name|code_size
argument_list|)
expr_stmt|;
name|current_function_anonymous_args
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output_epilogue */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Increase the `arm_text_location' by AMOUNT if we're in the text    segment.  */
end_comment

begin_function
name|void
name|arm_increase_location
parameter_list|(
name|amount
parameter_list|)
name|int
name|amount
decl_stmt|;
block|{
if|if
condition|(
name|in_text_section
argument_list|()
condition|)
name|arm_text_location
operator|+=
name|amount
expr_stmt|;
block|}
end_function

begin_comment
comment|/* arm_increase_location */
end_comment

begin_comment
comment|/* Like output_asm_insn (), but also increases the arm_text_location (if in    the .text segment, of course, even though this will always be true).    Returns the empty string.  */
end_comment

begin_function
name|char
modifier|*
name|arm_output_asm_insn
parameter_list|(
name|template
parameter_list|,
name|operands
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_text_section
argument_list|()
condition|)
name|arm_text_location
operator|+=
literal|4
expr_stmt|;
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/* arm_output_asm_insn */
end_comment

begin_comment
comment|/* Output a label definition.  If this label is within the .text segment, it    is stored in OFFSET_TABLE, to be used when building `llc' instructions.    Maybe GCC remembers names not starting with a `*' for a long time, but this    is a minority anyway, so we just make a copy.  Do not store the leading `*'    if the name starts with one.  */
end_comment

begin_function
name|void
name|arm_asm_output_label
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|real_name
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|struct
name|label_offset
modifier|*
name|cur
decl_stmt|;
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_text_section
argument_list|()
condition|)
return|return;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|real_name
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|real_name
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|real_name
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|real_name
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|real_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|real_name
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|hash
operator|+=
operator|*
name|s
expr_stmt|;
name|hash
operator|=
name|hash
operator|%
name|LABEL_HASH_SIZE
expr_stmt|;
name|cur
operator|=
operator|(
expr|struct
name|label_offset
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|label_offset
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|name
operator|=
name|real_name
expr_stmt|;
name|cur
operator|->
name|offset
operator|=
name|arm_text_location
expr_stmt|;
name|cur
operator|->
name|cdr
operator|=
name|offset_table
index|[
name|hash
index|]
expr_stmt|;
name|offset_table
index|[
name|hash
index|]
operator|=
name|cur
expr_stmt|;
block|}
end_function

begin_comment
comment|/* arm_asm_output_label */
end_comment

begin_comment
comment|/* Output the instructions needed to perform what Martin's /bin/as called    llc: load an SImode thing from the function's constant pool.     XXX This could be enhanced in that we do not really need a pointer in the    constant pool pointing to the real thing.  If we can address this pointer,    we can also address what it is pointing at, in fact, anything in the text    segment which has been defined already within this .s file.  */
end_comment

begin_function
name|char
modifier|*
name|arm_output_llc
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|label_offset
modifier|*
name|he
decl_stmt|;
name|int
name|hash
init|=
literal|0
decl_stmt|,
name|conditional
init|=
operator|(
name|arm_ccfsm_state
operator|==
literal|3
operator|||
name|arm_ccfsm_state
operator|==
literal|4
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'*'
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|s
operator|=
operator|&
name|name
index|[
literal|1
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|hash
operator|+=
operator|*
name|s
expr_stmt|;
name|hash
operator|=
name|hash
operator|%
name|LABEL_HASH_SIZE
expr_stmt|;
name|he
operator|=
name|offset_table
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|he
operator|&&
name|strcmp
argument_list|(
name|he
operator|->
name|name
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
name|he
operator|=
name|he
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
operator|!
name|he
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|arm_text_location
operator|+
literal|8
operator|-
name|he
operator|->
name|offset
operator|<
literal|4095
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tldr%s\t%s, [pc, #%s - . - 8]\n"
argument_list|,
name|conditional
condition|?
name|arm_condition_codes
index|[
name|arm_current_cc
index|]
else|:
literal|""
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
index|]
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|arm_increase_location
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
else|else
block|{
name|int
name|offset
init|=
operator|-
operator|(
name|arm_text_location
operator|+
literal|8
operator|-
name|he
operator|->
name|offset
operator|)
decl_stmt|;
name|char
modifier|*
name|reg_name
init|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
comment|/* ??? This is a hack, assuming the constant pool never is more than 	 (1 + 255) * 4096 == 1Meg away from the PC.  */
if|if
condition|(
name|offset
operator|>
literal|1000000
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tsub%s\t%s, pc, #(8 + . - %s)& ~4095\n"
argument_list|,
name|conditional
condition|?
name|arm_condition_codes
index|[
name|arm_current_cc
index|]
else|:
literal|""
argument_list|,
name|reg_name
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tldr%s\t%s, [%s, #- ((4 + . - %s)& 4095)]\n"
argument_list|,
name|conditional
condition|?
name|arm_condition_codes
index|[
name|arm_current_cc
index|]
else|:
literal|""
argument_list|,
name|reg_name
argument_list|,
name|reg_name
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|arm_increase_location
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_comment
comment|/* arm_output_llc */
end_comment

begin_comment
comment|/* Output code resembling an .lcomm directive.  /bin/as doesn't have this    directive hence this hack, which works by reserving some `.space' in the    bss segment directly.     XXX This is a severe hack, which is guaranteed NOT to work since it doesn't    define STATIC COMMON space but merely STATIC BSS space.  */
end_comment

begin_function
name|void
name|output_lcomm_directive
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|,
name|size
parameter_list|,
name|rounded
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|size
decl_stmt|,
name|rounded
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"\n\t.bss\t@ .lcomm\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|":\t.space\t%d\n"
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_text_section
argument_list|()
condition|)
name|fputs
argument_list|(
literal|"\n\t.text\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\n\t.data\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output_lcomm_directive */
end_comment

begin_escape
end_escape

begin_comment
comment|/* A finite state machine takes care of noticing whether or not instructions    can be conditionally executed, and thus decrease execution time and code    size by deleting branch instructions.  The fsm is controlled by    final_prescan_insn, and controls the actions of ASM_OUTPUT_OPCODE.  */
end_comment

begin_comment
comment|/* The state of the fsm controlling condition codes are:    0: normal, do nothing special    1: make ASM_OUTPUT_OPCODE not output this instruction    2: make ASM_OUTPUT_OPCODE not output this instruction    3: make instructions conditional    4: make instructions conditional     State transitions (state->state by whom under condition):    0 -> 1 final_prescan_insn if the `target' is a label    0 -> 2 final_prescan_insn if the `target' is an unconditional branch    1 -> 3 ASM_OUTPUT_OPCODE after not having output the conditional branch    2 -> 4 ASM_OUTPUT_OPCODE after not having output the conditional branch    3 -> 0 ASM_OUTPUT_INTERNAL_LABEL if the `target' label is reached           (the target label has CODE_LABEL_NUMBER equal to arm_target_label).    4 -> 0 final_prescan_insn if the `target' unconditional branch is reached           (the target insn is arm_target_insn).     XXX In case the `target' is an unconditional branch, this conditionalising    of the instructions always reduces code size, but not always execution    time.  But then, I want to reduce the code size to somewhere near what    /bin/cc produces.  */
end_comment

begin_comment
comment|/* The condition codes of the ARM, and the inverse function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|arm_condition_codes
index|[]
init|=
block|{
literal|"eq"
block|,
literal|"ne"
block|,
literal|"cs"
block|,
literal|"cc"
block|,
literal|"mi"
block|,
literal|"pl"
block|,
literal|"vs"
block|,
literal|"vc"
block|,
literal|"hi"
block|,
literal|"ls"
block|,
literal|"ge"
block|,
literal|"lt"
block|,
literal|"gt"
block|,
literal|"le"
block|,
literal|"al"
block|,
literal|"nv"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARM_INVERSE_CONDITION_CODE
parameter_list|(
name|X
parameter_list|)
value|((X) ^ 1)
end_define

begin_comment
comment|/* Returns the index of the ARM condition code string in    `arm_condition_codes'.  COMPARISON should be an rtx like    `(eq (...) (...))'.  */
end_comment

begin_function
name|int
name|get_arm_condition_code
parameter_list|(
name|comparison
parameter_list|)
name|rtx
name|comparison
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
condition|)
block|{
case|case
name|NE
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|EQ
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|GE
case|:
return|return
operator|(
literal|10
operator|)
return|;
case|case
name|GT
case|:
return|return
operator|(
literal|12
operator|)
return|;
case|case
name|LE
case|:
return|return
operator|(
literal|13
operator|)
return|;
case|case
name|LT
case|:
return|return
operator|(
literal|11
operator|)
return|;
case|case
name|GEU
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|GTU
case|:
return|return
operator|(
literal|8
operator|)
return|;
case|case
name|LEU
case|:
return|return
operator|(
literal|9
operator|)
return|;
case|case
name|LTU
case|:
return|return
operator|(
literal|3
operator|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/*NOTREACHED*/
return|return
operator|(
literal|42
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_arm_condition_code */
end_comment

begin_function
name|void
name|final_prescan_insn
parameter_list|(
name|insn
parameter_list|,
name|opvec
parameter_list|,
name|noperands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|opvec
decl_stmt|;
name|int
name|noperands
decl_stmt|;
block|{
comment|/* BODY will hold the body of INSN.  */
specifier|register
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* This will be 1 if trying to repeat the trick, and things need to be      reversed if it appears to fail.  */
name|int
name|reverse
init|=
literal|0
decl_stmt|;
comment|/* START_INSN will hold the insn from where we start looking.  This is the      first insn after the following code_label if REVERSE is true.  */
name|rtx
name|start_insn
init|=
name|insn
decl_stmt|;
comment|/* If in state 4, check if the target branch is reached, in order to      change back to state 0.  */
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|arm_target_insn
condition|)
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* If in state 3, it is possible to repeat the trick, if this insn is an      unconditional branch to a label, and immediately following this branch      is the previous target label which is only used once, and the label this      branch jumps to is not too far off.  */
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* XXX Isn't this always a barrier?  */
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|start_insn
argument_list|)
operator|==
name|arm_target_label
operator|&&
name|LABEL_NUSES
argument_list|(
name|start_insn
argument_list|)
operator|==
literal|1
condition|)
name|reverse
operator|=
name|TRUE
expr_stmt|;
else|else
return|return;
block|}
else|else
return|return;
block|}
if|if
condition|(
name|arm_ccfsm_state
operator|!=
literal|0
operator|&&
operator|!
name|reverse
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return;
if|if
condition|(
name|reverse
operator|||
operator|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
name|int
name|insns_skipped
init|=
literal|0
decl_stmt|,
name|fail
init|=
name|FALSE
decl_stmt|,
name|succeed
init|=
name|FALSE
decl_stmt|;
comment|/* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */
name|int
name|then_not_else
init|=
name|TRUE
decl_stmt|;
name|rtx
name|this_insn
init|=
name|start_insn
decl_stmt|,
name|label
decl_stmt|;
comment|/* Register the insn jumped to.  */
if|if
condition|(
name|reverse
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|then_not_else
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* See how many insns this branch skips, and what kind of insns.  If all 	 insns are okay, and the label or unconditional branch to the same 	 label is not too far away, succeed.  */
for|for
control|(
name|insns_skipped
operator|=
literal|0
init|;
operator|!
name|fail
operator|&&
operator|!
name|succeed
operator|&&
name|insns_skipped
operator|<
name|MAX_INSNS_SKIPPED
condition|;
name|insns_skipped
operator|++
control|)
block|{
name|rtx
name|scanbody
decl_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_insn
condition|)
break|break;
name|scanbody
operator|=
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* Succeed if it is the target label, otherwise fail since 		 control falls in from somewhere else.  */
if|if
condition|(
name|this_insn
operator|==
name|label
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
comment|/* XXX Is this case necessary?  */
comment|/* Succeed if the following insn is the target label. 		 Otherwise fail.  */
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|==
name|label
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* If this is an unconditional branch to the same label, succeed. 		 If it is to another label, do nothing.  If it is conditional, 		 fail.  */
comment|/* XXX Probably, the test for the SET and the PC are unnecessary. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
operator|&&
operator|!
name|reverse
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|INSN
case|:
comment|/* Instructions affecting the condition codes make it fail.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|scanbody
argument_list|)
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|succeed
condition|)
block|{
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|1
operator|||
name|reverse
condition|)
name|arm_target_label
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|2
condition|)
name|arm_target_insn
operator|=
name|this_insn
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from what 	     it was.  */
if|if
condition|(
operator|!
name|reverse
condition|)
name|arm_current_cc
operator|=
name|get_arm_condition_code
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
operator|||
name|then_not_else
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* final_prescan_insn */
end_comment

begin_comment
comment|/* EOF */
end_comment

end_unit

