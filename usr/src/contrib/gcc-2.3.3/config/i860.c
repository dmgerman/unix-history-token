begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Intel 860    Copyright (C) 1989, 1991 Free Software Foundation, Inc.    Derived from sparc.c.     Written by Richard Stallman (rms@ai.mit.edu).     Hacked substantially by Ron Guilmette (rfg@ncd.com) to cater    to the whims of the System V Release 4 assembler.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function_decl
specifier|static
name|rtx
name|find_addr_reg
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|I860_REG_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|I860_REG_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|i860_reg_prefix
init|=
name|I860_REG_PREFIX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch is emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|i860_compare_op0
decl_stmt|,
name|i860_compare_op1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if this pattern, can be evaluated safely, even if it    was not asked for.  */
end_comment

begin_function
name|int
name|safe_insn_src_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Just experimenting.  */
comment|/* No floating point src is safe if it contains an arithmetic      operation, since that operation may trap.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* We never need to negate or complement constants.  */
case|case
name|NEG
case|:
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|NOT
case|:
case|case
name|ZERO_EXTEND
case|:
return|return
literal|1
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
case|case
name|MINUS
case|:
case|case
name|PLUS
case|:
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if REG is clobbered in IN.    Return 2 if REG is used in IN.     Return 3 if REG is both used and clobbered in IN.    Return 0 if neither.  */
end_comment

begin_function
specifier|static
name|int
name|reg_clobbered_p
parameter_list|(
name|reg
parameter_list|,
name|in
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|int
name|set
init|=
literal|0
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|reg
condition|)
name|set
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|in
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|set
operator|=
literal|1
expr_stmt|;
comment|/* Anything that sets just part of the register 	     is considered using as well as setting it. 	     But note that a straight SUBREG of a single-word value 	     clobbers the entire value.   */
if|if
condition|(
name|dest
operator|!=
name|SET_DEST
argument_list|(
name|in
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|||
name|UNITS_PER_WORD
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
condition|)
name|used
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|set
condition|)
name|used
operator|=
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|in
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|used
operator|=
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|set
operator|+
name|used
operator|*
literal|2
return|;
block|}
if|if
condition|(
name|refers_to_regno_p
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|in
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if OP can be written to without screwing up    GCC's model of what's going on.  It is assumed that this operand    appears in the dest position of a SET insn in a conditional    branch's delay slot.  AFTER is the label to start looking from.  */
end_comment

begin_function
name|int
name|operand_clobbered_before_used_after
parameter_list|(
name|op
parameter_list|,
name|after
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
comment|/* Just experimenting.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CC0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|stack_pointer_rtx
condition|)
return|return
literal|0
return|;
comment|/* Scan forward from the label, to see if the value of OP 	 is clobbered before the first use.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
switch|switch
condition|(
name|reg_clobbered_p
argument_list|(
name|op
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
literal|0
case|:
break|break;
block|}
block|}
comment|/* If we reach another label without clobbering OP, 	     then we cannot safely write it here.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This is a jump insn which has already 		 been mangled.  We can't tell what it does.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Keep following jumps.  */
name|insn
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
comment|/* In both of these cases, the first insn executed      for this op will be a orh whatever%h,%?r0,%?r31,      which is tolerable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this pattern, as a source to a "SET",    is known to yield an instruction of unit size.  */
end_comment

begin_function
name|int
name|single_insn_src_p
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* This is not always a single insn src, technically, 	 but output_delayed_branch knows how to deal with it.  */
return|return
literal|1
return|;
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
comment|/* This is not a single insn src, technically, 	 but output_delayed_branch knows how to deal with it.  */
return|return
literal|1
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
literal|1
return|;
comment|/* We never need to negate or complement constants.  */
case|case
name|NEG
case|:
return|return
operator|(
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|NOT
case|:
case|case
name|ZERO_EXTEND
case|:
return|return
literal|1
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
comment|/* Detect cases that require multiple instructions.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
comment|/* Not doing floating point, since they probably 	 take longer than the branch slot they might fill.  */
return|return
operator|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
operator|)
return|;
case|case
name|AND
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|rtx
name|arg
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|SMALL_INT
argument_list|(
name|arg
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|&
literal|0xffff
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
case|case
name|IOR
case|:
case|case
name|XOR
case|:
comment|/* Both small and round numbers take one instruction; 	 others take two.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|SMALL_INT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|single_insn_src_p
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
comment|/* Not doing floating point, since they probably 	 take longer than the branch slot they might fill.  */
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero only if OP is a register of mode MODE,    or const0_rtx.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operands in a three    address add/subtract insn (such as add %o1,7,%l2) of mode MODE.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand for a logical insn of mode MODE.  */
end_comment

begin_function
name|int
name|logic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|LOGIC_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand for a shift insn of mode MODE.  */
end_comment

begin_function
name|int
name|shift_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand for either a logical insn    or an add insn of mode MODE.  */
end_comment

begin_function
name|int
name|compare_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|&&
name|LOGIC_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as the 5-bit immediate    operand of a bte or btne insn.  */
end_comment

begin_function
name|int
name|bte_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x20
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an indexed memory reference of mode MODE.  */
end_comment

begin_function
name|int
name|indexed_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SImode
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a suitable source operand for a load insn    with mode MODE.  */
end_comment

begin_function
name|int
name|load_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|indexed_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in add/subtract insns.  */
end_comment

begin_function
name|int
name|small_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in logic insns.  */
end_comment

begin_function
name|int
name|logic_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|LOGIC_INT
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
condition|)
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"orh %h0,%?r0,%?r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"st.l %r1,%L0(%?r31)"
return|;
block|}
else|else
return|return
literal|"st.l %r1,%0"
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|{ 	  rtx xoperands[2];  	  cc_status.flags&= ~CC_F0_IS_0; 	  xoperands[0] = gen_rtx (REG, SFmode, 32); 	  xoperands[1] = operands[1]; 	  output_asm_insn (singlemove_string (xoperands), xoperands); 	  xoperands[1] = xoperands[0]; 	  xoperands[0] = operands[0]; 	  output_asm_insn (singlemove_string (xoperands), xoperands); 	  return ""; 	}
endif|#
directive|endif
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"orh %h1,%?r0,%?r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"ld.l %L1(%?r31),%0"
return|;
block|}
return|return
literal|"ld.l %m1,%0"
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|const0_rtx
condition|)
return|return
literal|"mov %?r0,%0"
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
return|return
literal|"or %L1,%?r0,%0"
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0xffff8000
operator|)
operator|==
literal|0xffff8000
condition|)
return|return
literal|"adds %1,%?r0,%0"
return|;
if|if
condition|(
operator|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0x0000ffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|"orh %H1,%?r0,%0"
return|;
block|}
return|return
literal|"mov %1,%0"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Perhaps in some cases move double words    if there is a spare pair of floating regs.  */
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|split_double
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the first move would clobber the source of the second one,      do them in the other order.       RMS says "This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance."       but it happens on the sparc when loading parameter registers,      so I am going to define that circumstance, and make it work      as expected.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|CC_STATUS_PARTIAL_INIT
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"adds 0x4,%0,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"adds 0x4,%0,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"adds -0x4,%0,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"adds -0x4,%0,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Do the late half first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Then clobber.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|CC_STATUS_PARTIAL_INIT
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"adds 0x4,%0,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"adds 0x4,%0,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"adds -0x4,%0,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"adds -0x4,%0,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|output_fp_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* If the source operand is any sort of zero, use f0 instead.  */
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|DFmode
argument_list|,
name|F0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|"fmov.dd %1,%0"
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ixfr %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|"ixfr %1,%0"
return|;
block|}
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
condition|)
return|return
literal|"fmov.dd f0,%0"
return|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"orh %h1,%?r0,%?r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"fld.d %L1(%?r31),%0"
return|;
block|}
return|return
literal|"fld.d %1,%0"
return|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"fxfr %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|VOIDmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|"fxfr %1,%0"
return|;
block|}
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"orh %h0,%?r0,%?r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|"fst.d %1,%L0(%?r31)"
return|;
block|}
return|return
literal|"fst.d %1,%0"
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a template for a load instruction with mode MODE and    arguments from the string ARGS.     This string is in static storage.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|load_opcode
parameter_list|(
name|mode
parameter_list|,
name|args
parameter_list|,
name|reg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
name|opcode
operator|=
literal|"ld.b"
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|opcode
operator|=
literal|"ld.s"
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
if|if
condition|(
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|opcode
operator|=
literal|"fld.l"
expr_stmt|;
else|else
name|opcode
operator|=
literal|"ld.l"
expr_stmt|;
break|break;
case|case
name|DImode
case|:
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
name|DFmode
case|:
name|opcode
operator|=
literal|"fld.d"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|opcode
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Return a template for a store instruction with mode MODE and    arguments from the string ARGS.     This string is in static storage.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|store_opcode
parameter_list|(
name|mode
parameter_list|,
name|args
parameter_list|,
name|reg
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
name|opcode
operator|=
literal|"st.b"
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|opcode
operator|=
literal|"st.s"
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
if|if
condition|(
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|opcode
operator|=
literal|"fst.l"
expr_stmt|;
else|else
name|opcode
operator|=
literal|"st.l"
expr_stmt|;
break|break;
case|case
name|DImode
case|:
if|if
condition|(
operator|!
name|FP_REG_P
argument_list|(
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
name|DFmode
case|:
name|opcode
operator|=
literal|"fst.d"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|opcode
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a store-in-memory whose operands are OPERANDS[0,1].    OPERANDS[0] is a MEM, and OPERANDS[1] is a reg or zero.     This function returns a template for an insn.    This is in static storage.     It may also output some insns directly.    It may alter the values of operands[0] and operands[1].  */
end_comment

begin_function
name|char
modifier|*
name|output_store
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|address
operator|==
name|cc_prev_status
operator|.
name|mdep
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"orh %h0,%?r0,%?r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
block|}
comment|/* Store zero in two parts when appropriate.  */
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|&&
name|operands
index|[
literal|1
index|]
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
condition|)
return|return
name|store_opcode
argument_list|(
name|DFmode
argument_list|,
literal|"%r1,%L0(%?r31)"
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
return|;
comment|/* Code below isn't smart enough to move a doubleword in two parts,      so use output_move_double to do that in the cases that require it.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|&&
operator|!
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
return|return
name|store_opcode
argument_list|(
name|mode
argument_list|,
literal|"%r1,%L0(%?r31)"
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output a load-from-memory whose operands are OPERANDS[0,1].    OPERANDS[0] is a reg, and OPERANDS[1] is a mem.     This function returns a template for an insn.    This is in static storage.     It may also output some insns directly.    It may alter the values of operands[0] and operands[1].  */
end_comment

begin_function
name|char
modifier|*
name|output_load
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|address
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We don't bother trying to see if we know %hi(address).      This is because we are doing a load, and if we know the      %hi value, we probably also know that value in memory.  */
name|cc_status
operator|.
name|flags
operator||=
name|CC_KNOW_HI_R31
operator||
name|CC_HI_R31_ADJ
expr_stmt|;
name|cc_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|address
operator|==
name|cc_prev_status
operator|.
name|mdep
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|cc_status
operator|.
name|mdep
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"orh %h1,%?r0,%?r31"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|.
name|mdep
operator|=
name|address
expr_stmt|;
block|}
comment|/* Code below isn't smart enough to move a doubleword in two parts,      so use output_move_double to do that in the cases that require it.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|)
operator|&&
operator|!
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|output_move_double
argument_list|(
name|operands
argument_list|)
return|;
return|return
name|load_opcode
argument_list|(
name|mode
argument_list|,
literal|"%L1(%?r31),%0"
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Load the address specified by OPERANDS[3] into the register    specified by OPERANDS[0].     OPERANDS[3] may be the result of a sum, hence it could either be:     (1) CONST    (2) REG    (2) REG + CONST_INT    (3) REG + REG + CONST_INT    (4) REG + REG  (special case of 3).     Note that (3) is not a legitimate address.    All cases are handled here.  */
end_comment

begin_comment
unit|void output_load_address (operands)      rtx *operands; {   rtx base, offset;    if (CONSTANT_P (operands[3]))     {       output_asm_insn ("mov %3,%0", operands);       return;     }    if (REG_P (operands[3]))     {       if (REGNO (operands[0]) != REGNO (operands[3])) 	output_asm_insn ("shl %?r0,%3,%0", operands);       return;     }    if (GET_CODE (operands[3]) != PLUS)     abort ();    base = XEXP (operands[3], 0);   offset = XEXP (operands[3], 1);    if (GET_CODE (base) == CONST_INT)     {       rtx tmp = base;       base = offset;       offset = tmp;     }    if (GET_CODE (offset) != CONST_INT)     {
comment|/* Operand is (PLUS (REG) (REG)).  */
end_comment

begin_endif
unit|base = operands[3];       offset = const0_rtx;     }    if (REG_P (base))     {       operands[6] = base;       operands[7] = offset;       CC_STATUS_PARTIAL_INIT;       if (SMALL_INT (offset)) 	output_asm_insn ("adds %7,%6,%0", operands);       else 	output_asm_insn ("mov %7,%0\n\tadds %0,%6,%0", operands);     }   else if (GET_CODE (base) == PLUS)     {       operands[6] = XEXP (base, 0);       operands[7] = XEXP (base, 1);       operands[8] = offset;        CC_STATUS_PARTIAL_INIT;       if (SMALL_INT (offset)) 	output_asm_insn ("adds %6,%7,%0\n\tadds %8,%0,%0", operands);       else 	output_asm_insn ("mov %8,%0\n\tadds %0,%6,%0\n\tadds %0,%7,%0", operands);     }   else     abort (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output code to place a size count SIZE in register REG.    Because block moves are pipelined, we don't include the    first element in the transfer of SIZE to REG.    For this, we subtract ALIGN.  (Actually, I think it is not    right to subtract on this machine, so right now we don't.)  */
end_comment

begin_function
specifier|static
name|void
name|output_size_for_block_move
parameter_list|(
name|size
parameter_list|,
name|reg
parameter_list|,
name|align
parameter_list|)
name|rtx
name|size
decl_stmt|,
name|reg
decl_stmt|,
name|align
decl_stmt|;
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|reg
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|size
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|align
expr_stmt|;
if|#
directive|if
literal|1
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_R31
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|xoperands
argument_list|)
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|REG
condition|)
name|output_asm_insn
argument_list|(
literal|"sub %2,%1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
else|else
block|{
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_R31
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov %1,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit code to perform a block move.     OPERANDS[0] is the destination.    OPERANDS[1] is the source.    OPERANDS[2] is the size.    OPERANDS[3] is the known safe alignment.    OPERANDS[4..6] are pseudos we can safely clobber as temps.  */
end_comment

begin_function
name|char
modifier|*
name|output_block_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* A vector for our computed operands.  Note that load_output_address      makes use of (and can clobber) up to the 8th element of this vector.  */
name|rtx
name|xoperands
index|[
literal|10
index|]
decl_stmt|;
name|rtx
name|zoperands
index|[
literal|10
index|]
decl_stmt|;
specifier|static
name|int
name|movstrsi_label
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|temp1
init|=
name|operands
index|[
literal|4
index|]
decl_stmt|;
name|rtx
name|alignrtx
init|=
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|align
init|=
name|INTVAL
argument_list|(
name|alignrtx
argument_list|)
decl_stmt|;
name|int
name|chunk_size
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|temp1
expr_stmt|;
comment|/* We can't move more than four bytes at a time      because we have only one register to move them through.  */
if|if
condition|(
name|align
operator|>
literal|4
condition|)
block|{
name|align
operator|=
literal|4
expr_stmt|;
name|alignrtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Recognize special cases of block moves.  These occur      when GNU C++ is forced to treat something as BLKmode      to keep it in memory, when its mode could be represented      with something smaller.       We cannot do this for global variables, since we don't know      what pages they don't cross.  Sigh.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|size
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|xoperands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|op1
init|=
name|xoperands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|align
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|size
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|size
operator|>>
literal|2
operator|)
operator|<=
literal|16
condition|)
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_R31
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|>>
literal|2
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.l %a1,%?r31\n\tst.l %?r31,%a0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|align
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
name|size
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
name|size
operator|>>
literal|1
operator|)
operator|<=
literal|16
condition|)
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_R31
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|size
operator|>>
literal|1
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.s %a1,%?r31\n\tst.s %?r31,%a0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
literal|16
condition|)
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|size
argument_list|)
argument_list|)
operator|&&
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|size
argument_list|)
argument_list|)
condition|)
block|{
name|cc_status
operator|.
name|flags
operator|&=
operator|~
name|CC_KNOW_HI_R31
expr_stmt|;
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|xoperands
index|[
literal|0
index|]
operator|=
name|plus_constant
argument_list|(
name|op0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|plus_constant
argument_list|(
name|op1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.b %a1,%?r31\n\tst.b %?r31,%a0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
block|}
block|}
comment|/* Since we clobber untold things, nix the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
comment|/* This is the size of the transfer.      Either use the register which already contains the size,      or use a free register (used by no operands).  */
name|output_size_for_block_move
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|4
index|]
argument_list|,
name|alignrtx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Also emit code to decrement the size value by ALIGN.  */
block|zoperands[0] = operands[0];   zoperands[3] = plus_constant (operands[0], align);   output_load_address (zoperands);
endif|#
directive|endif
comment|/* Generate number for unique label.  */
name|xoperands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|movstrsi_label
operator|++
argument_list|)
expr_stmt|;
comment|/* Calculate the size of the chunks we will be trying to move first.  */
if|#
directive|if
literal|0
block|if ((align& 3) == 0)     chunk_size = 4;   else if ((align& 1) == 0)     chunk_size = 2;   else
endif|#
directive|endif
name|chunk_size
operator|=
literal|1
expr_stmt|;
comment|/* Copy the increment (negative) to a register for bla insn.  */
name|xoperands
index|[
literal|4
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|chunk_size
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|5
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %4,%?r0,%5"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Predecrement the loop counter.  This happens again also in the `bla'      instruction which precedes the loop, but we need to have it done      two times before we enter the loop because of the bizarre semantics      of the bla instruction.  */
name|output_asm_insn
argument_list|(
literal|"adds %5,%2,%2"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Check for the case where the original count was less than or equal to      zero.  Avoid going through the loop at all if the original count was      indeed less than or equal to zero.  Note that we treat the count as      if it were a signed 32-bit quantity here, rather than an unsigned one,      even though we really shouldn't.  We have to do this because of the      semantics of the `ble' instruction, which assume that the count is      a signed 32-bit value.  Anyway, in practice it won't matter because      nobody is going to try to do a memcpy() of more than half of the      entire address space (i.e. 2 gigabytes) anyway.  */
name|output_asm_insn
argument_list|(
literal|"bc .Le%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Make available a register which is a temporary.  */
name|xoperands
index|[
literal|6
index|]
operator|=
name|operands
index|[
literal|6
index|]
expr_stmt|;
comment|/* Now the actual loop.      In xoperands, elements 1 and 0 are the input and output vectors.      Element 2 is the loop index.  Element 5 is the increment.  */
name|output_asm_insn
argument_list|(
literal|"subs %1,%5,%1"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Lm%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"adds %0,%2,%6"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"\n.Lm%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Label for bla above.  */
name|output_asm_insn
argument_list|(
literal|"\n.Ls%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Loop start label. */
name|output_asm_insn
argument_list|(
literal|"adds %5,%6,%6"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* NOTE:  The code here which is supposed to handle the cases where the      sources and destinations are known to start on a 4 or 2 byte boundary      are currently broken.  They fail to do anything about the overflow      bytes which might still need to be copied even after we have copied      some number of words or halfwords.  Thus, for now we use the lowest      common denominator, i.e. the code which just copies some number of      totally unaligned individual bytes.  (See the calculation of      chunk_size above.  */
if|if
condition|(
name|chunk_size
operator|==
literal|4
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ld.l %2(%1),%?r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Ls%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st.l %?r31,8(%6)"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_size
operator|==
literal|2
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ld.s %2(%1),%?r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Ls%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st.s %?r31,4(%6)"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* chunk_size == 1 */
block|{
name|output_asm_insn
argument_list|(
literal|"ld.b %2(%1),%?r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bla %5,%2,.Ls%3"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"st.b %?r31,2(%6)"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"\n.Le%3:"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Here if count<= 0.  */
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a delayed branch insn with the delay insn in its    branch slot.  The delayed branch insn template is in TEMPLATE,    with operands OPERANDS.  The insn in its delay slot is INSN.     As a special case, since we know that all memory transfers are via    ld/st insns, if we see a (MEM (SYMBOL_REF ...)) we divide the memory    reference around the branch as  	orh ha%x,%?r0,%?r31 	b ... 	ld/st l%x(%?r31),...     As another special case, we handle loading (SYMBOL_REF ...) and    other large constants around branches as well:  	orh h%x,%?r0,%0 	b ... 	or l%x,%0,%1     */
end_comment

begin_function
name|char
modifier|*
name|output_delayed_branch
parameter_list|(
name|template
parameter_list|,
name|operands
parameter_list|,
name|insn
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* See if we are doing some branch together with setting some register      to some 32-bit value which does (or may) have some of the high-order      16 bits set.  If so, we need to set the register in two stages.  One      stage must be done before the branch, and the other one can be done      in the delay slot.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|&
operator|(
name|unsigned
operator|)
literal|0xffff0000
operator|)
operator|!=
operator|(
name|unsigned
operator|)
literal|0
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST
operator|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|src
expr_stmt|;
name|CC_STATUS_PARTIAL_INIT
expr_stmt|;
comment|/* Output the `orh' insn.  */
name|output_asm_insn
argument_list|(
literal|"orh %H1,%?r0,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* Output the branch instruction next.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now output the `or' insn.  */
name|output_asm_insn
argument_list|(
literal|"or %L1,%0,%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|split_template
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|src
expr_stmt|;
comment|/* Output the `orh' insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"orh %h1,%?r0,%?r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
name|split_template
operator|=
name|load_opcode
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|"%L1(%?r31),%0"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_KNOW_HI_R31
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_HI_R31_ADJ
operator|)
operator|&&
name|cc_prev_status
operator|.
name|mdep
operator|==
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"orh %h0,%?r0,%?r31"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
name|split_template
operator|=
name|store_opcode
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|"%r1,%L0(%?r31)"
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Output the branch instruction next.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now output the load or store. 	 No need to do a CC_STATUS_INIT, because we are branching anyway.  */
name|output_asm_insn
argument_list|(
name|split_template
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|insn_code_number
decl_stmt|;
name|rtx
name|pat
init|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|rtx
name|delay_insn
init|=
name|gen_rtx
argument_list|(
name|INSN
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pat
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Output the branch instruction first.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Now recognize the insn which we put in its delay slot. 	 We must do this after outputting the branch insn, 	 since operands may just be a pointer to `recog_operand'.  */
name|INSN_CODE
argument_list|(
name|delay_insn
argument_list|)
operator|=
name|insn_code_number
operator|=
name|recog
argument_list|(
name|pat
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|insn_extract
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_number
argument_list|,
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
block|}
name|CC_STATUS_INIT
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a newly constructed insn DELAY_INSN.  */
end_comment

begin_function
name|char
modifier|*
name|output_delay_insn
parameter_list|(
name|delay_insn
parameter_list|)
name|rtx
name|delay_insn
decl_stmt|;
block|{
name|char
modifier|*
name|template
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Now recognize the insn which we put in its delay slot.      We must do this after outputting the branch insn,      since operands may just be a pointer to `recog_operand'.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Extract the operands of this delay insn.  */
name|INSN_CODE
argument_list|(
name|delay_insn
argument_list|)
operator|=
name|insn_code_number
expr_stmt|;
name|insn_extract
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
comment|/* It is possible that this insn has not been properly scanned by final      yet.  If this insn's operands don't appear in the peephole's      actual operands, then they won't be fixed up by final, so we      make sure they get fixed up here.  -- This is a kludge.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_number
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
comment|/* Update `cc_status' for this instruction.      The instruction's output routine may change it further.      If the output routine for a jump insn needs to depend      on the cc status, it should look at cc_prev_status.  */
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|delay_insn
argument_list|)
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
comment|/* Now get the template for what this insn would      have been, without the branch.  */
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|delay_insn
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Special routine to convert an SFmode value represented as a    CONST_DOUBLE into its equivalent unsigned long bit pattern.    We convert the value from a double precision floating-point    value to single precision first, and thence to a bit-wise    equivalent unsigned long value.  This routine is used when    generating an immediate move of an SFmode value directly    into a general register because the svr4 assembler doesn't    grok floating literals in instruction operand contexts.  */
end_comment

begin_function
name|unsigned
name|long
name|sfmode_constant_to_ulong
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
block|}
name|u2
union|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SFmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
name|TARGET_FLOAT_FORMAT
operator|!=
name|HOST_FLOAT_FORMAT
name|error
name|IEEE
name|emulation
name|needed
endif|#
directive|endif
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|u2
operator|.
name|f
operator|=
name|d
expr_stmt|;
return|return
name|u2
operator|.
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function generates the assembly code for function entry.    The macro FUNCTION_PROLOGUE in i860.h is defined to call this function.     ASM_FILE is a stdio stream to output the code to.    SIZE is an int: how many units of temporary storage to allocate.     Refer to the array `regs_ever_live' to determine which registers    to save; `regs_ever_live[I]' is nonzero if register number I    is ever used in the function.  This macro is responsible for    knowing which registers should not be saved even if used.     NOTE: `frame_lower_bytes' is the count of bytes which will lie    between the new `fp' value and the new `sp' value after the    prologue is done.  `frame_upper_bytes' is the count of bytes    that will lie between the new `fp' and the *old* `sp' value    after the new `fp' is setup (in the prologue).  The upper    part of each frame always includes at least 2 words (8 bytes)    to hold the saved frame pointer and the saved return address.     The svr4 ABI for the i860 now requires that the values of the    stack pointer and frame pointer registers be kept aligned to    16-byte boundaries at all times.  We obey that restriction here.     The svr4 ABI for the i860 is entirely vague when it comes to specifying    exactly where the "preserved" registers should be saved.  The native    svr4 C compiler I now have doesn't help to clarify the requirements    very much because it is plainly out-of-date and non-ABI-compliant    (in at least one important way, i.e. how it generates function    epilogues).     The native svr4 C compiler saves the "preserved" registers (i.e.    r4-r15 and f2-f7) in the lower part of a frame (i.e. at negative    offsets from the frame pointer).     Previous versions of GCC also saved the "preserved" registers in the    "negative" part of the frame, but they saved them using positive    offsets from the (adjusted) stack pointer (after it had been adjusted    to allocate space for the new frame).  That's just plain wrong    because if the current function calls alloca(), the stack pointer    will get moved, and it will be impossible to restore the registers    properly again after that.     Both compilers handled parameter registers (i.e. r16-r27 and f8-f15)    by copying their values either into various "preserved" registers or    into stack slots in the lower part of the current frame (as seemed    appropriate, depending upon subsequent usage of these values).     Here we want to save the preserved registers at some offset from the    frame pointer register so as to avoid any possible problems arising    from calls to alloca().  We can either save them at small positive    offsets from the frame pointer, or at small negative offsets from    the frame pointer.  If we save them at small negative offsets from    the frame pointer (i.e. in the lower part of the frame) then we    must tell the rest of GCC (via STARTING_FRAME_OFFSET) exactly how    many bytes of space we plan to use in the lower part of the frame    for this purpose.  Since other parts of the compiler reference the    value of STARTING_FRAME_OFFSET long before final() calls this function,    we would have to go ahead and assume the worst-case storage requirements    for saving all of the "preserved" registers (and use that number, i.e.    `80', to define STARTING_FRAME_OFFSET) if we wanted to save them in    the lower part of the frame.  That could potentially be very wasteful,    and that wastefulness could really hamper people compiling for embedded    i860 targets with very tight limits on stack space.  Thus, we choose    here to save the preserved registers in the upper part of the    frame, so that we can decide at the very last minute how much (or how    little) space we must allocate for this purpose.     To satisfy the needs of the svr4 ABI "tdesc" scheme, preserved    registers must always be saved so that the saved values of registers    with higher numbers are at higher addresses.  We obey that restriction    here.     There are two somewhat different ways that you can generate prologues    here... i.e. pedantically ABI-compliant, and the "other" way.  The    "other" way is more consistent with what is currently generated by the    "native" svr4 C compiler for the i860.  That's important if you want    to use the current (as of 8/91) incarnation of svr4 SDB for the i860.    The SVR4 SDB for the i860 insists on having function prologues be    non-ABI-compliant!     To get fully ABI-compliant prologues, define I860_STRICT_ABI_PROLOGUES    in the i860svr4.h file.  (By default this is *not* defined).     The differences between the ABI-compliant and non-ABI-compliant prologues    are that (a) the ABI version seems to require the use of *signed*    (rather than unsigned) adds and subtracts, and (b) the ordering of    the various steps (e.g. saving preserved registers, saving the    return address, setting up the new frame pointer value) is different.     For strict ABI compliance, it seems to be the case that the very last    thing that is supposed to happen in the prologue is getting the frame    pointer set to its new value (but only after everything else has    already been properly setup).  We do that here, but only if the symbol    I860_STRICT_ABI_PROLOGUES is defined. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|STACK_ALIGNMENT
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|leaf_function_p
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|current_function_original_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|must_preserve_r1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|must_preserve_bytes
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|function_prologue
parameter_list|(
name|asm_file
parameter_list|,
name|local_bytes
parameter_list|)
specifier|register
name|FILE
modifier|*
name|asm_file
decl_stmt|;
specifier|register
name|unsigned
name|local_bytes
decl_stmt|;
block|{
specifier|register
name|unsigned
name|frame_lower_bytes
decl_stmt|;
specifier|register
name|unsigned
name|frame_upper_bytes
decl_stmt|;
specifier|register
name|unsigned
name|total_fsize
decl_stmt|;
specifier|register
name|unsigned
name|preserved_reg_bytes
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
specifier|register
name|unsigned
name|preserved_so_far
init|=
literal|0
decl_stmt|;
name|must_preserve_r1
operator|=
operator|(
name|optimize
operator|<
literal|2
operator|||
operator|!
name|leaf_function_p
argument_list|()
operator|)
expr_stmt|;
name|must_preserve_bytes
operator|=
literal|4
operator|+
operator|(
name|must_preserve_r1
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Count registers that need preserving.  Ignore r0.  It never needs      preserving.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|preserved_reg_bytes
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Round-up the frame_lower_bytes so that it's a multiple of 16. */
name|frame_lower_bytes
operator|=
operator|(
name|local_bytes
operator|+
name|STACK_ALIGNMENT
operator|-
literal|1
operator|)
operator|&
operator|-
name|STACK_ALIGNMENT
expr_stmt|;
comment|/* The upper part of each frame will contain the saved fp,      the saved r1, and stack slots for all of the other "preserved"      registers that we find we will need to save& restore. */
name|frame_upper_bytes
operator|=
name|must_preserve_bytes
operator|+
name|preserved_reg_bytes
expr_stmt|;
comment|/* Round-up the frame_upper_bytes so that it's a multiple of 16. */
name|frame_upper_bytes
operator|=
operator|(
name|frame_upper_bytes
operator|+
name|STACK_ALIGNMENT
operator|-
literal|1
operator|)
operator|&
operator|-
name|STACK_ALIGNMENT
expr_stmt|;
name|total_fsize
operator|=
name|frame_upper_bytes
operator|+
name|frame_lower_bytes
expr_stmt|;
ifndef|#
directive|ifndef
name|I860_STRICT_ABI_PROLOGUES
comment|/* There are two kinds of function prologues.      You use the "small" version if the total frame size is      small enough so that it can fit into an immediate 16-bit      value in one instruction.  Otherwise, you use the "large"      version of the function prologue.  */
if|if
condition|(
name|total_fsize
operator|>
literal|0x7fff
condition|)
block|{
comment|/* Adjust the stack pointer.  The ABI sez to do this using `adds', 	 but the native C compiler on svr4 uses `addu'.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\taddu -%d,%ssp,%ssp\n"
argument_list|,
name|frame_upper_bytes
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Save the old frame pointer.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %sfp,0(%ssp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Setup the new frame pointer.  The ABI sez to do this after 	 preserving registers (using adds), but that's not what the 	 native C compiler on svr4 does.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\taddu 0,%ssp,%sfp\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Get the value of frame_lower_bytes into r31.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\torh %d,%sr0,%sr31\n"
argument_list|,
name|frame_lower_bytes
operator|>>
literal|16
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tor %d,%sr31,%sr31\n"
argument_list|,
name|frame_lower_bytes
operator|&
literal|0xffff
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Now re-adjust the stack pointer using the value in r31. 	 The ABI sez to do this with `subs' but SDB may prefer `subu'.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tsubu %ssp,%sr31,%ssp\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Preserve registers.  The ABI sez to do this before setting 	 up the new frame pointer, but that's not what the native 	 C compiler on svr4 does.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %s%s,%d(%sfp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|preserved_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tfst.l %s%s,%d(%sfp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|preserved_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Save the return address.  */
if|if
condition|(
name|must_preserve_r1
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %sr1,4(%sfp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust the stack pointer.  The ABI sez to do this using `adds', 	 but the native C compiler on svr4 uses `addu'.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\taddu -%d,%ssp,%ssp\n"
argument_list|,
name|total_fsize
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Save the old frame pointer.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %sfp,%d(%ssp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|frame_lower_bytes
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Setup the new frame pointer.  The ABI sez to do this after 	 preserving registers and after saving the return address, 	(and its saz to do this using adds), but that's not what the 	 native C compiler on svr4 does.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\taddu %d,%ssp,%sfp\n"
argument_list|,
name|frame_lower_bytes
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Preserve registers.  The ABI sez to do this before setting 	 up the new frame pointer, but that's not what the native 	 compiler on svr4 does.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %s%s,%d(%sfp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|preserved_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tfst.l %s%s,%d(%sfp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|preserved_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Save the return address.  The ABI sez to do this earlier, 	 and also via an offset from %sp, but the native C compiler 	 on svr4 does it later (i.e. now) and uses an offset from 	 %fp.  */
if|if
condition|(
name|must_preserve_r1
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %sr1,4(%sfp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* defined(I860_STRICT_ABI_PROLOGUES) */
comment|/* There are two kinds of function prologues.      You use the "small" version if the total frame size is      small enough so that it can fit into an immediate 16-bit      value in one instruction.  Otherwise, you use the "large"      version of the function prologue.  */
if|if
condition|(
name|total_fsize
operator|>
literal|0x7fff
condition|)
block|{
comment|/* Adjust the stack pointer (thereby allocating a new frame).  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tadds -%d,%ssp,%ssp\n"
argument_list|,
name|frame_upper_bytes
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Save the caller's frame pointer.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %sfp,0(%ssp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Save return address.  */
if|if
condition|(
name|must_preserve_r1
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %sr1,4(%ssp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Get the value of frame_lower_bytes into r31 for later use.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\torh %d,%sr0,%sr31\n"
argument_list|,
name|frame_lower_bytes
operator|>>
literal|16
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tor %d,%sr31,%sr31\n"
argument_list|,
name|frame_lower_bytes
operator|&
literal|0xffff
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Now re-adjust the stack pointer using the value in r31.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tsubs %ssp,%sr31,%ssp\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Pre-compute value to be used as the new frame pointer.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tadds %ssp,%sr31,%sr31\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Preserve registers.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %s%s,%d(%sr31)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|preserved_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tfst.l %s%s,%d(%sr31)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|preserved_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Actually set the new value of the frame pointer.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tmov %sr31,%sfp\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust the stack pointer.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tadds -%d,%ssp,%ssp\n"
argument_list|,
name|total_fsize
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Save the caller's frame pointer.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %sfp,%d(%ssp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|frame_lower_bytes
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Save the return address.  */
if|if
condition|(
name|must_preserve_r1
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %sr1,%d(%ssp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|frame_lower_bytes
operator|+
literal|4
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Preserve registers.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tst.l %s%s,%d(%ssp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|frame_lower_bytes
operator|+
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|preserved_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tfst.l %s%s,%d(%ssp)\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|frame_lower_bytes
operator|+
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|preserved_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Setup the new frame pointer.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tadds %d,%ssp,%sfp\n"
argument_list|,
name|frame_lower_bytes
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(I860_STRICT_ABI_PROLOGUES) */
ifdef|#
directive|ifdef
name|ASM_OUTPUT_PROLOGUE_SUFFIX
name|ASM_OUTPUT_PROLOGUE_SUFFIX
argument_list|(
name|asm_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(ASM_OUTPUT_PROLOGUE_SUFFIX) */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function generates the assembly code for function exit.    The macro FUNCTION_EPILOGUE in i860.h is defined to call this function.     ASM_FILE is a stdio stream to output the code to.    SIZE is an int: how many units of temporary storage to allocate.     The function epilogue should not depend on the current stack pointer!    It should use the frame pointer only.  This is mandatory because    of alloca; we also take advantage of it to omit stack adjustments    before returning.     Note that when we go to restore the preserved register values we must    not try to address their slots by using offsets from the stack pointer.    That's because the stack pointer may have been moved during the function    execution due to a call to alloca().  Rather, we must restore all    preserved registers via offsets from the frame pointer value.     Note also that when the current frame is being "popped" (by adjusting    the value of the stack pointer) on function exit, we must (for the    sake of alloca) set the new value of the stack pointer based upon    the current value of the frame pointer.  We can't just add what we    believe to be the (static) frame size to the stack pointer because    if we did that, and alloca() had been called during this function,    we would end up returning *without* having fully deallocated all of    the space grabbed by alloca.  If that happened, and a function    containing one or more alloca() calls was called over and over again,    then the stack would grow without limit!     Finally note that the epilogues generated here are completely ABI    compliant.  They go out of their way to insure that the value in    the frame pointer register is never less than the value in the stack    pointer register.  It's not clear why this relationship needs to be    maintained at all times, but maintaining it only costs one extra    instruction, so what the hell. */
end_comment

begin_comment
comment|/* This corresponds to a version 4 TDESC structure. Lower numbered    versions successively omit the last word of the structure. We    don't try to handle version 5 here. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|TDESC_flags
block|{
name|int
name|version
range|:
literal|4
decl_stmt|;
name|int
name|reg_packing
range|:
literal|1
decl_stmt|;
name|int
name|callable_block
range|:
literal|1
decl_stmt|;
name|int
name|reserved
range|:
literal|4
decl_stmt|;
name|int
name|fregs
range|:
literal|6
decl_stmt|;
comment|/* fp regs 2-7 */
name|int
name|iregs
range|:
literal|16
decl_stmt|;
comment|/* regs 0-15 */
block|}
name|TDESC_flags
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|TDESC
block|{
name|TDESC_flags
name|flags
decl_stmt|;
name|int
name|integer_reg_offset
decl_stmt|;
comment|/* same as must_preserve_bytes */
name|int
name|floating_point_reg_offset
decl_stmt|;
name|unsigned
name|int
name|positive_frame_size
decl_stmt|;
comment|/* same as frame_upper_bytes */
name|unsigned
name|int
name|negative_frame_size
decl_stmt|;
comment|/* same as frame_lower_bytes */
block|}
name|TDESC
typedef|;
end_typedef

begin_function
name|void
name|function_epilogue
parameter_list|(
name|asm_file
parameter_list|,
name|local_bytes
parameter_list|)
specifier|register
name|FILE
modifier|*
name|asm_file
decl_stmt|;
specifier|register
name|unsigned
name|local_bytes
decl_stmt|;
block|{
specifier|register
name|unsigned
name|frame_upper_bytes
decl_stmt|;
specifier|register
name|unsigned
name|frame_lower_bytes
decl_stmt|;
specifier|register
name|unsigned
name|preserved_reg_bytes
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
specifier|register
name|unsigned
name|restored_so_far
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int_restored
decl_stmt|;
specifier|register
name|unsigned
name|mask
decl_stmt|;
name|unsigned
name|intflags
init|=
literal|0
decl_stmt|;
specifier|register
name|TDESC_flags
modifier|*
name|flags
init|=
operator|(
name|TDESC_flags
operator|*
operator|)
operator|&
name|intflags
decl_stmt|;
name|flags
operator|->
name|version
operator|=
literal|4
expr_stmt|;
name|flags
operator|->
name|reg_packing
operator|=
literal|1
expr_stmt|;
name|flags
operator|->
name|iregs
operator|=
literal|8
expr_stmt|;
comment|/* old fp always gets saved */
comment|/* Round-up the frame_lower_bytes so that it's a multiple of 16. */
name|frame_lower_bytes
operator|=
operator|(
name|local_bytes
operator|+
name|STACK_ALIGNMENT
operator|-
literal|1
operator|)
operator|&
operator|-
name|STACK_ALIGNMENT
expr_stmt|;
comment|/* Count the number of registers that were preserved in the prologue.      Ignore r0.  It is never preserved.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|preserved_reg_bytes
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* The upper part of each frame will contain only saved fp,      the saved r1, and stack slots for all of the other "preserved"      registers that we find we will need to save& restore. */
name|frame_upper_bytes
operator|=
name|must_preserve_bytes
operator|+
name|preserved_reg_bytes
expr_stmt|;
comment|/* Round-up frame_upper_bytes so that t is a multiple of 16. */
name|frame_upper_bytes
operator|=
operator|(
name|frame_upper_bytes
operator|+
name|STACK_ALIGNMENT
operator|-
literal|1
operator|)
operator|&
operator|-
name|STACK_ALIGNMENT
expr_stmt|;
comment|/* Restore all of the "preserved" registers that need restoring.  */
name|mask
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
operator|,
name|mask
operator|<<=
literal|1
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tld.l %d(%sfp),%s%s\n"
argument_list|,
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|restored_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|3
operator|&&
name|i
operator|<
literal|16
condition|)
name|flags
operator|->
name|iregs
operator||=
name|mask
expr_stmt|;
block|}
name|int_restored
operator|=
name|restored_so_far
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tfld.l %d(%sfp),%s%s\n"
argument_list|,
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|restored_so_far
operator|++
operator|)
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|33
operator|&
name|i
operator|<
literal|40
condition|)
name|flags
operator|->
name|fregs
operator||=
name|mask
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|33
operator|&&
name|i
operator|<
literal|40
condition|)
name|mask
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* Get the value we plan to use to restore the stack pointer into r31.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tadds %d,%sfp,%sr31\n"
argument_list|,
name|frame_upper_bytes
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Restore the return address and the old frame pointer.  */
if|if
condition|(
name|must_preserve_r1
condition|)
block|{
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tld.l 4(%sfp),%sr1\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
name|flags
operator|->
name|iregs
operator||=
literal|2
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tld.l 0(%sfp),%sfp\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
comment|/* Return and restore the old stack pointer value.  */
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\tbri %sr1\n\tmov %sr31,%ssp\n"
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|,
name|i860_reg_prefix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OUTPUT_TDESC
comment|/* Output an ABI-compliant TDESC entry */
if|if
condition|(
operator|!
name|frame_lower_bytes
condition|)
block|{
name|flags
operator|->
name|version
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|frame_upper_bytes
condition|)
block|{
name|flags
operator|->
name|version
operator|--
expr_stmt|;
if|if
condition|(
name|restored_so_far
operator|==
name|int_restored
condition|)
comment|/* No FP saves */
name|flags
operator|->
name|version
operator|--
expr_stmt|;
block|}
block|}
name|assemble_name
argument_list|(
name|asm_file
argument_list|,
name|current_function_original_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|".TDESC:\n"
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"%s 0x%0x\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|intflags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"%s %d\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|int_restored
condition|?
name|must_preserve_bytes
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|version
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"%s %d\n"
argument_list|,
name|ASM_LONG
argument_list|,
operator|(
name|restored_so_far
operator|==
name|int_restored
operator|)
condition|?
literal|0
else|:
name|must_preserve_bytes
operator|+
operator|(
literal|4
operator|*
name|int_restored
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|version
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"%s %d\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|frame_upper_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|version
operator|>
literal|3
condition|)
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"%s %d\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|frame_lower_bytes
argument_list|)
expr_stmt|;
block|}
block|}
name|tdesc_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"%s "
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_file
argument_list|,
name|current_function_original_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\n%s "
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_file
argument_list|,
name|current_function_original_name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|".TDESC\n"
argument_list|,
name|asm_file
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

