begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on AMD Am29000.    Copyright (C) 1987, 1988, 1990, 1991, 1992 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_comment
comment|/* This gives the size in words of the register stack for the current    procedure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|a29k_regstack_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to the last insn of the insn prologue.  It is set when    an insn without a filled delay slot is found near the start of the    function.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|a29k_last_prologue_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points to the first insn that will be in the epilogue.  It is null if    no epilogue is required.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|a29k_first_epilogue_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is nonzero if a a29k_first_epilogue_insn was put in a delay slot.  It    indicates that an intermediate label needs to be written.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|a29k_first_epilogue_insn_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location to hold the name of the current function.  We need this prolog to    contain the tag words prior to the declaration.  So the name must be stored    away.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|a29k_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of registers to debug register numbers.  The only change is    for the frame pointer and the register numbers used for the incoming    arguments.  */
end_comment

begin_decl_stmt
name|int
name|a29k_debug_reg_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|a29k_compare_op0
decl_stmt|,
name|a29k_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a29k_compare_fp_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Gives names for registers.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reg_names
index|[]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP is a 8-bit constant. */
end_comment

begin_function
name|int
name|cint_8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffffff00
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a 16-bit constant.  */
end_comment

begin_function
name|int
name|cint_16_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a constant that cannot be moved in a single insn.  */
end_comment

begin_function
name|int
name|long_const_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_29050
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0xffff0000
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|!=
literal|0x80000000
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following four functions detect constants of 0, 8, 16, and 24 used as    a position in ZERO_EXTRACT operations.  They can either be the appropriate    constant integer or a shift (which will be produced by combine).  */
end_comment

begin_function
specifier|static
name|int
name|shift_constant_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|,
name|val
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
name|val
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|val
operator|/
literal|8
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|3
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|const_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|shift_constant_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|const_8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|shift_constant_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|8
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|const_16_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|shift_constant_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|const_24_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|shift_constant_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
literal|24
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a floating-point constant of the proper mode.  */
end_comment

begin_function
name|int
name|float_const_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a floating-point constant of the proper mode or a    general-purpose register.  */
end_comment

begin_function
name|int
name|gpc_reg_or_float_constant_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|float_const_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an integer constant of the proper mode or a    general-purpose register.  */
end_comment

begin_function
name|int
name|gpc_reg_or_integer_constant_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
operator|)
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP is a special machine register.  */
end_comment

begin_function
name|int
name|spec_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_PARTIAL_INT
case|:
return|return
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|R_BP
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<=
name|R_CR
return|;
case|case
name|MODE_INT
case|:
return|return
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|R_Q
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<=
name|R_EXO
return|;
name|detault
label|:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is an accumulator register.  */
end_comment

begin_function
name|int
name|accum_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|R_ACC
argument_list|(
literal|0
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<=
name|R_ACC
argument_list|(
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a normal data register.  */
end_comment

begin_function
name|int
name|gpc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|op
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|+=
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|regno
operator|<
name|R_BP
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either an 8-bit constant integer or a general register.    If a register, it must be in the proper mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|srcb_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|mode
operator|==
name|QImode
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffffff00
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is either an immediate or a general register.  This is used    for the input operand of mtsr/mtrsim.  */
end_comment

begin_function
name|int
name|gpc_reg_or_immediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP can be used as the second operand of and AND insn.  This    includes srcb_operand and a constant whose complement fits in 8 bits.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|srcb_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|<
literal|256
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP can be used as the second operand of an ADD insn.    This is the same as above, except we use negative, rather than    complement.   */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|srcb_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|<
literal|256
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid address in a CALL_INSN.  These are a SYMBOL_REF    to the current function, all SYMBOL_REFs if TARGET_SMALL_MEMORY, or    a sufficiently-small constant.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
operator|(
name|TARGET_SMALL_MEMORY
operator|||
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_function_name
argument_list|)
operator|)
return|;
case|case
name|CONST_INT
case|:
return|return
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x40000
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP can be used as the input operand for a move insn.  */
end_comment

begin_function
name|int
name|in_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|orig_op
init|=
name|op
decl_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|UNITS_PER_WORD
operator|||
name|TARGET_DW_ENABLE
operator|)
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|QImode
operator|)
return|;
case|case
name|CONST_DOUBLE
case|:
return|return
operator|(
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if OP can be used as the output operand for a move insn.  */
end_comment

begin_function
name|int
name|out_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|orig_op
init|=
name|op
decl_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|orig_op
argument_list|,
name|mode
argument_list|)
operator|||
name|spec_reg_operand
argument_list|(
name|orig_op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|accum_reg_operand
argument_list|(
name|orig_op
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|UNITS_PER_WORD
operator|||
name|TARGET_DW_ENABLE
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an item in memory, given that we are in reload.  */
end_comment

begin_function
name|int
name|reload_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an object for which reload_memory_operand is true, return the address    of the operand, taking into account anything that reload may do.  */
end_comment

begin_function
name|rtx
name|a29k_get_reloaded_address
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|SUBREG_WORD
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
name|op
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
expr_stmt|;
return|return
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subfunction of the following function.  Update the flags of any MEM    found in part of X.  */
end_comment

begin_function
specifier|static
name|void
name|a29k_set_memflags_1
parameter_list|(
name|x
parameter_list|,
name|in_struct_p
parameter_list|,
name|volatile_p
parameter_list|,
name|unchanging_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|in_struct_p
decl_stmt|,
name|volatile_p
decl_stmt|,
name|unchanging_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SEQUENCE
case|:
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|a29k_set_memflags_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|a29k_set_memflags_1
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|a29k_set_memflags_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
name|a29k_set_memflags_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|volatile_p
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given INSN, which is either an INSN or a SEQUENCE generated to    perform a memory operation, look for any MEMs in either a SET_DEST or    a SET_SRC and copy the in-struct, unchanging, and volatile flags from    REF into each of the MEMs found.  If REF is not a MEM, don't do    anything.  */
end_comment

begin_function
name|void
name|a29k_set_memflags
parameter_list|(
name|insn
parameter_list|,
name|ref
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ref
decl_stmt|;
block|{
comment|/* Note that it is always safe to get these flags, though they won't      be what we think if REF is not a MEM.  */
name|int
name|in_struct_p
init|=
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|int
name|volatile_p
init|=
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|int
name|unchanging_p
init|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
operator|||
operator|(
operator|!
name|in_struct_p
operator|&&
operator|!
name|volatile_p
operator|&&
operator|!
name|unchanging_p
operator|)
condition|)
return|return;
name|a29k_set_memflags_1
argument_list|(
name|insn
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a comparison operator that we have in floating-point.  */
end_comment

begin_function
name|int
name|fp_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|GT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|GE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid branch comparison.  */
end_comment

begin_function
name|int
name|branch_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|GE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LT
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a load multiple operation.  It is known to be a    PARALLEL and the first three sections will be tested.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|-
literal|2
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similar, but tests for store multiple.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|num_special
init|=
name|TARGET_NO_STOREM_BUG
condition|?
literal|2
else|:
literal|1
decl_stmt|;
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|-
name|num_special
decl_stmt|;
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|+
name|num_special
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a special register REG and MASK, a value being masked against a    quantity to which the special register is set, return 1 if the masking    operation is built-in to the setting of that special register.  */
end_comment

begin_function
name|int
name|masks_bits_for_special
parameter_list|(
name|reg
parameter_list|,
name|mask
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|mask
decl_stmt|;
block|{
name|int
name|needed_mask_value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|mask
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
block|{
case|case
name|R_BP
case|:
case|case
name|R_INT
case|:
name|needed_mask_value
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|R_FC
case|:
name|needed_mask_value
operator|=
literal|31
expr_stmt|;
break|break;
case|case
name|R_CR
case|:
case|case
name|R_LRU
case|:
name|needed_mask_value
operator|=
literal|255
expr_stmt|;
break|break;
case|case
name|R_FPE
case|:
name|needed_mask_value
operator|=
literal|511
expr_stmt|;
break|break;
case|case
name|R_MMU
case|:
name|needed_mask_value
operator|=
literal|0x3ff
expr_stmt|;
break|break;
case|case
name|R_OPS
case|:
case|case
name|R_CPS
case|:
case|case
name|R_RBP
case|:
case|case
name|R_FPS
case|:
name|needed_mask_value
operator|=
literal|0xffff
expr_stmt|;
break|break;
case|case
name|R_VAB
case|:
name|needed_mask_value
operator|=
literal|0xffff0000
expr_stmt|;
break|break;
case|case
name|R_Q
case|:
case|case
name|R_CFG
case|:
case|case
name|R_CHA
case|:
case|case
name|R_CHD
case|:
case|case
name|R_CHC
case|:
case|case
name|R_TMC
case|:
case|case
name|R_TMR
case|:
case|case
name|R_PC0
case|:
case|case
name|R_PC1
case|:
case|case
name|R_PC2
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|INTVAL
argument_list|(
name|mask
argument_list|)
operator|&
operator|~
name|needed_mask_value
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if this label is that of the return point, but there is    a non-null epilogue.  */
end_comment

begin_function
name|int
name|epilogue_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|next_active_insn
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|a29k_first_epilogue_insn
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the register class of a scratch register needed to copy IN into    or out of a register in CLASS in MODE.  If it can be done directly,    NO_REGS is returned.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
condition|)
block|{
name|regno
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* A pseudo is the same as memory.  */
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|code
operator|=
name|MEM
expr_stmt|;
block|}
comment|/* If we are transferring between memory and a multi-word mode, we need      CR.  */
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
name|CR_REGS
return|;
comment|/* If between memory and a mode smaller than a word without DW being      enabled, we need BP.  */
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
operator|!
name|TARGET_DW_ENABLE
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
return|return
name|BP_REGS
return|;
comment|/* Otherwise, we can place anything into GENERAL_REGS and can put      GENERAL_REGS into anything.  */
if|if
condition|(
name|class
operator|==
name|GENERAL_REGS
operator|||
operator|(
name|regno
operator|!=
operator|-
literal|1
operator|&&
name|regno
operator|<
name|R_BP
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* We can place 16-bit constants into a special register.  */
if|if
condition|(
name|code
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|16
operator|||
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|in
argument_list|)
operator|<=
literal|65535
operator|)
operator|&&
operator|(
name|class
operator|==
name|BP_REGS
operator|||
name|class
operator|==
name|Q_REGS
operator|||
name|class
operator|==
name|SPECIAL_REGS
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Otherwise, we need GENERAL_REGS.  */
return|return
name|GENERAL_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* START is the zero-based incoming argument register index used (0 is 160,    i.e., the first incoming argument register) and COUNT is the number used.     Mark the corresponding incoming registers as neither fixed nor call used.    For each register used for incoming arguments, we have one less local    register that can be used.  So also mark some high-numbered registers as    fixed.     Return the first register number to use for the argument.  */
end_comment

begin_function
name|int
name|incoming_reg
parameter_list|(
name|start
parameter_list|,
name|count
parameter_list|)
name|int
name|start
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_NO_REUSE_ARGS
condition|)
comment|/* Mark all the used registers as not fixed and saved over calls.  */
for|for
control|(
name|i
operator|=
name|R_AR
argument_list|(
name|start
argument_list|)
init|;
name|i
operator|<
name|R_AR
argument_list|(
literal|16
argument_list|)
operator|&&
name|i
operator|<
name|R_AR
argument_list|(
name|start
operator|+
name|count
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Shorten the maximum size of the frame.  */
for|for
control|(
name|i
operator|=
name|R_AR
argument_list|(
literal|0
argument_list|)
operator|-
name|start
operator|-
name|count
init|;
name|i
operator|<
name|R_AR
argument_list|(
literal|0
argument_list|)
operator|-
name|start
condition|;
name|i
operator|++
control|)
block|{
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|R_AR
argument_list|(
name|start
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These routines are used in finding insns to fill delay slots in the    epilogue.  */
end_comment

begin_comment
comment|/* Return 1 if the current function will adjust the register stack.  */
end_comment

begin_function
name|int
name|needs_regstack_p
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
return|return
literal|1
return|;
comment|/* If any local register is used, we need to adjust the regstack.  */
for|for
control|(
name|i
operator|=
name|R_LR
argument_list|(
literal|127
argument_list|)
init|;
name|i
operator|>=
name|R_LR
argument_list|(
literal|0
argument_list|)
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
comment|/* We need a register stack if we make any calls.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, we don't.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X uses a local register.  */
end_comment

begin_function
name|int
name|uses_local_reg_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|R_LR
argument_list|(
literal|0
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|R_FP
return|;
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|uses_local_reg_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|uses_local_reg_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if this function is known to have a null epilogue.  */
end_comment

begin_function
name|int
name|null_epilogue
parameter_list|()
block|{
return|return
operator|(
name|reload_completed
operator|&&
operator|!
name|needs_regstack_p
argument_list|()
operator|&&
name|get_frame_size
argument_list|()
operator|==
literal|0
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out the assembler form of an operand.  Recognize the following    special options:  	%N means write the low-order 8 bits of the negative of the constant 	%Q means write a QImode operand (truncate constants to 8 bits) 	%M means write the low-order 16 bits of the constant 	%m means write the low-order 16 bits shifted left 16 bits 	%C means write the low-order 8 bits of the complement of the constant 	%b means write `f' is this is a reversed condition, `t' otherwise 	%B means write `t' is this is a reversed condition, `f' otherwise 	%J means write the 29k opcode part for a comparison operation 	%e means write the label with an extra `X' is this is the epilogue 	               otherwise the normal label name 	%E means write nothing if this insn has a delay slot, 		       a nop unless this is the epilogue label, in which case 		       write the first epilogue insn 	%F means write just the normal operand if the insn has a delay slot; 		       otherwise, this is a recursive call so output the 		       symbol + 4 and write the first prologue insn in the 		       delay slot. 	%L means write the register number plus one ("low order" register) 		       or the low-order part of a multi-word constant 	%O means write the register number plus two 	%P means write the register number plus three ("low order" of TImode) 	%S means write the number of words in the mode of the operand, 		       minus one (for CR)         %V means write the number of elements in a PARALLEL minus 1 	%# means write nothing if we have a delay slot, "\n\tnop" otherwise 	%* means write the register name for TPC.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* These macros test for integers and extract the low-order bits.  */
define|#
directive|define
name|INT_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)	\&& GET_MODE (X) == VOIDmode)
define|#
directive|define
name|INT_LOWPART
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'Q'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%Q value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'C'
case|:
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%C value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
operator|~
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'N'
case|:
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
operator|-
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'b'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
comment|/* It so happens that the RTX names for the conditions are the same as 	 the 29k's insns except for "ne", which requires "neq".  */
name|fprintf
argument_list|(
name|file
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"q"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'e'
case|:
if|if
condition|(
name|optimize
operator|&&
name|flag_delayed_branch
operator|&&
name|a29k_last_prologue_insn
operator|==
literal|0
operator|&&
name|epilogue_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* We need to output the label number of the last label in the 	     function, which is not necessarily X since there might be 	     a USE insn in between.  First go forward to the last insn, then 	     back up to a label.  */
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|x
operator|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LX"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_label
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'E'
case|:
if|if
condition|(
name|dbr_sequence_length
argument_list|()
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|a29k_last_prologue_insn
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t%s"
argument_list|,
name|a29k_last_prologue_insn
argument_list|)
expr_stmt|;
name|a29k_last_prologue_insn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|flag_delayed_branch
operator|&&
name|epilogue_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t%s"
argument_list|,
name|a29k_first_epilogue_insn
argument_list|)
expr_stmt|;
name|a29k_first_epilogue_insn_used
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_function_name
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+4\n\t%s,%d"
argument_list|,
name|a29k_regstack_size
operator|>=
literal|64
condition|?
literal|"const gr121"
else|:
literal|"sub gr1,gr1"
argument_list|,
name|a29k_regstack_size
operator|*
literal|4
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'L'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|union
name|real_extract
name|u
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$double1(%.20e)"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%L value"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%O value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'V'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%V value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'#'
case|:
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|a29k_last_prologue_insn
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t%s"
argument_list|,
name|a29k_last_prologue_insn
argument_list|)
expr_stmt|;
name|a29k_last_prologue_insn
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\tnop"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'*'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|R_TPC
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|union
name|real_extract
name|u
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SFmode
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$float"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$double%d"
argument_list|,
name|SUBREG_WORD
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%.20e)"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|union
name|real_extract
name|u
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$%s(%.20e)"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|?
literal|"float"
else|:
literal|"double0"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines to output function prolog and epilog code. */
end_comment

begin_comment
comment|/* Output function prolog code to file FILE.  Memory stack size is SIZE.     Also sets register names for incoming arguments and frame pointer.  */
end_comment

begin_function
name|void
name|output_prolog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|makes_calls
init|=
literal|0
decl_stmt|;
name|int
name|arg_count
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|tag_word
decl_stmt|;
comment|/* See if we make any calls.  We need to set lr1 if so.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|)
block|{
name|makes_calls
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Find the highest local register used.  */
for|for
control|(
name|i
operator|=
name|R_LR
argument_list|(
literal|127
argument_list|)
init|;
name|i
operator|>=
name|R_LR
argument_list|(
literal|0
argument_list|)
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
break|break;
name|a29k_regstack_size
operator|=
name|i
operator|-
operator|(
name|R_LR
argument_list|(
literal|0
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* If calling routines, ensure we count lr0& lr1.  */
if|if
condition|(
name|makes_calls
operator|&&
name|a29k_regstack_size
operator|<
literal|2
condition|)
name|a29k_regstack_size
operator|=
literal|2
expr_stmt|;
comment|/* Count frame pointer and align to 8 byte boundary (even number of      registers).  */
name|a29k_regstack_size
operator|+=
name|frame_pointer_needed
expr_stmt|;
if|if
condition|(
name|a29k_regstack_size
operator|&
literal|1
condition|)
name|a29k_regstack_size
operator|++
expr_stmt|;
comment|/* See how many incoming arguments we have in registers.  */
for|for
control|(
name|i
operator|=
name|R_AR
argument_list|(
literal|0
argument_list|)
init|;
name|i
operator|<
name|R_AR
argument_list|(
literal|16
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|arg_count
operator|++
expr_stmt|;
comment|/* The argument count includes the caller's lr0 and lr1.  */
name|arg_count
operator|+=
literal|2
expr_stmt|;
comment|/* Set the names and numbers of the frame pointer and incoming argument      registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|a29k_debug_reg_map
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
name|reg_names
index|[
name|R_LR
argument_list|(
name|a29k_regstack_size
operator|-
literal|1
argument_list|)
index|]
expr_stmt|;
name|a29k_debug_reg_map
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
name|R_LR
argument_list|(
name|a29k_regstack_size
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|reg_names
index|[
name|R_AR
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|reg_names
index|[
name|R_LR
argument_list|(
name|a29k_regstack_size
operator|+
name|i
operator|+
literal|2
argument_list|)
index|]
expr_stmt|;
name|a29k_debug_reg_map
index|[
name|R_AR
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|R_LR
argument_list|(
name|a29k_regstack_size
operator|+
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Compute memory stack size.  Add in number of bytes that the we should      push and pretend the caller did and the size of outgoing arguments.      Then round to a doubleword boundary.  */
name|size
operator|+=
operator|(
name|current_function_pretend_args_size
operator|+
name|current_function_outgoing_args_size
operator|)
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* Write header words.  See if one or two word form.  */
name|tag_word
operator|=
operator|(
name|frame_pointer_needed
condition|?
literal|0x400000
else|:
literal|0
operator|)
operator|+
operator|(
name|arg_count
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|/
literal|8
operator|>
literal|0xff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.word %d, 0x%0x\n"
argument_list|,
operator|(
name|size
operator|/
literal|8
operator|)
operator|<<
literal|2
argument_list|,
literal|0x800000
operator|+
name|tag_word
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.word 0x%0x\n"
argument_list|,
name|tag_word
operator|+
operator|(
operator|(
name|size
operator|/
literal|8
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
comment|/* Define the function name.  */
name|assemble_name
argument_list|(
name|file
argument_list|,
name|a29k_function_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
comment|/* Push the register stack by the proper amount.  There are two possible      ways to do this.  */
if|if
condition|(
name|a29k_regstack_size
operator|>=
literal|256
operator|/
literal|4
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tconst %s,%d\n\tsub gr1,gr1,%s\n"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|a29k_regstack_size
operator|*
literal|4
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a29k_regstack_size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub gr1,gr1,%d\n"
argument_list|,
name|a29k_regstack_size
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Test that the registers are available.  */
if|if
condition|(
name|a29k_regstack_size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tasgeu V_%sSPILL,gr1,%s\n"
argument_list|,
name|TARGET_KERNEL_REGISTERS
condition|?
literal|"K"
else|:
literal|""
argument_list|,
name|reg_names
index|[
name|R_RAB
index|]
argument_list|)
expr_stmt|;
comment|/* Set up frame pointer, if one is needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsll %s,%s,0\n"
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|)
expr_stmt|;
comment|/* Make room for any frame space.  There are three ways to do this.  */
if|if
condition|(
name|size
operator|>=
literal|256
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tconst %s,%d\n"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
literal|65536
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tconsth %s,%d\n"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_STACK_CHECK
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall %s,__msp_check\n"
argument_list|,
name|reg_names
index|[
name|R_TPC
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%s,%s\n"
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|TARGET_STACK_CHECK
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall %s,__msp_check\n"
argument_list|,
name|reg_names
index|[
name|R_TPC
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsub %s,%s,%d\n"
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* If this routine will make calls, set lr1.  If we see an insn that      can use a delay slot before a call or jump, save this insn for that      slot (this condition is equivalent to seeing if we have an insn that      needs delay slots before an insn that has a filled delay slot).  */
name|a29k_last_prologue_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|makes_calls
condition|)
block|{
name|i
operator|=
operator|(
name|a29k_regstack_size
operator|+
name|arg_count
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|256
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tconst %s,%d\n\tadd lr1,gr1,%s\n"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|i
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|optimize
operator|&&
name|flag_delayed_branch
condition|)
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|)
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
name|a29k_last_prologue_insn
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|a29k_last_prologue_insn
argument_list|,
literal|"add lr1,gr1,%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|a29k_last_prologue_insn
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd lr1,gr1,%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Compute the first insn of the epilogue.  */
name|a29k_first_epilogue_insn_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
name|a29k_regstack_size
operator|==
literal|0
operator|&&
operator|!
name|frame_pointer_needed
condition|)
name|a29k_first_epilogue_insn
operator|=
literal|0
expr_stmt|;
else|else
name|a29k_first_epilogue_insn
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|sprintf
argument_list|(
name|a29k_first_epilogue_insn
argument_list|,
literal|"sll %s,%s,0"
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a29k_regstack_size
condition|)
block|{
if|if
condition|(
name|a29k_regstack_size
operator|>=
literal|256
operator|/
literal|4
condition|)
name|sprintf
argument_list|(
name|a29k_first_epilogue_insn
argument_list|,
literal|"const %s,%d"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|a29k_regstack_size
operator|*
literal|4
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|a29k_first_epilogue_insn
argument_list|,
literal|"add gr1,gr1,%d"
argument_list|,
name|a29k_regstack_size
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|size
operator|>=
literal|256
condition|)
name|sprintf
argument_list|(
name|a29k_first_epilogue_insn
argument_list|,
literal|"const %s,%d"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|a29k_first_epilogue_insn
argument_list|,
literal|"add %s,%s,%d"
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call this after writing what might be the first instruction of the    epilogue.  If that first insn was used in a delay slot, an intermediate    label is written.  */
end_comment

begin_function
specifier|static
name|void
name|check_epilogue_internal_label
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|a29k_first_epilogue_insn_used
condition|)
return|return;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LX"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|a29k_first_epilogue_insn_used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the epilog of the last procedure to file FILE.  SIZE is the memory    stack size.  The register stack size is in the variable    A29K_REGSTACK_SIZE.  */
end_comment

begin_function
name|void
name|output_epilog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|locals_unavailable
init|=
literal|0
decl_stmt|;
comment|/* True until after first insn 				   after gr1 update. */
comment|/* If we hit a BARRIER before a real insn or CODE_LABEL, we don't      need to do anything because we are never jumped to.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
return|return;
comment|/* If a frame pointer was needed we must restore the memory stack pointer      before adjusting the register stack.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsll %s,%s,0\n"
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|FRAME_POINTER_REGNUM
index|]
argument_list|)
expr_stmt|;
name|check_epilogue_internal_label
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the register stack.  There are two ways to do this.  */
if|if
condition|(
name|a29k_regstack_size
condition|)
block|{
if|if
condition|(
name|a29k_regstack_size
operator|>=
literal|256
operator|/
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tconst %s,%d\n"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|a29k_regstack_size
operator|*
literal|4
argument_list|)
expr_stmt|;
name|check_epilogue_internal_label
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd gr1,gr1,%s\n"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd gr1,gr1,%d\n"
argument_list|,
name|a29k_regstack_size
operator|*
literal|4
argument_list|)
expr_stmt|;
name|check_epilogue_internal_label
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|locals_unavailable
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Restore the memory stack pointer if there is no frame pointer.      Adjust the size to include any pretend arguments and pushed      arguments and round to doubleword boundary.  */
name|size
operator|+=
operator|(
name|current_function_pretend_args_size
operator|+
name|current_function_outgoing_args_size
operator|)
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|size
operator|&&
operator|!
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|size
operator|>=
literal|256
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tconst %s,%d\n"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|check_epilogue_internal_label
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|locals_unavailable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>=
literal|65536
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tconsth %s,%d\n"
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%s\n"
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|R_TAV
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tadd %s,%s,%d\n"
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|reg_names
index|[
name|R_MSP
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|check_epilogue_internal_label
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|locals_unavailable
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|locals_unavailable
condition|)
block|{
comment|/* If we have an insn for this delay slot, write it.  */
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmpi lr0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a29k_regstack_size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tasleu V_%sFILL,lr1,%s\n"
argument_list|,
name|TARGET_KERNEL_REGISTERS
condition|?
literal|"K"
else|:
literal|""
argument_list|,
name|reg_names
index|[
name|R_RFB
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tnop\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

