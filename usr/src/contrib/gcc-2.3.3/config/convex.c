begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Convex.    Copyright (C) 1989,1991 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Boolean to keep track of whether the current section is .text or not.    Used by .align handler in convex.h. */
end_comment

begin_decl_stmt
name|int
name|current_section_is_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set_cmp saves the operands of a "cmp" insn, along with the type character  * to be used in the compare instruction.  *  * gen_cmp finds out what comparison is to be performed and outputs the  * necessary instructions, e.g.  *    "eq.w a1,a2\;jbra.t L5"  * for (cmpsi a1 a2) (beq L5)  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|xop0
decl_stmt|,
name|xop1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|typech
decl_stmt|,
name|regch
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|set_cmp
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|typechr
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|char
name|typechr
decl_stmt|;
block|{
name|xop0
operator|=
name|op0
expr_stmt|;
name|xop1
operator|=
name|op1
expr_stmt|;
name|typech
operator|=
name|typechr
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|regch
operator|=
name|A_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|?
literal|'a'
else|:
literal|'s'
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
name|regch
operator|=
name|A_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|?
literal|'a'
else|:
literal|'s'
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|gen_cmp
parameter_list|(
name|label
parameter_list|,
name|cmpop
parameter_list|,
name|tf
parameter_list|)
name|rtx
name|label
decl_stmt|;
name|char
modifier|*
name|cmpop
decl_stmt|;
name|char
name|tf
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|char
name|revop
index|[
literal|4
index|]
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
name|ops
index|[
literal|2
index|]
operator|=
name|label
expr_stmt|;
comment|/* Constant must be first; swap operands if necessary.      If lt, le, ltu, leu are swapped, change to le, lt, leu, ltu      and reverse the sense of the jump. */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop1
argument_list|)
condition|)
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|xop1
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|xop0
expr_stmt|;
if|if
condition|(
name|cmpop
index|[
literal|0
index|]
operator|==
literal|'l'
condition|)
block|{
name|bcopy
argument_list|(
name|cmpop
argument_list|,
name|revop
argument_list|,
sizeof|sizeof
name|revop
argument_list|)
expr_stmt|;
name|revop
index|[
literal|1
index|]
operator|^=
literal|'e'
operator|^
literal|'t'
expr_stmt|;
name|tf
operator|^=
literal|'t'
operator|^
literal|'f'
expr_stmt|;
name|cmpop
operator|=
name|revop
expr_stmt|;
block|}
block|}
else|else
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|xop0
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|xop1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.%c %%0,%%1\n\tjbr%c.%c %%l2"
argument_list|,
name|cmpop
argument_list|,
name|typech
argument_list|,
name|regch
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to separate CONST_DOUBLEs into component parts. */
end_comment

begin_function
name|int
name|const_double_high_int
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
return|;
else|else
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|const_double_low_int
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
return|;
else|else
return|return
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of args in the call insn X. */
end_comment

begin_function
specifier|static
name|int
name|call_num_args
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|INTVAL
argument_list|(
name|x
operator|->
name|fld
index|[
literal|1
index|]
operator|.
name|rtx
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
return|return
name|call_num_args
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan forward from a call to decide whether we need to reload AP    from 12(FP) after it.  We need to if there can be a reference to    arg_pointer_rtx before the next call, which will clobber AP.    Look forward in the instruction list until encountering a call    (don't need the load), or a reference to AP (do need it), or    a jump (don't know, do the load).  */
end_comment

begin_function
specifier|static
name|int
name|ap_reload_needed
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|JUMP_INSN
case|:
comment|/* Basic block ends.  If return, no AP needed, else assume it is. */
return|return
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|RETURN
return|;
case|case
name|CALL_INSN
case|:
comment|/* A subsequent call.  AP isn't needed unless the call itself 	     requires it.  But zero-arg calls don't clobber AP, so 	     don't terminate the search in that case. */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TARGET_ARGCOUNT
operator|&&
name|call_num_args
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
literal|0
return|;
case|case
name|BARRIER
case|:
comment|/* Barrier, don't need AP. */
return|return
literal|0
return|;
case|case
name|INSN
case|:
comment|/* Other insn may need AP; if not, keep looking. */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output the insns needed to do a call. */
end_comment

begin_function
name|char
modifier|*
name|output_call
parameter_list|(
name|insn
parameter_list|,
name|address
parameter_list|,
name|argcount
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|address
decl_stmt|,
name|argcount
decl_stmt|;
block|{
name|int
name|set_ap
init|=
name|TARGET_ARGCOUNT
operator|||
name|argcount
operator|!=
name|const0_rtx
decl_stmt|;
comment|/* If AP is used by the call address, evaluate the address into a temp. */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|address
argument_list|)
condition|)
if|if
condition|(
name|set_ap
condition|)
block|{
name|address
operator|=
name|XEXP
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ld.w %0,a1"
argument_list|,
operator|&
name|address
argument_list|)
expr_stmt|;
name|address
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|QImode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|9
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If there are args, point AP to them. */
if|if
condition|(
name|set_ap
condition|)
name|output_asm_insn
argument_list|(
literal|"mov sp,ap"
argument_list|)
expr_stmt|;
comment|/* If we are passing an arg count, convert it to words and push it. */
if|if
condition|(
name|TARGET_ARGCOUNT
condition|)
block|{
name|argcount
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|argcount
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pshea %a0"
argument_list|,
operator|&
name|argcount
argument_list|)
expr_stmt|;
block|}
comment|/* The call. */
name|output_asm_insn
argument_list|(
literal|"calls %0"
argument_list|,
operator|&
name|address
argument_list|)
expr_stmt|;
comment|/* If we clobbered AP, reload it if it is live. */
if|if
condition|(
name|set_ap
condition|)
if|if
condition|(
name|ap_reload_needed
argument_list|(
name|insn
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"ld.w 12(fp),ap"
argument_list|)
expr_stmt|;
comment|/* If we pushed an arg count, pop it and the args. */
if|if
condition|(
name|TARGET_ARGCOUNT
condition|)
block|{
name|argcount
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|argcount
argument_list|)
operator|*
literal|4
operator|+
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"add.w %0,sp"
argument_list|,
operator|&
name|argcount
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

end_unit

