begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Motorola 88000.    Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@mcc.com)    Enhanced by Michael Meissner (meissner@osf.org)    Currently supported by Tom Wood (wood@dg-rtp.dg.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|flag_traditional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|out_sccs_id
index|[]
init|=
literal|"@(#)m88k.c	2.2.14.4 10/29/92 05:37:46"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tm_sccs_id
index|[]
init|=
name|TM_SCCS_ID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|m88k_pound_sign
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Either # for SVR4 or empty for SVR3 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|m88k_short_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|m88k_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|m88k_volatile_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m88k_gp_threshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m88k_prologue_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ln directives can now be emitted */
end_comment

begin_decl_stmt
name|int
name|m88k_function_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter unique to each function */
end_comment

begin_decl_stmt
name|int
name|m88k_fp_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset of frame pointer if used */
end_comment

begin_decl_stmt
name|int
name|m88k_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of allocated stack (including frame) */
end_comment

begin_decl_stmt
name|int
name|m88k_case_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m88k_version_0300
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Version is at least 03.00 */
end_comment

begin_decl_stmt
name|rtx
name|m88k_compare_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cmp output pseudo register */
end_comment

begin_decl_stmt
name|rtx
name|m88k_compare_op0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cmpsi operand 0 */
end_comment

begin_decl_stmt
name|rtx
name|m88k_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cmpsi operand 1 */
end_comment

begin_decl_stmt
name|enum
name|attr_cpu
name|m88k_cpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target cpu */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Determine what instructions are needed to manufacture the integer VALUE    in the given MODE.  */
end_comment

begin_function
name|enum
name|m88k_instruction
name|classify_integer
parameter_list|(
name|mode
parameter_list|,
name|value
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|int
name|value
decl_stmt|;
block|{
specifier|register
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
name|m88k_zero
return|;
elseif|else
if|if
condition|(
name|SMALL_INTVAL
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|m88k_or
return|;
elseif|else
if|if
condition|(
name|SMALL_INTVAL
argument_list|(
operator|-
name|value
argument_list|)
condition|)
return|return
name|m88k_subu
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|HImode
condition|)
return|return
name|m88k_or_lo16
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|QImode
condition|)
return|return
name|m88k_or_lo8
return|;
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
name|m88k_oru_hi16
return|;
elseif|else
if|if
condition|(
name|integer_ok_for_set
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|m88k_set
return|;
else|else
return|return
name|m88k_oru_or
return|;
block|}
end_function

begin_comment
comment|/* Return the bit number in a compare word corresponding to CONDITION.  */
end_comment

begin_function
name|int
name|condition_value
parameter_list|(
name|condition
parameter_list|)
name|rtx
name|condition
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
literal|2
return|;
case|case
name|NE
case|:
return|return
literal|3
return|;
case|case
name|GT
case|:
return|return
literal|4
return|;
case|case
name|LE
case|:
return|return
literal|5
return|;
case|case
name|LT
case|:
return|return
literal|6
return|;
case|case
name|GE
case|:
return|return
literal|7
return|;
case|case
name|GTU
case|:
return|return
literal|8
return|;
case|case
name|LEU
case|:
return|return
literal|9
return|;
case|case
name|LTU
case|:
return|return
literal|10
return|;
case|case
name|GEU
case|:
return|return
literal|11
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|integer_ok_for_set
parameter_list|(
name|value
parameter_list|)
specifier|register
name|unsigned
name|value
decl_stmt|;
block|{
comment|/* All the "one" bits must be contiguous.  If so, MASK + 1 will be      a power of two or zero.  */
specifier|register
name|unsigned
name|mask
init|=
operator|(
name|value
operator||
operator|(
name|value
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
return|return
operator|(
name|value
operator|&&
name|POWER_OF_2_or_0
argument_list|(
name|mask
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_load_const_int
parameter_list|(
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|patterns
index|[]
init|=
block|{
literal|"or %0,%#r0,0"
block|,
literal|"or %0,%#r0,%1"
block|,
literal|"subu %0,%#r0,%n1"
block|,
literal|"or %0,%#r0,%h1"
block|,
literal|"or %0,%#r0,%q1"
block|,
literal|"set %0,%#r0,%s1"
block|,
literal|"or.u %0,%#r0,%X1"
block|,
literal|"or.u %0,%#r0,%X1\n\tor %0,%0,%x1"
block|,     }
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|patterns
index|[
name|classify_integer
argument_list|(
name|mode
argument_list|,
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* These next two routines assume that floating point numbers are represented    in a manner which is consistent between host and target machines.  */
end_comment

begin_function
name|char
modifier|*
name|output_load_const_float
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* These can return 0 under some circumstances when cross-compiling.  */
name|operands
index|[
literal|0
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
return|return
name|output_load_const_int
argument_list|(
name|SImode
argument_list|,
name|operands
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_load_const_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
comment|/* These can return zero on some cross-compilers, but there's nothing      we can do about it.  */
name|latehalf
index|[
literal|0
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|output_load_const_int
argument_list|(
name|SImode
argument_list|,
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|latehalf
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
return|return
name|output_load_const_int
argument_list|(
name|SImode
argument_list|,
name|operands
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_load_const_dimode
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|latehalf
index|[
literal|0
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|output_load_const_int
argument_list|(
name|SImode
argument_list|,
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|latehalf
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
return|return
name|output_load_const_int
argument_list|(
name|SImode
argument_list|,
name|operands
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].     Return 1 if we have written out everything that needs to be done to    do the move.  Otherwise, return 0 and the caller will emit the move    normally.     SCRATCH if non zero can be used as a scratch register for the move    operation.  It is provided by a SECONDARY_RELOAD_* macro if needed.  */
end_comment

begin_function
name|int
name|emit_move_sequence
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|,
name|scratch
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|scratch
decl_stmt|;
block|{
specifier|register
name|rtx
name|operand0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|operand1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
comment|/* Handle most common case first: storing into a register.  */
if|if
condition|(
name|register_operand
argument_list|(
name|operand0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|operand1
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|HIGH
comment|/* Only `general_operands' can come here, so MEM is ok.  */
operator|||
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Run this case quickly.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand0
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|operand1
operator|==
name|const0_rtx
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
condition|)
block|{
comment|/* Run this case quickly.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|validize_mem
argument_list|(
name|operand0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operand1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Simplify the source if we need to.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|HIGH
operator|&&
name|immediate_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
block|{
name|rtx
name|temp
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
condition|?
name|operand0
else|:
literal|0
operator|)
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_address
argument_list|(
name|flag_pic
operator|&&
name|symbolic_address_p
argument_list|(
name|operand1
argument_list|)
argument_list|,
name|operand1
argument_list|,
name|temp
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SImode
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now have insn-emit do whatever it normally does.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a legitimate reference for ORIG (either an address or a MEM)    using the register REG.  If PIC and the address is already    position-independent, use ORIG.  Newly generated position-independent    addresses go into a reg.  This is REG if non zero, otherwise we    allocate register(s) as necessary.  If this is called during reload,    and we need a second temp register, then we use SCRATCH, which is    provided via the SECONDARY_INPUT_RELOAD_CLASS mechanism.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|legitimize_address
parameter_list|(
name|pic
parameter_list|,
name|orig
parameter_list|,
name|reg
parameter_list|,
name|scratch
parameter_list|)
name|int
name|pic
decl_stmt|;
name|rtx
name|orig
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|scratch
decl_stmt|;
block|{
name|rtx
name|addr
init|=
operator|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
condition|?
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
else|:
name|orig
operator|)
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|temp
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|pic
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
comment|/* If not during reload, allocate another temp reg here for 		 loading in the address, so that these instructions can be 		 optimized properly.  */
name|temp
operator|=
operator|(
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
condition|?
name|reg
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|SImode
argument_list|,
name|temp
argument_list|,
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|temp
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* Put a REG_EQUAL note on this insn, so that it can be optimized 	     by loop.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|orig
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|legitimize_address
argument_list|(
literal|1
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|legitimize_address
argument_list|(
literal|1
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
condition|)
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* We can't create any new registers during reload, so use the 		 SCRATCH reg provided by the reload_insi pattern.  */
elseif|else
if|if
condition|(
name|scratch
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|scratch
expr_stmt|;
block|}
else|else
comment|/* If we reach here, then the SECONDARY_INPUT_RELOAD_CLASS 		   macro needs to be adjusted so that a scratch reg is provided 		   for this address.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|base
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Should we set special REG_NOTEs here?  */
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|SHORT_ADDRESS_P
argument_list|(
name|addr
argument_list|,
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_in_progress
operator|||
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|SImode
argument_list|,
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new
operator|!=
name|orig
operator|&&
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|new
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|orig
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support functions for code to emit a block move.  There are four methods    used to perform the block move:    + call memcpy    + call the looping library function, e.g. __movstrSI64n8    + call a non-looping library function, e.g. __movstrHI15x11    + produce an inline sequence of ld/st instructions     The parameters below describe the library functions produced by    movstr-m88k.sh.  */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_LOOP
value|64
end_define

begin_comment
comment|/* __movstrSI64n68 .. __movstrSI64n8 */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_QI
value|16
end_define

begin_comment
comment|/* __movstrQI16x16 .. __movstrQI16x2 */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_HI
value|48
end_define

begin_comment
comment|/* __movstrHI48x48 .. __movstrHI48x4 */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_SI
value|96
end_define

begin_comment
comment|/* __movstrSI96x96 .. __movstrSI96x8 */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_DI
value|96
end_define

begin_comment
comment|/* __movstrDI96x96 .. __movstrDI96x16 */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_ODD_HI
value|16
end_define

begin_comment
comment|/* __movstrHI15x15 .. __movstrHI15x5 */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_ODD_SI
value|48
end_define

begin_comment
comment|/* __movstrSI47x47 .. __movstrSI47x11, 			      __movstrSI46x46 .. __movstrSI46x10, 			      __movstrSI45x45 .. __movstrSI45x9 */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_ODD_DI
value|48
end_define

begin_comment
comment|/* __movstrDI47x47 .. __movstrDI47x23, 			      __movstrDI46x46 .. __movstrDI46x22, 			      __movstrDI45x45 .. __movstrDI45x21, 			      __movstrDI44x44 .. __movstrDI44x20, 			      __movstrDI43x43 .. __movstrDI43x19, 			      __movstrDI42x42 .. __movstrDI42x18, 			      __movstrDI41x41 .. __movstrDI41x17 */
end_comment

begin_comment
comment|/* Limits for using the non-looping movstr functions.  For the m88100    processor, we assume the source and destination are word aligned.    The QImode and HImode limits are the break even points where memcpy    does just as well and beyond which memcpy does better.  For the    m88110, we tend to assume double word alignment, but also analyze    the word aligned cases.  The analysis is complicated because memcpy    may use the cache control instructions for better performance.  */
end_comment

begin_define
define|#
directive|define
name|MOVSTR_QI_LIMIT_88100
value|13
end_define

begin_define
define|#
directive|define
name|MOVSTR_HI_LIMIT_88100
value|38
end_define

begin_define
define|#
directive|define
name|MOVSTR_SI_LIMIT_88100
value|MOVSTR_SI
end_define

begin_define
define|#
directive|define
name|MOVSTR_DI_LIMIT_88100
value|MOVSTR_SI
end_define

begin_define
define|#
directive|define
name|MOVSTR_QI_LIMIT_88000
value|16
end_define

begin_define
define|#
directive|define
name|MOVSTR_HI_LIMIT_88000
value|38
end_define

begin_define
define|#
directive|define
name|MOVSTR_SI_LIMIT_88000
value|72
end_define

begin_define
define|#
directive|define
name|MOVSTR_DI_LIMIT_88000
value|72
end_define

begin_define
define|#
directive|define
name|MOVSTR_QI_LIMIT_88110
value|16
end_define

begin_define
define|#
directive|define
name|MOVSTR_HI_LIMIT_88110
value|38
end_define

begin_define
define|#
directive|define
name|MOVSTR_SI_LIMIT_88110
value|72
end_define

begin_define
define|#
directive|define
name|MOVSTR_DI_LIMIT_88110
value|72
end_define

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|mode_from_align
index|[]
init|=
block|{
name|VOIDmode
block|,
name|QImode
block|,
name|HImode
block|,
name|VOIDmode
block|,
name|SImode
block|,
name|VOIDmode
block|,
name|VOIDmode
block|,
name|VOIDmode
block|,
name|DImode
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_from_align
index|[]
init|=
block|{
literal|0
block|,
name|MOVSTR_QI
block|,
name|MOVSTR_HI
block|,
literal|0
block|,
name|MOVSTR_SI
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|MOVSTR_DI
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|all_from_align
index|[]
init|=
block|{
literal|0
block|,
name|MOVSTR_QI
block|,
name|MOVSTR_ODD_HI
block|,
literal|0
block|,
name|MOVSTR_ODD_SI
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|MOVSTR_ODD_DI
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|best_from_align
index|[
literal|3
index|]
index|[
literal|9
index|]
init|=
block|{
literal|0
block|,
name|MOVSTR_QI_LIMIT_88100
block|,
name|MOVSTR_HI_LIMIT_88100
block|,
literal|0
block|,
name|MOVSTR_SI_LIMIT_88100
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|MOVSTR_DI_LIMIT_88100
block|,
literal|0
block|,
name|MOVSTR_QI_LIMIT_88110
block|,
name|MOVSTR_HI_LIMIT_88110
block|,
literal|0
block|,
name|MOVSTR_SI_LIMIT_88110
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|MOVSTR_DI_LIMIT_88110
block|,
literal|0
block|,
name|MOVSTR_QI_LIMIT_88000
block|,
name|MOVSTR_HI_LIMIT_88000
block|,
literal|0
block|,
name|MOVSTR_SI_LIMIT_88000
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|MOVSTR_DI_LIMIT_88000
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|block_move_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|block_move_no_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|block_move_sequence
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Emit code to perform a block move.  Choose the best method.     OPERANDS[0] is the destination.    OPERANDS[1] is the source.    OPERANDS[2] is the size.    OPERANDS[3] is the alignment safe to use.  */
end_comment

begin_function
name|void
name|expand_block_move
parameter_list|(
name|dest_mem
parameter_list|,
name|src_mem
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|dest_mem
decl_stmt|;
name|rtx
name|src_mem
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|align
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|int
name|constp
init|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|)
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|constp
condition|?
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|target
init|=
operator|(
name|int
operator|)
name|m88k_cpu
decl_stmt|;
name|assert
argument_list|(
name|CPU_M88100
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CPU_M88110
operator|==
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CPU_M88000
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|&&
name|bytes
operator|<=
literal|0
condition|)
return|return;
comment|/* Determine machine mode to do move with.  */
if|if
condition|(
name|align
operator|>
literal|4
operator|&&
operator|!
name|TARGET_88110
condition|)
name|align
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|align
operator|<=
literal|0
operator|||
name|align
operator|==
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* block move invalid alignment.  */
if|if
condition|(
name|constp
operator|&&
name|bytes
operator|<=
literal|3
operator|*
name|align
condition|)
name|block_move_sequence
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dest_mem
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|src_mem
argument_list|,
name|bytes
argument_list|,
name|align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constp
operator|&&
name|bytes
operator|<=
name|best_from_align
index|[
name|target
index|]
index|[
name|align
index|]
condition|)
name|block_move_no_loop
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dest_mem
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|src_mem
argument_list|,
name|bytes
argument_list|,
name|align
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|constp
operator|&&
name|align
operator|==
literal|4
operator|&&
name|TARGET_88100
condition|)
name|block_move_loop
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dest_mem
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|src_mem
argument_list|,
name|bytes
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|TARGET_MEM_FUNCTIONS
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"memcpy"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|Pmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|Pmode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"bcopy"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|3
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|Pmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|Pmode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Emit code to perform a block move by calling a looping movstr library    function.  SIZE and ALIGN are known constants.  DEST and SRC are    registers.  */
end_comment

begin_function
specifier|static
name|void
name|block_move_loop
parameter_list|(
name|dest
parameter_list|,
name|dest_mem
parameter_list|,
name|src
parameter_list|,
name|src_mem
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|dest_mem
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|src_mem
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|units
decl_stmt|;
name|int
name|remainder
decl_stmt|;
name|rtx
name|offset_rtx
decl_stmt|;
name|rtx
name|value_rtx
decl_stmt|;
name|char
name|entry
index|[
literal|30
index|]
decl_stmt|;
name|tree
name|entry_name
decl_stmt|;
comment|/* Determine machine mode to do move with.  */
if|if
condition|(
name|align
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Determine the structure of the loop.  */
name|count
operator|=
name|size
operator|/
name|MOVSTR_LOOP
expr_stmt|;
name|units
operator|=
operator|(
name|size
operator|-
name|count
operator|*
name|MOVSTR_LOOP
operator|)
operator|/
name|align
expr_stmt|;
if|if
condition|(
name|units
operator|<
literal|2
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|units
operator|+=
name|MOVSTR_LOOP
operator|/
name|align
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|block_move_no_loop
argument_list|(
name|dest
argument_list|,
name|dest_mem
argument_list|,
name|src
argument_list|,
name|src_mem
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return;
block|}
name|remainder
operator|=
name|size
operator|-
name|count
operator|*
name|MOVSTR_LOOP
operator|-
name|units
operator|*
name|align
expr_stmt|;
name|mode
operator|=
name|mode_from_align
index|[
name|align
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|entry
argument_list|,
literal|"__movstr%s%dn%d"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|MOVSTR_LOOP
argument_list|,
name|units
operator|*
name|align
argument_list|)
expr_stmt|;
name|entry_name
operator|=
name|get_identifier
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|offset_rtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|MOVSTR_LOOP
operator|+
operator|(
literal|1
operator|-
name|units
operator|)
operator|*
name|align
argument_list|)
expr_stmt|;
name|value_rtx
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|3
argument_list|)
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|value_rtx
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|value_rtx
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|value_rtx
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_call_movstrsi_loop
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|entry_name
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|,
name|offset_rtx
argument_list|,
name|value_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|value_rtx
argument_list|)
argument_list|,
operator|(
operator|(
name|units
operator|&
literal|1
operator|)
condition|?
literal|4
else|:
literal|5
operator|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
name|block_move_sequence
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|2
argument_list|)
argument_list|,
name|dest_mem
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|3
argument_list|)
argument_list|,
name|src_mem
argument_list|,
name|remainder
argument_list|,
name|align
argument_list|,
name|MOVSTR_LOOP
operator|+
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to perform a block move by calling a non-looping library    function.  SIZE and ALIGN are known constants.  DEST and SRC are    registers.  OFFSET is the known starting point for the output pattern.  */
end_comment

begin_function
specifier|static
name|void
name|block_move_no_loop
parameter_list|(
name|dest
parameter_list|,
name|dest_mem
parameter_list|,
name|src
parameter_list|,
name|src_mem
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|dest_mem
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|src_mem
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|mode_from_align
index|[
name|align
index|]
decl_stmt|;
name|int
name|units
init|=
name|size
operator|/
name|align
decl_stmt|;
name|int
name|remainder
init|=
name|size
operator|-
name|units
operator|*
name|align
decl_stmt|;
name|int
name|most
decl_stmt|;
name|int
name|value_reg
decl_stmt|;
name|rtx
name|offset_rtx
decl_stmt|;
name|rtx
name|value_rtx
decl_stmt|;
name|char
name|entry
index|[
literal|30
index|]
decl_stmt|;
name|tree
name|entry_name
decl_stmt|;
if|if
condition|(
name|remainder
operator|&&
name|size
operator|<=
name|all_from_align
index|[
name|align
index|]
condition|)
block|{
name|most
operator|=
name|all_from_align
index|[
name|align
index|]
operator|-
operator|(
name|align
operator|-
name|remainder
operator|)
expr_stmt|;
name|remainder
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|most
operator|=
name|max_from_align
index|[
name|align
index|]
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|entry
argument_list|,
literal|"__movstr%s%dx%d"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|most
argument_list|,
name|size
operator|-
name|remainder
argument_list|)
expr_stmt|;
name|entry_name
operator|=
name|get_identifier
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|offset_rtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|most
operator|-
operator|(
name|size
operator|-
name|remainder
operator|)
argument_list|)
expr_stmt|;
name|value_rtx
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|3
argument_list|)
argument_list|,
name|offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|value_rtx
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|value_rtx
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|value_rtx
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|value_reg
operator|=
operator|(
operator|(
operator|(
operator|(
name|most
operator|-
operator|(
name|size
operator|-
name|remainder
operator|)
operator|)
operator|/
name|align
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
operator|(
name|align
operator|==
literal|8
condition|?
literal|6
else|:
literal|5
operator|)
else|:
literal|4
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_call_block_move
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|entry_name
argument_list|)
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|,
name|offset_rtx
argument_list|,
name|value_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|value_rtx
argument_list|)
argument_list|,
name|value_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
name|block_move_sequence
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|2
argument_list|)
argument_list|,
name|dest_mem
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
literal|3
argument_list|)
argument_list|,
name|src_mem
argument_list|,
name|remainder
argument_list|,
name|align
argument_list|,
name|most
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to perform a block move with an offset sequence of ld/st    instructions (..., ld 0, st 1, ld 1, st 0, ...).  SIZE and ALIGN are    known constants.  DEST and SRC are registers.  OFFSET is the known    starting point for the output pattern.  */
end_comment

begin_function
specifier|static
name|void
name|block_move_sequence
parameter_list|(
name|dest
parameter_list|,
name|dest_mem
parameter_list|,
name|src
parameter_list|,
name|src_mem
parameter_list|,
name|size
parameter_list|,
name|align
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|dest_mem
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|src_mem
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|rtx
name|temp
index|[
literal|2
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
index|[
literal|2
index|]
decl_stmt|;
name|int
name|amount
index|[
literal|2
index|]
decl_stmt|;
name|int
name|active
index|[
literal|2
index|]
decl_stmt|;
name|int
name|phase
init|=
literal|0
decl_stmt|;
name|int
name|next
decl_stmt|;
name|int
name|offset_ld
init|=
name|offset
decl_stmt|;
name|int
name|offset_st
init|=
name|offset
decl_stmt|;
name|active
index|[
literal|0
index|]
operator|=
name|active
index|[
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* Establish parameters for the first load and for the second load if      it is known to be the same mode as the first.  */
name|amount
index|[
literal|0
index|]
operator|=
name|amount
index|[
literal|1
index|]
operator|=
name|align
expr_stmt|;
name|mode
index|[
literal|0
index|]
operator|=
name|mode_from_align
index|[
name|align
index|]
expr_stmt|;
name|temp
index|[
literal|0
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
literal|2
operator|*
name|align
condition|)
block|{
name|mode
index|[
literal|1
index|]
operator|=
name|mode
index|[
literal|0
index|]
expr_stmt|;
name|temp
index|[
literal|1
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|rtx
name|srcp
decl_stmt|,
name|dstp
decl_stmt|;
name|next
operator|=
name|phase
expr_stmt|;
name|phase
operator|=
operator|!
name|phase
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|/* Change modes as the sequence tails off.  */
if|if
condition|(
name|size
operator|<
name|amount
index|[
name|next
index|]
condition|)
block|{
name|amount
index|[
name|next
index|]
operator|=
operator|(
name|size
operator|>=
literal|4
condition|?
literal|4
else|:
operator|(
name|size
operator|>=
literal|2
condition|?
literal|2
else|:
literal|1
operator|)
operator|)
expr_stmt|;
name|mode
index|[
name|next
index|]
operator|=
name|mode_from_align
index|[
name|amount
index|[
name|next
index|]
index|]
expr_stmt|;
name|temp
index|[
name|next
index|]
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
index|[
name|next
index|]
argument_list|)
expr_stmt|;
block|}
name|size
operator|-=
name|amount
index|[
name|next
index|]
expr_stmt|;
name|srcp
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
index|[
name|next
index|]
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|src
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|SImode
argument_list|,
name|offset_ld
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|srcp
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|srcp
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|srcp
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|src_mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
index|[
name|next
index|]
argument_list|,
name|srcp
argument_list|)
expr_stmt|;
name|offset_ld
operator|+=
name|amount
index|[
name|next
index|]
expr_stmt|;
name|active
index|[
name|next
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|active
index|[
name|phase
index|]
condition|)
block|{
name|active
index|[
name|phase
index|]
operator|=
name|FALSE
expr_stmt|;
name|dstp
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
index|[
name|phase
index|]
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|dest
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|SImode
argument_list|,
name|offset_st
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|dstp
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|dest_mem
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|dstp
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|dest_mem
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|dstp
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|dest_mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dstp
argument_list|,
name|temp
index|[
name|phase
index|]
argument_list|)
expr_stmt|;
name|offset_st
operator|+=
name|amount
index|[
name|phase
index|]
expr_stmt|;
block|}
block|}
do|while
condition|(
name|active
index|[
name|next
index|]
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit the code to do an AND operation.  */
end_comment

begin_function
name|char
modifier|*
name|output_and
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|unsigned
name|int
name|value
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
literal|"and %0,%1,%2"
return|;
name|value
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SMALL_INTVAL
argument_list|(
name|value
argument_list|)
condition|)
return|return
literal|"mask %0,%1,%2"
return|;
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xffff0000
condition|)
return|return
literal|"and %0,%1,%x2"
return|;
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0xffff
condition|)
return|return
literal|"and.u %0,%1,%X2"
return|;
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|"mask.u %0,%1,%X2"
return|;
elseif|else
if|if
condition|(
name|integer_ok_for_set
argument_list|(
operator|~
name|value
argument_list|)
condition|)
return|return
literal|"clr %0,%1,%S2"
return|;
else|else
return|return
literal|"and.u %0,%1,%X2\n\tand %0,%0,%x2"
return|;
block|}
end_function

begin_comment
comment|/* Emit the code to do an inclusive OR operation.  */
end_comment

begin_function
name|char
modifier|*
name|output_ior
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|unsigned
name|int
name|value
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
literal|"or %0,%1,%2"
return|;
name|value
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SMALL_INTVAL
argument_list|(
name|value
argument_list|)
condition|)
return|return
literal|"or %0,%1,%2"
return|;
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|"or.u %0,%1,%X2"
return|;
elseif|else
if|if
condition|(
name|integer_ok_for_set
argument_list|(
name|value
argument_list|)
condition|)
return|return
literal|"set %0,%1,%s2"
return|;
else|else
return|return
literal|"or.u %0,%1,%X2\n\tor %0,%0,%x2"
return|;
block|}
end_function

begin_comment
comment|/* Emit the instructions for doing an XOR.  */
end_comment

begin_function
name|char
modifier|*
name|output_xor
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|unsigned
name|int
name|value
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
literal|"xor %0,%1,%2"
return|;
name|value
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SMALL_INTVAL
argument_list|(
name|value
argument_list|)
condition|)
return|return
literal|"xor %0,%1,%2"
return|;
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
return|return
literal|"xor.u %0,%1,%X2"
return|;
else|else
return|return
literal|"xor.u %0,%1,%X2\n\txor %0,%0,%x2"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a call.  Normally this is just bsr or jsr, but this also deals with    accomplishing a branch after the call by incrementing r1.  This requires    that various assembler bugs be accommodated.  The 4.30 DG/UX assembler    requires that forward references not occur when computing the difference of    two labels.  The [version?] Motorola assembler computes a word difference.    No doubt there's more to come!     It would seem the same idea could be used to tail call, but in this case,    the epilogue will be non-null.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|sb_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|sb_high
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|sb_low
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|output_call
parameter_list|(
name|operands
parameter_list|,
name|addr
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|final_sequence
condition|)
block|{
name|rtx
name|jump
decl_stmt|;
name|rtx
name|seq_insn
decl_stmt|;
comment|/* This can be generalized, but there is currently no need.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The address of interior insns is not computed, so use the sequence.  */
name|seq_insn
operator|=
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|=
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|;
name|rtx
name|dest
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|delta
init|=
literal|4
operator|*
operator|(
name|insn_addresses
index|[
name|INSN_UID
argument_list|(
name|dest
argument_list|)
index|]
operator|-
name|insn_addresses
index|[
name|INSN_UID
argument_list|(
name|seq_insn
argument_list|)
index|]
operator|-
literal|2
operator|)
decl_stmt|;
if|#
directive|if
operator|(
name|MONITOR_GCC
operator|&
literal|0x2
operator|)
comment|/* How often do long branches happen?  */
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|delta
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
condition|)
name|warning
argument_list|(
literal|"Internal gcc monitor: short-branch(%x)"
argument_list|,
name|delta
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Delete the jump.  */
name|PUT_CODE
argument_list|(
name|jump
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|jump
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|jump
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If we loose, we must use the non-delay form.  This is unlikely 	     to ever happen.  If it becomes a problem, claim that a call 	     has two delay slots and only the second can be filled with 	     a jump.  */
ifdef|#
directive|ifdef
name|AS_BUG_IMMEDIATE_LABEL
comment|/* The assembler restricts immediate values.  */
if|if
condition|(
operator|!
name|ADD_INTVAL
argument_list|(
name|delta
operator|*
literal|2
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|ADD_INTVAL
argument_list|(
name|delta
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|dest
expr_stmt|;
return|return
operator|(
name|REG_P
argument_list|(
name|addr
argument_list|)
condition|?
literal|"jsr %0\n\tbr %l1"
else|:
operator|(
name|flag_pic
condition|?
literal|"bsr %0#plt\n\tbr %l1"
else|:
literal|"bsr %0\n\tbr %l1"
operator|)
operator|)
return|;
block|}
comment|/* Output the short branch form.  */
name|output_asm_insn
argument_list|(
operator|(
name|REG_P
argument_list|(
name|addr
argument_list|)
condition|?
literal|"jsr.n %0"
else|:
operator|(
name|flag_pic
condition|?
literal|"bsr.n %0#plt"
else|:
literal|"bsr.n %0"
operator|)
operator|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_GAS
name|last
operator|=
operator|(
name|delta
operator|<
literal|0
condition|?
literal|"subu %#r1,%#r1,.-%l0+4"
else|:
literal|"addu %#r1,%#r1,%l0-.-4"
operator|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
else|#
directive|else
name|operands
index|[
literal|0
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|low
operator|=
name|dest
expr_stmt|;
name|high
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|last
operator|=
literal|"subu %#r1,%#r1,%l0\n%l1:"
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|high
operator|=
name|dest
expr_stmt|;
name|last
operator|=
literal|"addu %#r1,%#r1,%l0\n%l1:"
expr_stmt|;
block|}
comment|/* Record the values to be computed later as "def name,high-low".  */
name|sb_name
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|sb_name
argument_list|)
expr_stmt|;
name|sb_high
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|high
argument_list|,
name|sb_high
argument_list|)
expr_stmt|;
name|sb_low
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|low
argument_list|,
name|sb_low
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't USE_GAS */
return|return
name|last
return|;
block|}
block|}
return|return
operator|(
name|REG_P
argument_list|(
name|addr
argument_list|)
condition|?
literal|"jsr%. %0"
else|:
operator|(
name|flag_pic
condition|?
literal|"bsr%. %0#plt"
else|:
literal|"bsr%. %0"
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_short_branch_defs
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
name|name
index|[
literal|256
index|]
decl_stmt|,
name|high
index|[
literal|256
index|]
decl_stmt|,
name|low
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
init|;
name|sb_name
operator|&&
name|sb_high
operator|&&
name|sb_low
condition|;
name|sb_name
operator|=
name|XEXP
argument_list|(
name|sb_name
argument_list|,
literal|1
argument_list|)
operator|,
name|sb_high
operator|=
name|XEXP
argument_list|(
name|sb_high
argument_list|,
literal|1
argument_list|)
operator|,
name|sb_low
operator|=
name|XEXP
argument_list|(
name|sb_low
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|sb_name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|high
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|sb_high
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|low
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|sb_low
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This will change as the assembler requirements become known.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s\t %s,%s-%s\n"
argument_list|,
name|SET_ASM_OP
argument_list|,
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
operator|&
name|high
index|[
literal|1
index|]
argument_list|,
operator|&
name|low
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb_name
operator|||
name|sb_high
operator|||
name|sb_low
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return truth value of the statement that this conditional branch is likely    to fall through.  CONDITION, is the condition that JUMP_INSN is testing.  */
end_comment

begin_function
name|int
name|mostly_false_jump
parameter_list|(
name|jump_insn
parameter_list|,
name|condition
parameter_list|)
name|rtx
name|jump_insn
decl_stmt|,
name|condition
decl_stmt|;
block|{
name|rtx
name|target_label
init|=
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
decl_stmt|;
name|rtx
name|insnt
decl_stmt|,
name|insnj
decl_stmt|;
comment|/* Much of this isn't computed unless we're optimizing.  */
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Determine if one path or the other leads to a return.  */
for|for
control|(
name|insnt
operator|=
name|NEXT_INSN
argument_list|(
name|target_label
argument_list|)
init|;
name|insnt
condition|;
name|insnt
operator|=
name|NEXT_INSN
argument_list|(
name|insnt
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insnt
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insnt
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insnt
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insnt
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|insnt
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insnt
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|insnt
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insnt
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insnt
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insnt
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insnt
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|)
condition|)
name|insnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insnj
operator|=
name|NEXT_INSN
argument_list|(
name|jump_insn
argument_list|)
init|;
name|insnj
condition|;
name|insnj
operator|=
name|NEXT_INSN
argument_list|(
name|insnj
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insnj
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insnj
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insnj
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insnj
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|insnj
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insnj
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|insnj
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insnj
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insnj
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insnj
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insnj
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
operator|)
operator|)
condition|)
name|insnj
operator|=
literal|0
expr_stmt|;
comment|/* Predict to not return.  */
if|if
condition|(
operator|(
name|insnt
operator|==
literal|0
operator|)
operator|!=
operator|(
name|insnj
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|insnt
operator|==
literal|0
operator|)
return|;
comment|/* Predict loops to loop.  */
for|for
control|(
name|insnt
operator|=
name|PREV_INSN
argument_list|(
name|target_label
argument_list|)
init|;
name|insnt
operator|&&
name|GET_CODE
argument_list|(
name|insnt
argument_list|)
operator|==
name|NOTE
condition|;
name|insnt
operator|=
name|PREV_INSN
argument_list|(
name|insnt
argument_list|)
control|)
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insnt
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insnt
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insnt
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
condition|)
return|return
literal|0
return|;
comment|/* Predict backward branches usually take.  */
if|if
condition|(
name|final_sequence
condition|)
name|insnj
operator|=
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insnj
operator|=
name|jump_insn
expr_stmt|;
if|if
condition|(
name|insn_addresses
index|[
name|INSN_UID
argument_list|(
name|insnj
argument_list|)
index|]
operator|>
name|insn_addresses
index|[
name|INSN_UID
argument_list|(
name|target_label
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
comment|/* EQ tests are usually false and NE tests are usually true.  Also,      most quantities are positive, so we can make the appropriate guesses      about signed comparisons against zero.  Consider unsigned comparisons      to be a range check and assume quantities to be in range.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Unconditional branch.  */
return|return
literal|0
return|;
case|case
name|EQ
case|:
return|return
literal|1
return|;
case|case
name|NE
case|:
return|return
literal|0
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
comment|/* Must get casesi right at least.  */
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
literal|0
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the operand is a power of two and is a floating    point type (to optimize division by power of two into multiplication).  */
end_comment

begin_function
name|int
name|real_power_of_2_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
union|union
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|int
name|i
index|[
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
struct|struct
block|{
comment|/* IEEE double precision format */
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
decl_stmt|;
block|}
name|s
struct|;
struct|struct
block|{
comment|/* IEEE double format to quick check */
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
comment|/* if it fits in a float */
name|unsigned
name|exponent1
range|:
literal|4
decl_stmt|;
name|unsigned
name|exponent2
range|:
literal|7
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
decl_stmt|;
block|}
name|s2
struct|;
block|}
name|u
union|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DFmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SFmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
return|return
literal|0
return|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|s
operator|.
name|mantissa1
operator|!=
literal|0
operator|||
name|u
operator|.
name|s
operator|.
name|mantissa2
operator|!=
literal|0
comment|/* not a power of two */
operator|||
name|u
operator|.
name|s
operator|.
name|exponent
operator|==
literal|0
comment|/* constant 0.0 */
operator|||
name|u
operator|.
name|s
operator|.
name|exponent
operator|==
literal|0x7ff
comment|/* NAN */
operator|||
operator|(
name|u
operator|.
name|s2
operator|.
name|exponent1
operator|!=
literal|0x8
operator|&&
name|u
operator|.
name|s2
operator|.
name|exponent1
operator|!=
literal|0x7
operator|)
condition|)
return|return
literal|0
return|;
comment|/* const won't fit in float */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make OP legitimate for mode MODE.  Currently this only deals with DFmode    operands, putting them in registers and making CONST_DOUBLE values    SFmode where possible.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|legitimize_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
union|union
block|{
name|union
name|real_extract
name|r
decl_stmt|;
struct|struct
block|{
comment|/* IEEE double precision format */
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|exponent
range|:
literal|11
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
decl_stmt|;
block|}
name|d
struct|;
struct|struct
block|{
comment|/* IEEE double format to quick check */
name|unsigned
name|sign
range|:
literal|1
decl_stmt|;
comment|/* if it fits in a float */
name|unsigned
name|exponent1
range|:
literal|4
decl_stmt|;
name|unsigned
name|exponent2
range|:
literal|7
decl_stmt|;
name|unsigned
name|mantissa1
range|:
literal|20
decl_stmt|;
name|unsigned
name|mantissa2
decl_stmt|;
block|}
name|s
struct|;
block|}
name|u
union|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
name|mode
operator|!=
name|DFmode
condition|)
return|return
name|op
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|,
operator|&
name|u
operator|.
name|r
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|d
operator|.
name|exponent
operator|!=
literal|0x7ff
comment|/* NaN */
operator|&&
name|u
operator|.
name|d
operator|.
name|mantissa2
operator|==
literal|0
comment|/* Mantissa fits */
operator|&&
operator|(
name|u
operator|.
name|s
operator|.
name|exponent1
operator|==
literal|0x8
operator|||
name|u
operator|.
name|s
operator|.
name|exponent1
operator|==
literal|0x7
operator|)
comment|/* Exponent fits */
operator|&&
operator|(
name|temp
operator|=
name|simplify_unary_operation
argument_list|(
name|FLOAT_TRUNCATE
argument_list|,
name|SFmode
argument_list|,
name|op
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|gen_rtx
argument_list|(
name|FLOAT_EXTEND
argument_list|,
name|mode
argument_list|,
name|force_reg
argument_list|(
name|SFmode
argument_list|,
name|temp
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|op
return|;
return|return
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if OP is a suitable input for a move insn.  */
end_comment

begin_function
name|int
name|move_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|classify_integer
argument_list|(
name|mode
argument_list|,
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
name|m88k_oru_hi16
operator|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|symbolic_address_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is suitable for a call insn.  */
end_comment

begin_function
name|int
name|call_address_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|||
name|symbolic_address_p
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_address_p
parameter_list|(
name|op
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if OP is a register or const0_rtx.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if OP is a valid second operand for an arithmetic insn.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a  register or 5 bit integer.  */
end_comment

begin_function
name|int
name|arith5_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arith32_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arith64_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|DImode
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|int5_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
return|;
block|}
end_function

begin_function
name|int
name|int32_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register or a valid immediate operand for    addu or subu.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|ADD_INT
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if this is a bitmask filling the bottom bits, for optimizing and +    shift left combinations into a single mak instruction.  */
end_comment

begin_function
name|int
name|mak_mask_p
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
return|return
operator|(
name|value
operator|&&
name|POWER_OF_2_or_0
argument_list|(
name|value
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|reg_or_bbx_mask_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|value
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|POWER_OF_2
argument_list|(
name|value
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is valid to use in the context of a floating    point operation.  Special case 0.0, since we can use r0.  */
end_comment

begin_function
name|int
name|real_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|SFmode
operator|&&
name|mode
operator|!=
name|DFmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a relational operator.  */
end_comment

begin_function
name|int
name|relop
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if OP is a relational operator, and is not an unsigned    relational operator.  */
end_comment

begin_function
name|int
name|relop_no_unsigned
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
comment|/* @@ What is this test doing?  Why not use `mode'?  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|DImode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|DImode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the code of this rtx pattern is EQ or NE.  */
end_comment

begin_function
name|int
name|equality_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the code of this rtx pattern is pc or label_ref.  */
end_comment

begin_function
name|int
name|pc_or_label_ref
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output to FILE the start of the assembler file.  */
end_comment

begin_struct
struct|struct
name|option
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|variable
decl_stmt|;
name|int
name|on_value
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|output_option
parameter_list|(
name|file
parameter_list|,
name|sep
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|indent
parameter_list|,
name|pos
parameter_list|,
name|max
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|indent
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|strlen
argument_list|(
name|sep
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|pos
operator|>
name|max
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|indent
argument_list|)
expr_stmt|;
return|return
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
return|;
block|}
return|return
name|pos
operator|+
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%s"
argument_list|,
name|sep
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|m_options
index|[]
init|=
name|TARGET_SWITCHES
struct|;
end_struct

begin_function
specifier|static
name|void
name|output_options
parameter_list|(
name|file
parameter_list|,
name|f_options
parameter_list|,
name|f_len
parameter_list|,
name|W_options
parameter_list|,
name|W_len
parameter_list|,
name|pos
parameter_list|,
name|max
parameter_list|,
name|sep
parameter_list|,
name|indent
parameter_list|,
name|term
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|option
modifier|*
name|f_options
decl_stmt|;
name|struct
name|option
modifier|*
name|W_options
decl_stmt|;
name|int
name|f_len
decl_stmt|,
name|W_len
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|max
decl_stmt|;
name|char
modifier|*
name|indent
decl_stmt|;
name|char
modifier|*
name|term
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|optimize
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-O"
argument_list|,
literal|""
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-g"
argument_list|,
literal|""
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-traditional"
argument_list|,
literal|""
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_flag
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-p"
argument_list|,
literal|""
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_block_flag
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-a"
argument_list|,
literal|""
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|f_len
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|f_options
index|[
name|j
index|]
operator|.
name|variable
operator|==
name|f_options
index|[
name|j
index|]
operator|.
name|on_value
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-f"
argument_list|,
name|f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|W_len
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
name|W_options
index|[
name|j
index|]
operator|.
name|variable
operator|==
name|W_options
index|[
name|j
index|]
operator|.
name|on_value
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-W"
argument_list|,
name|W_options
index|[
name|j
index|]
operator|.
name|string
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|m_options
operator|/
sizeof|sizeof
name|m_options
index|[
literal|0
index|]
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|m_options
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|m_options
index|[
name|j
index|]
operator|.
name|value
operator|>
literal|0
operator|&&
operator|(
operator|(
name|m_options
index|[
name|j
index|]
operator|.
name|value
operator|&
name|target_flags
operator|)
operator|==
name|m_options
index|[
name|j
index|]
operator|.
name|value
operator|)
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-m"
argument_list|,
name|m_options
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|m88k_short_data
condition|)
name|pos
operator|=
name|output_option
argument_list|(
name|file
argument_list|,
name|sep
argument_list|,
literal|"-mshort-data-"
argument_list|,
name|m88k_short_data
argument_list|,
name|indent
argument_list|,
name|pos
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_file_start
parameter_list|(
name|file
parameter_list|,
name|f_options
parameter_list|,
name|f_len
parameter_list|,
name|W_options
parameter_list|,
name|W_len
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|option
modifier|*
name|f_options
decl_stmt|;
name|struct
name|option
modifier|*
name|W_options
decl_stmt|;
name|int
name|f_len
decl_stmt|,
name|W_len
decl_stmt|;
block|{
specifier|register
name|int
name|pos
decl_stmt|;
name|ASM_FIRST_LINE
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|output_file_directive
argument_list|(
name|file
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
comment|/* Switch to the data section so that the coffsem symbol and the      gcc2_compiled. symbol aren't in the text section.  */
name|data_section
argument_list|()
expr_stmt|;
name|ASM_COFFSEM
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|pos
operator|=
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n; cc1 (%s) arguments:"
argument_list|,
name|VERSION_STRING
argument_list|)
expr_stmt|;
name|output_options
argument_list|(
name|file
argument_list|,
name|f_options
argument_list|,
name|f_len
argument_list|,
name|W_options
argument_list|,
name|W_len
argument_list|,
name|pos
argument_list|,
literal|75
argument_list|,
literal|" "
argument_list|,
literal|"\n; "
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_IDENTIFY_REVISION
condition|)
block|{
name|char
name|indent
index|[
literal|256
index|]
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|indent
argument_list|,
literal|"]\"\n\t%s\t \"@(#)%s ["
argument_list|,
name|IDENT_ASM_OP
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|=
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"gcc %s, %.24s,"
argument_list|,
name|VERSION_STRING
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|output_options
argument_list|(
name|file
argument_list|,
name|f_options
argument_list|,
name|f_len
argument_list|,
name|W_options
argument_list|,
name|W_len
argument_list|,
name|pos
argument_list|,
literal|150
operator|-
name|strlen
argument_list|(
name|indent
argument_list|)
argument_list|,
literal|" "
argument_list|,
name|indent
argument_list|,
literal|"]\"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an ascii string.  */
end_comment

begin_function
name|void
name|output_ascii
parameter_list|(
name|file
parameter_list|,
name|opcode
parameter_list|,
name|max
parameter_list|,
name|p
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|opcode
decl_stmt|;
name|int
name|max
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|in_escape
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|num
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t \""
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|num
operator|>
name|max
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"\n\t%s\t \""
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|escape
label|:
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|num
operator|+=
literal|2
expr_stmt|;
name|in_escape
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_escape
operator|&&
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
comment|/* If a digit follows an octal-escape, the Vax assembler fails 	     to stop reading the escape after three digits.  Continue to 	     output the values as an octal-escape until a non-digit is 	     found.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|num
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
name|in_escape
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Some assemblers can't handle \a, \v, or \?.  */
case|case
literal|'\t'
case|:
name|c
operator|=
literal|'t'
expr_stmt|;
goto|goto
name|escape
goto|;
case|case
literal|'\f'
case|:
name|c
operator|=
literal|'f'
expr_stmt|;
goto|goto
name|escape
goto|;
case|case
literal|'\b'
case|:
name|c
operator|=
literal|'b'
expr_stmt|;
goto|goto
name|escape
goto|;
case|case
literal|'\r'
case|:
name|c
operator|=
literal|'r'
expr_stmt|;
goto|goto
name|escape
goto|;
case|case
literal|'\n'
case|:
name|c
operator|=
literal|'n'
expr_stmt|;
goto|goto
name|escape
goto|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|num
operator|+=
literal|4
expr_stmt|;
name|in_escape
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a label (allows insn-output.c to be compiled without including    m88k.c or needing to include stdio.h).  */
end_comment

begin_function
name|void
name|output_label
parameter_list|(
name|label_number
parameter_list|)
name|int
name|label_number
decl_stmt|;
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|label_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate the assembly code for function entry.     The prologue is responsible for setting up the stack frame,    initializing the frame pointer register, saving registers that must be    saved, and allocating SIZE additional bytes of storage for the    local variables.  SIZE is an integer.  FILE is a stdio    stream to which the assembler code should be output.     The label for the beginning of the function need not be output by this    macro.  That has already been done when the macro is run.     To determine which registers to save, the macro can refer to the array    `regs_ever_live': element R is nonzero if hard register    R is used anywhere within the function.  This implies the    function prologue should save register R, but not if it is one    of the call-used registers.     On machines where functions may or may not have frame-pointers, the    function entry code must vary accordingly; it must set up the frame    pointer if one is wanted, and not otherwise.  To determine whether a    frame pointer is in wanted, the macro can refer to the variable    `frame_pointer_needed'.  The variable's value will be 1 at run    time in a function that needs a frame pointer.     On machines where an argument may be passed partly in registers and    partly in memory, this macro must examine the variable    `current_function_pretend_args_size', and allocate that many bytes    of uninitialized space on the stack just underneath the first argument    arriving on the stack.  (This may not be at the very end of the stack,    if the calling sequence has pushed anything else since pushing the stack    arguments.  But usually, on such machines, nothing else has been pushed    yet, because the function prologue itself does all the pushing.)     If `ACCUMULATE_OUTGOING_ARGS' is defined, the variable    `current_function_outgoing_args_size' contains the size in bytes    required for the outgoing arguments.  This macro must add that    amount of uninitialized space to very bottom of the stack.     The stack frame we use looks like this:   caller                                                  callee         |==============================================|         |                caller's frame                |         |==============================================|         |     [caller's outgoing memory arguments]     |         |==============================================|         |  caller's outgoing argument area (32 bytes)  |   sp -> |==============================================|<- ap         |            [local variable space]            |         |----------------------------------------------|         |            [return address (r1)]             |         |----------------------------------------------|         |        [previous frame pointer (r30)]        |         |==============================================|<- fp         |       [preserved registers (r25..r14)]       |         |----------------------------------------------|         |       [preserved registers (x29..x22)]       |         |==============================================|         |    [dynamically allocated space (alloca)]    |         |==============================================|         |     [callee's outgoing memory arguments]     |         |==============================================|         | [callee's outgoing argument area (32 bytes)] |         |==============================================|<- sp    Notes:    r1 and r30 must be saved if debugging.    fp (if present) is located two words down from the local   variable space.   */
end_comment

begin_function_decl
specifier|static
name|void
name|emit_add
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|preserve_registers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_ldst
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_tdesc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|nregs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nxregs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|save_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frame_laid_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frame_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|variable_args_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epilogue_marked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prologue_marked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current_function_pretend_args_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current_function_outgoing_args_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FIRST_OCS_PRESERVE_REGISTER
value|14
end_define

begin_define
define|#
directive|define
name|LAST_OCS_PRESERVE_REGISTER
value|30
end_define

begin_define
define|#
directive|define
name|FIRST_OCS_EXTENDED_PRESERVE_REGISTER
value|(32 + 22)
end_define

begin_define
define|#
directive|define
name|LAST_OCS_EXTENDED_PRESERVE_REGISTER
value|(32 + 31)
end_define

begin_define
define|#
directive|define
name|STACK_UNIT_BOUNDARY
value|(STACK_BOUNDARY / BITS_PER_UNIT)
end_define

begin_define
define|#
directive|define
name|ROUND_CALL_BLOCK_SIZE
parameter_list|(
name|BYTES
parameter_list|)
define|\
value|(((BYTES) + (STACK_UNIT_BOUNDARY - 1))& ~(STACK_UNIT_BOUNDARY - 1))
end_define

begin_escape
end_escape

begin_comment
comment|/* Establish the position of the FP relative to the SP.  This is done    either during FUNCTION_PROLOGUE or by INITIAL_ELIMINATION_OFFSET.  */
end_comment

begin_function
name|void
name|m88k_layout_frame
parameter_list|()
block|{
name|int
name|regno
decl_stmt|,
name|sp_size
decl_stmt|;
name|frame_laid_out
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|save_regs
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|save_regs
argument_list|)
argument_list|)
expr_stmt|;
name|sp_size
operator|=
name|nregs
operator|=
name|nxregs
operator|=
literal|0
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
comment|/* Since profiling requires a call, make sure r1 is saved.  */
if|if
condition|(
name|profile_flag
operator|||
name|profile_block_flag
condition|)
name|save_regs
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If we are producing debug information, store r1 and r30 where the      debugger wants to find them (r30 at r30+0, r1 at r30+4).  Space has      already been reserved for r1/r30 in STARTING_FRAME_OFFSET.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
operator|!
name|TARGET_OCS_FRAME_POSITION
condition|)
name|save_regs
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If there is a call, alloca is used, __builtin_alloca is used, or      a dynamic-sized object is defined, add the 8 additional words      for the callee's argument area.  The common denominator is that the      FP is required.  may_call_alloca only gets calls to alloca;      current_function_calls_alloca gets alloca and __builtin_alloca.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|1
index|]
operator|||
name|frame_pointer_needed
condition|)
block|{
name|save_regs
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|sp_size
operator|+=
name|REG_PARM_STACK_SPACE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we are producing PIC, save the addressing base register and r1.  */
if|if
condition|(
name|flag_pic
operator|&&
name|current_function_uses_pic_offset_table
condition|)
block|{
name|save_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|nregs
operator|++
expr_stmt|;
block|}
comment|/* If a frame is requested, save the previous FP, and the return      address (r1), so that a traceback can be done without using tdesc      information.  Otherwise, simply save the FP if it is used as      a preserve register.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|save_regs
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
name|save_regs
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|regs_ever_live
index|[
name|FRAME_POINTER_REGNUM
index|]
condition|)
name|save_regs
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Figure out which extended register(s) needs to be saved.  */
for|for
control|(
name|regno
operator|=
name|FIRST_EXTENDED_REGISTER
operator|+
literal|1
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|save_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|nxregs
operator|++
expr_stmt|;
block|}
comment|/* Figure out which normal register(s) needs to be saved.  */
for|for
control|(
name|regno
operator|=
literal|2
init|;
name|regno
operator|<
name|FRAME_POINTER_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|save_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|nregs
operator|++
expr_stmt|;
block|}
comment|/* Achieve greatest use of double memory ops.  Either we end up saving      r30 or we use that slot to align the registers we do save.  */
if|if
condition|(
name|nregs
operator|>=
literal|2
operator|&&
name|save_regs
index|[
literal|1
index|]
operator|&&
operator|!
name|save_regs
index|[
name|FRAME_POINTER_REGNUM
index|]
condition|)
name|sp_size
operator|+=
literal|4
expr_stmt|;
name|nregs
operator|+=
name|save_regs
index|[
literal|1
index|]
operator|+
name|save_regs
index|[
name|FRAME_POINTER_REGNUM
index|]
expr_stmt|;
comment|/* if we need to align extended registers, add a word */
if|if
condition|(
name|nxregs
operator|>
literal|0
operator|&&
operator|(
name|nregs
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|sp_size
operator|+=
literal|4
expr_stmt|;
name|sp_size
operator|+=
literal|4
operator|*
name|nregs
expr_stmt|;
name|sp_size
operator|+=
literal|8
operator|*
name|nxregs
expr_stmt|;
name|sp_size
operator|+=
name|current_function_outgoing_args_size
expr_stmt|;
comment|/* The first two saved registers are placed above the new frame pointer      if any.  In the only case this matters, they are r1 and r30. */
if|if
condition|(
name|frame_pointer_needed
operator|||
name|sp_size
condition|)
name|m88k_fp_offset
operator|=
name|ROUND_CALL_BLOCK_SIZE
argument_list|(
name|sp_size
operator|-
name|STARTING_FRAME_OFFSET
argument_list|)
expr_stmt|;
else|else
name|m88k_fp_offset
operator|=
operator|-
name|STARTING_FRAME_OFFSET
expr_stmt|;
name|m88k_stack_size
operator|=
name|m88k_fp_offset
operator|+
name|STARTING_FRAME_OFFSET
expr_stmt|;
comment|/* First, combine m88k_stack_size and size.  If m88k_stack_size is      non-zero, align the frame size to 8 mod 16; otherwise align the      frame size to 0 mod 16.  (If stacks are 8 byte aligned, this ends      up as a NOP.  */
block|{
name|int
name|need
init|=
operator|(
operator|(
name|m88k_stack_size
condition|?
name|STACK_UNIT_BOUNDARY
operator|-
name|STARTING_FRAME_OFFSET
else|:
literal|0
operator|)
operator|-
operator|(
name|frame_size
operator|%
name|STACK_UNIT_BOUNDARY
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|need
condition|)
block|{
if|if
condition|(
name|need
operator|<
literal|0
condition|)
name|need
operator|+=
name|STACK_UNIT_BOUNDARY
expr_stmt|;
operator|(
name|void
operator|)
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|need
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|frame_size
operator|=
name|get_frame_size
argument_list|()
expr_stmt|;
block|}
name|m88k_stack_size
operator|=
name|ROUND_CALL_BLOCK_SIZE
argument_list|(
name|m88k_stack_size
operator|+
name|frame_size
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if this function is known to have a null prologue.  */
end_comment

begin_function
name|int
name|null_prologue
parameter_list|()
block|{
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|frame_laid_out
condition|)
name|m88k_layout_frame
argument_list|()
expr_stmt|;
return|return
operator|(
operator|!
name|frame_pointer_needed
operator|&&
name|nregs
operator|==
literal|0
operator|&&
name|nxregs
operator|==
literal|0
operator|&&
name|m88k_stack_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if the current function has any references to the arg pointer.    This is done indirectly by examining the DECL_ARGUMENTS' DECL_RTL.    It is OK to return TRUE if there are no references, but FALSE must be    correct.  */
end_comment

begin_function
specifier|static
name|int
name|uses_arg_area_p
parameter_list|()
block|{
specifier|register
name|tree
name|parm
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
operator|||
name|current_function_varargs
operator|||
name|variable_args_p
condition|)
return|return
literal|1
return|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|m88k_begin_prologue
parameter_list|(
name|stream
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|m88k_prologue_done
operator|=
literal|1
expr_stmt|;
comment|/* it's ok now to put out ln directives */
block|}
end_function

begin_function
name|void
name|m88k_end_prologue
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_OCS_DEBUG_INFO
operator|&&
operator|!
name|prologue_marked
condition|)
block|{
name|PUT_OCS_FUNCTION_START
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|prologue_marked
operator|=
literal|1
expr_stmt|;
comment|/* If we've already passed the start of the epilogue, say that 	 it starts here.  This marks the function as having a null body, 	 but at a point where the return address is in a known location.  	 Originally, I thought this couldn't happen, but the pic prologue 	 for leaf functions ends with the instruction that restores the 	 return address from the temporary register.  If the temporary 	 register is never used, that instruction can float all the way 	 to the end of the function.  */
if|if
condition|(
name|epilogue_marked
condition|)
name|PUT_OCS_FUNCTION_END
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|m88k_expand_prologue
parameter_list|()
block|{
name|m88k_layout_frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_OPTIMIZE_ARG_AREA
operator|&&
name|m88k_stack_size
operator|&&
operator|!
name|uses_arg_area_p
argument_list|()
condition|)
block|{
comment|/* The incoming argument area is used for stack space if it is not 	 used (or if -mno-optimize-arg-area is given).  */
if|if
condition|(
operator|(
name|m88k_stack_size
operator|-=
name|REG_PARM_STACK_SPACE
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|m88k_stack_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m88k_stack_size
condition|)
name|emit_add
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
operator|-
name|m88k_stack_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nregs
operator|||
name|nxregs
condition|)
name|preserve_registers
argument_list|(
name|m88k_fp_offset
operator|+
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|emit_add
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|m88k_fp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
name|save_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
block|{
name|rtx
name|return_reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|temp_reg
decl_stmt|;
if|if
condition|(
operator|!
name|save_regs
index|[
literal|1
index|]
condition|)
block|{
name|temp_reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|TEMP_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp_reg
argument_list|,
name|return_reg
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_locate1
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_locate2
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|return_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|save_regs
index|[
literal|1
index|]
condition|)
name|emit_move_insn
argument_list|(
name|return_reg
argument_list|,
name|temp_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|profile_flag
operator|||
name|profile_block_flag
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function generates the assembly code for function exit,    on machines that need it.  Args are same as for FUNCTION_PROLOGUE.     The function epilogue should not depend on the current stack pointer!    It should use the frame pointer only, if there is a frame pointer.    This is mandatory because of alloca; we also take advantage of it to    omit stack adjustments before returning.  */
end_comment

begin_function
name|void
name|m88k_begin_epilogue
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_OCS_DEBUG_INFO
operator|&&
operator|!
name|epilogue_marked
operator|&&
name|prologue_marked
condition|)
block|{
name|PUT_OCS_FUNCTION_END
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
name|epilogue_marked
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|m88k_end_epilogue
parameter_list|(
name|stream
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
if|if
condition|(
name|TARGET_OCS_DEBUG_INFO
operator|&&
operator|!
name|epilogue_marked
condition|)
name|PUT_OCS_FUNCTION_END
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* If the last insn isn't a BARRIER, we must write a return insn.  This      should only happen if the function has no prologe and no body.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tjmp\t %s\n"
argument_list|,
name|reg_names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|output_short_branch_defs
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_OCS_DEBUG_INFO
condition|)
name|output_tdesc
argument_list|(
name|stream
argument_list|,
name|m88k_fp_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|m88k_function_number
operator|++
expr_stmt|;
name|m88k_prologue_done
operator|=
literal|0
expr_stmt|;
comment|/* don't put out ln directives */
name|variable_args_p
operator|=
literal|0
expr_stmt|;
comment|/* has variable args */
name|frame_laid_out
operator|=
literal|0
expr_stmt|;
name|epilogue_marked
operator|=
literal|0
expr_stmt|;
name|prologue_marked
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|m88k_expand_epilogue
parameter_list|()
block|{
if|#
directive|if
operator|(
name|MONITOR_GCC
operator|&
literal|0x4
operator|)
comment|/* What are interesting prologue/epilogue values?  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"; size = %d, m88k_fp_offset = %d, m88k_stack_size = %d\n"
argument_list|,
name|size
argument_list|,
name|m88k_fp_offset
argument_list|,
name|m88k_stack_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|frame_pointer_needed
condition|)
name|emit_add
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame_pointer_rtx
argument_list|,
operator|-
name|m88k_fp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|nregs
operator|||
name|nxregs
condition|)
name|preserve_registers
argument_list|(
name|m88k_fp_offset
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m88k_stack_size
condition|)
name|emit_add
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|m88k_stack_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insns to set DSTREG to SRCREG + AMOUNT during the prologue or    epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|emit_add
parameter_list|(
name|dstreg
parameter_list|,
name|srcreg
parameter_list|,
name|amount
parameter_list|)
name|rtx
name|dstreg
decl_stmt|;
name|rtx
name|srcreg
decl_stmt|;
name|int
name|amount
decl_stmt|;
block|{
name|rtx
name|incr
init|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|abs
argument_list|(
name|amount
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ADD_INTVAL
argument_list|(
name|amount
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|TEMP_REGNUM
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|incr
argument_list|)
expr_stmt|;
name|incr
operator|=
name|temp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
operator|(
name|amount
operator|<
literal|0
condition|?
name|gen_subsi3
else|:
name|gen_addsi3
operator|)
operator|(
name|dstreg
operator|,
name|srcreg
operator|,
name|incr
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save/restore the preserve registers.  base is the highest offset from    r31 at which a register is stored.  store_p is true if stores are to    be done; otherwise loads.  */
end_comment

begin_function
specifier|static
name|void
name|preserve_registers
parameter_list|(
name|base
parameter_list|,
name|store_p
parameter_list|)
name|int
name|base
decl_stmt|;
name|int
name|store_p
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|offset
decl_stmt|;
struct|struct
name|mem_op
block|{
name|int
name|regno
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
name|mem_op
index|[
name|FIRST_PSEUDO_REGISTER
index|]
struct|;
name|struct
name|mem_op
modifier|*
name|mo_ptr
init|=
name|mem_op
decl_stmt|;
comment|/* The 88open OCS mandates that preserved registers be stored in      increasing order.  For compatibility with current practice,      the order is r1, r30, then the preserve registers.  */
name|offset
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|save_regs
index|[
literal|1
index|]
condition|)
block|{
comment|/* An extra word is given in this case to make best use of double 	 memory ops.  */
if|if
condition|(
name|nregs
operator|>
literal|2
operator|&&
operator|!
name|save_regs
index|[
name|FRAME_POINTER_REGNUM
index|]
condition|)
name|offset
operator|-=
literal|4
expr_stmt|;
name|emit_ldst
argument_list|(
name|store_p
argument_list|,
literal|1
argument_list|,
name|SImode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|-=
literal|4
expr_stmt|;
name|base
operator|=
name|offset
expr_stmt|;
block|}
comment|/* Walk the registers to save recording all single memory operations.  */
for|for
control|(
name|regno
operator|=
name|FRAME_POINTER_REGNUM
init|;
name|regno
operator|>
literal|1
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|save_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|&
literal|7
operator|)
operator|!=
literal|4
operator|||
operator|(
name|regno
operator|&
literal|1
operator|)
operator|!=
literal|1
operator|||
operator|!
name|save_regs
index|[
name|regno
operator|-
literal|1
index|]
condition|)
block|{
name|mo_ptr
operator|->
name|nregs
operator|=
literal|1
expr_stmt|;
name|mo_ptr
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|mo_ptr
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|mo_ptr
operator|++
expr_stmt|;
name|offset
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|regno
operator|--
expr_stmt|;
name|offset
operator|-=
literal|2
operator|*
literal|4
expr_stmt|;
block|}
block|}
comment|/* Walk the registers to save recording all double memory operations.      This avoids a delay in the epilogue (ld.d/ld).  */
name|offset
operator|=
name|base
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FRAME_POINTER_REGNUM
init|;
name|regno
operator|>
literal|1
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|save_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|&
literal|7
operator|)
operator|!=
literal|4
operator|||
operator|(
name|regno
operator|&
literal|1
operator|)
operator|!=
literal|1
operator|||
operator|!
name|save_regs
index|[
name|regno
operator|-
literal|1
index|]
condition|)
block|{
name|offset
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|mo_ptr
operator|->
name|nregs
operator|=
literal|2
expr_stmt|;
name|mo_ptr
operator|->
name|regno
operator|=
name|regno
operator|-
literal|1
expr_stmt|;
name|mo_ptr
operator|->
name|offset
operator|=
name|offset
operator|-
literal|4
expr_stmt|;
name|mo_ptr
operator|++
expr_stmt|;
name|regno
operator|--
expr_stmt|;
name|offset
operator|-=
literal|2
operator|*
literal|4
expr_stmt|;
block|}
block|}
comment|/* Walk the extended registers to record all memory operations.  */
comment|/*  Be sure the offset is double word aligned.  */
name|offset
operator|=
operator|(
name|offset
operator|-
literal|1
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|regno
operator|>
name|FIRST_EXTENDED_REGISTER
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|save_regs
index|[
name|regno
index|]
condition|)
block|{
name|mo_ptr
operator|->
name|nregs
operator|=
literal|2
expr_stmt|;
name|mo_ptr
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|mo_ptr
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|mo_ptr
operator|++
expr_stmt|;
name|offset
operator|-=
literal|2
operator|*
literal|4
expr_stmt|;
block|}
name|mo_ptr
operator|->
name|regno
operator|=
literal|0
expr_stmt|;
comment|/* Output the memory operations.  */
for|for
control|(
name|mo_ptr
operator|=
name|mem_op
init|;
name|mo_ptr
operator|->
name|regno
condition|;
name|mo_ptr
operator|++
control|)
block|{
if|if
condition|(
name|mo_ptr
operator|->
name|nregs
condition|)
name|emit_ldst
argument_list|(
name|store_p
argument_list|,
name|mo_ptr
operator|->
name|regno
argument_list|,
operator|(
name|mo_ptr
operator|->
name|nregs
operator|>
literal|1
condition|?
name|DImode
else|:
name|SImode
operator|)
argument_list|,
name|mo_ptr
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|emit_ldst
parameter_list|(
name|store_p
parameter_list|,
name|regno
parameter_list|,
name|mode
parameter_list|,
name|offset
parameter_list|)
name|int
name|store_p
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|store_p
condition|)
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the address expression REG to a CFA offset.  */
end_comment

begin_function
name|int
name|m88k_debugger_offset
parameter_list|(
name|reg
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|rtx
name|reg
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Put the offset in terms of the CFA (arg pointer).  */
if|if
condition|(
name|reg
operator|==
name|frame_pointer_rtx
condition|)
name|offset
operator|+=
name|m88k_fp_offset
operator|-
name|m88k_stack_size
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|stack_pointer_rtx
condition|)
name|offset
operator|-=
name|m88k_stack_size
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|!=
name|arg_pointer_rtx
condition|)
block|{
if|#
directive|if
operator|(
name|MONITOR_GCC
operator|&
literal|0x10
operator|)
comment|/* Watch for suspicious symbolic locations.  */
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
name|warning
argument_list|(
literal|"Internal gcc error: Can't express symbolic location"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Output the 88open OCS proscribed text description information.    The information is:         0  8: zero 	0 22: info-byte-length (16 or 20 bytes) 	0  2: info-alignment (word 2) 	1 32: info-protocol (version 1 or 2(pic)) 	2 32: starting-address (inclusive, not counting prologue) 	3 32: ending-address (exclusive, not counting epilog) 	4  8: info-variant (version 1 or 3(extended registers)) 	4 17: register-save-mask (from register 14 to 30) 	4  1: zero 	4  1: return-address-info-discriminant 	4  5: frame-address-register 	5 32: frame-address-offset 	6 32: return-address-info 	7 32: register-save-offset 	8 16: extended-register-save-mask (x16 - x31) 	8 16: extended-register-save-offset (WORDS from register-save-offset)  */
end_comment

begin_function
specifier|static
name|void
name|output_tdesc
parameter_list|(
name|file
parameter_list|,
name|offset
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|mask
decl_stmt|,
name|return_address_info
decl_stmt|,
name|register_save_offset
decl_stmt|;
name|long
name|xmask
decl_stmt|,
name|xregister_save_offset
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|mask
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|regno
operator|=
name|FIRST_OCS_PRESERVE_REGISTER
init|;
name|regno
operator|<=
name|LAST_OCS_PRESERVE_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|save_regs
index|[
name|regno
index|]
condition|)
block|{
name|mask
operator||=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|xmask
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
operator|,
name|regno
operator|=
name|FIRST_OCS_EXTENDED_PRESERVE_REGISTER
init|;
name|regno
operator|<=
name|LAST_OCS_EXTENDED_PRESERVE_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
name|xmask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|save_regs
index|[
name|regno
index|]
condition|)
block|{
name|xmask
operator||=
literal|1
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_regs
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|nxregs
operator|>
literal|0
operator|||
name|nregs
operator|>
literal|2
operator|)
operator|&&
operator|!
name|save_regs
index|[
name|FRAME_POINTER_REGNUM
index|]
condition|)
name|offset
operator|-=
literal|4
expr_stmt|;
name|return_address_info
operator|=
operator|-
name|m88k_stack_size
operator|+
name|offset
expr_stmt|;
name|register_save_offset
operator|=
name|return_address_info
operator|-
name|i
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
name|return_address_info
operator|=
literal|1
expr_stmt|;
name|register_save_offset
operator|=
operator|-
name|m88k_stack_size
operator|+
name|offset
operator|+
literal|4
operator|-
name|i
operator|*
literal|4
expr_stmt|;
block|}
name|xregister_save_offset
operator|=
operator|-
operator|(
name|j
operator|*
literal|2
operator|+
operator|(
operator|(
name|register_save_offset
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
name|tdesc_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t %d,%d"
argument_list|,
name|INT_ASM_OP
argument_list|,
comment|/* 8:0,22:(20 or 16),2:2 */
operator|(
operator|(
operator|(
name|xmask
operator|!=
literal|0
operator|)
condition|?
literal|20
else|:
literal|16
operator|)
operator|<<
literal|2
operator|)
operator||
literal|2
argument_list|,
name|flag_pic
condition|?
literal|2
else|:
literal|1
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
name|OCS_START_PREFIX
argument_list|,
name|m88k_function_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",%s%s"
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|flag_pic
condition|?
literal|"#rel"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
name|OCS_END_PREFIX
argument_list|,
name|m88k_function_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",%s%s"
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|flag_pic
condition|?
literal|"#rel"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",0x%x,0x%x,0x%x,0x%x"
argument_list|,
comment|/* 8:1,17:0x%.3x,1:0,1:%d,5:%d */
operator|(
operator|(
operator|(
name|xmask
condition|?
literal|3
else|:
literal|1
operator|)
operator|<<
operator|(
literal|17
operator|+
literal|1
operator|+
literal|1
operator|+
literal|5
operator|)
operator|)
operator||
operator|(
name|mask
operator|<<
operator|(
literal|1
operator|+
literal|1
operator|+
literal|5
operator|)
operator|)
operator||
operator|(
operator|(
operator|!
operator|!
name|save_regs
index|[
literal|1
index|]
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
operator|)
argument_list|,
operator|(
name|m88k_stack_size
operator|-
operator|(
name|frame_pointer_needed
condition|?
name|m88k_fp_offset
else|:
literal|0
operator|)
operator|)
argument_list|,
name|return_address_info
argument_list|,
name|register_save_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",0x%x%04x"
argument_list|,
name|xmask
argument_list|,
operator|(
literal|0xffff
operator|&
name|xregister_save_offset
operator|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to FILE to increment profiler label # LABELNO    for profiling a function entry.  NAME is the mcount function name    (varies), SAVEP indicates whether the parameter registers need to    be saved and restored.  */
end_comment

begin_function
name|void
name|output_function_profiler
parameter_list|(
name|file
parameter_list|,
name|labelno
parameter_list|,
name|name
parameter_list|,
name|savep
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|savep
decl_stmt|;
block|{
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
name|dbi
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|temp
init|=
operator|(
name|savep
condition|?
name|reg_names
index|[
literal|2
index|]
else|:
name|reg_names
index|[
literal|10
index|]
operator|)
decl_stmt|;
comment|/* Remember to update FUNCTION_PROFILER_LENGTH.  */
if|if
condition|(
name|savep
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsubu\t %s,%s,64\n"
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst.d\t %s,%s,32\n"
argument_list|,
name|reg_names
index|[
literal|2
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst.d\t %s,%s,40\n"
argument_list|,
name|reg_names
index|[
literal|4
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst.d\t %s,%s,48\n"
argument_list|,
name|reg_names
index|[
literal|6
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst.d\t %s,%s,56\n"
argument_list|,
name|reg_names
index|[
literal|8
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
block|}
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LP"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor.u\t %s,%s,%shi16(%s#got_rel)\n"
argument_list|,
name|temp
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor\t %s,%s,%slo16(%s#got_rel)\n"
argument_list|,
name|temp
argument_list|,
name|temp
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dbi
argument_list|,
literal|"\tld\t %s,%s,%s\n"
argument_list|,
name|temp
argument_list|,
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
name|sprintf
argument_list|(
name|dbi
argument_list|,
literal|"\tld\t %s,%s,%s#got_rel\n"
argument_list|,
name|temp
argument_list|,
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|,
operator|&
name|label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor.u\t %s,%s,%shi16(%s)\n"
argument_list|,
name|temp
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dbi
argument_list|,
literal|"\tor\t %s,%s,%slo16(%s)\n"
argument_list|,
name|temp
argument_list|,
name|temp
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbsr.n\t %s#plt\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbsr.n\t %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|dbi
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|savep
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld.d\t %s,%s,32\n"
argument_list|,
name|reg_names
index|[
literal|2
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld.d\t %s,%s,40\n"
argument_list|,
name|reg_names
index|[
literal|4
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld.d\t %s,%s,48\n"
argument_list|,
name|reg_names
index|[
literal|6
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld.d\t %s,%s,56\n"
argument_list|,
name|reg_names
index|[
literal|8
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t %s,%s,64\n"
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output assembler code to FILE to initialize basic-block profiling for    the current module.  LABELNO is unique to each instance.  */
end_comment

begin_function
name|void
name|output_function_block_profiler
parameter_list|(
name|file
parameter_list|,
name|labelno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|char
name|block
index|[
literal|256
index|]
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
comment|/* Remember to update FUNCTION_BLOCK_PROFILER_LENGTH.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|block
argument_list|,
literal|"LPBX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LPY"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* @@ Need to deal with PIC.  I'm not sure what the requirements are on      register usage, so I used r26/r27 to be safe.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor.u\t %s,%s,%shi16(%s)\n"
argument_list|,
name|reg_names
index|[
literal|27
index|]
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|block
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld\t %s,%s,%slo16(%s)\n"
argument_list|,
name|reg_names
index|[
literal|26
index|]
argument_list|,
name|reg_names
index|[
literal|27
index|]
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|block
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbcnd\t %sne0,%s,%s\n"
argument_list|,
name|m88k_pound_sign
argument_list|,
name|reg_names
index|[
literal|26
index|]
argument_list|,
operator|&
name|label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsubu\t %s,%s,64\n"
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst.d\t %s,%s,32\n"
argument_list|,
name|reg_names
index|[
literal|2
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst.d\t %s,%s,40\n"
argument_list|,
name|reg_names
index|[
literal|4
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst.d\t %s,%s,48\n"
argument_list|,
name|reg_names
index|[
literal|6
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst.d\t %s,%s,56\n"
argument_list|,
name|reg_names
index|[
literal|8
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tbsr.n\t "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
literal|"__bb_init_func"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor\t %s,%s,%slo16(%s)\n"
argument_list|,
name|reg_names
index|[
literal|2
index|]
argument_list|,
name|reg_names
index|[
literal|27
index|]
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|block
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld.d\t %s,%s,32\n"
argument_list|,
name|reg_names
index|[
literal|2
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld.d\t %s,%s,40\n"
argument_list|,
name|reg_names
index|[
literal|4
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld.d\t %s,%s,48\n"
argument_list|,
name|reg_names
index|[
literal|6
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld.d\t %s,%s,56\n"
argument_list|,
name|reg_names
index|[
literal|8
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t %s,%s,64\n"
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|,
name|reg_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LPY"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output assembler code to FILE to increment the count associated with    the basic block number BLOCKNO.  */
end_comment

begin_function
name|void
name|output_block_profiler
parameter_list|(
name|file
parameter_list|,
name|blockno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|blockno
decl_stmt|;
block|{
name|char
name|block
index|[
literal|256
index|]
decl_stmt|;
comment|/* Remember to update BLOCK_PROFILER_LENGTH.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|block
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* @@ Need to deal with PIC.  I'm not sure what the requirements are on      register usage, so I used r26/r27 to be safe.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tor.u\t %s,%s,%shi16(%s+%d)\n"
argument_list|,
name|reg_names
index|[
literal|27
index|]
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|block
index|[
literal|1
index|]
argument_list|,
literal|4
operator|*
name|blockno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tld\t %s,%s,%slo16(%s+%d)\n"
argument_list|,
name|reg_names
index|[
literal|26
index|]
argument_list|,
name|reg_names
index|[
literal|27
index|]
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|block
index|[
literal|1
index|]
argument_list|,
literal|4
operator|*
name|blockno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddu\t %s,%s,1\n"
argument_list|,
name|reg_names
index|[
literal|26
index|]
argument_list|,
name|reg_names
index|[
literal|26
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst\t %s,%s,%slo16(%s+%d)\n"
argument_list|,
name|reg_names
index|[
literal|26
index|]
argument_list|,
name|reg_names
index|[
literal|27
index|]
argument_list|,
name|m88k_pound_sign
argument_list|,
operator|&
name|block
index|[
literal|1
index|]
argument_list|,
literal|4
operator|*
name|blockno
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether a function argument is passed in a register, and    which register.     The arguments are CUM, which summarizes all the previous    arguments; MODE, the machine mode of the argument; TYPE,    the data type of the argument as a tree node or 0 if that is not known    (which happens for C support library functions); and NAMED,    which is 1 for an ordinary argument and 0 for nameless arguments that    correspond to `...' in the called function's prototype.     The value of the expression should either be a `reg' RTX for the    hard register in which to pass the argument, or zero to pass the    argument on the stack.     On the m88000 the first eight words of args are normally in registers    and the rest are pushed.  Double precision floating point must be    double word aligned (and if in a register, starting on an even    register). Structures and unions which are not 4 byte, and word    aligned are passed in memory rather than registers, even if they    would fit completely in the registers under OCS rules.     Note that FUNCTION_ARG and FUNCTION_INCOMING_ARG were different.    For structures that are passed in memory, but could have been    passed in registers, we first load the structure into the    register, and then when the last argument is passed, we store    the registers into the stack locations.  This fixes some bugs    where GCC did not expect to have register arguments, followed    by stack arguments, followed by register arguments.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|m88k_function_arg
parameter_list|(
name|args_so_far
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
name|args_so_far
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|int
name|bytes
decl_stmt|,
name|words
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|0
comment|/* undo putting struct in register */
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
name|mode
operator|=
name|BLKmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
name|TARGET_WARN_PASS_STRUCT
condition|)
name|warning
argument_list|(
literal|"argument #%d is a structure"
argument_list|,
name|args_so_far
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|args_so_far
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
operator|||
operator|(
name|type
operator|!=
literal|0
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|32
operator|)
operator|)
condition|)
name|args_so_far
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ESKIT
if|if
condition|(
name|no_reg_params
condition|)
return|return
operator|(
name|rtx
operator|)
literal|0
return|;
comment|/* don't put args in registers */
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
literal|0
operator|&&
name|mode
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* m88k_function_arg argument `type' is NULL for BLKmode. */
name|bytes
operator|=
operator|(
name|mode
operator|!=
name|BLKmode
operator|)
condition|?
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
else|:
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|words
operator|=
operator|(
name|bytes
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|args_so_far
operator|+
name|words
operator|>
literal|8
condition|)
return|return
operator|(
name|rtx
operator|)
literal|0
return|;
comment|/* args have exhausted registers */
elseif|else
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|&&
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|!=
name|BITS_PER_WORD
operator|||
name|bytes
operator|!=
name|UNITS_PER_WORD
operator|)
condition|)
return|return
operator|(
name|rtx
operator|)
literal|0
return|;
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
else|:
name|mode
operator|)
argument_list|,
literal|2
operator|+
name|args_so_far
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do what is necessary for `va_start'.  The argument is ignored;    We look at the current function to determine if stdargs or varargs    is used and fill in an initial va_list.  A pointer to this constructor    is returned.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|m88k_builtin_saveregs
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|block
decl_stmt|,
name|addr
decl_stmt|,
name|argsize
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|int
name|argadj
init|=
operator|(
operator|(
operator|!
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
operator|)
condition|?
operator|-
name|UNITS_PER_WORD
else|:
literal|0
operator|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
decl_stmt|;
name|int
name|fixed
decl_stmt|;
name|variable_args_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|current_function_arg_offset_rtx
argument_list|)
condition|)
block|{
name|fixed
operator|=
operator|(
name|XINT
argument_list|(
name|current_function_arg_offset_rtx
argument_list|,
literal|0
argument_list|)
operator|+
name|argadj
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|argsize
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|fixed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixed
operator|=
literal|0
expr_stmt|;
name|argsize
operator|=
name|plus_constant
argument_list|(
name|current_function_arg_offset_rtx
argument_list|,
name|argadj
argument_list|)
expr_stmt|;
name|argsize
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|Pmode
argument_list|,
name|argsize
argument_list|,
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|argsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the va_list constructor */
name|block
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|3
operator|*
name|UNITS_PER_WORD
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Store the argsize as the __va_arg member.  */
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|argsize
argument_list|)
expr_stmt|;
comment|/* Store the arg pointer in the __va_stk member.  */
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|virtual_incoming_args_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the register space, and store it as the __va_reg member.  */
name|addr
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|8
operator|*
name|UNITS_PER_WORD
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now store the incoming registers.  */
if|if
condition|(
name|fixed
operator|<
literal|8
condition|)
name|move_block_from_reg
argument_list|(
literal|2
operator|+
name|fixed
argument_list|,
name|change_address
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fixed
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|,
literal|8
operator|-
name|fixed
argument_list|)
expr_stmt|;
comment|/* Return the address of the va_list constructor, but don't put it in a      register.  This fails when not optimizing and produces worse code when      optimizing.  */
return|return
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If cmpsi has not been generated, emit code to do the test.  Return the    expression describing the test of operator OP.  */
end_comment

begin_function
name|rtx
name|emit_test
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|enum
name|rtx_code
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|m88k_compare_reg
operator|==
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_test
argument_list|(
name|m88k_compare_op0
argument_list|,
name|m88k_compare_op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|gen_rtx
argument_list|(
name|op
argument_list|,
name|mode
argument_list|,
name|m88k_compare_reg
argument_list|,
name|const0_rtx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine how to best perform cmpsi/bxx, where cmpsi has a constant    operand.  All tests with zero (albeit swapped) and all equality tests    with a constant are done with bcnd.  The remaining cases are swapped    as needed.  */
end_comment

begin_function
name|void
name|emit_bcnd
parameter_list|(
name|op
parameter_list|,
name|label
parameter_list|)
name|enum
name|rtx_code
name|op
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
if|if
condition|(
name|m88k_compare_op1
operator|==
name|const0_rtx
condition|)
name|emit_jump_insn
argument_list|(
name|optimize
condition|?
name|gen_bxx
argument_list|(
name|emit_test
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
argument_list|,
name|label
argument_list|)
else|:
name|gen_bcnd
argument_list|(
name|gen_rtx
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|,
name|m88k_compare_op0
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m88k_compare_op0
operator|==
name|const0_rtx
condition|)
name|emit_jump_insn
argument_list|(
name|optimize
condition|?
name|gen_bxx
argument_list|(
name|emit_test
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
argument_list|,
name|label
argument_list|)
else|:
name|gen_bcnd
argument_list|(
name|gen_rtx
argument_list|(
name|swap_condition
argument_list|(
name|op
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|m88k_compare_op1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|!=
name|EQ
operator|&&
name|op
operator|!=
name|NE
condition|)
name|emit_jump_insn
argument_list|(
name|gen_bxx
argument_list|(
name|emit_test
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|zero
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|constant
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|m88k_compare_op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|reg
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|m88k_compare_op0
argument_list|)
expr_stmt|;
name|constant
operator|=
name|m88k_compare_op1
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|m88k_compare_op1
argument_list|)
expr_stmt|;
name|constant
operator|=
name|m88k_compare_op0
expr_stmt|;
block|}
name|value
operator|=
name|INTVAL
argument_list|(
name|constant
argument_list|)
expr_stmt|;
comment|/* Perform an arithmetic computation to make the compared-to value 	 zero, but avoid loosing if the bcnd is later changed into sxx.  */
if|if
condition|(
name|SMALL_INTVAL
argument_list|(
name|value
argument_list|)
condition|)
name|emit_jump_insn
argument_list|(
name|gen_bxx
argument_list|(
name|emit_test
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|SMALL_INTVAL
argument_list|(
operator|-
name|value
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|zero
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_xorsi3
argument_list|(
name|zero
argument_list|,
name|reg
argument_list|,
name|constant
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bcnd
argument_list|(
name|gen_rtx
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|,
name|zero
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|xc
init|=
operator|(
name|x
condition|?
name|GET_CODE
argument_list|(
name|x
argument_list|)
else|:
name|UNKNOWN
operator|)
decl_stmt|;
specifier|register
name|int
name|value
init|=
operator|(
name|xc
operator|==
name|CONST_INT
condition|?
name|INTVAL
argument_list|(
name|x
argument_list|)
else|:
literal|0
operator|)
decl_stmt|;
specifier|static
name|int
name|sequencep
decl_stmt|;
specifier|static
name|int
name|reversep
decl_stmt|;
if|if
condition|(
name|sequencep
condition|)
block|{
if|if
condition|(
name|code
operator|<
literal|'B'
operator|||
name|code
operator|>
literal|'E'
condition|)
name|output_operand_lossage
argument_list|(
literal|"%R not followed by %B/C/D/E"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
name|xc
operator|=
name|reverse_condition
argument_list|(
name|xc
argument_list|)
expr_stmt|;
name|sequencep
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* addressing base register for PIC */
name|fputs
argument_list|(
name|reg_names
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'#'
case|:
comment|/* SVR4 pound-sign syntax character (empty if SVR3) */
name|fputs
argument_list|(
name|m88k_pound_sign
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'V'
case|:
comment|/* Output a serializing instruction as needed if the operand 		 (assumed to be a MEM) is a volatile load.  */
case|case
literal|'v'
case|:
comment|/* ditto for a volatile store.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|TARGET_SERIALIZE_VOLATILE
condition|)
block|{
comment|/* The m88110 implements two FIFO queues, one for loads and 	     one for stores.  These queues mean that loads complete in 	     their issue order as do stores.  An interaction between the 	     history buffer and the store reservation station ensures 	     that a store will not bypass load.  Finally, a load will not 	     bypass store, but only when they reference the same address.  	     To avoid this reordering (a load bypassing a store) for 	     volatile references, a serializing instruction is output. 	     We choose the fldcr instruction as it does not serialize on 	     the m88100 so that -m88000 code will not be degraded.  	     The mechanism below is completed by having CC_STATUS_INIT set 	     the code to the unknown value.  */
specifier|static
name|rtx
name|last_addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|'V'
comment|/* Only need to serialize before a load.  */
operator|&&
name|m88k_volatile_code
operator|!=
literal|'V'
comment|/* Loads complete in FIFO order.  */
operator|&&
operator|!
operator|(
name|m88k_volatile_code
operator|==
literal|'v'
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|last_addr
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
ifdef|#
directive|ifdef
name|AS_BUG_FLDCR
literal|"fldcr\t %s,%scr63\n\t"
argument_list|,
else|#
directive|else
literal|"fldcr\t %s,%sfcr63\n\t"
argument_list|,
endif|#
directive|endif
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|m88k_pound_sign
argument_list|)
expr_stmt|;
name|m88k_volatile_code
operator|=
name|code
expr_stmt|;
name|last_addr
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LO_SUM
condition|?
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
block|}
return|return;
case|case
literal|'X'
case|:
comment|/* print the upper 16 bits... */
name|value
operator|>>=
literal|16
expr_stmt|;
case|case
literal|'x'
case|:
comment|/* print the lower 16 bits of the integer constant in hex */
if|if
condition|(
name|xc
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %x/X value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x"
argument_list|,
name|value
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* print the low 16 bits of the negated integer constant */
if|if
condition|(
name|xc
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %H value"
argument_list|)
expr_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
case|case
literal|'h'
case|:
comment|/* print the register or low 16 bits of the integer constant */
if|if
condition|(
name|xc
operator|==
name|REG
condition|)
goto|goto
name|reg
goto|;
if|if
condition|(
name|xc
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %h value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|value
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Q'
case|:
comment|/* print the low 8 bits of the negated integer constant */
if|if
condition|(
name|xc
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %Q value"
argument_list|)
expr_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
case|case
literal|'q'
case|:
comment|/* print the register or low 8 bits of the integer constant */
if|if
condition|(
name|xc
operator|==
name|REG
condition|)
goto|goto
name|reg
goto|;
if|if
condition|(
name|xc
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %q value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'w'
case|:
comment|/* print the integer constant (X == 32 ? 0 : 32 - X) */
if|if
condition|(
name|xc
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %o value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|value
operator|==
literal|32
condition|?
literal|0
else|:
literal|32
operator|-
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'p'
case|:
comment|/* print the logarithm of the integer constant */
if|if
condition|(
name|xc
operator|!=
name|CONST_INT
operator|||
operator|(
name|value
operator|=
name|exact_log2
argument_list|(
name|value
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %p value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* compliment the value and then... */
name|value
operator|=
operator|~
name|value
expr_stmt|;
case|case
literal|'s'
case|:
comment|/* print the width and offset values forming the integer 		 constant with a SET instruction.  See integer_ok_for_set. */
block|{
specifier|register
name|unsigned
name|mask
decl_stmt|,
name|uval
init|=
name|value
decl_stmt|;
specifier|register
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|;
if|if
condition|(
name|xc
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %s/S value"
argument_list|)
expr_stmt|;
comment|/* All the "one" bits must be contiguous.  If so, MASK will be 	   a power of two or zero.  */
name|mask
operator|=
operator|(
name|uval
operator||
operator|(
name|uval
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|uval
operator|&&
name|POWER_OF_2_or_0
argument_list|(
name|mask
argument_list|)
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %s/S value"
argument_list|)
expr_stmt|;
name|top
operator|=
name|mask
condition|?
name|exact_log2
argument_list|(
name|mask
argument_list|)
else|:
literal|32
expr_stmt|;
name|bottom
operator|=
name|exact_log2
argument_list|(
name|uval
operator|&
operator|~
operator|(
name|uval
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d<%d>"
argument_list|,
name|top
operator|-
name|bottom
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'P'
case|:
comment|/* print nothing if pc_rtx; output label_ref */
if|if
condition|(
name|xc
operator|==
name|LABEL_REF
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xc
operator|!=
name|PC
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %P operand"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
comment|/* print 0 or 1 if operand is label_ref and then...  */
name|fputc
argument_list|(
name|xc
operator|==
name|LABEL_REF
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|file
argument_list|)
expr_stmt|;
case|case
literal|'.'
case|:
comment|/* print .n if delay slot is used */
name|fputs
argument_list|(
operator|(
name|final_sequence
operator|&&
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|?
literal|".n\t"
else|:
literal|"\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
comment|/* reverse the condition of the next print_operand 		 if operand is a label_ref.  */
name|sequencep
operator|++
expr_stmt|;
name|reversep
operator|=
operator|(
name|xc
operator|==
name|LABEL_REF
operator|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
comment|/* bcnd branch values */
name|fputs
argument_list|(
name|m88k_pound_sign
argument_list|,
name|file
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xc
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %B value"
argument_list|)
expr_stmt|;
block|}
case|case
literal|'C'
case|:
comment|/* bb0/bb1 branch values for comparisons */
name|fputs
argument_list|(
name|m88k_pound_sign
argument_list|,
name|file
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xc
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"gt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"hi"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"ls"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"lo"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"hs"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %C value"
argument_list|)
expr_stmt|;
block|}
case|case
literal|'D'
case|:
comment|/* bcnd branch values for float comparisons */
switch|switch
condition|(
name|xc
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"0xa"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"0x5"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GT
case|:
name|fputs
argument_list|(
name|m88k_pound_sign
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"gt0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"0xe"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"0x4"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"0xb"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %D value"
argument_list|)
expr_stmt|;
block|}
case|case
literal|'E'
case|:
comment|/* bcnd branch values for special integers */
switch|switch
condition|(
name|xc
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"0x8"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"0x7"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %E value"
argument_list|)
expr_stmt|;
block|}
case|case
literal|'d'
case|:
comment|/* second register of a two register pair */
if|if
condition|(
name|xc
operator|!=
name|REG
condition|)
name|output_operand_lossage
argument_list|(
literal|"`%d' operand isn't a register"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
comment|/* an immediate 0 should be represented as `r0' */
if|if
condition|(
name|x
operator|==
name|const0_rtx
condition|)
block|{
name|fputs
argument_list|(
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|xc
operator|!=
name|REG
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %r value"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|name
label|:
if|if
condition|(
name|xc
operator|==
name|REG
condition|)
block|{
name|reg
label|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand is r0"
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xc
operator|==
name|PLUS
condition|)
name|output_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xc
operator|==
name|MEM
condition|)
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xc
operator|==
name|CONST_DOUBLE
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand is const_double"
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'g'
case|:
comment|/* append #got_rel as needed */
if|if
condition|(
name|flag_pic
operator|&&
operator|(
name|xc
operator|==
name|SYMBOL_REF
operator|||
name|xc
operator|==
name|LABEL_REF
operator|)
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#got_rel"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|name
goto|;
case|case
literal|'a'
case|:
comment|/* (standard), assume operand is an address */
case|case
literal|'c'
case|:
comment|/* (standard), assume operand is an immediate value */
case|case
literal|'l'
case|:
comment|/* (standard), assume operand is a label_ref */
case|case
literal|'n'
case|:
comment|/* (standard), like %c, except negate first */
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
specifier|register
name|rtx
name|reg0
decl_stmt|,
name|reg1
decl_stmt|,
name|temp
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_SUM
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%slo16("
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|,
name|m88k_pound_sign
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|reg0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg0
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|reg0
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tmp
init|=
name|reg0
decl_stmt|;
name|reg0
operator|=
name|reg1
expr_stmt|;
name|reg1
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|reg0
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|reg0
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|reg1
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|reg0
argument_list|)
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|reg1
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg0
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg1
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%d"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg0
argument_list|)
index|]
argument_list|,
name|INTVAL
argument_list|(
name|reg1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|mreg
init|=
name|XEXP
argument_list|(
name|reg1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|mreg
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s[%s]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg0
argument_list|)
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|mreg
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%slo16("
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg0
argument_list|)
index|]
argument_list|,
name|m88k_pound_sign
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|reg1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|reg0
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#got_rel"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s[%s]"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%shi16("
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|m88k_pound_sign
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,%d"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s,"
argument_list|,
name|reg_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SHORT_ADDRESS_P
argument_list|(
name|addr
argument_list|,
name|temp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%siw16("
argument_list|,
name|m88k_pound_sign
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

