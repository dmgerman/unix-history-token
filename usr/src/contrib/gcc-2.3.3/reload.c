begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Search an insn for pseudo regs that must be in hard regs and are not.    Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains subroutines used only from the file reload1.c.    It knows how to scan one insn for operands and values    that need to be copied into registers to make valid code.    It also finds other operands and values which are valid    but for which equivalent values in registers exist and    ought to be used instead.     Before processing the first insn of the function, call `init_reload'.     To scan an insn, call `find_reloads'.  This does two things:    1. sets up tables describing which values must be reloaded    for this insn, and what kind of hard regs they must be reloaded into;    2. optionally record the locations where those values appear in    the data, so they can be replaced properly later.    This is done only if the second arg to `find_reloads' is nonzero.     The third arg to `find_reloads' specifies the number of levels    of indirect addressing supported by the machine.  If it is zero,    indirect addressing is not valid.  If it is one, (MEM (REG n))    is valid even if (REG n) did not get a hard register; if it is two,    (MEM (MEM (REG n))) is also valid even if (REG n) did not get a    hard register, and similarly for higher values.     Then you must choose the hard regs to reload those pseudo regs into,    and generate appropriate load insns before this insn and perhaps    also store insns after this insn.  Set up the array `reload_reg_rtx'    to contain the REG rtx's for the registers you used.  In some    cases `find_reloads' will return a nonzero value in `reload_reg_rtx'    for certain reloads.  Then that tells you which register to use,    so you do not need to allocate one.  But you still do need to add extra    instructions to copy the value into and out of that register.     Finally you must call `subst_reloads' to substitute the reload reg rtx's    into the locations already recorded.  NOTE SIDE EFFECTS:     find_reloads can alter the operands of the instruction it is called on.     1. Two operands of any sort may be interchanged, if they are in a    commutative instruction.    This happens only if find_reloads thinks the instruction will compile    better that way.     2. Pseudo-registers that are equivalent to constants are replaced    with those constants if they are not in hard registers.  1 happens every time find_reloads is called. 2 happens only when REPLACE is 1, which is only when actually doing the reloads, not when just counting them.   Using a reload register for several reloads in one insn:  When an insn has reloads, it is considered as having three parts: the input reloads, the insn itself after reloading, and the output reloads. Reloads of values used in memory addresses are often needed for only one part.  When this is so, reload_when_needed records which part needs the reload. Two reloads for different parts of the insn can share the same reload register.  When a reload is used for addresses in multiple parts, or when it is an ordinary operand, it is classified as RELOAD_OTHER, and cannot share a register with any other reload.  */
end_comment

begin_define
define|#
directive|define
name|REG_OK_STRICT
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_MOVE_COST
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_MOVE_COST
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The variables set up by `find_reloads' are:     n_reloads		  number of distinct reloads needed; max reload # + 1        tables indexed by reload number    reload_in		  rtx for value to reload from    reload_out		  rtx for where to store reload-reg afterward if nec 			   (often the same as reload_in)    reload_reg_class	  enum reg_class, saying what regs to reload into    reload_inmode	  enum machine_mode; mode this operand should have 			   when reloaded, on input.    reload_outmode	  enum machine_mode; mode this operand should have 			   when reloaded, on output.    reload_strict_low	  char; currently always zero; used to mean that this 			  reload is inside a STRICT_LOW_PART, but we don't 			  need to know this anymore.    reload_optional	  char, nonzero for an optional reload. 			   Optional reloads are ignored unless the 			   value is already sitting in a register.    reload_inc		  int, positive amount to increment or decrement by if 			   reload_in is a PRE_DEC, PRE_INC, POST_DEC, POST_INC. 			   Ignored otherwise (don't assume it is zero).    reload_in_reg	  rtx.  A reg for which reload_in is the equivalent. 			   If reload_in is a symbol_ref which came from 			   reg_equiv_constant, then this is the pseudo 			   which has that symbol_ref as equivalent.    reload_reg_rtx	  rtx.  This is the register to reload into. 			   If it is zero when `find_reloads' returns, 			   you must find a suitable register in the class 			   specified by reload_reg_class, and store here 			   an rtx for that register with mode from 			   reload_inmode or reload_outmode.    reload_nocombine	  char, nonzero if this reload shouldn't be 			   combined with another reload.    reload_needed_for      rtx, operand this reload is needed for address of. 			   0 means it isn't needed for addressing.    reload_needed_for_multiple 			  int, 1 if this reload needed for more than one thing.    reload_when_needed     enum, classifies reload as needed either for 			   addressing an input reload, addressing an output, 			   for addressing a non-reloaded mem ref, 			   or for unspecified purposes (i.e., more than one 			   of the above).    reload_secondary_reload int, gives the reload number of a secondary 			   reload, when needed; otherwise -1    reload_secondary_p	  int, 1 if this is a secondary register for one 			  or more reloads.    reload_secondary_icode enum insn_code, if a secondary reload is required, 			   gives the INSN_CODE that uses the secondary 			   reload as a scratch register, or CODE_FOR_nothing 			   if the secondary reload register is to be an 			   intermediate register.  */
end_comment

begin_decl_stmt
name|int
name|n_reloads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reload_in
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reload_out
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reg_class
name|reload_reg_class
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|reload_inmode
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|reload_outmode
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|reload_strict_low
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reload_reg_rtx
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|reload_optional
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reload_inc
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reload_in_reg
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|reload_nocombine
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reload_needed_for_multiple
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reload_needed_for
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reload_when_needed
name|reload_when_needed
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reload_secondary_reload
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reload_secondary_p
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|insn_code
name|reload_secondary_icode
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the "earlyclobber" operands of the current insn    are recorded here.  */
end_comment

begin_decl_stmt
name|int
name|n_earlyclobbers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reload_earlyclobbers
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Replacing reloads.     If `replace_reloads' is nonzero, then as each reload is recorded    an entry is made for it in the table `replacements'.    Then later `subst_reloads' can look through that table and    perform all the replacements needed.  */
end_comment

begin_comment
comment|/* Nonzero means record the places to replace.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|replace_reloads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each replacement is recorded with a structure like this.  */
end_comment

begin_struct
struct|struct
name|replacement
block|{
name|rtx
modifier|*
name|where
decl_stmt|;
comment|/* Location to store in */
name|rtx
modifier|*
name|subreg_loc
decl_stmt|;
comment|/* Location of SUBREG if WHERE is inside 				   a SUBREG; 0 otherwise.  */
name|int
name|what
decl_stmt|;
comment|/* which reload this is for */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* mode it must have */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|replacement
name|replacements
index|[
name|MAX_RECOG_OPERANDS
operator|*
operator|(
operator|(
name|MAX_REGS_PER_ADDRESS
operator|*
literal|2
operator|)
operator|+
literal|1
operator|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of replacements currently recorded.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_replacements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MEM-rtx's created for pseudo-regs in stack slots not directly addressable;    (see reg_equiv_address).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|memlocs
index|[
name|MAX_RECOG_OPERANDS
operator|*
operator|(
operator|(
name|MAX_REGS_PER_ADDRESS
operator|*
literal|2
operator|)
operator|+
literal|1
operator|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_memlocs
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
end_ifdef

begin_comment
comment|/* Save MEMs needed to copy from one class of registers to another.  One MEM    is used per mode, but normally only one or two modes are ever used.       We keep two versions, before and after register elimination.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|secondary_memlocs
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|secondary_memlocs_elim
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The instruction we are doing reloads for;    so we can test whether a register dies in it.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this instruction is a user-specified asm with operands.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_insn_is_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If hard_regs_live_known is nonzero,    we can tell which hard regs are currently live,    at least enough to succeed in choosing dummy reloads.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hard_regs_live_known
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard reg number,    element is nonegative if hard reg has been spilled.    This vector is passed to `find_reloads' as an argument    and is not changed here.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|static_reload_reg_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 in subst_reg_equivs if it changes anything.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|subst_reg_equivs_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On return from push_reload, holds the reload-number for the OUT    operand, which can be different for that from the input operand.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_reloadnum
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|alternative_allows_memconst
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|find_dummy_reload
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|find_reloads_toplev
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_reloads_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_reloads_address_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_reloads_address_part
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hard_reg_set_here_p
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* static rtx forget_volatility (); */
end_comment

begin_function_decl
specifier|static
name|rtx
name|subst_reg_equivs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|subst_indexed_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|copy_replacements
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
name|find_equiv_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_inc_amount
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
end_ifdef

begin_comment
comment|/* Determine if any secondary reloads are needed for loading (if IN_P is    non-zero) or storing (if IN_P is zero) X to or from a reload register of    register class RELOAD_CLASS in mode RELOAD_MODE.     Return the register class of a secondary reload register, or NO_REGS if    none.  *PMODE is set to the mode that the register is required in.    If the reload register is needed as a scratch register instead of an    intermediate register, *PICODE is set to the insn_code of the insn to be    used to load or store the primary reload register; otherwise *PICODE    is set to CODE_FOR_nothing.     In some cases (such as storing MQ into an external memory location on    the RT), both an intermediate register and a scratch register.  In that    case, *PICODE is set to CODE_FOR_nothing, the class for the intermediate    register is returned, and the *PTERTIARY_... variables are set to describe    the scratch register.  */
end_comment

begin_function
specifier|static
name|enum
name|reg_class
name|find_secondary_reload
parameter_list|(
name|x
parameter_list|,
name|reload_class
parameter_list|,
name|reload_mode
parameter_list|,
name|in_p
parameter_list|,
name|picode
parameter_list|,
name|pmode
parameter_list|,
name|ptertiary_class
parameter_list|,
name|ptertiary_icode
parameter_list|,
name|ptertiary_mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|reg_class
name|reload_class
decl_stmt|;
name|enum
name|machine_mode
name|reload_mode
decl_stmt|;
name|int
name|in_p
decl_stmt|;
name|enum
name|insn_code
modifier|*
name|picode
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|pmode
decl_stmt|;
name|enum
name|reg_class
modifier|*
name|ptertiary_class
decl_stmt|;
name|enum
name|insn_code
modifier|*
name|ptertiary_icode
decl_stmt|;
name|enum
name|machine_mode
modifier|*
name|ptertiary_mode
decl_stmt|;
block|{
name|enum
name|reg_class
name|class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|reload_mode
decl_stmt|;
name|enum
name|insn_code
name|icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|enum
name|reg_class
name|t_class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|machine_mode
name|t_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|insn_code
name|t_icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
comment|/* If X is a pseudo-register that has an equivalent MEM (actually, if it      is still a pseudo-register by now, it *must* have an equivalent MEM      but we don't want to assume that), use that equivalent when seeing if      a secondary reload is needed since whether or not a reload is needed      might be sensitive to the form of the MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|x
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
if|if
condition|(
name|in_p
condition|)
name|class
operator|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|reload_class
argument_list|,
name|reload_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
operator|!
name|in_p
condition|)
name|class
operator|=
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|reload_class
argument_list|,
name|reload_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we don't need any secondary registers, go away; the rest of the      values won't be used.  */
if|if
condition|(
name|class
operator|==
name|NO_REGS
condition|)
return|return
name|NO_REGS
return|;
comment|/* Get a possible insn to use.  If the predicate doesn't accept X, don't      use the insn.  */
name|icode
operator|=
operator|(
name|in_p
condition|?
name|reload_in_optab
index|[
operator|(
name|int
operator|)
name|reload_mode
index|]
else|:
name|reload_out_optab
index|[
operator|(
name|int
operator|)
name|reload_mode
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
name|in_p
index|]
operator|&&
operator|(
operator|!
operator|(
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
name|in_p
index|]
operator|)
operator|(
name|x
operator|,
name|reload_mode
operator|)
operator|)
condition|)
name|icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
comment|/* If we will be using an insn, see if it can directly handle the reload      register we will be using.  If it can, the secondary reload is for a      scratch register.  If it can't, we will use the secondary reload for      an intermediate register and require a tertiary reload for the scratch      register.  */
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* If IN_P is non-zero, the reload register will be the output in  	 operand 0.  If IN_P is zero, the reload register will be the input 	 in operand 1.  Outputs should have an initial "=", which we must 	 skip.  */
name|char
name|insn_letter
init|=
name|insn_operand_constraint
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
operator|!
name|in_p
index|]
index|[
name|in_p
index|]
decl_stmt|;
name|enum
name|reg_class
name|insn_class
init|=
operator|(
name|insn_letter
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_LETTER
argument_list|(
name|insn_letter
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|NO_REGS
operator|||
operator|(
name|in_p
operator|&&
name|insn_operand_constraint
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
operator|!
name|in_p
index|]
index|[
literal|0
index|]
operator|!=
literal|'='
operator|)
comment|/* The scratch register's constraint must start with "=&".  */
operator|||
name|insn_operand_constraint
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|!=
literal|'='
operator|||
name|insn_operand_constraint
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|!=
literal|'&'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|reload_class
argument_list|,
name|insn_class
argument_list|)
condition|)
name|mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|char
name|t_letter
init|=
name|insn_operand_constraint
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|class
operator|=
name|insn_class
expr_stmt|;
name|t_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|2
index|]
expr_stmt|;
name|t_class
operator|=
operator|(
name|t_letter
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_LETTER
argument_list|(
name|t_letter
argument_list|)
operator|)
expr_stmt|;
name|t_icode
operator|=
name|icode
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
block|}
block|}
operator|*
name|pmode
operator|=
name|mode
expr_stmt|;
operator|*
name|picode
operator|=
name|icode
expr_stmt|;
operator|*
name|ptertiary_class
operator|=
name|t_class
expr_stmt|;
operator|*
name|ptertiary_mode
operator|=
name|t_mode
expr_stmt|;
operator|*
name|ptertiary_icode
operator|=
name|t_icode
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SECONDARY_RELOADS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
end_ifdef

begin_comment
comment|/* Return a memory location that will be used to copy X in mode MODE.      If we haven't already made a location for this mode in this insn,    call find_reloads_address on the location being returned.  */
end_comment

begin_function
name|rtx
name|get_secondary_mem
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|loc
decl_stmt|;
name|int
name|mem_valid
decl_stmt|;
comment|/* If MODE is narrower than a word, widen it.  This is required because      most machines that require these memory locations do not support      short load and stores from all registers (e.g., FP registers).  We could      possibly conditionalize this, but we lose nothing by doing the wider      mode.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
condition|)
name|mode
operator|=
name|mode_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we already have made a MEM for this insn, return it.  */
if|if
condition|(
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|!=
literal|0
condition|)
return|return
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|mode
index|]
return|;
comment|/* If this is the first time we've tried to get a MEM for this mode,       allocate a new one.  `something_changed' in reload will get set      by noticing that the frame size has changed.  */
if|if
condition|(
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
condition|)
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get a version of the address doing any eliminations needed.  If that      didn't give us a new MEM, make a new one if it isn't valid.  */
name|loc
operator|=
name|eliminate_regs
argument_list|(
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|mem_valid
operator|=
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mem_valid
operator|&&
name|loc
operator|==
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
condition|)
name|loc
operator|=
name|copy_rtx
argument_list|(
name|loc
argument_list|)
expr_stmt|;
comment|/* The only time the call below will do anything is if the stack      offset is too large.  In that case IND_LEVELS doesn't matter, so we      can just pass a zero.  */
if|if
condition|(
operator|!
name|mem_valid
condition|)
name|find_reloads_address
argument_list|(
name|mode
argument_list|,
name|NULL_PTR
argument_list|,
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the address was not valid to begin with, we can not save it, because      there is no guarantee that the reloads needed to make it valid will      occur before every use of this address.  */
else|else
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|loc
expr_stmt|;
return|return
name|loc
return|;
block|}
end_function

begin_comment
comment|/* Clear any secondary memory locations we've made.  */
end_comment

begin_function
name|void
name|clear_secondary_mem
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
name|secondary_memlocs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SECONDARY_MEMORY_NEEDED */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Record one (sometimes two) reload that needs to be performed.    IN is an rtx saying where the data are to be found before this instruction.    OUT says where they must be stored after the instruction.    (IN is zero for data not read, and OUT is zero for data not written.)    INLOC and OUTLOC point to the places in the instructions where    IN and OUT were found.    CLASS is a register class required for the reloaded data.    INMODE is the machine mode that the instruction requires    for the reg that replaces IN and OUTMODE is likewise for OUT.     If IN is zero, then OUT's location and mode should be passed as    INLOC and INMODE.     STRICT_LOW is the 1 if there is a containing STRICT_LOW_PART rtx.     OPTIONAL nonzero means this reload does not need to be performed:    it can be discarded if that is more convenient.     The return value is the reload-number for this reload.     If both IN and OUT are nonzero, in some rare cases we might    want to make two separate reloads.  (Actually we never do this now.)    Therefore, the reload-number for OUT is stored in    output_reloadnum when we return; the return value applies to IN.    Usually (presently always), when IN and OUT are nonzero,    the two reload-numbers are equal, but the caller should be careful to    distinguish them.  */
end_comment

begin_function
specifier|static
name|int
name|push_reload
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|inloc
parameter_list|,
name|outloc
parameter_list|,
name|class
parameter_list|,
name|inmode
parameter_list|,
name|outmode
parameter_list|,
name|strict_low
parameter_list|,
name|optional
parameter_list|,
name|needed_for
parameter_list|)
specifier|register
name|rtx
name|in
decl_stmt|,
name|out
decl_stmt|;
name|rtx
modifier|*
name|inloc
decl_stmt|,
decl|*
name|outloc
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|reg_class
name|class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|inmode
decl_stmt|,
name|outmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strict_low
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|optional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|needed_for
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|dont_share
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|in_subreg_loc
init|=
literal|0
decl_stmt|,
modifier|*
name|out_subreg_loc
init|=
literal|0
decl_stmt|;
name|int
name|secondary_reload
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|insn_code
name|secondary_icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
comment|/* Compare two RTX's.  */
define|#
directive|define
name|MATCHES
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(x == y || (x != 0&& (GET_CODE (x) == REG				\ 			? GET_CODE (y) == REG&& REGNO (x) == REGNO (y)	\ 			: rtx_equal_p (x, y)&& ! side_effects_p (x))))
comment|/* INMODE and/or OUTMODE could be VOIDmode if no mode      has been specified for the operand.  In that case,      use the operand's mode as the mode to reload.  */
if|if
condition|(
name|inmode
operator|==
name|VOIDmode
operator|&&
name|in
operator|!=
literal|0
condition|)
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|outmode
operator|==
name|VOIDmode
operator|&&
name|out
operator|!=
literal|0
condition|)
name|outmode
operator|=
name|GET_MODE
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* If IN is a pseudo register everywhere-equivalent to a constant, and       it is not in a hard register, reload straight from the constant,      since we want to get rid of such pseudo registers.      Often this is done earlier, but not always in find_reloads_address.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|in
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
block|}
comment|/* Likewise for OUT.  Of course, OUT will never be equivalent to      an actual constant, but it might be equivalent to a memory location      (in the case of a parameter).  */
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|out
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|out
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
block|}
comment|/* If we have a read-write operand with an address side-effect,      change either IN or OUT so the side-effect happens only once.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
condition|)
name|in
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|out
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are reloading a (SUBREG (MEM ...) ...) or (SUBREG constant ...),      really reload just the inside expression in its own mode.      If we have (SUBREG:M1 (REG:M2 ...) ...) with M1 wider than M2 and the      register is a pseudo, this will become the same as the above case.      Do the same for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where      either M1 is not valid for R or M2 is wider than a word but we only      need one word to store an M2-sized quantity in R.      Note that the case of (SUBREG (CONST_INT...)...) is handled elsewhere;      we can't handle it here because CONST_INT does not indicate a mode.       Similarly, we must reload the inside expression if we have a      STRICT_LOW_PART (presumably, in == out in the cas).       Also reload the inner expression if it does not require a secondary      reload but the SUBREG does.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|strict_low
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|inmode
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|!=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|inmode
argument_list|,
name|in
argument_list|)
operator|!=
name|NO_REGS
operator|&&
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|NO_REGS
operator|)
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|in_subreg_loc
operator|=
name|inloc
expr_stmt|;
name|inloc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|=
operator|*
name|inloc
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
condition|)
comment|/* This is supposed to happen only for paradoxical subregs made by 	   combine.c.  (SUBREG (MEM)) isn't supposed to occur other ways.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly for paradoxical and problematical SUBREGs on the output.      Note that there is no reason we need worry about the previous value      of SUBREG_REG (out); even if wider than out,      storing in a subreg is entitled to clobber it all      (except in the case of STRICT_LOW_PART,      and in that case the constraint should label it input-output.)  */
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|strict_low
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|outmode
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|!=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|outmode
argument_list|,
name|out
argument_list|)
operator|!=
name|NO_REGS
operator|&&
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|NO_REGS
operator|)
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|out_subreg_loc
operator|=
name|outloc
expr_stmt|;
name|outloc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|=
operator|*
name|outloc
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|outmode
operator|=
name|GET_MODE
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* That's all we use STRICT_LOW for, so clear it.  At some point,      we may want to get rid of reload_strict_low.  */
name|strict_low
operator|=
literal|0
expr_stmt|;
comment|/* If IN appears in OUT, we can't share any input-only reload for IN.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|in
argument_list|,
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|dont_share
operator|=
literal|1
expr_stmt|;
comment|/* If IN is a SUBREG of a hard register, make a new REG.  This      simplifies some of the cases below.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|in
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Similarly for OUT.  */
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|out
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Narrow down the class of register wanted if that is      desirable on this machine for efficiency.  */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
name|class
operator|=
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|in
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* Output reloads may need analagous treatment, different in detail.  */
ifdef|#
directive|ifdef
name|PREFERRED_OUTPUT_RELOAD_CLASS
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
name|class
operator|=
name|PREFERRED_OUTPUT_RELOAD_CLASS
argument_list|(
name|out
argument_list|,
name|class
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure we use a class that can handle the actual pseudo      inside any subreg.  For example, on the 386, QImode regs      can appear within SImode subregs.  Although GENERAL_REGS      can handle SImode, QImode needs a smaller class.  */
ifdef|#
directive|ifdef
name|LIMIT_RELOAD_CLASS
if|if
condition|(
name|in_subreg_loc
condition|)
name|class
operator|=
name|LIMIT_RELOAD_CLASS
argument_list|(
name|inmode
argument_list|,
name|class
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
name|class
operator|=
name|LIMIT_RELOAD_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_subreg_loc
condition|)
name|class
operator|=
name|LIMIT_RELOAD_CLASS
argument_list|(
name|outmode
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
condition|)
name|class
operator|=
name|LIMIT_RELOAD_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|class
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|class
operator|==
name|NO_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Verify that this class is at least possible for the mode that      is specified.  */
if|if
condition|(
name|this_insn_is_asm
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
condition|)
name|mode
operator|=
name|inmode
expr_stmt|;
else|else
name|mode
operator|=
name|outmode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nregs
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|i
operator|+
name|j
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nregs
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|error_for_asm
argument_list|(
name|this_insn
argument_list|,
literal|"impossible register constraint in `asm'"
argument_list|)
expr_stmt|;
name|class
operator|=
name|ALL_REGS
expr_stmt|;
block|}
block|}
comment|/* We can use an existing reload if the class is right      and at least one of IN and OUT is a match      and the other is at worst neutral.      (A zero compared against anything is neutral.)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|reload_reg_class
index|[
name|i
index|]
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|reload_reg_class
index|[
name|i
index|]
argument_list|,
name|class
argument_list|)
operator|)
operator|&&
name|reload_strict_low
index|[
name|i
index|]
operator|==
name|strict_low
comment|/* If the existing reload has a register, it must fit our class.  */
operator|&&
operator|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|in
operator|!=
literal|0
operator|&&
name|MATCHES
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|in
argument_list|)
operator|&&
operator|!
name|dont_share
operator|&&
operator|(
name|out
operator|==
literal|0
operator|||
name|reload_out
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|MATCHES
argument_list|(
name|reload_out
index|[
name|i
index|]
argument_list|,
name|out
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|out
operator|!=
literal|0
operator|&&
name|MATCHES
argument_list|(
name|reload_out
index|[
name|i
index|]
argument_list|,
name|out
argument_list|)
operator|&&
operator|(
name|in
operator|==
literal|0
operator|||
name|reload_in
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|MATCHES
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|in
argument_list|)
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Reloading a plain reg for input can match a reload to postincrement      that reg, since the postincrement's value is the right value.      Likewise, it can match a preincrement reload, since we regard      the preincrementation as happening before any ref in this insn      to that register.  */
if|if
condition|(
name|i
operator|==
name|n_reloads
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|reload_reg_class
index|[
name|i
index|]
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|reload_reg_class
index|[
name|i
index|]
argument_list|,
name|class
argument_list|)
operator|)
comment|/* If the existing reload has a register, it must fit our class.  */
operator|&&
operator|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|true_regnum
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
name|reload_strict_low
index|[
name|i
index|]
operator|==
name|strict_low
operator|&&
name|out
operator|==
literal|0
operator|&&
name|reload_out
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|)
operator|==
name|PRE_DEC
operator|)
operator|&&
name|MATCHES
argument_list|(
name|XEXP
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PRE_DEC
operator|)
operator|&&
name|MATCHES
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reload_in
index|[
name|i
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure reload_in ultimately has the increment, 	     not the plain register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
name|in
operator|=
name|reload_in
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|n_reloads
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
name|enum
name|reg_class
name|secondary_class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|reg_class
name|secondary_out_class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|machine_mode
name|secondary_mode
init|=
name|inmode
decl_stmt|;
name|enum
name|machine_mode
name|secondary_out_mode
init|=
name|outmode
decl_stmt|;
name|enum
name|insn_code
name|secondary_icode
decl_stmt|;
name|enum
name|insn_code
name|secondary_out_icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|enum
name|reg_class
name|tertiary_class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|reg_class
name|tertiary_out_class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|machine_mode
name|tertiary_mode
decl_stmt|;
name|enum
name|machine_mode
name|tertiary_out_mode
decl_stmt|;
name|enum
name|insn_code
name|tertiary_icode
decl_stmt|;
name|enum
name|insn_code
name|tertiary_out_icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|int
name|tertiary_reload
init|=
operator|-
literal|1
decl_stmt|;
comment|/* See if we need a secondary reload register to move between 	 CLASS and IN or CLASS and OUT.  Get the modes and icodes to 	 use for each of them if so.  */
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
name|secondary_class
operator|=
name|find_secondary_reload
argument_list|(
name|in
argument_list|,
name|class
argument_list|,
name|inmode
argument_list|,
literal|1
argument_list|,
operator|&
name|secondary_icode
argument_list|,
operator|&
name|secondary_mode
argument_list|,
operator|&
name|tertiary_class
argument_list|,
operator|&
name|tertiary_icode
argument_list|,
operator|&
name|tertiary_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|!=
name|SCRATCH
condition|)
name|secondary_out_class
operator|=
name|find_secondary_reload
argument_list|(
name|out
argument_list|,
name|class
argument_list|,
name|outmode
argument_list|,
literal|0
argument_list|,
operator|&
name|secondary_out_icode
argument_list|,
operator|&
name|secondary_out_mode
argument_list|,
operator|&
name|tertiary_out_class
argument_list|,
operator|&
name|tertiary_out_icode
argument_list|,
operator|&
name|tertiary_out_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We can only record one secondary and one tertiary reload.  If both 	 IN and OUT need secondary reloads, we can only make an in-out 	 reload if neither need an insn and if the classes are compatible.  */
if|if
condition|(
name|secondary_class
operator|!=
name|NO_REGS
operator|&&
name|secondary_out_class
operator|!=
name|NO_REGS
operator|&&
name|reg_class_subset_p
argument_list|(
name|secondary_out_class
argument_list|,
name|secondary_class
argument_list|)
condition|)
name|secondary_class
operator|=
name|secondary_out_class
expr_stmt|;
if|if
condition|(
name|secondary_class
operator|!=
name|NO_REGS
operator|&&
name|secondary_out_class
operator|!=
name|NO_REGS
operator|&&
operator|(
operator|!
name|reg_class_subset_p
argument_list|(
name|secondary_class
argument_list|,
name|secondary_out_class
argument_list|)
operator|||
name|secondary_icode
operator|!=
name|CODE_FOR_nothing
operator|||
name|secondary_out_icode
operator|!=
name|CODE_FOR_nothing
operator|)
condition|)
block|{
name|push_reload
argument_list|(
name|NULL_RTX
argument_list|,
name|out
argument_list|,
name|NULL_PTR
argument_list|,
name|outloc
argument_list|,
name|class
argument_list|,
name|VOIDmode
argument_list|,
name|outmode
argument_list|,
name|strict_low
argument_list|,
name|optional
argument_list|,
name|needed_for
argument_list|)
expr_stmt|;
name|out
operator|=
literal|0
expr_stmt|;
name|outloc
operator|=
literal|0
expr_stmt|;
name|outmode
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* If we need a secondary reload for OUT but not IN, copy the 	 information.  */
if|if
condition|(
name|secondary_class
operator|==
name|NO_REGS
operator|&&
name|secondary_out_class
operator|!=
name|NO_REGS
condition|)
block|{
name|secondary_class
operator|=
name|secondary_out_class
expr_stmt|;
name|secondary_icode
operator|=
name|secondary_out_icode
expr_stmt|;
name|tertiary_class
operator|=
name|tertiary_out_class
expr_stmt|;
name|tertiary_icode
operator|=
name|tertiary_out_icode
expr_stmt|;
name|tertiary_mode
operator|=
name|tertiary_out_mode
expr_stmt|;
block|}
if|if
condition|(
name|secondary_class
operator|!=
name|NO_REGS
condition|)
block|{
comment|/* If we need a tertiary reload, see if we have one we can reuse 	     or else make one.  */
if|if
condition|(
name|tertiary_class
operator|!=
name|NO_REGS
condition|)
block|{
for|for
control|(
name|tertiary_reload
operator|=
literal|0
init|;
name|tertiary_reload
operator|<
name|n_reloads
condition|;
name|tertiary_reload
operator|++
control|)
if|if
condition|(
name|reload_secondary_p
index|[
name|tertiary_reload
index|]
operator|&&
operator|(
name|reg_class_subset_p
argument_list|(
name|tertiary_class
argument_list|,
name|reload_reg_class
index|[
name|tertiary_reload
index|]
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|reload_reg_class
index|[
name|tertiary_reload
index|]
argument_list|,
name|tertiary_class
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|reload_inmode
index|[
name|tertiary_reload
index|]
operator|==
name|tertiary_mode
operator|)
operator|||
name|reload_inmode
index|[
name|tertiary_reload
index|]
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
operator|(
name|reload_outmode
index|[
name|tertiary_reload
index|]
operator|==
name|tertiary_mode
operator|)
operator|||
name|reload_outmode
index|[
name|tertiary_reload
index|]
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|reload_secondary_icode
index|[
name|tertiary_reload
index|]
operator|==
name|CODE_FOR_nothing
operator|)
condition|)
block|{
if|if
condition|(
name|tertiary_mode
operator|!=
name|VOIDmode
condition|)
name|reload_inmode
index|[
name|tertiary_reload
index|]
operator|=
name|tertiary_mode
expr_stmt|;
if|if
condition|(
name|tertiary_out_mode
operator|!=
name|VOIDmode
condition|)
name|reload_outmode
index|[
name|tertiary_reload
index|]
operator|=
name|tertiary_mode
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|tertiary_class
argument_list|,
name|reload_reg_class
index|[
name|tertiary_reload
index|]
argument_list|)
condition|)
name|reload_reg_class
index|[
name|tertiary_reload
index|]
operator|=
name|tertiary_class
expr_stmt|;
if|if
condition|(
name|reload_needed_for
index|[
name|tertiary_reload
index|]
operator|!=
name|needed_for
condition|)
name|reload_needed_for_multiple
index|[
name|tertiary_reload
index|]
operator|=
literal|1
expr_stmt|;
name|reload_optional
index|[
name|tertiary_reload
index|]
operator|&=
name|optional
expr_stmt|;
name|reload_secondary_p
index|[
name|tertiary_reload
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tertiary_reload
operator|==
name|n_reloads
condition|)
block|{
comment|/* We need to make a new tertiary reload for this register 		     class.  */
name|reload_in
index|[
name|tertiary_reload
index|]
operator|=
name|reload_out
index|[
name|tertiary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_reg_class
index|[
name|tertiary_reload
index|]
operator|=
name|tertiary_class
expr_stmt|;
name|reload_inmode
index|[
name|tertiary_reload
index|]
operator|=
name|tertiary_mode
expr_stmt|;
name|reload_outmode
index|[
name|tertiary_reload
index|]
operator|=
name|tertiary_mode
expr_stmt|;
name|reload_reg_rtx
index|[
name|tertiary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_optional
index|[
name|tertiary_reload
index|]
operator|=
name|optional
expr_stmt|;
name|reload_inc
index|[
name|tertiary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_strict_low
index|[
name|tertiary_reload
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Maybe we could combine these, but it seems too tricky.  */
name|reload_nocombine
index|[
name|tertiary_reload
index|]
operator|=
literal|1
expr_stmt|;
name|reload_in_reg
index|[
name|tertiary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_needed_for
index|[
name|tertiary_reload
index|]
operator|=
name|needed_for
expr_stmt|;
name|reload_needed_for_multiple
index|[
name|tertiary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_secondary_reload
index|[
name|tertiary_reload
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reload_secondary_icode
index|[
name|tertiary_reload
index|]
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|reload_secondary_p
index|[
name|tertiary_reload
index|]
operator|=
literal|1
expr_stmt|;
name|n_reloads
operator|++
expr_stmt|;
name|i
operator|=
name|n_reloads
expr_stmt|;
block|}
block|}
comment|/* See if we can reuse an existing secondary reload.  */
for|for
control|(
name|secondary_reload
operator|=
literal|0
init|;
name|secondary_reload
operator|<
name|n_reloads
condition|;
name|secondary_reload
operator|++
control|)
if|if
condition|(
name|reload_secondary_p
index|[
name|secondary_reload
index|]
operator|&&
operator|(
name|reg_class_subset_p
argument_list|(
name|secondary_class
argument_list|,
name|reload_reg_class
index|[
name|secondary_reload
index|]
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|reload_reg_class
index|[
name|secondary_reload
index|]
argument_list|,
name|secondary_class
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|reload_inmode
index|[
name|secondary_reload
index|]
operator|==
name|secondary_mode
operator|)
operator|||
name|reload_inmode
index|[
name|secondary_reload
index|]
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
operator|(
name|reload_outmode
index|[
name|secondary_reload
index|]
operator|==
name|secondary_out_mode
operator|)
operator|||
name|reload_outmode
index|[
name|secondary_reload
index|]
operator|==
name|VOIDmode
operator|)
operator|&&
name|reload_secondary_reload
index|[
name|secondary_reload
index|]
operator|==
name|tertiary_reload
operator|&&
name|reload_secondary_icode
index|[
name|secondary_reload
index|]
operator|==
name|tertiary_icode
condition|)
block|{
if|if
condition|(
name|secondary_mode
operator|!=
name|VOIDmode
condition|)
name|reload_inmode
index|[
name|secondary_reload
index|]
operator|=
name|secondary_mode
expr_stmt|;
if|if
condition|(
name|secondary_out_mode
operator|!=
name|VOIDmode
condition|)
name|reload_outmode
index|[
name|secondary_reload
index|]
operator|=
name|secondary_out_mode
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|secondary_class
argument_list|,
name|reload_reg_class
index|[
name|secondary_reload
index|]
argument_list|)
condition|)
name|reload_reg_class
index|[
name|secondary_reload
index|]
operator|=
name|secondary_class
expr_stmt|;
if|if
condition|(
name|reload_needed_for
index|[
name|secondary_reload
index|]
operator|!=
name|needed_for
condition|)
name|reload_needed_for_multiple
index|[
name|secondary_reload
index|]
operator|=
literal|1
expr_stmt|;
name|reload_optional
index|[
name|secondary_reload
index|]
operator|&=
name|optional
expr_stmt|;
name|reload_secondary_p
index|[
name|secondary_reload
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|secondary_reload
operator|==
name|n_reloads
condition|)
block|{
comment|/* We need to make a new secondary reload for this register 		 class.  */
name|reload_in
index|[
name|secondary_reload
index|]
operator|=
name|reload_out
index|[
name|secondary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_reg_class
index|[
name|secondary_reload
index|]
operator|=
name|secondary_class
expr_stmt|;
name|reload_inmode
index|[
name|secondary_reload
index|]
operator|=
name|secondary_mode
expr_stmt|;
name|reload_outmode
index|[
name|secondary_reload
index|]
operator|=
name|secondary_out_mode
expr_stmt|;
name|reload_reg_rtx
index|[
name|secondary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_optional
index|[
name|secondary_reload
index|]
operator|=
name|optional
expr_stmt|;
name|reload_inc
index|[
name|secondary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_strict_low
index|[
name|secondary_reload
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Maybe we could combine these, but it seems too tricky.  */
name|reload_nocombine
index|[
name|secondary_reload
index|]
operator|=
literal|1
expr_stmt|;
name|reload_in_reg
index|[
name|secondary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_needed_for
index|[
name|secondary_reload
index|]
operator|=
name|needed_for
expr_stmt|;
name|reload_needed_for_multiple
index|[
name|secondary_reload
index|]
operator|=
literal|0
expr_stmt|;
name|reload_secondary_reload
index|[
name|secondary_reload
index|]
operator|=
name|tertiary_reload
expr_stmt|;
name|reload_secondary_icode
index|[
name|secondary_reload
index|]
operator|=
name|tertiary_icode
expr_stmt|;
name|reload_secondary_p
index|[
name|secondary_reload
index|]
operator|=
literal|1
expr_stmt|;
name|n_reloads
operator|++
expr_stmt|;
name|i
operator|=
name|n_reloads
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* If we need a memory location to copy between the two 		 reload regs, set it up now.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|secondary_icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|secondary_class
argument_list|,
name|class
argument_list|,
name|inmode
argument_list|)
condition|)
name|get_secondary_mem
argument_list|(
name|in
argument_list|,
name|inmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|secondary_icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|class
argument_list|,
name|secondary_class
argument_list|,
name|outmode
argument_list|)
condition|)
name|get_secondary_mem
argument_list|(
name|out
argument_list|,
name|outmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* We found no existing reload suitable for re-use. 	 So add an additional reload.  */
name|reload_in
index|[
name|i
index|]
operator|=
name|in
expr_stmt|;
name|reload_out
index|[
name|i
index|]
operator|=
name|out
expr_stmt|;
name|reload_reg_class
index|[
name|i
index|]
operator|=
name|class
expr_stmt|;
name|reload_inmode
index|[
name|i
index|]
operator|=
name|inmode
expr_stmt|;
name|reload_outmode
index|[
name|i
index|]
operator|=
name|outmode
expr_stmt|;
name|reload_reg_rtx
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reload_optional
index|[
name|i
index|]
operator|=
name|optional
expr_stmt|;
name|reload_inc
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reload_strict_low
index|[
name|i
index|]
operator|=
name|strict_low
expr_stmt|;
name|reload_nocombine
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reload_in_reg
index|[
name|i
index|]
operator|=
name|inloc
condition|?
operator|*
name|inloc
else|:
literal|0
expr_stmt|;
name|reload_needed_for
index|[
name|i
index|]
operator|=
name|needed_for
expr_stmt|;
name|reload_needed_for_multiple
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|reload_secondary_reload
index|[
name|i
index|]
operator|=
name|secondary_reload
expr_stmt|;
name|reload_secondary_icode
index|[
name|i
index|]
operator|=
name|secondary_icode
expr_stmt|;
name|reload_secondary_p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|n_reloads
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* If a memory location is needed for the copy, make one.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|class
argument_list|,
name|inmode
argument_list|)
condition|)
name|get_secondary_mem
argument_list|(
name|in
argument_list|,
name|inmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|class
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|outmode
argument_list|)
condition|)
name|get_secondary_mem
argument_list|(
name|out
argument_list|,
name|outmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We are reusing an existing reload, 	 but we may have additional information for it. 	 For example, we may now have both IN and OUT 	 while the old one may have just one of them.  */
if|if
condition|(
name|inmode
operator|!=
name|VOIDmode
condition|)
name|reload_inmode
index|[
name|i
index|]
operator|=
name|inmode
expr_stmt|;
if|if
condition|(
name|outmode
operator|!=
name|VOIDmode
condition|)
name|reload_outmode
index|[
name|i
index|]
operator|=
name|outmode
expr_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
name|reload_in
index|[
name|i
index|]
operator|=
name|in
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
name|reload_out
index|[
name|i
index|]
operator|=
name|out
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|reload_reg_class
index|[
name|i
index|]
argument_list|)
condition|)
name|reload_reg_class
index|[
name|i
index|]
operator|=
name|class
expr_stmt|;
name|reload_optional
index|[
name|i
index|]
operator|&=
name|optional
expr_stmt|;
if|if
condition|(
name|reload_needed_for
index|[
name|i
index|]
operator|!=
name|needed_for
condition|)
name|reload_needed_for_multiple
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the ostensible rtx being reload differs from the rtx found      in the location to substitute, this reload is not safe to combine      because we cannot reliably tell whether it appears in the insn.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|in
operator|!=
operator|*
name|inloc
condition|)
name|reload_nocombine
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This was replaced by changes in find_reloads_address_1 and the new      function inc_for_reload, which go with a new meaning of reload_inc.  */
comment|/* If this is an IN/OUT reload in an insn that sets the CC,      it must be for an autoincrement.  It doesn't work to store      the incremented value after the insn because that would clobber the CC.      So we must do the increment of the value reloaded from,      increment it, store it back, then decrement again.  */
block|if (out != 0&& sets_cc0_p (PATTERN (this_insn)))     {       out = 0;       reload_out[i] = 0;       reload_inc[i] = find_inc_amount (PATTERN (this_insn), in);
comment|/* If we did not find a nonzero amount-to-increment-by, 	 that contradicts the belief that IN is being incremented 	 in an address in this insn.  */
block|if (reload_inc[i] == 0) 	abort ();     }
endif|#
directive|endif
comment|/* If we will replace IN and OUT with the reload-reg,      record where they are located so that substitution need      not do a tree walk.  */
if|if
condition|(
name|replace_reloads
condition|)
block|{
if|if
condition|(
name|inloc
operator|!=
literal|0
condition|)
block|{
specifier|register
name|struct
name|replacement
modifier|*
name|r
init|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
decl_stmt|;
name|r
operator|->
name|what
operator|=
name|i
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
name|in_subreg_loc
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|inloc
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|inmode
expr_stmt|;
block|}
if|if
condition|(
name|outloc
operator|!=
literal|0
operator|&&
name|outloc
operator|!=
name|inloc
condition|)
block|{
specifier|register
name|struct
name|replacement
modifier|*
name|r
init|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
decl_stmt|;
name|r
operator|->
name|what
operator|=
name|i
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|outloc
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
name|out_subreg_loc
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|outmode
expr_stmt|;
block|}
block|}
comment|/* If this reload is just being introduced and it has both      an incoming quantity and an outgoing quantity that are      supposed to be made to match, see if either one of the two      can serve as the place to reload into.       If one of them is acceptable, set reload_reg_rtx[i]      to that one.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|out
operator|!=
literal|0
operator|&&
name|in
operator|!=
name|out
operator|&&
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|reload_reg_rtx
index|[
name|i
index|]
operator|=
name|find_dummy_reload
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|inloc
argument_list|,
name|outloc
argument_list|,
name|reload_reg_class
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If the outgoing register already contains the same value 	 as the incoming one, we can dispense with loading it. 	 The easiest way to tell the caller that is to give a phony 	 value for the incoming operand (same as outgoing one).  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
name|out
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|||
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
name|find_equiv_reg
argument_list|(
name|in
argument_list|,
name|this_insn
argument_list|,
literal|0
argument_list|,
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|,
name|static_reload_reg_p
argument_list|,
name|i
argument_list|,
name|inmode
argument_list|)
condition|)
name|reload_in
index|[
name|i
index|]
operator|=
name|out
expr_stmt|;
block|}
comment|/* If this is an input reload and the operand contains a register that      dies in this insn and is used nowhere else, see if it is the right class      to be used for this reload.  Use it if so.  (This occurs most commonly      in the case of paradoxical SUBREGs and in-out reloads).  We cannot do      this if it is also an output reload that mentions the register unless      the output is a SUBREG that clobbers an entire register.       Note that the operand might be one of the spill regs, if it is a      pseudo reg and we are in a block where spilling has not taken place.      But if there is no spilling in this block, that is OK.      An explicitly used hard reg cannot be a spill reg.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|in
operator|!=
literal|0
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|this_insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
argument_list|)
operator|&&
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
operator|(
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|inmode
argument_list|)
operator|)
argument_list|,
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|inloc
argument_list|)
operator|&&
operator|(
name|in
operator|!=
name|out
operator|||
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
operator|)
comment|/* Make sure the operand fits in the reg that dies.  */
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|inmode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|outmode
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
name|reload_reg_rtx
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|inmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|out
condition|)
name|output_reloadnum
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/* Record an additional place we must replace a value    for which we have already recorded a reload.    RELOADNUM is the value returned by push_reload    when the reload was recorded.    This is used in insn patterns that use match_dup.  */
end_comment

begin_function
specifier|static
name|void
name|push_replacement
parameter_list|(
name|loc
parameter_list|,
name|reloadnum
parameter_list|,
name|mode
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|replace_reloads
condition|)
block|{
specifier|register
name|struct
name|replacement
modifier|*
name|r
init|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
decl_stmt|;
name|r
operator|->
name|what
operator|=
name|reloadnum
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|loc
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If there is only one output reload, and it is not for an earlyclobber    operand, try to combine it with a (logically unrelated) input reload    to reduce the number of reload registers needed.     This is safe if the input reload does not appear in    the value being output-reloaded, because this implies    it is not needed any more once the original insn completes.     If that doesn't work, see we can use any of the registers that    die in this insn as a reload register.  We can if it is of the right    class and does not appear in the value being output-reloaded.  */
end_comment

begin_function
specifier|static
name|void
name|combine_reloads
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|output_reload
init|=
operator|-
literal|1
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Find the output reload; return unless there is exactly one      and that one is mandatory.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_out
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|output_reload
operator|>=
literal|0
condition|)
return|return;
name|output_reload
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|output_reload
operator|<
literal|0
operator|||
name|reload_optional
index|[
name|output_reload
index|]
condition|)
return|return;
comment|/* An input-output reload isn't combinable.  */
if|if
condition|(
name|reload_in
index|[
name|output_reload
index|]
operator|!=
literal|0
condition|)
return|return;
comment|/* If this reload is for an earlyclobber operand, we can't do anything.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_earlyclobbers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_out
index|[
name|output_reload
index|]
operator|==
name|reload_earlyclobbers
index|[
name|i
index|]
condition|)
return|return;
comment|/* Check each input reload; can we combine it?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_in
index|[
name|i
index|]
operator|&&
operator|!
name|reload_optional
index|[
name|i
index|]
operator|&&
operator|!
name|reload_nocombine
index|[
name|i
index|]
comment|/* Life span of this reload must not extend past main insn.  */
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_OUTPUT_RELOAD_ADDRESS
operator|&&
operator|!
name|reload_needed_for_multiple
index|[
name|i
index|]
operator|&&
name|reload_inmode
index|[
name|i
index|]
operator|==
name|reload_outmode
index|[
name|output_reload
index|]
operator|&&
name|reload_inc
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reload_strict_low
index|[
name|i
index|]
operator|==
literal|0
comment|/* Don't combine two reloads with different secondary reloads. */
operator|&&
operator|(
name|reload_secondary_reload
index|[
name|i
index|]
operator|==
name|reload_secondary_reload
index|[
name|output_reload
index|]
operator|||
name|reload_secondary_reload
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|||
name|reload_secondary_reload
index|[
name|output_reload
index|]
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|reg_class_subset_p
argument_list|(
name|reload_reg_class
index|[
name|i
index|]
argument_list|,
name|reload_reg_class
index|[
name|output_reload
index|]
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|reload_reg_class
index|[
name|output_reload
index|]
argument_list|,
name|reload_reg_class
index|[
name|i
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|MATCHES
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|reload_out
index|[
name|output_reload
index|]
argument_list|)
comment|/* Args reversed because the first arg seems to be 	       the one that we imagine being modified 	       while the second is the one that might be affected.  */
operator|||
operator|(
operator|!
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reload_out
index|[
name|output_reload
index|]
argument_list|,
name|reload_in
index|[
name|i
index|]
argument_list|)
comment|/* However, if the input is a register that appears inside 		   the output, then we also can't share. 		   Imagine (set (mem (reg 69)) (plus (reg 69) ...)). 		   If the same reload reg is used for both reg 69 and the 		   result to be stored in memory, then that result 		   will clobber the address of the memory ref.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|reload_in
index|[
name|i
index|]
argument_list|,
name|reload_out
index|[
name|output_reload
index|]
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* We have found a reload to combine with!  */
name|reload_out
index|[
name|i
index|]
operator|=
name|reload_out
index|[
name|output_reload
index|]
expr_stmt|;
name|reload_outmode
index|[
name|i
index|]
operator|=
name|reload_outmode
index|[
name|output_reload
index|]
expr_stmt|;
comment|/* Mark the old output reload as inoperative.  */
name|reload_out
index|[
name|output_reload
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The combined reload is needed for the entire insn.  */
name|reload_needed_for_multiple
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|reload_when_needed
index|[
name|i
index|]
operator|=
name|RELOAD_OTHER
expr_stmt|;
comment|/* If the output reload had a secondary reload, copy it. */
if|if
condition|(
name|reload_secondary_reload
index|[
name|output_reload
index|]
operator|!=
operator|-
literal|1
condition|)
name|reload_secondary_reload
index|[
name|i
index|]
operator|=
name|reload_secondary_reload
index|[
name|output_reload
index|]
expr_stmt|;
comment|/* If required, minimize the register class. */
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|reload_reg_class
index|[
name|output_reload
index|]
argument_list|,
name|reload_reg_class
index|[
name|i
index|]
argument_list|)
condition|)
name|reload_reg_class
index|[
name|i
index|]
operator|=
name|reload_reg_class
index|[
name|output_reload
index|]
expr_stmt|;
comment|/* Transfer all replacements from the old reload to the combined.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_replacements
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|replacements
index|[
name|j
index|]
operator|.
name|what
operator|==
name|output_reload
condition|)
name|replacements
index|[
name|j
index|]
operator|.
name|what
operator|=
name|i
expr_stmt|;
return|return;
block|}
comment|/* If this insn has only one operand that is modified or written (assumed      to be the first),  it must be the one corresponding to this reload.  It      is safe to use anything that dies in this insn for that output provided      that it does not occur in the output (we already know it isn't an      earlyclobber.  If this is an asm insn, give up.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|INSN_CODE
argument_list|(
name|this_insn
argument_list|)
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn_operand_constraint
index|[
name|INSN_CODE
argument_list|(
name|this_insn
argument_list|)
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
operator|||
name|insn_operand_constraint
index|[
name|INSN_CODE
argument_list|(
name|this_insn
argument_list|)
index|]
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
return|return;
comment|/* See if some hard register that dies in this insn and is not used in      the output is the right class.  Only works if the register we pick      up can fully hold our output reload.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|this_insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reload_out
index|[
name|output_reload
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reload_outmode
index|[
name|output_reload
index|]
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|output_reload
index|]
index|]
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reload_outmode
index|[
name|output_reload
index|]
argument_list|)
operator|<=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|reload_reg_rtx
index|[
name|output_reload
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|reload_outmode
index|[
name|output_reload
index|]
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to find a reload register for an in-out reload (expressions IN and OUT).    See if one of IN and OUT is a register that may be used;    this is desirable since a spill-register won't be needed.    If so, return the register rtx that proves acceptable.     INLOC and OUTLOC are locations where IN and OUT appear in the insn.    CLASS is the register class required for the reload.     If FOR_REAL is>= 0, it is the number of the reload,    and in some cases when it can be discovered that OUT doesn't need    to be computed, clear out reload_out[FOR_REAL].     If FOR_REAL is -1, this should not be done, because this call    is just to see if a register can be found, not to find and install it.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_dummy_reload
parameter_list|(
name|real_in
parameter_list|,
name|real_out
parameter_list|,
name|inloc
parameter_list|,
name|outloc
parameter_list|,
name|class
parameter_list|,
name|for_real
parameter_list|)
name|rtx
name|real_in
decl_stmt|,
name|real_out
decl_stmt|;
name|rtx
modifier|*
name|inloc
decl_stmt|,
decl|*
name|outloc
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|reg_class
name|class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|for_real
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|in
init|=
name|real_in
decl_stmt|;
name|rtx
name|out
init|=
name|real_out
decl_stmt|;
name|int
name|in_offset
init|=
literal|0
decl_stmt|;
name|int
name|out_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|value
init|=
literal|0
decl_stmt|;
comment|/* If operands exceed a word, we can't use either of them      unless they have the same size.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|real_out
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|real_in
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|real_out
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|real_in
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Find the inside of any subregs.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|out_offset
operator|=
name|SUBREG_WORD
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|=
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|in_offset
operator|=
name|SUBREG_WORD
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|=
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* Narrow down the reg class, the same way push_reload will;      otherwise we might find a dummy now, but push_reload won't.  */
name|class
operator|=
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|in
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* See if OUT will do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|out
argument_list|)
operator|+
name|out_offset
decl_stmt|;
name|int
name|nwords
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|real_out
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|saved_rtx
decl_stmt|;
comment|/* When we consider whether the insn uses OUT, 	 ignore references within IN.  They don't prevent us 	 from copying IN into OUT, because those refs would 	 move into the insn that reloads IN.  	 However, we only ignore IN in its role as this reload. 	 If the insn uses IN elsewhere and it contains OUT, 	 that counts.  We can't be sure it's the "same" operand 	 so it might not go through this reload.  */
name|saved_rtx
operator|=
operator|*
name|inloc
expr_stmt|;
operator|*
name|inloc
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
comment|/* A fixed reg that can overlap other regs better not be used 	     for reloading in any way.  */
ifdef|#
directive|ifdef
name|OVERLAPPING_REGNO_P
operator|&&
operator|!
operator|(
name|fixed_regs
index|[
name|regno
index|]
operator|&&
name|OVERLAPPING_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|nwords
argument_list|,
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|outloc
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nwords
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_out
argument_list|)
operator|==
name|REG
condition|)
name|value
operator|=
name|real_out
expr_stmt|;
else|else
name|value
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|real_out
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|inloc
operator|=
name|saved_rtx
expr_stmt|;
block|}
comment|/* Consider using IN if OUT was not acceptable      or if OUT dies in this insn (like the quotient in a divmod insn).      We can't use IN unless it is dies in this insn,      which means we must know accurately which hard regs are live.      Also, the result can't go in IN if IN is used within OUT.  */
if|if
condition|(
name|hard_regs_live_known
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|value
operator|==
literal|0
operator|||
name|find_reg_note
argument_list|(
name|this_insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|real_out
argument_list|)
operator|)
operator|&&
name|find_reg_note
argument_list|(
name|this_insn
argument_list|,
name|REG_DEAD
argument_list|,
name|real_in
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|in
argument_list|)
index|]
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|in
argument_list|)
operator|+
name|in_offset
decl_stmt|;
name|int
name|nwords
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|real_in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|nwords
argument_list|,
name|out
argument_list|,
name|NULL_PTR
argument_list|)
operator|&&
operator|!
name|hard_reg_set_here_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|nwords
argument_list|,
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nwords
condition|)
block|{
comment|/* If we were going to use OUT as the reload reg 		 and changed our mind, it means OUT is a dummy that 		 dies here.  So don't bother copying value to it.  */
if|if
condition|(
name|for_real
operator|>=
literal|0
operator|&&
name|value
operator|==
name|real_out
condition|)
name|reload_out
index|[
name|for_real
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_in
argument_list|)
operator|==
name|REG
condition|)
name|value
operator|=
name|real_in
expr_stmt|;
else|else
name|value
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
name|real_in
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines used mainly for determining    whether the IN or an OUT of a reload can serve as the    reload register.  */
end_comment

begin_comment
comment|/* Return 1 if expression X alters a hard reg in the range    from BEG_REGNO (inclusive) to END_REGNO (exclusive),    either explicitly or in the guise of a pseudo-reg allocated to REGNO.    X should be the body of an instruction.  */
end_comment

begin_function
specifier|static
name|int
name|hard_reg_set_here_p
parameter_list|(
name|beg_regno
parameter_list|,
name|end_regno
parameter_list|,
name|x
parameter_list|)
specifier|register
name|int
name|beg_regno
decl_stmt|,
name|end_regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
specifier|register
name|rtx
name|op0
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|r
init|=
name|REGNO
argument_list|(
name|op0
argument_list|)
decl_stmt|;
comment|/* See if this reg overlaps range under consideration.  */
if|if
condition|(
name|r
operator|<
name|end_regno
operator|&&
name|r
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|beg_regno
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|hard_reg_set_here_p
argument_list|(
name|beg_regno
argument_list|,
name|end_regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is a valid memory address for mode MODE,    and check that each pseudo reg has the proper kind of    hard reg.  */
end_comment

begin_function
name|int
name|strict_memory_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like rtx_equal_p except that it allows a REG and a SUBREG to match    if they are the same hard reg, and has special hacks for    autoincrement and autodecrement.    This is specifically intended for find_reloads to use    in determining whether two operands match.    X is the operand whose number is the lower of the two.     The value is 2 if Y contains a pre-increment that matches    a non-incrementing address in X.  */
end_comment

begin_comment
comment|/* ??? To be completely correct, we should arrange to pass    for X the output operand and for Y the input operand.    For now, we assume that the output operand has the lower number    because that is natural in (SET output (... input ...)).  */
end_comment

begin_function
name|int
name|operands_match_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|success_2
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|REG
operator|||
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|i
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
goto|goto
name|slow
goto|;
name|i
operator|+=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|j
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
goto|goto
name|slow
goto|;
name|j
operator|+=
name|SUBREG_WORD
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
name|i
operator|==
name|j
return|;
block|}
comment|/* If two operands must match, because they are really a single      operand of an assembler insn, then two postincrements are invalid      because the assembler insn would increment only once.      On the other hand, an postincrement matches ordinary indexing      if the postincrement is the output operand.  */
if|if
condition|(
name|code
operator|==
name|POST_DEC
operator|||
name|code
operator|==
name|POST_INC
condition|)
return|return
name|operands_match_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|y
argument_list|)
return|;
comment|/* Two preincrements are invalid      because the assembler insn would increment only once.      On the other hand, an preincrement matches ordinary indexing      if the preincrement is the input operand.      In this case, return 2, since some callers need to do special      things when this happens.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PRE_INC
condition|)
return|return
name|operands_match_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|2
else|:
literal|0
return|;
name|slow
label|:
comment|/* Now we have disposed of all the cases       in which different rtx codes can match.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|success_2
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
name|val
operator|=
name|operands_match_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If any subexpression returns 2, 	     we should return 2 if we are successful.  */
if|if
condition|(
name|val
operator|==
literal|2
condition|)
name|success_2
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
operator|+
name|success_2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of times character C occurs in string S.  */
end_comment

begin_function
name|int
name|n_occurrences
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|decomposition
block|{
name|int
name|reg_flag
decl_stmt|;
name|int
name|safe
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|start
decl_stmt|;
name|HOST_WIDE_INT
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Describe the range of registers or memory referenced by X.    If X is a register, set REG_FLAG and put the first register     number into START and the last plus one into END.    If X is a memory reference, put a base address into BASE     and a range of integer offsets into START and END.    If X is pushing on the stack, we can assume it causes no trouble,     so we set the SAFE field.  */
end_comment

begin_function
specifier|static
name|struct
name|decomposition
name|decompose
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|decomposition
name|val
decl_stmt|;
name|int
name|all_const
init|=
literal|0
decl_stmt|;
name|val
operator|.
name|reg_flag
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|safe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
condition|)
block|{
name|val
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|.
name|start
operator|=
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|safe
operator|=
name|REGNO
argument_list|(
name|val
operator|.
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|all_const
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|base
operator|=
name|addr
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST
condition|)
name|offset
operator|=
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|all_const
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|base
operator|=
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|.
name|start
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|val
operator|.
name|start
operator|+
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|base
operator|=
name|base
expr_stmt|;
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|val
operator|.
name|reg_flag
operator|=
literal|1
expr_stmt|;
name|val
operator|.
name|start
operator|=
name|true_regnum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|start
operator|<
literal|0
condition|)
block|{
comment|/* A pseudo with no hard reg.  */
name|val
operator|.
name|start
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|val
operator|.
name|start
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* A hard reg.  */
name|val
operator|.
name|end
operator|=
name|val
operator|.
name|start
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|val
operator|.
name|start
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
comment|/* This could be more precise, but it's good enough.  */
return|return
name|decompose
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
name|val
operator|.
name|reg_flag
operator|=
literal|1
expr_stmt|;
name|val
operator|.
name|start
operator|=
name|true_regnum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|start
operator|<
literal|0
condition|)
return|return
name|decompose
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
else|else
comment|/* A hard reg.  */
name|val
operator|.
name|end
operator|=
name|val
operator|.
name|start
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|val
operator|.
name|start
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
comment|/* This hasn't been assigned yet, so it can't conflict yet.  */
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
condition|)
name|val
operator|.
name|safe
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if altering Y will not modify the value of X.    Y is also described by YDATA, which should be decompose (Y).  */
end_comment

begin_function
specifier|static
name|int
name|immune_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|ydata
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|decomposition
name|ydata
decl_stmt|;
block|{
name|struct
name|decomposition
name|xdata
decl_stmt|;
if|if
condition|(
name|ydata
operator|.
name|reg_flag
condition|)
return|return
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|ydata
operator|.
name|start
argument_list|,
name|ydata
operator|.
name|end
argument_list|,
name|x
argument_list|,
name|NULL_PTR
argument_list|)
return|;
if|if
condition|(
name|ydata
operator|.
name|safe
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If Y is memory and X is not, Y can't affect X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
name|xdata
operator|=
name|decompose
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|xdata
operator|.
name|base
argument_list|,
name|ydata
operator|.
name|base
argument_list|)
condition|)
block|{
comment|/* If bases are distinct symbolic constants, there is no overlap.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xdata
operator|.
name|base
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|ydata
operator|.
name|base
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Constants and stack slots never overlap.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xdata
operator|.
name|base
argument_list|)
operator|&&
operator|(
name|ydata
operator|.
name|base
operator|==
name|frame_pointer_rtx
operator|||
name|ydata
operator|.
name|base
operator|==
name|stack_pointer_rtx
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|ydata
operator|.
name|base
argument_list|)
operator|&&
operator|(
name|xdata
operator|.
name|base
operator|==
name|frame_pointer_rtx
operator|||
name|xdata
operator|.
name|base
operator|==
name|stack_pointer_rtx
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If either base is variable, we don't know anything.  */
return|return
literal|0
return|;
block|}
return|return
operator|(
name|xdata
operator|.
name|start
operator|>=
name|ydata
operator|.
name|end
operator|||
name|ydata
operator|.
name|start
operator|>=
name|xdata
operator|.
name|end
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but calls decompose.  */
end_comment

begin_function
name|int
name|safe_from_earlyclobber
parameter_list|(
name|op
parameter_list|,
name|clobber
parameter_list|)
name|rtx
name|op
decl_stmt|,
name|clobber
decl_stmt|;
block|{
name|struct
name|decomposition
name|early_data
decl_stmt|;
name|early_data
operator|=
name|decompose
argument_list|(
name|clobber
argument_list|)
expr_stmt|;
return|return
name|immune_p
argument_list|(
name|op
argument_list|,
name|clobber
argument_list|,
name|early_data
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point of this file: search the body of INSN    for values that need reloading and record them with push_reload.    REPLACE nonzero means record also where the values occur    so that subst_reloads can be used.     IND_LEVELS says how many levels of indirection are supported by this    machine; a value of zero means that a memory reference is not a valid    memory address.     LIVE_KNOWN says we have valid information about which hard    regs are live at each point in the program; this is true when    we are called from global_alloc but false when stupid register    allocation has been done.     RELOAD_REG_P if nonzero is a vector indexed by hard reg number    which is nonnegative if the reg has been commandeered for reloading into.    It is copied into STATIC_RELOAD_REG_P and referenced from there    by various subroutines.  */
end_comment

begin_function
name|void
name|find_reloads
parameter_list|(
name|insn
parameter_list|,
name|replace
parameter_list|,
name|ind_levels
parameter_list|,
name|live_known
parameter_list|,
name|reload_reg_p
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|replace
decl_stmt|,
name|ind_levels
decl_stmt|;
name|int
name|live_known
decl_stmt|;
name|short
modifier|*
name|reload_reg_p
decl_stmt|;
block|{
name|rtx
name|non_reloaded_operands
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|n_non_reloaded_operands
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
enum|enum
name|reload_modified
block|{
name|RELOAD_NOTHING
block|,
name|RELOAD_READ
block|,
name|RELOAD_READ_WRITE
block|,
name|RELOAD_WRITE
block|}
enum|;
specifier|register
name|int
name|insn_code_number
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|noperands
decl_stmt|;
comment|/* These are the constraints for the insn.  We don't change them.  */
name|char
modifier|*
name|constraints1
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* These start out as the constraints for the insn      and they are chewed up as we consider alternatives.  */
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* These are the preferred classes for an operand, or NO_REGS if it isn't      a register.  */
name|enum
name|reg_class
name|preferred_class
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|pref_or_nothing
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Nonzero for a MEM operand whose entire address needs a reload.  */
name|int
name|address_reloaded
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|no_input_reloads
init|=
literal|0
decl_stmt|,
name|no_output_reloads
init|=
literal|0
decl_stmt|;
name|int
name|n_alternatives
decl_stmt|;
name|int
name|this_alternative
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|this_alternative_win
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|this_alternative_offmemok
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|this_alternative_earlyclobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|this_alternative_matches
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|swapped
decl_stmt|;
name|int
name|goal_alternative
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|this_alternative_number
decl_stmt|;
name|int
name|goal_alternative_number
decl_stmt|;
name|int
name|operand_reloadnum
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|goal_alternative_matches
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|goal_alternative_matched
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|goal_alternative_win
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|goal_alternative_offmemok
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|goal_alternative_earlyclobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|goal_alternative_swapped
decl_stmt|;
name|enum
name|reload_modified
name|modified
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|best
decl_stmt|;
name|int
name|commutative
decl_stmt|;
name|char
name|operands_match
index|[
name|MAX_RECOG_OPERANDS
index|]
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|substed_operand
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|goal_earlyclobber
decl_stmt|,
name|this_earlyclobber
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|this_insn
operator|=
name|insn
expr_stmt|;
name|this_insn_is_asm
operator|=
literal|0
expr_stmt|;
comment|/* Tentative.  */
name|n_reloads
operator|=
literal|0
expr_stmt|;
name|n_replacements
operator|=
literal|0
expr_stmt|;
name|n_memlocs
operator|=
literal|0
expr_stmt|;
name|n_earlyclobbers
operator|=
literal|0
expr_stmt|;
name|replace_reloads
operator|=
name|replace
expr_stmt|;
name|hard_regs_live_known
operator|=
name|live_known
expr_stmt|;
name|static_reload_reg_p
operator|=
name|reload_reg_p
expr_stmt|;
comment|/* JUMP_INSNs and CALL_INSNs are not allowed to have any output reloads;      neither are insns that SET cc0.  Insns that use CC0 are not allowed      to have any input reloads.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|no_output_reloads
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|no_input_reloads
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg_set_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|no_output_reloads
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* The eliminated forms of any secondary memory locations are per-insn, so      clear them out here.  */
name|bzero
argument_list|(
name|secondary_memlocs_elim
argument_list|,
sizeof|sizeof
name|secondary_memlocs_elim
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Find what kind of insn this is.  NOPERANDS gets number of operands.      Make OPERANDS point to a vector of operand values.      Make OPERAND_LOCS point to a vector of pointers to      where the operands were found.      Fill CONSTRAINTS and CONSTRAINTS1 with pointers to the      constraint-strings for this insn.      Return if the insn needs no reload processing.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|SET
case|:
comment|/* Dispose quickly of (set (reg..) (reg..)) if both have hard regs and it 	 is cheap to move between them.  If it is not, there may not be an insn 	 to do the copy, so we may need a reload.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGISTER_MOVE_COST
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|2
condition|)
return|return;
case|case
name|PARALLEL
case|:
case|case
name|ASM_OPERANDS
case|:
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands.  */
name|insn_code_number
operator|=
operator|-
literal|1
expr_stmt|;
name|this_insn_is_asm
operator|=
literal|1
expr_stmt|;
comment|/* expand_asm_operands makes sure there aren't too many operands.  */
if|if
condition|(
name|noperands
operator|>
name|MAX_RECOG_OPERANDS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now get the operand values and constraints out of the insn.  */
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|recog_operand
argument_list|,
name|recog_operand_loc
argument_list|,
name|constraints
argument_list|,
name|operand_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|constraints
argument_list|,
name|constraints1
argument_list|,
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|n_alternatives
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|constraints
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n_alternatives
operator|!=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|constraints
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
condition|)
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"operand constraints differ in number of alternatives"
argument_list|)
expr_stmt|;
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|n_reloads
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
break|break;
block|}
default|default:
comment|/* Ordinary insn: recognize it, get the operands via insn_extract 	 and get the constraints.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_code_number
operator|<
literal|0
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|noperands
operator|=
name|insn_n_operands
index|[
name|insn_code_number
index|]
expr_stmt|;
name|n_alternatives
operator|=
name|insn_n_alternatives
index|[
name|insn_code_number
index|]
expr_stmt|;
comment|/* Just return "no reloads" if insn has no operands with constraints.  */
if|if
condition|(
name|n_alternatives
operator|==
literal|0
condition|)
return|return;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|constraints
index|[
name|i
index|]
operator|=
name|constraints1
index|[
name|i
index|]
operator|=
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
expr_stmt|;
name|operand_mode
index|[
name|i
index|]
operator|=
name|insn_operand_mode
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|noperands
operator|==
literal|0
condition|)
return|return;
name|commutative
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we will need to know, later, whether some pair of operands      are the same, we must compare them now and save the result.      Reloading the base and index registers will clobber them      and afterward they will fail to match.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
comment|/* Scan this operand's constraint to see if it should match another.  */
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
comment|/* The last operand should not be marked commutative.  */
if|if
condition|(
name|i
operator|==
name|noperands
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|this_insn_is_asm
condition|)
name|warning_for_asm
argument_list|(
name|this_insn
argument_list|,
literal|"`%%' constraint used with last operand"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|commutative
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
name|operands_match
index|[
name|c
index|]
index|[
name|i
index|]
operator|=
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|c
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* An operand may not match itself.  */
if|if
condition|(
name|c
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|this_insn_is_asm
condition|)
name|warning_for_asm
argument_list|(
name|this_insn
argument_list|,
literal|"operand %d has constraint %d"
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If C can be commuted with C+1, and C might need to match I, 	       then C+1 might also need to match I.  */
if|if
condition|(
name|commutative
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|commutative
operator|||
name|c
operator|==
name|commutative
operator|+
literal|1
condition|)
block|{
name|int
name|other
init|=
name|c
operator|+
operator|(
name|c
operator|==
name|commutative
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
decl_stmt|;
name|operands_match
index|[
name|other
index|]
index|[
name|i
index|]
operator|=
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|other
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|commutative
operator|||
name|i
operator|==
name|commutative
operator|+
literal|1
condition|)
block|{
name|int
name|other
init|=
name|i
operator|+
operator|(
name|i
operator|==
name|commutative
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
decl_stmt|;
name|operands_match
index|[
name|c
index|]
index|[
name|other
index|]
operator|=
name|operands_match_p
argument_list|(
name|recog_operand
index|[
name|c
index|]
argument_list|,
name|recog_operand
index|[
name|other
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Note that C is supposed to be less than I. 		   No need to consider altering both C and I 		   because in that case we would alter one into the other.  */
block|}
block|}
block|}
comment|/* Examine each operand that is a memory reference or memory address      and reload parts of the addresses into index registers.      While we are at it, initialize the array `modified'.      Also here any references to pseudo regs that didn't get hard regs      but are equivalent to constants get replaced in the insn itself      with those constants.  Nobody will ever see them again.        Finally, set up the preferred classes of each operand.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|modified
index|[
name|i
index|]
operator|=
name|RELOAD_READ
expr_stmt|;
name|address_reloaded
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
block|{
name|find_reloads_address
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_PTR
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
operator|=
operator|*
name|recog_operand_loc
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|)
condition|)
name|address_reloaded
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
operator|=
operator|*
name|recog_operand_loc
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
operator|=
operator|*
name|recog_operand_loc
index|[
name|i
index|]
operator|=
name|find_reloads_toplev
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|,
name|set
operator|!=
literal|0
operator|&&
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|recog_operand_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
comment|/* This is equivalent to calling find_reloads_toplev. 	     The code is duplicated for speed. 	     When we find a pseudo always equivalent to a constant, 	     we replace it by the constant.  We must be sure, however, 	     that we don't try to replace it in the insn in which it 	     is being set.   */
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
name|set
operator|==
literal|0
operator|||
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|recog_operand_loc
index|[
name|i
index|]
operator|)
condition|)
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This might screw code in reload1.c to delete prior output-reload 	 that feeds this insn.  */
block|if (reg_equiv_mem[regno] != 0) 	    substed_operand[i] = recog_operand[i] 	      = reg_equiv_mem[regno];
endif|#
directive|endif
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* If reg_equiv_address is not a constant address, copy it, 		 since it may be shared.  */
name|rtx
name|address
init|=
name|reg_equiv_address
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|address
argument_list|)
condition|)
name|address
operator|=
name|copy_rtx
argument_list|(
name|address
argument_list|)
expr_stmt|;
comment|/* If this is an output operand, we must output a CLOBBER 		 after INSN so find_equiv_reg knows REGNO is being written. */
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
operator|||
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
operator|*
name|recog_operand_loc
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
operator|=
operator|*
name|recog_operand_loc
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* If the operand is still a register (we didn't replace it with an 	 equivalent), get the preferred class to reload it into.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|preferred_class
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|code
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|?
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|)
else|:
name|NO_REGS
operator|)
expr_stmt|;
name|pref_or_nothing
index|[
name|i
index|]
operator|=
operator|(
name|code
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_alternate_class
argument_list|(
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|NO_REGS
operator|)
expr_stmt|;
block|}
comment|/* If this is simply a copy from operand 1 to operand 0, merge the      preferred classes for the operands.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|noperands
operator|>=
literal|2
operator|&&
name|recog_operand
index|[
literal|0
index|]
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|&&
name|recog_operand
index|[
literal|1
index|]
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|preferred_class
index|[
literal|0
index|]
operator|=
name|preferred_class
index|[
literal|1
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|preferred_class
index|[
literal|0
index|]
index|]
index|[
operator|(
name|int
operator|)
name|preferred_class
index|[
literal|1
index|]
index|]
expr_stmt|;
name|pref_or_nothing
index|[
literal|0
index|]
operator||=
name|pref_or_nothing
index|[
literal|1
index|]
expr_stmt|;
name|pref_or_nothing
index|[
literal|1
index|]
operator||=
name|pref_or_nothing
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Now see what we need for pseudo-regs that didn't get hard regs      or got the wrong kind of hard reg.  For this, we must consider      all the operands together against the register constraints.  */
name|best
operator|=
name|MAX_RECOG_OPERANDS
operator|+
literal|300
expr_stmt|;
name|swapped
operator|=
literal|0
expr_stmt|;
name|goal_alternative_swapped
operator|=
literal|0
expr_stmt|;
name|try_swapped
label|:
comment|/* The constraints are made of several alternatives.      Each operand's constraint looks like foo,bar,... with commas      separating the alternatives.  The first alternatives for all      operands go together, the second alternatives go together, etc.       First loop over alternatives.  */
for|for
control|(
name|this_alternative_number
operator|=
literal|0
init|;
name|this_alternative_number
operator|<
name|n_alternatives
condition|;
name|this_alternative_number
operator|++
control|)
block|{
comment|/* Loop over operands for one constraint alternative.  */
comment|/* LOSERS counts those that don't fit this alternative 	 and would require loading.  */
name|int
name|losers
init|=
literal|0
decl_stmt|;
comment|/* BAD is set to 1 if it some operand can't fit this alternative 	 even after reloading.  */
name|int
name|bad
init|=
literal|0
decl_stmt|;
comment|/* REJECT is a count of how undesirable this alternative says it is 	 if any reloading is required.  If the alternative matches exactly 	 then REJECT is ignored, but otherwise it gets this much 	 counted against it in addition to the reloading needed.  Each  	 ? counts three times here since we want the disparaging caused by 	 a bad register class to only count 1/3 as much.  */
name|int
name|reject
init|=
literal|0
decl_stmt|;
name|this_earlyclobber
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
specifier|register
name|int
name|win
init|=
literal|0
decl_stmt|;
comment|/* 0 => this operand can be reloaded somehow for this alternative */
name|int
name|badop
init|=
literal|1
decl_stmt|;
comment|/* 0 => this operand can be reloaded if the alternative allows regs.  */
name|int
name|winreg
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|register
name|rtx
name|operand
init|=
name|recog_operand
index|[
name|i
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means this is a MEM that must be reloaded into a reg 	     regardless of what the constraint says.  */
name|int
name|force_reload
init|=
literal|0
decl_stmt|;
name|int
name|offmemok
init|=
literal|0
decl_stmt|;
name|int
name|earlyclobber
init|=
literal|0
decl_stmt|;
comment|/* If the operand is a SUBREG, extract 	     the REG or MEM (or maybe even a constant) within. 	     (Constants can occur as a result of reg_equiv_constant.)  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|operand
operator|=
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
expr_stmt|;
comment|/* Force reload if this is not a register or if there may may 		 be a problem accessing the register in the outer mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|REG
if|#
directive|if
name|defined
argument_list|(
name|BYTE_LOADS_ZERO_EXTEND
argument_list|)
operator|||
name|defined
argument_list|(
name|BYTE_LOADS_SIGN_EXTEND
argument_list|)
comment|/* ??? The comment below clearly does not match the code. 		     What the code below actually does is set force_reload 		     for a paradoxical subreg of a pseudo.  rms and kenner 		     can't see the point of doing this.  */
comment|/* Nonparadoxical subreg of a pseudoreg. 		     Don't to load the full width if on this machine 		     we expected the fetch to extend.  */
operator|||
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|)
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
endif|#
directive|endif
comment|/* Subreg of a hard reg which can't handle the subreg's mode 		     or which would handle that mode in the wrong number of 		     registers for subregging to work.  */
operator|||
operator|(
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|operand
argument_list|)
argument_list|,
name|operand_mode
index|[
name|i
index|]
argument_list|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|!=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|operand
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|force_reload
operator|=
literal|1
expr_stmt|;
block|}
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|NO_REGS
expr_stmt|;
name|this_alternative_win
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_offmemok
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_earlyclobber
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_matches
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* An empty constraint or empty alternative 	     allows anything which matched the pattern.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|win
operator|=
literal|1
operator|,
name|badop
operator|=
literal|0
expr_stmt|;
comment|/* Scan this alternative's specs for this operand; 	     set WIN if the operand fits any letter in this alternative. 	     Otherwise, clear BADOP if this operand could 	     fit some letter after reloads, 	     or set WINREG if this operand could fit after reloads 	     provided the constraint allows some registers.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
name|modified
index|[
name|i
index|]
operator|=
name|RELOAD_WRITE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|modified
index|[
name|i
index|]
operator|=
name|RELOAD_READ_WRITE
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
break|break;
case|case
literal|'%'
case|:
comment|/* The last operand should not be marked commutative.  */
if|if
condition|(
name|i
operator|!=
name|noperands
operator|-
literal|1
condition|)
name|commutative
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|reject
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|reject
operator|=
literal|300
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Ignore rest of this alternative as far as 		   reloading is concerned.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
name|c
operator|-=
literal|'0'
expr_stmt|;
name|this_alternative_matches
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
comment|/* We are supposed to match a previous operand. 		   If we do, we win if that one did. 		   If we do not, count both of the operands as losers. 		   (This is too conservative, since most of the time 		   only a single reload insn will be needed to make 		   the two operands win.  As a result, this alternative 		   may be rejected when it is actually desirable.)  */
if|if
condition|(
operator|(
name|swapped
operator|&&
operator|(
name|c
operator|!=
name|commutative
operator|||
name|i
operator|!=
name|commutative
operator|+
literal|1
operator|)
operator|)
comment|/* If we are matching as if two operands were swapped, 		       also pretend that operands_match had been computed 		       with swapped. 		       But if I is the second of those and C is the first, 		       don't exchange them, because operands_match is valid 		       only on one side of its diagonal.  */
condition|?
operator|(
name|operands_match
index|[
operator|(
name|c
operator|==
name|commutative
operator|||
name|c
operator|==
name|commutative
operator|+
literal|1
operator|)
condition|?
literal|2
operator|*
name|commutative
operator|+
literal|1
operator|-
name|c
else|:
name|c
index|]
index|[
operator|(
name|i
operator|==
name|commutative
operator|||
name|i
operator|==
name|commutative
operator|+
literal|1
operator|)
condition|?
literal|2
operator|*
name|commutative
operator|+
literal|1
operator|-
name|i
else|:
name|i
index|]
operator|)
else|:
name|operands_match
index|[
name|c
index|]
index|[
name|i
index|]
condition|)
name|win
operator|=
name|this_alternative_win
index|[
name|c
index|]
expr_stmt|;
else|else
block|{
comment|/* Operands don't match.  */
name|rtx
name|value
decl_stmt|;
comment|/* Retroactively mark the operand we had to match 		       as a loser, if it wasn't already.  */
if|if
condition|(
name|this_alternative_win
index|[
name|c
index|]
condition|)
name|losers
operator|++
expr_stmt|;
name|this_alternative_win
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this_alternative
index|[
name|c
index|]
operator|==
operator|(
name|int
operator|)
name|NO_REGS
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* But count the pair only once in the total badness of 		       this alternative, if the pair can be a dummy reload.  */
name|value
operator|=
name|find_dummy_reload
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|recog_operand
index|[
name|c
index|]
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|recog_operand_loc
index|[
name|c
index|]
argument_list|,
name|this_alternative
index|[
name|c
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|losers
operator|--
expr_stmt|;
block|}
comment|/* This can be fixed with reloads if the operand 		   we are supposed to match can be fixed with reloads.  */
name|badop
operator|=
literal|0
expr_stmt|;
name|this_alternative
index|[
name|i
index|]
operator|=
name|this_alternative
index|[
name|c
index|]
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* All necessary reloads for an address_operand 		   were handled in find_reloads_address.  */
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|ALL_REGS
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|force_reload
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|<
literal|0
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
condition|)
name|badop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|address_reloaded
index|[
name|i
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|address_reloaded
index|[
name|i
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Memory operand whose address is not offsettable.  */
case|case
literal|'V'
case|:
if|if
condition|(
name|force_reload
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|ind_levels
condition|?
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
else|:
name|offsettable_nonstrict_memref_p
argument_list|(
name|operand
argument_list|)
operator|)
comment|/* Certain mem addresses will become offsettable 		       after they themselves are reloaded.  This is important; 		       we don't want our own handling of unoffsettables 		       to override the handling of reg_equiv_address.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|ind_levels
operator|==
literal|0
operator|||
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Memory operand whose address is offsettable.  */
case|case
literal|'o'
case|:
if|if
condition|(
name|force_reload
condition|)
break|break;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
comment|/* If IND_LEVELS, find_reloads_address won't reload a 			pseudo that didn't get a hard reg, so we have to 			reject that case.  */
operator|&&
operator|(
name|ind_levels
condition|?
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
else|:
name|offsettable_nonstrict_memref_p
argument_list|(
name|operand
argument_list|)
operator|)
operator|)
comment|/* Certain mem addresses will become offsettable 		       after they themselves are reloaded.  This is important; 		       we don't want our own handling of unoffsettables 		       to override the handling of reg_equiv_address.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|ind_levels
operator|==
literal|0
operator|||
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|<
literal|0
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
condition|)
name|badop
operator|=
literal|0
expr_stmt|;
name|offmemok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* Output operand that is stored before the need for the 		   input operands (and their index registers) is over.  */
name|earlyclobber
operator|=
literal|1
operator|,
name|this_earlyclobber
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Match any floating double constant, but only if 		   we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|operand
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|operand
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|operand
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
operator|!
name|force_reload
comment|/* A PLUS is never a valid operand, but reload can make 		       it from a register when eliminating registers.  */
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|PLUS
comment|/* A SCRATCH is not a valid operand.  */
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SCRATCH
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
operator|||
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|operand
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|<
literal|0
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* Drop through into 'r' case */
case|case
literal|'r'
case|:
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|this_alternative
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
goto|goto
name|reg
goto|;
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|operand
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|this_alternative
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
name|reg
label|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|==
name|BLKmode
condition|)
break|break;
name|winreg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|operand
argument_list|,
name|this_alternative
index|[
name|i
index|]
argument_list|,
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|constraints
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
comment|/* If this operand could be handled with a reg, 	     and some reg is allowed, then this operand can be handled.  */
if|if
condition|(
name|winreg
operator|&&
name|this_alternative
index|[
name|i
index|]
operator|!=
operator|(
name|int
operator|)
name|NO_REGS
condition|)
name|badop
operator|=
literal|0
expr_stmt|;
comment|/* Record which operands fit this alternative.  */
name|this_alternative_earlyclobber
index|[
name|i
index|]
operator|=
name|earlyclobber
expr_stmt|;
if|if
condition|(
name|win
operator|&&
operator|!
name|force_reload
condition|)
name|this_alternative_win
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|this_alternative_offmemok
index|[
name|i
index|]
operator|=
name|offmemok
expr_stmt|;
name|losers
operator|++
expr_stmt|;
if|if
condition|(
name|badop
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* Alternative loses if it has no regs for a reg operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|this_alternative
index|[
name|i
index|]
operator|==
operator|(
name|int
operator|)
name|NO_REGS
operator|&&
name|this_alternative_matches
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* Alternative loses if it requires a type of reload not 		 permitted for this insn.  We can always reload SCRATCH 		 and objects with a REG_UNUSED note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SCRATCH
operator|&&
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
operator|&&
name|no_output_reloads
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|operand
argument_list|)
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
operator|&&
name|no_input_reloads
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* We prefer to reload pseudos over reloading other things, 		 since such reloads may be able to be eliminated later. 		 If we are reloading a SCRATCH, we won't be generating any 		 insns, just using a register, so it is also preferred.  		 So bump REJECT in other cases.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SCRATCH
condition|)
name|reject
operator|++
expr_stmt|;
block|}
comment|/* If this operand is a pseudo register that didn't get a hard  	     reg and this alternative accepts some register, see if the 	     class that we want is a subset of the preferred class for this 	     register.  If not, but it intersects that class, use the 	     preferred class instead.  If it does not intersect the preferred 	     class, show that usage of this alternative should be discouraged; 	     it will be discouraged more still if the register is `preferred 	     or nothing'.  We do this because it increases the chance of 	     reusing our spill register in a later insn and avoiding a pair 	     of memory stores and loads.  	     Don't bother with this if this alternative will accept this 	     operand.  	     Don't do this for a multiword operand, if 	     we have to worry about small classes, because making reg groups 	     harder to allocate is asking for trouble.  	     Don't do this if the preferred class has only one register 	     because we might otherwise exhaust the class.  */
if|if
condition|(
operator|!
name|win
operator|&&
name|this_alternative
index|[
name|i
index|]
operator|!=
operator|(
name|int
operator|)
name|NO_REGS
ifdef|#
directive|ifdef
name|SMALL_REGISTER_CLASSES
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|)
operator|<=
name|UNITS_PER_WORD
endif|#
directive|endif
operator|&&
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|preferred_class
index|[
name|i
index|]
index|]
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|reg_class_subset_p
argument_list|(
name|this_alternative
index|[
name|i
index|]
argument_list|,
name|preferred_class
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* Since we don't have a way of forming the intersection, 		     we just do something special if the preferred class 		     is a subset of the class we have; that's the most  		     common case anyway.  */
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|preferred_class
index|[
name|i
index|]
argument_list|,
name|this_alternative
index|[
name|i
index|]
argument_list|)
condition|)
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|preferred_class
index|[
name|i
index|]
expr_stmt|;
else|else
name|reject
operator|+=
operator|(
literal|1
operator|+
name|pref_or_nothing
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now see if any output operands that are marked "earlyclobber" 	 in this alternative conflict with any input operands 	 or any memory addresses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|this_alternative_earlyclobber
index|[
name|i
index|]
operator|&&
name|this_alternative_win
index|[
name|i
index|]
condition|)
block|{
name|struct
name|decomposition
name|early_data
decl_stmt|;
name|int
name|j
decl_stmt|;
name|early_data
operator|=
name|decompose
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|)
block|{
if|if
condition|(
name|this_insn_is_asm
condition|)
name|warning_for_asm
argument_list|(
name|this_insn
argument_list|,
literal|"`&' constraint used with input operand"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|this_alternative
index|[
name|i
index|]
operator|==
name|NO_REGS
condition|)
block|{
name|this_alternative_earlyclobber
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this_insn_is_asm
condition|)
name|error_for_asm
argument_list|(
name|this_insn
argument_list|,
literal|"`&' constraint used with no register class"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|noperands
condition|;
name|j
operator|++
control|)
comment|/* Is this an input operand or a memory ref?  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|j
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|modified
index|[
name|j
index|]
operator|!=
name|RELOAD_WRITE
operator|)
operator|&&
name|j
operator|!=
name|i
comment|/* Ignore things like match_operator operands.  */
operator|&&
operator|*
name|constraints1
index|[
name|j
index|]
operator|!=
literal|0
comment|/* Don't count an input operand that is constrained to match 		     the early clobber operand.  */
operator|&&
operator|!
operator|(
name|this_alternative_matches
index|[
name|j
index|]
operator|==
name|i
operator|&&
name|rtx_equal_p
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|recog_operand
index|[
name|j
index|]
argument_list|)
operator|)
comment|/* Is it altered by storing the earlyclobber operand?  */
operator|&&
operator|!
name|immune_p
argument_list|(
name|recog_operand
index|[
name|j
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|early_data
argument_list|)
condition|)
block|{
comment|/* If the output is in a single-reg class, 		     it's costly to reload it, so reload the input instead.  */
if|if
condition|(
name|reg_class_size
index|[
name|this_alternative
index|[
name|i
index|]
index|]
operator|==
literal|1
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|j
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|losers
operator|++
expr_stmt|;
name|this_alternative_win
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* If an earlyclobber operand conflicts with something, 	       it must be reloaded, so request this and count the cost.  */
if|if
condition|(
name|j
operator|!=
name|noperands
condition|)
block|{
name|losers
operator|++
expr_stmt|;
name|this_alternative_win
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|noperands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|this_alternative_matches
index|[
name|j
index|]
operator|==
name|i
operator|&&
name|this_alternative_win
index|[
name|j
index|]
condition|)
block|{
name|this_alternative_win
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|losers
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* If one alternative accepts all the operands, no reload required, 	 choose that alternative; don't consider the remaining ones.  */
if|if
condition|(
name|losers
operator|==
literal|0
condition|)
block|{
comment|/* Unswap these so that they are never swapped at `finish'.  */
if|if
condition|(
name|commutative
operator|>=
literal|0
condition|)
block|{
name|recog_operand
index|[
name|commutative
index|]
operator|=
name|substed_operand
index|[
name|commutative
index|]
expr_stmt|;
name|recog_operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|goal_alternative_win
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|goal_alternative
index|[
name|i
index|]
operator|=
name|this_alternative
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_offmemok
index|[
name|i
index|]
operator|=
name|this_alternative_offmemok
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_matches
index|[
name|i
index|]
operator|=
name|this_alternative_matches
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_earlyclobber
index|[
name|i
index|]
operator|=
name|this_alternative_earlyclobber
index|[
name|i
index|]
expr_stmt|;
block|}
name|goal_alternative_number
operator|=
name|this_alternative_number
expr_stmt|;
name|goal_alternative_swapped
operator|=
name|swapped
expr_stmt|;
name|goal_earlyclobber
operator|=
name|this_earlyclobber
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* REJECT, set by the ! and ? constraint characters and when a register 	 would be reloaded into a non-preferred class, discourages the use of 	 this alternative for a reload goal.  REJECT is incremented by three 	 for each ? and one for each non-preferred class.  */
name|losers
operator|=
name|losers
operator|*
literal|3
operator|+
name|reject
expr_stmt|;
comment|/* If this alternative can be made to work by reloading, 	 and it needs less reloading than the others checked so far, 	 record it as the chosen goal for reloading.  */
if|if
condition|(
operator|!
name|bad
operator|&&
name|best
operator|>
name|losers
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|goal_alternative
index|[
name|i
index|]
operator|=
name|this_alternative
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_win
index|[
name|i
index|]
operator|=
name|this_alternative_win
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_offmemok
index|[
name|i
index|]
operator|=
name|this_alternative_offmemok
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_matches
index|[
name|i
index|]
operator|=
name|this_alternative_matches
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_earlyclobber
index|[
name|i
index|]
operator|=
name|this_alternative_earlyclobber
index|[
name|i
index|]
expr_stmt|;
block|}
name|goal_alternative_swapped
operator|=
name|swapped
expr_stmt|;
name|best
operator|=
name|losers
expr_stmt|;
name|goal_alternative_number
operator|=
name|this_alternative_number
expr_stmt|;
name|goal_earlyclobber
operator|=
name|this_earlyclobber
expr_stmt|;
block|}
block|}
comment|/* If insn is commutative (it's safe to exchange a certain pair of operands)      then we need to try each alternative twice,      the second time matching those two operands      as if we had exchanged them.      To do this, really exchange them in operands.       If we have just tried the alternatives the second time,      return operands to normal and drop through.  */
if|if
condition|(
name|commutative
operator|>=
literal|0
condition|)
block|{
name|swapped
operator|=
operator|!
name|swapped
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
block|{
specifier|register
name|enum
name|reg_class
name|tclass
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|recog_operand
index|[
name|commutative
index|]
operator|=
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|recog_operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|substed_operand
index|[
name|commutative
index|]
expr_stmt|;
name|tclass
operator|=
name|preferred_class
index|[
name|commutative
index|]
expr_stmt|;
name|preferred_class
index|[
name|commutative
index|]
operator|=
name|preferred_class
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|preferred_class
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|tclass
expr_stmt|;
name|t
operator|=
name|pref_or_nothing
index|[
name|commutative
index|]
expr_stmt|;
name|pref_or_nothing
index|[
name|commutative
index|]
operator|=
name|pref_or_nothing
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|pref_or_nothing
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|t
expr_stmt|;
name|bcopy
argument_list|(
name|constraints1
argument_list|,
name|constraints
argument_list|,
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|try_swapped
goto|;
block|}
else|else
block|{
name|recog_operand
index|[
name|commutative
index|]
operator|=
name|substed_operand
index|[
name|commutative
index|]
expr_stmt|;
name|recog_operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/* The operands don't meet the constraints.      goal_alternative describes the alternative      that we could reach by reloading the fewest operands.      Reload so as to fit it.  */
if|if
condition|(
name|best
operator|==
name|MAX_RECOG_OPERANDS
operator|+
literal|300
condition|)
block|{
comment|/* No alternative works with reloads??  */
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"inconsistent operand constraints in an `asm'"
argument_list|)
expr_stmt|;
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|n_reloads
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Jump to `finish' from above if all operands are valid already.      In that case, goal_alternative_win is all 1.  */
name|finish
label|:
comment|/* Right now, for any pair of operands I and J that are required to match,      with I< J,      goal_alternative_matches[J] is I.      Set up goal_alternative_matched as the inverse function:      goal_alternative_matched[I] = J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
name|goal_alternative_matched
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|goal_alternative_win
index|[
name|i
index|]
operator|&&
name|goal_alternative_matches
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|goal_alternative_matched
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
comment|/* If the best alternative is with operands 1 and 2 swapped,      consider them swapped before reporting the reloads.  */
if|if
condition|(
name|goal_alternative_swapped
condition|)
block|{
specifier|register
name|rtx
name|tem
decl_stmt|;
name|tem
operator|=
name|substed_operand
index|[
name|commutative
index|]
expr_stmt|;
name|substed_operand
index|[
name|commutative
index|]
operator|=
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|recog_operand
index|[
name|commutative
index|]
expr_stmt|;
name|recog_operand
index|[
name|commutative
index|]
operator|=
name|recog_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|recog_operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|tem
expr_stmt|;
block|}
comment|/* Perform whatever substitutions on the operands we are supposed      to make due to commutativity or replacement of registers      with equivalent constants or memory slots.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|recog_operand_loc
index|[
name|i
index|]
operator|=
name|substed_operand
index|[
name|i
index|]
expr_stmt|;
comment|/* While we are looping on operands, initialize this.  */
name|operand_reloadnum
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Any constants that aren't allowed and can't be reloaded      into registers are here changed into memory references.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|goal_alternative_win
index|[
name|i
index|]
operator|&&
name|CONSTANT_P
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|)
operator|==
name|NO_REGS
operator|)
operator|&&
name|operand_mode
index|[
name|i
index|]
operator|!=
name|VOIDmode
condition|)
block|{
operator|*
name|recog_operand_loc
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
operator|=
name|find_reloads_toplev
argument_list|(
name|force_const_mem
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ind_levels
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternative_allows_memconst
argument_list|(
name|constraints1
index|[
name|i
index|]
argument_list|,
name|goal_alternative_number
argument_list|)
condition|)
name|goal_alternative_win
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now record reloads for all the operands that need them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|goal_alternative_win
index|[
name|i
index|]
condition|)
block|{
comment|/* Operands that match previous ones have already been handled.  */
if|if
condition|(
name|goal_alternative_matches
index|[
name|i
index|]
operator|>=
literal|0
condition|)
empty_stmt|;
comment|/* Handle an operand with a nonoffsettable address 	   appearing where an offsettable address will do 	   by reloading the address into a base register.  */
elseif|else
if|if
condition|(
name|goal_alternative_matched
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|&&
name|goal_alternative_offmemok
index|[
name|i
index|]
operator|&&
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|reload_inc
index|[
name|operand_reloadnum
index|[
name|i
index|]
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|goal_alternative_matched
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_operand
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_operand
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_operand_loc
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_operand_loc
index|[
name|i
index|]
else|:
literal|0
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|insn_code_number
operator|<
literal|0
condition|?
literal|0
else|:
name|insn_operand_strict_low
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* In a matching pair of operands, one must be input only 	   and the other must be output only. 	   Pass the input operand as IN and the other as OUT.  */
elseif|else
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
operator|&&
name|modified
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
operator|==
name|RELOAD_WRITE
condition|)
block|{
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|recog_operand
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|recog_operand_loc
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
name|operand_mode
index|[
name|i
index|]
argument_list|,
name|operand_mode
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|operand_reloadnum
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
operator|=
name|output_reloadnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
operator|&&
name|modified
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
operator|==
name|RELOAD_READ
condition|)
block|{
name|operand_reloadnum
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
operator|=
name|push_reload
argument_list|(
name|recog_operand
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|recog_operand_loc
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
name|operand_mode
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
name|operand_mode
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|output_reloadnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"inconsistent operand constraints in an `asm'"
argument_list|)
expr_stmt|;
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|n_reloads
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|goal_alternative_matched
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|goal_alternative_matches
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|optimize
condition|)
block|{
name|rtx
name|operand
init|=
name|recog_operand
index|[
name|i
index|]
decl_stmt|;
comment|/* For each non-matching operand that's a pseudo-register  	   that didn't get a hard register, make an optional reload. 	   This may get done even if the insn needs no reloads otherwise.  */
comment|/* (It would be safe to make an optional reload for a matching pair 	   of operands, but we don't bother yet.)  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|SUBREG
condition|)
name|operand
operator|=
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|<
literal|0
operator|&&
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
operator|!=
name|NO_REGS
comment|/* Don't make optional output reloads for jump insns 	       (such as aobjeq on the vax).  */
operator|&&
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
condition|)
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_operand
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_operand
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_operand_loc
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_operand_loc
index|[
name|i
index|]
else|:
literal|0
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|insn_code_number
operator|<
literal|0
condition|?
literal|0
else|:
name|insn_operand_strict_low
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
operator|)
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* Make an optional reload for an explicit mem ref.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
operator|!=
name|NO_REGS
comment|/* Don't make optional output reloads for jump insns 		    (such as aobjeq on the vax).  */
operator|&&
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
condition|)
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_operand
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_operand
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_operand_loc
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_operand_loc
index|[
name|i
index|]
else|:
literal|0
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|insn_code_number
operator|<
literal|0
condition|?
literal|0
else|:
name|insn_operand_strict_low
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
operator|)
argument_list|,
literal|1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|non_reloaded_operands
index|[
name|n_non_reloaded_operands
operator|++
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|goal_alternative_matched
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|goal_alternative_matches
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|non_reloaded_operands
index|[
name|n_non_reloaded_operands
operator|++
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
expr_stmt|;
comment|/* Record the values of the earlyclobber operands for the caller.  */
if|if
condition|(
name|goal_earlyclobber
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|goal_alternative_earlyclobber
index|[
name|i
index|]
condition|)
name|reload_earlyclobbers
index|[
name|n_earlyclobbers
operator|++
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
expr_stmt|;
comment|/* If this insn pattern contains any MATCH_DUP's, make sure that      they will be substituted if the operands they match are substituted.      Also do now any substitutions we already did on the operands.       Don't do this if we aren't making replacements because we might be      propagating things allocated by frame pointer elimination into places      it doesn't expect.  */
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
operator|&&
name|replace
condition|)
for|for
control|(
name|i
operator|=
name|insn_n_dups
index|[
name|insn_code_number
index|]
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|opno
init|=
name|recog_dup_num
index|[
name|i
index|]
decl_stmt|;
operator|*
name|recog_dup_loc
index|[
name|i
index|]
operator|=
operator|*
name|recog_operand_loc
index|[
name|opno
index|]
expr_stmt|;
if|if
condition|(
name|operand_reloadnum
index|[
name|opno
index|]
operator|>=
literal|0
condition|)
name|push_replacement
argument_list|(
name|recog_dup_loc
index|[
name|i
index|]
argument_list|,
name|operand_reloadnum
index|[
name|opno
index|]
argument_list|,
name|insn_operand_mode
index|[
name|insn_code_number
index|]
index|[
name|opno
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This loses because reloading of prior insns can invalidate the equivalence      (or at least find_equiv_reg isn't smart enough to find it any more),      causing this insn to need more reload regs than it needed before.      It may be too late to make the reload regs available.      Now this optimization is done safely in choose_reload_regs.  */
comment|/* For each reload of a reg into some other class of reg,      search for an existing equivalent reg (same value now) in the right class.      We can use it as long as we don't need to change its contents.  */
block|for (i = 0; i< n_reloads; i++)     if (reload_reg_rtx[i] == 0&& reload_in[i] != 0&& GET_CODE (reload_in[i]) == REG&& reload_out[i] == 0)       { 	reload_reg_rtx[i] 	  = find_equiv_reg (reload_in[i], insn, reload_reg_class[i], -1, 			    static_reload_reg_p, 0, reload_inmode[i]);
comment|/* Prevent generation of insn to load the value 	   because the one we found already has the value.  */
block|if (reload_reg_rtx[i]) 	  reload_in[i] = reload_reg_rtx[i];       }
endif|#
directive|endif
else|#
directive|else
comment|/* no REGISTER_CONSTRAINTS */
name|int
name|noperands
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|int
name|goal_earlyclobber
init|=
literal|0
decl_stmt|;
comment|/* Always 0, to make combine_reloads happen.  */
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|n_reloads
operator|=
literal|0
expr_stmt|;
name|n_replacements
operator|=
literal|0
expr_stmt|;
name|n_earlyclobbers
operator|=
literal|0
expr_stmt|;
name|replace_reloads
operator|=
name|replace
expr_stmt|;
name|this_insn
operator|=
name|insn
expr_stmt|;
comment|/* Find what kind of insn this is.  NOPERANDS gets number of operands.      Store the operand values in RECOG_OPERAND and the locations      of the words in the insn that point to them in RECOG_OPERAND_LOC.      Return if the insn needs no reload processing.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
condition|)
block|{
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
case|case
name|ASM_INPUT
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|PARALLEL
case|:
case|case
name|SET
case|:
name|noperands
operator|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|noperands
operator|>=
literal|0
condition|)
block|{
comment|/* This insn is an `asm' with operands. 	     First, find out how many operands, and allocate space.  */
name|insn_code_number
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* ??? This is a bug! ??? 	     Give up and delete this insn if it has too many operands.  */
if|if
condition|(
name|noperands
operator|>
name|MAX_RECOG_OPERANDS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now get the operand values out of the insn.  */
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|recog_operand
argument_list|,
name|recog_operand_loc
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Ordinary insn: recognize it, allocate space for operands and 	 constraints, and get them out via insn_extract.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|noperands
operator|=
name|insn_n_operands
index|[
name|insn_code_number
index|]
expr_stmt|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noperands
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|is_set_dest
init|=
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
if|if
condition|(
name|insn_operand_address_p
index|[
name|insn_code_number
index|]
index|[
name|i
index|]
condition|)
name|find_reloads_address
argument_list|(
name|VOIDmode
argument_list|,
name|NULL_PTR
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|recog_operand_loc
index|[
name|i
index|]
argument_list|,
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
operator|*
name|recog_operand_loc
index|[
name|i
index|]
operator|=
name|find_reloads_toplev
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|,
name|is_set_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|!
name|is_set_dest
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
operator|*
name|recog_operand_loc
index|[
name|i
index|]
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This might screw code in reload1.c to delete prior output-reload 	 that feeds this insn.  */
block|if (reg_equiv_mem[regno] != 0) 	    recog_operand[i] = *recog_operand_loc[i] 	      = reg_equiv_mem[regno];
endif|#
directive|endif
block|}
comment|/* All operands are non-reloaded.  */
name|non_reloaded_operands
index|[
name|n_non_reloaded_operands
operator|++
index|]
operator|=
name|recog_operand
index|[
name|i
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no REGISTER_CONSTRAINTS */
comment|/* Determine which part of the insn each reload is needed for,      based on which operand the reload is needed for.      Reloads of entire operands are classified as RELOAD_OTHER.      So are reloads for which a unique purpose is not known.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|reload_when_needed
index|[
name|i
index|]
operator|=
name|RELOAD_OTHER
expr_stmt|;
if|if
condition|(
name|reload_needed_for
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|!
name|reload_needed_for_multiple
index|[
name|i
index|]
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|output_address
init|=
literal|0
decl_stmt|;
name|int
name|input_address
init|=
literal|0
decl_stmt|;
name|int
name|operand_address
init|=
literal|0
decl_stmt|;
comment|/* This reload is needed only for the address of something. 	     Determine whether it is needed for addressing an operand 	     being reloaded for input, whether it is needed for an 	     operand being reloaded for output, and whether it is needed 	     for addressing an operand that won't really be reloaded.  	     Note that we know that this reload is needed in only one address, 	     but we have not yet checked for the case where that same address 	     is used in both input and output reloads. 	     The following code detects this case.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_needed_for
index|[
name|i
index|]
operator|==
name|reload_in
index|[
name|j
index|]
operator|||
name|reload_needed_for
index|[
name|i
index|]
operator|==
name|reload_out
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|reload_optional
index|[
name|j
index|]
condition|)
name|operand_address
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reload_needed_for
index|[
name|i
index|]
operator|==
name|reload_in
index|[
name|j
index|]
condition|)
name|input_address
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reload_needed_for
index|[
name|i
index|]
operator|==
name|reload_out
index|[
name|j
index|]
condition|)
name|output_address
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Don't ignore memrefs without optional reloads.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_non_reloaded_operands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_needed_for
index|[
name|i
index|]
operator|==
name|non_reloaded_operands
index|[
name|j
index|]
condition|)
name|operand_address
operator|=
literal|1
expr_stmt|;
comment|/* If it is needed for only one of those, record which one.  */
if|if
condition|(
name|input_address
operator|&&
operator|!
name|output_address
operator|&&
operator|!
name|operand_address
condition|)
name|reload_when_needed
index|[
name|i
index|]
operator|=
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
expr_stmt|;
if|if
condition|(
name|output_address
operator|&&
operator|!
name|input_address
operator|&&
operator|!
name|operand_address
condition|)
name|reload_when_needed
index|[
name|i
index|]
operator|=
name|RELOAD_FOR_OUTPUT_RELOAD_ADDRESS
expr_stmt|;
if|if
condition|(
name|operand_address
operator|&&
operator|!
name|input_address
operator|&&
operator|!
name|output_address
condition|)
name|reload_when_needed
index|[
name|i
index|]
operator|=
name|RELOAD_FOR_OPERAND_ADDRESS
expr_stmt|;
comment|/* Indicate those RELOAD_OTHER reloads which, though they have 	     0 for reload_output, still cannot overlap an output reload.  */
if|if
condition|(
name|output_address
operator|&&
name|reload_when_needed
index|[
name|i
index|]
operator|==
name|RELOAD_OTHER
condition|)
name|reload_needed_for_multiple
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If we have earlyclobbers, make sure nothing overlaps them.  */
if|if
condition|(
name|n_earlyclobbers
operator|>
literal|0
condition|)
block|{
name|reload_when_needed
index|[
name|i
index|]
operator|=
name|RELOAD_OTHER
expr_stmt|;
name|reload_needed_for_multiple
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Perhaps an output reload can be combined with another      to reduce needs by one.  */
if|if
condition|(
operator|!
name|goal_earlyclobber
condition|)
name|combine_reloads
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if alternative number ALTNUM in constraint-string CONSTRAINT    accepts a memory operand with constant address.  */
end_comment

begin_function
specifier|static
name|int
name|alternative_allows_memconst
parameter_list|(
name|constraint
parameter_list|,
name|altnum
parameter_list|)
name|char
modifier|*
name|constraint
decl_stmt|;
name|int
name|altnum
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Skip alternatives before the one requested.  */
while|while
condition|(
name|altnum
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|constraint
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|altnum
operator|--
expr_stmt|;
block|}
comment|/* Scan the requested alternative for 'm' or 'o'.      If one of them is present, this alternative accepts memory constants.  */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|constraint
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'#'
condition|)
if|if
condition|(
name|c
operator|==
literal|'m'
operator|||
name|c
operator|==
literal|'o'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan X for memory references and scan the addresses for reloading.    Also checks for references to "constant" regs that we want to eliminate    and replaces them with the values they stand for.    We may alter X destructively if it contains a reference to such.    If X is just a constant reg, we return the equivalent value    instead of X.     IND_LEVELS says how many levels of indirect addressing this machine    supports.     IS_SET_DEST is true if X is the destination of a SET, which is not    appropriate to be replaced by a constant.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_reloads_toplev
parameter_list|(
name|x
parameter_list|,
name|ind_levels
parameter_list|,
name|is_set_dest
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
name|int
name|is_set_dest
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
comment|/* This code is duplicated for speed in find_reloads.  */
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|!
name|is_set_dest
condition|)
name|x
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/*  This creates (subreg (mem...)) which would cause an unnecessary     reload of the mem.  */
if|else if (reg_equiv_mem[regno] != 0) 	x = reg_equiv_mem[regno];
endif|#
directive|endif
elseif|else
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* If reg_equiv_address varies, it may be shared, so copy it.  */
name|rtx
name|addr
init|=
name|reg_equiv_address
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
name|copy_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|tem
init|=
name|x
decl_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Check for SUBREG containing a REG that's equivalent to a constant.  	 If the constant has a known value, truncate it right now. 	 Similarly if we are extracting a single-word of a multi-word 	 constant.  If the constant is symbolic, allow it to be substituted 	 normally.  push_reload will strip the subreg later.  If the 	 constant is VOIDmode, abort because we will lose the mode of 	 the register (this should never happen because one of the cases 	 above should handle it).  */
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|BITS_PER_WORD
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
name|tem
operator|=
name|operand_subword
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the subreg contains a reg that will be converted to a mem, 	 convert the subreg to a narrower memref now. 	 Otherwise, we would get (subreg (mem ...) ...), 	 which would force reload of the mem.  	 We also need to do this if there is an equivalent MEM that is 	 not offsettable.  In that case, alter_subreg would produce an 	 invalid address on big-endian machines.  	 For machines that extend byte loads, we must not reload using 	 a wider mode if we have a paradoxical SUBREG.  find_reloads will 	 force a reload in that case.  So we should not do anything here.  */
elseif|else
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
if|#
directive|if
name|defined
argument_list|(
name|BYTE_LOADS_ZERO_EXTEND
argument_list|)
operator|||
name|defined
argument_list|(
name|BYTE_LOADS_SIGN_EXTEND
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
operator|(
name|reg_equiv_mem
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
name|rtx
name|addr
init|=
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
condition|?
name|reg_equiv_address
index|[
name|regno
index|]
else|:
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|int
name|size
decl_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|MIN
argument_list|(
name|size
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|MIN
argument_list|(
name|size
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|find_reloads_toplev
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ind_levels
argument_list|,
name|is_set_dest
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|make_memloc
parameter_list|(
name|ad
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|ad
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|tem
init|=
name|reg_equiv_address
index|[
name|regno
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_memlocs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|tem
argument_list|,
name|XEXP
argument_list|(
name|memlocs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|memlocs
index|[
name|i
index|]
return|;
comment|/* If TEM might contain a pseudo, we must copy it to avoid      modifying it when we do the substitution for the reload.  */
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|copy_rtx
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|tem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|memlocs
index|[
name|n_memlocs
operator|++
index|]
operator|=
name|tem
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Record all reloads needed for handling memory address AD    which appears in *LOC in a memory reference to mode MODE    which itself is found in location  *MEMREFLOC.    Note that we take shortcuts assuming that no multi-reg machine mode    occurs as part of an address.     OPERAND is the operand of the insn within which this address appears.     IND_LEVELS says how many levels of indirect addressing this machine    supports.     Value is nonzero if this address is reloaded or replaced as a whole.    This is interesting to the caller if the address is an autoincrement.     Note that there is no verification that the address will be valid after    this routine does its work.  Instead, we rely on the fact that the address    was valid when reload started.  So we need only undo things that reload    could have broken.  These are wrong register types, pseudos not allocated    to a hard register, and frame pointer elimination.  */
end_comment

begin_function
specifier|static
name|int
name|find_reloads_address
parameter_list|(
name|mode
parameter_list|,
name|memrefloc
parameter_list|,
name|ad
parameter_list|,
name|loc
parameter_list|,
name|operand
parameter_list|,
name|ind_levels
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|memrefloc
decl_stmt|;
name|rtx
name|ad
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|operand
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If the address is a register, see if it is a legitimate address and      reload if not.  We first handle the cases where we need not reload      or where we must reload in a non-standard way.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|ad
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|make_memloc
argument_list|(
name|ad
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|reg_equiv_mem
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we can't indirect any more, a pseudo must be reloaded. 	     If the pseudo's address in its MEM is a SYMBOL_REF, it 	     must be reloaded unless indirect_symref_ok.  Otherwise, it 	     can be reloaded if the address is REG or REG + CONST_INT.  */
if|if
condition|(
name|ind_levels
operator|>
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|indirect_symref_ok
operator|)
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|tem
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* The only remaining case where we can avoid a reload is if this is a 	 hard register that is valid as a base register and which is not the 	 subject of a CLOBBER in this insn.  */
elseif|else
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|regno_clobbered_p
argument_list|(
name|regno
argument_list|,
name|this_insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we do not have one of the cases above, we must do the reload.  */
name|push_reload
argument_list|(
name|ad
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
block|{
comment|/* The address appears valid, so reloads are not needed. 	 But the address may contain an eliminable register. 	 This can happen because a machine with indirect addressing 	 may consider a pseudo register by itself a valid address even when 	 it has failed to get a hard reg. 	 So do a tree-walk to find and eliminate all such regs.  */
comment|/* But first quickly dispose of a common case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|subst_reg_equivs_changed
operator|=
literal|0
expr_stmt|;
operator|*
name|loc
operator|=
name|subst_reg_equivs
argument_list|(
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subst_reg_equivs_changed
condition|)
return|return
literal|0
return|;
comment|/* Check result for validity after substitution.  */
if|if
condition|(
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* The address is not valid.  We have to figure out why.  One possibility      is that it is itself a MEM.  This can happen when the frame pointer is      being eliminated, a pseudo is not allocated to a hard register, and the      offset between the frame and stack pointers is not its initial value.      In that case the pseudo will have been replaced by a MEM referring to      the stack pointer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* First ensure that the address in this MEM is valid.  Then, unless 	 indirect addresses are valid, reload the MEM into a register.  */
name|tem
operator|=
name|ad
expr_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
operator|==
literal|0
condition|?
literal|0
else|:
name|ind_levels
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If tem was changed, then we must create a new memory reference to 	 hold it and store it back into memrefloc.  */
if|if
condition|(
name|tem
operator|!=
name|ad
operator|&&
name|memrefloc
condition|)
block|{
name|rtx
name|oldref
init|=
operator|*
name|memrefloc
decl_stmt|;
operator|*
name|memrefloc
operator|=
name|copy_rtx
argument_list|(
operator|*
name|memrefloc
argument_list|)
expr_stmt|;
name|copy_replacements
argument_list|(
name|tem
argument_list|,
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|==
name|oldref
condition|)
name|operand
operator|=
operator|*
name|memrefloc
expr_stmt|;
block|}
comment|/* Check similar cases as for indirect addresses as above except 	 that we can allow pseudos and a MEM since they should have been 	 taken care of above.  */
if|if
condition|(
name|ind_levels
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|indirect_symref_ok
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
comment|/* Must use TEM here, not AD, since it is the one that will 	     have any subexpressions reloaded, if needed.  */
name|push_reload
argument_list|(
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* If we have address of a stack slot but it's not valid      (displacement is too large), compute the sum in a register.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|||
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Unshare the MEM rtx so we can safely alter it.  */
if|if
condition|(
name|memrefloc
condition|)
block|{
name|rtx
name|oldref
init|=
operator|*
name|memrefloc
decl_stmt|;
operator|*
name|memrefloc
operator|=
name|copy_rtx
argument_list|(
operator|*
name|memrefloc
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|==
name|oldref
condition|)
name|operand
operator|=
operator|*
name|memrefloc
expr_stmt|;
block|}
if|if
condition|(
name|double_reg_address_ok
condition|)
block|{
comment|/* Unshare the sum as well.  */
operator|*
name|loc
operator|=
name|ad
operator|=
name|copy_rtx
argument_list|(
name|ad
argument_list|)
expr_stmt|;
comment|/* Reload the displacement into an index reg. 	     We assume the frame pointer or arg pointer is a base reg.  */
name|find_reloads_address_part
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the sum of two regs is not necessarily valid, 	     reload the sum into a base reg. 	     That will at least work.  */
name|find_reloads_address_part
argument_list|(
name|ad
argument_list|,
name|loc
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* If we have an indexed stack slot, there are three possible reasons why      it might be invalid: The index might need to be reloaded, the address      might have been made by frame pointer elimination and hence have a      constant out of range, or both reasons might apply.         We can easily check for an index needing reload, but even if that is the      case, we might also have an invalid constant.  To avoid making the      conservative assumption and requiring two reloads, we see if this address      is valid when not interpreted strictly.  If it is, the only problem is      that the index needs a reload and find_reloads_address_1 will take care      of it.       There is still a case when we might generate an extra reload,      however.  In certain cases eliminate_regs will return a MEM for a REG      (see the code there for details).  In those cases, memory_address_p      applied to our address will return 0 so we will think that our offset      must be too large.  But it might indeed be valid and the only problem      is that a MEM is present where a REG should be.  This case should be      very rare and there doesn't seem to be any way to avoid it.       If we decide to do something here, it must be that      `double_reg_address_ok' is true and that this address rtl was made by      eliminate_regs.  We generate a reload of the fp/sp/ap + constant and      rework the sum so that the reload register will be added to the index.      This is safe because we know the address isn't shared.       We check for fp/ap/sp as both the first and second operand of the      innermost PLUS.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|ad
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|find_reloads_address_part
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|ad
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|find_reloads_address_part
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* See if address becomes valid when an eliminable register      in a sum is replaced.  */
name|tem
operator|=
name|ad
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
condition|)
name|tem
operator|=
name|subst_indexed_address
argument_list|(
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|ad
operator|&&
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
comment|/* Ok, we win that way.  Replace any additional eliminable 	 registers.  */
name|subst_reg_equivs_changed
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|subst_reg_equivs
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Make sure that didn't make the address invalid again.  */
if|if
condition|(
operator|!
name|subst_reg_equivs_changed
operator|||
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|tem
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If constants aren't valid addresses, reload the constant address      into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|ad
argument_list|)
operator|&&
operator|!
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
block|{
comment|/* If AD is in address in the constant pool, the MEM rtx may be shared. 	 Unshare it so we can safely alter it.  */
if|if
condition|(
name|memrefloc
operator|&&
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|ad
argument_list|)
condition|)
block|{
name|rtx
name|oldref
init|=
operator|*
name|memrefloc
decl_stmt|;
operator|*
name|memrefloc
operator|=
name|copy_rtx
argument_list|(
operator|*
name|memrefloc
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|==
name|oldref
condition|)
name|operand
operator|=
operator|*
name|memrefloc
expr_stmt|;
block|}
name|find_reloads_address_part
argument_list|(
name|ad
argument_list|,
name|loc
argument_list|,
name|BASE_REG_CLASS
argument_list|,
name|Pmode
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|find_reloads_address_1
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|,
name|loc
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all pseudo regs appearing in AD    that are eliminable in favor of equivalent values    and do not have hard regs; replace them by their equivalents.  */
end_comment

begin_function
specifier|static
name|rtx
name|subst_reg_equivs
parameter_list|(
name|ad
parameter_list|)
name|rtx
name|ad
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|ad
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|HIGH
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|ad
return|;
case|case
name|REG
case|:
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|ad
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|subst_reg_equivs_changed
operator|=
literal|1
expr_stmt|;
return|return
name|reg_equiv_constant
index|[
name|regno
index|]
return|;
block|}
block|}
return|return
name|ad
return|;
case|case
name|PLUS
case|:
comment|/* Quickly dispose of a common case.  */
if|if
condition|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|ad
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|ad
argument_list|,
name|i
argument_list|)
operator|=
name|subst_reg_equivs
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ad
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the sum of X and Y, making canonicalizations assumed in an    address, namely: sum constant integers, surround the sum of two    constants with a CONST, put the constant as the second operand, and    group the constant on the outermost sum.     This routine assumes both inputs are already in canonical form.  */
end_comment

begin_function
name|rtx
name|form_sum
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|y
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|x
argument_list|,
name|INTVAL
argument_list|(
name|y
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|tem
operator|=
name|x
operator|,
name|x
operator|=
name|y
operator|,
name|y
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|form_sum
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|form_sum
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
comment|/* Note that if the operands of Y are specified in the opposite      order in the recursive calls below, infinite recursion will occur.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|form_sum
argument_list|(
name|form_sum
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* If both constant, encapsulate sum.  Otherwise, just form sum.  A      constant will have been placed second.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
block|}
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If ADDR is a sum containing a pseudo register that should be    replaced with a constant (from reg_equiv_constant),    return the result of doing so, and also apply the associative    law so that the result is more likely to be a valid address.    (But it is not guaranteed to be one.)     Note that at most one register is replaced, even if more are    replaceable.  Also, we try to put the result into a canonical form    so it is more likely to be a valid address.     In all other cases, return ADDR.  */
end_comment

begin_function
specifier|static
name|rtx
name|subst_indexed_address
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|op0
init|=
literal|0
decl_stmt|,
name|op1
init|=
literal|0
decl_stmt|,
name|op2
init|=
literal|0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Try to find a register to replace.  */
name|op0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|,
name|op2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|op0
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|op1
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|tem
operator|=
name|subst_indexed_address
argument_list|(
name|op0
argument_list|)
operator|)
operator|!=
name|op0
condition|)
name|op0
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|tem
operator|=
name|subst_indexed_address
argument_list|(
name|op1
argument_list|)
operator|)
operator|!=
name|op1
condition|)
name|op1
operator|=
name|tem
expr_stmt|;
else|else
return|return
name|addr
return|;
comment|/* Pick out up to three things to add.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
condition|)
name|op2
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
condition|)
name|op2
operator|=
name|op1
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|,
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute the sum.  */
if|if
condition|(
name|op2
operator|!=
literal|0
condition|)
name|op1
operator|=
name|form_sum
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
literal|0
condition|)
name|op0
operator|=
name|form_sum
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the pseudo registers we must reload into hard registers    in a subexpression of a would-be memory address, X.    (This function is not called if the address we find is strictly valid.)    CONTEXT = 1 means we are considering regs as index regs,    = 0 means we are considering them as base regs.     OPERAND is the operand of the insn within which this address appears.     IND_LEVELS says how many levels of indirect addressing are    supported at this point in the address.     We return nonzero if X, as a whole, is reloaded or replaced.  */
end_comment

begin_comment
comment|/* Note that we take shortcuts assuming that no multi-reg machine mode    occurs as part of an address.    Also, this is not fully machine-customizable; it works for machines    such as vaxes and 68000's and 32000's, but other possible machines    could have addressing modes that this does not handle right.  */
end_comment

begin_function
specifier|static
name|int
name|find_reloads_address_1
parameter_list|(
name|x
parameter_list|,
name|context
parameter_list|,
name|loc
parameter_list|,
name|operand
parameter_list|,
name|ind_levels
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|context
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|rtx
name|operand
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
block|{
specifier|register
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|RTX_CODE
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
specifier|register
name|RTX_CODE
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|MULT
operator|||
name|code0
operator|==
name|SIGN_EXTEND
operator|||
name|code1
operator|==
name|MEM
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MULT
operator|||
name|code1
operator|==
name|SIGN_EXTEND
operator|||
name|code0
operator|==
name|MEM
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|CONST_INT
operator|||
name|code0
operator|==
name|CONST
operator|||
name|code0
operator|==
name|SYMBOL_REF
operator|||
name|code0
operator|==
name|LABEL_REF
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|||
name|code1
operator|==
name|CONST
operator|||
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|LABEL_REF
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|REG_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|REG_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op0
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
else|else
block|{
name|find_reloads_address_1
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POST_INC
operator|||
name|code
operator|==
name|POST_DEC
operator|||
name|code
operator|==
name|PRE_INC
operator|||
name|code
operator|==
name|PRE_DEC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|rtx
name|x_orig
init|=
name|x
decl_stmt|;
comment|/* A register that is incremented cannot be constant!  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Handle a register that is equivalent to a memory location 	     which cannot be addressed directly.  */
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|rtx
name|tem
init|=
name|make_memloc
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regno
argument_list|)
decl_stmt|;
comment|/* First reload the memory location's address.  */
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
comment|/* Put this inside a new increment-expression.  */
name|x
operator|=
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
comment|/* Proceed to reload that, as if it contained a register.  */
block|}
comment|/* If we have a hard register that is ok as an index, 	     don't make a reload.  If an autoincrement of a nice register 	     isn't "valid", it must be that no autoincrement is "valid". 	     If that is true and something made an autoincrement anyway, 	     this must be a special context where one is allowed. 	     (For example, a "push" instruction.) 	     We can't improve this address, so leave it alone.  */
comment|/* Otherwise, reload the autoincrement into a suitable hard reg 	     and record how much to increment by.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
operator|(
name|context
condition|?
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|regno
argument_list|)
else|:
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|)
condition|)
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
name|int
name|reloadnum
init|=
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
decl_stmt|;
name|reload_inc
index|[
name|reloadnum
index|]
operator|=
name|find_inc_amount
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x_orig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Update the REG_INC notes.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|this_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x_orig
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|push_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reloadnum
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* This is probably the result of a substitution, by eliminate_regs, 	     of an equivalent address for a pseudo that was not allocated to a 	     hard register.  Verify that the specified address is valid and 	     reload it into a register.  */
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|link
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
comment|/* Since we know we are going to reload this item, don't decrement 	     for the indirection level.  	     Note that this is actually conservative:  it would be slightly 	     more efficient to use the value of SPILL_INDIRECT_LEVELS from 	     reload1.c here.  */
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|reloadnum
operator|=
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|reload_inc
index|[
name|reloadnum
index|]
operator|=
name|find_inc_amount
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|FIND_REG_INC_NOTE
argument_list|(
name|this_insn
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|!=
literal|0
condition|)
name|push_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reloadnum
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
comment|/* This is probably the result of a substitution, by eliminate_regs, 	 of an equivalent address for a pseudo that was not allocated to a 	 hard register.  Verify that the specified address is valid and reload 	 it into a register.  	 Since we know we are going to reload this item, don't decrement 	 for the indirection level.  	 Note that this is actually conservative:  it would be slightly more 	 efficient to use the value of SPILL_INDIRECT_LEVELS from 	 reload1.c here.  */
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
operator|*
name|loc
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|find_reloads_address_part
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|,
name|loc
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|#
directive|if
literal|0
comment|/* This might screw code in reload1.c to delete prior output-reload 	 that feeds this insn.  */
block|if (reg_equiv_mem[regno] != 0) 	{ 	  push_reload (reg_equiv_mem[regno], NULL_RTX, loc, NULL_PTR, 		       context ? INDEX_REG_CLASS : BASE_REG_CLASS, 		       GET_MODE (x), VOIDmode, 0, 0, operand); 	  return 1; 	}
endif|#
directive|endif
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|make_memloc
argument_list|(
name|x
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
operator|(
name|context
condition|?
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|regno
argument_list|)
else|:
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|)
condition|)
block|{
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If a register appearing in an address is the subject of a CLOBBER 	 in this insn, reload it into some other register to be safe. 	 The CLOBBER is supposed to make the register unavailable 	 from before this insn to after it.  */
if|if
condition|(
name|regno_clobbered_p
argument_list|(
name|regno
argument_list|,
name|this_insn
argument_list|)
condition|)
block|{
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|BASE_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|operand
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|find_reloads_address_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|context
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|operand
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* X, which is found at *LOC, is a part of an address that needs to be    reloaded into a register of class CLASS.  If X is a constant, or if    X is a PLUS that contains a constant, check that the constant is a    legitimate operand and that we are supposed to be able to load    it into the register.     If not, force the constant into memory and reload the MEM instead.     MODE is the mode to use, in case X is an integer constant.     NEEDED_FOR says which operand this reload is needed for.     IND_LEVELS says how many levels of indirect addressing this machine    supports.  */
end_comment

begin_function
specifier|static
name|void
name|find_reloads_address_part
parameter_list|(
name|x
parameter_list|,
name|loc
parameter_list|,
name|class
parameter_list|,
name|mode
parameter_list|,
name|needed_for
parameter_list|,
name|ind_levels
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|needed_for
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|x
argument_list|,
name|class
argument_list|)
operator|==
name|NO_REGS
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|x
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|find_reloads_address
argument_list|(
name|mode
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|needed_for
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|class
argument_list|)
operator|==
name|NO_REGS
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|mode
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|needed_for
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
name|NULL_PTR
argument_list|,
name|class
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|needed_for
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute into X the registers into which we have reloaded    the things that need reloading.  The array `replacements'    says contains the locations of all pointers that must be changed    and says what to replace them with.     Return the rtx that X translates into; usually X, but modified.  */
end_comment

begin_function
name|void
name|subst_reloads
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_replacements
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|replacement
modifier|*
name|r
init|=
operator|&
name|replacements
index|[
name|i
index|]
decl_stmt|;
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|r
operator|->
name|what
index|]
decl_stmt|;
if|if
condition|(
name|reloadreg
condition|)
block|{
comment|/* Encapsulate RELOADREG so its machine mode matches what 	     used to be there.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|r
operator|->
name|mode
operator|&&
name|r
operator|->
name|mode
operator|!=
name|VOIDmode
condition|)
name|reloadreg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|r
operator|->
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are putting this into a SUBREG and RELOADREG is a 	     SUBREG, we would be making nested SUBREGs, so we have to fix 	     this up.  Note that r->where ==&SUBREG_REG (*r->subreg_loc).  */
if|if
condition|(
name|r
operator|->
name|subreg_loc
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reloadreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
operator|*
name|r
operator|->
name|subreg_loc
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
condition|)
operator|*
name|r
operator|->
name|subreg_loc
operator|=
name|SUBREG_REG
argument_list|(
name|reloadreg
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|r
operator|->
name|where
operator|=
name|SUBREG_REG
argument_list|(
name|reloadreg
argument_list|)
expr_stmt|;
name|SUBREG_WORD
argument_list|(
operator|*
name|r
operator|->
name|subreg_loc
argument_list|)
operator|+=
name|SUBREG_WORD
argument_list|(
name|reloadreg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|r
operator|->
name|where
operator|=
name|reloadreg
expr_stmt|;
block|}
comment|/* If reload got no reg and isn't optional, something's wrong.  */
elseif|else
if|if
condition|(
operator|!
name|reload_optional
index|[
name|r
operator|->
name|what
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of any replacements being done into X and move those copies    to locations in Y, a copy of X.  We only look at the highest level of    the RTL.  */
end_comment

begin_function
name|void
name|copy_replacements
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|struct
name|replacement
modifier|*
name|r
decl_stmt|;
comment|/* We can't support X being a SUBREG because we might then need to know its      location if something inside it was replaced.  */
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_replacements
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|replacements
index|[
name|j
index|]
operator|.
name|subreg_loc
operator|==
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|r
operator|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|where
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|r
operator|->
name|what
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|what
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|replacements
index|[
name|j
index|]
operator|.
name|where
operator|==
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|r
operator|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
expr_stmt|;
name|r
operator|->
name|where
operator|=
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|what
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|what
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|mode
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If LOC was scheduled to be replaced by something, return the replacement.    Otherwise, return *LOC.  */
end_comment

begin_function
name|rtx
name|find_replacement
parameter_list|(
name|loc
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
name|struct
name|replacement
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
operator|&
name|replacements
index|[
literal|0
index|]
init|;
name|r
operator|<
operator|&
name|replacements
index|[
name|n_replacements
index|]
condition|;
name|r
operator|++
control|)
block|{
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|r
operator|->
name|what
index|]
decl_stmt|;
if|if
condition|(
name|reloadreg
operator|&&
name|r
operator|->
name|where
operator|==
name|loc
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|r
operator|->
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|r
operator|->
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reloadreg
return|;
block|}
elseif|else
if|if
condition|(
name|reloadreg
operator|&&
name|r
operator|->
name|subreg_loc
operator|==
name|loc
condition|)
block|{
comment|/* RELOADREG must be either a REG or a SUBREG.  	     ??? Is it actually still ever a SUBREG?  If so, why?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reloadreg
argument_list|)
operator|==
name|REG
condition|)
return|return
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|==
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
condition|)
return|return
name|reloadreg
return|;
else|else
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|reloadreg
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|reloadreg
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
operator|*
name|loc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if register in range [REGNO, ENDREGNO)    appears either explicitly or implicitly in X    other than being stored into.     References contained within the substructure at LOC do not count.    LOC may be zero, meaning don't ignore anything.     This is similar to refers_to_regno_p in rtlanal.c except that we    look at equivalences for pseudos that didn't get hard registers.  */
end_comment

begin_function
name|int
name|refers_to_regno_for_reload_p
parameter_list|(
name|regno
parameter_list|,
name|endregno
parameter_list|,
name|x
parameter_list|,
name|loc
parameter_list|)
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|repeat
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|i
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a pseudo, a hard register must not have been allocated. 	 X must therefore either be a constant or be in memory.  */
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|i
index|]
condition|)
return|return
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|reg_equiv_memory_loc
index|[
name|i
index|]
argument_list|,
name|NULL_PTR
argument_list|)
return|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|endregno
operator|>
name|i
operator|&&
name|regno
operator|<
name|i
operator|+
operator|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
operator|)
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG of a hard reg, we can see exactly which 	 registers are being modified.  Otherwise, handle normally.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|inner_regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|inner_endregno
init|=
name|inner_regno
operator|+
operator|(
name|inner_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
return|return
name|endregno
operator|>
name|inner_regno
operator|&&
name|regno
operator|<
name|inner_endregno
return|;
block|}
break|break;
case|case
name|CLOBBER
case|:
case|case
name|SET
case|:
if|if
condition|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|loc
comment|/* Note setting a SUBREG counts as referring to the REG it is in for 	     a pseudo but not for hard registers since we can 	     treat each word individually.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|loc
operator|!=
operator|&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|&&
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|||
name|loc
operator|==
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|loc
operator|!=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc
operator|!=
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if modifying X will affect IN.  If X is a register or a SUBREG,    we check if any register number in X conflicts with the relevant register    numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN    contains a MEM (we don't bother checking for memory addresses that can't    conflict because we expect this to be a rare case.      This function is similar to reg_overlap_mention_p in rtlanal.c except    that we look at equivalences for pseudos that didn't get hard registers.  */
end_comment

begin_function
name|int
name|reg_overlap_mentioned_for_reload_p
parameter_list|(
name|x
parameter_list|,
name|in
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|in
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|+=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a pseudo, it must not have been assigned a hard register. 	 Therefore, it must either be in memory or be a constant.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
condition|)
return|return
name|refers_to_mem_for_reload_p
argument_list|(
name|in
argument_list|)
return|;
elseif|else
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|refers_to_mem_for_reload_p
argument_list|(
name|in
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
condition|)
return|return
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|in
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|in
argument_list|,
name|NULL_PTR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if anything in X contains a MEM.  Look also for pseudo    registers.  */
end_comment

begin_function
name|int
name|refers_to_mem_for_reload_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|refers_to_mem_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* [[This function is currently obsolete, now that volatility    is represented by a special bit `volatil' so VOLATILE is never used;    and UNCHANGING has never been brought into use.]]     Alter X by eliminating all VOLATILE and UNCHANGING expressions.    Each of them is replaced by its operand.    Thus, (PLUS (VOLATILE (MEM (REG 5))) (CONST_INT 4))    becomes (PLUS (MEM (REG 5)) (CONST_INT 4)).     If X is itself a VOLATILE expression,    we return the expression that should replace it    but we do not modify X.  */
end_comment

begin_endif
unit|static rtx forget_volatility (x)      register rtx x; {   enum rtx_code code = GET_CODE (x);   register char *fmt;   register int i;   register rtx value = 0;    switch (code)     {     case LABEL_REF:     case SYMBOL_REF:     case CONST_INT:     case CONST_DOUBLE:     case CONST:     case REG:     case CC0:     case PC:       return x;      case VOLATILE:     case UNCHANGING:       return XEXP (x, 0);     }    fmt = GET_RTX_FORMAT (code);   for (i = GET_RTX_LENGTH (code) - 1; i>= 0; i--)     {       if (fmt[i] == 'e') 	XEXP (x, i) = forget_volatility (XEXP (x, i));       if (fmt[i] == 'E') 	{ 	  register int j; 	  for (j = XVECLEN (x, i) - 1; j>= 0; j--) 	    XVECEXP (x, i, j) = forget_volatility (XVECEXP (x, i, j)); 	}     }    return x; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Check the insns before INSN to see if there is a suitable register    containing the same value as GOAL.    If OTHER is -1, look for a register in class CLASS.    Otherwise, just see if register number OTHER shares GOAL's value.     Return an rtx for the register found, or zero if none is found.     If RELOAD_REG_P is (short *)1,    we reject any hard reg that appears in reload_reg_rtx    because such a hard reg is also needed coming into this insn.     If RELOAD_REG_P is any other nonzero value,    it is a vector indexed by hard reg number    and we reject any hard reg whose element in the vector is nonnegative    as well as any that appears in reload_reg_rtx.     If GOAL is zero, then GOALREG is a register number; we look    for an equivalent for that register.     MODE is the machine mode of the value we want an equivalence for.    If GOAL is nonzero and not VOIDmode, then it must have mode MODE.     This function is used by jump.c as well as in the reload pass.     If GOAL is the sum of the stack pointer and a constant, we treat it    as if it were a constant except that sp is required to be unchanging.  */
end_comment

begin_function
name|rtx
name|find_equiv_reg
parameter_list|(
name|goal
parameter_list|,
name|insn
parameter_list|,
name|class
parameter_list|,
name|other
parameter_list|,
name|reload_reg_p
parameter_list|,
name|goalreg
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|goal
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
specifier|register
name|int
name|other
decl_stmt|;
name|short
modifier|*
name|reload_reg_p
decl_stmt|;
name|int
name|goalreg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|p
init|=
name|insn
decl_stmt|;
name|rtx
name|valtry
decl_stmt|,
name|value
decl_stmt|,
name|where
decl_stmt|;
specifier|register
name|rtx
name|pat
decl_stmt|;
specifier|register
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|valueno
decl_stmt|;
name|int
name|goal_mem
init|=
literal|0
decl_stmt|;
name|int
name|goal_const
init|=
literal|0
decl_stmt|;
name|int
name|goal_mem_addr_varies
init|=
literal|0
decl_stmt|;
name|int
name|need_stable_sp
init|=
literal|0
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|valuenregs
decl_stmt|;
if|if
condition|(
name|goal
operator|==
literal|0
condition|)
name|regno
operator|=
name|goalreg
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|goal
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_float_store
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|goal
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|0
return|;
comment|/* An address with side effects must be reexecuted.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
return|return
literal|0
return|;
block|}
name|goal_mem
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|goal
argument_list|)
condition|)
name|goal_const
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|goal_const
operator|=
name|need_stable_sp
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* On some machines, certain regs must always be rejected      because they don't behave the way ordinary registers do.  */
ifdef|#
directive|ifdef
name|OVERLAPPING_REGNO_P
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|OVERLAPPING_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Scan insns back from INSN, looking for one that copies      a value into or out of GOAL.      Stop and give up if we reach a label.  */
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
comment|/* If we don't want spill regs ... */
operator|&&
operator|(
operator|!
operator|(
name|reload_reg_p
operator|!=
literal|0
operator|&&
name|reload_reg_p
operator|!=
operator|(
name|short
operator|*
operator|)
literal|1
operator|)
comment|/* ... then ignore insns introduced by reload; they aren't useful 	     and can cause results in reload_as_needed to be different 	     from what they were when calculating the need for spills. 	     If we notice an input-reload insn here, we will reject it below, 	     but it might hide a usable equivalent.  That makes bad code. 	     It may even abort: perhaps no reg was spilled for this insn 	     because it was assumed we would find that equivalent.  */
operator|||
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|<
name|reload_first_uid
operator|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|pat
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* First check for something that sets some reg equal to GOAL.  */
if|if
condition|(
name|pat
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|true_regnum
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|regno
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|regno
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|goal_const
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|goal
argument_list|)
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|goal_mem
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|goal
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|goal_mem
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|goal
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
comment|/* If we are looking for a constant, 		     and something equivalent to that constant was copied 		     into a reg, we can use that reg.  */
operator|||
operator|(
name|goal_const
operator|&&
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|goal
argument_list|)
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|goal_const
operator|&&
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|goal
argument_list|)
operator|==
name|CONST_DOUBLE_LOW
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|valtry
operator|=
name|operand_subword
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|goal_const
operator|&&
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|goal
argument_list|)
operator|==
name|CONST_DOUBLE_HIGH
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|valtry
operator|=
name|operand_subword
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|)
condition|)
if|if
condition|(
name|other
operator|>=
literal|0
condition|?
name|valueno
operator|==
name|other
else|:
operator|(
operator|(
name|unsigned
operator|)
name|valueno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|valueno
argument_list|)
operator|)
condition|)
block|{
name|value
operator|=
name|valtry
expr_stmt|;
name|where
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* We found a previous insn copying GOAL into a suitable other reg VALUE      (or copying VALUE into GOAL, if GOAL is also a register).      Now verify that VALUE is really valid.  */
comment|/* VALUENO is the register number of VALUE; a hard register.  */
comment|/* Don't try to re-use something that is killed in this insn.  We want      to be able to trust REG_UNUSED notes.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|where
argument_list|,
name|REG_UNUSED
argument_list|,
name|value
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we propose to get the value from the stack pointer or if GOAL is      a MEM based on the stack pointer, we need a stable SP.  */
if|if
condition|(
name|valueno
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|(
name|goal_mem
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|goal
argument_list|)
operator|)
condition|)
name|need_stable_sp
operator|=
literal|1
expr_stmt|;
comment|/* Reject VALUE if the copy-insn moved the wrong sort of datum.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
comment|/* Reject VALUE if it was loaded from GOAL      and is also a register that appears in the address of GOAL.  */
if|if
condition|(
name|goal_mem
operator|&&
name|value
operator|==
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|where
argument_list|)
argument_list|)
operator|&&
name|refers_to_regno_for_reload_p
argument_list|(
name|valueno
argument_list|,
operator|(
name|valueno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|valueno
argument_list|,
name|mode
argument_list|)
operator|)
argument_list|,
name|goal
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject registers that overlap GOAL.  */
if|if
condition|(
operator|!
name|goal_mem
operator|&&
operator|!
name|goal_const
operator|&&
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|>
name|valueno
operator|&&
name|regno
operator|<
name|valueno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|valueno
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject VALUE if it is one of the regs reserved for reloads.      Reload1 knows how to reuse them anyway, and it would get      confused if we allocated one without its knowledge.      (Now that insns introduced by reload are ignored above,      this case shouldn't happen, but I'm not positive.)  */
if|if
condition|(
name|reload_reg_p
operator|!=
literal|0
operator|&&
name|reload_reg_p
operator|!=
operator|(
name|short
operator|*
operator|)
literal|1
operator|&&
name|reload_reg_p
index|[
name|valueno
index|]
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* On some machines, certain regs must always be rejected      because they don't behave the way ordinary registers do.  */
ifdef|#
directive|ifdef
name|OVERLAPPING_REGNO_P
if|if
condition|(
name|OVERLAPPING_REGNO_P
argument_list|(
name|valueno
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|valuenregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|valueno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Reject VALUE if it is a register being used for an input reload      even if it is not one of those reserved.  */
if|if
condition|(
name|reload_reg_p
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|reload_in
index|[
name|i
index|]
condition|)
block|{
name|int
name|regno1
init|=
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|nregs1
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno1
argument_list|,
name|GET_MODE
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno1
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|regno1
operator|+
name|nregs1
operator|>
name|valueno
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|goal_mem
condition|)
name|goal_mem_addr_varies
operator|=
name|rtx_addr_varies_p
argument_list|(
name|goal
argument_list|)
expr_stmt|;
comment|/* Now verify that the values of GOAL and VALUE remain unaltered      until INSN is reached.  */
name|p
operator|=
name|insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|where
condition|)
return|return
name|value
return|;
comment|/* Don't trust the conversion past a function call 	 if either of the two is in a call-clobbered register, or memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|valueno
operator|>=
literal|0
operator|&&
name|valueno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|valueno
index|]
operator|)
operator|||
name|goal_mem
operator|||
name|need_stable_sp
operator|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|INSN_CLOBBERS_REGNO_P
if|if
condition|(
operator|(
name|valueno
operator|>=
literal|0
operator|&&
name|valueno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|INSN_CLOBBERS_REGNO_P
argument_list|(
name|p
argument_list|,
name|valueno
argument_list|)
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|INSN_CLOBBERS_REGNO_P
argument_list|(
name|p
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* If this insn P stores in either GOAL or VALUE, return 0. 	     If GOAL is a memory ref and this insn writes memory, return 0. 	     If GOAL is a memory ref and its address is not constant, 	     and this insn P changes a register used in GOAL, return 0.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|xregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|xnregs
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|xnregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|xnregs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xregno
operator|<
name|regno
operator|+
name|nregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xregno
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|valueno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|goal_mem_addr_varies
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|dest
argument_list|,
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|goal_mem
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|need_stable_sp
operator|&&
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|v1
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|v1
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|v1
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
specifier|register
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|v1
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|xregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|xnregs
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|xnregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|xnregs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xregno
operator|<
name|regno
operator|+
name|nregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xregno
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|valueno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|goal_mem_addr_varies
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|dest
argument_list|,
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|goal_mem
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|need_stable_sp
operator|&&
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* If this insn auto-increments or auto-decrements 	     either regno or valueno, return 0 now. 	     If GOAL is a memory ref and its address is not constant, 	     and this insn P increments a register used in GOAL, return 0.  */
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|incno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|incno
operator|<
name|regno
operator|+
name|nregs
operator|&&
name|incno
operator|>=
name|regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|incno
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|incno
operator|>=
name|valueno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|goal_mem_addr_varies
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a place where INCED appears in an increment or decrement operator    within X, and return the amount INCED is incremented or decremented by.    The value is always positive.  */
end_comment

begin_function
specifier|static
name|int
name|find_inc_amount
parameter_list|(
name|x
parameter_list|,
name|inced
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|inced
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
specifier|register
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|)
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|inced
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
specifier|register
name|int
name|tem
init|=
name|find_inc_amount
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|inced
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
specifier|register
name|int
name|tem
init|=
name|find_inc_amount
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|inced
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */
end_comment

begin_function
name|int
name|regno_clobbered_p
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

