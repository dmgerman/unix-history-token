begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Method dispatcher and class-object creator for Objective C.    Copyright (C) 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files    compiled with GCC to produce an executable, this does not cause    the resulting executable to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gstdarg.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"gstddef.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"objc.h"
end_include

begin_include
include|#
directive|include
file|"objc-proto.h"
end_include

begin_define
define|#
directive|define
name|MODULE_HASH_SIZE
value|32
end_define

begin_comment
comment|/* Initial module hash table size. 				 Value doesn't really matter.  */
end_comment

begin_define
define|#
directive|define
name|CLASS_HASH_SIZE
value|32
end_define

begin_comment
comment|/* Initial number of buckets size of 				 class hash table.  Value doesn't 				 really matter.  */
end_comment

begin_comment
comment|/* Forward declare some functions.  */
end_comment

begin_decl_stmt
name|id
name|objc_object_create
argument_list|(
name|Class_t
argument_list|)
decl_stmt|,
name|objc_object_dispose
argument_list|(
name|id
argument_list|)
decl_stmt|,
name|objc_object_realloc
argument_list|(
name|id
argument_list|,
name|unsigned
name|int
argument_list|)
decl_stmt|,
name|objc_object_copy
argument_list|(
name|id
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|objc_error
parameter_list|(
name|id
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|id
name|nil_method
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|id
name|return_error_static
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|IMP
name|handle_runtime_error
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_dispatch_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|SEL
name|record_selector
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_methods_from_class
parameter_list|(
name|Class_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_methods_from_list
parameter_list|(
name|MethodList_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_class
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is a hash table of Class_t structures.   *  * At initialization the executable is searched for all Class_t structures.   * Since these structures are created by the compiler they are therefore  * located in the TEXT segment.    *  * A identical structure is allocated from the free store and initialized from  * its TEXT counterpart and placed in the hash table using the TEXT part as  * its key.   *  * Since the free store structure is now writable, additional initialization  * takes place such as its "info" variable, method cache allocation, and  * linking of all of its method and ivar lists from multiple implementations.   */
end_comment

begin_decl_stmt
name|cache_ptr
name|class_hash_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This variable is a flag used within the messaging routines.  If a  * application sets it to !0 then the messager will print messages sent to  * objects.   */
end_comment

begin_decl_stmt
name|BOOL
name|objc_trace
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This mutex provides a course lock for method dispatch.  */
end_comment

begin_decl_stmt
name|MUTEX
name|runtimeMutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This hash table is used by the initialization routines.  When the  * constructor function (__objc_execClass) is called it is passed a pointer  * to a module structure.  That pointer is stored in this table and its  * contents are processed in __objcInit.   */
end_comment

begin_decl_stmt
name|cache_ptr
name|module_hash_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This hash table is used in the constructor subroutine to hold pointers   * to categories that have not been attached to a class.  Constructors are  * received in a random order.  Files may contain category implementation  * of objects whose constructor hasn't been executed yet.  Therefore,   * there is no object to attach the categories.  *  * This hash table holds pointers to categories that haven't been  * attached to objects.  As objects are processed the category hash  * table is searched for attachments.  If a category is found for the  * object it is attached to the object and deleted from the hash table.  */
end_comment

begin_decl_stmt
name|cache_ptr
name|unclaimed_category_hash_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This flag is used by the messager routines to determine if the run-time  * has been initialized.  If the run-time isn't initialized then a  * initialization clean up routine is called.   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Records that hold pointers to arrays of records.  The terminal records are  * method implementations.   *  * The size of the first record is the number of unique classes in the  * executable.  The second is the number of selectors.   *  * The second record conatins methods that are visible to the class -- that is,  * methods that are not overriden from the classt to the root object.   *  * The cache pointers of class and meta class structures point to one of these  * records.   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|record
modifier|*
name|instance_method_record
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|record
modifier|*
name|factory_method_record
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This structure is used to translate between selectors and their ASCII  * representation.  A NULL terminated array of char*,  * OBJC_SELECTOR_REFERENCES, is passed to the constructor routine:   * __objc_execClass. That routine places entries from that array into this  * structure.  The location within OBJC_SELECTOR_REFERENCES where the string  * was taken from is replaced with a small integer, the index into the array  * inside selectorTranslateTable.  That integer then becomes the selector.   *  * Selectors begin at 1 to numEntries.  A selector outside of that range is  * considered an error.  The selector integers are used as the first index  * into the instance_method_record and factory_method_record arrays.   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|record
modifier|*
name|selector_record
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This data structure is used in the special case where usual fatal error  * functions are called but have been overridden in a class.  The value  * returned by that function is returned to the calling object.  error_static  * holds the returned value until it is retrieved by return_error_static  * which returns it to the calling function.   */
end_comment

begin_decl_stmt
specifier|static
name|id
name|error_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a class and selector, return the selector's implementation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|IMP
name|get_imp
parameter_list|(
name|Class_t
name|class
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|IMP
name|imp
init|=
name|NULL
decl_stmt|;
name|imp
operator|=
name|record_get
argument_list|(
name|getClassNumber
argument_list|(
name|class
argument_list|)
argument_list|,
name|record_get
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|sel
argument_list|,
operator|*
name|class
operator|->
name|cache
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|imp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
if|#
directive|if
literal|0
comment|/* There is no portable way to get the program name.  Too bad.  */
block|fprintf (stderr, "%s: ", programname);
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exceeded"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|xcalloc
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|units
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
name|calloc
argument_list|(
name|size
argument_list|,
name|units
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exceeded"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|__objc_xmalloc
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exceeded"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|__objc_xrealloc
parameter_list|(
name|void
modifier|*
name|optr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
name|optr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exceeded"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|__objc_xcalloc
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|int
name|units
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
name|calloc
argument_list|(
name|size
argument_list|,
name|units
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exceeded"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|my_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * This function is called by constructor functions generated for each module  * compiled.    *  * The purpose of this function is to gather the module pointers so that they  * may be processed by the initialization clean up routine.   */
end_comment

begin_function
name|void
name|__objc_execClass
parameter_list|(
name|Module_t
name|module
parameter_list|)
block|{
comment|/* Has we processed any constructors previously?       Flag used to indicate that some global data structures      need to be built.  */
specifier|static
name|BOOL
name|previous_constructors
init|=
literal|0
decl_stmt|;
name|Symtab_t
name|symtab
init|=
name|module
operator|->
name|symtab
decl_stmt|;
name|Class_t
name|object_class
decl_stmt|;
name|node_ptr
name|node
decl_stmt|;
name|SEL
argument_list|*
operator|(
operator|*
name|selectors
operator|)
index|[]
operator|=
operator|(
name|SEL
operator|*
operator|(
operator|*
operator|)
index|[]
operator|)
name|symtab
operator|->
name|refs
argument_list|;
name|int
name|i
argument_list|;
name|BOOL
name|incomplete
operator|=
literal|0
argument_list|;
name|assert
argument_list|(
name|module
operator|->
name|size
operator|==
sizeof|sizeof
argument_list|(
name|Module
argument_list|)
argument_list|)
argument_list|;
name|DEBUG_PRINTF
argument_list|(
literal|"received load module: %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|)
argument_list|;
comment|/* Header file data structure hack test.  */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|Class
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|MetaClass
argument_list|)
argument_list|)
argument_list|;
comment|/* On the first call of this routine, initialize      some data structures.  */
argument_list|if
operator|(
operator|!
name|previous_constructors
operator|)
block|{
comment|/* Enable malloc debugging. This'll slow'er down! */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|NeXT
argument_list|)
name|malloc_debug
argument_list|(
literal|62
argument_list|)
block|;
endif|#
directive|endif
comment|/* Allocate and initialize the mutex.  */
name|MUTEX_ALLOC
argument_list|(
operator|&
name|runtimeMutex
argument_list|)
block|;
name|MUTEX_INIT
argument_list|(
name|runtimeMutex
argument_list|)
block|;
comment|/* Allocate the module hash table.  */
name|module_hash_table
operator|=
name|hash_new
argument_list|(
name|MODULE_HASH_SIZE
argument_list|,
operator|(
name|hash_func_type
operator|)
name|hash_ptr
argument_list|,
operator|(
name|compare_func_type
operator|)
name|compare_ptrs
argument_list|)
block|;
comment|/* Allocate a table for unclaimed categories.  */
name|unclaimed_category_hash_table
operator|=
name|hash_new
argument_list|(
literal|16
argument_list|,
operator|(
name|hash_func_type
operator|)
name|hash_ptr
argument_list|,
operator|(
name|compare_func_type
operator|)
name|compare_ptrs
argument_list|)
block|;
comment|/* Allocate a master selector table if it doesn't exist.  */
name|selector_record
operator|=
name|record_new
argument_list|()
block|;
name|previous_constructors
operator|=
literal|1
block|;   }
comment|/* Save the module pointer for later processing.  */
name|hash_add
argument_list|(
operator|&
name|module_hash_table
argument_list|,
name|module
argument_list|,
name|module
argument_list|)
argument_list|;
comment|/* Parse the classes in the load module and gather selector information.  */
name|DEBUG_PRINTF
argument_list|(
literal|"gathering selectors from module: %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|)
argument_list|;   for
operator|(
name|i
operator|=
literal|0
expr|;
name|i
operator|<
name|symtab
operator|->
name|cls_def_cnt
expr|;
operator|++
name|i
operator|)
block|{
name|Class_t
name|class
operator|=
operator|(
name|Class_t
operator|)
name|symtab
operator|->
name|defs
index|[
name|i
index|]
block|;
comment|/* Make sure we have what we think.  */
name|assert
argument_list|(
name|class
operator|->
name|info
operator|&
name|CLS_CLASS
argument_list|)
block|;
name|assert
argument_list|(
name|class
operator|->
name|class_pointer
operator|->
name|info
operator|&
name|CLS_META
argument_list|)
block|;
name|DEBUG_PRINTF
argument_list|(
literal|"phase 1, processing class: %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
block|;
comment|/* Store the class in the class table and assign class numbers.  */
name|addClassToHash
argument_list|(
name|class
argument_list|)
block|;
comment|/* Store all of the selectors in the class and meta class.  */
name|record_methods_from_class
argument_list|(
name|class
argument_list|)
block|;
name|record_methods_from_class
argument_list|(
operator|(
name|Class_t
operator|)
name|class
operator|->
name|class_pointer
argument_list|)
block|;
comment|/* Initialize the cache pointers.  */
name|class
operator|->
name|cache
operator|=
operator|&
name|instance_method_record
block|;
name|class
operator|->
name|class_pointer
operator|->
name|cache
operator|=
operator|&
name|factory_method_record
block|;   }
comment|/* Replace referenced selectors.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|sel_ref_cnt
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|selectors
operator|)
index|[
name|i
index|]
operator|=
name|record_selector
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
operator|*
name|selectors
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Try to build the class hierarchy and initialize the data structures.  */
name|object_class
operator|=
name|objc_getClass
argument_list|(
literal|"Object"
argument_list|)
expr_stmt|;
if|if
condition|(
name|object_class
condition|)
block|{
comment|/* Make sure we have what we think we have.  */
name|assert
argument_list|(
name|object_class
operator|->
name|class_pointer
operator|->
name|info
operator|&
name|CLS_META
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|object_class
operator|->
name|info
operator|&
name|CLS_CLASS
argument_list|)
expr_stmt|;
comment|/* Connect the classes together (at least as much as we can).  */
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class_t
name|class1
init|=
name|node
operator|->
name|value
decl_stmt|;
comment|/* Make sure we have what we think we have.  */
name|assert
argument_list|(
name|class1
operator|->
name|info
operator|&
name|CLS_CLASS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|class1
operator|->
name|class_pointer
operator|->
name|info
operator|&
name|CLS_META
argument_list|)
expr_stmt|;
comment|/* The class_pointer of all meta classes point to Object's meta class.  */
name|class1
operator|->
name|class_pointer
operator|->
name|class_pointer
operator|=
name|object_class
operator|->
name|class_pointer
expr_stmt|;
comment|/* Assign super class pointers */
if|if
condition|(
name|class1
operator|->
name|super_class
condition|)
block|{
name|Class_t
name|aSuperClass
init|=
name|objc_getClass
argument_list|(
operator|(
name|char
operator|*
operator|)
name|class1
operator|->
name|super_class
argument_list|)
decl_stmt|;
if|if
condition|(
name|aSuperClass
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"making class connections for: %s\n"
argument_list|,
name|class1
operator|->
name|name
argument_list|)
expr_stmt|;
name|class1
operator|->
name|super_class
operator|=
name|aSuperClass
expr_stmt|;
if|if
condition|(
name|class1
operator|->
name|class_pointer
operator|->
name|super_class
condition|)
name|class1
operator|->
name|class_pointer
operator|->
name|super_class
operator|=
name|class1
operator|->
name|super_class
operator|->
name|class_pointer
expr_stmt|;
comment|/* Mark the class as initialized.  */
name|class1
operator|->
name|info
operator||=
name|CLS_RTI
expr_stmt|;
block|}
else|else
comment|/* Couldn't find the class's super class.  */
name|incomplete
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Couldn't find class Object.  */
name|incomplete
operator|=
literal|1
expr_stmt|;
comment|/* Process category information from the module.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab
operator|->
name|cat_def_cnt
condition|;
operator|++
name|i
control|)
block|{
name|Category_t
name|category
init|=
name|symtab
operator|->
name|defs
index|[
name|i
operator|+
name|symtab
operator|->
name|cls_def_cnt
index|]
decl_stmt|;
name|Class_t
name|class
init|=
name|objc_getClass
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
comment|/* If the class for the category exists then append its        methods.  */
if|if
condition|(
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"processing categories from (module,object): %s, %s\n"
argument_list|,
name|module
operator|->
name|name
argument_list|,
name|class_getClassName
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do instance methods.  */
if|if
condition|(
name|category
operator|->
name|instance_methods
condition|)
name|addMethodsToClass
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|instance_methods
argument_list|)
expr_stmt|;
comment|/* Do class methods.  */
if|if
condition|(
name|category
operator|->
name|class_methods
condition|)
name|addMethodsToClass
argument_list|(
operator|(
name|Class_t
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|category
operator|->
name|class_methods
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The object to which the category methods belong can't 	 be found.  Save the information.  */
name|hash_add
argument_list|(
operator|&
name|unclaimed_category_hash_table
argument_list|,
name|category
argument_list|,
name|category
argument_list|)
expr_stmt|;
name|incomplete
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Scan the unclaimed category hash.        Attempt to attach any unclaimed categories to objects.  */
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|unclaimed_category_hash_table
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|unclaimed_category_hash_table
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Category_t
name|category
init|=
name|node
operator|->
name|value
decl_stmt|;
name|Class_t
name|class
init|=
name|objc_getClass
argument_list|(
name|category
operator|->
name|class_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|class
condition|)
block|{
name|DEBUG_PRINTF
argument_list|(
literal|"attaching stored categories to object: %s\n"
argument_list|,
name|class_getClassName
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete this class from the hash table.  */
name|hash_remove
argument_list|(
name|unclaimed_category_hash_table
argument_list|,
name|category
argument_list|)
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|instance_methods
condition|)
name|addMethodsToClass
argument_list|(
name|class
argument_list|,
name|category
operator|->
name|instance_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|->
name|class_methods
condition|)
name|addMethodsToClass
argument_list|(
operator|(
name|Class_t
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|category
operator|->
name|class_methods
argument_list|)
expr_stmt|;
block|}
else|else
name|incomplete
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Can we finish the run time initialization? */
if|if
condition|(
operator|!
name|incomplete
condition|)
block|{
name|initialize_dispatch_tables
argument_list|()
expr_stmt|;
comment|/* Debug run time test.        We're initialized! */
name|initialized
operator|=
literal|1
expr_stmt|;
comment|/* Print out class tables if debugging.  */
name|DEBUG_PRINTF
argument_list|(
literal|"dump of class tables from objcInit\n"
argument_list|)
expr_stmt|;
name|debug_dump_classes
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|IMP
name|objc_msgSend
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
comment|/*    * A method is always called by the compiler.  If a method wasn't    * found then supply a default.     */
name|IMP
name|imp
init|=
name|nil_method
decl_stmt|;
comment|/* The run time must be initialized at this point.      Otherwise we get a message sent to a object with a bogus selector.  */
name|assert
argument_list|(
name|initialized
argument_list|)
expr_stmt|;
comment|/* Objective-C allows messages to be sent to a nil object.  */
if|if
condition|(
name|receiver
condition|)
block|{
comment|/* Check for common programmer error.  */
if|if
condition|(
operator|!
name|receiver
operator|->
name|class_pointer
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"method %s sent to deallocated object %#x\n"
argument_list|,
name|sel_getName
argument_list|(
name|sel
argument_list|)
argument_list|,
name|receiver
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Initialize the class if need be.  */
if|if
condition|(
operator|!
operator|(
name|receiver
operator|->
name|class_pointer
operator|->
name|info
operator|&
name|CLS_INITIALIZED
operator|)
condition|)
name|initialize_class
argument_list|(
name|receiver
operator|->
name|class_pointer
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*      * If we're passed a object then its class_pointer is a Class.  If      * we're passed a Class then its class_pointer is a MetaClass.       * Therefore, searching for a instance or class method      * requires no special decision making here.       *      * Look for the method.       */
name|imp
operator|=
name|get_imp
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|,
name|sel
argument_list|)
expr_stmt|;
comment|/* If the method cannot be found then perform error handling.  */
if|if
condition|(
operator|!
name|imp
condition|)
name|imp
operator|=
name|handle_runtime_error
argument_list|(
name|receiver
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
comment|/* Nice debugging messages if enabled.  */
if|if
condition|(
name|objc_trace
condition|)
block|{
name|printf
argument_list|(
literal|"trace: objc_msgSend , obj=%#x, class=%s, method=%s\n"
argument_list|,
name|receiver
argument_list|,
name|receiver
operator|->
name|class_pointer
operator|->
name|name
argument_list|,
name|sel_getName
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|imp
return|;
block|}
end_function

begin_function
name|IMP
name|objc_msgSendSuper
parameter_list|(
name|Super_t
name|super
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|IMP
name|imp
decl_stmt|;
name|assert
argument_list|(
name|initialized
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|super
operator|->
name|class
operator|->
name|info
operator|&
name|CLS_INITIALIZED
operator|)
condition|)
name|initialize_class
argument_list|(
name|super
operator|->
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|super
operator|->
name|receiver
operator|->
name|class_pointer
operator|->
name|info
operator|&
name|CLS_INITIALIZED
operator|)
condition|)
name|initialize_class
argument_list|(
name|super
operator|->
name|receiver
operator|->
name|class_pointer
operator|->
name|name
argument_list|)
expr_stmt|;
name|imp
operator|=
name|get_imp
argument_list|(
name|super
operator|->
name|class
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imp
condition|)
name|imp
operator|=
name|handle_runtime_error
argument_list|(
name|super
operator|->
name|receiver
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|objc_trace
condition|)
block|{
name|printf
argument_list|(
literal|"trace: objc_msgSendSuper , obj=%#x, class=%s, method=%s\n"
argument_list|,
name|super
operator|->
name|receiver
argument_list|,
name|super
operator|->
name|receiver
operator|->
name|class_pointer
operator|->
name|name
argument_list|,
name|sel_getName
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|imp
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called by objc_msgSend or objc_msgSendSuper when a  * message is sent to a object which it does not recognize.   */
end_comment

begin_function
specifier|static
name|IMP
name|handle_runtime_error
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|IMP
name|imp
decl_stmt|;
comment|/*    * If the object recognizes the doesNotRecognize: method then we're    * going to send it.     */
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|sel_getUid
argument_list|(
literal|"doesNotRecognize:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
condition|)
name|error_static
operator|=
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|sel_getUid
argument_list|(
literal|"doesNotRecognize:"
argument_list|)
argument_list|,
name|sel
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*      * The object doesn't recognize the method.  Check for      * responding to error:.  If it does then sent it.       */
name|char
name|msg
index|[
literal|256
operator|+
name|strlen
argument_list|(
name|sel_getName
argument_list|(
name|sel
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|object
operator|->
name|class_pointer
operator|->
name|name
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s does not recognize %s"
argument_list|,
name|object
operator|->
name|class_pointer
operator|->
name|name
argument_list|,
name|sel_getName
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|sel_getUid
argument_list|(
literal|"error:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
condition|)
name|error_static
operator|=
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|sel_getUid
argument_list|(
literal|"error:"
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*        * The object doesn't respond to doesNotRecognize: or        * error:;  Therefore, a default action is taken.         */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Either doesNotRecognize: or error: has been overridden.  We have    * to return that value as the default action.     */
return|return
name|return_error_static
return|;
block|}
end_function

begin_comment
comment|/*  * This function is used by the run-time to provide a method where nil  * objects can receive messages.   *  * This method simply returns self.   */
end_comment

begin_function
specifier|static
name|id
name|nil_method
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|,
modifier|...
parameter_list|)
block|{
return|return
name|object
return|;
block|}
end_function

begin_comment
comment|/*  * This function is used by the run-time to provide a method where nil  * objects can receive messages.   *  * This method simply returns self.   *  * Note: multiple thread problem area.   */
end_comment

begin_function
specifier|static
name|id
name|return_error_static
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|,
modifier|...
parameter_list|)
block|{
return|return
name|error_static
return|;
block|}
end_function

begin_comment
comment|/*  * These variables provide a way for the defalut methods of object  * allocation, destruction, and reallocation to be overridden.   */
end_comment

begin_function_decl
name|id
function_decl|(
modifier|*
name|_alloc
function_decl|)
parameter_list|(
name|Class_t
parameter_list|)
init|=
name|objc_object_create
function_decl|;
end_function_decl

begin_function_decl
name|id
function_decl|(
modifier|*
name|_dealloc
function_decl|)
parameter_list|(
name|id
parameter_list|)
init|=
name|objc_object_dispose
function_decl|;
end_function_decl

begin_function_decl
name|id
function_decl|(
modifier|*
name|_realloc
function_decl|)
parameter_list|(
name|id
parameter_list|,
name|unsigned
name|int
parameter_list|)
init|=
name|objc_object_realloc
function_decl|;
end_function_decl

begin_function_decl
name|id
function_decl|(
modifier|*
name|_copy
function_decl|)
parameter_list|(
name|id
parameter_list|)
init|=
name|objc_object_copy
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|_error
function_decl|)
parameter_list|(
name|id
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
init|=
name|objc_error
function_decl|;
end_function_decl

begin_function
name|id
name|objc_object_create
parameter_list|(
name|Class_t
name|class
parameter_list|)
block|{
name|id
name|object
decl_stmt|;
name|assert
argument_list|(
name|class
argument_list|)
expr_stmt|;
comment|/*    * Allocate memory for the object, initialize the memory to 0, and    * set the object's class_pointer.     *    * The object's class_pointer is the class's TEXT image.  It is used by    * the messager as the key to the class hash for methods.     *    * No need to initialize the class.  That was done in objcInit.     */
name|object
operator|=
operator|(
name|id
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|class
operator|->
name|instance_size
argument_list|)
expr_stmt|;
name|object
operator|->
name|class_pointer
operator|=
name|class
expr_stmt|;
return|return
name|object
return|;
block|}
end_function

begin_function
name|id
name|objc_object_dispose
parameter_list|(
name|id
name|object
parameter_list|)
block|{
name|object
operator|->
name|class_pointer
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
end_function

begin_function
name|id
name|objc_object_realloc
parameter_list|(
name|id
name|object
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
name|id
name|obj
decl_stmt|;
comment|/* Can't resize a object smaller than its instance size.  */
comment|/* Don't use assert here;      checks for user errors shouldn't depend on NDEBUG.  */
if|if
condition|(
name|length
operator|<
name|object
operator|->
name|class_pointer
operator|->
name|instance_size
condition|)
name|abort
argument_list|()
expr_stmt|;
name|obj
operator|=
operator|(
name|id
operator|)
name|realloc
argument_list|(
name|object
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|+
name|object
operator|->
name|class_pointer
operator|->
name|instance_size
argument_list|,
name|length
operator|-
name|object
operator|->
name|class_pointer
operator|->
name|instance_size
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

begin_function
name|id
name|objc_object_copy
parameter_list|(
name|id
name|object
parameter_list|)
block|{
name|id
name|obj
decl_stmt|;
name|obj
operator|=
name|class_createInstance
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|object
argument_list|,
name|obj
argument_list|,
name|objc_classSize
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

begin_function
name|void
name|objc_error
parameter_list|(
name|id
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Silly function to skip past a sequence of digits in a string.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|skip_digits
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
operator|++
name|str
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|method_getNumberOfArguments
parameter_list|(
name|Method_t
name|method
parameter_list|)
block|{
name|unsigned
name|int
name|num
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
init|=
operator|&
name|method
operator|->
name|method_types
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
comment|/* Skip past size info.  */
name|args
operator|=
name|skip_digits
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Argument type next.  */
name|assert
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
operator|++
name|num
expr_stmt|;
comment|/* Step to next arg.  */
operator|++
name|args
expr_stmt|;
block|}
name|assert
argument_list|(
name|num
operator|>=
literal|2
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|method_getArgumentInfo
parameter_list|(
name|Method_t
name|method
parameter_list|,
name|int
name|indx
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|args
init|=
name|skip_digits
argument_list|(
operator|&
name|method
operator|->
name|method_types
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|method_getNumberOfArguments
argument_list|(
name|method
argument_list|)
operator|>=
name|indx
argument_list|)
expr_stmt|;
comment|/* Step to arg.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indx
condition|;
operator|++
name|i
control|)
block|{
operator|++
name|args
expr_stmt|;
name|args
operator|=
name|skip_digits
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* Return arg data.  */
operator|*
name|type
operator|=
name|args
operator|++
expr_stmt|;
operator|*
name|offset
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|indx
return|;
block|}
end_function

begin_comment
comment|/* This function is not thread safe.  */
end_comment

begin_function
name|Ivar_t
name|object_getIvarAddress
parameter_list|(
name|id
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Class_t
name|class
init|=
name|object
operator|->
name|class_pointer
decl_stmt|;
comment|/* Here is the thread safe problem.  */
name|Ivar_t
name|ivar
init|=
name|NULL
decl_stmt|;
do|do
block|{
name|IvarList_t
name|ivars
init|=
name|class
operator|->
name|ivars
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Look at all of the ivar names.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivars
operator|->
name|ivar_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|ivars
operator|->
name|ivar_list
index|[
name|i
index|]
operator|.
name|ivar_name
argument_list|)
condition|)
name|ivar
operator|=
operator|&
name|ivars
operator|->
name|ivar_list
index|[
name|i
index|]
expr_stmt|;
comment|/*      * If the ivar wasn't found then lets look to the      * super class.       *      * If the class is Object then the super class is NULL      * and we're done.       */
name|class
operator|=
name|class
operator|->
name|super_class
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ivar
operator|&&
name|class
condition|)
do|;
return|return
name|ivar
return|;
block|}
end_function

begin_comment
comment|/*  * Search for a method starting from the current class up its hierarchy.    *  * Return a pointer to the method's method structure if found.  NULL otherwise.   */
end_comment

begin_function
name|Method_t
name|searchForMethodInHierarchy
parameter_list|(
name|Class_t
name|class
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|Method_t
name|method
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|sel
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|name
operator|=
name|sel_getName
argument_list|(
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/*    * Scan the method list of the class.  If the method isn't found in    * the list then step to its super class.     */
do|do
block|{
name|method
operator|=
name|searchForMethodInList
argument_list|(
name|class
operator|->
name|methods
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|class
operator|=
name|class
operator|->
name|super_class
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|method
operator|&&
name|class
condition|)
do|;
return|return
name|method
return|;
block|}
end_function

begin_comment
comment|/*  * Given a linked list of method and a method's name.  Search for the named  * method's method structure.   *  * Return a pointer to the method's method structure if found.  NULL otherwise.   */
end_comment

begin_function
name|Method_t
name|searchForMethodInList
parameter_list|(
name|MethodList_t
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|MethodList_t
name|method_list
init|=
name|list
decl_stmt|;
comment|/* Check for bumbling.  */
comment|/* ??? Who generates the name?  Is it the user, or part of this file?      If we crash here, whose fault is it?  */
name|assert
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* If not found then we'll search the list.  */
while|while
condition|(
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Search the method list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|method
operator|->
name|method_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|method
return|;
block|}
comment|/* The method wasn't found.  Follow the link to the next list of         methods.  */
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * This function adds a method list to a class.    *  * This function is typically called by another function specific to the  * run-time.  As such this function does not worry about thread safe issued.    */
end_comment

begin_function
name|void
name|addMethodsToClass
parameter_list|(
name|Class_t
name|class
parameter_list|,
name|MethodList_t
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Passing of a linked list is not allowed.  Do multiple calls.  */
name|assert
argument_list|(
operator|!
name|list
operator|->
name|method_next
argument_list|)
expr_stmt|;
comment|/* Check for duplicates.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
comment|/* Sometimes these are NULL */
if|if
condition|(
name|searchForMethodInList
argument_list|(
name|class
operator|->
name|methods
argument_list|,
name|method
operator|->
name|method_name
argument_list|)
condition|)
block|{
comment|/* 	 * Duplication. Print a error message an change the 	 * method name to NULL.  	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"attempt to add a existing method: %s\n"
argument_list|,
name|method
operator|->
name|method_name
argument_list|)
expr_stmt|;
name|method
operator|->
name|method_name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Add the methods to the class's method list.  */
name|list
operator|->
name|method_next
operator|=
name|class
operator|->
name|methods
expr_stmt|;
name|class
operator|->
name|methods
operator|=
name|list
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function removes the instance and factory methods in the passed list  * from a class.    *  * Methods are removed from a class by replacing the method's name with NULL.   *  *  * This function is typically called by another function specific to the  * run-time.  As such this function does not worry about thread safe issued.    */
end_comment

begin_function
name|void
name|class_removeMethods
parameter_list|(
name|Class_t
name|class
parameter_list|,
name|MethodList_t
name|method_list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Passing of a linked list is not allowed.  Do multiple calls.  */
name|assert
argument_list|(
operator|!
name|method_list
operator|->
name|method_next
argument_list|)
expr_stmt|;
comment|/*    * For each method in the list search the method lists erasing any    * entries found.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|kill_method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
name|Method_t
name|method
decl_stmt|;
comment|/* Remove any instance method found.  */
name|method
operator|=
name|searchForMethodInList
argument_list|(
name|class
operator|->
name|methods
argument_list|,
name|kill_method
operator|->
name|method_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
condition|)
name|method
operator|->
name|method_name
operator|=
name|NULL
expr_stmt|;
comment|/* Remove any factory method found.  */
name|method
operator|=
name|searchForMethodInList
argument_list|(
name|class
operator|->
name|class_pointer
operator|->
name|methods
argument_list|,
name|kill_method
operator|->
name|method_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
condition|)
name|method
operator|->
name|method_name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is a incomplete implementation of posing.   This function does the  * bulk of the work but does not initialize the class method caches.  That is  * a run-time specific operation.   *  * I implement posing by hiding SUPER_CLASS, creating new class and meta  * class structures, initializing it with IMPOSTOR, and changing it such  * that it is identified as SUPER_CLASS. SUPER_CLASS remains in the  * hierarchy but is inaccessible by the means. The class hierarchy is then re  * arranged such that all of the subclasses of SUPER_CLASS now inherit from  * the new class structures -- except the impostor itself. The only dramatic  * effect on the application is that subclasses of SUPER_CLASS cannot do a   * [ ....  superClass ] and expect their real super class.   */
end_comment

begin_function
name|Class_t
name|class_poseAs
parameter_list|(
name|Class_t
name|impostor
parameter_list|,
name|Class_t
name|super_class
parameter_list|)
block|{
name|Class_t
name|new_class
init|=
operator|(
name|Class_t
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Class
argument_list|)
argument_list|)
decl_stmt|;
name|MetaClass_t
name|new_meta_class
init|=
operator|(
name|MetaClass_t
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|MetaClass
argument_list|)
argument_list|)
decl_stmt|;
name|node_ptr
name|node
decl_stmt|;
name|char
modifier|*
name|new_name
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|super_class
operator|->
name|name
argument_list|)
operator|+
literal|12
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|new_class
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|new_meta_class
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
comment|/* No dispatching while the the posing class is being built.      The dispatch tables will be hacked on.  */
name|MUTEX_LOCK
argument_list|(
name|runtimeMutex
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|impostor
operator|->
name|info
operator|&
name|CLS_CLASS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|super_class
operator|->
name|info
operator|&
name|CLS_CLASS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|impostor
operator|->
name|instance_size
operator|==
name|super_class
operator|->
name|instance_size
argument_list|)
expr_stmt|;
comment|/* Create the impostor class.  */
name|new_class
operator|->
name|class_pointer
operator|=
name|new_meta_class
expr_stmt|;
name|new_class
operator|->
name|super_class
operator|=
name|super_class
expr_stmt|;
name|new_class
operator|->
name|name
operator|=
name|super_class
operator|->
name|name
expr_stmt|;
name|new_class
operator|->
name|version
operator|=
name|super_class
operator|->
name|version
expr_stmt|;
name|new_class
operator|->
name|info
operator|=
name|super_class
operator|->
name|info
expr_stmt|;
name|new_class
operator|->
name|instance_size
operator|=
name|super_class
operator|->
name|instance_size
expr_stmt|;
name|new_class
operator|->
name|ivars
operator|=
name|super_class
operator|->
name|ivars
expr_stmt|;
name|new_class
operator|->
name|methods
operator|=
name|impostor
operator|->
name|methods
expr_stmt|;
name|new_class
operator|->
name|cache
operator|=
operator|&
name|instance_method_record
expr_stmt|;
comment|/* Create the impostor meta class.  */
name|new_meta_class
operator|->
name|class_pointer
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|class_pointer
expr_stmt|;
name|new_meta_class
operator|->
name|super_class
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|super_class
expr_stmt|;
name|new_meta_class
operator|->
name|name
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|name
expr_stmt|;
name|new_meta_class
operator|->
name|version
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|version
expr_stmt|;
name|new_meta_class
operator|->
name|info
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|info
expr_stmt|;
name|new_meta_class
operator|->
name|instance_size
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|instance_size
expr_stmt|;
name|new_meta_class
operator|->
name|ivars
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|ivars
expr_stmt|;
name|new_meta_class
operator|->
name|methods
operator|=
name|impostor
operator|->
name|class_pointer
operator|->
name|methods
expr_stmt|;
name|new_meta_class
operator|->
name|cache
operator|=
operator|&
name|factory_method_record
expr_stmt|;
comment|/*    * Delete the class from the hash table, change its name so that it    * can no longer be found, then place it back into the hash table    * using its new name.     *    * Don't worry about the class number.  It is already assigned.     *    * Don't worry about dangling pointers.  Life's a bitch.  (A little bit    * of memory is lost with the hash key.)    */
name|hash_remove
argument_list|(
name|class_hash_table
argument_list|,
name|super_class
operator|->
name|name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s*"
argument_list|,
name|super_class
operator|->
name|name
argument_list|)
expr_stmt|;
name|super_class
operator|->
name|name
operator|=
name|new_name
expr_stmt|;
name|super_class
operator|->
name|class_pointer
operator|->
name|name
operator|=
name|new_name
expr_stmt|;
name|hash_add
argument_list|(
operator|&
name|class_hash_table
argument_list|,
name|super_class
operator|->
name|name
argument_list|,
name|super_class
argument_list|)
expr_stmt|;
comment|/*    * Now change all of the classes derived from super_class to be    * derived from a impostor (except the impostor's impostor.     */
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class_t
name|class1
init|=
name|node
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|class1
operator|->
name|super_class
operator|==
name|super_class
condition|)
if|if
condition|(
name|class1
operator|!=
name|impostor
condition|)
name|class1
operator|->
name|super_class
operator|=
name|new_class
expr_stmt|;
block|}
comment|/* Place the impostor class in class hash table      and assign it a class number.  */
name|addClassToHash
argument_list|(
name|new_class
argument_list|)
expr_stmt|;
comment|/* Reinitialize the dispatch tables.  */
name|initialize_dispatch_tables
argument_list|()
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
name|runtimeMutex
argument_list|)
expr_stmt|;
comment|/* Print out class tables if debugging.  */
name|DEBUG_PRINTF
argument_list|(
literal|"dump of class tables class_poseAs\n"
argument_list|)
expr_stmt|;
name|debug_dump_classes
argument_list|()
expr_stmt|;
return|return
name|new_class
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is given a class and records all of the methods in its class  * structure in the record table.    */
end_comment

begin_function
specifier|static
name|void
name|record_methods_from_class
parameter_list|(
name|Class_t
name|class
parameter_list|)
block|{
name|MethodList_t
name|method_list
decl_stmt|;
name|method_list
operator|=
name|class
operator|->
name|methods
expr_stmt|;
while|while
condition|(
name|method_list
condition|)
block|{
name|record_methods_from_list
argument_list|(
name|method_list
argument_list|)
expr_stmt|;
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine is given a list of methods and records each of the methods in  * the record table.  This is the routine that does the actual recording  * work.   */
end_comment

begin_function
specifier|static
name|void
name|record_methods_from_list
parameter_list|(
name|MethodList_t
name|method_list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
name|record_selector
argument_list|(
name|method
operator|->
name|method_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|SEL
name|sel_getUid
parameter_list|(
specifier|const
name|STR
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|record_entries
argument_list|(
name|selector_record
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|record_get
argument_list|(
name|i
argument_list|,
name|selector_record
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|SEL
operator|)
name|i
return|;
comment|/* Unable to locate selector.  Return error value.  */
return|return
operator|(
name|SEL
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|STR
name|sel_getName
parameter_list|(
name|SEL
name|selector
parameter_list|)
block|{
return|return
name|record_get
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|selector
argument_list|,
name|selector_record
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Store the passed selector name in the selector record and return its  * selector value (value returned by sel_getUid).   */
end_comment

begin_function
specifier|static
name|SEL
name|record_selector
parameter_list|(
specifier|const
name|char
modifier|*
name|sel
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Find either the selector in the table or an empty slot.  */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|record_entries
argument_list|(
name|selector_record
argument_list|)
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sel
argument_list|,
name|record_get
argument_list|(
name|j
argument_list|,
name|selector_record
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|SEL
operator|)
name|j
return|;
comment|/* Save the selector name.  */
name|record_store
argument_list|(
name|my_strdup
argument_list|(
name|sel
argument_list|)
argument_list|,
name|selector_record
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"Record: %s as: %#x\n"
argument_list|,
name|sel
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|SEL
operator|)
name|j
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the dispatch tables.  This requires the initialization of the  * instance_method_record and factory_method_record arrays and the arrays they  * point to.   *  * The first array is indexed by a class number.  Therefore its size is the  * number of classes in the executable.  The second array is indexed by a  * selector id.  Therefore its size is the number of unique selectors in the  * application.   *  * When a method is sent to a object its class number is extracted from the  * class structure and used in the first array.  The selector id is used in  * the second.  The result value is a method implementation.   */
end_comment

begin_function
specifier|static
name|void
name|initialize_dispatch_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Check to make sure things are in place.  */
name|assert
argument_list|(
name|selector_record
argument_list|)
expr_stmt|;
comment|/* Blow away the instance and factory method records.  */
if|if
condition|(
name|factory_method_record
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|record_entries
argument_list|(
name|factory_method_record
argument_list|)
condition|;
operator|++
name|i
control|)
name|record_delete
argument_list|(
name|record_get
argument_list|(
name|i
argument_list|,
name|factory_method_record
argument_list|)
argument_list|)
expr_stmt|;
name|record_delete
argument_list|(
name|factory_method_record
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instance_method_record
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|record_entries
argument_list|(
name|instance_method_record
argument_list|)
condition|;
operator|++
name|i
control|)
name|record_delete
argument_list|(
name|record_get
argument_list|(
name|i
argument_list|,
name|instance_method_record
argument_list|)
argument_list|)
expr_stmt|;
name|record_delete
argument_list|(
name|instance_method_record
argument_list|)
expr_stmt|;
block|}
comment|/* Reallocate the instance and factory method records.  */
name|factory_method_record
operator|=
name|record_new
argument_list|()
expr_stmt|;
name|instance_method_record
operator|=
name|record_new
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|record_entries
argument_list|(
name|selector_record
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|record_store
argument_list|(
name|record_new
argument_list|()
argument_list|,
name|factory_method_record
argument_list|)
expr_stmt|;
name|record_store
argument_list|(
name|record_new
argument_list|()
argument_list|,
name|instance_method_record
argument_list|)
expr_stmt|;
block|}
comment|/* Fool all of the secondary records into thinking they have data.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|record_entries
argument_list|(
name|selector_record
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|record
modifier|*
name|record
decl_stmt|;
name|node_ptr
name|node
decl_stmt|;
name|record
operator|=
name|record_get
argument_list|(
name|i
argument_list|,
name|factory_method_record
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|module_hash_table
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|module_hash_table
argument_list|,
name|node
argument_list|)
control|)
name|record_store
argument_list|(
name|NULL
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|record
operator|=
name|record_get
argument_list|(
name|i
argument_list|,
name|instance_method_record
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|module_hash_table
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|module_hash_table
argument_list|,
name|node
argument_list|)
control|)
name|record_store
argument_list|(
name|NULL
argument_list|,
name|record
argument_list|)
expr_stmt|;
block|}
comment|/* For all classes fill in the methods implemented by the class and visiable      from the class in the hierarchy.  Those methods are assigned to the      class.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|record_entries
argument_list|(
name|selector_record
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
comment|/* i is a sel */
name|node_ptr
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class_t
name|class
init|=
name|node
operator|->
name|value
decl_stmt|;
name|MetaClass_t
name|meta_class
init|=
name|class
operator|->
name|class_pointer
decl_stmt|;
name|int
name|class_number
init|=
name|getClassNumber
argument_list|(
name|class
argument_list|)
decl_stmt|;
name|Method_t
name|method
decl_stmt|;
comment|/* DEBUG_PRINTF ("Assignment of sel=%s, class=%s (%#x, %#x)\n",  	 sel_getName ((SEL)i), class->name, 	 searchForMethodInHierarchy (class, (SEL)i), 	 searchForMethodInHierarchy ((Class_t)meta_class, (SEL)i)); */
name|method
operator|=
name|searchForMethodInHierarchy
argument_list|(
name|class
argument_list|,
operator|(
name|SEL
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
condition|)
name|record_store_at
argument_list|(
name|class_number
argument_list|,
name|method
operator|->
name|method_imp
argument_list|,
name|record_get
argument_list|(
name|i
argument_list|,
name|instance_method_record
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|class_number
operator|==
name|getClassNumber
argument_list|(
operator|(
name|Class_t
operator|)
name|class
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|=
name|searchForMethodInHierarchy
argument_list|(
operator|(
name|Class_t
operator|)
name|meta_class
argument_list|,
operator|(
name|SEL
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
condition|)
name|record_store_at
argument_list|(
name|class_number
argument_list|,
name|method
operator|->
name|method_imp
argument_list|,
name|record_get
argument_list|(
name|i
argument_list|,
name|factory_method_record
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This method is called by the dispatch routines when a class has not been  * initialized.  This method is responsible for initializing the class.  This  * is accomplished by first testing the class itself for responding to the  * +initialize method.  If such a method is implemented then it is called.   * Before exit, irregardless if the class implements +initialize, the class  * is marked as initialized.   */
end_comment

begin_function
specifier|static
name|void
name|initialize_class
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Method_t
name|method
init|=
name|NULL
decl_stmt|;
name|Class_t
name|class
init|=
name|objc_getClass
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|SEL
name|sel
init|=
name|sel_getUid
argument_list|(
literal|"initialize"
argument_list|)
decl_stmt|;
comment|/* The class should not be initialized at this point.  */
name|assert
argument_list|(
operator|!
operator|(
name|class
operator|->
name|info
operator|&
name|CLS_INITIALIZED
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|class
operator|->
name|class_pointer
operator|->
name|info
operator|&
name|CLS_INITIALIZED
operator|)
argument_list|)
expr_stmt|;
comment|/* Search for the +initialize method.      Call it if it exists.  */
if|if
condition|(
name|sel
condition|)
name|method
operator|=
name|searchForMethodInList
argument_list|(
name|class
operator|->
name|class_pointer
operator|->
name|methods
argument_list|,
name|sel_getName
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
condition|)
block|{
name|IMP
name|imp
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"Class: %s sending +%s\n"
argument_list|,
name|name
argument_list|,
name|sel_getName
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|imp
operator|=
name|get_imp
argument_list|(
operator|(
name|Class_t
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|sel
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|imp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|imp
call|)
argument_list|(
operator|(
name|id
operator|)
name|class
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the class as initialized.  */
name|class
operator|->
name|info
operator||=
name|CLS_INITIALIZED
expr_stmt|;
name|class
operator|->
name|class_pointer
operator|->
name|info
operator||=
name|CLS_INITIALIZED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Silly little function that checks to make sure the class hash table is  * initialized.  If it isn't initialized then do it.   */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|class_hash_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|unsigned
name|int
name|init
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|class_hash_table
operator|=
name|hash_new
argument_list|(
name|CLASS_HASH_SIZE
argument_list|,
operator|(
name|hash_func_type
operator|)
name|hash_string
argument_list|,
operator|(
name|compare_func_type
operator|)
name|compare_strings
argument_list|)
expr_stmt|;
name|init
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|Class_t
name|objc_getClass
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Class_t
name|class
decl_stmt|;
comment|/* Make sure the class hash table exists.  */
name|class_hash_init
argument_list|()
expr_stmt|;
name|class
operator|=
name|hash_value_for_key
argument_list|(
name|class_hash_table
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|class
return|;
block|}
end_function

begin_function
name|MetaClass_t
name|objc_getMetaClass
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Meta classes are pointed to by the class's class_pointer.      Just get the class and return its class_pointer.  */
return|return
operator|(
name|objc_getClass
argument_list|(
name|name
argument_list|)
operator|)
operator|->
name|class_pointer
return|;
block|}
end_function

begin_function
name|void
name|addClassToHash
parameter_list|(
name|Class_t
name|class
parameter_list|)
block|{
name|Class_t
name|hClass
decl_stmt|;
name|class_hash_init
argument_list|()
expr_stmt|;
comment|/* Check to see if the class is already in the hash table.  */
name|hClass
operator|=
name|hash_value_for_key
argument_list|(
name|class_hash_table
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hClass
condition|)
block|{
comment|/* The class isn't in the hash table.  Add the class and         assign a class number.  */
specifier|static
name|unsigned
name|int
name|class_number
init|=
literal|1
decl_stmt|;
name|setClassNumber
argument_list|(
name|class
argument_list|,
name|class_number
argument_list|)
expr_stmt|;
name|setClassNumber
argument_list|(
operator|(
name|Class_t
operator|)
name|class
operator|->
name|class_pointer
argument_list|,
name|class_number
argument_list|)
expr_stmt|;
operator|++
name|class_number
expr_stmt|;
name|hash_add
argument_list|(
operator|&
name|class_hash_table
argument_list|,
name|class
operator|->
name|name
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|debug_dump_classes
parameter_list|(
name|void
parameter_list|)
block|{
name|node_ptr
name|node
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"class tables\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class_t
name|class
init|=
name|node
operator|->
name|value
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"Class { /*%#x*/\n"
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   MetaClass_t  class_pointer = %#x\n"
argument_list|,
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   Class_t      super_class   = %#x\n"
argument_list|,
name|class
operator|->
name|super_class
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   char         *name          = %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   long         version       = %ld\n"
argument_list|,
name|class
operator|->
name|version
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   long         info          = %#x\n"
argument_list|,
name|class
operator|->
name|info
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   long         instance_size = %ld\n"
argument_list|,
name|class
operator|->
name|instance_size
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   IvarList_t   ivars         = %#x\n"
argument_list|,
name|class
operator|->
name|ivars
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   MethodList_t methods       = %#x\n"
argument_list|,
name|class
operator|->
name|methods
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   cache_ptr      cache         = %#x\n"
argument_list|,
name|class
operator|->
name|cache
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"}[%d];\n"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|class_hash_table
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class_t
name|class
init|=
call|(
name|Class_t
call|)
argument_list|(
call|(
name|Class_t
call|)
argument_list|(
name|node
operator|->
name|value
argument_list|)
argument_list|)
operator|->
name|class_pointer
decl_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"MetaClass { /*%#x*/\n"
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   MetaClass_t  class_pointer = %#x\n"
argument_list|,
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   MetaClass_t  super_class   = %#x\n"
argument_list|,
name|class
operator|->
name|super_class
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   char         *name          = %s\n"
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   long         version       = %ld\n"
argument_list|,
name|class
operator|->
name|version
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   long         info          = %#x\n"
argument_list|,
name|class
operator|->
name|info
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   long         instance_size = %ld\n"
argument_list|,
name|class
operator|->
name|instance_size
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   IvarList_t   ivars         = %#x\n"
argument_list|,
name|class
operator|->
name|ivars
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   MethodList_t methods       = %#x\n"
argument_list|,
name|class
operator|->
name|methods
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"   cache_ptr      cache         = %#x\n"
argument_list|,
name|class
operator|->
name|cache
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"}[%d];\n"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

