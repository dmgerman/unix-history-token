begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_req.c	4.47 (Berkeley) 7/1/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_req.c,v 1.1 1993/06/01 02:33:47 vixie Exp vixie $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986, 1988, 1990  * -  * Copyright (c) 1986, 1988, 1990 Regents of the University of California.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"../conf/portability.h"
end_include

begin_include
include|#
directive|include
file|"../conf/options.h"
end_include

begin_include
include|#
directive|include
file|"ns.h"
end_include

begin_include
include|#
directive|include
file|"db.h"
end_include

begin_define
define|#
directive|define
name|NADDRECS
value|20
end_define

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|ddt
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|addinfo
block|{
name|char
modifier|*
name|a_dname
decl_stmt|;
comment|/* domain name */
name|u_short
name|a_class
decl_stmt|;
comment|/* class for address */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|addinfo
name|addinfo
index|[
name|NADDRECS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* additional info records */
end_comment

begin_function_decl
specifier|static
name|void
name|addname
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|addcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of names in addinfo */
end_comment

begin_decl_stmt
name|int
name|xfr_disabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to disable zone xfrs */
end_comment

begin_decl_stmt
name|int
name|needs_prime_cache
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if we need a priming */
end_comment

begin_decl_stmt
name|u_char
modifier|*
name|dnptrs
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptrs to dnames in message for dn_comp */
end_comment

begin_function_decl
specifier|extern
name|int
name|writemsg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* db_glue.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|fp_query
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|dn_comp
argument_list|()
decl_stmt|,
name|add_data
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|prime_cache
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|time_t
name|retrytime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|qinfo
modifier|*
name|sysquery
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LOCALDOM
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|localdomain
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XFRNETS
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|netinfo
modifier|*
name|xfrnets
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|stale
argument_list|()
decl_stmt|,
name|make_rr
argument_list|()
decl_stmt|,
name|doaddinfo
argument_list|()
decl_stmt|,
name|doaddauth
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ns_req
argument_list|()
decl_stmt|,
name|fwritemsg
argument_list|()
decl_stmt|,
name|getname
argument_list|()
decl_stmt|,
name|doaxfr
argument_list|()
decl_stmt|,
name|startxfr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process request using database; assemble and send response.  */
end_comment

begin_function
name|void
name|ns_req
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|buflen
parameter_list|,
name|qsp
parameter_list|,
name|from
parameter_list|,
name|dfd
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|,
name|buflen
decl_stmt|;
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
name|int
name|dfd
decl_stmt|;
block|{
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|lp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|,
modifier|*
name|answers
decl_stmt|;
name|u_char
modifier|*
name|eom
decl_stmt|,
modifier|*
name|omsg
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|count
decl_stmt|,
name|foundname
decl_stmt|,
name|founddata
decl_stmt|,
name|omsglen
decl_stmt|,
name|cname
init|=
literal|0
decl_stmt|;
name|u_short
name|id
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
specifier|extern
name|struct
name|netinfo
modifier|*
name|local
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|fwdinfo
modifier|*
name|fwdtab
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"ns_req()\n"
argument_list|)
expr_stmt|;
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|qr
condition|)
block|{
name|ns_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
comment|/* Now is a safe time for housekeeping */
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
return|return;
block|}
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|eom
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
name|addcount
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|opcode
condition|)
block|{
case|case
name|QUERY
case|:
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_QUERIES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|1
operator|||
name|hp
operator|->
name|ancount
operator|||
name|hp
operator|->
name|nscount
operator|||
name|hp
operator|->
name|arcount
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR Query header counts wrong\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 		 * Get domain name, class, and type. 		 */
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
operator|*
name|dpp
operator|++
operator|=
name|cp
expr_stmt|;
comment|/* remember name for compression */
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR Query expand name failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR Query message length short\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|cp
operator|<
name|eom
condition|)
if|if
condition|(
name|debug
operator|>
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"message length> received message\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
operator|(
name|type
operator|>
name|T_ANY
operator|)
operator|||
operator|(
name|type
operator|<
literal|0
operator|)
condition|)
name|typestats
index|[
literal|0
index|]
operator|++
expr_stmt|;
comment|/* Bad type */
else|else
name|typestats
index|[
name|type
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Process query. 		 */
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
comment|/* refuse request if not a TCP connection */
if|if
condition|(
name|qsp
operator|==
name|QSTREAM_NULL
operator|||
name|xfr_disabled
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"T_AXFR via UDP refused\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|refuse
goto|;
block|}
ifdef|#
directive|ifdef
name|XFRNETS
if|if
condition|(
name|xfrnets
condition|)
block|{
comment|/* if xfrnets was specified, peer address 				 * must be on it.  should probably allow 				 * for negation some day. (vix@decwrl) 				 */
name|struct
name|sockaddr
name|saddr
decl_stmt|;
name|int
name|slen
init|=
operator|(
sizeof|sizeof
name|saddr
operator|)
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|iaddr
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|saddr
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|getpeername
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
operator|&
name|saddr
argument_list|,
operator|&
name|slen
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"getpeername: %m"
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
if|if
condition|(
name|saddr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"af%d???"
argument_list|,
name|saddr
operator|.
name|sa_family
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
if|if
condition|(
operator|!
name|net_on_netlist
argument_list|(
name|iaddr
operator|->
name|sin_addr
argument_list|,
name|xfrnets
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"dangerous TCP addr: %s %u"
argument_list|,
name|inet_ntoa
argument_list|(
name|iaddr
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|iaddr
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
block|}
endif|#
directive|endif
comment|/*XFRNETS*/
name|dnptrs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* don't compress names */
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* recursion not possible */
block|}
name|buflen
operator|-=
name|msglen
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|foundname
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|dnbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|QRYLOG
if|if
condition|(
name|qrylog
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"XX /%s/%s/%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|dname
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*QRYLOG*/
name|try_again
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: nlookup(%s) id %d type=%d\n"
argument_list|,
name|dname
argument_list|,
name|hp
operator|->
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fname
operator|=
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: %s '%s' as '%s' (cname=%d)\n"
argument_list|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
argument_list|,
name|dname
argument_list|,
name|fname
argument_list|,
name|cname
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCALDOM
comment|/* 		 * if nlookup failed to find the name then 		 * see if there are any '.''s in the name 		 * if not then add local domain name to the 		 * name and try again. 		 */
if|if
condition|(
name|np
operator|==
name|NULL
operator|&&
name|localdomain
operator|&&
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dname
argument_list|,
name|localdomain
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: nlookup(%s) type=%d\n"
argument_list|,
name|dname
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*LOCALDOM*/
ifdef|#
directive|ifdef
name|YPKLUDGE
comment|/* Some braindamaged resolver software will not  		   recognize internet addresses in dot notation and  		   send out address  queries for "names" such as  		   128.93.8.1.  This kludge will prevent those  		   from flooding higher level servers. 		   We simply claim to be authoritative and that 		   the domain doesn't exist. 		   Note that we could return the address but we 		   don't do that in order to encourage that broken 		   software is fixed. 		*/
if|if
condition|(
name|np
operator|==
name|NULL
operator|&&
name|type
operator|==
name|T_A
operator|&&
name|class
operator|==
name|C_IN
operator|&&
name|dname
condition|)
block|{
name|struct
name|sockaddr_in
name|ina
decl_stmt|;
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|dname
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"ypkludge: hit as '%s'\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|finish
goto|;
block|}
block|}
endif|#
directive|endif
comment|/*YPKLUDGE*/
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
goto|goto
name|fetchns
goto|;
name|foundname
operator|++
expr_stmt|;
name|answers
operator|=
operator|(
name|char
operator|*
operator|)
name|cp
expr_stmt|;
name|count
operator|=
name|cp
operator|-
name|msg
expr_stmt|;
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* NO data available.  Refuse AXFR requests, or 			 * look for better servers for other requests. 			 */
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"T_AXFR refused: no data\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|refuse
goto|;
block|}
else|else
goto|goto
name|fetchns
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|msglen
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|type
operator|!=
name|T_CNAME
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
block|{
if|if
condition|(
name|cname
operator|++
operator|>=
name|MAXCNAMES
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: leaving, MAXCNAMES exceeded\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: foundname = %d count = %d "
argument_list|,
name|foundname
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"founddata = %d cname = %d\n"
argument_list|,
name|founddata
argument_list|,
name|cname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|lp
operator|=
name|local
argument_list|(
name|from
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sort_response
argument_list|(
name|answers
argument_list|,
name|count
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|startxfr
argument_list|(
name|qsp
argument_list|,
name|np
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|)
expr_stmt|;
name|sqrm
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 		 * If we found an authoritative answer, 		 * we're done. 		 */
if|if
condition|(
name|hp
operator|->
name|aa
condition|)
goto|goto
name|finish
goto|;
endif|#
directive|endif
name|fetchns
label|:
comment|/* 	 	 * Look for name servers to refer to and fill in the authority 	 	 * section or record the address for forwarding the query 	 	 * (recursion desired). 	 	 */
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* del@harris */
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
if|if
condition|(
operator|!
name|foundname
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: leaving (%s, rcode %d)\n"
argument_list|,
name|dname
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|class
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX 				 * should return SOA if founddata == 0, 				 * but old named's are confused by an SOA 				 * in the auth. section if there's no error. 				 */
if|if
condition|(
name|foundname
operator|==
literal|0
operator|&&
name|np
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
block|}
goto|goto
name|finish
goto|;
case|case
name|SERVFAIL
case|:
if|if
condition|(
operator|!
name|founddata
operator|&&
operator|!
operator|(
name|forward_only
operator|&&
name|fwdtab
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
comment|/* 		 *  If we successfully found the answer in the cache 		 *  or this is not a recursive query, then add the 		 *  nameserver references ("authority section") here 		 *  and return. 		 */
if|if
condition|(
name|founddata
operator|||
operator|(
operator|!
name|hp
operator|->
name|rd
operator|)
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|count
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 		 *  At this point, we don't have the answer, but we do 		 *  have some NS's to try.  If the user would like us 		 *  to recurse, create the initial query.  If a cname 		 *  is involved, we need to build a new query and save 		 *  the old one in cmsg/cmsglen. 		 */
if|if
condition|(
name|cname
condition|)
block|{
name|omsg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|omsg
operator|==
operator|(
name|u_char
operator|*
operator|)
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"ns_req: malloc fail\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ns_req: Out Of Memory"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
break|break;
block|}
name|id
operator|=
name|hp
operator|->
name|id
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|msg
argument_list|,
name|omsg
argument_list|,
name|omsglen
operator|=
name|msglen
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
operator|+
name|buflen
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
operator|&
name|qp
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|FW_OK
operator|&&
name|cname
condition|)
name|free
argument_list|(
name|omsg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|FW_OK
case|:
if|if
condition|(
name|cname
condition|)
block|{
name|qp
operator|->
name|q_cname
operator|=
name|cname
expr_stmt|;
name|qp
operator|->
name|q_cmsg
operator|=
operator|(
name|char
operator|*
operator|)
name|omsg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|omsglen
expr_stmt|;
name|qp
operator|->
name|q_id
operator|=
name|id
expr_stmt|;
block|}
break|break;
case|case
name|FW_DUP
case|:
break|break;
comment|/* Duplicate request dropped */
case|case
name|FW_NOSERVER
case|:
comment|/*  			** Don't go into an infinite loop if  			** the admin gave root NS records in the cache 			** file without giving address records 			** for the root servers. 			*/
if|if
condition|(
name|np
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"ns_req: no address for root server\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ns_req: no address for root server"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|np
operator|=
name|np
operator|->
name|n_parent
expr_stmt|;
block|}
goto|goto
name|fetchns
goto|;
comment|/* Try again. */
case|case
name|FW_SERVFAIL
case|:
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Now is a safe time for housekeeping */
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
return|return;
if|#
directive|if
name|INVQ
case|case
name|IQUERY
case|:
block|{
specifier|register
name|struct
name|invbuf
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|dlen
decl_stmt|,
name|alen
decl_stmt|;
name|char
name|anbuf
index|[
name|PACKETSZ
index|]
decl_stmt|,
modifier|*
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_IQUERIES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|ancount
operator|!=
literal|1
operator|||
name|hp
operator|->
name|qdcount
operator|||
name|hp
operator|->
name|nscount
operator|||
name|hp
operator|->
name|arcount
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR IQuery header counts wrong\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* 		 * Skip domain name, get class, and type. 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR IQuery packet name problem\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|eom
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR IQuery message length off\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* not all inverse queries are handled. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
break|break;
default|default:
goto|goto
name|refuse
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: IQuery class %d type %d\n"
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|anbuf
argument_list|,
name|alen
operator|=
operator|(
name|char
operator|*
operator|)
name|cp
operator|-
name|fname
argument_list|)
expr_stmt|;
name|data
operator|=
name|anbuf
operator|+
name|alen
operator|-
name|dlen
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|fname
expr_stmt|;
name|buflen
operator|-=
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|invtab
index|[
name|dhash
argument_list|(
name|data
argument_list|,
name|dlen
argument_list|)
index|]
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INVBLKSZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|np
operator|=
name|ip
operator|->
name|i_dname
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"dname = %d\n"
argument_list|,
name|np
operator|->
name|n_dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_size
operator|!=
name|dlen
operator|||
name|bcmp
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
condition|)
continue|continue;
name|getname
argument_list|(
name|np
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: IQuery found %s\n"
argument_list|,
name|dnbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buflen
operator|-=
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|dnbuf
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|dp
operator|->
name|d_type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|dp
operator|->
name|d_class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: IQuery %d records\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|alen
operator|>
name|buflen
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|anbuf
argument_list|,
name|cp
argument_list|,
name|alen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|alen
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/*INVQ*/
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
comment|/*  * In a sense the following constant should be defined in<arpa/nameser.h>,  * since it is returned here in place of a response code if the update was  * forwarded, and the response codes are defined in nameser.h.  On the other  * hand, though, this constant is only seen in this file.  The assumption  * here is that none of the other return codes equals this one (a good  * assumption, since they only occupy 4 bits over-the-wire)  */
define|#
directive|define
name|FORWARDED
value|1000
comment|/* Call InitDynUpdate for all dynamic update requests */
case|case
name|UPDATEM
case|:
case|case
name|UPDATEMA
case|:
case|case
name|UPDATED
case|:
case|case
name|UPDATEDA
case|:
case|case
name|UPDATEA
case|:
name|n
operator|=
name|InitDynUpdate
argument_list|(
name|hp
argument_list|,
name|nsp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|cp
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|FORWARDED
condition|)
return|return;
comment|/* Return directly because InitDynUpdate                                  * forwarded the query to the primary, so we                                  * will send response later                                  */
else|else
break|break;
comment|/* Either sucessful primary update or failure;                                  * return response code to client                                  */
endif|#
directive|endif
comment|/* ALLOW_UPDATES */
case|case
name|ZONEREF
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Refresh Zone\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*FALLTHROUGH*/
default|default:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Opcode %d not implemented\n"
argument_list|,
name|hp
operator|->
name|opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOTIMP
expr_stmt|;
block|}
goto|goto
name|finish
goto|;
name|refuse
label|:
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|finish
label|:
ifdef|#
directive|ifdef
name|STATS
switch|switch
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
case|case
name|NOERROR
case|:
name|stats
index|[
name|S_RESPOK
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
name|stats
index|[
name|S_RESPFORMERR
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
break|break;
default|default:
name|stats
index|[
name|S_RESPFAIL
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
comment|/* set Response flag */
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
comment|/* Recursion is Available */
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|addcount
condition|)
block|{
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: answer -> %s %d (%d) id=%d %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|qsp
operator|==
name|QSTREAM_NULL
condition|?
name|dfd
else|:
name|qsp
operator|->
name|s_rfd
argument_list|,
name|ntohs
argument_list|(
name|from
operator|->
name|sin_port
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|,
name|local
argument_list|(
name|from
argument_list|)
operator|==
name|NULL
condition|?
literal|"Remote"
else|:
literal|"Local"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|qsp
operator|==
name|QSTREAM_NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|dfd
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"error returning msg errno=%d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_OUTPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
operator|(
name|void
operator|)
name|writemsg
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
comment|/* Now is a safe time */
block|}
end_function

begin_function
name|void
name|fwritemsg
parameter_list|(
name|rfp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
name|u_short
name|len
init|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|msglen
argument_list|)
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
literal|1
argument_list|,
name|rfp
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
literal|1
argument_list|,
name|rfp
argument_list|)
operator|!=
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"fwrite failed %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  *  Test a datum for validity and return non-zero if it is out of date.  */
end_comment

begin_function
name|int
name|stale
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
decl_stmt|;
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_PRIMARY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|Z_SECONDARY
case|:
comment|/* 		 * Check to see whether a secondary zone 		 * has expired; if so clear authority flag 		 * for zone and return true.  If lastupdate 		 * is in the future, assume zone is up-to-date. 		 */
if|if
condition|(
call|(
name|int32_t
call|)
argument_list|(
name|tt
operator|.
name|tv_sec
operator|-
name|zp
operator|->
name|z_lastupdate
argument_list|)
operator|>
operator|(
name|int32_t
operator|)
name|zp
operator|->
name|z_expire
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"stale: secondary zone %s expired\n"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stale
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"secondary zone \"%s\" expired"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_state
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|Z_CACHE
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"stale: ttl %d %d (x%x)\n"
argument_list|,
name|dp
operator|->
name|d_ttl
argument_list|,
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
argument_list|,
name|dp
operator|->
name|d_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Copy databuf into a resource record for replies.  * Return size of RR if OK, -1 if buffer is full.  */
end_comment

begin_function
name|int
name|make_rr
parameter_list|(
name|name
parameter_list|,
name|dp
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|doadd
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|doadd
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
specifier|register
name|int32_t
name|n
decl_stmt|;
specifier|register
name|int32_t
name|ttl
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|edp
init|=
name|dnptrs
operator|+
sizeof|sizeof
argument_list|(
name|dnptrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dnptrs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"make_rr(%s, %x, %x, %d, %d) %d zone %d ttl %d\n"
argument_list|,
name|name
argument_list|,
name|dp
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|doadd
argument_list|,
name|dp
operator|->
name|d_size
argument_list|,
name|dp
operator|->
name|d_zone
argument_list|,
name|dp
operator|->
name|d_ttl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zp
operator|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
expr_stmt|;
comment|/* check for outdated RR before updating dnptrs by dn_comp() (???) */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
operator|-
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|||
operator|(
name|ttl
operator|<
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
comment|/*XXX*/
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"make_rr: %d=>0, x%x\n"
argument_list|,
name|ttl
argument_list|,
name|dp
operator|->
name|d_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|d_ttl
condition|)
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
expr_stmt|;
else|else
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
comment|/* really default */
ifdef|#
directive|ifdef
name|notdef
comment|/* don't decrease ttl based on time since verification */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_SECONDARY
condition|)
block|{
comment|/* 			 * Set ttl to value received from primary, 			 * less time since we verified it (but never 			 * less than a small positive value). 			 */
name|ttl
operator|-=
name|tt
operator|.
name|tv_sec
operator|-
name|zp
operator|->
name|z_lastupdate
expr_stmt|;
if|if
condition|(
name|ttl
operator|<=
literal|0
condition|)
name|ttl
operator|=
literal|120
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|buflen
operator|-=
name|RRFIXEDSZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|name
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|buf
operator|+
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|dp
operator|->
name|d_type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|dp
operator|->
name|d_class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_CNAME
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_MB
case|:
case|case
name|T_NS
case|:
comment|/* Store domain name in answer */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|?
name|n
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
else|:
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
block|{
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|n
operator|=
name|dp
operator|->
name|d_size
operator|-
operator|(
name|cp1
operator|-
name|dp
operator|->
name|d_data
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
comment|/* cp1 == our data/ cp == data of RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
comment|/* copy preference */
name|bcopy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|cp1
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|buflen
operator|-=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|dp
operator|->
name|d_size
operator|>
name|buflen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bcopy
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_short
operator|)
name|dp
operator|->
name|d_size
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dp
operator|->
name|d_size
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|addname
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|short
name|class
decl_stmt|;
block|{
specifier|register
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
operator|,
name|n
operator|=
name|addcount
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* add domain name to additional section */
if|if
condition|(
name|addcount
operator|<
name|NADDRECS
condition|)
block|{
name|addcount
operator|++
expr_stmt|;
name|ap
operator|->
name|a_dname
operator|=
name|name
expr_stmt|;
name|ap
operator|->
name|a_class
operator|=
name|class
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup addresses for names in addinfo and put into the message's  * additional section.  */
end_comment

begin_function
name|int
name|doaddinfo
parameter_list|(
name|hp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"doaddinfo() addcount = %d\n"
argument_list|,
name|addcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"doaddinfo(): tc already set, bailing\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|msg
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|int
name|foundstale
init|=
literal|0
decl_stmt|,
name|foundany
init|=
literal|0
decl_stmt|,
name|save_count
init|=
name|count
decl_stmt|,
name|save_msglen
init|=
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|save_cp
init|=
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"do additional '%s'\n"
argument_list|,
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* because "nlookup" stomps on arg. */
name|np
operator|=
name|nlookup
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|ap
operator|->
name|a_dname
condition|)
goto|goto
name|next_rr
goto|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"found it\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* look for the data */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
condition|)
continue|continue;
name|foundany
operator|++
expr_stmt|;
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|foundstale
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"doaddinfo: stale entry '%s'%s\n"
argument_list|,
name|np
operator|->
name|n_dname
argument_list|,
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|?
literal|" hint"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* 			 *  Should be smart and eliminate duplicate 			 *  data here.	XXX 			 */
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* truncation in the additional-data section 				 * is not all that serious.  we do not set TC, 				 * since the answer and authority sections are 				 * OK; however, since we're not setting TC we 				 * have to make sure that none of the RR's for 				 * this name go out (!TC implies that all 				 * {name,type} appearances are complete -- and 				 * since we only do A RR's here, the name is 				 * the key).	vixie, 23apr93 				 */
name|cp
operator|=
name|save_cp
expr_stmt|;
name|msglen
operator|=
name|save_msglen
expr_stmt|;
name|count
operator|=
name|save_count
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"addinfo: adding address data n = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|+=
name|n
expr_stmt|;
name|msglen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|next_rr
label|:
if|if
condition|(
name|foundstale
condition|)
block|{
comment|/* Cache invalidate the address RR's */
name|delete_all
argument_list|(
name|np
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foundstale
operator|||
operator|!
name|foundany
condition|)
block|{
comment|/* ask a real server for this info */
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
block|}
block|}
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|msg
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doaddauth
parameter_list|(
name|hp
parameter_list|,
name|cp
parameter_list|,
name|buflen
parameter_list|,
name|np
parameter_list|,
name|dp
parameter_list|)
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
operator|||
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dnbuf
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"doaddauth: can't add '%s' (%d) (n=%d)\n"
argument_list|,
name|dnbuf
argument_list|,
name|buflen
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the domain name of 'np' and put in 'buf'.  Bounds checking is done.  */
end_comment

begin_function
name|void
name|getname
parameter_list|(
name|np
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|np
operator|->
name|n_dname
argument_list|)
operator|)
operator|+
literal|1
operator|>=
name|buflen
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"domain name too long: %s...\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"Name_Too_Long"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|np
operator|->
name|n_dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|i
expr_stmt|;
name|buflen
operator|-=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|np
operator|=
name|np
operator|->
name|n_parent
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do a zone transfer (or a recursive part of a zone transfer).  * SOA record already sent.  *  * top always refers to the domain at the top of the zone being transferred.  * np refers to a domain inside the zone being transferred,  *	which will be equal to top if this is the first call,  *	or will be a subdomain below top if this is a recursive call,  * rfp is a stdio file to which output is sent.  */
end_comment

begin_function
name|void
name|doaxfr
parameter_list|(
name|np
parameter_list|,
name|rfp
parameter_list|,
name|top
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|top
decl_stmt|;
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|gdp
decl_stmt|;
comment|/* glue databuf */
name|struct
name|namebuf
modifier|*
name|gnp
decl_stmt|;
comment|/* glue namebuf */
name|struct
name|namebuf
modifier|*
name|tnp
decl_stmt|;
comment|/* top namebuf */
name|struct
name|databuf
modifier|*
name|tdp
decl_stmt|;
comment|/* top databuf */
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|,
modifier|*
modifier|*
name|nppend
decl_stmt|;
name|char
name|msg
index|[
name|PACKETSZ
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|int
name|fndns
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|(
name|np
operator|==
name|top
operator|)
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"doaxfr()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fndns
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|opcode
operator|=
name|QUERY
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
name|hp
operator|->
name|tc
operator|=
name|hp
operator|->
name|ra
operator|=
name|hp
operator|->
name|pr
operator|=
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
operator|)
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first do the NS records (del@harris) */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
block|{
name|fndns
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|top
condition|)
block|{
comment|/*  Glue the sub domains together by sending  		     *  the address records for the sub domain 		     *  name servers along if necessary. 		     *  Glue is necessary if the server is in any zone 		     *  delegated from the current (top) zone.  Such 		     *  a delegated zone might or might not be that 		     *  referred to by the NS record now being handled. 		     */
name|htp
operator|=
name|hashtab
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
operator|)
expr_stmt|;
name|gnp
operator|=
name|nlookup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
condition|)
continue|continue;
for|for
control|(
name|tnp
operator|=
name|gnp
init|;
name|tnp
operator|!=
name|NULL
condition|;
name|tnp
operator|=
name|tnp
operator|->
name|n_parent
control|)
if|if
condition|(
name|tnp
operator|==
name|top
condition|)
break|break;
if|if
condition|(
name|tnp
operator|==
name|NULL
condition|)
continue|continue;
comment|/* name server is not below top domain */
for|for
control|(
name|tnp
operator|=
name|gnp
init|;
name|tnp
operator|!=
name|top
condition|;
name|tnp
operator|=
name|tnp
operator|->
name|n_parent
control|)
block|{
for|for
control|(
name|tdp
operator|=
name|tnp
operator|->
name|n_data
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|d_next
control|)
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
break|break;
if|if
condition|(
name|tdp
operator|!=
name|NULL
condition|)
break|break;
comment|/* found a zone cut */
block|}
if|if
condition|(
name|tnp
operator|==
name|top
condition|)
continue|continue;
comment|/* name server is not in a delegated zone */
comment|/* now we know glue records are needed.  send them. */
for|for
control|(
name|gdp
operator|=
name|gnp
operator|->
name|n_data
init|;
name|gdp
operator|!=
name|NULL
condition|;
name|gdp
operator|=
name|gdp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|gdp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|stale
argument_list|(
name|gdp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|fname
argument_list|,
name|gdp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* no need to send anything else because of delegation */
if|if
condition|(
operator|(
name|np
operator|!=
name|top
operator|)
operator|&&
name|fndns
condition|)
return|return;
comment|/* do the rest of the data records */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
comment|/* 		 * Skip the top SOA record (marks end of data); 		 * don't send SOA for subdomains, as we're not sending them; 		 * skip the NS records because we did them first. 		 */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|||
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|||
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finally do non-delegated subdomains.  Delegated subdomains 	 * have already been handled. 	 */
comment|/* 	 * We find the subdomains by looking in the hash table for this 	 * domain, but the root domain needs special treatment, because 	 * of the following wart in the database design: 	 * 	 * The top level hash table (pointed to by the global `hashtab' 	 * variable) contains pointers to the namebuf's for the root as 	 * well as for the top-level domains below the root, in contrast 	 * to the usual situation where a hash table contains entries 	 * for domains at the same level.  The n_hash member of the 	 * namebuf for the root domain is NULL instead of pointing to a 	 * hashbuf for the top-level domains.  The n_parent members of 	 * the namebufs for the top-level domains are NULL instead of 	 * pointing to the namebuf for the root. 	 * 	 * We work around the wart as follows: 	 * 	 * If we are not dealing with the root zone then we just set 	 * htp = np->n_hash, pointing to the hash table for the current 	 * domain, and we walk through the hash table as usual, 	 * processing the namebufs for all the subdomains. 	 * 	 * If we are dealing with the root zone, then we set 	 * htp = hashtab, pointing to the global hash table (because 	 * there is no hash table associated with the root domain's 	 * namebuf.  While we walk this hash table, we take care not to 	 * recursively process the entry for the root namebuf. 	 * 	 * (apb@und nov1990) 	 */
name|htp
operator|=
operator|(
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
name|hashtab
else|:
name|np
operator|->
name|n_hash
operator|)
expr_stmt|;
if|if
condition|(
name|htp
operator|==
name|NULL
condition|)
block|{
return|return;
comment|/* no subdomains */
block|}
name|npp
operator|=
name|htp
operator|->
name|h_tab
expr_stmt|;
name|nppend
operator|=
name|npp
operator|+
name|htp
operator|->
name|h_size
expr_stmt|;
while|while
condition|(
name|npp
operator|<
name|nppend
condition|)
block|{
for|for
control|(
name|np
operator|=
operator|*
name|npp
operator|++
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* don't redo root domain */
name|doaxfr
argument_list|(
name|np
argument_list|,
name|rfp
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|(
name|np
operator|==
name|top
operator|)
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"exit doaxfr()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
end_ifdef

begin_comment
comment|/*  * Called by UPDATE{A,D,DA,M,MA} to initiate a dynamic update.  If this is the  * primary server for the zone being updated, we update the zone's serial  * number and then call doupdate directly. If this is a secondary, we just  * forward the update; this way, if the primary update fails (e.g., if the  * primary is unavailable), we don't update the secondary; if the primary  * update suceeds, ns_resp will get called with the response (when it comes  * in), and then update the secondary's copy.  */
end_comment

begin_expr_stmt
name|InitDynUpdate
argument_list|(
name|hp
argument_list|,
name|nsp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|startcp
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|)
specifier|register
name|HEADER
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|databuf
modifier|*
name|nsp
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msglen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|startcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
comment|/* lookup relative to root */
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|olddp
decl_stmt|,
modifier|*
name|newdp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|startcp
decl_stmt|;
name|short
name|class
decl_stmt|,
name|type
decl_stmt|;
name|int
name|n
decl_stmt|,
name|size
decl_stmt|,
name|zonenum
decl_stmt|;
name|char
name|ZoneName
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|znp
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR InitDynUpdate expand name failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
comment|/* T_SOA updates not allowed */
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"InitDynUpdate: REFUSED - SOA update\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|size
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/****XXX - need bounds checking here ****/
name|cp
operator|+=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dnbuf
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* zone not found */
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
name|zp
operator|=
operator|&
name|zones
index|[
name|zonenum
index|]
expr_stmt|;
comment|/* Disallow updates for which we aren't authoratative.  Note: the 	   following test doesn't work right:  If it's for a non-local zone, 	   we will think it's a primary but be unable to lookup the namebuf, 	   thus returning 'NXDOMAIN' */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_PRIMARY
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|Z_SECONDARY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"InitDynUpdate: REFUSED - non-primary, non-sedondary update\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_state
operator|&
name|Z_DYNAMIC
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"InitDynUpdate: REFUSED - dynamic flag not set for zone\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
comment|/* 	 * Lookup the zone namebuf.  Lookup "xyz" not "xyz.", since 	 * otherwise the lookup fails, because '.' may have a nil n_hash 	 * associated with it. 	 */
name|strcpy
argument_list|(
name|ZoneName
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|znp
operator|=
operator|&
name|ZoneName
index|[
name|strlen
argument_list|(
name|ZoneName
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|znp
operator|==
literal|'.'
condition|)
operator|*
name|znp
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|ZoneName
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fname
operator|!=
name|ZoneName
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"InitDynUpdate: lookup failed on zone (%s)\n"
argument_list|,
name|ZoneName
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"InitDynUpdate: lookup failed on zone (%s)\n"
argument_list|,
name|ZoneName
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
comment|/* 	 * If this is the primary copy increment the serial number.  Don't 	 * increment the serial number if this is a secondary; this way, if 2 	 * different secondaries both update the primary, they will both have 	 * lower serial numbers than the primary has, and hence eventually 	 * refresh and get all updates and become consistent. 	 * 	 * Note that the serial number must be incremented in both the zone 	 * data structure and the zone's namebuf. 	 */
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_SECONDARY
case|:
comment|/* forward update to primary */
name|nspp
operator|=
name|nsp
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
block|{
if|if
condition|(
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
operator|*
name|nspp
operator|++
operator|=
name|dp
expr_stmt|;
else|else
break|break;
block|}
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
comment|/* Delimiter */
if|if
condition|(
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
name|NULL
argument_list|,
name|dnbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
return|return
operator|(
name|FORWARDED
operator|)
return|;
case|case
name|Z_PRIMARY
case|:
name|zp
operator|->
name|z_serial
operator|++
expr_stmt|;
name|olddp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
comment|/* old databuf */
comment|/* Find the SOA record */
for|for
control|(
name|olddp
operator|=
name|np
operator|->
name|n_data
init|;
name|olddp
operator|!=
name|NULL
condition|;
name|olddp
operator|=
name|olddp
operator|->
name|d_next
control|)
if|if
condition|(
name|match
argument_list|(
name|olddp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
break|break;
if|if
condition|(
name|olddp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"InitDynUpdate: Couldn't find SOA record for '%s'\n"
argument_list|,
name|ZoneName
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"InitDynUpdate: Couldn't find SOA record for '%s'\n"
argument_list|,
name|ZoneName
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
name|newdp
operator|=
name|savedata
argument_list|(
name|olddp
operator|->
name|d_class
argument_list|,
name|olddp
operator|->
name|d_type
argument_list|,
name|olddp
operator|->
name|d_ttl
argument_list|,
name|olddp
operator|->
name|d_data
argument_list|,
name|olddp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|newdp
operator|->
name|d_zone
operator|=
name|olddp
operator|->
name|d_zone
expr_stmt|;
ifdef|#
directive|ifdef
name|CRED
name|newdp
operator|->
name|d_cred
operator|=
name|DB_C_AUTH
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|newdp
operator|->
name|d_data
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip origin string */
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip in-charge string */
name|putlong
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
name|zp
operator|->
name|z_serial
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"after stuffing data into newdp:\n"
argument_list|)
expr_stmt|;
name|printSOAdata
argument_list|(
name|newdp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|ZoneName
argument_list|,
name|olddp
argument_list|,
name|newdp
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|!=
name|NOERROR
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"InitDynUpdate: SOA update failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
comment|/* vix@dec mar92 */
return|return
operator|(
name|NOCHANGE
operator|)
return|;
block|}
comment|/* Now update the RR itself */
if|if
condition|(
name|doupdate
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
name|zonenum
argument_list|,
operator|(
expr|struct
name|databuf
operator|*
operator|)
literal|0
argument_list|,
name|DB_NODATA
ifdef|#
directive|ifdef
name|CRED
argument_list|,
name|DB_C_AUTH
endif|#
directive|endif
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"InitDynUpdate: doupdate failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* doupdate fills in rcode */
return|return
operator|(
name|hp
operator|->
name|rcode
operator|)
return|;
block|}
name|zp
operator|->
name|z_state
operator||=
name|Z_CHANGED
expr_stmt|;
return|return
operator|(
name|NOERROR
operator|)
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Print the contents of the data in databuf pointed to by dp for an SOA record  */
end_comment

begin_macro
name|printSOAdata
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
return|return;
comment|/* Otherwise fprintf to ddt will bomb */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata(%x): origin(%x)='%s'\n"
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip origin string */
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata: in-charge(%x)='%s'\n"
argument_list|,
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip in-charge string */
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata: serial(%x)=%d\n"
argument_list|,
name|cp
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALLOW_UPDATES */
end_comment

begin_comment
comment|/* rm_datum(dp, np, pdp)  *	remove datum 'dp' from name 'np'.  pdp is previous data pointer.  * return value:  *	"next" field from removed datum, suitable for relinking  */
end_comment

begin_function
name|struct
name|databuf
modifier|*
name|rm_datum
parameter_list|(
name|dp
parameter_list|,
name|np
parameter_list|,
name|pdp
parameter_list|)
specifier|register
name|struct
name|databuf
modifier|*
name|pdp
decl_stmt|,
decl|*
name|dp
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|ndp
init|=
name|dp
operator|->
name|d_next
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"rm_datum(%x, %x, %x) -> %x\n"
argument_list|,
name|dp
argument_list|,
name|np
operator|->
name|n_data
argument_list|,
name|pdp
argument_list|,
name|ndp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|#
directive|if
name|INVQ
name|rminv
argument_list|(
name|dp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pdp
operator|==
name|NULL
condition|)
name|np
operator|->
name|n_data
operator|=
name|ndp
expr_stmt|;
else|else
name|pdp
operator|->
name|d_next
operator|=
name|ndp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
return|return
name|ndp
return|;
block|}
end_block

begin_comment
comment|/* rm_name(np, he, pnp)  *	remove name 'np' from parent 'pp'.  pnp is previous name pointer.  * return value:  *	"next" field from removed name, suitable for relinking  */
end_comment

begin_function
name|struct
name|namebuf
modifier|*
name|rm_name
parameter_list|(
name|np
parameter_list|,
name|pp
parameter_list|,
name|pnp
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
decl|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|pnp
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|namebuf
modifier|*
name|nnp
init|=
name|np
operator|->
name|n_next
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* verify */
if|if
condition|(
operator|(
name|np
operator|->
name|n_data
operator|&&
operator|(
name|msg
operator|=
literal|"data"
operator|)
operator|)
operator|||
operator|(
name|np
operator|->
name|n_hash
operator|&&
operator|(
name|msg
operator|=
literal|"hash"
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"rm_name(%x(%s)): non-nil %s pointer\n"
argument_list|,
name|np
argument_list|,
name|np
operator|->
name|n_dname
condition|?
name|np
operator|->
name|n_dname
else|:
literal|"Nil"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rm_name(%x(%s)): non-nil %s pointer\n"
argument_list|,
name|np
argument_list|,
name|np
operator|->
name|n_dname
condition|?
name|np
operator|->
name|n_dname
else|:
literal|"Nil"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* unlink */
if|if
condition|(
name|pnp
condition|)
block|{
name|pnp
operator|->
name|n_next
operator|=
name|nnp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pp
operator|=
name|nnp
expr_stmt|;
block|}
comment|/* deallocate */
name|free
argument_list|(
name|np
operator|->
name|n_dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|np
argument_list|)
expr_stmt|;
comment|/* done */
return|return
name|nnp
return|;
block|}
end_block

begin_function
name|void
name|startxfr
parameter_list|(
name|qsp
parameter_list|,
name|np
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|int
name|fdstat
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"startxfr()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * child does the work while 	 * the parent continues 	 * 	 * XXX this needs to be a vfork/exec since on non-copy-on-write 	 * systems with huge nameserver images, this is very expensive. 	 */
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"startxfr: child pid %d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rfp
operator|=
name|fdopen
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setproctitle
argument_list|(
literal|"zone XFR to"
argument_list|,
name|qsp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
name|fdstat
operator|=
name|fcntl
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdstat
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|F_SETFL
argument_list|,
name|fdstat
operator|&
operator|~
name|PORT_NONBLOCK
argument_list|)
expr_stmt|;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|doaxfr
argument_list|(
name|np
argument_list|,
name|rfp
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|rfp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

