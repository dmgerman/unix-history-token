begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985, 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that: (1) source distributions retain this entire copyright  * notice and comment, and (2) distributions including binaries display  * the following acknowledgement:  ``This product includes software  * developed by the University of California, Berkeley and its contributors''  * in the documentation or other materials provided with the distribution  * and in all advertising materials mentioning features or use of this  * software. Neither the name of the University nor the names of its  * contributors may be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/*  * Originally, this program came from Rutgers University, however it  * is based on nslookup and other pieces of named tools, so it needs  * that copyright notice.  */
end_comment

begin_comment
comment|/*  * Extensively modified by E. Wassenaar, Nikhef-H,<e07@nikhef.nl>  *  * The officially maintained source of this program is available  * via anonymous ftp from machine 'ftp.nikhef.nl' [192.16.199.1]  * in the directory '/pub/network' as 'host.tar.Z'  *  * Also available in this directory are patched versions of the  * BIND 4.8.3 nameserver and resolver library which you may need  * to fully exploit the features of this program, although they  * are not mandatory. See the file 'README_FIRST' for details.  *  * You are kindly requested to report bugs and make suggestions  * for improvements to the author at the given email address,  * and to not re-distribute your own modifications to others.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			New features  *  * - Major overhaul of the whole code.  * - Very rigid error checking, with more verbose error messages.  * - Zone listing section completely rewritten.  * - It is now possible to do recursive listings into subdomains.  * - Maintain resource record statistics during zone listings.  * - Maintain count of hosts during zone listings.  * - Exploit multiple server addresses if available.  * - Option to exploit only primary server for zone transfers.  * - Option to exclude info from names that do not reside in a domain.  * - Implement timeout handling during connect and read.  * - Write resource record output to optional logfile.  * - Special MB tracing by recursively expanding MR and MG records.  * - Special mode to check SOA records at each nameserver for domain.  * - Special mode to check inverse mappings of host addresses.  * - Code is extensively documented.  */
end_comment

begin_comment
comment|/*  *			Publication history  *  * Revision:	910129  *			Maintain count of hosts during domain listings.  *			Check for hosts with same name as subdomain.  *			Add -H option for special host count mode.  *			Recognize obsolete T_MAILA.  * Revision:	910415  *			Improve finding of subdomain names.  *			Allow subdomains not directly within domain.  *			Check for unauthoritative glue records.  *			Add -T option to print ttl when non-verbose.  *			Improve connect timeout handling.  *			Improve dotted quad parsing.  *			Minimum ttl is now called default ttl.  * Revision:	910905  *			Improve counting of hosts within domain.  *			Allow hosts not directly within domain.  *			Increase (static) maximum number of hosts.  * Revision:	910923  *			Count gateway hosts (with multiple addresses).  *			Add -G option to list gateway hosts.  * Revision:	911010  *			Don't recurse on cnames if querytype is cname.  * Revision:	911201  *			Option -T also prints MX preference value.  *			Save name of longest hostname found (just for fun).  *			Undocumented option -g to select long names (fun).  * Revision:	920315  *			Improve counting of hosts within domain.  *			Discard glue records not directly within domain.  *			Keep track of hosts with duplicate address.  *			Add -D option to list duplicate hosts.  *			Add -E option to list extrazone hosts.  *			Miscellaneous casting and typing cleanup.  *			Increase (static) number of possible subdomains.  * Revision:	920616  *			Allocate list of zonenames dynamically, not statically.  *			Move and slightly modify the test for fake hosts.  *			Suppress host count statistics during inverse listing.  *			Miscellaneous documentation updates.  * Revision:	920624  *			Lookup server name before changing nameserver address.  *			Handle possible truncation in zone transfers.  *			Provide private simplified version of res_send().  *			Add -u option to force virtual circuit connections.  *			Move all socket I/O routines to separate send.c.  * Revision:	920702  *			Recognize alternative program call names.  *			Distinguish between auth and non-auth NO_DATA.  * Revision:	921005  *			Anticipate ultrix specific resolv.h  *			Miscellaneous declaration changes.  *			Some reshuffling of code.  * Revision:	930209  *			Lookup server name with default resolver values.  *			Check SOA records without nameserver recursion.  *			Implement new RR types from RFC 1183 and 1348.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Version
index|[]
init|=
literal|"@(#)host.c	e07@nikhef.nl (Eric Wassenaar) 930209"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  *			Compilation options  *  * This program usually compiles without special compilation options,  * but for some platforms you have to define the following settings:  *  * #if defined(_AIX)  *	DEFS = -D_BSD -D_BSD_INCLUDES -U__STR__ -DBIT_ZERO_ON_LEFT  *  * #if defined(hpux)  *	DEFS = -DSYSV_SETVBUF  *  * #if defined(ultrix)  *	DEFS = -DULTRIX_RESOLV  *	Only if you are using the default ultrix<resolv.h>  */
end_comment

begin_comment
comment|/*  *			Miscellaneous notes  *  * This program should be linked explicitly with the BIND resolver library  * in case the default gethostbyname() or gethostbyaddr() routines use a  * non-standard strategy for retrieving information. These functions in the  * resolver library call on the nameserver, and fall back on the hosts file  * only if no nameserver is running (ECONNREFUSED).  *  * You may also want to link this program with the BIND resolver library if  * your default library has not been compiled with DEBUG printout enabled.  *  * The version of the resolver should be BIND 4.8.2 or later. The crucial  * include files are<netdb.h>, (resolv.h>,<arpa/nameser.h>. These files  * are assumed to be present in the /usr/include directory.  *  * The resolver code depends on the definition of the BSD pre-processor  * variable. This variable is usually defined in the file<sys/param.h>.  *  * The definition of this variable determines the method how to handle  * datagram connections. This may not work properly on all platforms  * (e.g. sun). A fix for this is available (see above).  *  * The hostent struct defined in<netdb.h> is assumed to handle multiple  * addresses in h_addr_list[]. Usually this is true if BSD>= 43.  *  * Your version of the nameserver may not handle queries about top-level  * domains properly. It needs a patch if it appends the default domain  * to single names for which it has no data cached. A fix for this is  * available (see above).  *  * For smooth porting to both BSD and SYSV environments:  * - Do not use the function value returned by sprintf().  *   It is of different type in the two environments.  * - Use<string.h> instead of<strings.h>.  *  * The treatment of TXT records has changed from 4.8.2 to 4.8.3. Formerly,  * the data consisted simply of the text string. Now, the text string is  * preceded by the character count with a maximum of 255, and multiple  * strings are embedded if the total character count exceeds 255.  * We handle only the new situation in this program, assuming that nobody  * uses TXT records before 4.8.3.  *  * Note that in 4.8.3 PACKETSZ from nameser.h is still at 512, which is  * the maximum possible packet size for datagrams, whereas MAXDATA from  * db.h has increased from 256 to 2048.  * The nameserver reads queries in a buffer of size BUFSIZ.  *  * The gethostbyname() routine in 4.8.3 interprets dotted quads (if not  * terminated with a dot) and simulates a gethostbyaddr(), but we will  * not rely on it, and handle dotted quads ourselves.  *  * On some systems a bug in the _doprnt() routine exists which prevents  * printf("%.*s", n, string) to be printed correctly if n == 0.  *  * This program has not been optimized for speed. Especially the memory  * management is simple and straightforward.  */
end_comment

begin_comment
comment|/*  *			Terminology used  *  * Gateway hosts.  * These are hosts that have more that one address registered under  * the same name. Obviously we cannot recognize a gateway host if it  * has different names associated with its different addresses.  *  * Duplicate hosts.  * These are non-gateway hosts of which the address was found earlier  * but with a different name, possibly in a totally different domain.  * Such hosts should not be counted again in the overall host count.  * This situation notably occurs in e.g. the "ac.uk" domain which has  * many names registered in both the long and the abbreviated form,  * such as 'host.department.university.ac.uk' and 'host.dept.un.ac.uk'.  * This is probably not an error per se. It is an error if some domain  * has registered a foreign address under a name within its own domain.  * To recognize duplicate hosts when traversing many zones, we have to  * maintain a global list of host addresses. To simplify things, only  * single address hosts are handled as such.  *  * Extrazone hosts.  * These are hosts which belong to a domain but which are not residing  * directly within the domain under consideration and which are not  * glue records for a subdomain of the given domain. E.g. if we are  * processing the domain 'bar' and find 'host.foo.bar' but 'foo.bar'  * is not a registered subdomain of 'bar' then it is considered to be  * an extrazone host. This is not necessarily an error, but it could be.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *		Usage: host [options] name [server]  *  * Regular command line options:  * ----------------------------  *  * -t type	specify query type; default is T_A for normal mode  *  * -a		specify query type T_ANY  *  * -v		print verbose messages (-vv is very verbose)  *  * -d		print debugging output (-dd prints even more)  *  * Special mode options.  * --------------------  *  * -l		special mode to generate zone listing for domain  *  * -L level	do recursive domain listing/checking this levels deep  *  * -p		use primary nameserver of domain for zone transfers  *  * -S		print zone resource record statistics  *  * -H		special mode to count hosts residing in domain  *  * -G		same as -H but lists gateway hosts in addition  *  * -E		same as -H but lists extrazone hosts in addition  *  * -D		same as -H but lists duplicate hosts in addition  *  * -C		special mode to check SOA records for domain  *  * -A		special mode to check reverse mappings of host addresses  *  * Miscellaneous options.  * ---------------------  *  * -T		print ttl value during non-verbose output  *  * -e		exclude info from names that do not reside in domain  *  * -f file	log resource record output also in given file  *  * -i		generate inverse in-addr.arpa query for dotted quad  *  * -q		be quiet about some non-fatal errors  *  * Seldom used options.  * -------------------  *  * -c class	specify query class; default is C_IN  *  * -m		specify query type T_MAILB and trace MB records  *  * -r		do not use recursion when querying nameserver  *  * -s secs	specify timeout value in seconds; default is 2 * 5  *  * -u		use virtual circuit instead of datagram for queries  *  * -w		wait until nameserver becomes available  *  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Usage
index|[]
init|=
literal|"\ Usage:      host [-v] [-a] [-t querytype]  name  [server]\n\ Listing:    host [-v] [-a] [-t querytype]  -l domain  [server]\n\ Hostcount:  host [-v] -H [-D] [-E] [-G] domain\n\ Check soa:  host [-v] -C domain\n\ Addrcheck:  host [-v] -A host\n\ Special options: [-L level] [-S] [-p]\n\ Common  options: [-T] [-d] [-e] [-f logfile] [-i] [-q]\n\ Other   options: [-c class] [-m] [-r] [-s secs] [-u] [-w]\ "
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|justfun
end_define

begin_comment
comment|/* this is only for fun */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|condition
parameter_list|)
define|\
value|{\ 	if (!(condition))\ 	{\ 		(void) fprintf(stderr, "assertion botch: ");\ 		(void) fprintf(stderr, "%s(%d): ", __FILE__, __LINE__);\ 		(void) fprintf(stderr, "%s\n", "condition");\ 		exit(EX_SOFTWARE);\ 	}\ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|condition
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_define
define|#
directive|define
name|input
end_define

begin_comment
comment|/* read-only input parameter */
end_comment

begin_define
define|#
directive|define
name|output
end_define

begin_comment
comment|/* modified output parameter */
end_comment

begin_typedef
typedef|typedef
name|char
name|ptr_t
typedef|;
end_typedef

begin_comment
comment|/* generic pointer type; will become void */
end_comment

begin_typedef
typedef|typedef
name|u_int
name|siz_t
typedef|;
end_typedef

begin_comment
comment|/* general size type; will become int */
end_comment

begin_typedef
typedef|typedef
name|int
name|bool
typedef|;
end_typedef

begin_comment
comment|/* boolean type */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_include
include|#
directive|include
file|"type.h"
end_include

begin_comment
comment|/* types should be defined in nameser.h */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|C_HS
end_ifndef

begin_define
define|#
directive|define
name|C_HS
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DATA
end_ifndef

begin_define
define|#
directive|define
name|NO_DATA
value|NO_ADDRESS
end_define

begin_comment
comment|/* used here only in case authoritative */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NO_RREC
value|5
end_define

begin_comment
comment|/* used for non-authoritative NO_DATA */
end_comment

begin_define
define|#
directive|define
name|T_NONE
value|0
end_define

begin_comment
comment|/* yet unspecified resource record type */
end_comment

begin_define
define|#
directive|define
name|T_FIRST
value|T_A
end_define

begin_comment
comment|/* first possible type in resource record */
end_comment

begin_define
define|#
directive|define
name|T_LAST
value|T_AXFR - 1
end_define

begin_comment
comment|/* last  possible type in resource record */
end_comment

begin_define
define|#
directive|define
name|MAXADDRS
value|35
end_define

begin_comment
comment|/* max address count from gethostnamadr.c */
end_comment

begin_define
define|#
directive|define
name|NOT_DOTTED_QUAD
value|((u_long)-1)
end_define

begin_define
define|#
directive|define
name|LOCALHOST_ADDR
value|((u_long)0x7f000001)
end_define

begin_define
define|#
directive|define
name|bitset
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)& (b)) != 0)
end_define

begin_define
define|#
directive|define
name|sameword
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcasecmp(a,b) == 0)
end_define

begin_define
define|#
directive|define
name|samepart
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strncasecmp(a,b,strlen(b)) == 0)
end_define

begin_define
define|#
directive|define
name|fakename
parameter_list|(
name|a
parameter_list|)
value|(samepart(a,"localhost.") || samepart(a,"loopback."))
end_define

begin_define
define|#
directive|define
name|fakeaddr
parameter_list|(
name|a
parameter_list|)
value|(((a) == 0) || ((a) == htonl(LOCALHOST_ADDR)))
end_define

begin_define
define|#
directive|define
name|newstr
parameter_list|(
name|a
parameter_list|)
value|strcpy((char *)xalloc((ptr_t *)NULL, strlen(a)+1), a)
end_define

begin_define
define|#
directive|define
name|newblk
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|(t *)xalloc((ptr_t *)a, (int)((n)*sizeof(t)))
end_define

begin_define
define|#
directive|define
name|xfree
parameter_list|(
name|a
parameter_list|)
value|(void) free((ptr_t *)a)
end_define

begin_define
define|#
directive|define
name|incopy
parameter_list|(
name|a
parameter_list|)
value|*((struct in_addr *)a)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ULTRIX_RESOLV
end_ifdef

begin_define
define|#
directive|define
name|nslist
parameter_list|(
name|i
parameter_list|)
value|_res.ns_list[i].addr
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|nslist
parameter_list|(
name|i
parameter_list|)
value|_res.nsaddr_list[i]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|PACKETSZ
operator|>
literal|1024
end_if

begin_define
define|#
directive|define
name|MAXPACKET
value|PACKETSZ
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXPACKET
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|header
decl_stmt|;
name|u_char
name|packet
index|[
name|MAXPACKET
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EXTERN
value|extern
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|EXTERN
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in gethostnamadr.c */
end_comment

begin_decl_stmt
name|EXTERN
name|struct
name|state
name|_res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in res_init.c */
end_comment

begin_decl_stmt
name|int
name|record_stats
index|[
name|T_ANY
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of resource records per type */
end_comment

begin_decl_stmt
name|char
name|cnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name to which CNAME is aliased */
end_comment

begin_decl_stmt
name|char
name|mnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name to which MR or MG is aliased */
end_comment

begin_decl_stmt
name|char
name|soanamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|soaname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain name of SOA record */
end_comment

begin_decl_stmt
name|char
name|subnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|subname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain name of NS record */
end_comment

begin_decl_stmt
name|char
name|adrnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|adrname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain name of A record */
end_comment

begin_decl_stmt
name|u_long
name|address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internet address of A record */
end_comment

begin_decl_stmt
name|char
name|servername
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|server
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of explicit server to query */
end_comment

begin_decl_stmt
name|char
modifier|*
name|logfilename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of log file */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|logfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default is stdout only */
end_comment

begin_decl_stmt
name|char
modifier|*
name|queryname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the name about which to query */
end_comment

begin_decl_stmt
name|int
name|querytype
init|=
name|T_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the type of the query */
end_comment

begin_decl_stmt
name|int
name|queryclass
init|=
name|C_IN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the class of the query */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print resolver debugging output */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbose mode for extra output */
end_comment

begin_decl_stmt
name|bool
name|quiet
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* suppress some warning messages */
end_comment

begin_decl_stmt
name|bool
name|inverse
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generate inverse in-addr.arpa queries */
end_comment

begin_decl_stmt
name|bool
name|primary
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use primary server for zone transfers */
end_comment

begin_decl_stmt
name|bool
name|ttlprint
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print ttl value in non-verbose mode */
end_comment

begin_decl_stmt
name|bool
name|waitmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait until server becomes available */
end_comment

begin_decl_stmt
name|bool
name|mailmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace MG and MR into MB records */
end_comment

begin_decl_stmt
name|bool
name|addrmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check reverse mappings of addresses */
end_comment

begin_decl_stmt
name|bool
name|listmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generate zone listing of domain */
end_comment

begin_decl_stmt
name|bool
name|hostmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count real hosts residing within domain */
end_comment

begin_decl_stmt
name|bool
name|duplmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list duplicate hosts within domain */
end_comment

begin_decl_stmt
name|bool
name|extrmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list extrazone hosts within domain */
end_comment

begin_decl_stmt
name|bool
name|gatemode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list gateway hosts within domain */
end_comment

begin_decl_stmt
name|bool
name|checkmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check SOA records at each nameserver */
end_comment

begin_decl_stmt
name|int
name|recursive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recursive listmode maximum level */
end_comment

begin_decl_stmt
name|bool
name|exclusive
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exclude records that are not in domain */
end_comment

begin_decl_stmt
name|bool
name|statistics
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print resource record statistics */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|justfun
end_ifdef

begin_decl_stmt
name|int
name|namelen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* select records exceeding this length */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|u_long
name|inet_addr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|inet_ntoa
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (struct in_addr) */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, char *) */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, char) */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, char) */
end_comment

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int) */
end_comment

begin_comment
comment|/* main.c */
end_comment

begin_function_decl
name|int
name|main
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int, char **) */
end_comment

begin_function_decl
name|bool
name|execute
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (u_long) */
end_comment

begin_function_decl
name|void
name|set_server
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, ...) */
end_comment

begin_function_decl
name|void
name|errmsg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, ...) */
end_comment

begin_comment
comment|/* info.c */
end_comment

begin_function_decl
name|bool
name|get_hostinfo
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|bool
name|get_domaininfo
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, char*) */
end_comment

begin_function_decl
name|int
name|get_info
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (querybuf *, char *, int, int) */
end_comment

begin_function_decl
name|int
name|print_info
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (querybuf *, int, char *, int) */
end_comment

begin_function_decl
name|void
name|doprintf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, ...) */
end_comment

begin_function_decl
name|u_char
modifier|*
name|print_rr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, u_char*, u_char*, u_char*, int) */
end_comment

begin_function_decl
name|u_char
modifier|*
name|skip_qr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, u_char*, u_char*, u_char*) */
end_comment

begin_comment
comment|/* list.c */
end_comment

begin_function_decl
name|bool
name|list_domain
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|int
name|find_servers
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|int
name|get_servers
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|int
name|get_nsinfo
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (querybuf *, int, char *) */
end_comment

begin_function_decl
name|bool
name|transfer_zone
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, int, struct in_addr) */
end_comment

begin_function_decl
name|bool
name|get_zone
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, int, struct in_addr) */
end_comment

begin_function_decl
name|char
modifier|*
name|get_primary
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|bool
name|check_domain
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|int
name|get_soainfo
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (querybuf *, int, char *) */
end_comment

begin_function_decl
name|void
name|check_soa
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (querybuf *, char *) */
end_comment

begin_comment
comment|/* addr.c */
end_comment

begin_function_decl
name|bool
name|check_addr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|bool
name|check_name
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (u_long) */
end_comment

begin_comment
comment|/* util.c */
end_comment

begin_function_decl
name|int
name|parse_type
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|int
name|parse_class
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|char
modifier|*
name|in_addr_arpa
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *) */
end_comment

begin_function_decl
name|void
name|print_host
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, struct hostent *) */
end_comment

begin_function_decl
name|void
name|print_res
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (void) */
end_comment

begin_function_decl
name|void
name|print_statistics
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, int) */
end_comment

begin_function_decl
name|void
name|clear_statistics
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (void) */
end_comment

begin_function_decl
name|void
name|print_types
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, int) */
end_comment

begin_function_decl
name|void
name|ns_error
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, int) */
end_comment

begin_function_decl
name|char
modifier|*
name|decode_error
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int) */
end_comment

begin_function_decl
name|void
name|print_status
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (querybuf *) */
end_comment

begin_function_decl
name|void
name|pr_error
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, ...) */
end_comment

begin_function_decl
name|void
name|pr_warning
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, ...) */
end_comment

begin_function_decl
name|bool
name|want_rr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int, int) */
end_comment

begin_function_decl
name|bool
name|indomain
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, char *, bool) */
end_comment

begin_function_decl
name|bool
name|samedomain
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, char *, bool) */
end_comment

begin_function_decl
name|bool
name|gluerecord
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, char *, char **, int) */
end_comment

begin_function_decl
name|char
modifier|*
name|pr_type
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int) */
end_comment

begin_function_decl
name|char
modifier|*
name|pr_class
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int) */
end_comment

begin_function_decl
name|int
name|expand
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, int, u_char*, u_char*, u_char*, char *) */
end_comment

begin_function_decl
name|int
name|check_size
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, int, u_char*, u_char*, u_char*, int) */
end_comment

begin_function_decl
name|ptr_t
modifier|*
name|xalloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (ptr_t *, int) */
end_comment

begin_comment
comment|/* send.c */
end_comment

begin_function_decl
name|int
name|res_send
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (char *, int, char *, int) */
end_comment

begin_function_decl
name|int
name|_res_connect
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int, struct sockaddr_in *, int) */
end_comment

begin_function_decl
name|int
name|_res_write
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int, char *, int) */
end_comment

begin_function_decl
name|int
name|_res_read
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* (int, char *, int) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ** MAIN -- Start of program host ** ----------------------------- ** **	Exits: **		EX_OK		Operation successfully completed **		EX_UNAVAILABLE	Could not obtain requested information **		EX_CANTCREAT	Could not create specified logfile **		EX_OSERR	Could not obtain resources **		EX_USAGE	Improper parameter/option specified **		EX_SOFTWARE	Assertion botch in DEBUG mode */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|option
decl_stmt|;
name|struct
name|state
name|_new
decl_stmt|;
comment|/* new resolver database */
name|u_long
name|addr
decl_stmt|;
comment|/* explicit address of query */
name|bool
name|result
decl_stmt|;
comment|/* result status of action taken */
name|char
modifier|*
name|program
decl_stmt|;
comment|/* name that host was called with */
comment|/*  * Synchronize stdout and stderr in case output is redirected.  * Note that some SYSV implementations may have setlinebuf().  */
if|#
directive|if
name|defined
argument_list|(
name|SYSV_SETVBUF
argument_list|)
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  * Initialize resolver. See print_res() for details.  * Pickup current values and set new defaults.  * Query for optional server is also done with new defaults.  * Old defaults are (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)  */
operator|(
name|void
operator|)
name|res_init
argument_list|()
expr_stmt|;
comment|/* we handle default domains ourselves, thank you */
name|_res
operator|.
name|options
operator||=
name|RES_DEFNAMES
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DNSRCH
expr_stmt|;
name|_res
operator|.
name|options
operator||=
name|RES_RECURSE
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_USEVC
expr_stmt|;
name|_res
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
comment|/* number  of retries, default = 4 */
name|_res
operator|.
name|retrans
operator|=
literal|5
expr_stmt|;
comment|/* timeout in seconds, default = 5 or 6 */
comment|/* save new defaults */
name|_new
operator|=
name|_res
expr_stmt|;
comment|/*  * Check if host was called with a different name.  */
name|program
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|program
operator|++
operator|==
name|NULL
condition|)
name|program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* check for resource record names */
name|querytype
operator|=
name|parse_type
argument_list|(
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
name|querytype
operator|<
literal|0
condition|)
name|querytype
operator|=
name|T_NONE
expr_stmt|;
comment|/* check for zone listing abbreviation */
if|if
condition|(
name|sameword
argument_list|(
name|program
argument_list|,
literal|"zone"
argument_list|)
condition|)
name|listmode
operator|=
name|TRUE
expr_stmt|;
comment|/*  * Scan command line options and flags.  */
while|while
condition|(
name|argc
operator|>
literal|2
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|option
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
init|;
operator|*
name|option
operator|!=
literal|'\0'
condition|;
name|option
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|option
condition|)
block|{
case|case
literal|'w'
case|:
name|waitmode
operator|=
name|TRUE
expr_stmt|;
name|_new
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
name|_new
operator|.
name|retrans
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|_new
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
name|_new
operator|.
name|retrans
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|_new
operator|.
name|retrans
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid timeout value %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|_new
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|_new
operator|.
name|options
operator||=
name|RES_USEVC
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
comment|/* increment debugging level */
name|_new
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
comment|/* increment verbosity level */
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|inverse
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|primary
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|exclusive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|statistics
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ttlprint
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|addrmode
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'G'
case|:
if|if
condition|(
operator|*
name|option
operator|==
literal|'D'
condition|)
name|duplmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|option
operator|==
literal|'E'
condition|)
name|extrmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|option
operator|==
literal|'G'
condition|)
name|gatemode
operator|=
name|TRUE
expr_stmt|;
comment|/* fall through */
case|case
literal|'H'
case|:
name|hostmode
operator|=
name|TRUE
expr_stmt|;
name|listmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|querytype
operator|==
name|T_NONE
condition|)
name|querytype
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* suppress zone data output */
break|break;
case|case
literal|'C'
case|:
name|checkmode
operator|=
name|TRUE
expr_stmt|;
name|listmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|querytype
operator|==
name|T_NONE
condition|)
name|querytype
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* suppress zone data output */
break|break;
case|case
literal|'l'
case|:
name|listmode
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|recursive
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid recursion level %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|logfilename
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|queryclass
operator|=
name|parse_class
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryclass
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid query class %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|querytype
operator|=
name|parse_type
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|querytype
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid query type %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|querytype
operator|=
name|T_ANY
expr_stmt|;
comment|/* filter anything available */
break|break;
case|case
literal|'m'
case|:
name|mailmode
operator|=
name|TRUE
expr_stmt|;
name|querytype
operator|=
name|T_MAILB
expr_stmt|;
comment|/* filter MINFO/MG/MR/MB data */
break|break;
ifdef|#
directive|ifdef
name|justfun
case|case
literal|'g'
case|:
name|namelen
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid length %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|fatal
argument_list|(
name|Usage
argument_list|)
expr_stmt|;
block|}
block|}
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
comment|/* must have at least one argument */
if|if
condition|(
name|argc
operator|<
literal|2
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
name|Usage
argument_list|)
expr_stmt|;
comment|/* check for nonsense input names */
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|>
name|MAXDNAME
condition|)
name|fatal
argument_list|(
literal|"Query name %s too long"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|>
name|MAXDNAME
condition|)
name|fatal
argument_list|(
literal|"Server name %s too long"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*  * Analyze name and type to be queried about.  * In regular mode, the querytype is used to formulate the nameserver  * query, and any response is filtered out when processing the answer.  * In listmode, the querytype is used to filter out the proper records.  */
name|queryname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|queryname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|queryname
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|queryname
argument_list|,
literal|"."
argument_list|)
condition|)
name|addr
operator|=
name|NOT_DOTTED_QUAD
expr_stmt|;
else|else
name|addr
operator|=
name|inet_addr
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
comment|/* invert dotted quad if so requested */
if|if
condition|(
operator|(
name|addr
operator|!=
name|NOT_DOTTED_QUAD
operator|)
operator|&&
name|inverse
condition|)
block|{
name|queryname
operator|=
name|in_addr_arpa
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryname
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Invalid dotted quad %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|addr
operator|=
name|NOT_DOTTED_QUAD
expr_stmt|;
block|}
else|else
name|inverse
operator|=
name|FALSE
expr_stmt|;
comment|/* set querytype for regular mode if unspecified */
if|if
condition|(
operator|(
name|querytype
operator|==
name|T_NONE
operator|)
operator|&&
operator|!
name|listmode
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|!=
name|NOT_DOTTED_QUAD
operator|)
operator|||
name|inverse
condition|)
name|querytype
operator|=
name|T_PTR
expr_stmt|;
else|else
name|querytype
operator|=
name|T_A
expr_stmt|;
block|}
comment|/* cannot have dotted quad in listmode */
if|if
condition|(
name|listmode
operator|&&
operator|(
name|addr
operator|!=
name|NOT_DOTTED_QUAD
operator|)
condition|)
name|fatal
argument_list|(
literal|"Invalid query name %s"
argument_list|,
name|queryname
argument_list|)
expr_stmt|;
comment|/* must have regular name or dotted quad in addrmode */
if|if
condition|(
name|addrmode
operator|&&
name|inverse
condition|)
name|fatal
argument_list|(
literal|"Invalid query name %s"
argument_list|,
name|queryname
argument_list|)
expr_stmt|;
comment|/* show what we are going to query about */
if|if
condition|(
name|verbose
condition|)
name|print_types
argument_list|(
name|queryname
argument_list|,
name|querytype
argument_list|)
expr_stmt|;
comment|/*  * Check for possible alternative server.  */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|set_server
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* set new resolver values changed by command options */
name|_res
operator|.
name|retry
operator|=
name|_new
operator|.
name|retry
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|_new
operator|.
name|retrans
expr_stmt|;
name|_res
operator|.
name|options
operator|=
name|_new
operator|.
name|options
expr_stmt|;
comment|/* show the new resolver database */
if|if
condition|(
name|debug
operator|>
literal|1
operator|||
name|verbose
operator|>
literal|1
condition|)
name|print_res
argument_list|()
expr_stmt|;
comment|/*  * Open log file if requested.  */
if|if
condition|(
name|logfilename
condition|)
block|{
name|logfile
operator|=
name|fopen
argument_list|(
name|logfilename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|logfilename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * All set. Perform requested function.  */
name|result
operator|=
name|execute
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|FALSE
condition|)
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** EXECUTE -- Perform the requested function ** ----------------------------------------- ** **	Returns: **		TRUE if information was obtained successfully. **		FALSE otherwise. ** **	The whole environment has been set up and checked for **	legality and consistency. */
end_comment

begin_function
name|bool
name|execute
parameter_list|(
name|addr
parameter_list|)
name|input
name|u_long
name|addr
decl_stmt|;
comment|/* explicit address of query */
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
name|newnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|NULL
decl_stmt|;
comment|/* name to which CNAME is aliased */
name|int
name|ncnames
init|=
literal|0
decl_stmt|;
comment|/* count of CNAMEs in chain */
name|bool
name|result
decl_stmt|;
comment|/* result status of action taken */
comment|/*  * Special mode to check inverse mappings of host addresses.  */
if|if
condition|(
name|addrmode
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|NOT_DOTTED_QUAD
condition|)
name|result
operator|=
name|check_addr
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|check_name
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Special mode to list contents of specified domain.  */
if|if
condition|(
name|listmode
condition|)
block|{
name|result
operator|=
name|list_domain
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Regular mode to query about specified host.  */
name|result
operator|=
name|FALSE
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
comment|/* retry until positive result or permanent failure */
while|while
condition|(
name|result
operator|==
name|FALSE
operator|&&
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|NOT_DOTTED_QUAD
condition|)
block|{
comment|/* reset CNAME indicator */
name|cname
operator|=
name|NULL
expr_stmt|;
comment|/* lookup the name in question */
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
name|result
operator|=
name|get_hostinfo
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|get_hostinfo
argument_list|(
name|newname
argument_list|)
expr_stmt|;
comment|/* recurse on CNAMEs, but not too deep */
if|if
condition|(
name|cname
operator|&&
operator|(
name|querytype
operator|!=
name|T_CNAME
operator|)
condition|)
block|{
name|newname
operator|=
name|strcpy
argument_list|(
name|newnamebuf
argument_list|,
name|cname
argument_list|)
expr_stmt|;
name|ncnames
operator|++
expr_stmt|;
if|if
condition|(
name|ncnames
operator|>
literal|5
condition|)
block|{
name|errmsg
argument_list|(
literal|"Possible CNAME loop"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|result
operator|=
name|FALSE
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|print_host
argument_list|(
literal|"Name"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* only retry if so requested */
if|if
condition|(
operator|!
name|waitmode
condition|)
break|break;
block|}
comment|/* explain the reason of a failure */
if|if
condition|(
name|result
operator|==
name|FALSE
condition|)
name|ns_error
argument_list|(
name|queryname
argument_list|,
name|querytype
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** SET_SERVER -- Override default nameserver with explicit server ** -------------------------------------------------------------- ** **	Returns: **		None. **		Aborts the program if an unknown host was given. ** **	Side effects: **		The global variable server is set to indicate **		that an explicit server is being used. ** **	The default nameserver addresses in the resolver database **	which are initialized by res_init() from /etc/resolv.conf **	are replaced with the (possibly multiple) addresses of an **	explicitly named server host. If a dotted quad is given, **	only that single address will be used. */
end_comment

begin_function
name|void
name|set_server
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of server to be queried */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|u_long
name|addr
decl_stmt|;
comment|/* explicit address of server */
name|addr
operator|=
name|inet_addr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|inaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NOT_DOTTED_QUAD
condition|)
block|{
comment|/* lookup all of its addresses; this must not fail */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|errmsg
argument_list|(
literal|"Error in looking up server name"
argument_list|)
expr_stmt|;
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNS
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_addr
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|_res
operator|.
name|nscount
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
comment|/* lookup the name, but use only the given address */
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|nslist
argument_list|(
literal|0
argument_list|)
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nslist
argument_list|(
literal|0
argument_list|)
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|nslist
argument_list|(
literal|0
argument_list|)
operator|.
name|sin_addr
operator|=
name|inaddr
expr_stmt|;
name|_res
operator|.
name|nscount
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|server
operator|=
name|strcpy
argument_list|(
name|servername
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
literal|"Server"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|server
operator|=
name|strcpy
argument_list|(
name|servername
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Server: %s\n\n"
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** FATAL -- Abort program when illegal option encountered ** ------------------------------------------------------ ** **	Returns: **		Aborts after issuing error message. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** ERRMSG -- Issue error message to error output ** --------------------------------------------- ** **	Returns: **		None. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|errmsg
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_HOSTINFO -- Principal routine to query about given name ** ----------------------------------------------------------- ** **	Returns: **		TRUE if requested info was obtained successfully. **		FALSE otherwise. ** **	This is the equivalent of the resolver module res_search(). */
end_comment

begin_function
name|bool
name|get_hostinfo
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name to query about */
block|{
specifier|extern
name|char
modifier|*
name|hostalias
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
modifier|*
name|domain
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|dot
decl_stmt|;
comment|/* number of dots in query name */
name|bool
name|result
decl_stmt|;
comment|/* result status of action taken */
comment|/*  * Single dot means root domain.  */
if|if
condition|(
name|sameword
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|result
operator|=
name|get_domaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Count number of dots.  */
for|for
control|(
name|dot
operator|=
literal|0
operator|,
name|cp
operator|=
name|name
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
name|dot
operator|++
expr_stmt|;
comment|/*  * Check for aliases of single name.  */
if|if
condition|(
name|dot
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|hostalias
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Aliased to \"%s\"\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_domaininfo
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Trailing dot means absolute address.  */
if|if
condition|(
name|dot
operator|!=
literal|0
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|get_domaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Append own domain if appropriate.  */
if|if
condition|(
operator|(
name|dot
operator|==
literal|0
operator|&&
name|bitset
argument_list|(
name|RES_DEFNAMES
argument_list|,
name|_res
operator|.
name|options
argument_list|)
operator|)
operator|||
operator|(
name|dot
operator|!=
literal|0
operator|&&
name|bitset
argument_list|(
name|RES_DNSRCH
argument_list|,
name|_res
operator|.
name|options
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|domain
operator|=
name|_res
operator|.
name|dnsrch
init|;
operator|*
name|domain
condition|;
name|domain
operator|++
control|)
block|{
name|result
operator|=
name|get_domaininfo
argument_list|(
name|name
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* in case nameserver not present */
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/*  * Single hostname lookup failed.  */
if|if
condition|(
name|dot
operator|==
literal|0
condition|)
block|{
comment|/* set status in case we never queried */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DEFNAMES
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|h_errno
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Rest means fully qualified.  */
name|result
operator|=
name|get_domaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_DOMAININFO -- Fetch and print desired info about name in domain ** ------------------------------------------------------------------- ** **	Returns: **		TRUE if requested info was obtained successfully. **		FALSE otherwise. ** **	This is the equivalent of the resolver module res_querydomain(). */
end_comment

begin_function
name|bool
name|get_domaininfo
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name to query about */
name|input
name|char
modifier|*
name|domain
decl_stmt|;
comment|/* domain to which name is relative */
block|{
name|char
name|namebuf
index|[
literal|2
operator|*
name|MAXDNAME
operator|+
literal|2
index|]
decl_stmt|;
comment|/* buffer to store full domain name */
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|domain
operator|==
name|NULL
operator|||
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"Trying %s ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Trying %s within %s ...\n"
argument_list|,
name|name
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
comment|/*  * Construct the actual domain name.  * A null domain means the given name is already fully qualified.  */
if|if
condition|(
name|domain
operator|==
name|NULL
operator|||
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%.*s"
argument_list|,
name|MAXDNAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%.*s.%.*s"
argument_list|,
name|MAXDNAME
argument_list|,
name|name
argument_list|,
name|MAXDNAME
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|name
operator|=
name|namebuf
expr_stmt|;
comment|/*  * Fetch the desired info, and print any relevant data.  */
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|querytype
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|anslen
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|result
operator|=
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|T_ANY
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|==
name|NOERROR
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_INFO -- Basic routine to issue a nameserver query ** ----------------------------------------------------- ** **	Returns: **		Length of nameserver answer buffer, if obtained. **		-1 if an error occurred (h_errno is set appropriately). ** **	This is the equivalent of the resolver module res_query(). */
end_comment

begin_function
name|int
name|get_info
parameter_list|(
name|answerbuf
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|)
name|output
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of buffer to store answer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name to query about */
name|input
name|int
name|type
decl_stmt|;
comment|/* specific resource record type */
name|input
name|int
name|class
decl_stmt|;
comment|/* specific resource record class */
block|{
name|querybuf
name|query
decl_stmt|;
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|ancount
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
comment|/*  * Construct query, and send it to the nameserver.  * res_send() will fail if no nameserver responded. In this case the possible  * values for errno are ECONNREFUSED and ETIMEDOUT. If we did get an answer,  * errno should be reset, since res_send() may have left an errno in case it  * has used datagrams. Our private version of res_send() will leave also other  * error statuses, and will clear errno if an answer was obtained.  */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* reset before querying nameserver */
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rrec
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
sizeof|sizeof
argument_list|(
name|querybuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_mkquery failed\n"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|res_send
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
name|n
argument_list|,
operator|(
name|char
operator|*
operator|)
name|answerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|querybuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_send failed\n"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* reset after we got an answer */
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
condition|)
block|{
name|pr_error
argument_list|(
literal|"answer length %d too short"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  * Analyze the status of the answer from the nameserver.  */
if|if
condition|(
name|debug
operator|||
name|verbose
condition|)
name|print_status
argument_list|(
name|answerbuf
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|ancount
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|bp
operator|->
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* distinguish between authoritative or not */
name|h_errno
operator|=
name|bp
operator|->
name|aa
condition|?
name|HOST_NOT_FOUND
else|:
name|TRY_AGAIN
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
comment|/* distinguish between authoritative or not */
name|h_errno
operator|=
name|bp
operator|->
name|aa
condition|?
name|NO_DATA
else|:
name|NO_RREC
expr_stmt|;
break|break;
case|case
name|SERVFAIL
case|:
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
case|case
name|NOCHANGE
case|:
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
break|break;
default|default:
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|h_errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_INFO -- Check resource records in answer and print relevant data ** ---------------------------------------------------------------------- ** **	Returns: **		NOERROR if answer buffer was processed successfully. **		FORMERR otherwise. ** **	Side effects: **		Will recurse on MAILB records if appropriate. **		See also side effects of the print_rr() routine. */
end_comment

begin_function
name|int
name|print_info
parameter_list|(
name|answerbuf
parameter_list|,
name|answerlen
parameter_list|,
name|name
parameter_list|,
name|filter
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
name|input
name|int
name|answerlen
decl_stmt|;
comment|/* length of answer buffer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name we are querying about */
name|input
name|int
name|filter
decl_stmt|;
comment|/* type of records we want to see */
block|{
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|eom
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
name|answerlen
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
comment|/*  * Skip the query section in the response (present only in normal queries).  */
if|if
condition|(
name|qdcount
condition|)
block|{
while|while
condition|(
name|qdcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
comment|/* cp += dn_skipname(cp, eom) + QFIXEDSZ; */
name|cp
operator|=
name|skip_qr
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FORMERR
operator|)
return|;
name|qdcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|qdcount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid qdcount in response"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
block|}
comment|/*  * Process the actual answer section in the response.  * During zone transfers, this is the only section available.  */
if|if
condition|(
name|ancount
condition|)
block|{
if|if
condition|(
operator|!
name|listmode
operator|&&
name|verbose
operator|&&
operator|!
name|bp
operator|->
name|aa
condition|)
name|printf
argument_list|(
literal|"The following answer is not authoritative:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ancount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|print_rr
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FORMERR
operator|)
return|;
name|ancount
operator|--
expr_stmt|;
comment|/* 		 * When we ask for address and there is a CNAME, it returns 		 * both the CNAME and the address.  Since we trace down the 		 * CNAME chain ourselves, we don't really want to print the 		 * address at this point. 		 */
if|if
condition|(
operator|!
name|listmode
operator|&&
operator|!
name|verbose
operator|&&
name|cname
condition|)
return|return
operator|(
name|NOERROR
operator|)
return|;
comment|/* 		 * Recursively expand MR or MG records into MB records. 		 */
if|if
condition|(
name|mailmode
operator|&&
operator|!
name|listmode
operator|&&
name|mname
condition|)
block|{
name|char
name|newnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|newname
operator|=
name|strcpy
argument_list|(
name|newnamebuf
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|get_hostinfo
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ancount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid ancount in response"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
block|}
comment|/*  * The nameserver and additional info section are normally not processed.  */
if|if
condition|(
operator|!
name|verbose
operator|||
name|exclusive
condition|)
return|return
operator|(
name|NOERROR
operator|)
return|;
if|if
condition|(
name|nscount
condition|)
block|{
name|printf
argument_list|(
literal|"Authoritative nameservers:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|nscount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|print_rr
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FORMERR
operator|)
return|;
name|nscount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nscount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid nscount in response"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|arcount
condition|)
block|{
name|printf
argument_list|(
literal|"Additional information:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|arcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|print_rr
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|filter
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FORMERR
operator|)
return|;
name|arcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|arcount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid arcount in response"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NOERROR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** DOPRINT -- Output resource record data if this record is wanted ** --------------------------------------------------------------- ** **	Returns: **		None. ** **	Inputs: **		The global variable doprint is set by print_rr() **		if we need to print the data. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|doprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether or not to print */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|doprintf
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
block|{
if|if
condition|(
name|doprint
condition|)
block|{
name|printf
argument_list|(
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_RR -- Decode single resource record and output relevant data ** ------------------------------------------------------------------ ** **	Returns: **		Pointer to position in answer buffer after current record. **		NULL if there was a format error in the current record. ** **	Outputs: **		The global variable doprint is set appropriately **		for use by doprintf(). ** **	Side effects: **		Updates resource record statistics in record_stats[]. **		Sets soaname if this is an SOA record. **		Sets subname if this is an NS record. **		Sets adrname if this is an A record. **		Sets address if this is an A record. **		Sets cname if this is a valid CNAME record. **		Sets mname if this is a valid MAILB record. **		These variables must have been cleared before calling **		print_info() and may be checked afterwards. */
end_comment

begin_function
name|u_char
modifier|*
name|print_rr
parameter_list|(
name|name
parameter_list|,
name|cp
parameter_list|,
name|msg
parameter_list|,
name|eom
parameter_list|,
name|filter
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name we are querying about */
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in answer buf */
name|input
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_comment
comment|/* begin and end of answer buf */
end_comment

begin_decl_stmt
name|input
name|int
name|filter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of records we want to see */
end_comment

begin_block
block|{
name|char
name|rname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* record name in LHS */
name|char
name|dname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* domain name in RHS */
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|ttl
decl_stmt|,
name|dlen
decl_stmt|;
comment|/* fixed values in every record */
name|u_char
modifier|*
name|eor
decl_stmt|;
comment|/* predicted position of next record */
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|struct
name|protoent
modifier|*
name|protocol
decl_stmt|;
name|struct
name|servent
modifier|*
name|service
decl_stmt|;
comment|/*  * Pickup the standard values present in each resource record.  */
name|n
operator|=
name|expand
argument_list|(
name|name
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|eor
operator|=
name|cp
operator|+
name|dlen
expr_stmt|;
comment|/*  * Decide whether or not to print this resource record.  */
name|doprint
operator|=
name|want_rr
argument_list|(
name|type
argument_list|,
name|filter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|obsolete
if|if
condition|(
name|doprint
operator|&&
name|exclusive
operator|&&
operator|!
name|samedomain
argument_list|(
name|rname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|doprint
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|doprint
operator|&&
name|exclusive
operator|&&
operator|!
name|indomain
argument_list|(
name|rname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|doprint
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|doprint
operator|&&
name|exclusive
operator|&&
name|fakename
argument_list|(
name|rname
argument_list|)
condition|)
name|doprint
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|justfun
if|if
condition|(
name|namelen
operator|&&
operator|(
name|strlen
argument_list|(
name|rname
argument_list|)
operator|<
name|namelen
operator|)
condition|)
name|doprint
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/*  * Print name and common values, if appropriate.  */
if|if
condition|(
name|verbose
condition|)
name|doprintf
argument_list|(
literal|"%-20s\t%d\t%s\t%s"
argument_list|,
name|rname
argument_list|,
name|ttl
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ttlprint
condition|)
name|doprintf
argument_list|(
literal|"%-20s\t%d\t%s"
argument_list|,
name|rname
argument_list|,
name|ttl
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|"%-20s\t%s"
argument_list|,
name|rname
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  * Update resource record statistics for zone listing.  */
if|if
condition|(
name|type
operator|>=
name|T_FIRST
operator|&&
name|type
operator|<=
name|T_LAST
condition|)
name|record_stats
index|[
name|type
index|]
operator|++
expr_stmt|;
comment|/*  * Save the domain name of an SOA or NS or A record for zone listing.  */
if|if
condition|(
name|type
operator|==
name|T_A
condition|)
name|adrname
operator|=
name|strcpy
argument_list|(
name|adrnamebuf
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|T_NS
condition|)
name|subname
operator|=
name|strcpy
argument_list|(
name|subnamebuf
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|soaname
operator|=
name|strcpy
argument_list|(
name|soanamebuf
argument_list|,
name|rname
argument_list|)
expr_stmt|;
comment|/*  * Print type specific data, if appropriate.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
case|case
name|C_HS
case|:
if|if
condition|(
name|dlen
operator|==
literal|4
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|inaddr
operator|.
name|s_addr
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|dlen
operator|==
literal|7
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|inaddr
operator|.
name|s_addr
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|", protocol = %d"
argument_list|,
name|cp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|", port = %d"
argument_list|,
operator|(
name|cp
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
name|cp
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
name|address
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|address
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|T_MX
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|verbose
operator|||
name|ttlprint
condition|)
name|doprintf
argument_list|(
literal|"\t%ld "
argument_list|,
name|_getshort
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"%s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
case|case
name|T_CNAME
case|:
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|" (\n\t\t\t%ld\t;serial (version)"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\n\t\t\t%ld\t;refresh period"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\n\t\t\t%ld\t;retry refresh time"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\n\t\t\t%ld\t;expiration period"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\n\t\t\t%ld\t;default ttl\n\t\t\t)"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_WKS
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|protocol
operator|=
name|getprotobynumber
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
condition|)
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|protocol
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|" %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|eor
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|&
literal|0200
condition|)
block|{
if|if
condition|(
name|protocol
condition|)
name|service
operator|=
name|getservbyport
argument_list|(
name|htons
argument_list|(
name|n
argument_list|)
argument_list|,
name|protocol
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|service
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|service
condition|)
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|service
operator|->
name|s_name
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|" %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|c
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|n
operator|&
literal|07
condition|)
do|;
block|}
name|doprintf
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%.*s"
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%.*s"
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|T_MINFO
case|:
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_MD
case|:
case|case
name|T_MF
case|:
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|obsolete
case|case
name|T_TXT
case|:
if|if
condition|(
name|dlen
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%.*s"
argument_list|,
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|T_TXT
case|:
while|while
condition|(
name|cp
operator|<
name|eor
condition|)
block|{
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%.*s"
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
block|}
break|break;
case|case
name|T_UINFO
case|:
if|if
condition|(
name|dlen
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%.*s"
argument_list|,
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
break|break;
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
if|if
condition|(
name|dlen
operator|==
literal|4
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%ld"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
break|break;
case|case
name|T_UNSPEC
case|:
case|case
name|T_NULL
case|:
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
case|case
name|T_RP
case|:
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_RT
case|:
case|case
name|T_AFSDB
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|verbose
operator|||
name|ttlprint
condition|)
name|doprintf
argument_list|(
literal|"\t%ld "
argument_list|,
name|_getshort
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"%s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_X25
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%.*s"
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|T_ISDN
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%.*s"
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|<
name|eor
condition|)
block|{
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%.*s"
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
block|}
break|break;
case|case
name|T_NSAP
case|:
case|case
name|T_NSAPPTR
case|:
name|doprintf
argument_list|(
literal|"\t(not yet implemented)"
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
default|default:
name|doprintf
argument_list|(
literal|"\t???"
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
name|doprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*  * Save the CNAME alias for cname chain tracing.  * Save the MR or MG alias for MB chain tracing.  */
if|if
condition|(
operator|(
name|type
operator|==
name|T_CNAME
operator|)
operator|&&
name|n
operator|>
literal|0
operator|&&
name|cp
operator|==
name|eor
condition|)
name|cname
operator|=
name|strcpy
argument_list|(
name|cnamebuf
argument_list|,
name|dname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|T_MR
operator|||
name|type
operator|==
name|T_MG
operator|)
operator|&&
name|n
operator|>
literal|0
operator|&&
name|cp
operator|==
name|eor
condition|)
name|mname
operator|=
name|strcpy
argument_list|(
name|mnamebuf
argument_list|,
name|dname
argument_list|)
expr_stmt|;
comment|/*  * Check if we have reached the exact end of this record.  */
if|if
condition|(
name|cp
operator|!=
name|eor
condition|)
block|{
name|pr_error
argument_list|(
literal|"size error in %s record for %s, dlen = %d, off by = %d"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rname
argument_list|,
name|dlen
argument_list|,
operator|(
name|cp
operator|-
name|eor
operator|)
argument_list|)
expr_stmt|;
comment|/* we believe value of dlen; should perhaps return(NULL) */
name|cp
operator|=
name|eor
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** SKIP_QR -- Skip the query record in the nameserver answer buffer ** ---------------------------------------------------------------- ** **	Returns: **		Pointer to position in answer buffer after current record. **		NULL if there was a format error in the current record. */
end_comment

begin_function
name|u_char
modifier|*
name|skip_qr
parameter_list|(
name|name
parameter_list|,
name|cp
parameter_list|,
name|msg
parameter_list|,
name|eom
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name we are querying about */
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in answer buf */
name|input
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_comment
comment|/* begin and end of answer buf */
end_comment

begin_block
block|{
name|char
name|rname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* record name in LHS */
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
comment|/* fixed values in query record */
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|name
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%-20s\t%s\t%s\n"
argument_list|,
name|rname
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Nameserver information.  * Stores the names and addresses of all servers that are to be queried  * for a zone transfer of the desired domain. Normally these are the  * authoritative primary and/or secondary nameservers for the domain.  */
end_comment

begin_define
define|#
directive|define
name|MAXNSNAME
value|12
end_define

begin_comment
comment|/* maximum count of nameservers per domain */
end_comment

begin_define
define|#
directive|define
name|MAXIPADDR
value|10
end_define

begin_comment
comment|/* maximum count of addresses per nameserver */
end_comment

begin_decl_stmt
name|char
name|nsname
index|[
name|MAXNSNAME
index|]
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nameserver hostname */
end_comment

begin_decl_stmt
name|struct
name|in_addr
name|ipaddr
index|[
name|MAXNSNAME
index|]
index|[
name|MAXIPADDR
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nameserver addresses */
end_comment

begin_decl_stmt
name|int
name|naddrs
index|[
name|MAXNSNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of addresses */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_struct
struct|struct
name|nsdata
block|{
name|char
name|nsname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* nameserver hostname */
name|struct
name|in_addr
name|ipaddr
index|[
name|MAXIPADDR
index|]
decl_stmt|;
comment|/* nameserver addresses */
name|int
name|naddrs
decl_stmt|;
comment|/* count of addresses */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|nsdata
name|ns
index|[
name|MAXNSNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nameserver info */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Host information.  * Stores names and (single) addresses encountered during the zone listing  * of all A records that belong to the domain. Non-authoritative glue records  * that do not belong to the domain are not stored. Glue records that belong  * to a subdomain will be filtered out later during the host count scan.  */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTS
value|25000
end_define

begin_comment
comment|/* maximum count of hostnames per zone */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hostname
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname of host in domain */
end_comment

begin_decl_stmt
name|u_long
name|hostaddr
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first host address */
end_comment

begin_decl_stmt
name|bool
name|multaddr
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if this is a multiple address host */
end_comment

begin_decl_stmt
name|int
name|hostcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of hosts in domain */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_struct
struct|struct
name|hsdata
block|{
name|char
modifier|*
name|hostname
decl_stmt|;
comment|/* hostname of host in domain */
name|u_long
name|hostaddr
decl_stmt|;
comment|/* first host address */
name|bool
name|multaddr
decl_stmt|;
comment|/* set if this is a multiple address host */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|hsdata
name|hs
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* info on hosts in domain */
end_comment

begin_decl_stmt
name|int
name|hostcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of hosts in domain */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * The maximum count of subdomains per zone doesn't apply any more,  * since the list of zonenames is now allocated dynamically, but the  * host data could have been allocated dynamically instead of statically,  * although this is less important since it is not saved across calls.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Subdomain information.  * Stores the names of the subdomains encountered during the zone listing.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|zonename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of subdomains in domain */
end_comment

begin_decl_stmt
name|int
name|zonecount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of subdomains in domain */
end_comment

begin_comment
comment|/*  * Address information.  * Stores the (single) addresses of hosts found in all domains traversed.  * Used to search for duplicate hosts (same address but different name).  */
end_comment

begin_decl_stmt
name|u_long
modifier|*
name|addrlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global list of addresses */
end_comment

begin_decl_stmt
name|int
name|addrcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of global addresses */
end_comment

begin_comment
comment|/*  * SOA record information.  */
end_comment

begin_struct
struct|struct
name|soa_data
block|{
name|char
name|sname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* name of primary server */
name|char
name|mname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* name of hostmaster mailbox */
name|int
name|serial
decl_stmt|;
comment|/* serial (version) number */
name|int
name|refresh
decl_stmt|;
comment|/* refresh time in seconds */
name|int
name|retry
decl_stmt|;
comment|/* refresh retry time in seconds */
name|int
name|expire
decl_stmt|;
comment|/* expiration time in seconds */
name|int
name|defttl
decl_stmt|;
comment|/* default time_to_live */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|soa_data
name|soa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer to store soa data */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ** LIST_DOMAIN -- Basic routine to do complete zone listing and checking ** --------------------------------------------------------------------- ** **	Returns: **		TRUE if the requested info was processed successfully. **		FALSE otherwise. */
end_comment

begin_decl_stmt
name|int
name|total_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of calls for possible zones */
end_comment

begin_decl_stmt
name|int
name|total_zones
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of zones successfully read */
end_comment

begin_decl_stmt
name|int
name|total_hosts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of hosts in all subdomains */
end_comment

begin_decl_stmt
name|int
name|total_dupls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of duplicates in all subdomains */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|justfun
end_ifdef

begin_decl_stmt
name|char
name|longname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* longest hostname found */
end_comment

begin_decl_stmt
name|int
name|longsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of longest hostname */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|recursion_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current recursion level */
end_comment

begin_function
name|bool
name|list_domain
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to list */
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nservers
decl_stmt|;
comment|/* count of nameservers */
name|int
name|nzones
decl_stmt|;
comment|/* count of subdomains */
name|int
name|nhosts
decl_stmt|;
comment|/* count of real hostnames */
name|int
name|ndupls
decl_stmt|;
comment|/* count of duplicate hosts */
name|int
name|nextrs
decl_stmt|;
comment|/* count of extrazone hosts */
name|int
name|ngates
decl_stmt|;
comment|/* count of gateway hosts */
name|total_calls
operator|+=
literal|1
expr_stmt|;
comment|/* new attempt */
comment|/*  * Normalize to not have trailing dot, unless it is the root domain.  */
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|name
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|name
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*  * Indicate whether we are processing an "in-addr.arpa" inverse domain.  * In this case we will suppress accumulating host count statistics.  */
name|inverse
operator|=
name|indomain
argument_list|(
name|name
argument_list|,
literal|"in-addr.arpa"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  * Find the nameservers for the given domain.  */
name|nservers
operator|=
name|find_servers
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nservers
operator|<
literal|1
condition|)
block|{
name|errmsg
argument_list|(
literal|"No nameservers for %s found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Make sure we have an address for at least one nameserver.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|naddrs
index|[
name|n
index|]
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|n
operator|>=
name|nservers
condition|)
block|{
name|errmsg
argument_list|(
literal|"No addresses of nameservers for %s found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Check SOA records at each of the nameservers.  * Temporarily save our current server info from the resolver database.  * Turn off nameserver recursion and make sure answer is authoritative.  */
if|if
condition|(
name|checkmode
condition|)
block|{
name|struct
name|state
name|save_res
decl_stmt|;
comment|/* saved copy of resolver database */
name|char
modifier|*
name|save_server
decl_stmt|;
comment|/* saved copy of server name */
comment|/* save resolver database */
name|save_res
operator|=
name|_res
expr_stmt|;
name|save_server
operator|=
name|server
expr_stmt|;
comment|/* turn off nameserver recursion */
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|naddrs
index|[
name|n
index|]
operator|<
literal|1
condition|)
continue|continue;
comment|/* shortcut */
name|server
operator|=
name|nsname
index|[
name|n
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNS
operator|&&
name|i
operator|<
name|naddrs
index|[
name|n
index|]
condition|;
name|i
operator|++
control|)
block|{
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_addr
operator|=
name|ipaddr
index|[
name|n
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|_res
operator|.
name|nscount
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|check_domain
argument_list|(
name|name
argument_list|)
operator|==
name|FALSE
condition|)
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_SOA
argument_list|)
expr_stmt|;
block|}
comment|/* restore resolver database */
name|_res
operator|=
name|save_res
expr_stmt|;
name|server
operator|=
name|save_server
expr_stmt|;
comment|/* all done if maximum recursion level reached */
if|if
condition|(
operator|!
name|recursive
operator|||
operator|(
name|recursion_level
operator|>=
name|recursive
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*  * Ask zone transfer to the nameservers, until one responds.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
index|[
name|n
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying server %s (%s) ...\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ipaddr
index|[
name|n
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|transfer_zone
argument_list|(
name|name
argument_list|,
name|queryclass
argument_list|,
name|ipaddr
index|[
name|n
index|]
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* double break */
if|if
condition|(
name|h_errno
operator|!=
name|TRY_AGAIN
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_AXFR
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* in case nameserver not present */
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
break|break;
endif|#
directive|endif
block|}
block|}
name|done
label|:
if|if
condition|(
name|n
operator|>=
name|nservers
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_AXFR
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|"No nameservers for %s responded"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Print resource record statistics if so requested.  */
if|if
condition|(
name|statistics
condition|)
name|print_statistics
argument_list|(
name|name
argument_list|,
name|querytype
argument_list|)
expr_stmt|;
comment|/*  * Accumulate host count statistics for this domain.  */
name|nzones
operator|=
name|zonecount
expr_stmt|;
name|nhosts
operator|=
literal|0
operator|,
name|ndupls
operator|=
literal|0
operator|,
name|nextrs
operator|=
literal|0
operator|,
name|ngates
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hostcount
condition|;
name|n
operator|++
control|)
block|{
comment|/* skip fake hosts using a very rudimentary test */
if|if
condition|(
name|fakename
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
operator|||
name|fakeaddr
argument_list|(
name|hostaddr
index|[
name|n
index|]
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|justfun
comment|/* save longest hostname encountered so far */
if|if
condition|(
name|strlen
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
operator|>
name|longsize
condition|)
block|{
name|longsize
operator|=
name|strlen
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|longname
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* skip apparent glue records */
if|if
condition|(
name|gluerecord
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|,
name|name
argument_list|,
name|zonename
argument_list|,
name|nzones
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s is glue record\n"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* otherwise count as host */
name|nhosts
operator|++
expr_stmt|;
comment|/* 	 * Mark hosts not residing directly in domain as extrazone host. 	 */
if|if
condition|(
operator|!
name|samedomain
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|nextrs
operator|++
expr_stmt|;
if|if
condition|(
name|extrmode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"%s is extrazone host\n"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mark hosts with more than one address as gateway host. 	 * These are not checked for duplicate addresses. 	 */
if|if
condition|(
name|multaddr
index|[
name|n
index|]
condition|)
block|{
name|ngates
operator|++
expr_stmt|;
if|if
condition|(
name|gatemode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"%s is gateway host\n"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Compare single address hosts against global list of addresses. 	 * Multiple address hosts are too complicated to handle this way. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|addrlist
index|[
name|i
index|]
operator|==
name|hostaddr
index|[
name|n
index|]
condition|)
break|break;
comment|/* duplicate */
if|if
condition|(
name|i
operator|<
name|addrcount
condition|)
block|{
name|ndupls
operator|++
expr_stmt|;
if|if
condition|(
name|duplmode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"%s is duplicate host\n"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|addrcount
condition|)
block|{
name|addrlist
operator|=
name|newblk
argument_list|(
name|addrlist
argument_list|,
name|addrcount
operator|+
literal|1
argument_list|,
name|u_long
argument_list|)
expr_stmt|;
name|addrlist
index|[
name|addrcount
index|]
operator|=
name|hostaddr
index|[
name|n
index|]
expr_stmt|;
name|addrcount
operator|++
expr_stmt|;
block|}
block|}
comment|/*  * Print statistics for this domain.  */
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|hostmode
condition|)
block|{
name|printf
argument_list|(
literal|"Found %d host%s within %s\n"
argument_list|,
name|nhosts
argument_list|,
name|nhosts
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ndupls
operator|>
literal|0
operator|)
operator|||
name|duplmode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"Found %d duplicate host%s within %s\n"
argument_list|,
name|ndupls
argument_list|,
name|ndupls
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nextrs
operator|>
literal|0
operator|)
operator|||
name|extrmode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"Found %d extrazone host%s within %s\n"
argument_list|,
name|nextrs
argument_list|,
name|nextrs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ngates
operator|>
literal|0
operator|)
operator|||
name|gatemode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"Found %d gateway host%s within %s\n"
argument_list|,
name|ngates
argument_list|,
name|ngates
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|total_zones
operator|+=
literal|1
expr_stmt|;
comment|/* update total zones processed */
name|total_hosts
operator|+=
name|nhosts
expr_stmt|;
comment|/* update total number of hosts */
name|total_dupls
operator|+=
name|ndupls
expr_stmt|;
comment|/* update total number of duplicates */
comment|/*  * The names of the hosts were allocated dynamically.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hostcount
condition|;
name|n
operator|++
control|)
name|xfree
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
comment|/*  * Do recursion on subdomains if requested and any were found.  * Temporarily save subdomain list, and force allocation of new list.  */
if|if
condition|(
name|verbose
operator|||
name|statistics
condition|)
name|printf
argument_list|(
literal|"Found %d subdomain%s within %s\n"
argument_list|,
name|nzones
argument_list|,
name|nzones
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
operator|&&
operator|(
name|recursion_level
operator|<
name|recursive
operator|)
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nzones
condition|;
name|n
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|subdomain
decl_stmt|;
comment|/* local copy of list */
name|subdomain
operator|=
name|zonename
expr_stmt|;
name|zonename
operator|=
name|NULL
expr_stmt|;
comment|/* allocate new list */
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|checkmode
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Entering subdomain %s\n"
argument_list|,
name|subdomain
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|recursion_level
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|list_domain
argument_list|(
name|subdomain
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|recursion_level
operator|--
expr_stmt|;
name|zonename
operator|=
name|subdomain
expr_stmt|;
block|}
block|}
comment|/*  * The names of the subdomains were allocated dynamically.  * The list of subdomain names was also allocated dynamically.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nzones
condition|;
name|n
operator|++
control|)
name|xfree
argument_list|(
name|zonename
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonename
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|zonename
argument_list|)
expr_stmt|;
name|zonename
operator|=
name|NULL
expr_stmt|;
comment|/*  * Print final overall statistics.  */
if|if
condition|(
name|recursive
operator|&&
operator|(
name|recursion_level
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|checkmode
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|hostmode
condition|)
name|printf
argument_list|(
literal|"Encountered %d host%s in %d domain%s within %s\n"
argument_list|,
name|total_hosts
argument_list|,
name|total_hosts
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total_zones
argument_list|,
name|total_zones
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|hostmode
condition|)
name|printf
argument_list|(
literal|"Encountered %d duplicate host%s in %d domain%s within %s\n"
argument_list|,
name|total_dupls
argument_list|,
name|total_dupls
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total_zones
argument_list|,
name|total_zones
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|checkmode
condition|)
name|printf
argument_list|(
literal|"Processed %d domain%s out of %d attempt%s\n"
argument_list|,
name|total_zones
argument_list|,
name|total_zones
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total_calls
argument_list|,
name|total_calls
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|justfun
if|if
condition|(
name|verbose
operator|&&
operator|(
name|longsize
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"Longest hostname %s\t%d\n"
argument_list|,
name|longname
argument_list|,
name|longsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** FIND_SERVERS -- Fetch names and addresses of authoritative servers ** ------------------------------------------------------------------ ** **	Returns: **		The number of servers found. **		0 if no servers could be determined successfully. ** **	Inputs: **		The global variable server, if set, contains the name **		of the explicit server to be contacted. **		The global variable primary, if set, indicates that **		we must use the primary nameserver for the domain. ** **	Outputs: **		Names are stored in the nsname[] database. **		Addresses are stored in the ipaddr[] database. **		Address counts are stored in the naddrs[] database. */
end_comment

begin_function
name|int
name|find_servers
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to find servers for */
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nservers
decl_stmt|;
comment|/* count of nameservers */
comment|/*  * Use the explicit server if given on the command line.  * Its addresses are stored in the resolver state struct.  * This server may not be authoritative for the given domain.  */
if|if
condition|(
name|server
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nsname
index|[
literal|0
index|]
argument_list|,
name|server
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXIPADDR
operator|&&
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
name|ipaddr
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_addr
expr_stmt|;
name|naddrs
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|nservers
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|nservers
operator|)
return|;
block|}
comment|/*  * Fetch primary nameserver info if so requested.  * Get its name from the SOA record for the domain,  * and do a regular host lookup to fetch its addresses.  */
if|if
condition|(
name|primary
condition|)
block|{
name|char
modifier|*
name|primaryname
decl_stmt|;
name|primaryname
operator|=
name|get_primary
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|primaryname
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_SOA
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hp
operator|=
name|gethostbyname
argument_list|(
name|primaryname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|primaryname
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nsname
index|[
literal|0
index|]
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXIPADDR
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|ipaddr
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|naddrs
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d address%s for %s\n"
argument_list|,
name|naddrs
index|[
literal|0
index|]
argument_list|,
name|naddrs
index|[
literal|0
index|]
operator|==
literal|1
condition|?
literal|"  "
else|:
literal|"es"
argument_list|,
name|nsname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nservers
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|nservers
operator|)
return|;
block|}
comment|/*  * Otherwise we have to find the nameservers for the domain.  */
name|nservers
operator|=
name|get_servers
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nservers
operator|<
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_NS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Usually we'll get addresses for all the servers in the additional  * info section.  But in case we don't, look up their addresses.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|naddrs
index|[
name|n
index|]
operator|==
literal|0
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXIPADDR
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|ipaddr
index|[
name|n
index|]
index|[
name|i
index|]
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|naddrs
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d address%s for %s by extra query\n"
argument_list|,
name|naddrs
index|[
name|n
index|]
argument_list|,
name|naddrs
index|[
name|n
index|]
operator|==
literal|1
condition|?
literal|"  "
else|:
literal|"es"
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d address%s for %s\n"
argument_list|,
name|naddrs
index|[
name|n
index|]
argument_list|,
name|naddrs
index|[
name|n
index|]
operator|==
literal|1
condition|?
literal|"  "
else|:
literal|"es"
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nservers
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_SERVERS -- Fetch names and addresses of authoritative servers ** ----------------------------------------------------------------- ** **	Returns: **		The number of servers found. **		0 if no servers could be determined successfully. ** **	Side effects: **		Names are stored in the nsname[] database. **		Addresses are stored in the ipaddr[] database. **		Address counts are stored in the naddrs[] database. */
end_comment

begin_function
name|int
name|get_servers
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to find servers for */
block|{
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
name|int
name|nservers
decl_stmt|;
comment|/* count of nameservers */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Finding nameservers for %s ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|T_NS
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|anslen
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|T_ANY
argument_list|)
expr_stmt|;
name|nservers
operator|=
name|get_nsinfo
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|nservers
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_NSINFO -- Extract nameserver data from nameserver answer buffer ** ------------------------------------------------------------------- ** **	Returns: **		The number of servers found. **		0 if no servers could be determined successfully. ** **	Outputs: **		Names are stored in the nsname[] database. **		Addresses are stored in the ipaddr[] database. **		Address counts are stored in the naddrs[] database. */
end_comment

begin_function
name|int
name|get_nsinfo
parameter_list|(
name|answerbuf
parameter_list|,
name|answerlen
parameter_list|,
name|name
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
name|input
name|int
name|answerlen
decl_stmt|;
comment|/* length of answer buffer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to find servers for */
block|{
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|;
name|int
name|rrcount
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nservers
init|=
literal|0
decl_stmt|;
comment|/* count of nameservers */
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|eom
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
name|answerlen
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|skip_qr
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|qdcount
operator|--
expr_stmt|;
block|}
comment|/*  * If the answer is authoritative, the names are found in the  * answer section, and the nameserver section is empty.  * If not, there may be duplicate names in both sections.  * Addresses are found in the additional info section both cases.  */
name|rrcount
operator|=
name|ancount
operator|+
name|nscount
operator|+
name|arcount
expr_stmt|;
while|while
condition|(
name|rrcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|char
name|rname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|ttl
decl_stmt|,
name|dlen
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|name
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%-20s\t%d\t%s\t%s\n"
argument_list|,
name|rname
argument_list|,
name|ttl
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|type
operator|==
name|T_NS
operator|)
operator|&&
name|sameword
argument_list|(
name|rname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nservers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
name|dname
argument_list|)
condition|)
break|break;
comment|/* duplicate */
if|if
condition|(
name|i
operator|>=
name|nservers
operator|&&
name|nservers
operator|<
name|MAXNSNAME
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nsname
index|[
name|nservers
index|]
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|naddrs
index|[
name|nservers
index|]
operator|=
literal|0
expr_stmt|;
name|nservers
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|T_A
operator|)
operator|&&
name|dlen
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nservers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
name|rname
argument_list|)
condition|)
break|break;
comment|/* found */
if|if
condition|(
name|i
operator|<
name|nservers
operator|&&
name|naddrs
index|[
name|i
index|]
operator|<
name|MAXIPADDR
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ipaddr
index|[
name|i
index|]
index|[
name|naddrs
index|[
name|i
index|]
index|]
operator|=
name|inaddr
expr_stmt|;
name|naddrs
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
name|rrcount
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|nservers
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** TRANSFER_ZONE -- Wrapper for get_zone() to hide administrative tasks ** -------------------------------------------------------------------- ** **	Returns: **		See get_zone() for details. ** **	Side effects: **		See get_zone() for details. ** **	This routine may be called repeatedly with different server **	addresses, until one of the servers responds. Various items **	must be reset on every try to continue with a clean slate. */
end_comment

begin_function
name|bool
name|transfer_zone
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|inaddr
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to do zone xfer for */
name|input
name|int
name|class
decl_stmt|;
comment|/* specific resource record class */
name|input
name|struct
name|in_addr
name|inaddr
decl_stmt|;
comment|/* address of server to be queried */
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/*  * Reset the resource record statistics before each try.  */
name|clear_statistics
argument_list|()
expr_stmt|;
comment|/*  * Perform the actual zone transfer.  */
if|if
condition|(
name|get_zone
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|inaddr
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/*  * Failure to get the zone. Free any memory that may have been allocated.  * On success it is the responsibility of the caller to free the memory.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hostcount
condition|;
name|n
operator|++
control|)
name|xfree
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|zonecount
condition|;
name|n
operator|++
control|)
name|xfree
argument_list|(
name|zonename
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonename
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|zonename
argument_list|)
expr_stmt|;
name|zonename
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_ZONE -- Perform a zone transfer from server at specific address ** ------------------------------------------------------------------- ** **	Returns: **		TRUE if the zone data have been retrieved successfully. **		FALSE if an error occurred (h_errno is set appropriately). **		Set TRY_AGAIN wherever possible to try the next server. ** **	Side effects: **		Stores list of subdomains found in zonename[], **		and the count of subdomains in zonecount. **		Stores list of hostnames  found in hostname[], **		and the count of hostnames in hostcount. **		Updates resource record statistics in record_stats[]. **		This array must have been cleared before. */
end_comment

begin_function
name|bool
name|get_zone
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|inaddr
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to do zone xfer for */
name|input
name|int
name|class
decl_stmt|;
comment|/* specific resource record class */
name|input
name|struct
name|in_addr
name|inaddr
decl_stmt|;
comment|/* address of server to be queried */
block|{
name|querybuf
name|query
decl_stmt|;
name|querybuf
name|answer
decl_stmt|;
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|ancount
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nrecords
init|=
literal|0
decl_stmt|;
comment|/* number of records processed */
name|int
name|soacount
init|=
literal|0
decl_stmt|;
comment|/* count of SOA records */
name|zonecount
operator|=
literal|0
expr_stmt|;
comment|/* count of subdomains */
name|hostcount
operator|=
literal|0
expr_stmt|;
comment|/* count of hostnames */
comment|/*  * Construct query, and connect to the given server.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|T_AXFR
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rrec
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
sizeof|sizeof
argument_list|(
name|querybuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_mkquery failed\n"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"get_zone()\n"
argument_list|)
expr_stmt|;
name|p_query
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|)
expr_stmt|;
block|}
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|inaddr
expr_stmt|;
if|if
condition|(
name|_res_connect
argument_list|(
name|sock
argument_list|,
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
operator|||
name|verbose
condition|)
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Asking zone transfer for %s ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/*  * Send the query buffer.  */
if|if
condition|(
name|_res_write
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Process all incoming records, each record in a separate packet.  */
while|while
condition|(
operator|(
name|n
operator|=
name|_res_read
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|answer
argument_list|,
sizeof|sizeof
argument_list|(
name|querybuf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
condition|)
block|{
name|pr_error
argument_list|(
literal|"answer length %d too short"
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"got answer:\n"
argument_list|)
expr_stmt|;
name|p_query
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|answer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Analyze the contents of the answer and check for errors. 	 */
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|&
name|answer
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|ancount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|print_status
argument_list|(
operator|&
name|answer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* distinguish between authoritative or not */
name|h_errno
operator|=
name|bp
operator|->
name|aa
condition|?
name|HOST_NOT_FOUND
else|:
name|TRY_AGAIN
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
comment|/* distinguish between authoritative or not */
name|h_errno
operator|=
name|bp
operator|->
name|aa
condition|?
name|NO_DATA
else|:
name|NO_RREC
expr_stmt|;
break|break;
default|default:
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|h_errno
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Valid packet received. Print contents if appropriate. 	 */
name|nrecords
operator|++
expr_stmt|;
name|soaname
operator|=
name|NULL
expr_stmt|;
name|subname
operator|=
name|NULL
expr_stmt|;
name|adrname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|n
argument_list|,
name|name
argument_list|,
name|querytype
argument_list|)
expr_stmt|;
comment|/* 	 * Terminate upon the second SOA record for this domain. 	 */
if|if
condition|(
name|soaname
operator|&&
name|sameword
argument_list|(
name|soaname
argument_list|,
name|name
argument_list|)
condition|)
if|if
condition|(
name|soacount
operator|++
condition|)
break|break;
comment|/* the nameserver balks on this one */
if|if
condition|(
name|soaname
operator|&&
operator|!
name|sameword
argument_list|(
name|soaname
argument_list|,
name|name
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous SOA record for %s within %s"
argument_list|,
name|soaname
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Save encountered subdomain name for recursive listing. 	 */
if|if
condition|(
name|subname
operator|&&
name|indomain
argument_list|(
name|subname
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zonecount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|zonename
index|[
name|i
index|]
argument_list|,
name|subname
argument_list|)
condition|)
break|break;
comment|/* duplicate */
if|if
condition|(
name|i
operator|>=
name|zonecount
condition|)
block|{
name|zonename
operator|=
name|newblk
argument_list|(
name|zonename
argument_list|,
name|zonecount
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|zonename
index|[
name|zonecount
index|]
operator|=
name|newstr
argument_list|(
name|subname
argument_list|)
expr_stmt|;
name|zonecount
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|obsolete
comment|/* not sure whether this is illegal or not (no, it's not) */
if|if
condition|(
name|subname
operator|&&
operator|!
name|samedomain
argument_list|(
name|subname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous NS record for %s within %s"
argument_list|,
name|subname
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* warn about strange subdomains */
if|if
condition|(
name|subname
operator|&&
operator|!
name|indomain
argument_list|(
name|subname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous NS record for %s within %s"
argument_list|,
name|subname
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Save encountered name of A record for hostname count. 	 */
if|if
condition|(
name|adrname
operator|&&
name|indomain
argument_list|(
name|adrname
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
operator|&&
operator|!
name|inverse
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hostcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|hostname
index|[
name|i
index|]
argument_list|,
name|adrname
argument_list|)
condition|)
break|break;
comment|/* duplicate */
if|if
condition|(
name|i
operator|<
name|hostcount
operator|&&
name|address
operator|!=
name|hostaddr
index|[
name|i
index|]
condition|)
name|multaddr
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|hostcount
operator|&&
name|hostcount
operator|<
name|MAXHOSTS
condition|)
block|{
name|hostname
index|[
name|hostcount
index|]
operator|=
name|newstr
argument_list|(
name|adrname
argument_list|)
expr_stmt|;
name|hostaddr
index|[
name|hostcount
index|]
operator|=
name|address
expr_stmt|;
name|multaddr
index|[
name|hostcount
index|]
operator|=
name|FALSE
expr_stmt|;
name|hostcount
operator|++
expr_stmt|;
if|if
condition|(
name|hostcount
operator|==
name|MAXHOSTS
condition|)
name|pr_error
argument_list|(
literal|"maximum number of %d hostnames reached"
argument_list|,
name|hostcount
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check for unauthoritative glue records */
if|if
condition|(
name|adrname
operator|&&
operator|!
name|indomain
argument_list|(
name|adrname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous glue record for %s within %s"
argument_list|,
name|adrname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*  * End of zone transfer at second SOA record or zero length read.  */
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/*  * Do extra check for hostnames also defined as subdomains.  * They may have been defined in the child domain, and crept in  * the parent domain, or may have been defined as glue records.  * This is not necessarily an error, but the hostname count may  * be actually wrong. Leave it in for the time being.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hostcount
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zonecount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sameword
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|,
name|zonename
index|[
name|i
index|]
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous A record for %s within %s"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Transfer complete, %d records received for %s\n"
argument_list|,
name|nrecords
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_PRIMARY -- Fetch name of primary nameserver for a domain ** ------------------------------------------------------------ ** **	Returns: **		Pointer to the name of the primary server, if found. **		NULL if the server could not be determined. */
end_comment

begin_function
name|char
modifier|*
name|get_primary
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to get soa for */
block|{
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Finding primary nameserver for %s ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|T_SOA
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|anslen
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|T_ANY
argument_list|)
expr_stmt|;
name|soaname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|get_soainfo
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soaname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|soa
operator|.
name|sname
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_DOMAIN -- Fetch and analyze SOA record of a domain ** -------------------------------------------------------- ** **	Returns: **		TRUE if the SOA record was found at the given server. **		FALSE otherwise. ** **	Inputs: **		The global variable server must contain the name **		of the server that was queried. */
end_comment

begin_function
name|bool
name|check_domain
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to get soa for */
block|{
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Checking SOA for %s at server %s\n"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|T_SOA
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|anslen
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|T_ANY
argument_list|)
expr_stmt|;
name|soaname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|get_soainfo
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soaname
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|check_soa
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_SOAINFO -- Extract SOA data from nameserver answer buffer ** ------------------------------------------------------------- ** **	Returns: **		NOERROR if the SOA record was found successfully. **		FORMERR otherwise. ** **	Outputs: **		The global struct soa is filled with the soa data. ** **	Side effects: **		Sets soaname if this is a valid SOA record. **		This variable must have been cleared before calling **		get_soainfo() and may be checked afterwards. */
end_comment

begin_function
name|int
name|get_soainfo
parameter_list|(
name|answerbuf
parameter_list|,
name|answerlen
parameter_list|,
name|name
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
name|input
name|int
name|answerlen
decl_stmt|;
comment|/* length of answer buffer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to get soa for */
block|{
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|eom
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
name|answerlen
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|skip_qr
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FORMERR
operator|)
return|;
name|qdcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|qdcount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid qdcount in response"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
comment|/*  * Check answer section only.  * The nameserver section may contain the nameservers for the domain,  * and the additional section their addresses, but not guaranteed.  */
while|while
condition|(
name|ancount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|char
name|rname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|ttl
decl_stmt|,
name|dlen
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|u_char
modifier|*
name|eor
decl_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|name
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|FORMERR
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FORMERR
operator|)
return|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|eor
operator|=
name|cp
operator|+
name|dlen
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%-20s\t%d\t%s\t%s\n"
argument_list|,
name|rname
argument_list|,
name|ttl
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_SOA
case|:
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|soa
operator|.
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|soa
operator|.
name|mname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|soa
operator|.
name|serial
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|soa
operator|.
name|refresh
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|soa
operator|.
name|retry
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|soa
operator|.
name|expire
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|soa
operator|.
name|defttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
comment|/* valid complete soa record found */
name|soaname
operator|=
name|strcpy
argument_list|(
name|soanamebuf
argument_list|,
name|rname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|!=
name|eor
condition|)
block|{
name|pr_error
argument_list|(
literal|"size error in %s record for %s, dlen = %d, off by = %d"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rname
argument_list|,
name|dlen
argument_list|,
operator|(
name|cp
operator|-
name|eor
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
name|ancount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ancount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid ancount in response"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
return|return
operator|(
name|NOERROR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_SOA -- Analyze retrieved SOA records of a domain ** ------------------------------------------------------ ** **	Returns: **		None. ** **	Inputs: **		The global variable server must contain the name **		of the server that was queried. **		The global struct soa must contain the soa data. */
end_comment

begin_function
name|void
name|check_soa
parameter_list|(
name|answerbuf
parameter_list|,
name|name
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain to check soa for */
block|{
specifier|static
name|char
modifier|*
name|oldname
init|=
name|NULL
decl_stmt|;
comment|/* previous name of domain */
specifier|static
name|char
modifier|*
name|oldserver
init|=
name|NULL
decl_stmt|;
comment|/* previous name of server */
specifier|static
name|struct
name|soa_data
name|oldsoa
decl_stmt|;
comment|/* previous soa data */
name|HEADER
modifier|*
name|bp
decl_stmt|;
comment|/*  * Print the various SOA fields in abbreviated form.  */
name|printf
argument_list|(
literal|"%s\t%s\t(%d %d %d %d %d)\n"
argument_list|,
name|soa
operator|.
name|sname
argument_list|,
name|soa
operator|.
name|mname
argument_list|,
name|soa
operator|.
name|serial
argument_list|,
name|soa
operator|.
name|refresh
argument_list|,
name|soa
operator|.
name|retry
argument_list|,
name|soa
operator|.
name|expire
argument_list|,
name|soa
operator|.
name|defttl
argument_list|)
expr_stmt|;
comment|/*  * We are supposed to have queried an authoritative nameserver, and  * nameserver recursion has been turned off. Answer must be authoritative.  */
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|->
name|aa
condition|)
name|pr_error
argument_list|(
literal|"SOA record for %s at %s is not authoritative"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
comment|/*  * Compare various fields with those of the previous query, if any.  * Different serial numbers may be present if secondaries have not yet  * refreshed the data from the primary.  */
if|if
condition|(
name|oldname
operator|&&
operator|!
name|sameword
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|)
condition|)
name|oldname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|oldname
condition|)
block|{
if|if
condition|(
name|soa
operator|.
name|serial
operator|!=
name|oldsoa
operator|.
name|serial
condition|)
name|pr_warning
argument_list|(
literal|"%s has different serial than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|soa
operator|.
name|sname
argument_list|,
name|oldsoa
operator|.
name|sname
argument_list|)
condition|)
name|pr_error
argument_list|(
literal|"%s has different primary than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|soa
operator|.
name|mname
argument_list|,
name|oldsoa
operator|.
name|mname
argument_list|)
condition|)
name|pr_error
argument_list|(
literal|"%s has different hostmaster than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
block|}
name|oldname
operator|=
name|name
expr_stmt|;
name|oldserver
operator|=
name|server
expr_stmt|;
name|oldsoa
operator|=
name|soa
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_ADDR -- Check if reverse address mappings revert to host ** -------------------------------------------------------------- ** **	Returns: **		TRUE if all addresses of host map back to host. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|check_addr
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* hostname to check addresses for */
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|in_addr
name|inaddr
index|[
name|MAXADDRS
index|]
decl_stmt|;
name|int
name|naddr
decl_stmt|;
name|char
name|hnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|hname
decl_stmt|;
name|int
name|matched
decl_stmt|;
comment|/*  * Look up the specified host to fetch its addresses.  */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|hname
operator|=
name|strcpy
argument_list|(
name|hnamebuf
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXADDRS
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|inaddr
index|[
name|i
index|]
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|naddr
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d address%s for %s\n"
argument_list|,
name|naddr
argument_list|,
name|naddr
operator|==
literal|1
condition|?
literal|""
else|:
literal|"es"
argument_list|,
name|hname
argument_list|)
expr_stmt|;
comment|/*  * Map back the addresses found, and check if they revert to host.  */
for|for
control|(
name|matched
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddr
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|iname
init|=
name|inet_ntoa
argument_list|(
name|inaddr
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|u_long
name|addr
init|=
name|inaddr
index|[
name|i
index|]
operator|.
name|s_addr
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Checking %s address %s\n"
argument_list|,
name|hname
argument_list|,
name|iname
argument_list|)
expr_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
name|ns_error
argument_list|(
name|iname
argument_list|,
name|T_PTR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
name|hname
argument_list|)
condition|)
name|pr_error
argument_list|(
literal|"address %s of %s maps to %s"
argument_list|,
name|iname
argument_list|,
name|hname
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
else|else
name|matched
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|matched
operator|==
name|naddr
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_NAME -- Check if address belongs to host addresses ** -------------------------------------------------------- ** **	Returns: **		TRUE if given address was found among host addresses. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|check_name
parameter_list|(
name|addr
parameter_list|)
name|input
name|u_long
name|addr
decl_stmt|;
comment|/* address of host to check */
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|char
name|hnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|hname
decl_stmt|;
name|char
name|inamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|iname
decl_stmt|;
name|int
name|matched
decl_stmt|;
comment|/*  * Check if the address is registered by fetching its hostname.  */
name|inaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|iname
operator|=
name|strcpy
argument_list|(
name|inamebuf
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|iname
argument_list|,
name|T_PTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|hname
operator|=
name|strcpy
argument_list|(
name|hnamebuf
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Address %s maps to %s\n"
argument_list|,
name|iname
argument_list|,
name|hname
argument_list|)
expr_stmt|;
comment|/*  * Lookup the hostname found to fetch its addresses.  * Check if the given address is listed among the known addresses.  */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|hname
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
for|for
control|(
name|matched
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|inaddr
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Checking %s address %s\n"
argument_list|,
name|hname
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inaddr
operator|.
name|s_addr
operator|==
name|addr
condition|)
name|matched
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
name|pr_error
argument_list|(
literal|"address %s does not belong to %s"
argument_list|,
name|iname
argument_list|,
name|hname
argument_list|)
expr_stmt|;
return|return
operator|(
name|matched
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PARSE_TYPE -- Decode rr type from input string ** ---------------------------------------------- ** **	Returns: **		Value of resource record type. **		-1 if specified record name is invalid. ** **	Note.	T_MD, T_MF, T_MAILA are obsolete, but recognized. **		T_AXFR is not allowed to be specified as query type. */
end_comment

begin_function
name|int
name|parse_type
parameter_list|(
name|str
parameter_list|)
name|input
name|char
modifier|*
name|str
decl_stmt|;
comment|/* input string with record type */
block|{
specifier|register
name|int
name|type
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"A"
argument_list|)
condition|)
return|return
operator|(
name|T_A
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"NS"
argument_list|)
condition|)
return|return
operator|(
name|T_NS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MD"
argument_list|)
condition|)
return|return
operator|(
name|T_MD
operator|)
return|;
comment|/* obsolete */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MF"
argument_list|)
condition|)
return|return
operator|(
name|T_MF
operator|)
return|;
comment|/* obsolete */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"CNAME"
argument_list|)
condition|)
return|return
operator|(
name|T_CNAME
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"SOA"
argument_list|)
condition|)
return|return
operator|(
name|T_SOA
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MB"
argument_list|)
condition|)
return|return
operator|(
name|T_MB
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MG"
argument_list|)
condition|)
return|return
operator|(
name|T_MG
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MR"
argument_list|)
condition|)
return|return
operator|(
name|T_MR
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"NULL"
argument_list|)
condition|)
return|return
operator|(
name|T_NULL
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"WKS"
argument_list|)
condition|)
return|return
operator|(
name|T_WKS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"PTR"
argument_list|)
condition|)
return|return
operator|(
name|T_PTR
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"HINFO"
argument_list|)
condition|)
return|return
operator|(
name|T_HINFO
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MINFO"
argument_list|)
condition|)
return|return
operator|(
name|T_MINFO
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MX"
argument_list|)
condition|)
return|return
operator|(
name|T_MX
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"TXT"
argument_list|)
condition|)
return|return
operator|(
name|T_TXT
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"RP"
argument_list|)
condition|)
return|return
operator|(
name|T_RP
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"AFSDB"
argument_list|)
condition|)
return|return
operator|(
name|T_AFSDB
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"X25"
argument_list|)
condition|)
return|return
operator|(
name|T_X25
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"ISDN"
argument_list|)
condition|)
return|return
operator|(
name|T_ISDN
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"RT"
argument_list|)
condition|)
return|return
operator|(
name|T_RT
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"NSAP"
argument_list|)
condition|)
return|return
operator|(
name|T_NSAP
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"NSAP-PTR"
argument_list|)
condition|)
return|return
operator|(
name|T_NSAPPTR
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"UINFO"
argument_list|)
condition|)
return|return
operator|(
name|T_UINFO
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"UID"
argument_list|)
condition|)
return|return
operator|(
name|T_UID
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"GID"
argument_list|)
condition|)
return|return
operator|(
name|T_GID
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"UNSPEC"
argument_list|)
condition|)
return|return
operator|(
name|T_UNSPEC
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"AXFR"
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* illegal */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MAILB"
argument_list|)
condition|)
return|return
operator|(
name|T_MAILB
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MAILA"
argument_list|)
condition|)
return|return
operator|(
name|T_MAILA
operator|)
return|;
comment|/* obsolete */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"ANY"
argument_list|)
condition|)
return|return
operator|(
name|T_ANY
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"*"
argument_list|)
condition|)
return|return
operator|(
name|T_ANY
operator|)
return|;
name|type
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|T_FIRST
operator|&&
name|type
operator|<=
name|T_LAST
condition|)
return|return
operator|(
name|type
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PARSE_CLASS -- Decode rr class from input string ** ------------------------------------------------ ** **	Returns: **		Value of resource class. **		-1 if specified class name is invalid. */
end_comment

begin_function
name|int
name|parse_class
parameter_list|(
name|str
parameter_list|)
name|input
name|char
modifier|*
name|str
decl_stmt|;
comment|/* input string with resource class */
block|{
specifier|register
name|int
name|class
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"IN"
argument_list|)
condition|)
return|return
operator|(
name|C_IN
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"CHAOS"
argument_list|)
condition|)
return|return
operator|(
name|C_CHAOS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"HS"
argument_list|)
condition|)
return|return
operator|(
name|C_HS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"ANY"
argument_list|)
condition|)
return|return
operator|(
name|C_ANY
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"*"
argument_list|)
condition|)
return|return
operator|(
name|C_ANY
operator|)
return|;
name|class
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|>
literal|0
condition|)
return|return
operator|(
name|class
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** IN_ADDR_ARPA -- Convert dotted quad string to inverse in-addr.arpa ** ------------------------------------------------------------------ ** **	Returns: **		Pointer to inverse in-addr.arpa. domain name **		with trailing dot to force absolute domain name. **		NULL in case of invalid dotted quad input string. */
end_comment

begin_function
name|char
modifier|*
name|in_addr_arpa
parameter_list|(
name|dottedquad
parameter_list|)
name|input
name|char
modifier|*
name|dottedquad
decl_stmt|;
comment|/* input string with dotted quad */
block|{
specifier|static
name|char
name|addrbuf
index|[
literal|32
index|]
decl_stmt|;
name|u_int
name|a
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|dottedquad
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
operator|&
name|a
index|[
literal|0
index|]
argument_list|,
operator|&
name|a
index|[
literal|1
index|]
argument_list|,
operator|&
name|a
index|[
literal|2
index|]
argument_list|,
operator|&
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|4
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addrbuf
argument_list|,
literal|"%u.%u.%u.%u.in-addr.arpa."
argument_list|,
name|a
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addrbuf
argument_list|,
literal|"%u.%u.%u.in-addr.arpa."
argument_list|,
name|a
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addrbuf
argument_list|,
literal|"%u.%u.in-addr.arpa."
argument_list|,
name|a
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addrbuf
argument_list|,
literal|"%u.in-addr.arpa."
argument_list|,
name|a
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
name|a
index|[
name|n
index|]
operator|>
literal|255
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|addrbuf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_HOST -- Print hostname and address of hostent struct ** ---------------------------------------------------------- ** **	Returns: **		None. */
end_comment

begin_function
name|void
name|print_host
parameter_list|(
name|heading
parameter_list|,
name|hp
parameter_list|)
name|input
name|char
modifier|*
name|heading
decl_stmt|;
comment|/* header string */
name|input
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
comment|/* address of hostent struct */
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|printf
argument_list|(
literal|"%s: %s"
argument_list|,
name|heading
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|hp
operator|->
name|h_addr_list
init|;
name|ap
operator|&&
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|==
name|hp
operator|->
name|h_addr_list
condition|)
name|printf
argument_list|(
literal|"\nAddress:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|incopy
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ap
operator|=
name|hp
operator|->
name|h_aliases
init|;
name|ap
operator|&&
operator|*
name|ap
operator|&&
operator|*
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|==
name|hp
operator|->
name|h_aliases
condition|)
name|printf
argument_list|(
literal|"\nAliases:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_RES -- Print resolver database information ** ------------------------------------------------ ** **	Returns: **		None. ** **	Inputs: **		The resolver database _res is localized in the resolver. */
end_comment

begin_function
name|void
name|print_res
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|domain
decl_stmt|;
comment|/*  * The default domain is defined by the "domain" entry in /etc/resolv.conf  * if not overridden by the environment variable "LOCALDOMAIN".  * If still not defined, gethostname() may yield a fully qualified hostname.  */
name|printf
argument_list|(
literal|"Default domain:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_res
operator|.
name|defdname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|_res
operator|.
name|defdname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*  * The search domains are extracted from the default domain components,  * but may be overridden by "search" directives in /etc/resolv.conf  * since 4.8.3.  */
name|printf
argument_list|(
literal|"Search domains:"
argument_list|)
expr_stmt|;
for|for
control|(
name|domain
operator|=
name|_res
operator|.
name|dnsrch
init|;
operator|*
name|domain
condition|;
name|domain
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*  * The routine res_send() will do _res.retry tries to contact each of the  * _res.nscount nameserver addresses before giving up when using datagrams.  * The first try will timeout after _res.retrans seconds. Each following  * try will timeout after ((_res.retrans<< try) / _res.nscount) seconds.  * Note. When we contact an explicit server the addresses will be replaced  * by the multiple addresses of the same server.  * When doing a zone transfer _res.retrans is used for the connect timeout.  */
name|printf
argument_list|(
literal|"Timeout per retry: %d secs\n"
argument_list|,
name|_res
operator|.
name|retrans
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Number of retries: %d\n"
argument_list|,
name|_res
operator|.
name|retry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Number of addresses: %d\n"
argument_list|,
name|_res
operator|.
name|nscount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  * The resolver options are initialized by res_init() to contain the  * defaults settings (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)  * The various options have the following meaning:  *  *	RES_INIT	set after res_init() has been called  *	RES_DEBUG	let the resolver modules print debugging info  *	RES_AAONLY	want authoritative answers only (not implemented)  *	RES_USEVC	use tcp virtual circuit instead of udp datagrams  *	RES_PRIMARY	use primary nameserver only (not implemented)  *	RES_IGNTC	ignore datagram truncation; don't switch to tcp  *	RES_RECURSE	forward query if answer not locally available  *	RES_DEFNAMES	add default domain to queryname without dot  *	RES_STAYOPEN	keep tcp socket open for subsequent queries  *	RES_DNSRCH	append search domains even to queryname with dot  */
name|printf
argument_list|(
literal|"Options set:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_INIT
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" INIT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_DEBUG
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_AAONLY
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" AAONLY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_USEVC
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" USEVC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_PRIMARY
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PRIMARY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_IGNTC
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" IGNTC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_RECURSE
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" RECURSE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_DEFNAMES
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DEFNAMES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_STAYOPEN
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" STAYOPEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_DNSRCH
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DNSRCH"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Options clr:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_INIT
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" INIT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DEBUG
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_AAONLY
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" AAONLY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_USEVC
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" USEVC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_PRIMARY
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PRIMARY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_IGNTC
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" IGNTC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_RECURSE
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" RECURSE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DEFNAMES
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DEFNAMES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_STAYOPEN
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" STAYOPEN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DNSRCH
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DNSRCH"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_STATISTICS -- Print resource record statistics ** ---------------------------------------------------- ** **	Returns: **		None. ** **	Inputs: **		The record_stats[] counts have been updated by print_rr(). */
end_comment

begin_function
name|void
name|print_statistics
parameter_list|(
name|name
parameter_list|,
name|filter
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of domain we are listing */
name|input
name|int
name|filter
decl_stmt|;
comment|/* type of records we want to see */
block|{
specifier|register
name|int
name|type
decl_stmt|;
name|int
name|nrecords
decl_stmt|;
for|for
control|(
name|type
operator|=
name|T_FIRST
init|;
name|type
operator|<=
name|T_LAST
condition|;
name|type
operator|++
control|)
block|{
name|nrecords
operator|=
name|record_stats
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|nrecords
operator|>
literal|0
operator|||
operator|(
name|filter
operator|!=
name|T_ANY
operator|&&
name|want_rr
argument_list|(
name|type
argument_list|,
name|filter
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Found %4d %-5s record%s within %s\n"
argument_list|,
name|nrecords
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|nrecords
operator|==
literal|1
condition|?
literal|" "
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** CLEAR_STATISTICS -- Clear resource record statistics ** ---------------------------------------------------- ** **	Returns: **		None. */
end_comment

begin_function
name|void
name|clear_statistics
parameter_list|()
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|record_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|record_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_TYPES -- Print resource record types wanted ** ------------------------------------------------- ** **	Returns: **		None. */
end_comment

begin_function
name|void
name|print_types
parameter_list|(
name|name
parameter_list|,
name|filter
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name we want to query about */
name|input
name|int
name|filter
decl_stmt|;
comment|/* type of records we want to see */
block|{
specifier|register
name|int
name|type
decl_stmt|;
if|if
condition|(
name|filter
operator|>=
name|T_NONE
condition|)
block|{
name|printf
argument_list|(
literal|"Query about %s for record types"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|==
name|T_ANY
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|pr_type
argument_list|(
name|T_ANY
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|type
operator|=
name|T_FIRST
init|;
name|type
operator|<=
name|T_LAST
condition|;
name|type
operator|++
control|)
if|if
condition|(
name|want_rr
argument_list|(
name|type
argument_list|,
name|filter
argument_list|)
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** NS_ERROR -- Print error message from errno and h_errno ** ------------------------------------------------------ ** **	Returns: **		None. ** **	Inputs: **		The global variable server, if set, contains **		the name of the server that was contacted. */
end_comment

begin_function
name|void
name|ns_error
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name we queried about */
name|input
name|int
name|type
decl_stmt|;
comment|/* record type we queried about */
block|{
comment|/*  * If res_send() fails, it will leave errno in either of the first two  * following states when using datagrams. Note that this depends on the  * proper handling of connected datagram sockets, which is usually true  * if BSD>= 43 (see res_send.c for details; it may need a patch).  * Note. If it succeeds, it may leave errno in the state EAFNOSUPPORT  * if it has disconnected a previously connected datagram socket, since  * the dummy address used to disconnect does not have a proper family set.  * Always clear errno after getting a reply, or patch res_send().  * Our private version of res_send() will leave also other error statuses.  */
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ECONNREFUSED
case|:
comment|/* 		 * The contacted host does not have a nameserver running. 		 * The standard res_send() also returns this if none of 		 * the intended hosts could be reached via datagrams. 		 */
if|if
condition|(
name|server
condition|)
name|errmsg
argument_list|(
literal|"Nameserver %s not running"
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"Nameserver not running"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIMEDOUT
case|:
comment|/* 		 * The contacted host did not give any reply at all. 		 */
if|if
condition|(
name|server
condition|)
name|errmsg
argument_list|(
literal|"Nameserver %s not responding"
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"Nameserver not responding"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
comment|/* 		 * The host to be contacted or its network can not be reached. 		 * Our private res_send() also returns this using datagrams. 		 */
if|if
condition|(
name|server
condition|)
name|errmsg
argument_list|(
literal|"Nameserver %s not reachable"
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"Nameserver not reachable"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  * Print the message associated with the particular nameserver error.  */
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
comment|/* 		 * The specified name does definitely not exist at all. 		 * In this case the answer is always authoritative. 		 */
name|errmsg
argument_list|(
literal|"%s does not exist (Authoritative answer)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
comment|/* 		 * Some intermediate server failure, e.g. timeout. 		 */
name|errmsg
argument_list|(
literal|"%s %s record not found, try again"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
comment|/* 		 * Some irrecoverable format error, or server refusal. 		 */
name|errmsg
argument_list|(
literal|"%s %s record not found, no recovery"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_DATA
case|:
comment|/* 		 * The name is valid, but the specified type does not exist. 		 * This status is here returned only in case authoritative. 		 */
name|errmsg
argument_list|(
literal|"%s has no %s record (Authoritative answer)"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_RREC
case|:
comment|/* 		 * The specified type does not exist, but we don't know whether 		 * the name is valid or not. The answer was not authoritative. 		 * Perhaps recursion was off, and no data was cached locally. 		 */
name|errmsg
argument_list|(
literal|"%s %s record not present"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Unknown cause for server failure. 		 */
name|errmsg
argument_list|(
literal|"%s %s record not found"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** DECODE_ERROR -- Convert nameserver error code to error message ** -------------------------------------------------------------- ** **	Returns: **		Pointer to appropriate error message. */
end_comment

begin_function
name|char
modifier|*
name|decode_error
parameter_list|(
name|error
parameter_list|)
name|input
name|int
name|error
decl_stmt|;
comment|/* error code from bp->rcode */
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|NOERROR
case|:
return|return
operator|(
literal|"no error"
operator|)
return|;
case|case
name|FORMERR
case|:
return|return
operator|(
literal|"format error"
operator|)
return|;
case|case
name|SERVFAIL
case|:
return|return
operator|(
literal|"server failed"
operator|)
return|;
case|case
name|NXDOMAIN
case|:
return|return
operator|(
literal|"non-existent domain"
operator|)
return|;
case|case
name|NOTIMP
case|:
return|return
operator|(
literal|"not implemented"
operator|)
return|;
case|case
name|REFUSED
case|:
return|return
operator|(
literal|"query refused"
operator|)
return|;
case|case
name|NOCHANGE
case|:
return|return
operator|(
literal|"no change"
operator|)
return|;
block|}
return|return
operator|(
literal|"unknown error"
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_STATUS -- Print result status after nameserver query ** ---------------------------------------------------------- ** **	Returns: **		None. ** **	Conditions: **		The size of the answer buffer must have been **		checked before to be of sufficient length, **		i.e. to contain at least the buffer header. */
end_comment

begin_function
name|void
name|print_status
parameter_list|(
name|answerbuf
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
block|{
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|ancount
decl_stmt|;
name|bool
name|failed
decl_stmt|;
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|failed
operator|=
operator|(
name|bp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|ancount
operator|==
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Query %s, %d answer%s%s, %sstatus: %s\n"
argument_list|,
name|failed
condition|?
literal|"failed"
else|:
literal|"done"
argument_list|,
name|ancount
argument_list|,
name|ancount
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|bp
operator|->
name|tc
condition|?
literal|" (truncated)"
else|:
literal|""
argument_list|,
name|bp
operator|->
name|aa
condition|?
literal|"authoritative "
else|:
literal|""
argument_list|,
name|decode_error
argument_list|(
operator|(
name|int
operator|)
name|bp
operator|->
name|rcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PR_ERROR -- Print error message about encountered inconsistencies ** ----------------------------------------------------------------- ** **	We are supposed to have an error condition which is fatal **	for normal continuation, and the message is always printed. ** **	Returns: **		None. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|pr_error
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" *** "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** PR_WARNING -- Print warning message about encountered inconsistencies ** --------------------------------------------------------------------- ** **	We are supposed to have an error condition which is non-fatal **	for normal continuation, and the message is suppressed in case **	quiet mode has been selected. ** **	Returns: **		None. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|pr_warning
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" !!! "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** WANT_RR -- Indicate whether the rr type matches the desired filter ** ------------------------------------------------------------------ ** **	Returns: **		TRUE if the resource record type matches the filter. **		FALSE otherwise. ** **	In regular mode, the querytype is used to formulate the query, **	and the filter is set to T_ANY to filter out any response. **	In listmode, we get everything, so the filter is set to the **	querytype to filter out the proper responses. **	Note that T_NONE is the default querytype in listmode. */
end_comment

begin_function
name|bool
name|want_rr
parameter_list|(
name|type
parameter_list|,
name|filter
parameter_list|)
name|input
name|int
name|type
decl_stmt|;
comment|/* resource record type */
name|input
name|int
name|filter
decl_stmt|;
comment|/* type of records we want to see */
block|{
if|if
condition|(
name|type
operator|==
name|filter
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|T_ANY
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|T_NONE
operator|&&
operator|(
name|type
operator|==
name|T_A
operator|||
name|type
operator|==
name|T_NS
operator|||
name|type
operator|==
name|T_PTR
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|T_MAILB
operator|&&
operator|(
name|type
operator|==
name|T_MB
operator|||
name|type
operator|==
name|T_MR
operator|||
name|type
operator|==
name|T_MG
operator|||
name|type
operator|==
name|T_MINFO
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|T_MAILA
operator|&&
operator|(
name|type
operator|==
name|T_MD
operator|||
name|type
operator|==
name|T_MF
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** INDOMAIN -- Check whether a name belongs to a domain ** ---------------------------------------------------- ** **	Returns: **		TRUE if the given name lies anywhere in the domain, or **		if the given name is the same as the domain and may be so. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|indomain
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|,
name|equal
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name under consideration */
name|input
name|char
modifier|*
name|domain
decl_stmt|;
comment|/* the name of the domain */
name|input
name|bool
name|equal
decl_stmt|;
comment|/* set if name may be same as domain */
block|{
specifier|register
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|equal
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|dot
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sameword
argument_list|(
name|dot
operator|+
literal|1
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|dot
operator|=
name|index
argument_list|(
name|dot
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** SAMEDOMAIN -- Check whether a name belongs to a domain ** ------------------------------------------------------ ** **	Returns: **		TRUE if the given name lies directly in the domain, or **		if the given name is the same as the domain and may be so. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|samedomain
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|,
name|equal
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name under consideration */
name|input
name|char
modifier|*
name|domain
decl_stmt|;
comment|/* the name of the domain */
name|input
name|bool
name|equal
decl_stmt|;
comment|/* set if name may be same as domain */
block|{
specifier|register
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|equal
operator|)
return|;
name|dot
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|NULL
condition|)
return|return
operator|(
name|sameword
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|dot
operator|+
literal|1
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GLUERECORD -- Check whether a name is a glue record ** --------------------------------------------------- ** **	Returns: **		TRUE is this is a glue record. **		FALSE otherwise. ** **	The name is supposed to be the name of an address record. **	If it lies directly in the given domain, it is considered **	an ordinary host within that domain, and not a glue record. **	If it does not belong to the given domain at all, is it **	here considered to be a glue record. **	If it lies in the given domain, but not directly, it is **	considered a glue record if it belongs to any of the known **	subdomains of the given domain. **	In the root domain itself are no hosts, only glue records. */
end_comment

begin_function
name|bool
name|gluerecord
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|,
name|zone
parameter_list|,
name|nzones
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name under consideration */
name|input
name|char
modifier|*
name|domain
decl_stmt|;
comment|/* name of domain being processed */
name|input
name|char
modifier|*
name|zone
index|[]
decl_stmt|;
comment|/* list of known subdomains */
name|input
name|int
name|nzones
decl_stmt|;
comment|/* number of known subdomains */
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|samedomain
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|indomain
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nzones
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|indomain
argument_list|(
name|name
argument_list|,
name|zone
index|[
name|n
index|]
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PR_TYPE -- Return name of resource record type ** ---------------------------------------------- ** **	Returns: **		Pointer to name of resource record type. */
end_comment

begin_function
name|char
modifier|*
name|pr_type
parameter_list|(
name|type
parameter_list|)
name|input
name|int
name|type
decl_stmt|;
comment|/* resource record type */
block|{
specifier|static
name|char
name|nbuf
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
return|return
operator|(
literal|"A"
operator|)
return|;
comment|/* internet address */
case|case
name|T_NS
case|:
return|return
operator|(
literal|"NS"
operator|)
return|;
comment|/* authoritative server */
case|case
name|T_MD
case|:
return|return
operator|(
literal|"MD"
operator|)
return|;
comment|/* mail destination */
case|case
name|T_MF
case|:
return|return
operator|(
literal|"MF"
operator|)
return|;
comment|/* mail forwarder */
case|case
name|T_CNAME
case|:
return|return
operator|(
literal|"CNAME"
operator|)
return|;
comment|/* canonical name */
case|case
name|T_SOA
case|:
return|return
operator|(
literal|"SOA"
operator|)
return|;
comment|/* start of auth zone */
case|case
name|T_MB
case|:
return|return
operator|(
literal|"MB"
operator|)
return|;
comment|/* mailbox domain name */
case|case
name|T_MG
case|:
return|return
operator|(
literal|"MG"
operator|)
return|;
comment|/* mail group member */
case|case
name|T_MR
case|:
return|return
operator|(
literal|"MR"
operator|)
return|;
comment|/* mail rename name */
case|case
name|T_NULL
case|:
return|return
operator|(
literal|"NULL"
operator|)
return|;
comment|/* null resource record */
case|case
name|T_WKS
case|:
return|return
operator|(
literal|"WKS"
operator|)
return|;
comment|/* well known service */
case|case
name|T_PTR
case|:
return|return
operator|(
literal|"PTR"
operator|)
return|;
comment|/* domain name pointer */
case|case
name|T_HINFO
case|:
return|return
operator|(
literal|"HINFO"
operator|)
return|;
comment|/* host information */
case|case
name|T_MINFO
case|:
return|return
operator|(
literal|"MINFO"
operator|)
return|;
comment|/* mailbox information */
case|case
name|T_MX
case|:
return|return
operator|(
literal|"MX"
operator|)
return|;
comment|/* mail routing info */
case|case
name|T_TXT
case|:
return|return
operator|(
literal|"TXT"
operator|)
return|;
comment|/* descriptive text */
case|case
name|T_RP
case|:
return|return
operator|(
literal|"RP"
operator|)
return|;
comment|/* responsible person */
case|case
name|T_AFSDB
case|:
return|return
operator|(
literal|"AFSDB"
operator|)
return|;
comment|/* afs database location */
case|case
name|T_X25
case|:
return|return
operator|(
literal|"X25"
operator|)
return|;
comment|/* x25 address */
case|case
name|T_ISDN
case|:
return|return
operator|(
literal|"ISDN"
operator|)
return|;
comment|/* isdn address */
case|case
name|T_RT
case|:
return|return
operator|(
literal|"RT"
operator|)
return|;
comment|/* route through host */
case|case
name|T_NSAP
case|:
return|return
operator|(
literal|"NSAP"
operator|)
return|;
comment|/* nsap address */
case|case
name|T_NSAPPTR
case|:
return|return
operator|(
literal|"NSAP-PTR"
operator|)
return|;
comment|/* nsap pointer */
case|case
name|T_UINFO
case|:
return|return
operator|(
literal|"UINFO"
operator|)
return|;
comment|/* user information */
case|case
name|T_UID
case|:
return|return
operator|(
literal|"UID"
operator|)
return|;
comment|/* user ident */
case|case
name|T_GID
case|:
return|return
operator|(
literal|"GID"
operator|)
return|;
comment|/* group ident */
case|case
name|T_UNSPEC
case|:
return|return
operator|(
literal|"UNSPEC"
operator|)
return|;
comment|/* unspecified binary data */
case|case
name|T_AXFR
case|:
return|return
operator|(
literal|"AXFR"
operator|)
return|;
comment|/* zone transfer */
case|case
name|T_MAILB
case|:
return|return
operator|(
literal|"MAILB"
operator|)
return|;
comment|/* matches MB/MR/MG/MINFO */
case|case
name|T_MAILA
case|:
return|return
operator|(
literal|"MAILA"
operator|)
return|;
comment|/* matches MD/MF */
case|case
name|T_ANY
case|:
return|return
operator|(
literal|"ANY"
operator|)
return|;
comment|/* matches any type */
case|case
name|T_NONE
case|:
return|return
operator|(
literal|"resource"
operator|)
return|;
comment|/* not yet determined */
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|nbuf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PR_CLASS -- Return name of resource record class ** ------------------------------------------------ ** **	Returns: **		Pointer to name of resource record class. */
end_comment

begin_function
name|char
modifier|*
name|pr_class
parameter_list|(
name|class
parameter_list|)
name|input
name|int
name|class
decl_stmt|;
comment|/* resource record class */
block|{
specifier|static
name|char
name|nbuf
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
return|return
operator|(
literal|"IN"
operator|)
return|;
comment|/* internet */
case|case
name|C_CHAOS
case|:
return|return
operator|(
literal|"CHAOS"
operator|)
return|;
comment|/* chaosnet */
case|case
name|C_HS
case|:
return|return
operator|(
literal|"HS"
operator|)
return|;
comment|/* hesiod */
case|case
name|C_ANY
case|:
return|return
operator|(
literal|"ANY"
operator|)
return|;
comment|/* any class */
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%d"
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
operator|(
name|nbuf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** EXPAND -- Expand compressed domain name in a recource record ** ------------------------------------------------------------ ** **	Returns: **		Number of bytes advanced in answer buffer. **		-1 if there was a format error. */
end_comment

begin_function
name|int
name|expand
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|cp
parameter_list|,
name|msg
parameter_list|,
name|eom
parameter_list|,
name|namebuf
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of resource record */
name|input
name|int
name|type
decl_stmt|;
comment|/* type of resource record */
name|input
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in answer buf */
name|input
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_comment
comment|/* begin and end of answer buf */
end_comment

begin_decl_stmt
name|output
name|char
modifier|*
name|namebuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of buf to expand name in */
end_comment

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|namebuf
argument_list|,
name|MAXDNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|pr_error
argument_list|(
literal|"expand error in %s record for %s, offset = %d"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
operator|(
name|cp
operator|-
name|msg
operator|)
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|namebuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|namebuf
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|namebuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_SIZE -- Check whether resource record is of sufficient length ** ------------------------------------------------------------------- ** **	Returns: **		Requested size if current record is long enough. **		-1 if current record does not have this many bytes. ** **	Note that HINFO records are very often incomplete since only **	one of the two data fields has been filled in and the second **	field is missing. So we generate only a warning message. */
end_comment

begin_function
name|int
name|check_size
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|cp
parameter_list|,
name|msg
parameter_list|,
name|eor
parameter_list|,
name|size
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of resource record */
name|input
name|int
name|type
decl_stmt|;
comment|/* type of resource record */
name|input
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in answer buf */
name|input
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eor
decl_stmt|;
end_function

begin_comment
comment|/* begin and end of answer buf */
end_comment

begin_decl_stmt
name|input
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* required record size remaining */
end_comment

begin_block
block|{
if|if
condition|(
name|cp
operator|+
name|size
operator|>
name|eor
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|T_HINFO
condition|)
name|pr_error
argument_list|(
literal|"incomplete %s record for %s, offset = %d"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
operator|(
name|cp
operator|-
name|msg
operator|)
argument_list|)
expr_stmt|;
else|else
name|pr_warning
argument_list|(
literal|"incomplete %s record for %s, offset = %d"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
operator|(
name|cp
operator|-
name|msg
operator|)
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** XALLOC -- Allocate or reallocate additional memory ** -------------------------------------------------- ** **	Returns: **		Pointer to (re)allocated buffer space. **		Aborts if the requested memory could not be obtained. */
end_comment

begin_function
name|ptr_t
modifier|*
name|xalloc
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
specifier|register
name|ptr_t
modifier|*
name|buf
decl_stmt|;
comment|/* current start of buffer space */
name|input
name|int
name|size
decl_stmt|;
comment|/* number of bytes to allocate */
block|{
specifier|extern
name|ptr_t
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|extern
name|ptr_t
modifier|*
name|realloc
parameter_list|()
function_decl|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|buf
operator|=
name|malloc
argument_list|(
operator|(
name|siz_t
operator|)
name|size
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
operator|(
name|siz_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|errmsg
argument_list|(
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

