begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cut.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains function which manipulate the cut buffers. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_if
if|#
directive|if
name|TURBOC
end_if

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_comment
comment|/* needed for getpid */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TOS
end_if

begin_include
include|#
directive|include
file|<osbind.h>
end_include

begin_define
define|#
directive|define
name|rename
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|Frename(0,a,b)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NANNONS
value|9
end_define

begin_comment
comment|/* number of annonymous buffers */
end_comment

begin_struct
specifier|static
struct|struct
name|cutbuf
block|{
name|short
modifier|*
name|phys
decl_stmt|;
comment|/* pointer to an array of #s of BLKs containing text */
name|int
name|nblks
decl_stmt|;
comment|/* number of blocks in phys[] array */
name|int
name|start
decl_stmt|;
comment|/* offset into first block of start of cut */
name|int
name|end
decl_stmt|;
comment|/* offset into last block of end of cut */
name|int
name|fd
decl_stmt|;
comment|/* fd of tmp file, or -1 to use tmpfd */
name|char
name|lnmode
decl_stmt|;
comment|/* boolean: line-mode cut? (as opposed to char-mode) */
block|}
name|named
index|[
literal|27
index|]
struct|,
comment|/* cut buffers "a through "z and ". */
name|annon
index|[
name|NANNONS
index|]
struct|;
end_struct

begin_comment
comment|/* annonymous cut buffers */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cbname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name chosen for next cut/paste operation */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_RECYCLE
end_ifndef

begin_comment
comment|/* This function builds a list of all blocks needed in the current tmp file  * for the contents of cut buffers.  * !!! WARNING: if you have more than ~450000 bytes of text in all of the  * cut buffers, then this will fail disastrously, because buffer overflow  * is *not* allowed for.  */
end_comment

begin_function
name|int
name|cutneeds
parameter_list|(
name|need
parameter_list|)
name|BLK
modifier|*
name|need
decl_stmt|;
comment|/* this is where we deposit the list */
block|{
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
comment|/* used to count through cut buffers */
name|int
name|i
decl_stmt|;
comment|/* used to count through blocks of a cut buffer */
name|int
name|n
decl_stmt|;
comment|/* total number of blocks in list */
name|n
operator|=
literal|0
expr_stmt|;
comment|/* first the named buffers... */
for|for
control|(
name|cb
operator|=
name|named
init|;
name|cb
operator|<
operator|&
name|named
index|[
literal|27
index|]
condition|;
name|cb
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|fd
operator|>
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|cb
operator|->
name|nblks
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|need
operator|->
name|n
index|[
name|n
operator|++
index|]
operator|=
name|cb
operator|->
name|phys
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* then the anonymous buffers */
for|for
control|(
name|cb
operator|=
name|annon
init|;
name|cb
operator|<
operator|&
name|annon
index|[
name|NANNONS
index|]
condition|;
name|cb
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|fd
operator|>
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|cb
operator|->
name|nblks
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|need
operator|->
name|n
index|[
name|n
operator|++
index|]
operator|=
name|cb
operator|->
name|phys
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function frees a cut buffer */
end_comment

begin_function
specifier|static
name|void
name|cutfree
parameter_list|(
name|buf
parameter_list|)
name|struct
name|cutbuf
modifier|*
name|buf
decl_stmt|;
block|{
name|char
name|cutfname
index|[
literal|50
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* return immediately if the buffer is already empty */
if|if
condition|(
name|buf
operator|->
name|nblks
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* else free up stuff */
name|buf
operator|->
name|nblks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|buf
operator|->
name|phys
condition|)
name|msg
argument_list|(
literal|"cutfree() tried to free an NULL buf->phys pointer."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|->
name|phys
argument_list|)
expr_stmt|;
comment|/* see if anybody else needs this tmp file */
if|if
condition|(
name|buf
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|27
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|named
index|[
name|i
index|]
operator|.
name|nblks
operator|>
literal|0
operator|&&
name|named
index|[
name|i
index|]
operator|.
name|fd
operator|==
name|buf
operator|->
name|fd
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/* if nobody else needs it, then discard the tmp file */
if|if
condition|(
name|buf
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|i
operator|==
literal|27
condition|)
block|{
name|close
argument_list|(
name|buf
operator|->
name|fd
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|strcpy
argument_list|(
name|cutfname
argument_list|,
name|o_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|cutfname
argument_list|)
operator|)
operator|&&
operator|!
name|strchr
argument_list|(
literal|":/\\"
argument_list|,
name|cutfname
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cutfname
index|[
name|i
operator|++
index|]
operator|=
name|SLASH
expr_stmt|;
name|sprintf
argument_list|(
name|cutfname
operator|+
name|i
argument_list|,
name|CUTNAME
operator|+
literal|3
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|buf
operator|->
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|cutfname
argument_list|,
name|CUTNAME
argument_list|,
name|o_directory
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|buf
operator|->
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unlink
argument_list|(
name|cutfname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called when we are about to abort a tmp file.  If any  * cut buffers still need the file, then a copy of the file should be  * created for use by the cut buffers.  *  * To minimize the number of extra files lying around, only named cut buffers  * are preserved in a file switch; the annonymous buffers just go away.  */
end_comment

begin_function
name|void
name|cutswitch
parameter_list|(
name|tmpname
parameter_list|)
name|char
modifier|*
name|tmpname
decl_stmt|;
comment|/* name of the tmp file */
block|{
name|char
name|cutfname
index|[
literal|50
index|]
decl_stmt|;
comment|/* used to build a new name for the tmp file */
name|int
name|fd
decl_stmt|;
comment|/* a new fd for the current tmp file */
name|int
name|i
decl_stmt|;
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|int
name|j
decl_stmt|;
endif|#
directive|endif
comment|/* discard all annonymous cut buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NANNONS
condition|;
name|i
operator|++
control|)
block|{
name|cutfree
argument_list|(
operator|&
name|annon
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* find the first named buffer that uses this tmp file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|27
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|named
index|[
name|i
index|]
operator|.
name|nblks
operator|>
literal|0
operator|&&
name|named
index|[
name|i
index|]
operator|.
name|fd
operator|<
literal|0
condition|)
block|{
break|break;
block|}
block|}
comment|/* if none of them use this tmp file, then we're done */
if|if
condition|(
name|i
operator|==
literal|27
condition|)
block|{
return|return;
block|}
comment|/* else we'll need this file and an fd a little longer */
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|strcpy
argument_list|(
name|cutfname
argument_list|,
name|o_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|strlen
argument_list|(
name|cutfname
argument_list|)
operator|)
operator|&&
operator|!
name|strchr
argument_list|(
literal|":/\\"
argument_list|,
name|cutfname
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cutfname
index|[
name|j
operator|++
index|]
operator|=
name|SLASH
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|tmpname
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cutfname
operator|+
name|j
argument_list|,
name|CUTNAME
operator|+
literal|3
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|tmpname
argument_list|,
name|cutfname
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|cutfname
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
name|tmpfd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* we'll try to close this in tmp.c, but who cares? */
else|#
directive|else
name|fd
operator|=
name|dup
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|sprintf
argument_list|(
name|cutfname
argument_list|,
name|CUTNAME
argument_list|,
literal|""
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
argument_list|(
name|tmpname
argument_list|,
operator|&
name|cutfname
index|[
literal|1
index|]
argument_list|)
condition|)
comment|/* skip slash */
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|cutfname
argument_list|,
name|CUTNAME
argument_list|,
name|o_directory
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|link
argument_list|(
name|tmpname
argument_list|,
name|cutfname
argument_list|)
operator|||
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* have all cut buffers use the new fd instead */
for|for
control|(
init|;
name|i
operator|<
literal|27
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|named
index|[
name|i
index|]
operator|.
name|nblks
operator|>
literal|0
operator|&&
name|named
index|[
name|i
index|]
operator|.
name|fd
operator|<
literal|0
condition|)
block|{
name|named
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function should be called just before termination of vi */
end_comment

begin_function
name|void
name|cutend
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* free all named cut buffers, since they might be forcing an older 	 * tmp file to be retained. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|27
condition|;
name|i
operator|++
control|)
block|{
name|cutfree
argument_list|(
operator|&
name|named
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is used to select the cut buffer to be used next */
end_comment

begin_function
name|void
name|cutname
parameter_list|(
name|name
parameter_list|)
name|int
name|name
decl_stmt|;
comment|/* a single character */
block|{
name|cbname
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function copies a selected segment of text to a cut buffer */
end_comment

begin_function
name|void
name|cut
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|MARK
name|from
decl_stmt|;
comment|/* start of text to cut */
name|MARK
name|to
decl_stmt|;
comment|/* end of text to cut */
block|{
name|int
name|first
decl_stmt|;
comment|/* logical number of first block in cut */
name|int
name|last
decl_stmt|;
comment|/* logical number of last block used in cut */
name|long
name|line
decl_stmt|;
comment|/* a line number */
name|int
name|lnmode
decl_stmt|;
comment|/* boolean: will this be a line-mode cut? */
name|MARK
name|delthru
decl_stmt|;
comment|/* end of text temporarily inserted for apnd */
name|REG
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
name|REG
name|long
name|l
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|blkc
decl_stmt|;
comment|/* detect whether this must be a line-mode cut or char-mode cut */
if|if
condition|(
name|markidx
argument_list|(
name|from
argument_list|)
operator|==
literal|0
operator|&&
name|markidx
argument_list|(
name|to
argument_list|)
operator|==
literal|0
condition|)
name|lnmode
operator|=
name|TRUE
expr_stmt|;
else|else
name|lnmode
operator|=
name|FALSE
expr_stmt|;
comment|/* by default, we don't "delthru" anything */
name|delthru
operator|=
name|MARK_UNSET
expr_stmt|;
comment|/* decide which cut buffer to use */
if|if
condition|(
operator|!
name|cbname
condition|)
block|{
comment|/* free up the last annonymous cut buffer */
name|cutfree
argument_list|(
operator|&
name|annon
index|[
name|NANNONS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* shift the annonymous cut buffers */
for|for
control|(
name|i
operator|=
name|NANNONS
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|annon
index|[
name|i
index|]
operator|=
name|annon
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* use the first annonymous cut buffer */
name|cb
operator|=
name|annon
expr_stmt|;
name|cb
operator|->
name|nblks
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbname
operator|>=
literal|'a'
operator|&&
name|cbname
operator|<=
literal|'z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|cbname
operator|-
literal|'a'
index|]
expr_stmt|;
name|cutfree
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
elseif|else
if|if
condition|(
name|cbname
operator|>=
literal|'A'
operator|&&
name|cbname
operator|<=
literal|'Z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|cbname
operator|-
literal|'A'
index|]
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|nblks
operator|>
literal|0
condition|)
block|{
comment|/* resolve linemode/charmode differences */
if|if
condition|(
operator|!
name|lnmode
operator|&&
name|cb
operator|->
name|lnmode
condition|)
block|{
name|from
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|markidx
argument_list|(
name|to
argument_list|)
operator|!=
literal|0
operator|||
name|to
operator|==
name|from
condition|)
block|{
name|to
operator|=
name|to
operator|+
name|BLKSIZE
operator|-
name|markidx
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|lnmode
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* insert the old cut-buffer before the new text */
name|mark
index|[
literal|28
index|]
operator|=
name|to
expr_stmt|;
name|delthru
operator|=
name|paste
argument_list|(
name|from
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|delthru
operator|==
name|MARK_UNSET
condition|)
block|{
return|return;
block|}
name|delthru
operator|++
expr_stmt|;
name|to
operator|=
name|mark
index|[
literal|28
index|]
expr_stmt|;
block|}
name|cutfree
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
elseif|else
if|if
condition|(
name|cbname
operator|==
literal|'.'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
literal|26
index|]
expr_stmt|;
name|cutfree
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"Invalid cut buffer name: \"%c"
argument_list|,
name|cbname
argument_list|)
expr_stmt|;
name|cbname
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|cbname
operator|=
literal|'\0'
expr_stmt|;
name|cb
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* detect whether we're doing a line mode cut */
name|cb
operator|->
name|lnmode
operator|=
name|lnmode
expr_stmt|;
comment|/* ---------- */
comment|/* Reporting... */
if|if
condition|(
name|markidx
argument_list|(
name|from
argument_list|)
operator|==
literal|0
operator|&&
name|markidx
argument_list|(
name|to
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rptlines
operator|=
name|markline
argument_list|(
name|to
argument_list|)
operator|-
name|markline
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|rptlabel
operator|=
literal|"yanked"
expr_stmt|;
block|}
comment|/* ---------- */
comment|/* make sure each block has a physical disk address */
name|blksync
argument_list|()
expr_stmt|;
comment|/* find the first block in the cut */
name|line
operator|=
name|markline
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
name|first
operator|=
literal|1
init|;
name|line
operator|>
name|lnum
index|[
name|first
index|]
condition|;
name|first
operator|++
control|)
block|{ 	}
comment|/* fetch text of the block containing that line */
name|blkc
operator|=
name|scan
operator|=
name|blkget
argument_list|(
name|first
argument_list|)
operator|->
name|c
expr_stmt|;
comment|/* find the mark in the block */
for|for
control|(
name|l
operator|=
name|lnum
index|[
name|first
operator|-
literal|1
index|]
init|;
operator|++
name|l
operator|<
name|line
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|scan
operator|++
operator|!=
literal|'\n'
condition|)
block|{ 		}
block|}
name|scan
operator|+=
name|markidx
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* remember the offset of the start */
name|cb
operator|->
name|start
operator|=
name|scan
operator|-
name|blkc
expr_stmt|;
comment|/* ---------- */
comment|/* find the last block in the cut */
name|line
operator|=
name|markline
argument_list|(
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|last
operator|=
name|first
init|;
name|line
operator|>
name|lnum
index|[
name|last
index|]
condition|;
name|last
operator|++
control|)
block|{ 	}
comment|/* fetch text of the block containing that line */
if|if
condition|(
name|last
operator|!=
name|first
condition|)
block|{
name|blkc
operator|=
name|scan
operator|=
name|blkget
argument_list|(
name|last
argument_list|)
operator|->
name|c
expr_stmt|;
block|}
else|else
block|{
name|scan
operator|=
name|blkc
expr_stmt|;
block|}
comment|/* find the mark in the block */
for|for
control|(
name|l
operator|=
name|lnum
index|[
name|last
operator|-
literal|1
index|]
init|;
operator|++
name|l
operator|<
name|line
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|scan
operator|++
operator|!=
literal|'\n'
condition|)
block|{ 		}
block|}
if|if
condition|(
name|markline
argument_list|(
name|to
argument_list|)
operator|<=
name|nlines
condition|)
block|{
name|scan
operator|+=
name|markidx
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* remember the offset of the end */
name|cb
operator|->
name|end
operator|=
name|scan
operator|-
name|blkc
expr_stmt|;
comment|/* ------- */
comment|/* remember the physical block numbers of all included blocks */
name|cb
operator|->
name|nblks
operator|=
name|last
operator|-
name|first
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|end
operator|>
literal|0
condition|)
block|{
name|cb
operator|->
name|nblks
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|lint
name|cb
operator|->
name|phys
operator|=
operator|(
name|short
operator|*
operator|)
literal|0
expr_stmt|;
else|#
directive|else
name|cb
operator|->
name|phys
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|cb
operator|->
name|nblks
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|nblks
condition|;
name|i
operator|++
control|)
block|{
name|cb
operator|->
name|phys
index|[
name|i
index|]
operator|=
name|hdr
operator|.
name|n
index|[
name|first
operator|++
index|]
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* if we temporarily inserted text for appending, then delete that 	 * text now -- before the user sees it. 	 */
if|if
condition|(
name|delthru
condition|)
block|{
name|line
operator|=
name|rptlines
expr_stmt|;
name|delete
argument_list|(
name|from
argument_list|,
name|delthru
argument_list|)
expr_stmt|;
name|rptlines
operator|=
name|line
expr_stmt|;
name|rptlabel
operator|=
literal|"yanked"
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
block|}
end_function

begin_function
specifier|static
name|void
name|readcutblk
parameter_list|(
name|cb
parameter_list|,
name|blkno
parameter_list|)
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
name|int
name|blkno
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
comment|/* either tmpfd or cb->fd */
comment|/* decide which fd to use */
if|if
condition|(
name|cb
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
name|fd
operator|=
name|cb
operator|->
name|fd
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|=
name|tmpfd
expr_stmt|;
block|}
comment|/* get the block */
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
name|cb
operator|->
name|phys
index|[
name|blkno
index|]
operator|*
operator|(
name|long
operator|)
name|BLKSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
operator|(
name|unsigned
operator|)
name|BLKSIZE
argument_list|)
operator|!=
name|BLKSIZE
condition|)
block|{
name|msg
argument_list|(
literal|"Error reading back from tmp file for pasting!"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function inserts text from a cut buffer, and returns the MARK where  * insertion ended.  Return MARK_UNSET on errors.  */
end_comment

begin_function
name|MARK
name|paste
parameter_list|(
name|at
parameter_list|,
name|after
parameter_list|,
name|retend
parameter_list|)
name|MARK
name|at
decl_stmt|;
comment|/* where to insert the text */
name|int
name|after
decl_stmt|;
comment|/* boolean: insert after mark? (rather than before) */
name|int
name|retend
decl_stmt|;
comment|/* boolean: return end of text? (rather than start) */
block|{
name|REG
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
comment|/* decide which cut buffer to use */
if|if
condition|(
name|cbname
operator|>=
literal|'A'
operator|&&
name|cbname
operator|<=
literal|'Z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|cbname
operator|-
literal|'A'
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbname
operator|>=
literal|'a'
operator|&&
name|cbname
operator|<=
literal|'z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|cbname
operator|-
literal|'a'
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbname
operator|>=
literal|'1'
operator|&&
name|cbname
operator|<=
literal|'9'
condition|)
block|{
name|cb
operator|=
operator|&
name|annon
index|[
name|cbname
operator|-
literal|'1'
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbname
operator|==
literal|'.'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
literal|26
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cbname
condition|)
block|{
name|cb
operator|=
name|annon
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"Invalid cut buffer name: \"%c"
argument_list|,
name|cbname
argument_list|)
expr_stmt|;
name|cbname
operator|=
literal|'\0'
expr_stmt|;
return|return
name|MARK_UNSET
return|;
block|}
comment|/* make sure it isn't empty */
if|if
condition|(
name|cb
operator|->
name|nblks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cbname
condition|)
name|msg
argument_list|(
literal|"Cut buffer \"%c is empty"
argument_list|,
name|cbname
argument_list|)
expr_stmt|;
else|else
name|msg
argument_list|(
literal|"Cut buffer is empty"
argument_list|)
expr_stmt|;
name|cbname
operator|=
literal|'\0'
expr_stmt|;
return|return
name|MARK_UNSET
return|;
block|}
name|cbname
operator|=
literal|'\0'
expr_stmt|;
comment|/* adjust the insertion MARK for "after" and line-mode cuts */
if|if
condition|(
name|cb
operator|->
name|lnmode
condition|)
block|{
name|at
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|at
operator|+=
name|BLKSIZE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|after
condition|)
block|{
comment|/* careful! if markidx(at) == 0 we might be pasting into an 		 * empty line -- so we can't blindly increment "at". 		 */
if|if
condition|(
name|markidx
argument_list|(
name|at
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pfetch
argument_list|(
name|markline
argument_list|(
name|at
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
literal|0
condition|)
block|{
name|at
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|at
operator|++
expr_stmt|;
block|}
block|}
comment|/* put a copy of the "at" mark in the mark[] array, so it stays in 	 * sync with changes made via add(). 	 */
name|mark
index|[
literal|27
index|]
operator|=
name|at
expr_stmt|;
comment|/* simple one-block paste? */
if|if
condition|(
name|cb
operator|->
name|nblks
operator|==
literal|1
condition|)
block|{
comment|/* get the block */
name|readcutblk
argument_list|(
name|cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* isolate the text we need within it */
if|if
condition|(
name|cb
operator|->
name|end
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* insert it */
name|ChangeText
block|{
name|add
argument_list|(
name|at
argument_list|,
operator|&
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|start
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* multi-block paste */
name|ChangeText
block|{
name|i
operator|=
name|cb
operator|->
name|nblks
operator|-
literal|1
expr_stmt|;
comment|/* add text from the last block first */
if|if
condition|(
name|cb
operator|->
name|end
operator|>
literal|0
condition|)
block|{
name|readcutblk
argument_list|(
name|cb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|add
argument_list|(
name|at
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
comment|/* add intervening blocks */
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|readcutblk
argument_list|(
name|cb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|at
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
comment|/* add text from the first cut block */
name|readcutblk
argument_list|(
name|cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|at
argument_list|,
operator|&
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|start
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reporting... */
name|rptlines
operator|=
name|markline
argument_list|(
name|mark
index|[
literal|27
index|]
argument_list|)
operator|-
name|markline
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|rptlabel
operator|=
literal|"pasted"
expr_stmt|;
comment|/* return the mark at the beginning/end of inserted text */
if|if
condition|(
name|retend
condition|)
block|{
return|return
name|mark
index|[
literal|27
index|]
operator|-
literal|1L
return|;
block|}
return|return
name|at
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_AT
end_ifndef

begin_comment
comment|/* This function copies characters from a cut buffer into a string.  * It returns the number of characters in the cut buffer.  If the cut  * buffer is too large to fit in the string (i.e. if cb2str() returns  * a number>= size) then the characters will not have been copied.  * It returns 0 if the cut buffer is empty, and -1 for invalid cut buffers.  */
end_comment

begin_function
name|int
name|cb2str
parameter_list|(
name|name
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|int
name|name
decl_stmt|;
comment|/* the name of a cut-buffer to get: a-z only! */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* where to put the string */
name|unsigned
name|size
decl_stmt|;
comment|/* size of buf */
block|{
name|REG
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
name|REG
name|char
modifier|*
name|src
decl_stmt|;
name|REG
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* decide which cut buffer to use */
if|if
condition|(
name|name
operator|>=
literal|'a'
operator|&&
name|name
operator|<=
literal|'z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|name
operator|-
literal|'a'
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* if the buffer is empty, return 0 */
if|if
condition|(
name|cb
operator|->
name|nblks
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* !!! if not a single-block cut, then fail */
if|if
condition|(
name|cb
operator|->
name|nblks
operator|!=
literal|1
condition|)
block|{
return|return
name|size
return|;
block|}
comment|/* if too big, return the size now, without doing anything */
if|if
condition|(
name|cb
operator|->
name|end
operator|-
name|cb
operator|->
name|start
operator|>=
name|size
condition|)
block|{
return|return
name|cb
operator|->
name|end
operator|-
name|cb
operator|->
name|start
return|;
block|}
comment|/* get the block */
name|readcutblk
argument_list|(
name|cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* isolate the string within that blk */
if|if
condition|(
name|cb
operator|->
name|start
operator|==
literal|0
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|dest
operator|=
name|tmpblk
operator|.
name|c
operator|,
name|src
operator|=
name|dest
operator|+
name|cb
operator|->
name|start
init|;
name|src
operator|<
name|tmpblk
operator|.
name|c
operator|+
name|cb
operator|->
name|end
condition|;
control|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* copy the string into the buffer */
if|if
condition|(
name|buf
operator|!=
name|tmpblk
operator|.
name|c
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* return the length */
return|return
name|cb
operator|->
name|end
operator|-
name|cb
operator|->
name|start
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

