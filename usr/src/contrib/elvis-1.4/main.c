begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the main() function of vi */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_extern
extern|extern		trapint(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* defined below */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_expr_stmt
specifier|static
name|init_digraphs
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|tag
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|err
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|char
name|firstarg
index|[
literal|256
index|]
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|firstarg
decl_stmt|;
endif|#
directive|endif
comment|/* set mode to MODE_VI or MODE_EX depending on program name */
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
comment|/* "ex" */
name|mode
operator|=
name|MODE_EX
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* "view" */
name|mode
operator|=
name|MODE_VI
expr_stmt|;
operator|*
name|o_readonly
operator|=
name|TRUE
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
case|case
literal|'t'
case|:
comment|/* "edit" or "input" */
name|mode
operator|=
name|MODE_VI
expr_stmt|;
operator|*
name|o_inputmode
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* "vi" or "elvis" */
name|mode
operator|=
name|MODE_VI
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DEBUG
ifdef|#
directive|ifdef
name|SIGQUIT
comment|/* normally, we ignore SIGQUIT.  SIGINT is trapped later */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* temporarily ignore SIGINT */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* start curses */
name|initscr
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* initialize the options */
name|initopts
argument_list|()
expr_stmt|;
comment|/* map the arrow keys.  The KU,KD,KL,and KR variables correspond to 	 * the :ku=: (etc.) termcap capabilities.  The variables are defined 	 * as part of the curses package. 	 */
if|if
condition|(
name|has_KU
condition|)
name|mapkey
argument_list|(
name|has_KU
argument_list|,
literal|"k"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Up>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_KD
condition|)
name|mapkey
argument_list|(
name|has_KD
argument_list|,
literal|"j"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Down>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_KL
condition|)
name|mapkey
argument_list|(
name|has_KL
argument_list|,
literal|"h"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Left>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_KR
condition|)
name|mapkey
argument_list|(
name|has_KR
argument_list|,
literal|"l"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Right>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_HM
condition|)
name|mapkey
argument_list|(
name|has_HM
argument_list|,
literal|"^"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Home>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_EN
condition|)
name|mapkey
argument_list|(
name|has_EN
argument_list|,
literal|"$"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<End>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_PU
condition|)
name|mapkey
argument_list|(
name|has_PU
argument_list|,
literal|"\002"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<PgUp>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_PD
condition|)
name|mapkey
argument_list|(
name|has_PD
argument_list|,
literal|"\006"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<PgDn>"
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS
if|if
condition|(
operator|*
name|o_pcbios
condition|)
block|{
name|mapkey
argument_list|(
literal|"#R"
argument_list|,
literal|"i"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Insrt>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"#S"
argument_list|,
literal|"x"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Del>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"#s"
argument_list|,
literal|"B"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"^<left>"
argument_list|)
expr_stmt|;
name|mapkey
argument_list|(
literal|"#t"
argument_list|,
literal|"W"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"^<right>"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|ERASEKEY
operator|!=
literal|'\177'
condition|)
block|{
name|mapkey
argument_list|(
literal|"\177"
argument_list|,
literal|"x"
argument_list|,
name|WHEN_VICMD
operator||
name|WHEN_INMV
argument_list|,
literal|"<Del>"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|init_digraphs
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* NO_DIGRAPH */
comment|/* process any flags */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|==
literal|'-'
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'R'
case|:
comment|/* readonly */
operator|*
name|o_readonly
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* recover */
name|msg
argument_list|(
literal|"Use the `virec` program to recover lost files"
argument_list|)
expr_stmt|;
name|endmsgs
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* tag */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
name|tag
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
name|tag
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* vi mode */
name|mode
operator|=
name|MODE_VI
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ex mode */
name|mode
operator|=
name|MODE_EX
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
case|case
literal|'i'
case|:
comment|/* input mode */
operator|*
name|o_inputmode
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
case|case
literal|'m'
case|:
comment|/* use "errlist" as the errlist */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
name|err
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|argc
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|err
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|""
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|msg
argument_list|(
literal|"Ignoring unknown flag \"%s\""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if we were given an initial ex command, save it... */
if|if
condition|(
name|i
operator|<
name|argc
operator|&&
operator|*
name|argv
index|[
name|i
index|]
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
name|cmd
operator|=
name|argv
index|[
name|i
operator|++
index|]
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
literal|"$"
expr_stmt|;
comment|/* "vi + file" means start at EOF */
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* the remaining args are file names. */
name|nargs
operator|=
name|argc
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|MSDOS
operator|||
name|TOS
operator|)
name|firstarg
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|args
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|argc
operator|&&
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|<
sizeof|sizeof
name|args
condition|)
block|{
name|strcat
argument_list|(
name|args
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|args
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|!
operator|(
name|MSDOS
operator|||
name|TOS
operator|)
else|else
block|{
name|firstarg
operator|=
literal|""
expr_stmt|;
block|}
endif|#
directive|endif
name|argno
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|MSDOS
operator|||
name|TOS
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|args
argument_list|,
name|wildcard
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|nargs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|==
literal|' '
condition|)
block|{
name|nargs
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|&&
name|args
index|[
name|i
index|]
operator|!=
literal|' '
condition|;
name|i
operator|++
control|)
block|{
name|firstarg
index|[
name|i
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
block|}
name|firstarg
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|firstarg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* perform the .exrc files and EXINIT environment variable */
ifdef|#
directive|ifdef
name|SYSEXRC
name|doexrc
argument_list|(
name|SYSEXRC
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HMEXRC
name|str
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|sprintf
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"%s%c%s"
argument_list|,
name|str
argument_list|,
name|SLASH
argument_list|,
name|HMEXRC
argument_list|)
expr_stmt|;
name|doexrc
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|doexrc
argument_list|(
name|EXRC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXINIT
name|str
operator|=
name|getenv
argument_list|(
name|EXINIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|exstring
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* search for a tag (or an error) now, if desired */
name|blkinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|cmd_tag
argument_list|(
name|MARK_FIRST
argument_list|,
name|MARK_FIRST
argument_list|,
name|CMD_TAG
argument_list|,
literal|0
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_ERRLIST
elseif|else
if|if
condition|(
name|err
condition|)
block|{
name|cmd_errlist
argument_list|(
name|MARK_FIRST
argument_list|,
name|MARK_FIRST
argument_list|,
name|CMD_ERRLIST
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if no tag/err, or tag failed, then start with first arg */
if|if
condition|(
name|tmpfd
operator|<
literal|0
operator|&&
name|tmpstart
argument_list|(
name|firstarg
argument_list|)
operator|==
literal|0
operator|&&
operator|*
name|origname
condition|)
block|{
name|ChangeText
block|{ 		}
name|clrflag
argument_list|(
name|file
argument_list|,
name|MODIFIED
argument_list|)
expr_stmt|;
block|}
comment|/* now we do the immediate ex command that we noticed before */
if|if
condition|(
name|cmd
condition|)
block|{
name|doexcmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/* repeatedly call ex() or vi() (depending on the mode) until the 	 * mode is set to MODE_QUIT 	 */
while|while
condition|(
name|mode
operator|!=
name|MODE_QUIT
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
condition|)
block|{
comment|/* Maybe we just aborted a change? */
name|abortdo
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|TURBOC
name|signal
argument_list|(
name|SIGINT
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|trapint
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_VI
case|:
name|vi
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_EX
case|:
name|ex
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|msg
argument_list|(
literal|"mode = %d?"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE_QUIT
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* free up the cut buffers */
name|cutend
argument_list|()
expr_stmt|;
comment|/* end curses */
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
if|if
condition|(
name|has_CQ
condition|)
name|do_CQ
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|endmsgs
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|trapint
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|resume_curses
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|abortdo
argument_list|()
expr_stmt|;
if|#
directive|if
name|OSK
name|sigmask
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TURBO_C
name|signal
argument_list|(
name|signo
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|trapint
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|signo
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|longjmp
argument_list|(
name|jmpenv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_comment
comment|/* This stuff us used to build the default digraphs table. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digtable
index|[]
index|[
literal|4
index|]
init|=
block|{
if|#
directive|if
name|CS_IBMPC
literal|"C,\200"
block|,
literal|"u\"\1"
block|,
literal|"e'\2"
block|,
literal|"a^\3"
block|,
literal|"a\"\4"
block|,
literal|"a`\5"
block|,
literal|"a@\6"
block|,
literal|"c,\7"
block|,
literal|"e^\10"
block|,
literal|"e\"\211"
block|,
literal|"e`\12"
block|,
literal|"i\"\13"
block|,
literal|"i^\14"
block|,
literal|"i`\15"
block|,
literal|"A\"\16"
block|,
literal|"A@\17"
block|,
literal|"E'\20"
block|,
literal|"ae\21"
block|,
literal|"AE\22"
block|,
literal|"o^\23"
block|,
literal|"o\"\24"
block|,
literal|"o`\25"
block|,
literal|"u^\26"
block|,
literal|"u`\27"
block|,
literal|"y\"\30"
block|,
literal|"O\"\31"
block|,
literal|"U\"\32"
block|,
literal|"a'\240"
block|,
literal|"i'!"
block|,
literal|"o'\""
block|,
literal|"u'#"
block|,
literal|"n~$"
block|,
literal|"N~%"
block|,
literal|"a-&"
block|,
literal|"o-'"
block|,
literal|"~?("
block|,
literal|"~!-"
block|,
literal|"\"<."
block|,
literal|"\">/"
block|,
if|#
directive|if
name|CS_SPECIAL
literal|"2/+"
block|,
literal|"4/,"
block|,
literal|"^+;"
block|,
literal|"^q<"
block|,
literal|"^c="
block|,
literal|"^r>"
block|,
literal|"^t?"
block|,
literal|"pp]"
block|,
literal|"^^^"
block|,
literal|"oo_"
block|,
literal|"*a`"
block|,
literal|"*ba"
block|,
literal|"*pc"
block|,
literal|"*Sd"
block|,
literal|"*se"
block|,
literal|"*uf"
block|,
literal|"*tg"
block|,
literal|"*Ph"
block|,
literal|"*Ti"
block|,
literal|"*Oj"
block|,
literal|"*dk"
block|,
literal|"*Hl"
block|,
literal|"*hm"
block|,
literal|"*En"
block|,
literal|"*No"
block|,
literal|"eqp"
block|,
literal|"pmq"
block|,
literal|"ger"
block|,
literal|"les"
block|,
literal|"*It"
block|,
literal|"*iu"
block|,
literal|"*/v"
block|,
literal|"*=w"
block|,
literal|"sq{"
block|,
literal|"^n|"
block|,
literal|"^2}"
block|,
literal|"^3~"
block|,
literal|"^_\377"
block|,
endif|#
directive|endif
comment|/* CS_SPECIAL */
endif|#
directive|endif
comment|/* CS_IBMPC */
if|#
directive|if
name|CS_LATIN1
literal|"~!!"
block|,
literal|"a-*"
block|,
literal|"\">+"
block|,
literal|"o-:"
block|,
literal|"\"<>"
block|,
literal|"~??"
block|,
literal|"A`@"
block|,
literal|"A'A"
block|,
literal|"A^B"
block|,
literal|"A~C"
block|,
literal|"A\"D"
block|,
literal|"A@E"
block|,
literal|"AEF"
block|,
literal|"C,G"
block|,
literal|"E`H"
block|,
literal|"E'I"
block|,
literal|"E^J"
block|,
literal|"E\"K"
block|,
literal|"I`L"
block|,
literal|"I'M"
block|,
literal|"I^N"
block|,
literal|"I\"O"
block|,
literal|"-DP"
block|,
literal|"N~Q"
block|,
literal|"O`R"
block|,
literal|"O'S"
block|,
literal|"O^T"
block|,
literal|"O~U"
block|,
literal|"O\"V"
block|,
literal|"O/X"
block|,
literal|"U`Y"
block|,
literal|"U'Z"
block|,
literal|"U^["
block|,
literal|"U\"\\"
block|,
literal|"Y'_"
block|,
literal|"a``"
block|,
literal|"a'a"
block|,
literal|"a^b"
block|,
literal|"a~c"
block|,
literal|"a\"d"
block|,
literal|"a@e"
block|,
literal|"aef"
block|,
literal|"c,g"
block|,
literal|"e`h"
block|,
literal|"e'i"
block|,
literal|"e^j"
block|,
literal|"e\"k"
block|,
literal|"i`l"
block|,
literal|"i'm"
block|,
literal|"i^n"
block|,
literal|"i\"o"
block|,
literal|"-dp"
block|,
literal|"n~q"
block|,
literal|"o`r"
block|,
literal|"o's"
block|,
literal|"o^t"
block|,
literal|"o~u"
block|,
literal|"o\"v"
block|,
literal|"o/x"
block|,
literal|"u`y"
block|,
literal|"u'z"
block|,
literal|"u^{"
block|,
literal|"u\"|"
block|,
literal|"y'~"
block|,
endif|#
directive|endif
comment|/* CS_LATIN1 */
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|init_digraphs
argument_list|()
block|{
name|int
name|i
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|digtable
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|do_digraph
argument_list|(
name|FALSE
argument_list|,
name|digtable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|do_digraph
argument_list|(
name|FALSE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_DIGRAPH */
end_comment

end_unit

