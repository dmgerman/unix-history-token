begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* opts.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the code that manages the run-time options -- The   * values that can be modified via the "set" command.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|(char *)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* maximum width to permit for strings, including ="" */
end_comment

begin_define
define|#
directive|define
name|MAXWIDTH
value|20
end_define

begin_comment
comment|/* These are the default values of all options */
end_comment

begin_decl_stmt
name|char
name|o_autoindent
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_autoprint
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_autowrite
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ERRLIST
end_ifndef

begin_decl_stmt
name|char
name|o_cc
index|[
literal|30
index|]
init|=
block|{
name|CC_COMMAND
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_CHARATTR
end_ifndef

begin_decl_stmt
name|char
name|o_charattr
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|o_columns
index|[
literal|3
index|]
init|=
block|{
literal|80
block|,
literal|32
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_decl_stmt
name|char
name|o_digraph
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|o_directory
index|[
literal|30
index|]
init|=
name|TMPDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_edcompatible
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_errorbells
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_exrefresh
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_decl_stmt
name|char
name|o_flipcase
index|[
literal|80
index|]
if|#
directive|if
name|CS_IBMPC
init|=
block|{
literal|"\207\200\201\232\202\220\204\216\206\217\221\222\224\231\244\245"
block|}
endif|#
directive|endif
if|#
directive|if
name|CS_LATIN1
comment|/* initialized by initopts() */
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SENTENCE
end_ifndef

begin_decl_stmt
name|char
name|o_hideformat
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|o_ignorecase
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
end_ifndef

begin_decl_stmt
name|char
name|o_inputmode
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|o_keytime
index|[
literal|3
index|]
init|=
block|{
literal|2
block|,
literal|0
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_keywordprg
index|[
literal|80
index|]
init|=
block|{
name|KEYWORDPRG
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_lines
index|[
literal|3
index|]
init|=
block|{
literal|25
block|,
literal|2
block|,
literal|50
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* More lines? Enlarge kbuf */
end_comment

begin_decl_stmt
name|char
name|o_list
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MAGIC
end_ifndef

begin_decl_stmt
name|char
name|o_magic
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ERRLIST
end_ifndef

begin_decl_stmt
name|char
name|o_make
index|[
literal|30
index|]
init|=
block|{
name|MAKE_COMMAND
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MODELINE
end_ifndef

begin_decl_stmt
name|char
name|o_modeline
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SENTENCE
end_ifndef

begin_decl_stmt
name|char
name|o_paragraphs
index|[
literal|30
index|]
init|=
literal|"PPppIPLPQP"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_decl_stmt
name|char
name|o_pcbios
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|o_readonly
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_report
index|[
literal|3
index|]
init|=
block|{
literal|5
block|,
literal|1
block|,
literal|127
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_scroll
index|[
literal|3
index|]
init|=
block|{
literal|12
block|,
literal|1
block|,
literal|127
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SENTENCE
end_ifndef

begin_decl_stmt
name|char
name|o_sections
index|[
literal|30
index|]
init|=
literal|"NHSHSSSEse"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|o_shell
index|[
literal|60
index|]
init|=
name|SHELL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_shiftwidth
index|[
literal|3
index|]
init|=
block|{
literal|8
block|,
literal|1
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SHOWMATCH
end_ifndef

begin_decl_stmt
name|char
name|o_showmatch
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SHOWMODE
end_ifndef

begin_decl_stmt
name|char
name|o_smd
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|o_sidescroll
index|[
literal|3
index|]
init|=
block|{
literal|8
block|,
literal|1
block|,
literal|40
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_sync
index|[
literal|1
index|]
init|=
block|{
name|NEEDSYNC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_tabstop
index|[
literal|3
index|]
init|=
block|{
literal|8
block|,
literal|1
block|,
literal|40
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_term
index|[
literal|30
index|]
init|=
literal|"?"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_vbell
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_warn
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_wrapmargin
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_wrapscan
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following describes the names& types of all options */
end_comment

begin_define
define|#
directive|define
name|BOOL
value|0
end_define

begin_define
define|#
directive|define
name|NUM
value|1
end_define

begin_define
define|#
directive|define
name|STR
value|2
end_define

begin_define
define|#
directive|define
name|SET
value|0x01
end_define

begin_comment
comment|/* this option has had its value altered */
end_comment

begin_define
define|#
directive|define
name|CANSET
value|0x02
end_define

begin_comment
comment|/* this option can be set at any time */
end_comment

begin_define
define|#
directive|define
name|RCSET
value|0x06
end_define

begin_comment
comment|/* this option can be set in a .exrc file only */
end_comment

begin_define
define|#
directive|define
name|MR
value|0x40
end_define

begin_comment
comment|/* does this option affect the way text is displayed? */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of an option */
name|char
modifier|*
name|nm
decl_stmt|;
comment|/* short name of an option */
name|char
name|type
decl_stmt|;
comment|/* type of an option */
name|char
name|flags
decl_stmt|;
comment|/* boolean: has this option been set? */
name|char
modifier|*
name|value
decl_stmt|;
comment|/* value */
block|}
name|opts
index|[]
init|=
block|{
comment|/* name			type	flags	redraw	value */
block|{
literal|"autoindent"
block|,
literal|"ai"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_autoindent
block|}
block|,
block|{
literal|"autoprint"
block|,
literal|"ap"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_autoprint
block|}
block|,
block|{
literal|"autowrite"
block|,
literal|"aw"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_autowrite
block|}
block|,
ifndef|#
directive|ifndef
name|NO_ERRLIST
block|{
literal|"cc"
block|,
literal|"cc"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_cc
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CHARATTR
block|{
literal|"charattr"
block|,
literal|"ca"
block|,
name|BOOL
block|,
name|CANSET
operator||
name|MR
block|,
name|o_charattr
block|}
block|,
endif|#
directive|endif
block|{
literal|"columns"
block|,
literal|"co"
block|,
name|NUM
block|,
name|SET
block|,
name|o_columns
block|}
block|,
ifndef|#
directive|ifndef
name|NO_DIGRAPH
block|{
literal|"digraph"
block|,
literal|"dig"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_digraph
block|}
block|,
endif|#
directive|endif
block|{
literal|"directory"
block|,
literal|"dir"
block|,
name|STR
block|,
name|RCSET
block|,
name|o_directory
block|}
block|,
block|{
literal|"edcompatible"
block|,
literal|"ed"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_edcompatible
block|}
block|,
block|{
literal|"errorbells"
block|,
literal|"eb"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_errorbells
block|}
block|,
block|{
literal|"exrefresh"
block|,
literal|"er"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_exrefresh
block|}
block|,
ifndef|#
directive|ifndef
name|NO_DIGRAPH
block|{
literal|"flipcase"
block|,
literal|"fc"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_flipcase
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SENTENCE
block|{
literal|"hideformat"
block|,
literal|"hf"
block|,
name|BOOL
block|,
name|CANSET
operator||
name|MR
block|,
name|o_hideformat
block|}
block|,
endif|#
directive|endif
block|{
literal|"ignorecase"
block|,
literal|"ic"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_ignorecase
block|}
block|,
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
block|{
literal|"inputmode"
block|,
literal|"im"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_inputmode
block|}
block|,
endif|#
directive|endif
block|{
literal|"keytime"
block|,
literal|"kt"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_keytime
block|}
block|,
block|{
literal|"keywordprg"
block|,
literal|"kp"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_keywordprg
block|}
block|,
block|{
literal|"lines"
block|,
literal|"ls"
block|,
name|NUM
block|,
name|SET
block|,
name|o_lines
block|}
block|,
block|{
literal|"list"
block|,
literal|"li"
block|,
name|BOOL
block|,
name|CANSET
operator||
name|MR
block|,
name|o_list
block|}
block|,
ifndef|#
directive|ifndef
name|NO_MAGIC
block|{
literal|"magic"
block|,
literal|"ma"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_magic
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
block|{
literal|"make"
block|,
literal|"mk"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_make
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_MODELINE
block|{
literal|"modeline"
block|,
literal|"ml"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_modeline
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SENTENCE
block|{
literal|"paragraphs"
block|,
literal|"pa"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_paragraphs
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|MSDOS
block|{
literal|"pcbios"
block|,
literal|"pc"
block|,
name|BOOL
block|,
name|SET
block|,
name|o_pcbios
block|}
block|,
endif|#
directive|endif
block|{
literal|"readonly"
block|,
literal|"ro"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_readonly
block|}
block|,
block|{
literal|"report"
block|,
literal|"re"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_report
block|}
block|,
block|{
literal|"scroll"
block|,
literal|"sc"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_scroll
block|}
block|,
ifndef|#
directive|ifndef
name|NO_SENTENCE
block|{
literal|"sections"
block|,
literal|"se"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_sections
block|}
block|,
endif|#
directive|endif
block|{
literal|"shell"
block|,
literal|"sh"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_shell
block|}
block|,
ifndef|#
directive|ifndef
name|NO_SHOWMATCH
block|{
literal|"showmatch"
block|,
literal|"sm"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_showmatch
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SHOWMODE
block|{
literal|"showmode"
block|,
literal|"smd"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_smd
block|}
block|,
endif|#
directive|endif
block|{
literal|"shiftwidth"
block|,
literal|"sw"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_shiftwidth
block|}
block|,
block|{
literal|"sidescroll"
block|,
literal|"ss"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_sidescroll
block|}
block|,
block|{
literal|"sync"
block|,
literal|"sy"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_sync
block|}
block|,
block|{
literal|"tabstop"
block|,
literal|"ts"
block|,
name|NUM
block|,
name|CANSET
operator||
name|MR
block|,
name|o_tabstop
block|}
block|,
block|{
literal|"term"
block|,
literal|"te"
block|,
name|STR
block|,
name|SET
block|,
name|o_term
block|}
block|,
block|{
literal|"vbell"
block|,
literal|"vb"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_vbell
block|}
block|,
block|{
literal|"warn"
block|,
literal|"wa"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_warn
block|}
block|,
block|{
literal|"wrapmargin"
block|,
literal|"wm"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_wrapmargin
block|}
block|,
block|{
literal|"wrapscan"
block|,
literal|"ws"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_wrapscan
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|CANSET
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* This function initializes certain options from environment variables, etc. */
end_comment

begin_function
name|void
name|initopts
parameter_list|()
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* set some stuff from environment variables */
if|#
directive|if
name|MSDOS
if|if
condition|(
name|val
operator|=
name|getenv
argument_list|(
literal|"COMSPEC"
argument_list|)
condition|)
comment|/* yes, ASSIGNMENT! */
else|#
directive|else
if|if
condition|(
name|val
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
condition|)
comment|/* yes, ASSIGNMENT! */
endif|#
directive|endif
block|{
name|strcpy
argument_list|(
name|o_shell
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ANY_UNIX
if|if
condition|(
name|val
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
condition|)
comment|/* yes, ASSIGNMENT! */
block|{
name|strcpy
argument_list|(
name|o_term
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|TOS
name|val
operator|=
literal|"vt52"
expr_stmt|;
name|strcpy
argument_list|(
name|o_term
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
comment|/* yes, ASSIGNMENT! */
operator|&&
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"pcbios"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|o_term
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|o_pcbios
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|o_term
argument_list|,
literal|"pcbios"
argument_list|)
expr_stmt|;
name|o_pcbios
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|MSDOS
operator|||
name|TOS
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
operator|)
comment|/* yes, ASSIGNMENT! */
operator|||
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
operator|)
condition|)
name|strcpy
argument_list|(
name|o_directory
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|o_scroll
operator|=
name|LINES
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
comment|/* disable the vbell option if we don't know how to do a vbell */
if|if
condition|(
operator|!
name|has_VB
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|!=
name|o_vbell
condition|;
name|i
operator|++
control|)
block|{ 		}
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|CANSET
expr_stmt|;
operator|*
name|o_vbell
operator|=
name|FALSE
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_DIGRAPH
ifdef|#
directive|ifdef
name|CS_LATIN1
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|val
operator|=
name|o_flipcase
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* leave out the multiply/divide symbols */
if|if
condition|(
name|i
operator|==
literal|23
condition|)
continue|continue;
comment|/* add upper/lowercase pair */
operator|*
name|val
operator|++
operator|=
name|i
operator|+
literal|0xc0
expr_stmt|;
operator|*
name|val
operator|++
operator|=
name|i
operator|+
literal|0xe0
expr_stmt|;
block|}
operator|*
name|val
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* CS_LATIN1 */
endif|#
directive|endif
comment|/* not NO_DIGRAPH */
block|}
end_function

begin_comment
comment|/* This function lists the current values of all options */
end_comment

begin_function
name|void
name|dumpopts
parameter_list|(
name|all
parameter_list|)
name|int
name|all
decl_stmt|;
comment|/* boolean: dump all options, or just set ones? */
block|{
ifndef|#
directive|ifndef
name|NO_OPTCOLS
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
name|nbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* used for converting numbers to ASCII */
name|int
name|widths
index|[
literal|5
index|]
decl_stmt|;
comment|/* width of each column, including gap */
name|int
name|ncols
decl_stmt|;
comment|/* number of columns */
name|int
name|nrows
decl_stmt|;
comment|/* number of options per column */
name|int
name|nset
decl_stmt|;
comment|/* number of options to be output */
name|int
name|width
decl_stmt|;
comment|/* width of a particular option */
name|int
name|todump
index|[
literal|50
index|]
decl_stmt|;
comment|/* indicies of options to be dumped */
comment|/* step 1: count the number of set options */
for|for
control|(
name|nset
operator|=
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|all
operator|||
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SET
operator|)
condition|)
block|{
name|todump
index|[
name|nset
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* step two: try to use as many columns as possible */
for|for
control|(
name|ncols
operator|=
operator|(
name|nset
operator|>
literal|5
condition|?
literal|5
else|:
name|nset
operator|)
init|;
name|ncols
operator|>
literal|1
condition|;
name|ncols
operator|--
control|)
block|{
comment|/* how many would go in this column? */
name|nrows
operator|=
operator|(
name|nset
operator|+
name|ncols
operator|-
literal|1
operator|)
operator|/
name|ncols
expr_stmt|;
comment|/* figure out the width of each column */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
name|widths
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|nrows
operator|*
name|i
init|;
name|j
operator|<
name|nrows
operator|&&
name|k
operator|<
name|nset
condition|;
name|j
operator|++
operator|,
name|k
operator|++
control|)
block|{
comment|/* figure out the width of a particular option */
switch|switch
condition|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
if|if
condition|(
operator|!
operator|*
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
condition|)
name|width
operator|=
literal|2
expr_stmt|;
else|else
name|width
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|width
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|MAXWIDTH
condition|)
name|width
operator|=
name|MAXWIDTH
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|width
operator|=
literal|4
expr_stmt|;
break|break;
block|}
name|width
operator|+=
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* if this is the widest so far, widen col */
if|if
condition|(
name|width
operator|>
name|widths
index|[
name|i
index|]
condition|)
block|{
name|widths
index|[
name|i
index|]
operator|=
name|width
expr_stmt|;
block|}
block|}
block|}
comment|/* if the total width is narrow enough, then use it */
for|for
control|(
name|width
operator|=
operator|-
literal|2
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
name|width
operator|+=
name|widths
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|<
name|COLS
operator|-
literal|1
condition|)
block|{
break|break;
block|}
block|}
comment|/* step 3: output the columns */
name|nrows
operator|=
operator|(
name|nset
operator|+
name|ncols
operator|-
literal|1
operator|)
operator|/
name|ncols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrows
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ncols
condition|;
name|j
operator|++
control|)
block|{
comment|/* if we hit the end of the options, quit */
name|k
operator|=
name|i
operator|+
name|j
operator|*
name|nrows
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|nset
condition|)
block|{
break|break;
block|}
comment|/* output this option's value */
name|width
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
if|if
condition|(
operator|!
operator|*
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
condition|)
block|{
name|qaddch
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
name|width
operator|=
literal|2
expr_stmt|;
block|}
name|qaddstr
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|width
operator|+=
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%-3d"
argument_list|,
name|UCHAR
argument_list|(
operator|*
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|width
operator|=
literal|4
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|qaddstr
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|width
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|MAXWIDTH
condition|)
block|{
name|width
operator|=
name|MAXWIDTH
expr_stmt|;
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
operator|+
name|MAXWIDTH
operator|-
literal|6
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|qaddstr
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|width
operator|+=
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* pad the field to the correct size */
if|if
condition|(
name|k
operator|+
name|nrows
operator|<=
name|nset
condition|)
block|{
while|while
condition|(
name|width
operator|<
name|widths
index|[
name|j
index|]
operator|+
literal|2
condition|)
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|width
operator|++
expr_stmt|;
block|}
block|}
block|}
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|int
name|i
decl_stmt|;
name|int
name|col
decl_stmt|;
name|char
name|nbuf
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|col
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
comment|/* if not set and not all, ignore this option */
if|if
condition|(
operator|!
name|all
operator|&&
operator|!
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SET
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* align this option in one of the columns */
if|if
condition|(
name|col
operator|>
literal|52
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|col
operator|>
literal|26
condition|)
block|{
while|while
condition|(
name|col
operator|<
literal|52
condition|)
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|col
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|col
operator|<
literal|26
condition|)
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
if|if
condition|(
operator|!
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
name|qaddch
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
name|qaddstr
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|col
operator|+=
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%-3d"
argument_list|,
name|UCHAR
argument_list|(
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|4
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|qaddstr
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|3
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|exrefresh
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|>
literal|0
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MKEXRC
end_ifndef

begin_comment
comment|/* This function saves the current configuarion of options to a file */
end_comment

begin_function
name|void
name|saveopts
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* file descriptor to write to */
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
comment|/* write each set options */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
comment|/* if unset or unsettable, ignore this option */
if|if
condition|(
operator|!
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SET
operator|)
operator|||
operator|!
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CANSET
operator|)
condition|)
block|{
continue|continue;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"set "
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|&
name|buf
index|[
literal|4
index|]
expr_stmt|;
switch|switch
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
if|if
condition|(
operator|!
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
operator|*
name|pos
operator|++
operator|=
literal|'n'
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
literal|'o'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|pos
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pos
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|sprintf
argument_list|(
name|pos
argument_list|,
literal|"%s=%-3d\n"
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|sprintf
argument_list|(
name|pos
argument_list|,
literal|"%s=\"%s\"\n"
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|twrite
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function changes the values of one or more options. */
end_comment

begin_function
name|void
name|setopts
parameter_list|(
name|assignments
parameter_list|)
name|char
modifier|*
name|assignments
decl_stmt|;
comment|/* a string containing option assignments */
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of variable in assignments */
name|char
modifier|*
name|value
decl_stmt|;
comment|/* value of the variable */
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used for moving through strings */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* for each assignment... */
for|for
control|(
name|name
operator|=
name|assignments
init|;
operator|*
name|name
condition|;
control|)
block|{
comment|/* skip whitespace */
if|if
condition|(
operator|*
name|name
operator|==
literal|' '
operator|||
operator|*
name|name
operator|==
literal|'\t'
condition|)
block|{
name|name
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* find the value, if any */
for|for
control|(
name|scan
operator|=
name|name
init|;
operator|*
name|scan
operator|>=
literal|'a'
operator|&&
operator|*
name|scan
operator|<=
literal|'z'
condition|;
name|scan
operator|++
control|)
block|{ 		}
if|if
condition|(
operator|*
name|scan
operator|==
literal|'='
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|scan
operator|==
literal|'"'
condition|)
block|{
name|value
operator|=
operator|++
name|scan
expr_stmt|;
while|while
condition|(
operator|*
name|scan
operator|&&
operator|*
name|scan
operator|!=
literal|'"'
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|scan
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|=
name|scan
expr_stmt|;
while|while
condition|(
operator|*
name|scan
operator|&&
operator|*
name|scan
operator|!=
literal|' '
operator|&&
operator|*
name|scan
operator|!=
literal|'\t'
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|scan
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|scan
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|name
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* find the variable */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|name
operator|&&
name|strcmp
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|nm
argument_list|,
name|name
argument_list|)
condition|;
name|i
operator|++
control|)
block|{ 		}
comment|/* change the variable */
if|if
condition|(
operator|!
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|msg
argument_list|(
literal|"invalid option name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CANSET
operator|)
operator|!=
name|CANSET
condition|)
block|{
name|msg
argument_list|(
literal|"option \"%s\" can't be altered"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|RCSET
operator|)
operator|!=
name|CANSET
operator|&&
name|nlines
operator|>=
literal|1L
condition|)
block|{
name|msg
argument_list|(
literal|"option \"%s\" can only be set in a %s file"
argument_list|,
name|name
argument_list|,
name|EXRC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
condition|)
block|{
switch|switch
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
name|msg
argument_list|(
literal|"option \"[no]%s\" is boolean"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|j
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
operator|*
name|value
operator|!=
literal|'0'
condition|)
block|{
name|msg
argument_list|(
literal|"option \"%s\" must have a numeric value"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|<
name|opts
index|[
name|i
index|]
operator|.
name|value
index|[
literal|1
index|]
operator|||
name|j
operator|>
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|value
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
name|msg
argument_list|(
literal|"option \"%s\" must have a value between %d and %d"
argument_list|,
name|name
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|value
index|[
literal|1
index|]
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|value
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|SET
expr_stmt|;
block|}
break|break;
case|case
name|STR
case|:
name|strcpy
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|SET
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|MR
condition|)
block|{
name|mustredraw
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
comment|/* valid option, no value */
block|{
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|type
operator|==
name|BOOL
condition|)
block|{
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|=
operator|(
name|name
index|[
operator|-
literal|1
index|]
operator|!=
literal|'o'
operator|)
expr_stmt|;
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|SET
expr_stmt|;
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|MR
condition|)
block|{
name|mustredraw
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|msg
argument_list|(
literal|"option \"%s\" must be given a value"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* move on to the next option */
name|name
operator|=
name|scan
expr_stmt|;
block|}
comment|/* special processing ... */
comment|/* if "readonly" then set the READONLY flag for this file */
if|if
condition|(
operator|*
name|o_readonly
condition|)
block|{
name|setflag
argument_list|(
name|file
argument_list|,
name|READONLY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

