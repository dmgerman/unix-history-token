begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* system.c  -- UNIX version */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains a new version of the system() function and related stuff.  *  * Entry points are:  *	system(cmd)	- run a single shell command  *	wildcard(names)	- expand wildcard characters in filanames  *	filter(m,n,cmd)	- run text lines through a filter program  *  * This is probably the single least portable file in the program.  The code  * shown here should work correctly if it links at all; it will work on UNIX  * and any O.S./Compiler combination which adheres to UNIX forking conventions.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|ANY_UNIX
end_if

begin_comment
comment|/* This is a new version of the system() function.  The only difference  * between this one and the library one is: this one uses the o_shell option.  */
end_comment

begin_function
name|int
name|system
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* a command to run */
block|{
name|int
name|status
decl_stmt|;
comment|/* exit status of the command */
comment|/* warn the user if the file hasn't been saved yet */
if|if
condition|(
operator|*
name|o_warn
operator|&&
name|tstflag
argument_list|(
name|file
argument_list|,
name|MODIFIED
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|MODE_VI
condition|)
block|{
name|mode
operator|=
name|MODE_COLON
expr_stmt|;
block|}
name|msg
argument_list|(
literal|"Warning: \"%s\" has been modified but not yet saved"
argument_list|,
name|origname
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* error */
name|msg
argument_list|(
literal|"fork() failed"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* child */
comment|/* for the child, close all files except stdin/out/err */
for|for
control|(
name|status
operator|=
literal|3
init|;
name|status
operator|<
literal|60
operator|&&
operator|(
name|close
argument_list|(
name|status
argument_list|)
operator|,
name|errno
operator|!=
name|EINVAL
operator|)
condition|;
name|status
operator|++
control|)
block|{ 		}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|o_shell
condition|)
block|{
name|execle
argument_list|(
name|o_shell
argument_list|,
name|o_shell
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|environ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execle
argument_list|(
name|o_shell
argument_list|,
name|o_shell
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|environ
argument_list|)
expr_stmt|;
block|}
name|msg
argument_list|(
literal|"execle(\"%s\", ...) failed"
argument_list|,
name|o_shell
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* if we get here, the exec failed */
default|default:
comment|/* parent */
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* This private function opens a pipe from a filter.  It is similar to the  * system() function above, and to popen(cmd, "r").  */
end_comment

begin_function
specifier|static
name|int
name|rpipe
parameter_list|(
name|cmd
parameter_list|,
name|in
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* the filter command to use */
name|int
name|in
decl_stmt|;
comment|/* the fd to use for stdin */
block|{
name|int
name|r0w1
index|[
literal|2
index|]
decl_stmt|;
comment|/* the pipe fd's */
comment|/* make the pipe */
if|if
condition|(
name|pipe
argument_list|(
name|r0w1
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|/* pipe failed */
block|}
comment|/* The parent process (elvis) ignores signals while the filter runs. 	 * The child (the filter program) will reset this, so that it can 	 * catch the signal. 	 */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* error */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* child */
comment|/* close the "read" end of the pipe */
name|close
argument_list|(
name|r0w1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* redirect stdout to go to the "write" end of the pipe */
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|r0w1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|r0w1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|r0w1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* redirect stdin */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* the filter should accept SIGINT signals */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* exec the shell to run the command */
name|execle
argument_list|(
name|o_shell
argument_list|,
name|o_shell
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|environ
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* if we get here, exec failed */
default|default:
comment|/* parent */
comment|/* close the "write" end of the pipe */
name|close
argument_list|(
name|r0w1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|r0w1
index|[
literal|0
index|]
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* non-DOS */
end_comment

begin_if
if|#
directive|if
name|OSK
end_if

begin_comment
comment|/* This private function opens a pipe from a filter.  It is similar to the  * system() function above, and to popen(cmd, "r").  */
end_comment

begin_function
specifier|static
name|int
name|rpipe
parameter_list|(
name|cmd
parameter_list|,
name|in
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* the filter command to use */
name|int
name|in
decl_stmt|;
comment|/* the fd to use for stdin */
block|{
name|char
modifier|*
modifier|*
name|argblk
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|command
decl_stmt|;
name|int
name|stdinp
decl_stmt|,
name|stdoutp
decl_stmt|;
name|unsigned
name|addstack
init|=
literal|0
decl_stmt|;
name|int
name|words
decl_stmt|,
name|len
decl_stmt|,
name|loop
init|=
literal|1
decl_stmt|;
name|int
name|fp
decl_stmt|,
name|pipe_pid
decl_stmt|;
specifier|extern
name|int
name|os9forkc
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|command
operator|=
name|cmd
expr_stmt|;
name|words
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return
literal|0
return|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|index
argument_list|(
name|command
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
block|{
name|loop
operator|--
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
name|len
operator|=
name|p
operator|-
name|command
expr_stmt|;
name|words
operator|++
expr_stmt|;
while|while
condition|(
name|command
index|[
name|len
index|]
operator|&&
name|command
index|[
name|len
index|]
operator|==
literal|' '
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|command
index|[
name|len
index|]
condition|)
break|break;
name|command
operator|=
name|command
operator|+
name|len
expr_stmt|;
block|}
do|while
condition|(
name|loop
condition|)
do|;
if|if
condition|(
operator|(
name|argblk
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|words
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
condition|)
return|return
literal|0
return|;
name|command
operator|=
name|cmd
expr_stmt|;
name|words
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|index
argument_list|(
name|command
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
block|{
name|loop
operator|--
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
name|len
operator|=
name|p
operator|-
name|command
expr_stmt|;
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|command
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|argblk
index|[
name|words
operator|++
index|]
operator|=
name|buffer
expr_stmt|;
name|buffer
operator|+=
name|len
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|command
index|[
name|len
index|]
operator|&&
name|command
index|[
name|len
index|]
operator|==
literal|' '
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|command
index|[
name|len
index|]
condition|)
break|break;
name|command
operator|=
name|command
operator|+
name|len
expr_stmt|;
block|}
do|while
condition|(
name|loop
condition|)
do|;
if|if
condition|(
name|argblk
index|[
name|words
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|addstack
operator|=
literal|1024
operator|*
name|atoi
argument_list|(
operator|&
name|argblk
index|[
operator|--
name|words
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argblk
index|[
name|words
index|]
operator|=
literal|0
expr_stmt|;
name|stdoutp
operator|=
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* close stdout */
if|if
condition|(
operator|(
name|fp
operator|=
name|open
argument_list|(
literal|"/pipe"
argument_list|,
name|S_IREAD
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dup
argument_list|(
name|stdoutp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdoutp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|stdinp
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|pipe_pid
operator|=
name|os9exec
argument_list|(
name|os9forkc
argument_list|,
name|argblk
index|[
literal|0
index|]
argument_list|,
name|argblk
argument_list|,
name|environ
argument_list|,
name|addstack
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe_pid
operator|==
operator|-
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|stdoutp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdoutp
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|stdinp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|fp
operator|=
operator|(
name|short
operator|)
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* save pipe */
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* get rid of the pipe */
name|dup
argument_list|(
name|stdoutp
argument_list|)
expr_stmt|;
comment|/* restore old stdout */
name|close
argument_list|(
name|stdoutp
argument_list|)
expr_stmt|;
comment|/* close path to stdout copy */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|stdinp
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ANY_UNIX
operator|||
name|OSK
end_if

begin_comment
comment|/* This function closes the pipe opened by rpipe(), and returns 0 for success */
end_comment

begin_function
specifier|static
name|int
name|rpclose
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* non-DOS */
end_comment

begin_comment
comment|/* This function expands wildcards in a filename or filenames.  It does this  * by running the "echo" command on the filenames via the shell; it is assumed  * that the shell will expand the names for you.  If for any reason it can't  * run echo, then it returns the names unmodified.  */
end_comment

begin_if
if|#
directive|if
name|MSDOS
operator|||
name|TOS
end_if

begin_define
define|#
directive|define
name|PROG
value|"wildcard "
end_define

begin_define
define|#
directive|define
name|PROGLEN
value|9
end_define

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROG
value|"echo "
end_define

begin_define
define|#
directive|define
name|PROGLEN
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|wildcard
parameter_list|(
name|names
parameter_list|)
name|char
modifier|*
name|names
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|fd
decl_stmt|;
name|REG
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/* build the echo command */
if|if
condition|(
name|names
operator|!=
name|tmpblk
operator|.
name|c
condition|)
block|{
comment|/* the names aren't in tmpblk.c, so we can do it the easy way */
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|PROG
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|names
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the names are already in tmpblk.c, so shift them to make 		 * room for the word "echo " 		 */
for|for
control|(
name|s
operator|=
name|names
operator|+
name|strlen
argument_list|(
name|names
argument_list|)
operator|+
literal|1
operator|,
name|d
operator|=
name|s
operator|+
name|PROGLEN
init|;
name|s
operator|>
name|names
condition|;
control|)
block|{
operator|*
operator|--
name|d
operator|=
operator|*
operator|--
name|s
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|names
argument_list|,
name|PROG
argument_list|,
name|PROGLEN
argument_list|)
expr_stmt|;
block|}
comment|/* run the command& read the resulting names */
name|fd
operator|=
name|rpipe
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|names
return|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|j
operator|=
name|tread
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
operator|+
name|i
argument_list|,
name|BLKSIZE
operator|-
name|i
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>
literal|0
condition|)
do|;
comment|/* successful? */
if|if
condition|(
name|rpclose
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
operator|&&
name|j
operator|==
literal|0
operator|&&
name|i
operator|<
name|BLKSIZE
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* "i-1" so we clip off the newline */
return|return
name|tmpblk
operator|.
name|c
return|;
block|}
else|else
block|{
return|return
name|names
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function runs a range of lines through a filter program, and replaces  * the original text with the filtered version.  As a special case, if "to"  * is MARK_UNSET, then it runs the filter program with stdin coming from  * /dev/null, and inserts any output lines.  */
end_comment

begin_function
name|int
name|filter
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cmd
parameter_list|)
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
comment|/* the range of lines to filter */
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* the filter command */
block|{
name|int
name|scratch
decl_stmt|;
comment|/* fd of the scratch file */
name|int
name|fd
decl_stmt|;
comment|/* fd of the pipe from the filter */
name|char
name|scrout
index|[
literal|50
index|]
decl_stmt|;
comment|/* name of the scratch out file */
name|MARK
name|new
decl_stmt|;
comment|/* place where new text should go */
name|int
name|i
decl_stmt|;
comment|/* write the lines (if specified) to a temp file */
if|if
condition|(
name|to
condition|)
block|{
comment|/* we have lines */
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|strcpy
argument_list|(
name|scrout
argument_list|,
name|o_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|scrout
argument_list|)
operator|)
operator|&&
name|strchr
argument_list|(
literal|"\\/:"
argument_list|,
name|scrout
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|scrout
index|[
name|i
operator|++
index|]
operator|=
name|SLASH
expr_stmt|;
name|strcpy
argument_list|(
name|scrout
operator|+
name|i
argument_list|,
name|SCRATCHOUT
operator|+
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|scrout
argument_list|,
name|SCRATCHOUT
argument_list|,
name|o_directory
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mktemp
argument_list|(
name|scrout
argument_list|)
expr_stmt|;
name|cmd_write
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|CMD_BANG
argument_list|,
literal|0
argument_list|,
name|scrout
argument_list|)
expr_stmt|;
comment|/* use those lines as stdin */
name|scratch
operator|=
name|open
argument_list|(
name|scrout
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch
operator|<
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|scrout
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|scratch
operator|=
literal|0
expr_stmt|;
block|}
comment|/* start the filter program */
name|fd
operator|=
name|rpipe
argument_list|(
name|cmd
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|to
condition|)
block|{
name|close
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|scrout
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|ChangeText
block|{
comment|/* adjust MARKs for whole lines, and set "new" */
name|from
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|to
condition|)
block|{
name|to
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|to
operator|+=
name|BLKSIZE
expr_stmt|;
name|new
operator|=
name|to
expr_stmt|;
block|}
else|else
block|{
name|new
operator|=
name|from
operator|+
name|BLKSIZE
expr_stmt|;
block|}
comment|/* repeatedly read in new text and add it */
while|while
condition|(
operator|(
name|i
operator|=
name|tread
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|BLKSIZE
operator|-
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|add
argument_list|(
name|new
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tmpblk
operator|.
name|c
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tmpblk
operator|.
name|c
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|new
operator|=
operator|(
name|new
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
expr_stmt|;
block|}
else|else
block|{
name|new
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* delete old text, if any */
if|if
condition|(
name|to
condition|)
block|{
name|delete
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* Reporting... */
name|rptlabel
operator|=
literal|"more"
expr_stmt|;
if|if
condition|(
name|rptlines
operator|<
literal|0
condition|)
block|{
name|rptlines
operator|=
operator|-
name|rptlines
expr_stmt|;
name|rptlabel
operator|=
literal|"less"
expr_stmt|;
block|}
comment|/* cleanup */
name|rpclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
condition|)
block|{
name|close
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|scrout
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

