begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* curses.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the functions& variables needed for a tiny subset of  * curses.  The principle advantage of this version of curses is its  * extreme speed.  Disadvantages are potentially larger code, few supported  * functions, limited compatibility with full curses, and only stdscr.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_if
if|#
directive|if
name|ANY_UNIX
end_if

begin_if
if|#
directive|if
name|UNIXV
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_undef
undef|#
directive|undef
name|TIOCWINSZ
end_undef

begin_comment
comment|/* we can't handle it correctly yet */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TOS
end_if

begin_include
include|#
directive|include
file|<osbind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|OSK
end_if

begin_include
include|#
directive|include
file|<sgstat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|starttcap
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* variables, publicly available& used in the macros */
end_comment

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* speed of the tty, eg B2400 */
end_comment

begin_if
if|#
directive|if
name|OSK
end_if

begin_decl_stmt
name|char
name|PC_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad char */
end_comment

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* backspace character string */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad char */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|WINDOW
modifier|*
name|stdscr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer into kbuf[] */
end_comment

begin_decl_stmt
name|WINDOW
name|kbuf
index|[
name|KBSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a very large output buffer */
end_comment

begin_decl_stmt
name|int
name|LINES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :li#: number of rows */
end_comment

begin_decl_stmt
name|int
name|COLS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :co#: number of columns */
end_comment

begin_decl_stmt
name|int
name|AM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :am:  boolean: auto margins? */
end_comment

begin_decl_stmt
name|int
name|PT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :pt:  boolean: physical tabs? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|VB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :vb=: visible bell */
end_comment

begin_decl_stmt
name|char
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :up=: move cursor up */
end_comment

begin_decl_stmt
name|char
modifier|*
name|SO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :so=: standout start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|SE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :se=: standout end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|US
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :us=: underline start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|UE
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ue=: underline end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|MD
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :md=: bold start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ME
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :me=: bold end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|AS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :as=: alternate (italic) start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|AE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ae=: alternate (italic) end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cm=: cursor movement */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ce=: clear to end of line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cd=: clear to end of screen */
end_comment

begin_decl_stmt
name|char
modifier|*
name|AL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :al=: add a line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :dl=: delete a line */
end_comment

begin_if
if|#
directive|if
name|OSK
end_if

begin_decl_stmt
name|char
modifier|*
name|SR_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :sr=: scroll reverse */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|SR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :sr=: scroll reverse */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|KS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ks=: init string for cursor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ke=: restore string for cursor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KU
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ku=: key sequence sent by up arrow */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :kd=: key sequence sent by down arrow */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :kl=: key sequence sent by left arrow */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :kr=: key sequence sent by right arrow */
end_comment

begin_decl_stmt
name|char
modifier|*
name|HM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :HM=: key sequence sent by the<Home> key */
end_comment

begin_decl_stmt
name|char
modifier|*
name|EN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :EN=: key sequence sent by the<End> key */
end_comment

begin_decl_stmt
name|char
modifier|*
name|PU
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :PU=: key sequence sent by the<PgUp> key */
end_comment

begin_decl_stmt
name|char
modifier|*
name|PD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :PD=: key sequence sent by the<PgDn> key */
end_comment

begin_decl_stmt
name|char
modifier|*
name|IM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :im=: insert mode start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|IC
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ic=: insert the following character */
end_comment

begin_decl_stmt
name|char
modifier|*
name|EI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ei=: insert mode end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :dc=: delete a character */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ti=: terminal init */
end_comment

begin_comment
comment|/* GB */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :te=: terminal exit */
end_comment

begin_comment
comment|/* GB */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|CQ
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cQ=: normal cursor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CX
init|=
operator|(
name|char
operator|*
operator|)
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cX=: cursor used for EX command/entry */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CV
init|=
operator|(
name|char
operator|*
operator|)
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cV=: cursor used for VI command mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CI
init|=
operator|(
name|char
operator|*
operator|)
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cI=: cursor used for VI input mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CR
init|=
operator|(
name|char
operator|*
operator|)
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cR=: cursor used for VI replace mode */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|aend
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end an attribute -- either UE or ME */
end_comment

begin_decl_stmt
name|char
name|ERASEKEY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* backspace key taken from ioctl structure */
end_comment

begin_if
if|#
directive|if
name|ANY_UNIX
end_if

begin_if
if|#
directive|if
name|UNIXV
end_if

begin_decl_stmt
specifier|static
name|struct
name|termio
name|oldtermio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original tty mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termio
name|newtermio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cbreak/noecho tty mode */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|oldsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original tty mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|newsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cbreak/nl/noecho tty mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^C or DEL, the "intr" character */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSLTC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|oldswitch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^Z, the "suspend" character */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldquote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^V, the "quote next char" char */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|OSK
end_if

begin_decl_stmt
specifier|static
name|struct
name|sgbuf
name|oldsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orginal tty mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgbuf
name|newsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* noecho tty mode */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|capbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* capability string buffer */
end_comment

begin_function
name|void
name|initscr
parameter_list|()
block|{
comment|/* make sure TERM variable is set */
if|#
directive|if
name|MSDOS
name|char
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"pcbios"
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
condition|)
endif|#
directive|endif
block|{
if|#
directive|if
name|ANY_UNIX
name|write
argument_list|(
literal|2
argument_list|,
literal|"Environment variable TERM must be set\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|38
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|OSK
name|writeln
argument_list|(
literal|2
argument_list|,
literal|"Environment variable TERM must be set\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|38
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|getsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|MSDOS
operator|*
name|o_pcbios
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* start termcap stuff */
name|starttcap
argument_list|()
expr_stmt|;
block|}
comment|/* create stdscr and curscr */
name|stdscr
operator|=
name|kbuf
expr_stmt|;
comment|/* change the terminal mode to cbreak/noecho */
if|#
directive|if
name|ANY_UNIX
if|#
directive|if
name|UNIXV
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|oldtermio
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|oldsgttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|OSK
name|_gs_opt
argument_list|(
literal|0
argument_list|,
operator|&
name|oldsgttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|resume_curses
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|endwin
parameter_list|()
block|{
comment|/* change the terminal mode back the way it was */
name|suspend_curses
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|curses_active
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|suspend_curses
parameter_list|()
block|{
if|#
directive|if
name|ANY_UNIX
operator|&&
operator|!
name|UNIXV
name|struct
name|tchars
name|tbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
name|struct
name|ltchars
name|ltbuf
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
if|if
condition|(
name|has_CQ
condition|)
block|{
name|do_CQ
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|has_TE
condition|)
comment|/* GB */
block|{
name|do_TE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|has_KE
condition|)
block|{
name|do_KE
argument_list|()
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
comment|/* change the terminal mode back the way it was */
if|#
directive|if
name|ANY_UNIX
if|#
directive|if
name|UNIXV
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|oldtermio
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|oldsgttyb
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tbuf
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_intrc
operator|=
name|oldint
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltbuf
argument_list|)
expr_stmt|;
name|ltbuf
operator|.
name|t_suspc
operator|=
name|oldswitch
expr_stmt|;
name|ltbuf
operator|.
name|t_lnextc
operator|=
name|oldquote
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|OSK
name|_ss_opt
argument_list|(
literal|0
argument_list|,
operator|&
name|oldsgttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curses_active
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|resume_curses
parameter_list|(
name|quietly
parameter_list|)
name|int
name|quietly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|curses_active
condition|)
block|{
comment|/* change the terminal mode to cbreak/noecho */
if|#
directive|if
name|ANY_UNIX
if|#
directive|if
name|UNIXV
name|ospeed
operator|=
operator|(
name|oldtermio
operator|.
name|c_cflag
operator|&
name|CBAUD
operator|)
expr_stmt|;
name|ERASEKEY
operator|=
name|oldtermio
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|newtermio
operator|=
name|oldtermio
expr_stmt|;
name|newtermio
operator|.
name|c_iflag
operator|&=
operator|(
name|IXON
operator||
name|IXOFF
operator||
name|IXANY
operator||
name|ISTRIP
operator||
name|IGNBRK
operator|)
expr_stmt|;
name|newtermio
operator|.
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
name|newtermio
operator|.
name|c_lflag
operator|&=
name|ISIG
expr_stmt|;
name|newtermio
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|ctrl
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
comment|/* always use ^C for interrupts */
name|newtermio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|newtermio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VSWTCH
name|newtermio
operator|.
name|c_cc
index|[
name|VSWTCH
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|newtermio
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* BSD or V7 or Coherent or Minix */
name|struct
name|tchars
name|tbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
name|struct
name|ltchars
name|ltbuf
decl_stmt|;
endif|#
directive|endif
name|ospeed
operator|=
name|oldsgttyb
operator|.
name|sg_ospeed
expr_stmt|;
name|ERASEKEY
operator|=
name|oldsgttyb
operator|.
name|sg_erase
expr_stmt|;
name|newsgttyb
operator|=
name|oldsgttyb
expr_stmt|;
name|newsgttyb
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|newsgttyb
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|CRMOD
operator||
name|ECHO
operator||
name|XTABS
operator|)
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|newsgttyb
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tbuf
argument_list|)
expr_stmt|;
name|oldint
operator|=
name|tbuf
operator|.
name|t_intrc
expr_stmt|;
name|tbuf
operator|.
name|t_intrc
operator|=
name|ctrl
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
comment|/* always use ^C for interrupts */
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltbuf
argument_list|)
expr_stmt|;
name|oldswitch
operator|=
name|ltbuf
operator|.
name|t_suspc
expr_stmt|;
name|ltbuf
operator|.
name|t_suspc
operator|=
literal|0
expr_stmt|;
comment|/* disable ^Z for elvis */
name|oldquote
operator|=
name|ltbuf
operator|.
name|t_lnextc
expr_stmt|;
name|ltbuf
operator|.
name|t_lnextc
operator|=
literal|0
expr_stmt|;
comment|/* disable ^V for elvis */
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|OSK
name|newsgttyb
operator|=
name|oldsgttyb
expr_stmt|;
name|newsgttyb
operator|.
name|sg_echo
operator|=
literal|0
expr_stmt|;
name|newsgttyb
operator|.
name|sg_eofch
operator|=
literal|0
expr_stmt|;
name|newsgttyb
operator|.
name|sg_kbach
operator|=
literal|0
expr_stmt|;
name|newsgttyb
operator|.
name|sg_kbich
operator|=
name|ctrl
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
name|_ss_opt
argument_list|(
literal|0
argument_list|,
operator|&
name|newsgttyb
argument_list|)
expr_stmt|;
name|ospeed
operator|=
name|oldsgttyb
operator|.
name|sg_baud
expr_stmt|;
name|ERASEKEY
operator|=
name|oldsgttyb
operator|.
name|sg_bspch
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|has_TI
condition|)
comment|/* GB */
block|{
name|do_TI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|has_KS
condition|)
block|{
name|do_KS
argument_list|()
expr_stmt|;
block|}
name|curses_active
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If we're supposed to quit quietly, then we're done */
if|if
condition|(
name|quietly
condition|)
block|{
return|return;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_SO
argument_list|()
expr_stmt|;
name|qaddstr
argument_list|(
literal|"[Press<RETURN> to continue]"
argument_list|)
expr_stmt|;
name|do_SE
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|ttyread
argument_list|(
name|kbuf
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* in RAW mode, so<20 is very likely */
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|mode
operator|=
name|MODE_COLON
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|MODE_VI
expr_stmt|;
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|exwrote
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|TURBOC
name|signal
argument_list|(
name|SIGINT
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|trapint
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|lacking
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"This termcap entry lacks the :"
argument_list|,
operator|(
name|unsigned
operator|)
literal|30
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|s
argument_list|,
operator|(
name|unsigned
operator|)
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"=: capability\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|14
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|write
argument_list|(
literal|2
argument_list|,
literal|"\l"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|starttcap
parameter_list|()
block|{
name|char
modifier|*
name|str
decl_stmt|;
specifier|static
name|char
name|cbmem
index|[
literal|800
index|]
decl_stmt|;
define|#
directive|define
name|MUSTHAVE
parameter_list|(
name|T
parameter_list|,
name|s
parameter_list|)
value|if (!(T = tgetstr(s,&capbuf))) lacking(s)
define|#
directive|define
name|MAYHAVE
parameter_list|(
name|T
parameter_list|,
name|s
parameter_list|)
value|if (str = tgetstr(s,&capbuf)) T = str
define|#
directive|define
name|PAIR
parameter_list|(
name|T
parameter_list|,
name|U
parameter_list|,
name|sT
parameter_list|,
name|sU
parameter_list|)
value|T=tgetstr(sT,&capbuf);U=tgetstr(sU,&capbuf);if (!T||!U)T=U=""
comment|/* allocate memory for capbuf */
name|capbuf
operator|=
name|cbmem
expr_stmt|;
comment|/* get the termcap entry */
switch|switch
condition|(
name|tgetent
argument_list|(
name|kbuf
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|write
argument_list|(
literal|2
argument_list|,
literal|"Can't read /etc/termcap\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|24
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|write
argument_list|(
literal|2
argument_list|,
literal|"\l"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|write
argument_list|(
literal|2
argument_list|,
literal|"Unrecognized TERM type\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|23
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|write
argument_list|(
literal|2
argument_list|,
literal|"\l"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* get strings */
name|MUSTHAVE
argument_list|(
name|UP
argument_list|,
literal|"up"
argument_list|)
expr_stmt|;
name|MAYHAVE
argument_list|(
name|VB
argument_list|,
literal|"vb"
argument_list|)
expr_stmt|;
name|MUSTHAVE
argument_list|(
name|CM
argument_list|,
literal|"cm"
argument_list|)
expr_stmt|;
name|PAIR
argument_list|(
name|SO
argument_list|,
name|SE
argument_list|,
literal|"so"
argument_list|,
literal|"se"
argument_list|)
expr_stmt|;
name|PAIR
argument_list|(
name|TI
argument_list|,
name|TE
argument_list|,
literal|"ti"
argument_list|,
literal|"te"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|PAIR
argument_list|(
name|US
argument_list|,
name|UE
argument_list|,
literal|"us"
argument_list|,
literal|"ue"
argument_list|)
expr_stmt|;
name|PAIR
argument_list|(
name|MD
argument_list|,
name|ME
argument_list|,
literal|"md"
argument_list|,
literal|"me"
argument_list|)
expr_stmt|;
comment|/* get italics, or have it default to underline */
name|PAIR
argument_list|(
name|AS
argument_list|,
name|AE
argument_list|,
literal|"as"
argument_list|,
literal|"ae"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|AS
condition|)
block|{
name|AS
operator|=
name|US
expr_stmt|;
name|AE
operator|=
name|UE
expr_stmt|;
block|}
block|}
name|MAYHAVE
argument_list|(
name|AL
argument_list|,
literal|"al"
argument_list|)
expr_stmt|;
name|MAYHAVE
argument_list|(
name|DL
argument_list|,
literal|"dl"
argument_list|)
expr_stmt|;
name|MUSTHAVE
argument_list|(
name|CE
argument_list|,
literal|"ce"
argument_list|)
expr_stmt|;
name|MAYHAVE
argument_list|(
name|CD
argument_list|,
literal|"cd"
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|MAYHAVE
argument_list|(
name|SR_
argument_list|,
literal|"sr"
argument_list|)
expr_stmt|;
else|#
directive|else
name|MAYHAVE
argument_list|(
name|SR
argument_list|,
literal|"sr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PAIR
argument_list|(
name|IM
argument_list|,
name|EI
argument_list|,
literal|"im"
argument_list|,
literal|"ei"
argument_list|)
expr_stmt|;
name|MAYHAVE
argument_list|(
name|IC
argument_list|,
literal|"ic"
argument_list|)
expr_stmt|;
name|MAYHAVE
argument_list|(
name|DC
argument_list|,
literal|"dc"
argument_list|)
expr_stmt|;
comment|/* other termcap stuff */
name|AM
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
name|PT
operator|=
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
expr_stmt|;
name|getsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Key sequences */
name|PAIR
argument_list|(
name|KS
argument_list|,
name|KE
argument_list|,
literal|"ks"
argument_list|,
literal|"ke"
argument_list|)
expr_stmt|;
name|MAYHAVE
argument_list|(
name|KU
argument_list|,
literal|"ku"
argument_list|)
expr_stmt|;
comment|/* up */
name|MAYHAVE
argument_list|(
name|KD
argument_list|,
literal|"kd"
argument_list|)
expr_stmt|;
comment|/* down */
name|MAYHAVE
argument_list|(
name|KL
argument_list|,
literal|"kl"
argument_list|)
expr_stmt|;
comment|/* left */
name|MAYHAVE
argument_list|(
name|KR
argument_list|,
literal|"kr"
argument_list|)
expr_stmt|;
comment|/* right */
name|MAYHAVE
argument_list|(
name|PU
argument_list|,
literal|"kP"
argument_list|)
expr_stmt|;
comment|/* PgUp */
name|MAYHAVE
argument_list|(
name|PD
argument_list|,
literal|"kN"
argument_list|)
expr_stmt|;
comment|/* PgDn */
name|MAYHAVE
argument_list|(
name|HM
argument_list|,
literal|"kh"
argument_list|)
expr_stmt|;
comment|/* Home */
name|MAYHAVE
argument_list|(
name|EN
argument_list|,
literal|"kH"
argument_list|)
expr_stmt|;
comment|/* End */
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
operator|!
name|PU
condition|)
name|MAYHAVE
argument_list|(
name|PU
argument_list|,
literal|"K2"
argument_list|)
expr_stmt|;
comment|/* "3x3 pad" names for PgUp, etc. */
if|if
condition|(
operator|!
name|PD
condition|)
name|MAYHAVE
argument_list|(
name|PD
argument_list|,
literal|"K5"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HM
condition|)
name|MAYHAVE
argument_list|(
name|HM
argument_list|,
literal|"K1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EN
condition|)
name|MAYHAVE
argument_list|(
name|EN
argument_list|,
literal|"K4"
argument_list|)
expr_stmt|;
name|MAYHAVE
argument_list|(
name|PU
argument_list|,
literal|"PU"
argument_list|)
expr_stmt|;
comment|/* old XENIX names for PgUp, etc. */
name|MAYHAVE
argument_list|(
name|PD
argument_list|,
literal|"PD"
argument_list|)
expr_stmt|;
comment|/* (overrides others, if used.) */
name|MAYHAVE
argument_list|(
name|HM
argument_list|,
literal|"HM"
argument_list|)
expr_stmt|;
name|MAYHAVE
argument_list|(
name|EN
argument_list|,
literal|"EN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
comment|/* cursor shapes */
name|CQ
operator|=
name|tgetstr
argument_list|(
literal|"cQ"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_CQ
condition|)
block|{
name|CX
operator|=
name|tgetstr
argument_list|(
literal|"cX"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CX
condition|)
name|CX
operator|=
name|CQ
expr_stmt|;
name|CV
operator|=
name|tgetstr
argument_list|(
literal|"cV"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CV
condition|)
name|CV
operator|=
name|CQ
expr_stmt|;
name|CI
operator|=
name|tgetstr
argument_list|(
literal|"cI"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CI
condition|)
name|CI
operator|=
name|CQ
expr_stmt|;
name|CR
operator|=
name|tgetstr
argument_list|(
literal|"cR"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CR
condition|)
name|CR
operator|=
name|CQ
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
else|else
block|{
name|PAIR
argument_list|(
name|CQ
argument_list|,
name|CV
argument_list|,
literal|"ve"
argument_list|,
literal|"vs"
argument_list|)
expr_stmt|;
name|CX
operator|=
name|CI
operator|=
name|CR
operator|=
name|CQ
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !CRUNCH */
endif|#
directive|endif
comment|/* !NO_CURSORSHAPE */
undef|#
directive|undef
name|MUSTHAVE
undef|#
directive|undef
name|MAYHAVE
undef|#
directive|undef
name|PAIR
block|}
end_function

begin_comment
comment|/* This function gets the window size.  It uses the TIOCGWINSZ ioctl call if  * your system has it, or tgetnum("li") and tgetnum("co") if it doesn't.  * This function is called once during initialization, and thereafter it is  * called whenever the SIGWINCH signal is sent to this process.  */
end_comment

begin_function
name|int
name|getsize
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|int
name|lines
decl_stmt|;
name|int
name|cols
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|size
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGWINCH
comment|/* reset the signal vector */
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|getsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get the window size, one way or another. */
name|lines
operator|=
name|cols
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|size
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|lines
operator|=
name|size
operator|.
name|ws_row
expr_stmt|;
name|cols
operator|=
name|size
operator|.
name|ws_col
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|lines
operator|==
literal|0
operator|||
name|cols
operator|==
literal|0
operator|)
operator|&&
name|signo
operator|==
literal|0
condition|)
block|{
name|LINES
operator|=
name|CHECKBIOS
argument_list|(
name|v_rows
argument_list|()
argument_list|,
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
argument_list|)
expr_stmt|;
name|COLS
operator|=
name|CHECKBIOS
argument_list|(
name|v_cols
argument_list|()
argument_list|,
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lines
operator|>=
literal|2
operator|&&
name|cols
operator|>=
literal|30
condition|)
block|{
name|LINES
operator|=
name|lines
expr_stmt|;
name|COLS
operator|=
name|cols
expr_stmt|;
block|}
comment|/* Make sure we got values that we can live with */
if|if
condition|(
name|LINES
operator|<
literal|2
operator|||
name|COLS
operator|<
literal|30
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Screen too small\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|17
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|write
argument_list|(
literal|2
argument_list|,
literal|"\l"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* !!! copy the new values into Elvis' options */
block|{
specifier|extern
name|char
name|o_columns
index|[]
decl_stmt|,
name|o_lines
index|[]
decl_stmt|;
operator|*
name|o_columns
operator|=
name|COLS
expr_stmt|;
operator|*
name|o_lines
operator|=
name|LINES
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is a function version of addch() -- it is used by tputs() */
end_comment

begin_function
name|int
name|faddch
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* These functions are equivelent to the macros of the same names... */
end_comment

begin_function
name|void
name|qaddstr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|REG
name|char
modifier|*
name|s_
decl_stmt|,
modifier|*
name|d_
decl_stmt|;
if|#
directive|if
name|MSDOS
if|if
condition|(
name|o_pcbios
index|[
literal|0
index|]
condition|)
block|{
while|while
condition|(
operator|*
name|str
condition|)
name|qaddch
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|s_
operator|=
operator|(
name|str
operator|)
operator|,
name|d_
operator|=
name|stdscr
init|;
operator|*
name|d_
operator|++
operator|=
operator|*
name|s_
operator|++
condition|;
control|)
block|{ 	}
name|stdscr
operator|=
name|d_
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|attrset
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
name|do_aend
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|A_BOLD
condition|)
block|{
name|do_MD
argument_list|()
expr_stmt|;
name|aend
operator|=
name|ME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|A_UNDERLINE
condition|)
block|{
name|do_US
argument_list|()
expr_stmt|;
name|aend
operator|=
name|UE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|A_ALTCHARSET
condition|)
block|{
name|do_AS
argument_list|()
expr_stmt|;
name|aend
operator|=
name|AE
expr_stmt|;
block|}
else|else
block|{
name|aend
operator|=
literal|""
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|insch
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|has_IM
condition|)
name|do_IM
argument_list|()
expr_stmt|;
name|do_IC
argument_list|()
expr_stmt|;
name|qaddch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_EI
condition|)
name|do_EI
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_decl_stmt
specifier|static
name|int
name|alarmtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw read - #defined to read (0, ...) on non-MSDOS.  * With MSDOS, am maximum of 1 byte is read.  * If more bytes should be read, just change the loop.  * The following code uses the IBM-PC-System-Timer, so probably wont't work  * on non-compatibles.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|ttyread
argument_list|(
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|volatile
name|char
name|far
modifier|*
name|biostimer
decl_stmt|;
name|char
name|oldtime
decl_stmt|;
name|int
name|nticks
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|biostimer
operator|=
operator|(
name|char
name|far
operator|*
operator|)
literal|0x0040006cl
expr_stmt|;
name|oldtime
operator|=
operator|*
name|biostimer
expr_stmt|;
while|while
condition|(
operator|!
name|pos
operator|&&
operator|(
operator|!
name|alarmtime
operator|||
name|nticks
operator|<
name|alarmtime
operator|)
condition|)
block|{
if|if
condition|(
name|kbhit
argument_list|()
condition|)
if|if
condition|(
operator|(
name|buf
index|[
name|pos
operator|++
index|]
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|0
condition|)
comment|/* function key */
name|buf
index|[
name|pos
operator|-
literal|1
index|]
operator|=
literal|'#'
expr_stmt|;
if|if
condition|(
name|oldtime
operator|!=
operator|*
name|biostimer
condition|)
block|{
name|nticks
operator|++
expr_stmt|;
name|oldtime
operator|=
operator|*
name|biostimer
expr_stmt|;
block|}
block|}
return|return
name|pos
return|;
block|}
end_block

begin_macro
name|alarm
argument_list|(
argument|time
argument_list|)
end_macro

begin_decl_stmt
name|int
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|alarmtime
operator|=
literal|2
operator|*
name|time
expr_stmt|;
comment|/* ticks are 1/18 sec. */
block|}
end_block

begin_macro
name|sleep
argument_list|(
argument|seconds
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|seconds
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|volatile
name|char
name|far
modifier|*
name|biostimer
init|=
operator|(
name|char
name|far
operator|*
operator|)
literal|0x0040006cl
decl_stmt|;
name|char
name|stop
decl_stmt|;
name|stop
operator|=
operator|*
name|biostimer
operator|+
literal|18
operator|*
name|seconds
expr_stmt|;
while|while
condition|(
operator|*
name|biostimer
operator|!=
name|stop
condition|)
block|{ 	}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TOS
end_if

begin_decl_stmt
specifier|static
name|int
name|alarmtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|timer
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|gettime
argument_list|()
block|{
name|timer
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
literal|0x4ba
operator|)
block|; }
comment|/*ARGSUSED*/
name|ttyread
argument_list|(
argument|buf
argument_list|,
argument|len
argument_list|)
name|char
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|long
name|l
decl_stmt|;
name|long
name|endtime
decl_stmt|;
name|Supexec
argument_list|(
name|gettime
argument_list|)
expr_stmt|;
name|endtime
operator|=
name|timer
operator|+
name|alarmtime
expr_stmt|;
while|while
condition|(
operator|!
name|pos
operator|&&
operator|(
operator|!
name|alarmtime
operator|||
name|timer
operator|<
name|endtime
operator|)
condition|)
block|{
if|if
condition|(
name|Bconstat
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|l
operator|=
name|Bconin
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
name|pos
operator|++
index|]
operator|=
name|l
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|buf
index|[
name|pos
operator|-
literal|1
index|]
operator|=
literal|'#'
expr_stmt|;
name|buf
index|[
name|pos
operator|++
index|]
operator|=
name|l
operator|>>
literal|16
expr_stmt|;
block|}
block|}
name|Supexec
argument_list|(
name|gettime
argument_list|)
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
end_block

begin_macro
name|alarm
argument_list|(
argument|time
argument_list|)
end_macro

begin_decl_stmt
name|int
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|alarmtime
operator|=
literal|50
operator|*
name|time
expr_stmt|;
comment|/* ticks are 1/200 sec. */
block|}
end_block

begin_macro
name|ttywrite
argument_list|(
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|len
operator|--
condition|)
name|Bconout
argument_list|(
literal|2
argument_list|,
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|OSK
end_if

begin_macro
name|ttyread
argument_list|(
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REG
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|_gs_rdy
argument_list|(
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|i
operator|<
name|len
condition|?
name|i
else|:
name|len
argument_list|)
return|;
else|else
return|return
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|alarm
argument_list|(
argument|time
argument_list|)
end_macro

begin_decl_stmt
name|int
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|TIME
parameter_list|(
name|secs
parameter_list|)
value|((secs<< 8) | 0x80000000)
specifier|static
name|int
name|alrmid
decl_stmt|;
if|if
condition|(
name|time
condition|)
name|alrmid
operator|=
name|alm_set
argument_list|(
name|SIGQUIT
argument_list|,
name|TIME
argument_list|(
name|time
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|alm_delete
argument_list|(
name|alrmid
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSK */
end_comment

end_unit

