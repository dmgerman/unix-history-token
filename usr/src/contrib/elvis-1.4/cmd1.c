begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cmd1.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains some of the EX commands - mostly ones that deal with  * files, options, etc. -- anything except text.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"regexp.h"
end_include

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_define
define|#
directive|define
name|DATE
value|__DATE__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* print the selected lines with info on the blocks */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_debug
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
name|REG
name|long
name|l
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* scan lnum[] to determine which block its in */
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|l
operator|>
name|lnum
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{ 	}
do|do
block|{
comment|/* fetch text of the block containing that line */
name|scan
operator|=
name|blkget
argument_list|(
name|i
argument_list|)
operator|->
name|c
expr_stmt|;
comment|/* calculate its length */
if|if
condition|(
name|scan
index|[
name|BLKSIZE
operator|-
literal|1
index|]
condition|)
block|{
name|len
operator|=
name|BLKSIZE
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
comment|/* print block stats */
name|msg
argument_list|(
literal|"##### hdr[%d]=%d, lnum[%d-1]=%ld, lnum[%d]=%ld (%ld lines)"
argument_list|,
name|i
argument_list|,
name|hdr
operator|.
name|n
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|lnum
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|i
argument_list|,
name|lnum
index|[
name|i
index|]
argument_list|,
name|lnum
index|[
name|i
index|]
operator|-
name|lnum
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"##### len=%d, buf=0x%lx, %sdirty"
argument_list|,
name|len
argument_list|,
name|scan
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|scan
operator|)
index|[
name|MAXBLKS
operator|+
literal|1
index|]
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bang
condition|)
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|addch
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
block|}
name|exrefresh
argument_list|()
expr_stmt|;
comment|/* next block */
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|MAXBLKS
operator|&&
name|lnum
index|[
name|i
index|]
operator|&&
name|lnum
index|[
name|i
operator|-
literal|1
index|]
operator|<
name|markline
argument_list|(
name|tomark
argument_list|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/* This function checks a lot of conditions to make sure they aren't screwy */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_validate
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nlcnt
decl_stmt|;
comment|/* used to count newlines */
name|int
name|len
decl_stmt|;
comment|/* counts non-NUL characters */
comment|/* check lnum[0] */
if|if
condition|(
name|lnum
index|[
literal|0
index|]
operator|!=
literal|0L
condition|)
block|{
name|msg
argument_list|(
literal|"lnum[0] = %ld"
argument_list|,
name|lnum
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* check each block */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|lnum
index|[
name|i
index|]
operator|<=
name|nlines
condition|;
name|i
operator|++
control|)
block|{
name|scan
operator|=
name|blkget
argument_list|(
name|i
argument_list|)
operator|->
name|c
expr_stmt|;
if|if
condition|(
name|scan
index|[
name|BLKSIZE
operator|-
literal|1
index|]
condition|)
block|{
name|msg
argument_list|(
literal|"block %d has no NUL at the end"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|nlcnt
operator|=
name|len
operator|=
literal|0
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
operator|,
name|len
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\n'
condition|)
block|{
name|nlcnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scan
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|msg
argument_list|(
literal|"block %d doesn't end with '\\n' (length %d)"
argument_list|,
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bang
operator|||
name|nlcnt
operator|!=
name|lnum
index|[
name|i
index|]
operator|-
name|lnum
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
name|msg
argument_list|(
literal|"block %d (line %ld?) has %d lines, but should have %ld"
argument_list|,
name|i
argument_list|,
name|lnum
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1L
argument_list|,
name|nlcnt
argument_list|,
name|lnum
index|[
name|i
index|]
operator|-
name|lnum
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|exrefresh
argument_list|()
expr_stmt|;
block|}
comment|/* check lnum again */
if|if
condition|(
name|lnum
index|[
name|i
index|]
operator|!=
name|INFINITY
condition|)
block|{
name|msg
argument_list|(
literal|"hdr.n[%d] = %d, but lnum[%d] = %ld"
argument_list|,
name|i
argument_list|,
name|hdr
operator|.
name|n
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|lnum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|msg
argument_list|(
literal|"# = \"%s\", %% = \"%s\""
argument_list|,
name|prevorig
argument_list|,
name|origname
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_mark
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
comment|/* validate the name of the mark */
if|if
condition|(
operator|!
name|extra
operator|||
operator|*
name|extra
operator|<
literal|'a'
operator|||
operator|*
name|extra
operator|>
literal|'z'
operator|||
name|extra
index|[
literal|1
index|]
condition|)
block|{
name|msg
argument_list|(
literal|"Invalid mark name"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mark
index|[
operator|*
name|extra
operator|-
literal|'a'
index|]
operator|=
name|tomark
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_write
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|int
name|append
decl_stmt|;
comment|/* boolean: write in "append" mode? */
name|REG
name|long
name|l
decl_stmt|;
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
comment|/* if all lines are to be written, use tmpsave() */
if|if
condition|(
name|frommark
operator|==
name|MARK_FIRST
operator|&&
name|tomark
operator|==
name|MARK_LAST
condition|)
block|{
name|tmpsave
argument_list|(
name|extra
argument_list|,
name|bang
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* see if we're going to do this in append mode or not */
name|append
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|extra
index|[
literal|0
index|]
operator|==
literal|'>'
operator|&&
name|extra
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
name|extra
operator|+=
literal|2
expr_stmt|;
name|append
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* either the file must not exist, or we must have a ! or be appending */
if|if
condition|(
name|access
argument_list|(
name|extra
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|bang
operator|&&
operator|!
name|append
condition|)
block|{
name|msg
argument_list|(
literal|"File already exists - Use :w! to overwrite"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else do it line-by-line, like cmd_print() */
if|if
condition|(
name|append
condition|)
block|{
ifdef|#
directive|ifdef
name|O_APPEND
name|fd
operator|=
name|open
argument_list|(
name|extra
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
expr_stmt|;
else|#
directive|else
name|fd
operator|=
name|open
argument_list|(
name|extra
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* so we know the file isn't open yet */
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fd
operator|=
name|creat
argument_list|(
name|extra
argument_list|,
name|FILEPERMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't write to \"%s\""
argument_list|,
name|extra
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|l
operator|=
name|markline
argument_list|(
name|frommark
argument_list|)
init|;
name|l
operator|<=
name|markline
argument_list|(
name|tomark
argument_list|)
condition|;
name|l
operator|++
control|)
block|{
comment|/* get the next line */
name|scan
operator|=
name|fetchline
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
index|[
name|i
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* print the line */
name|twrite
argument_list|(
name|fd
argument_list|,
name|scan
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_shell
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
specifier|static
name|char
name|prevextra
index|[
literal|80
index|]
decl_stmt|;
comment|/* special case: ":sh" means ":!sh" */
if|if
condition|(
name|cmd
operator|==
name|CMD_SHELL
condition|)
block|{
name|extra
operator|=
name|o_shell
expr_stmt|;
name|frommark
operator|=
name|tomark
operator|=
literal|0L
expr_stmt|;
block|}
comment|/* if extra is "!", substute previous command */
if|if
condition|(
operator|*
name|extra
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|prevextra
condition|)
block|{
name|msg
argument_list|(
literal|"No previous shell command to substitute for '!'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|extra
operator|=
name|prevextra
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|CMD_BANG
operator|&&
name|strlen
argument_list|(
name|extra
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|prevextra
argument_list|)
operator|-
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|prevextra
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* if no lines were specified, just run the command */
name|suspend_curses
argument_list|()
expr_stmt|;
if|if
condition|(
name|frommark
operator|==
literal|0L
condition|)
block|{
name|system
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* pipe lines from the file through the command */
block|{
name|filter
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* resume curses quietly for MODE_EX, but noisily otherwise */
name|resume_curses
argument_list|(
name|mode
operator|==
name|MODE_EX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_global
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
comment|/* rest of the command line */
block|{
name|char
modifier|*
name|cmdptr
decl_stmt|;
comment|/* the command from the command line */
name|char
name|cmdln
index|[
literal|100
index|]
decl_stmt|;
comment|/* copy of the command from the command line */
name|char
modifier|*
name|line
decl_stmt|;
comment|/* a line from the file */
name|long
name|l
decl_stmt|;
comment|/* used as a counter to move through lines */
name|long
name|lqty
decl_stmt|;
comment|/* quantity of lines to be scanned */
name|long
name|nchanged
decl_stmt|;
comment|/* number of lines changed */
name|regexp
modifier|*
name|re
decl_stmt|;
comment|/* the compiled search expression */
comment|/* can't nest global commands */
if|if
condition|(
name|doingglobal
condition|)
block|{
name|msg
argument_list|(
literal|"Can't nest global commands."
argument_list|)
expr_stmt|;
name|rptlines
operator|=
operator|-
literal|1L
expr_stmt|;
return|return;
block|}
comment|/* ":g! ..." is the same as ":v ..." */
if|if
condition|(
name|bang
condition|)
block|{
name|cmd
operator|=
name|CMD_VGLOBAL
expr_stmt|;
block|}
comment|/* make sure we got a search pattern */
if|if
condition|(
operator|*
name|extra
operator|!=
literal|'/'
operator|&&
operator|*
name|extra
operator|!=
literal|'?'
condition|)
block|{
name|msg
argument_list|(
literal|"Usage: %c /regular expression/ command"
argument_list|,
name|cmd
operator|==
name|CMD_GLOBAL
condition|?
literal|'g'
else|:
literal|'v'
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* parse& compile the search pattern */
name|cmdptr
operator|=
name|parseptrn
argument_list|(
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extra
index|[
literal|1
index|]
condition|)
block|{
name|msg
argument_list|(
literal|"Can't use empty regular expression with '%c' command"
argument_list|,
name|cmd
operator|==
name|CMD_GLOBAL
condition|?
literal|'g'
else|:
literal|'v'
argument_list|)
expr_stmt|;
return|return;
block|}
name|re
operator|=
name|regcomp
argument_list|(
name|extra
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|re
condition|)
block|{
comment|/* regcomp found& described an error */
return|return;
block|}
comment|/* for each line in the range */
name|doingglobal
operator|=
name|TRUE
expr_stmt|;
name|ChangeText
block|{
comment|/* NOTE: we have to go through the lines in a forward order, 		 * otherwise "g/re/p" would look funny.  *BUT* for "g/re/d" 		 * to work, simply adding 1 to the line# on each loop won't 		 * work.  The solution: count lines relative to the end of 		 * the file.  Think about it. 		 */
for|for
control|(
name|l
operator|=
name|nlines
operator|-
name|markline
argument_list|(
name|frommark
argument_list|)
operator|,
name|lqty
operator|=
name|markline
argument_list|(
name|tomark
argument_list|)
operator|-
name|markline
argument_list|(
name|frommark
argument_list|)
operator|+
literal|1L
operator|,
name|nchanged
operator|=
literal|0L
init|;
name|lqty
operator|>
literal|0
operator|&&
name|nlines
operator|-
name|l
operator|>=
literal|0
operator|&&
name|nchanged
operator|>=
literal|0L
condition|;
name|l
operator|--
operator|,
name|lqty
operator|--
control|)
block|{
comment|/* fetch the line */
name|line
operator|=
name|fetchline
argument_list|(
name|nlines
operator|-
name|l
argument_list|)
expr_stmt|;
comment|/* if it contains the search pattern... */
if|if
condition|(
operator|(
operator|!
name|regexec
argument_list|(
name|re
argument_list|,
name|line
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
operator|(
name|cmd
operator|!=
name|CMD_GLOBAL
operator|)
condition|)
block|{
comment|/* move the cursor to that line */
name|cursor
operator|=
name|MARK_AT_LINE
argument_list|(
name|nlines
operator|-
name|l
argument_list|)
expr_stmt|;
comment|/* do the ex command (without mucking up 				 * the original copy of the command line) 				 */
name|strcpy
argument_list|(
name|cmdln
argument_list|,
name|cmdptr
argument_list|)
expr_stmt|;
name|rptlines
operator|=
literal|0L
expr_stmt|;
name|doexcmd
argument_list|(
name|cmdln
argument_list|)
expr_stmt|;
name|nchanged
operator|+=
name|rptlines
expr_stmt|;
block|}
block|}
block|}
name|doingglobal
operator|=
name|FALSE
expr_stmt|;
comment|/* free the regexp */
name|free
argument_list|(
name|re
argument_list|)
expr_stmt|;
comment|/* Reporting...*/
name|rptlines
operator|=
name|nchanged
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_file
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* if we're given a new filename, use it as this file's name */
if|if
condition|(
name|extra
operator|&&
operator|*
name|extra
condition|)
block|{
name|strcpy
argument_list|(
name|origname
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|==
name|CMD_FILE
condition|)
block|{
name|msg
argument_list|(
literal|"\"%s\" %s%s %ld lines,  line %ld [%ld%%]"
argument_list|,
operator|*
name|origname
condition|?
name|origname
else|:
literal|"[NO FILE]"
argument_list|,
name|tstflag
argument_list|(
name|file
argument_list|,
name|MODIFIED
argument_list|)
condition|?
literal|"[MODIFIED]"
else|:
literal|""
argument_list|,
name|tstflag
argument_list|(
name|file
argument_list|,
name|READONLY
argument_list|)
condition|?
literal|"[READONLY]"
else|:
literal|""
argument_list|,
name|nlines
argument_list|,
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|frommark
argument_list|)
operator|*
literal|100
operator|/
name|nlines
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|markline
argument_list|(
name|frommark
argument_list|)
operator|==
name|markline
argument_list|(
name|tomark
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"%ld"
argument_list|,
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"range \"%ld,%ld\" contains %ld lines"
argument_list|,
name|markline
argument_list|(
name|frommark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|tomark
argument_list|)
argument_list|,
name|markline
argument_list|(
name|tomark
argument_list|)
operator|-
name|markline
argument_list|(
name|frommark
argument_list|)
operator|+
literal|1L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_edit
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|long
name|line
init|=
literal|1L
decl_stmt|;
comment|/* might be set to prevline */
comment|/* Editing previous file?  Then start at previous line */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|extra
argument_list|,
name|prevorig
argument_list|)
condition|)
block|{
name|line
operator|=
name|prevline
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* if we were given an explicit starting line, then start there */
if|if
condition|(
operator|*
name|extra
operator|==
literal|'+'
condition|)
block|{
for|for
control|(
name|extra
operator|++
operator|,
name|line
operator|=
literal|0L
init|;
operator|*
name|extra
operator|>=
literal|'0'
operator|&&
operator|*
name|extra
operator|<=
literal|'9'
condition|;
name|extra
operator|++
control|)
block|{
name|line
operator|*=
literal|10L
expr_stmt|;
name|line
operator|+=
operator|(
operator|*
name|extra
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|extra
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|extra
argument_list|)
condition|)
block|{
name|extra
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
comment|/* switch files */
if|if
condition|(
name|tmpabort
argument_list|(
name|bang
argument_list|)
condition|)
block|{
name|tmpstart
argument_list|(
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<=
name|nlines
operator|&&
name|line
operator|>=
literal|1L
condition|)
block|{
name|cursor
operator|=
name|MARK_AT_LINE
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|msg
argument_list|(
literal|"Use edit! to abort changes, or w to save changes"
argument_list|)
expr_stmt|;
comment|/* so we can say ":e!#" next time... */
name|strcpy
argument_list|(
name|prevorig
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|prevline
operator|=
literal|1L
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This code is also used for rewind -- GB */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_next
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|build
decl_stmt|;
comment|/* if extra stuff given, use ":args" to define a new args list */
if|if
condition|(
name|cmd
operator|==
name|CMD_NEXT
operator|&&
name|extra
operator|&&
operator|*
name|extra
condition|)
block|{
name|cmd_args
argument_list|(
name|frommark
argument_list|,
name|tomark
argument_list|,
name|cmd
argument_list|,
name|bang
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* move to the next arg */
if|if
condition|(
name|cmd
operator|==
name|CMD_NEXT
condition|)
block|{
name|i
operator|=
name|argno
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|CMD_PREVIOUS
condition|)
block|{
name|i
operator|=
name|argno
operator|-
literal|1
expr_stmt|;
block|}
else|else
comment|/* cmd == CMD_REWIND */
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|nargs
condition|)
block|{
name|msg
argument_list|(
literal|"No %sfiles to edit"
argument_list|,
name|cmd
operator|==
name|CMD_REWIND
condition|?
literal|""
else|:
literal|"more "
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* find& isolate the name of the file to edit */
for|for
control|(
name|j
operator|=
name|i
operator|,
name|scan
operator|=
name|args
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
while|while
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|scan
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|scan
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|build
operator|=
name|tmpblk
operator|.
name|c
init|;
operator|*
name|scan
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
operator|*
name|scan
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
operator|)
condition|;
control|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
operator|*
name|build
operator|=
literal|'\0'
expr_stmt|;
comment|/* switch to the next file */
if|if
condition|(
name|tmpabort
argument_list|(
name|bang
argument_list|)
condition|)
block|{
name|tmpstart
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|argno
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"Use :%s! to abort changes, or w to save changes"
argument_list|,
name|cmd
operator|==
name|CMD_NEXT
condition|?
literal|"next"
else|:
name|cmd
operator|==
name|CMD_PREVIOUS
condition|?
literal|"previous"
else|:
literal|"rewind"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* also called from :wq -- always writes back in this case */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_xit
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
specifier|static
name|long
name|whenwarned
decl_stmt|;
comment|/* when the user was last warned of extra files */
name|int
name|oldflag
decl_stmt|;
comment|/* if there are more files to edit, then warn user */
if|if
condition|(
name|argno
operator|+
literal|1
operator|<
name|nargs
operator|&&
name|whenwarned
operator|!=
name|changes
operator|&&
operator|(
operator|!
name|bang
operator|||
name|cmd
operator|!=
name|CMD_QUIT
operator|)
condition|)
block|{
name|msg
argument_list|(
literal|"More files to edit -- Use \":n\" to go to next file"
argument_list|)
expr_stmt|;
name|whenwarned
operator|=
name|changes
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cmd
operator|==
name|CMD_QUIT
condition|)
block|{
if|if
condition|(
name|tmpabort
argument_list|(
name|bang
argument_list|)
condition|)
block|{
name|mode
operator|=
name|MODE_QUIT
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"Use q! to abort changes, or wq to save changes"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* else try to save this file */
name|oldflag
operator|=
name|tstflag
argument_list|(
name|file
argument_list|,
name|MODIFIED
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CMD_WQUIT
condition|)
name|setflag
argument_list|(
name|file
argument_list|,
name|MODIFIED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpend
argument_list|(
name|bang
argument_list|)
condition|)
block|{
name|mode
operator|=
name|MODE_QUIT
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"Could not save file -- use quit! to abort changes, or w filename"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oldflag
condition|)
name|clrflag
argument_list|(
name|file
argument_list|,
name|MODIFIED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_args
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|eow
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|int
name|addcols
decl_stmt|;
name|int
name|scrolled
init|=
literal|0
decl_stmt|;
comment|/* if no extra names given, or just current name, then report the args 	 * we have now. 	 */
if|if
condition|(
operator|!
name|extra
operator|||
operator|!
operator|*
name|extra
condition|)
block|{
for|for
control|(
name|scan
operator|=
name|args
operator|,
name|col
operator|=
name|arg
operator|=
literal|0
init|;
operator|*
name|scan
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|scan
operator|&&
name|isascii
argument_list|(
operator|*
name|scan
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
name|eow
operator|=
name|scan
expr_stmt|;
while|while
condition|(
operator|*
name|eow
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
operator|*
operator|++
name|eow
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|eow
argument_list|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|arg
operator|==
name|argno
condition|)
name|addcols
operator|=
literal|2
expr_stmt|;
else|else
name|addcols
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|col
operator|+
name|addcols
operator|+
call|(
name|int
call|)
argument_list|(
name|eow
operator|-
name|scan
argument_list|)
operator|+
literal|1
operator|>=
name|COLS
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|scrolled
operator|=
literal|1
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
condition|)
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|argno
condition|)
name|qaddch
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|eow
condition|)
block|{
name|qaddch
argument_list|(
operator|*
name|scan
operator|++
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|argno
condition|)
name|qaddch
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|arg
operator|++
expr_stmt|;
name|col
operator|+=
name|addcols
expr_stmt|;
block|}
comment|/* write a trailing newline */
if|if
condition|(
operator|(
name|mode
operator|==
name|MODE_EX
operator|||
name|mode
operator|==
name|MODE_COLON
operator|||
name|scrolled
operator|)
operator|&&
name|col
condition|)
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* new args list given */
block|{
name|strcpy
argument_list|(
name|args
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|argno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* before the first, so :next will go to first */
comment|/* count the names */
for|for
control|(
name|nargs
operator|=
literal|0
operator|,
name|scan
operator|=
name|args
init|;
operator|*
name|scan
condition|;
name|nargs
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|scan
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
operator|*
name|scan
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
operator|)
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|scan
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
block|}
name|msg
argument_list|(
literal|"%d files to edit"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_cd
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
comment|/* default directory name is $HOME */
if|if
condition|(
operator|!
operator|*
name|extra
condition|)
block|{
name|extra
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extra
condition|)
block|{
name|msg
argument_list|(
literal|"environment variable $HOME not set"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* go to the directory */
if|if
condition|(
name|chdir
argument_list|(
name|extra
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_map
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|char
modifier|*
name|mapto
decl_stmt|;
comment|/* "map" with no extra will dump the map table contents */
if|if
condition|(
operator|!
operator|*
name|extra
condition|)
block|{
name|dumpkey
argument_list|(
name|bang
condition|?
name|WHEN_VIINP
operator||
name|WHEN_VIREP
else|:
name|WHEN_VICMD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "extra" is key to map, followed my what it maps to */
for|for
control|(
name|mapto
operator|=
name|extra
init|;
operator|*
name|mapto
operator|&&
operator|*
name|mapto
operator|!=
literal|' '
operator|&&
operator|*
name|mapto
operator|!=
literal|'\t'
condition|;
name|mapto
operator|++
control|)
block|{ 		}
while|while
condition|(
operator|*
name|mapto
operator|==
literal|' '
operator|||
operator|*
name|mapto
operator|==
literal|'\t'
condition|)
block|{
operator|*
name|mapto
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|mapkey
argument_list|(
name|extra
argument_list|,
name|mapto
argument_list|,
name|bang
condition|?
name|WHEN_VIINP
operator||
name|WHEN_VIREP
else|:
name|WHEN_VICMD
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_set
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|*
name|extra
condition|)
block|{
name|dumpopts
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* "FALSE" means "don't dump all" - only set */
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|extra
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|dumpopts
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* "TRUE" means "dump all" - even unset vars */
block|}
else|else
block|{
name|setopts
argument_list|(
name|extra
argument_list|)
expr_stmt|;
comment|/* That option may have affected the appearence of text */
name|changes
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_tag
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used to scan through the tmpblk.c */
name|char
modifier|*
name|cmp
decl_stmt|;
comment|/* char of tag name we're comparing, or NULL */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* marks the end of chars in tmpblk.c */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor used to read the file */
ifndef|#
directive|ifndef
name|NO_MAGIC
name|char
name|wasmagic
decl_stmt|;
comment|/* preserves the original state of o_magic */
endif|#
directive|endif
specifier|static
name|char
name|prevtag
index|[
literal|30
index|]
decl_stmt|;
comment|/* if no tag is given, use the previous tag */
if|if
condition|(
operator|!
name|extra
operator|||
operator|!
operator|*
name|extra
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|prevtag
condition|)
block|{
name|msg
argument_list|(
literal|"No previous tag"
argument_list|)
expr_stmt|;
return|return;
block|}
name|extra
operator|=
name|prevtag
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|prevtag
argument_list|,
name|extra
argument_list|,
sizeof|sizeof
name|prevtag
argument_list|)
expr_stmt|;
block|}
comment|/* open the tags file */
name|fd
operator|=
name|open
argument_list|(
name|TAGS
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"No tags file"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Hmmm... this would have been a lot easier with<stdio.h> */
comment|/* find the line with our tag in it */
for|for
control|(
name|scan
operator|=
name|end
operator|=
name|tmpblk
operator|.
name|c
operator|,
name|cmp
operator|=
name|extra
init|;
condition|;
name|scan
operator|++
control|)
block|{
comment|/* read a block, if necessary */
if|if
condition|(
name|scan
operator|>=
name|end
condition|)
block|{
name|end
operator|=
name|tmpblk
operator|.
name|c
operator|+
name|tread
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|BLKSIZE
argument_list|)
expr_stmt|;
name|scan
operator|=
name|tmpblk
operator|.
name|c
expr_stmt|;
if|if
condition|(
name|scan
operator|>=
name|end
condition|)
block|{
name|msg
argument_list|(
literal|"tag \"%s\" not found"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* if we're comparing, compare... */
if|if
condition|(
name|cmp
condition|)
block|{
comment|/* matched??? wow! */
if|if
condition|(
operator|!
operator|*
name|cmp
operator|&&
operator|*
name|scan
operator|==
literal|'\t'
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|cmp
operator|++
operator|!=
operator|*
name|scan
condition|)
block|{
comment|/* failed! skip to newline */
name|cmp
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* if we're skipping to newline, do it fast! */
if|if
condition|(
operator|!
name|cmp
condition|)
block|{
while|while
condition|(
name|scan
operator|<
name|end
operator|&&
operator|*
name|scan
operator|!=
literal|'\n'
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|<
name|end
condition|)
block|{
name|cmp
operator|=
name|extra
expr_stmt|;
block|}
block|}
block|}
comment|/* found it! get the rest of the line into memory */
for|for
control|(
name|cmp
operator|=
name|tmpblk
operator|.
name|c
operator|,
name|scan
operator|++
init|;
name|scan
operator|<
name|end
operator|&&
operator|*
name|scan
operator|!=
literal|'\n'
condition|;
control|)
block|{
operator|*
name|cmp
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|==
name|end
condition|)
block|{
name|tread
argument_list|(
name|fd
argument_list|,
name|cmp
argument_list|,
name|BLKSIZE
operator|-
operator|(
name|cmp
operator|-
name|tmpblk
operator|.
name|c
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* we can close the tags file now */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* extract the filename from the line, and edit the file */
for|for
control|(
name|cmp
operator|=
name|tmpblk
operator|.
name|c
init|;
operator|*
name|cmp
operator|!=
literal|'\t'
condition|;
name|cmp
operator|++
control|)
block|{ 	}
operator|*
name|cmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|origname
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tmpabort
argument_list|(
name|bang
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"Use :tag! to abort changes, or :w to save changes"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmpstart
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* move to the desired line (or to line 1 if that fails) */
ifndef|#
directive|ifndef
name|NO_MAGIC
name|wasmagic
operator|=
operator|*
name|o_magic
expr_stmt|;
operator|*
name|o_magic
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|cursor
operator|=
name|MARK_FIRST
expr_stmt|;
name|linespec
argument_list|(
name|cmp
argument_list|,
operator|&
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|==
name|MARK_UNSET
condition|)
block|{
name|cursor
operator|=
name|MARK_FIRST
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_MAGIC
operator|*
name|o_magic
operator|=
name|wasmagic
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_visual
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|mode
operator|=
name|MODE_VI
expr_stmt|;
name|msg
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* describe this version of the program */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_version
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|DATE
name|msg
argument_list|(
literal|"%s"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
else|#
directive|else
name|msg
argument_list|(
literal|"%s  (%s)"
argument_list|,
name|VERSION
argument_list|,
name|DATE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPILED_BY
name|msg
argument_list|(
literal|"Compiled by %s"
argument_list|,
name|COMPILED_BY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CREDIT
name|msg
argument_list|(
literal|"%s"
argument_list|,
name|CREDIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COPYING
name|msg
argument_list|(
literal|"%s"
argument_list|,
name|COPYING
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MKEXRC
end_ifndef

begin_comment
comment|/* make a .exrc file which describes the current configuration */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_mkexrc
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
comment|/* the default name for the .exrc file EXRC */
if|if
condition|(
operator|!
operator|*
name|extra
condition|)
block|{
name|extra
operator|=
name|EXRC
expr_stmt|;
block|}
comment|/* create the .exrc file */
name|fd
operator|=
name|creat
argument_list|(
name|extra
argument_list|,
name|FILEPERMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Couldn't create a new \"%s\" file"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* save stuff */
name|savekeys
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|saveopts
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|savedigs
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ABBR
name|saveabbr
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* close the file */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"Created a new \"%s\" file"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_digraph
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|;
name|MARK
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|do_digraph
argument_list|(
name|bang
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ERRLIST
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|errfile
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the name of a file containing an error */
end_comment

begin_decl_stmt
specifier|static
name|long
name|errline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the line number for an error */
end_comment

begin_comment
comment|/* This static function tries to parse an error message.  *  * For most compilers, the first word is taken to be the name of the erroneous  * file, and the first number after that is taken to be the line number where  * the error was detected.  The description of the error follows, possibly  * preceded by an "error ... :" or "warning ... :" label which is skipped.  *  * For Coherent, error messages look like "line#: filename: message".  *  * For non-error lines, or unparsable error lines, this function returns NULL.  * Normally, though, it alters errfile and errline, and returns a pointer to  * the description.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parse_errmsg
parameter_list|(
name|text
parameter_list|)
name|REG
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|REG
name|char
modifier|*
name|cpy
decl_stmt|;
name|long
name|atol
parameter_list|()
function_decl|;
if|#
directive|if
name|COHERENT
operator|||
name|TOS
comment|/* any Mark Williams compiler */
comment|/* Get the line number.  If no line number, then ignore this line. */
name|errline
operator|=
name|atol
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|errline
operator|==
literal|0L
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
comment|/* Skip to the start of the filename */
while|while
condition|(
operator|*
name|text
operator|&&
operator|*
name|text
operator|++
operator|!=
literal|':'
condition|)
block|{ 	}
if|if
condition|(
operator|!
operator|*
name|text
operator|++
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
comment|/* copy the filename to errfile */
for|for
control|(
name|cpy
operator|=
name|errfile
init|;
operator|*
name|text
operator|&&
operator|(
operator|*
name|cpy
operator|++
operator|=
operator|*
name|text
operator|++
operator|)
operator|!=
literal|':'
condition|;
control|)
block|{ 	}
if|if
condition|(
operator|!
operator|*
name|text
operator|++
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
name|cpy
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|text
return|;
else|#
directive|else
comment|/* not a Mark Williams compiler */
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* the error message is the whole line, by default */
name|errmsg
operator|=
name|text
expr_stmt|;
comment|/* skip leading garbage */
while|while
condition|(
operator|*
name|text
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|text
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|text
argument_list|)
operator|)
condition|)
block|{
name|text
operator|++
expr_stmt|;
block|}
comment|/* copy over the filename */
name|cpy
operator|=
name|errfile
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|text
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|text
argument_list|)
operator|||
operator|*
name|text
operator|==
literal|'.'
condition|)
block|{
operator|*
name|cpy
operator|++
operator|=
operator|*
name|text
operator|++
expr_stmt|;
block|}
operator|*
name|cpy
operator|=
literal|'\0'
expr_stmt|;
comment|/* ignore the name "Error" and filenames that contain a '/' */
if|if
condition|(
operator|*
name|text
operator|==
literal|'/'
operator|||
operator|!
name|strcmp
argument_list|(
name|errfile
operator|+
literal|1
argument_list|,
literal|"rror"
argument_list|)
operator|||
name|access
argument_list|(
name|errfile
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
comment|/* skip garbage between filename and line number */
while|while
condition|(
operator|*
name|text
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|text
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|text
argument_list|)
operator|)
condition|)
block|{
name|text
operator|++
expr_stmt|;
block|}
comment|/* if the number is part of a larger word, then ignore this line */
if|if
condition|(
operator|*
name|text
operator|&&
name|isascii
argument_list|(
name|text
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isalpha
argument_list|(
name|text
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
comment|/* get the error line */
name|errline
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|text
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|text
argument_list|)
condition|)
block|{
name|errline
operator|*=
literal|10
expr_stmt|;
name|errline
operator|+=
operator|(
operator|*
name|text
operator|-
literal|'0'
operator|)
expr_stmt|;
name|text
operator|++
expr_stmt|;
block|}
comment|/* any line which lacks a filename or line number should be ignored */
if|if
condition|(
operator|!
name|errfile
index|[
literal|0
index|]
operator|||
operator|!
name|errline
condition|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
comment|/* locate the beginning of the error description */
while|while
condition|(
operator|*
name|text
operator|&&
name|isascii
argument_list|(
operator|*
name|text
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|text
argument_list|)
condition|)
block|{
name|text
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|text
condition|)
block|{
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* skip "error #:" and "warning #:" clauses */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|text
operator|+
literal|1
argument_list|,
literal|"rror "
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|text
operator|+
literal|1
argument_list|,
literal|"arning "
argument_list|,
literal|7
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|text
operator|+
literal|1
argument_list|,
literal|"atal error"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
do|do
block|{
name|text
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|text
operator|&&
operator|*
name|text
operator|!=
literal|':'
condition|)
do|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* anything other than whitespace or a colon is important */
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|text
argument_list|)
operator|||
operator|(
operator|!
name|isspace
argument_list|(
operator|*
name|text
argument_list|)
operator|&&
operator|*
name|text
operator|!=
literal|':'
operator|)
condition|)
block|{
name|errmsg
operator|=
name|text
expr_stmt|;
break|break;
block|}
comment|/* else keep looking... */
name|text
operator|++
expr_stmt|;
block|}
return|return
name|errmsg
return|;
endif|#
directive|endif
comment|/* not COHERENT */
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_errlist
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
specifier|static
name|long
name|endline
decl_stmt|;
comment|/* original number of lines in this file */
specifier|static
name|long
name|offset
decl_stmt|;
comment|/* offset of the next line in the errlist file */
specifier|static
name|int
name|fd
init|=
operator|-
literal|2
decl_stmt|;
comment|/* fd of the errlist file */
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* if a new errlist file is named, open it */
if|if
condition|(
name|extra
operator|&&
name|extra
index|[
literal|0
index|]
condition|)
block|{
comment|/* close the old one */
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|extra
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0L
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|ERRLIST
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0L
expr_stmt|;
block|}
comment|/* do we have an errlist file now? */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"There is no errlist file"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* find the next error message in the file */
do|do
block|{
comment|/* read the next line from the errlist */
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tread
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
operator|(
name|unsigned
operator|)
name|BLKSIZE
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"No more errors"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tmpblk
operator|.
name|c
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
block|{ 		}
name|tmpblk
operator|.
name|c
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* look for an error message in the line */
name|errmsg
operator|=
name|parse_errmsg
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errmsg
condition|)
block|{
name|offset
operator|+=
name|i
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|errmsg
condition|)
do|;
comment|/* switch to the file containing the error, if this isn't it */
if|if
condition|(
name|strcmp
argument_list|(
name|origname
argument_list|,
name|errfile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|tmpabort
argument_list|(
name|bang
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"Use :er! to abort changes, or :w to save changes"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmpstart
argument_list|(
name|errfile
argument_list|)
expr_stmt|;
name|endline
operator|=
name|nlines
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endline
operator|==
literal|0L
condition|)
block|{
name|endline
operator|=
name|nlines
expr_stmt|;
block|}
comment|/* go to the line where the error was detected */
name|cursor
operator|=
name|MARK_AT_LINE
argument_list|(
name|errline
operator|+
operator|(
name|nlines
operator|-
name|endline
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
name|MARK_LAST
condition|)
block|{
name|cursor
operator|=
name|MARK_LAST
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|MODE_VI
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* display the error message */
if|if
condition|(
name|nlines
operator|>
name|endline
condition|)
block|{
name|msg
argument_list|(
literal|"line %ld(+%ld): %.60s"
argument_list|,
name|errline
argument_list|,
name|nlines
operator|-
name|endline
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nlines
operator|<
name|endline
condition|)
block|{
name|msg
argument_list|(
literal|"line %ld(-%ld): %.60s"
argument_list|,
name|errline
argument_list|,
name|endline
operator|-
name|nlines
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"line %ld: %.65s"
argument_list|,
name|errline
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
comment|/* remember where the NEXT error line will start */
name|offset
operator|+=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_make
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|BLK
name|buf
decl_stmt|;
comment|/* if the file hasn't been saved, then complain unless ! */
if|if
condition|(
name|tstflag
argument_list|(
name|file
argument_list|,
name|MODIFIED
argument_list|)
operator|&&
operator|!
name|bang
condition|)
block|{
name|msg
argument_list|(
literal|"\"%s\" not saved yet"
argument_list|,
name|origname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* build the command */
name|sprintf
argument_list|(
name|buf
operator|.
name|c
argument_list|,
literal|"%s %s %s%s"
argument_list|,
operator|(
name|cmd
operator|==
name|CMD_CC
condition|?
name|o_cc
else|:
name|o_make
operator|)
argument_list|,
name|extra
argument_list|,
name|REDIRECT
argument_list|,
name|ERRLIST
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|buf
operator|.
name|c
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* run the command, with curses temporarily disabled */
name|suspend_curses
argument_list|()
expr_stmt|;
name|system
argument_list|(
name|buf
operator|.
name|c
argument_list|)
expr_stmt|;
name|resume_curses
argument_list|(
name|mode
operator|==
name|MODE_EX
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_COLON
condition|)
name|mode
operator|=
name|MODE_VI
expr_stmt|;
comment|/* run the "errlist" command */
name|cmd_errlist
argument_list|(
name|MARK_UNSET
argument_list|,
name|MARK_UNSET
argument_list|,
name|cmd
argument_list|,
name|bang
argument_list|,
name|ERRLIST
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ABBR
end_ifndef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|cmd_abbr
parameter_list|(
name|frommark
parameter_list|,
name|tomark
parameter_list|,
name|cmd
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|MARK
name|frommark
decl_stmt|,
name|tomark
decl_stmt|;
name|CMD
name|cmd
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
block|{
name|do_abbr
argument_list|(
name|extra
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

