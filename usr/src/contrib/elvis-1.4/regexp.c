begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* regexp.c */
end_comment

begin_comment
comment|/* This file contains the code that compiles regular expressions and executes  * them.  It supports the same syntax and features as vi's regular expression  * code.  Specifically, the meta characters are:  *	^	matches the beginning of a line  *	$	matches the end of a line  *	\<	matches the beginning of a word  *	\>	matches the end of a word  *	.	matches any single character  *	[]	matches any character in a character class  *	\(	delimits the start of a subexpression  *	\)	delimits the end of a subexpression  *	*	repeats the preceding 0 or more times  * NOTE: You cannot follow a \) with a *.  *  * The physical structure of a compiled RE is as follows:  *	- First, there is a one-byte value that says how many character classes  *	  are used in this regular expression  *	- Next, each character class is stored as a bitmap that is 256 bits  *	  (32 bytes) long.  *	- A mixture of literal characters and compiled meta characters follows.  *	  This begins with M_BEGIN(0) and ends with M_END(0).  All meta chars  *	  are stored as a \n followed by a one-byte code, so they take up two  *	  bytes apiece.  Literal characters take up one byte apiece.  \n can't  *	  be used as a literal character.  *  * If NO_MAGIC is defined, then a different set of functions is used instead.  * That right, this file contains TWO versions of the code.  */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"regexp.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|previous
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the previous regexp, used when null regexp is given */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MAGIC
end_ifndef

begin_comment
comment|/* THE REAL REGEXP PACKAGE IS USED UNLESS "NO_MAGIC" IS DEFINED */
end_comment

begin_comment
comment|/* These are used to classify or recognize meta-characters */
end_comment

begin_define
define|#
directive|define
name|META
value|'\0'
end_define

begin_define
define|#
directive|define
name|BASE_META
parameter_list|(
name|m
parameter_list|)
value|((m) - 256)
end_define

begin_define
define|#
directive|define
name|INT_META
parameter_list|(
name|c
parameter_list|)
value|((c) + 256)
end_define

begin_define
define|#
directive|define
name|IS_META
parameter_list|(
name|m
parameter_list|)
value|((m)>= 256)
end_define

begin_define
define|#
directive|define
name|IS_CLASS
parameter_list|(
name|m
parameter_list|)
value|((m)>= M_CLASS(0)&& (m)<= M_CLASS(9))
end_define

begin_define
define|#
directive|define
name|IS_START
parameter_list|(
name|m
parameter_list|)
value|((m)>= M_START(0)&& (m)<= M_START(9))
end_define

begin_define
define|#
directive|define
name|IS_END
parameter_list|(
name|m
parameter_list|)
value|((m)>= M_END(0)&& (m)<= M_END(9))
end_define

begin_define
define|#
directive|define
name|IS_CLOSURE
parameter_list|(
name|m
parameter_list|)
value|((m)>= M_SPLAT&& (m)<= M_QMARK)
end_define

begin_define
define|#
directive|define
name|ADD_META
parameter_list|(
name|s
parameter_list|,
name|m
parameter_list|)
value|(*(s)++ = META, *(s)++ = BASE_META(m))
end_define

begin_define
define|#
directive|define
name|GET_META
parameter_list|(
name|s
parameter_list|)
value|(*(s) == META ? INT_META(*++(s)) : *s)
end_define

begin_comment
comment|/* These are the internal codes used for each type of meta-character */
end_comment

begin_define
define|#
directive|define
name|M_BEGLINE
value|256
end_define

begin_comment
comment|/* internal code for ^ */
end_comment

begin_define
define|#
directive|define
name|M_ENDLINE
value|257
end_define

begin_comment
comment|/* internal code for $ */
end_comment

begin_define
define|#
directive|define
name|M_BEGWORD
value|258
end_define

begin_comment
comment|/* internal code for \< */
end_comment

begin_define
define|#
directive|define
name|M_ENDWORD
value|259
end_define

begin_comment
comment|/* internal code for \> */
end_comment

begin_define
define|#
directive|define
name|M_ANY
value|260
end_define

begin_comment
comment|/* internal code for . */
end_comment

begin_define
define|#
directive|define
name|M_SPLAT
value|261
end_define

begin_comment
comment|/* internal code for * */
end_comment

begin_define
define|#
directive|define
name|M_PLUS
value|262
end_define

begin_comment
comment|/* internal code for \+ */
end_comment

begin_define
define|#
directive|define
name|M_QMARK
value|263
end_define

begin_comment
comment|/* internal code for \? */
end_comment

begin_define
define|#
directive|define
name|M_CLASS
parameter_list|(
name|n
parameter_list|)
value|(264+(n))
end_define

begin_comment
comment|/* internal code for [] */
end_comment

begin_define
define|#
directive|define
name|M_START
parameter_list|(
name|n
parameter_list|)
value|(274+(n))
end_define

begin_comment
comment|/* internal code for \( */
end_comment

begin_define
define|#
directive|define
name|M_END
parameter_list|(
name|n
parameter_list|)
value|(284+(n))
end_define

begin_comment
comment|/* internal code for \) */
end_comment

begin_comment
comment|/* These are used during compilation */
end_comment

begin_decl_stmt
specifier|static
name|int
name|class_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to assign class IDs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|start_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to assign start IDs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|end_stk
index|[
name|NSUBEXP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to assign end IDs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|end_sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|retext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to the text being compiled */
end_comment

begin_comment
comment|/* error-handling stuff */
end_comment

begin_decl_stmt
name|jmp_buf
name|errorhandler
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FAIL
parameter_list|(
name|why
parameter_list|)
value|regerror(why); longjmp(errorhandler, 1)
end_define

begin_comment
comment|/* This function builds a bitmap for a particular class */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|makeclass
parameter_list|(
name|text
parameter_list|,
name|bmap
parameter_list|)
name|REG
name|char
modifier|*
name|text
decl_stmt|;
comment|/* start of the class */
name|REG
name|char
modifier|*
name|bmap
decl_stmt|;
comment|/* the bitmap */
block|{
name|REG
name|int
name|i
decl_stmt|;
name|int
name|complement
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|TRACE
name|printf
argument_list|(
literal|"makeclass(\"%s\", 0x%lx)\n"
argument_list|,
name|text
argument_list|,
operator|(
name|long
operator|)
name|bmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* zero the bitmap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bmap
operator|&&
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|bmap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* see if we're going to complement this class */
if|if
condition|(
operator|*
name|text
operator|==
literal|'^'
condition|)
block|{
name|text
operator|++
expr_stmt|;
name|complement
operator|=
literal|1
expr_stmt|;
block|}
comment|/* add in the characters */
while|while
condition|(
operator|*
name|text
operator|&&
operator|*
name|text
operator|!=
literal|']'
condition|)
block|{
comment|/* is this a span of characters? */
if|if
condition|(
name|text
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
name|text
index|[
literal|2
index|]
condition|)
block|{
comment|/* spans can't be backwards */
if|if
condition|(
name|text
index|[
literal|0
index|]
operator|>
name|text
index|[
literal|2
index|]
condition|)
block|{
name|FAIL
argument_list|(
literal|"Backwards span in []"
argument_list|)
expr_stmt|;
block|}
comment|/* add each character in the span to the bitmap */
for|for
control|(
name|i
operator|=
name|text
index|[
literal|0
index|]
init|;
name|bmap
operator|&&
name|i
operator|<=
name|text
index|[
literal|2
index|]
condition|;
name|i
operator|++
control|)
block|{
name|bmap
index|[
name|i
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
comment|/* move past this span */
name|text
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* add this single character to the span */
name|i
operator|=
operator|*
name|text
operator|++
expr_stmt|;
if|if
condition|(
name|bmap
condition|)
block|{
name|bmap
index|[
name|i
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* make sure the closing ] is missing */
if|if
condition|(
operator|*
name|text
operator|++
operator|!=
literal|']'
condition|)
block|{
name|FAIL
argument_list|(
literal|"] missing"
argument_list|)
expr_stmt|;
block|}
comment|/* if we're supposed to complement this class, then do so */
if|if
condition|(
name|complement
operator|&&
name|bmap
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|bmap
index|[
name|i
index|]
operator|=
operator|~
name|bmap
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|text
return|;
block|}
end_function

begin_comment
comment|/* This function gets the next character or meta character from a string.  * The pointer is incremented by 1, or by 2 for \-quoted characters.  For [],  * a bitmap is generated via makeclass() (if re is given), and the  * character-class text is skipped.  */
end_comment

begin_function
specifier|static
name|int
name|gettoken
parameter_list|(
name|sptr
parameter_list|,
name|re
parameter_list|)
name|char
modifier|*
modifier|*
name|sptr
decl_stmt|;
name|regexp
modifier|*
name|re
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
operator|*
name|sptr
expr_stmt|;
operator|++
operator|*
name|sptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
operator|*
name|sptr
expr_stmt|;
operator|++
operator|*
name|sptr
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
return|return
name|M_BEGWORD
return|;
case|case
literal|'>'
case|:
return|return
name|M_ENDWORD
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|start_cnt
operator|>=
name|NSUBEXP
condition|)
block|{
name|FAIL
argument_list|(
literal|"Too many \\(s"
argument_list|)
expr_stmt|;
block|}
name|end_stk
index|[
name|end_sp
operator|++
index|]
operator|=
name|start_cnt
expr_stmt|;
return|return
name|M_START
argument_list|(
name|start_cnt
operator|++
argument_list|)
return|;
case|case
literal|')'
case|:
if|if
condition|(
name|end_sp
operator|<=
literal|0
condition|)
block|{
name|FAIL
argument_list|(
literal|"Mismatched \\)"
argument_list|)
expr_stmt|;
block|}
return|return
name|M_END
argument_list|(
name|end_stk
index|[
operator|--
name|end_sp
index|]
argument_list|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
operator|*
name|o_magic
condition|?
name|c
else|:
name|M_SPLAT
operator|)
return|;
case|case
literal|'.'
case|:
return|return
operator|(
operator|*
name|o_magic
condition|?
name|c
else|:
name|M_ANY
operator|)
return|;
case|case
literal|'+'
case|:
return|return
name|M_PLUS
return|;
case|case
literal|'?'
case|:
return|return
name|M_QMARK
return|;
default|default:
return|return
name|c
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|o_magic
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'^'
case|:
if|if
condition|(
operator|*
name|sptr
operator|==
name|retext
operator|+
literal|1
condition|)
block|{
return|return
name|M_BEGLINE
return|;
block|}
return|return
name|c
return|;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
operator|*
operator|*
name|sptr
condition|)
block|{
return|return
name|M_ENDLINE
return|;
block|}
return|return
name|c
return|;
case|case
literal|'.'
case|:
return|return
name|M_ANY
return|;
case|case
literal|'*'
case|:
return|return
name|M_SPLAT
return|;
case|case
literal|'['
case|:
comment|/* make sure we don't have too many classes */
if|if
condition|(
name|class_cnt
operator|>=
literal|10
condition|)
block|{
name|FAIL
argument_list|(
literal|"Too many []s"
argument_list|)
expr_stmt|;
block|}
comment|/* process the character list for this class */
if|if
condition|(
name|re
condition|)
block|{
comment|/* generate the bitmap for this class */
operator|*
name|sptr
operator|=
name|makeclass
argument_list|(
operator|*
name|sptr
argument_list|,
name|re
operator|->
name|program
operator|+
literal|1
operator|+
literal|32
operator|*
name|class_cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* skip to end of the class */
operator|*
name|sptr
operator|=
name|makeclass
argument_list|(
operator|*
name|sptr
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|M_CLASS
argument_list|(
name|class_cnt
operator|++
argument_list|)
return|;
default|default:
return|return
name|c
return|;
block|}
block|}
else|else
comment|/* unquoted nomagic */
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'^'
case|:
if|if
condition|(
operator|*
name|sptr
operator|==
name|retext
operator|+
literal|1
condition|)
block|{
return|return
name|M_BEGLINE
return|;
block|}
return|return
name|c
return|;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
operator|*
operator|*
name|sptr
condition|)
block|{
return|return
name|M_ENDLINE
return|;
block|}
return|return
name|c
return|;
default|default:
return|return
name|c
return|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* This function calculates the number of bytes that will be needed for a  * compiled RE.  Its argument is the uncompiled version.  It is not clever  * about catching syntax errors; that is done in a later pass.  */
end_comment

begin_function
specifier|static
name|unsigned
name|calcsize
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|unsigned
name|size
decl_stmt|;
name|int
name|token
decl_stmt|;
name|retext
operator|=
name|text
expr_stmt|;
name|class_cnt
operator|=
literal|0
expr_stmt|;
name|start_cnt
operator|=
literal|1
expr_stmt|;
name|end_sp
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|5
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|gettoken
argument_list|(
operator|&
name|text
argument_list|,
operator|(
name|regexp
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|IS_CLASS
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|size
operator|+=
literal|34
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_META
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|size
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|size
operator|++
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* This function compiles a regexp. */
end_comment

begin_function
name|regexp
modifier|*
name|regcomp
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|int
name|needfirst
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
name|int
name|token
decl_stmt|;
name|int
name|peek
decl_stmt|;
name|char
modifier|*
name|build
decl_stmt|;
name|regexp
modifier|*
name|re
decl_stmt|;
comment|/* prepare for error handling */
name|re
operator|=
operator|(
name|regexp
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|errorhandler
argument_list|)
condition|)
block|{
if|if
condition|(
name|re
condition|)
block|{
name|free
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|regexp
operator|*
operator|)
literal|0
return|;
block|}
comment|/* if an empty regexp string was given, use the previous one */
if|if
condition|(
operator|*
name|text
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|previous
condition|)
block|{
name|FAIL
argument_list|(
literal|"No previous RE"
argument_list|)
expr_stmt|;
block|}
name|text
operator|=
name|previous
expr_stmt|;
block|}
else|else
comment|/* non-empty regexp given, so remember it */
block|{
if|if
condition|(
name|previous
condition|)
name|free
argument_list|(
name|previous
argument_list|)
expr_stmt|;
name|previous
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous
condition|)
name|strcpy
argument_list|(
name|previous
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|/* allocate memory */
name|class_cnt
operator|=
literal|0
expr_stmt|;
name|start_cnt
operator|=
literal|1
expr_stmt|;
name|end_sp
operator|=
literal|0
expr_stmt|;
name|retext
operator|=
name|text
expr_stmt|;
name|size
operator|=
name|calcsize
argument_list|(
name|text
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|regexp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|re
operator|=
operator|(
operator|(
name|regexp
operator|*
operator|)
literal|0
operator|)
operator|+
name|size
expr_stmt|;
else|#
directive|else
name|re
operator|=
operator|(
name|regexp
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|re
condition|)
block|{
name|FAIL
argument_list|(
literal|"Not enough memory for this RE"
argument_list|)
expr_stmt|;
block|}
comment|/* compile it */
name|build
operator|=
operator|&
name|re
operator|->
name|program
index|[
literal|1
operator|+
literal|32
operator|*
name|class_cnt
index|]
expr_stmt|;
name|re
operator|->
name|program
index|[
literal|0
index|]
operator|=
name|class_cnt
expr_stmt|;
for|for
control|(
name|token
operator|=
literal|0
init|;
name|token
operator|<
name|NSUBEXP
condition|;
name|token
operator|++
control|)
block|{
name|re
operator|->
name|startp
index|[
name|token
index|]
operator|=
name|re
operator|->
name|endp
index|[
name|token
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|re
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|bol
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|minlen
operator|=
literal|0
expr_stmt|;
name|needfirst
operator|=
literal|1
expr_stmt|;
name|class_cnt
operator|=
literal|0
expr_stmt|;
name|start_cnt
operator|=
literal|1
expr_stmt|;
name|end_sp
operator|=
literal|0
expr_stmt|;
name|retext
operator|=
name|text
expr_stmt|;
for|for
control|(
name|token
operator|=
name|M_START
argument_list|(
literal|0
argument_list|)
operator|,
name|peek
operator|=
name|gettoken
argument_list|(
operator|&
name|text
argument_list|,
name|re
argument_list|)
init|;
name|token
condition|;
name|token
operator|=
name|peek
operator|,
name|peek
operator|=
name|gettoken
argument_list|(
operator|&
name|text
argument_list|,
name|re
argument_list|)
control|)
block|{
comment|/* special processing for the closure operator */
if|if
condition|(
name|IS_CLOSURE
argument_list|(
name|peek
argument_list|)
condition|)
block|{
comment|/* detect misuse of closure operator */
if|if
condition|(
name|IS_START
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|FAIL
argument_list|(
literal|"* or \\+ or \\? follows nothing"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_META
argument_list|(
name|token
argument_list|)
operator|&&
name|token
operator|!=
name|M_ANY
operator|&&
operator|!
name|IS_CLASS
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|FAIL
argument_list|(
literal|"* or \\+ or \\? can only follow a normal character or . or []"
argument_list|)
expr_stmt|;
block|}
comment|/* it is okay -- make it prefix instead of postfix */
name|ADD_META
argument_list|(
name|build
argument_list|,
name|peek
argument_list|)
expr_stmt|;
comment|/* take care of "needfirst" - is this the first char? */
if|if
condition|(
name|needfirst
operator|&&
name|peek
operator|==
name|M_PLUS
operator|&&
operator|!
name|IS_META
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|re
operator|->
name|first
operator|=
name|token
expr_stmt|;
block|}
name|needfirst
operator|=
literal|0
expr_stmt|;
comment|/* we used "peek" -- need to refill it */
name|peek
operator|=
name|gettoken
argument_list|(
operator|&
name|text
argument_list|,
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CLOSURE
argument_list|(
name|peek
argument_list|)
condition|)
block|{
name|FAIL
argument_list|(
literal|"* or \\+ or \\? doubled up"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_META
argument_list|(
name|token
argument_list|)
condition|)
block|{
comment|/* normal char is NOT argument of closure */
if|if
condition|(
name|needfirst
condition|)
block|{
name|re
operator|->
name|first
operator|=
name|token
expr_stmt|;
name|needfirst
operator|=
literal|0
expr_stmt|;
block|}
name|re
operator|->
name|minlen
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|M_ANY
operator|||
name|IS_CLASS
argument_list|(
name|token
argument_list|)
condition|)
block|{
comment|/* . or [] is NOT argument of closure */
name|needfirst
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|minlen
operator|++
expr_stmt|;
block|}
comment|/* the "token" character is not closure -- process it normally */
if|if
condition|(
name|token
operator|==
name|M_BEGLINE
condition|)
block|{
comment|/* set the BOL flag instead of storing M_BEGLINE */
name|re
operator|->
name|bol
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_META
argument_list|(
name|token
argument_list|)
condition|)
block|{
name|ADD_META
argument_list|(
name|build
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|build
operator|++
operator|=
name|token
expr_stmt|;
block|}
block|}
comment|/* end it with a \) which MUST MATCH the opening \( */
name|ADD_META
argument_list|(
name|build
argument_list|,
name|M_END
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_sp
operator|>
literal|0
condition|)
block|{
name|FAIL
argument_list|(
literal|"Not enough \\)s"
argument_list|)
expr_stmt|;
block|}
return|return
name|re
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* This function checks for a match between a character and a token which is  * known to represent a single character.  It returns 0 if they match, or  * 1 if they don't.  */
end_comment

begin_function
name|int
name|match1
parameter_list|(
name|re
parameter_list|,
name|ch
parameter_list|,
name|token
parameter_list|)
name|regexp
modifier|*
name|re
decl_stmt|;
name|REG
name|char
name|ch
decl_stmt|;
name|REG
name|int
name|token
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ch
condition|)
block|{
comment|/* the end of a line can't match any RE of width 1 */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|token
operator|==
name|M_ANY
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|IS_CLASS
argument_list|(
name|token
argument_list|)
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|program
index|[
literal|1
operator|+
literal|32
operator|*
operator|(
name|token
operator|-
name|M_CLASS
argument_list|(
literal|0
argument_list|)
operator|)
operator|+
operator|(
name|ch
operator|>>
literal|3
operator|)
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|ch
operator|&
literal|7
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|token
operator|||
operator|(
operator|*
name|o_ignorecase
operator|&&
name|isupper
argument_list|(
name|ch
argument_list|)
operator|&&
name|tolower
argument_list|(
name|ch
argument_list|)
operator|==
name|token
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function checks characters up to and including the next closure, at  * which point it does a recursive call to check the rest of it.  This function  * returns 0 if everything matches, or 1 if something doesn't match.  */
end_comment

begin_function
name|int
name|match
parameter_list|(
name|re
parameter_list|,
name|str
parameter_list|,
name|prog
parameter_list|,
name|here
parameter_list|)
name|regexp
modifier|*
name|re
decl_stmt|;
comment|/* the regular expression */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string */
name|REG
name|char
modifier|*
name|prog
decl_stmt|;
comment|/* a portion of re->program, an compiled RE */
name|REG
name|char
modifier|*
name|here
decl_stmt|;
comment|/* a portion of str, the string to compare it to */
block|{
name|REG
name|int
name|token
decl_stmt|;
name|REG
name|int
name|nmatched
decl_stmt|;
name|REG
name|int
name|closure
decl_stmt|;
for|for
control|(
name|token
operator|=
name|GET_META
argument_list|(
name|prog
argument_list|)
init|;
operator|!
name|IS_CLOSURE
argument_list|(
name|token
argument_list|)
condition|;
name|prog
operator|++
operator|,
name|token
operator|=
name|GET_META
argument_list|(
name|prog
argument_list|)
control|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
comment|/*case M_BEGLINE: can't happen; re->bol is used instead */
case|case
name|M_ENDLINE
case|:
if|if
condition|(
operator|*
name|here
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|M_BEGWORD
case|:
if|if
condition|(
name|here
operator|!=
name|str
operator|&&
operator|(
name|here
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|||
name|isascii
argument_list|(
name|here
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isalnum
argument_list|(
name|here
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|M_ENDWORD
case|:
if|if
condition|(
name|here
index|[
literal|0
index|]
operator|==
literal|'_'
operator|||
name|isascii
argument_list|(
name|here
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isalnum
argument_list|(
name|here
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|M_START
argument_list|(
literal|0
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|1
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|5
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|6
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|7
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|8
argument_list|)
case|:
case|case
name|M_START
argument_list|(
literal|9
argument_list|)
case|:
name|re
operator|->
name|startp
index|[
name|token
operator|-
name|M_START
argument_list|(
literal|0
argument_list|)
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|here
expr_stmt|;
break|break;
case|case
name|M_END
argument_list|(
literal|0
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|1
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|5
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|6
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|7
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|8
argument_list|)
case|:
case|case
name|M_END
argument_list|(
literal|9
argument_list|)
case|:
name|re
operator|->
name|endp
index|[
name|token
operator|-
name|M_END
argument_list|(
literal|0
argument_list|)
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|here
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|M_END
argument_list|(
literal|0
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
break|break;
default|default:
comment|/* literal, M_CLASS(n), or M_ANY */
if|if
condition|(
name|match1
argument_list|(
name|re
argument_list|,
operator|*
name|here
argument_list|,
name|token
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|here
operator|++
expr_stmt|;
block|}
block|}
comment|/* C L O S U R E */
comment|/* step 1: see what we have to match against, and move "prog" to point 	 * the the remainder of the compiled RE. 	 */
name|closure
operator|=
name|token
expr_stmt|;
name|prog
operator|++
operator|,
name|token
operator|=
name|GET_META
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|prog
operator|++
expr_stmt|;
comment|/* step 2: see how many times we can match that token against the string */
for|for
control|(
name|nmatched
operator|=
literal|0
init|;
operator|(
name|closure
operator|!=
name|M_QMARK
operator|||
name|nmatched
operator|<
literal|1
operator|)
operator|&&
operator|*
name|here
operator|&&
name|match1
argument_list|(
name|re
argument_list|,
operator|*
name|here
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|;
name|nmatched
operator|++
operator|,
name|here
operator|++
control|)
block|{ 	}
comment|/* step 3: try to match the remainder, and back off if it doesn't */
while|while
condition|(
name|nmatched
operator|>=
literal|0
operator|&&
name|match
argument_list|(
name|re
argument_list|,
name|str
argument_list|,
name|prog
argument_list|,
name|here
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nmatched
operator|--
expr_stmt|;
name|here
operator|--
expr_stmt|;
block|}
comment|/* so how did it work out? */
if|if
condition|(
name|nmatched
operator|>=
operator|(
operator|(
name|closure
operator|==
name|M_PLUS
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function searches through a string for text that matches an RE. */
end_comment

begin_function
name|int
name|regexec
parameter_list|(
name|re
parameter_list|,
name|str
parameter_list|,
name|bol
parameter_list|)
name|regexp
modifier|*
name|re
decl_stmt|;
comment|/* the compiled regexp to search for */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string to search through */
name|int
name|bol
decl_stmt|;
comment|/* boolean: does str start at the beginning of a line? */
block|{
name|char
modifier|*
name|prog
decl_stmt|;
comment|/* the entry point of re->program */
name|int
name|len
decl_stmt|;
comment|/* length of the string */
name|REG
name|char
modifier|*
name|here
decl_stmt|;
comment|/* if must start at the beginning of a line, and this isn't, then fail */
if|if
condition|(
name|re
operator|->
name|bol
operator|&&
operator|!
name|bol
condition|)
block|{
return|return
literal|0
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|prog
operator|=
name|re
operator|->
name|program
operator|+
literal|1
operator|+
literal|32
operator|*
name|re
operator|->
name|program
index|[
literal|0
index|]
expr_stmt|;
comment|/* search for the RE in the string */
if|if
condition|(
name|re
operator|->
name|bol
condition|)
block|{
comment|/* must occur at BOL */
if|if
condition|(
operator|(
name|re
operator|->
name|first
operator|&&
name|match1
argument_list|(
name|re
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
name|re
operator|->
name|first
argument_list|)
operator|)
comment|/* wrong first letter? */
operator|||
name|len
operator|<
name|re
operator|->
name|minlen
comment|/* not long enough? */
operator|||
name|match
argument_list|(
name|re
argument_list|,
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
name|prog
argument_list|,
name|str
argument_list|)
condition|)
comment|/* doesn't match? */
return|return
literal|0
return|;
comment|/* THEN FAIL! */
block|}
ifndef|#
directive|ifndef
name|CRUNCH
elseif|else
if|if
condition|(
operator|!
operator|*
name|o_ignorecase
condition|)
block|{
comment|/* can occur anywhere in the line, noignorecase */
for|for
control|(
name|here
operator|=
operator|(
name|char
operator|*
operator|)
name|str
init|;
operator|(
name|re
operator|->
name|first
operator|&&
name|re
operator|->
name|first
operator|!=
operator|*
name|here
operator|)
operator|||
name|match
argument_list|(
name|re
argument_list|,
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
name|prog
argument_list|,
name|here
argument_list|)
condition|;
name|here
operator|++
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
name|len
operator|<
name|re
operator|->
name|minlen
condition|)
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
comment|/* can occur anywhere in the line, ignorecase */
for|for
control|(
name|here
operator|=
operator|(
name|char
operator|*
operator|)
name|str
init|;
operator|(
name|re
operator|->
name|first
operator|&&
name|match1
argument_list|(
name|re
argument_list|,
operator|*
name|here
argument_list|,
operator|(
name|int
operator|)
name|re
operator|->
name|first
argument_list|)
operator|)
operator|||
name|match
argument_list|(
name|re
argument_list|,
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
name|prog
argument_list|,
name|here
argument_list|)
condition|;
name|here
operator|++
operator|,
name|len
operator|--
control|)
block|{
if|if
condition|(
name|len
operator|<
name|re
operator|->
name|minlen
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* if we didn't fail, then we must have succeeded */
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NO_MAGIC */
end_comment

begin_function
name|regexp
modifier|*
name|regcomp
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|regexp
modifier|*
name|re
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* allocate a big enough regexp structure */
ifdef|#
directive|ifdef
name|lint
name|re
operator|=
operator|(
name|regexp
operator|*
operator|)
literal|0
expr_stmt|;
else|#
directive|else
name|re
operator|=
operator|(
name|regexp
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|exp
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|regexp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|re
condition|)
block|{
name|regerror
argument_list|(
literal|"Could not malloc a regexp structure"
argument_list|)
expr_stmt|;
return|return
operator|(
name|regexp
operator|*
operator|)
literal|0
return|;
block|}
comment|/* initialize all fields of the structure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSUBEXP
condition|;
name|i
operator|++
control|)
block|{
name|re
operator|->
name|startp
index|[
name|i
index|]
operator|=
name|re
operator|->
name|endp
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|re
operator|->
name|minlen
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|re
operator|->
name|bol
operator|=
literal|0
expr_stmt|;
comment|/* copy the string into it, translating ^ and $ as needed */
for|for
control|(
name|src
operator|=
name|exp
operator|,
name|dest
operator|=
name|re
operator|->
name|program
operator|+
literal|1
init|;
operator|*
name|src
condition|;
name|src
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'^'
case|:
if|if
condition|(
name|src
operator|==
name|exp
condition|)
block|{
name|re
operator|->
name|bol
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dest
operator|++
operator|=
literal|'^'
expr_stmt|;
name|re
operator|->
name|minlen
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|src
index|[
literal|1
index|]
condition|)
block|{
name|re
operator|->
name|bol
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dest
operator|++
operator|=
literal|'$'
expr_stmt|;
name|re
operator|->
name|minlen
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|src
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
operator|++
name|src
expr_stmt|;
name|re
operator|->
name|minlen
operator|++
expr_stmt|;
block|}
else|else
block|{
name|regerror
argument_list|(
literal|"extra \\ at end of regular expression"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
name|re
operator|->
name|minlen
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
return|return
name|re
return|;
block|}
end_function

begin_comment
comment|/* This "helper" function checks for a match at a given location.  It returns  * 1 if it matches, 0 if it doesn't match here but might match later on in the  * string, or -1 if it could not possibly match  */
end_comment

begin_function
specifier|static
name|int
name|reghelp
parameter_list|(
name|prog
parameter_list|,
name|string
parameter_list|,
name|bolflag
parameter_list|)
name|struct
name|regexp
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|bolflag
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
comment|/* if ^, then require bolflag */
if|if
condition|(
operator|(
name|prog
operator|->
name|bol
operator|&
literal|1
operator|)
operator|&&
operator|!
name|bolflag
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* if it matches, then it will start here */
name|prog
operator|->
name|startp
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
comment|/* compare, possibly ignoring case */
if|if
condition|(
operator|*
name|o_ignorecase
condition|)
block|{
for|for
control|(
name|scan
operator|=
operator|&
name|prog
operator|->
name|program
index|[
literal|1
index|]
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
operator|,
name|string
operator|++
control|)
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|scan
argument_list|)
operator|!=
name|tolower
argument_list|(
operator|*
name|string
argument_list|)
condition|)
return|return
operator|*
name|string
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
else|else
block|{
for|for
control|(
name|scan
operator|=
operator|&
name|prog
operator|->
name|program
index|[
literal|1
index|]
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
operator|,
name|string
operator|++
control|)
if|if
condition|(
operator|*
name|scan
operator|!=
operator|*
name|string
condition|)
return|return
operator|*
name|string
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
comment|/* if $, then require string to end here, too */
if|if
condition|(
operator|(
name|prog
operator|->
name|bol
operator|&
literal|2
operator|)
operator|&&
operator|*
name|string
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* if we get to here, it matches */
name|prog
operator|->
name|endp
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|regexec
parameter_list|(
name|prog
parameter_list|,
name|string
parameter_list|,
name|bolflag
parameter_list|)
name|struct
name|regexp
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|bolflag
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
comment|/* keep trying to match it */
for|for
control|(
name|rc
operator|=
name|reghelp
argument_list|(
name|prog
argument_list|,
name|string
argument_list|,
name|bolflag
argument_list|)
init|;
name|rc
operator|==
literal|0
condition|;
name|rc
operator|=
name|reghelp
argument_list|(
name|prog
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
control|)
block|{
name|string
operator|++
expr_stmt|;
block|}
comment|/* did we match? */
return|return
name|rc
operator|==
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

