begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  maharani - a czarina-like program that generates interpress files  *  *  Written for Xerox Corporation by William LeFebvre  *  *  Copyright (c)  1984, 1985, 1986 Xerox Corporation  *  *  HISTORY  * 23-Sep-86  Lee Moore (lee) at Xerox Webster Research Center  *	Added Jim Mayer's fix to the space allocator.  *  * 13-apr-86  Ed Flint (ed) at Xerox Webster Research Center  *	do_file will reset to left margin when encountering carriage return  *  * 11-Feb-86  Lee Moore (lee) at Xerox Webster Research Center  *	Added various suggestions from Larry Parmalee at Cornell U.  *	1)  Margin adjustments.  Margins vary according to portrait or  *	    landscape mode.  If headings are suppressed, then that area  *	    is used for text.  Room left to punch holes at left.  *	2)  Baseline spacing is tightened up for smaller font sizes  *	3)  options can now reset each other  *	4)  added "-P" option to specifiy output device (for compatibility  *	    with lpr system stuff.)  *	5)  Improved maha environment variable handling (pair up and eliminate  *	    double and single quotes).  *	6)  Interpress file now has mode 600 (for security reasons)  *	7)  Maximum line length increased.  *  * 13-Jan-86  Lee Moore (lee) at Xerox Webster Research Center  *	Changed a call to strcpyn to strncpy.  *  *  8-apr-85  ed flint  *	conditional compilation for vax11-c (vms)  *  *  26-mar-85 ed flint @ Xerox, WRC  *	add fclose after do_file to prevent running out of open file descriptors  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_include
include|#
directive|include
include|stdio
end_include

begin_include
include|#
directive|include
include|ssdef
end_include

begin_include
include|#
directive|include
include|ctype
end_include

begin_include
include|#
directive|include
include|descrip
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"iptokens.h"
end_include

begin_include
include|#
directive|include
file|"literal.h"
end_include

begin_include
include|#
directive|include
file|"operator.h"
end_include

begin_comment
comment|/*  * the following defines a program that will queue an Interpress master  * for printing  */
end_comment

begin_define
define|#
directive|define
name|QIP
value|"qip"
end_define

begin_define
define|#
directive|define
name|Break_size
value|1024
end_define

begin_define
define|#
directive|define
name|Default_universal_prefix
value|"Xerox/XC1-1-1/"
end_define

begin_define
define|#
directive|define
name|Line_size
value|192
end_define

begin_comment
comment|/* upped from 132 */
end_comment

begin_comment
comment|/* All page boundaries are computed in the 1/10 point co-ordinate system */
end_comment

begin_comment
comment|/*  *  Orig_y is an offset from the top of the page.  It must be converted  *  to a measurement from the bottom of the page (a calculation that is  *  rotation-dependent).  */
end_comment

begin_define
define|#
directive|define
name|INCH
value|720
end_define

begin_define
define|#
directive|define
name|Half_INCH
value|360
end_define

begin_define
define|#
directive|define
name|Sixth_INCH
value|120
end_define

begin_comment
comment|/* one line at 6 lpi */
end_comment

begin_define
define|#
directive|define
name|Page_width
value|(8 * INCH + Half_INCH)
end_define

begin_define
define|#
directive|define
name|Page_length
value|(11 * INCH)
end_define

begin_comment
comment|/* rflg  ?  Landscape mode : Portrait mode */
end_comment

begin_define
define|#
directive|define
name|Orig_x
value|(rflg ? (1.5 * INCH/10) : (9 * INCH/10))
end_define

begin_define
define|#
directive|define
name|Orig_y
value|(rflg ? (Sixth_INCH * 8) : (Sixth_INCH * 5))
end_define

begin_define
define|#
directive|define
name|Header_to_orig_x
value|0
end_define

begin_define
define|#
directive|define
name|Header_to_orig_y
value|(2 * Sixth_INCH)
end_define

begin_comment
comment|/* Frame variable defines */
end_comment

begin_define
define|#
directive|define
name|F_transform
value|0
end_define

begin_define
define|#
directive|define
name|F_headfont
value|1
end_define

begin_define
define|#
directive|define
name|F_bodyfont
value|2
end_define

begin_define
define|#
directive|define
name|F_italicfont
value|3
end_define

begin_define
define|#
directive|define
name|No
value|0
end_define

begin_define
define|#
directive|define
name|Yes
value|1
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enum, perhaps? */
end_comment

begin_typedef
typedef|typedef
name|char
name|boolean
typedef|;
end_typedef

begin_comment
comment|/* routines that return something other than int */
end_comment

begin_function_decl
name|char
modifier|*
name|strecpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|allocate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|next_arg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|itoa
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* option flags */
end_comment

begin_decl_stmt
name|boolean
name|lflg
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line printer mode */
end_comment

begin_decl_stmt
name|boolean
name|rflg
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rotation - landscape mode */
end_comment

begin_decl_stmt
name|boolean
name|tflg
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* omit title */
end_comment

begin_comment
comment|/* valued options */
end_comment

begin_decl_stmt
name|int
name|columns
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bodyfont_name
init|=
literal|"Vintage-Printwheel/10"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|headfont_name
init|=
literal|"Modern-Bold/12"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|italicfont_name
init|=
literal|"Modern-Bold-Italic/12"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|banner
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|copies
init|=
literal|"1"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|printer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination printer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|header
init|=
literal|"%f            %t            Page %p, line %l"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pages
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|template
init|=
literal|"IPPXXXXXX"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  page characteristics:  these variables define the extremes for the  *  current page or column.  'column_separation' is the distance between  *  the left sides of each column on the page.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|notdef
end_ifndef

begin_decl_stmt
name|int
name|left_margin
init|=
operator|(
literal|9
operator|*
name|INCH
operator|/
literal|10
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* x origin in portrait mode */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|left_margin
init|=
name|Orig_x
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|right_margin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top_margin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bottom_margin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|column_separation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sundries */
end_comment

begin_decl_stmt
name|boolean
name|send_to_printer
init|=
name|Yes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|real_header
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* header built here */
end_comment

begin_decl_stmt
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name invoked with */
end_comment

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|page_select
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of page selections */
end_comment

begin_decl_stmt
name|int
modifier|*
name|curr_page_select
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|page_low
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|page_high
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipress_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interpress file descriptor */
end_comment

begin_decl_stmt
name|int
name|null_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd for /dev/null */
end_comment

begin_decl_stmt
name|int
name|line_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|page_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pages_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total pages for this interpress file */
end_comment

begin_decl_stmt
name|int
name|special_font
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fonts that require special handling */
end_comment

begin_decl_stmt
name|int
name|line_spacing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tab_amount
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|vax11c
end_ifndef

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* passwd entry for this user */
end_comment

begin_decl_stmt
name|struct
name|stat
name|file_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stat of current file */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Font_Terminal
value|1
end_define

begin_comment
comment|/* current arguments */
end_comment

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font structure definition */
end_comment

begin_struct
struct|struct
name|font
block|{
name|char
modifier|*
name|ft_universal_name
decl_stmt|;
name|char
modifier|*
name|ft_leaf_name
decl_stmt|;
name|int
name|ft_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* fonts used */
end_comment

begin_decl_stmt
name|struct
name|font
name|headfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|font
name|bodyfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|font
name|italicfont
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|_argc
parameter_list|,
name|_argv
parameter_list|)
name|int
name|_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|_argv
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* temporary pointers used for loops and such */
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* file currently processing */
ifdef|#
directive|ifdef
name|vax11c
name|int
name|error
decl_stmt|;
name|int
name|retlen
decl_stmt|;
name|char
name|command
index|[
literal|256
index|]
decl_stmt|;
name|$DESCRIPTOR
argument_list|(
name|mahadesc
argument_list|,
literal|"MAHAENV"
argument_list|)
expr_stmt|;
name|$DESCRIPTOR
argument_list|(
name|cmddesc
argument_list|,
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get our name */
if|if
condition|(
name|_argc
operator|<
literal|1
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|vax11c
name|myname
operator|=
name|_argv
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|myname
operator|=
name|rindex
argument_list|(
name|_argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|myname
operator|=
name|_argv
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|myname
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* get the options specified in the environment (defaults) */
ifdef|#
directive|ifdef
name|vax11c
if|if
condition|(
operator|(
name|error
operator|=
name|lib$get_symbol
argument_list|(
operator|&
name|mahadesc
argument_list|,
operator|&
name|cmddesc
argument_list|,
operator|&
name|retlen
argument_list|)
operator|)
operator|==
name|SS$_NORMAL
condition|)
block|{
if|if
condition|(
name|retlen
operator|!=
literal|0
condition|)
block|{
name|command
index|[
name|retlen
operator|&
literal|0xff
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate string */
name|src
operator|=
name|command
expr_stmt|;
comment|/* break the string up into null terminated arguments */
comment|/* half the length is a good upper bound on number of arguments */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|strlen
argument_list|(
name|src
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|argc
operator|=
literal|1
operator|,
name|ptr
operator|=
name|src
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|argc
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|' '
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'"'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|ptr
operator|!=
literal|'"'
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\''
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|ptr
operator|!=
literal|'\''
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
block|}
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* terminate the argument list */
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* process the options found in the environment */
name|get_options
argument_list|()
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|src
operator|=
name|getenv
argument_list|(
literal|"MAHA"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* break the string up into null terminated arguments */
comment|/* half the length is a good upper bound on number of arguments */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|allocate
argument_list|(
name|strlen
argument_list|(
name|src
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|argc
operator|=
literal|1
operator|,
name|ptr
operator|=
name|src
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|argc
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
name|char
name|quote
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|dst
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|' '
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'"'
operator|||
operator|*
name|ptr
operator|==
literal|'\''
condition|)
block|{
name|quote
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
comment|/* Save + skip quote */
while|while
condition|(
operator|*
name|ptr
operator|!=
name|quote
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* Skip closing quote */
block|}
else|else
operator|*
name|dst
operator|++
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* skip 1st trailing space */
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
comment|/* end arg. */
block|}
comment|/* terminate the argument list */
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* process the options found in the environment */
name|get_options
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* use the real arguments */
name|argc
operator|=
name|_argc
expr_stmt|;
name|argv
operator|=
name|_argv
expr_stmt|;
comment|/* process (real) arguments */
name|get_options
argument_list|()
expr_stmt|;
comment|/* establish and verify the requested fonts */
name|establish_font
argument_list|(
name|headfont_name
argument_list|,
operator|&
name|headfont
argument_list|)
expr_stmt|;
name|establish_font
argument_list|(
name|bodyfont_name
argument_list|,
operator|&
name|bodyfont
argument_list|)
expr_stmt|;
name|establish_font
argument_list|(
name|italicfont_name
argument_list|,
operator|&
name|italicfont
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax11c
comment|/* get passwd entry for future reference */
name|pwd
operator|=
name|getpwuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* setup output file */
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
comment|/* build a temporary file name */
ifdef|#
directive|ifdef
name|vax11c
name|output
operator|=
name|mktemp
argument_list|(
name|template
argument_list|)
expr_stmt|;
else|#
directive|else
name|output
operator|=
name|allocate
argument_list|(
literal|1
operator|+
literal|5
operator|+
literal|1
operator|+
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|output
argument_list|,
literal|"/tmp/@%d.ip"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|vax11c
if|if
condition|(
operator|(
name|ipress_file
operator|=
name|creat
argument_list|(
name|output
argument_list|,
literal|0
argument_list|,
literal|"rfm=udf"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|ipress_file
operator|=
name|creat
argument_list|(
name|output
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|system_error
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ip_select
argument_list|(
name|ipress_file
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax11c
comment|/* open the null device for throwing away output */
name|null_file
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set null strings to default values */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* banner name defaults to full name from gecos field */
name|name
operator|=
name|pwd
operator|->
name|pw_gecos
expr_stmt|;
comment|/* perform expansion and stripping */
if|if
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* this affects pwd->pw_gecos, too! */
block|}
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|'&'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|allocate
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|src
operator|=
name|pwd
operator|->
name|pw_gecos
operator|,
name|dest
operator|=
name|name
init|;
operator|*
name|src
operator|!=
literal|'\0'
condition|;
name|src
operator|++
operator|,
name|dest
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'&'
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|pwd
operator|->
name|pw_name
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|ptr
operator|++
control|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|ptr
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|banner
operator|==
name|NULL
condition|)
block|{
comment|/* banner defaults to file name(s) */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|banner
operator|=
literal|"out of the blue"
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|length
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
name|banner
operator|=
name|allocate
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|banner
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
name|strecpy
argument_list|(
name|ptr
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strecpy
argument_list|(
name|ptr
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|-=
literal|2
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* unravel the page specifiation */
comment|/* we will never need more than strlen(pages) ints to hold the info */
if|if
condition|(
name|pages
operator|!=
name|NULL
condition|)
block|{
name|page_select
operator|=
operator|(
name|int
operator|*
operator|)
name|allocate
argument_list|(
name|strlen
argument_list|(
name|pages
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|unravel_pages
argument_list|(
name|pages
argument_list|,
name|page_select
argument_list|)
expr_stmt|;
block|}
comment|/* write the preamble for the interpress file */
name|AppendOp
argument_list|(
name|OP_beginBlock
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_beginBody
argument_list|)
expr_stmt|;
comment|/* preamble start */
comment|/* setup font definitions in frame */
name|SetupFont
argument_list|(
name|headfont
operator|.
name|ft_universal_name
argument_list|,
name|headfont
operator|.
name|ft_size
operator|*
literal|10.
argument_list|,
name|F_headfont
argument_list|)
expr_stmt|;
name|SetupFont
argument_list|(
name|bodyfont
operator|.
name|ft_universal_name
argument_list|,
name|bodyfont
operator|.
name|ft_size
operator|*
literal|10.
argument_list|,
name|F_bodyfont
argument_list|)
expr_stmt|;
name|SetupFont
argument_list|(
name|italicfont
operator|.
name|ft_universal_name
argument_list|,
name|headfont
operator|.
name|ft_size
operator|*
literal|10.
argument_list|,
comment|/* use headfont's size */
name|F_italicfont
argument_list|)
expr_stmt|;
comment|/* remember special fonts */
if|if
condition|(
name|strcmp
argument_list|(
name|bodyfont
operator|.
name|ft_leaf_name
argument_list|,
literal|"Terminal"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special_font
operator|=
name|Font_Terminal
expr_stmt|;
block|}
comment|/* save scaling transform that uses 1/10 point co-ordinate system */
name|top_margin
operator|=
operator|(
name|rflg
condition|?
name|Page_width
else|:
name|Page_length
operator|)
operator|-
name|Orig_y
expr_stmt|;
if|if
condition|(
name|tflg
condition|)
comment|/* the user may not want headings... */
name|top_margin
operator|+=
name|Header_to_orig_y
expr_stmt|;
comment|/* use heading area */
name|bottom_margin
operator|=
literal|2
operator|*
name|Sixth_INCH
expr_stmt|;
name|right_margin
operator|=
operator|(
name|rflg
condition|?
name|Page_length
else|:
name|Page_width
operator|)
operator|-
name|Orig_x
expr_stmt|;
name|column_separation
operator|=
operator|(
name|right_margin
operator|-
name|Orig_x
operator|)
operator|/
name|columns
expr_stmt|;
name|line_spacing
operator|=
operator|(
name|bodyfont
operator|.
name|ft_size
operator|+
operator|(
operator|(
name|bodyfont
operator|.
name|ft_size
operator|>
literal|8
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
operator|)
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|rflg
condition|)
block|{
comment|/* we need a rotation transform, too */
name|Rotate
argument_list|(
literal|90.
argument_list|)
expr_stmt|;
name|Translate
argument_list|(
operator|(
name|double
operator|)
name|Page_width
argument_list|,
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|AppendRational
argument_list|(
literal|353L
argument_list|,
literal|10000000L
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflg
condition|)
block|{
name|AppendOp
argument_list|(
name|OP_concat
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_concat
argument_list|)
expr_stmt|;
block|}
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|F_transform
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_fset
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_endBody
argument_list|)
expr_stmt|;
comment|/* end preamble */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* no filenames -- do standard input */
name|filename
operator|=
name|NULL
expr_stmt|;
name|do_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|filename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* this is really standard input */
name|filename
operator|=
name|NULL
expr_stmt|;
name|do_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* open the file */
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|system_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* wrap up the output */
name|ip_select
argument_list|(
name|ipress_file
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_endBlock
argument_list|)
expr_stmt|;
name|ip_close
argument_list|()
expr_stmt|;
comment|/* send to the printer */
if|if
condition|(
name|send_to_printer
condition|)
block|{
if|if
condition|(
name|pages_printed
operator|==
literal|0
condition|)
block|{
comment|/* don't print anything but remove temporary */
ifdef|#
directive|ifdef
name|vax11c
name|delete
argument_list|(
name|output
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|output
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|vax11c
name|char
name|buff
index|[
literal|256
index|]
decl_stmt|;
name|int
name|wait
init|=
literal|0
decl_stmt|;
name|$DESCRIPTOR
argument_list|(
name|buffdesc
argument_list|,
name|buff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"xpress/noformat "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buff
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|buffdesc
operator|.
name|dsc$w_length
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|lib$spawn
argument_list|(
operator|&
name|buffdesc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|wait
argument_list|)
operator|)
operator|!=
name|SS$_NORMAL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nFile %s contains interpress master\n"
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|delete
argument_list|(
name|output
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|buff
decl_stmt|;
comment|/* exec a "qip" to queue the file */
name|buff
operator|=
name|allocate
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"F"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buff
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|printer
condition|)
name|execlp
argument_list|(
name|QIP
argument_list|,
literal|"qip"
argument_list|,
literal|"-q"
argument_list|,
name|printer
argument_list|,
literal|"-c"
argument_list|,
name|copies
argument_list|,
literal|"-nc"
argument_list|,
literal|"-nk"
argument_list|,
literal|"-t"
argument_list|,
name|banner
argument_list|,
literal|"-x"
argument_list|,
name|buff
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|execlp
argument_list|(
name|QIP
argument_list|,
literal|"qip"
argument_list|,
literal|"-c"
argument_list|,
name|copies
argument_list|,
literal|"-nc"
argument_list|,
literal|"-nk"
argument_list|,
literal|"-t"
argument_list|,
name|banner
argument_list|,
literal|"-x"
argument_list|,
name|buff
argument_list|,
name|output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't execl the queing program: %s\n"
argument_list|,
name|QIP
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|QIP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File %s contains interpress master.\n"
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_macro
name|get_options
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|process_arg
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *  unravel_pages(str, spec) - unravel the page range specification in "str"  *			       into integer pairs in "spec".  The first two  *			       ints in "spec" bound the first range of pages,  *			       the next two bound the second range, and so on.  *			       The array is terminated with the pair 0, 0.  */
end_comment

begin_macro
name|unravel_pages
argument_list|(
argument|str
argument_list|,
argument|spec
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|spec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|last_num
init|=
literal|0
decl_stmt|;
name|int
name|this_num
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
name|boolean
name|is_range
init|=
name|No
decl_stmt|;
name|boolean
name|bad_spec
init|=
name|No
decl_stmt|;
name|boolean
name|done
init|=
name|No
decl_stmt|;
define|#
directive|define
name|Start_new_num
value|(last_num = this_num, this_num = 0)
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|str
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
comment|/* set "done" flag and pretend it's the end of a number */
name|done
operator|=
name|Yes
expr_stmt|;
name|ch
operator|=
literal|','
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
name|this_num
operator|*=
literal|10
expr_stmt|;
name|this_num
operator|+=
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|this_num
operator|<
name|last_num
operator|&&
operator|*
name|str
operator|!=
literal|'\0'
condition|)
block|{
name|bad_spec
operator|=
name|Yes
expr_stmt|;
block|}
operator|*
name|spec
operator|++
operator|=
name|this_num
expr_stmt|;
name|Start_new_num
expr_stmt|;
name|is_range
operator|=
name|Yes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|this_num
operator|<
name|last_num
condition|)
block|{
name|bad_spec
operator|=
name|Yes
expr_stmt|;
block|}
operator|*
name|spec
operator|++
operator|=
name|this_num
expr_stmt|;
if|if
condition|(
name|is_range
condition|)
block|{
name|is_range
operator|=
name|No
expr_stmt|;
block|}
else|else
block|{
operator|*
name|spec
operator|++
operator|=
name|this_num
expr_stmt|;
block|}
name|Start_new_num
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad character in page specification\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|--
name|spec
operator|==
literal|0
condition|)
block|{
operator|*
name|spec
operator|=
literal|1
operator|<<
literal|15
expr_stmt|;
comment|/* infinity */
block|}
if|if
condition|(
name|bad_spec
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: pages should be given in non-descending order.\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|process_arg
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|>
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
comment|/* this is a column count specifier */
name|columns
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* not an option */
return|return
operator|(
name|No
operator|)
return|;
case|case
literal|'b'
case|:
name|banner
operator|=
name|next_arg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|temp
operator|=
name|atoi
argument_list|(
name|copies
operator|=
name|next_arg
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bogus number of copies; you only get one!\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|copies
operator|=
literal|"1"
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|bodyfont_name
operator|=
name|next_arg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|headfont_name
operator|=
name|next_arg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* replace header */
name|tflg
operator|=
name|No
expr_stmt|;
name|header
operator|=
name|next_arg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* append to header */
name|tflg
operator|=
name|No
expr_stmt|;
name|p1
operator|=
name|next_arg
argument_list|()
expr_stmt|;
name|p2
operator|=
name|allocate
argument_list|(
name|strlen
argument_list|(
name|header
argument_list|)
operator|+
name|strlen
argument_list|(
name|p1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p2
argument_list|,
name|header
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|p2
argument_list|,
literal|"      "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|p2
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|header
operator|=
name|p2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|tflg
operator|=
name|lflg
operator|=
name|Yes
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|name
operator|=
name|next_arg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|output
operator|=
name|next_arg
argument_list|()
expr_stmt|;
name|send_to_printer
operator|=
name|No
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|printer
operator|=
name|next_arg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rflg
operator|=
name|Yes
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|rflg
operator|=
name|No
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|pages
operator|=
name|next_arg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tflg
operator|=
name|Yes
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown option '%c'\n"
argument_list|,
name|myname
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Yes
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|No
operator|)
return|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|next_arg
parameter_list|()
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
return|return
operator|(
operator|(
operator|++
name|argv
operator|)
index|[
literal|0
index|]
operator|)
return|;
block|}
else|else
block|{
name|argv
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
operator|&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *  establish_font(name, font) - break apart the parts of the string "name"  *				 and fill in the structure pointed to by  *				 "font".  Also, verify that the font requested  *				 actually exists.  This routine also  *				 understands universal font names.  */
end_comment

begin_macro
name|establish_font
argument_list|(
argument|name
argument_list|,
argument|font
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|font
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|unamep
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|slashp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
comment|/* not a universal name -- put the default on the front */
name|font
operator|->
name|ft_universal_name
operator|=
name|unamep
operator|=
name|allocate
argument_list|(
name|strlen
argument_list|(
name|Default_universal_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|unamep
argument_list|,
name|Default_universal_prefix
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|unamep
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* already is a universal name -- just allocate space for it */
name|font
operator|->
name|ft_universal_name
operator|=
name|unamep
operator|=
name|allocate
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy in the whole name, without the leading slash */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|unamep
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* strip size off the end, if it is there */
if|if
condition|(
operator|(
name|slashp
operator|=
name|ptr
operator|=
name|rindex
argument_list|(
name|unamep
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
name|ch
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
operator|++
name|ptr
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ch
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
condition|)
block|{
comment|/* last element is not a number -- no point size */
name|size
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* shift this digit in */
name|size
operator|*=
literal|10
expr_stmt|;
name|size
operator|+=
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
comment|/* if no point size, use default */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|font
operator|->
name|ft_size
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|font
operator|->
name|ft_size
operator|=
name|size
expr_stmt|;
operator|*
name|slashp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* set pointer to last element */
if|if
condition|(
operator|(
name|ptr
operator|=
name|rindex
argument_list|(
name|unamep
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|font
operator|->
name|ft_leaf_name
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|font
operator|->
name|ft_leaf_name
operator|=
name|font
operator|->
name|ft_universal_name
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|do_file
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|char
name|input_line
index|[
name|Line_size
index|]
decl_stmt|;
name|char
name|line_buffer
index|[
name|Line_size
index|]
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|current_line
decl_stmt|;
name|int
name|lines_on_page
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|column
decl_stmt|;
ifndef|#
directive|ifndef
name|vax11c
comment|/* fstat it to get information displayed in the header */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|file
argument_list|)
argument_list|,
operator|&
name|file_stat
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|system_error
argument_list|(
literal|"fstat botched"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* reset essentials */
name|page_number
operator|=
literal|0
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
name|lines_on_page
operator|=
literal|0
expr_stmt|;
name|curr_page_select
operator|=
name|page_select
expr_stmt|;
if|if
condition|(
name|pages
operator|!=
name|NULL
condition|)
block|{
name|page_low
operator|=
name|page_select
index|[
literal|0
index|]
expr_stmt|;
name|page_high
operator|=
name|page_select
index|[
literal|1
index|]
expr_stmt|;
block|}
name|current_line
operator|=
name|top_margin
expr_stmt|;
comment|/*      *  Strangeness:  page_number is incremented by page_start and      *  line_number is incremented in the "while(fgets..." loop.      */
comment|/* start the first page */
name|page_start
argument_list|()
expr_stmt|;
comment|/*      *  More strangeness:  we had to set line_number to 1 to trick      *  page_start into reporting the right line count in the header.  Now      *  we reset it to 0 before entering the read/print loop.      */
name|line_number
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|input_line
argument_list|,
name|Line_size
argument_list|,
name|file
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* new line */
name|line_number
operator|++
expr_stmt|;
comment|/* remember the length */
name|length
operator|=
name|strlen
argument_list|(
name|input_line
argument_list|)
expr_stmt|;
comment|/* nuke any trailing newline */
if|if
condition|(
name|input_line
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|input_line
index|[
operator|--
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|lflg
condition|?
name|lines_on_page
operator|>=
literal|66
else|:
name|current_line
operator|<
name|bottom_margin
condition|)
block|{
comment|/* start a new page */
name|page_end
argument_list|(
name|No
argument_list|)
expr_stmt|;
name|page_start
argument_list|()
expr_stmt|;
name|lines_on_page
operator|=
literal|0
expr_stmt|;
comment|/* remember, y goes backwards */
name|current_line
operator|=
name|top_margin
expr_stmt|;
block|}
comment|/* make sure that the line actually contains something */
if|if
condition|(
name|input_line
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* set x and y for the beginning of the line */
name|Setxy
argument_list|(
operator|(
name|double
operator|)
name|left_margin
argument_list|,
operator|(
name|double
operator|)
name|current_line
argument_list|)
expr_stmt|;
comment|/* copy from input_line to line_buffer making any necessary 	       changes along the way */
name|column
operator|=
literal|0
expr_stmt|;
name|src
operator|=
name|input_line
expr_stmt|;
name|dest
operator|=
name|line_buffer
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|src
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* carriage return */
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line_buffer
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ShowString
argument_list|(
name|line_buffer
argument_list|)
expr_stmt|;
block|}
name|Setxy
argument_list|(
operator|(
name|double
operator|)
name|left_margin
argument_list|,
operator|(
name|double
operator|)
name|current_line
argument_list|)
expr_stmt|;
name|dest
operator|=
name|line_buffer
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
comment|/* new page after this line */
name|current_line
operator|=
name|bottom_margin
expr_stmt|;
name|lines_on_page
operator|=
literal|66
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
comment|/* tab expansion */
do|do
block|{
operator|*
name|dest
operator|++
operator|=
literal|' '
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|column
operator|%
name|tab_amount
operator|!=
literal|0
condition|)
do|;
break|break;
case|case
literal|'$'
case|:
operator|*
name|dest
operator|++
operator|=
literal|'\244'
expr_stmt|;
name|column
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|special_font
operator|==
name|Font_Terminal
condition|)
block|{
comment|/* heavy hackery here */
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
name|ShowString
argument_list|(
name|line_buffer
argument_list|)
expr_stmt|;
name|Setyrel
argument_list|(
operator|-
literal|20.
argument_list|)
expr_stmt|;
name|ShowString
argument_list|(
literal|"\305"
argument_list|)
expr_stmt|;
name|Setyrel
argument_list|(
literal|20.
argument_list|)
expr_stmt|;
name|dest
operator|=
name|line_buffer
expr_stmt|;
name|column
operator|++
expr_stmt|;
break|break;
block|}
comment|/* else fall thru ... */
default|default:
operator|*
name|dest
operator|++
operator|=
name|ch
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line_buffer
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ShowString
argument_list|(
name|line_buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* advance the line counters */
name|current_line
operator|-=
name|line_spacing
expr_stmt|;
name|lines_on_page
operator|++
expr_stmt|;
block|}
comment|/* wrap up the file */
name|page_end
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  page handling:  a distinction is made between virtual pages and actual  *  pages.  A virtual page is one series of lines from the file that appears  *  vertically on the printed page.  The actual page is the page as the  *  printer prints it (a printed page, if you will).  There may be several  *  virtual pages on one actual page.  The page_start and page_end routines  *  that follow start and terminate virtual pages.  The mapping between  *  virtual and actual pages is a function of the options specified by the  *  user.  If the user requests two column output then there will be two  *  virtual pages for every actual page.  These pages will sit side-by-side on  *  the actual page.  The mapping is accomplished by changing the variables  *  left_margin and right_margin.  "page_start" also handles printing of the  *  page header, since there is only one of these on every actual page.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_column
decl_stmt|;
end_decl_stmt

begin_macro
name|page_start
argument_list|()
end_macro

begin_block
block|{
name|boolean
name|in_set
decl_stmt|;
ifdef|#
directive|ifdef
name|vax11c
name|long
name|bintim
decl_stmt|;
endif|#
directive|endif
comment|/* reset the column count if starting a new file */
if|if
condition|(
name|line_number
operator|==
literal|1
condition|)
block|{
name|current_column
operator|=
literal|0
expr_stmt|;
block|}
comment|/* either move the left margin or put out a new page */
if|if
condition|(
name|current_column
operator|!=
literal|0
condition|)
block|{
name|left_margin
operator|+=
name|column_separation
expr_stmt|;
block|}
else|else
block|{
comment|/* increment page count and reset margin */
name|page_number
operator|++
expr_stmt|;
name|left_margin
operator|=
name|Orig_x
expr_stmt|;
comment|/* is it in the page specification set? */
if|if
condition|(
name|page_select
operator|==
name|NULL
condition|)
block|{
comment|/* every page is in the set if there is no specification */
name|in_set
operator|=
name|Yes
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|page_low
operator|<=
name|page_number
operator|&&
name|page_number
operator|<=
name|page_high
condition|)
block|{
name|in_set
operator|=
name|Yes
expr_stmt|;
name|ip_select
argument_list|(
name|ipress_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_number
operator|==
name|page_high
condition|)
block|{
comment|/* at the top of the current range -- time to move up */
name|curr_page_select
operator|+=
literal|2
expr_stmt|;
name|page_low
operator|=
name|curr_page_select
index|[
literal|0
index|]
expr_stmt|;
name|page_high
operator|=
name|curr_page_select
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not in set -- redirect output to null device */
name|in_set
operator|=
name|No
expr_stmt|;
name|ip_select
argument_list|(
name|null_file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_set
condition|)
block|{
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
comment|/* increment total page count */
name|pages_printed
operator|++
expr_stmt|;
comment|/* output stuff for new ip page */
name|AppendOp
argument_list|(
name|OP_beginBody
argument_list|)
expr_stmt|;
comment|/* set the transformation */
name|Fget
argument_list|(
name|F_transform
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
comment|/* build the header if we need to print it */
if|if
condition|(
operator|!
name|tflg
condition|)
block|{
comment|/* move characters from header to real_header */
comment|/* and expand format items along the way.     */
name|src
operator|=
name|header
expr_stmt|;
name|dst
operator|=
name|real_header
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|src
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
name|ch
operator|=
operator|*
operator|++
name|src
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* file name */
name|dst
operator|=
name|strecpy
argument_list|(
name|dst
argument_list|,
name|filename
operator|==
name|NULL
condition|?
literal|"Standard input"
else|:
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* mtime */
ifdef|#
directive|ifdef
name|vax11c
name|time
argument_list|(
operator|&
name|bintim
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dst
argument_list|,
name|ctime
argument_list|(
operator|&
name|bintim
argument_list|)
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|24
expr_stmt|;
else|#
directive|else
comment|/* 				 *  ctime returns a 26 character string that 				 *  has a newline and null at the end. 				 *  26 - 2 == 24. 				 */
if|if
condition|(
name|file_stat
operator|.
name|st_mtime
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|dst
argument_list|,
name|ctime
argument_list|(
operator|&
name|file_stat
operator|.
name|st_mtime
argument_list|)
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|24
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|'p'
case|:
comment|/* page number */
name|dst
operator|=
name|itoa
argument_list|(
name|dst
argument_list|,
name|page_number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* line number */
name|dst
operator|=
name|itoa
argument_list|(
name|dst
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* end of the string */
name|src
operator|--
expr_stmt|;
comment|/* maintain loop invariant */
break|break;
default|default:
comment|/* copy the character */
operator|*
name|dst
operator|++
operator|=
name|ch
expr_stmt|;
comment|/* break; */
block|}
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
name|ch
expr_stmt|;
block|}
name|src
operator|++
expr_stmt|;
block|}
comment|/* terminate the real header */
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
comment|/* display the header */
name|Setxy
argument_list|(
call|(
name|double
call|)
argument_list|(
name|left_margin
operator|-
name|Header_to_orig_x
argument_list|)
argument_list|,
call|(
name|double
call|)
argument_list|(
name|top_margin
operator|+
name|Header_to_orig_y
argument_list|)
argument_list|)
expr_stmt|;
name|Setfont
argument_list|(
name|F_headfont
argument_list|)
expr_stmt|;
name|ShowString
argument_list|(
name|real_header
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* select the body font */
name|Setfont
argument_list|(
name|F_bodyfont
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|page_end
argument_list|(
argument|eof
argument_list|)
end_macro

begin_decl_stmt
name|int
name|eof
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|current_column
operator|=
operator|++
name|current_column
operator|%
name|columns
operator|)
operator|==
literal|0
operator|||
name|eof
condition|)
block|{
name|AppendOp
argument_list|(
name|OP_endBody
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|strecpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
condition|)
empty_stmt|;
return|return
operator|(
operator|--
name|dest
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|itoa
parameter_list|(
name|buff
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|char
name|tbuff
index|[
literal|12
index|]
decl_stmt|;
comment|/* will build number here -- max of 10 digits */
specifier|register
name|char
modifier|*
name|ptr
init|=
name|tbuff
operator|+
literal|11
decl_stmt|;
operator|*
name|ptr
operator|--
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|--
operator|=
operator|(
name|val
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|val
operator|/=
literal|10
expr_stmt|;
block|}
return|return
operator|(
name|strecpy
argument_list|(
name|buff
argument_list|,
operator|++
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  allocate(space) - allocate "space" bytes with sbrk.  This routine uses a  *		      fairly naive algorithm.  It sbrk-s space in Break_size  *		      chunks and allocates space from a chunk until a request  *		      for more space than is left in the chunk is made.  Then,  *		      it allocates a new chunk.  The unused space at the end  *		      of the old chunk remains unused.  This does NOT depend  *		      on sbrk returning contiguous chunks of memory during the  *		      life of the program.  If the request is greater than  *		      Break_size, the next multiple of Break_size greater  *		      than the request size is chosen.  */
end_comment

begin_function
name|char
modifier|*
name|allocate
parameter_list|(
name|space
parameter_list|)
name|int
name|space
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|hi_water
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|max_alloc
init|=
name|NULL
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|hi_water
operator|==
name|NULL
operator|||
name|max_alloc
operator|+
name|space
operator|>
name|hi_water
condition|)
block|{
name|int
name|alloc_size
init|=
operator|(
name|space
operator|<=
name|Break_size
condition|?
name|Break_size
else|:
operator|(
operator|(
name|space
operator|+
name|Break_size
operator|-
literal|1
operator|)
operator|/
name|Break_size
operator|)
operator|*
name|Break_size
operator|)
decl_stmt|;
name|hi_water
operator|=
name|sbrk
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|hi_water
operator|==
operator|-
literal|1
condition|)
block|{
name|system_error
argument_list|(
literal|"out of space"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|max_alloc
operator|=
name|hi_water
operator|+
name|alloc_size
operator|-
literal|1
expr_stmt|;
block|}
name|ptr
operator|=
name|hi_water
expr_stmt|;
name|hi_water
operator|+=
name|space
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_macro
name|system_error
argument_list|(
argument|message
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|saved_errno
decl_stmt|;
comment|/* value of errno not preserved by fprintf */
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
name|perror
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_function
name|char
modifier|*
name|rindex
parameter_list|(
name|string
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|pos
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|string
operator|==
name|c
condition|)
name|pos
operator|=
name|string
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|string
operator|++
condition|)
do|;
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

