begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote tape emulator subroutines.    Copyright (C) 1988 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* JF: modified to make all rmtXXX calls into macros for speed */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /usr/src/local/usr.lib/librmt/RCS/rmtlib.c,v 1.7 89/03/23 14:09:51 root Exp Locker: root $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Log:	rmtlib.c,v $  * Revision 1.7  89/03/23  14:09:51  root  * Fix from haynes@ucscc.ucsc.edu for use w/compat. ADR.  *   * Revision 1.6  88/10/25  17:04:29  root  * rexec code and a bug fix from srs!dan, miscellanious cleanup. ADR.  *   * Revision 1.5  88/10/25  16:30:17  root  * Fix from jeff@gatech.edu for getting user@host:dev right. ADR.  *   * Revision 1.4  87/10/30  10:36:12  root  * Made 4.2 syntax a compile time option. ADR.  *   * Revision 1.3  87/04/22  11:16:48  root  * Two fixes from parmelee@wayback.cs.cornell.edu to correctly  * do fd biasing and rmt protocol on 'S' command. ADR.  *   * Revision 1.2  86/10/09  16:38:53  root  * Changed to reflect 4.3BSD rcp syntax. ADR.  *   * Revision 1.1  86/10/09  16:17:35  root  * Initial revision  *   */
end_comment

begin_comment
comment|/*  *	rmt --- remote tape emulator subroutines  *  *	Originally written by Jeff Lee, modified some by Arnold Robbins  *  *	WARNING:  The man page rmt(8) for /etc/rmt documents the remote mag  *	tape protocol which rdump and rrestore use.  Unfortunately, the man  *	page is *WRONG*.  The author of the routines I'm including originally  *	wrote his code just based on the man page, and it didn't work, so he  *	went to the rdump source to figure out why.  The only thing he had to  *	change was to check for the 'F' return code in addition to the 'E',  *	and to separate the various arguments with \n instead of a space.  I  *	personally don't think that this is much of a problem, but I wanted to  *	point it out.  *	-- Arnold Robbins  *  *	Redone as a library that can replace open, read, write, etc, by  *	Fred Fish, with some additional work by Arnold Robbins.  */
end_comment

begin_comment
comment|/* Use -DUSE_REXEC for rexec code, courtesy of Dan Kegel, srs!dan */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_MTIO
argument_list|)
end_if

begin_define
define|#
directive|define
name|NO_RMTIOCTL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_RMTIOCTL
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_REXEC
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|BUFMAGIC
value|64
end_define

begin_comment
comment|/* a magic number for buffer sizes */
end_comment

begin_comment
comment|/*  *	MAXUNIT --- Maximum number of remote tape file units  */
end_comment

begin_define
define|#
directive|define
name|MAXUNIT
value|4
end_define

begin_comment
comment|/*  *	READ --- Return the number of the read side file descriptor  *	WRITE --- Return the number of the write side file descriptor  */
end_comment

begin_define
define|#
directive|define
name|READ
parameter_list|(
name|fd
parameter_list|)
value|(Ctp[fd][0])
end_define

begin_define
define|#
directive|define
name|WRITE
parameter_list|(
name|fd
parameter_list|)
value|(Ptc[fd][1])
end_define

begin_decl_stmt
specifier|static
name|int
name|Ctp
index|[
name|MAXUNIT
index|]
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Ptc
index|[
name|MAXUNIT
index|]
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|__rmt_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	_rmt_panic --- close off a remote tape connection  */
end_comment

begin_function
specifier|static
name|void
name|_rmt_panic
parameter_list|(
name|fildes
parameter_list|)
name|int
name|fildes
decl_stmt|;
block|{
name|close
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|WRITE
argument_list|(
name|fildes
argument_list|)
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|fildes
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|WRITE
argument_list|(
name|fildes
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	command --- attempt to perform a remote tape command  */
end_comment

begin_function
specifier|static
name|int
name|command
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|blen
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGNAL_VOID
name|void
function_decl|(
modifier|*
name|pstat
function_decl|)
parameter_list|()
function_decl|;
else|#
directive|else
name|int
function_decl|(
modifier|*
name|pstat
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/*  *	save current pipe status and try to make the request  */
name|blen
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|pstat
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|WRITE
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|buf
argument_list|,
name|blen
argument_list|)
operator|==
name|blen
condition|)
block|{
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pstat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *	something went wrong. close down and go home  */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pstat
argument_list|)
expr_stmt|;
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	status --- retrieve the status from the pipe  */
end_comment

begin_function
specifier|static
name|int
name|status
parameter_list|(
name|fildes
parameter_list|)
name|int
name|fildes
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFMAGIC
index|]
decl_stmt|;
comment|/*  *	read the reply command line  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
name|buffer
init|;
name|i
operator|<
name|BUFMAGIC
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|BUFMAGIC
condition|)
block|{
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	check the return status  */
for|for
control|(
name|cp
operator|=
name|buffer
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'E'
operator|||
operator|*
name|cp
operator|==
literal|'F'
condition|)
block|{
name|errno
operator|=
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|read
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'F'
condition|)
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	check for mis-synced pipes  */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'A'
condition|)
block|{
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|atoi
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_REXEC
end_ifdef

begin_comment
comment|/*  * _rmt_rexec  *  * execute /etc/rmt on a remote system using rexec().  * Return file descriptor of bidirectional socket for stdin and stdout  * If username is NULL, or an empty string, uses current username.  *  * ADR: By default, this code is not used, since it requires that  * the user have a .netrc file in his/her home directory, or that the  * application designer be willing to have rexec prompt for login and  * password info. This may be unacceptable, and .rhosts files for use  * with rsh are much more common on BSD systems.  */
end_comment

begin_function
specifier|static
name|int
name|_rmt_rexec
parameter_list|(
name|host
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
comment|/* may be NULL */
block|{
name|struct
name|servent
modifier|*
name|rexecserv
decl_stmt|;
name|int
name|save_stdin
init|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|save_stdout
init|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|tape_fd
decl_stmt|;
comment|/* Return value. */
comment|/* 	 * When using cpio -o< filename, stdin is no longer the tty. 	 * But the rexec subroutine reads the login and the passwd on stdin,  	 * to allow remote execution of the command. 	 * So, reopen stdin and stdout on /dev/tty before the rexec and 	 * give them back their original value after. 	 */
if|if
condition|(
name|freopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|rexecserv
operator|=
name|getservbyname
argument_list|(
literal|"exec"
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|rexecserv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"? exec/tcp: service not available."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|user
operator|!=
name|NULL
operator|)
operator|&&
operator|*
name|user
operator|==
literal|'\0'
condition|)
name|user
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|tape_fd
operator|=
name|rexec
argument_list|(
operator|&
name|host
argument_list|,
name|rexecserv
operator|->
name|s_port
argument_list|,
name|user
argument_list|,
name|NULL
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|fdopen
argument_list|(
name|save_stdin
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fdopen
argument_list|(
name|save_stdout
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
return|return
name|tape_fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_REXEC */
end_comment

begin_comment
comment|/*  *	_rmt_open --- open a magtape device on system specified, as given user  *  *	file name has the form [user@]system:/dev/???? #ifdef COMPAT  *	file name has the form system[.user]:/dev/???? #endif  */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTLEN
value|257
end_define

begin_comment
comment|/* BSD allows very long host names... */
end_comment

begin_function
name|int
name|__rmt_open
parameter_list|(
name|path
parameter_list|,
name|oflag
parameter_list|,
name|mode
parameter_list|,
name|bias
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|oflag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|bias
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|char
name|buffer
index|[
name|BUFMAGIC
index|]
decl_stmt|;
name|char
name|system
index|[
name|MAXHOSTLEN
index|]
decl_stmt|;
name|char
name|device
index|[
name|BUFMAGIC
index|]
decl_stmt|;
name|char
name|login
index|[
name|BUFMAGIC
index|]
decl_stmt|;
name|char
modifier|*
name|sys
decl_stmt|,
modifier|*
name|dev
decl_stmt|,
modifier|*
name|user
decl_stmt|;
name|sys
operator|=
name|system
expr_stmt|;
name|dev
operator|=
name|device
expr_stmt|;
name|user
operator|=
name|login
expr_stmt|;
comment|/*  *	first, find an open pair of file descriptors  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNIT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|READ
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|WRITE
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXUNIT
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	pull apart system and device, and optional user  *	don't munge original string  *	if COMPAT is defined, also handle old (4.2) style person.site notation.  */
while|while
condition|(
operator|*
name|path
operator|!=
literal|'@'
ifdef|#
directive|ifdef
name|COMPAT
operator|&&
operator|*
name|path
operator|!=
literal|'.'
endif|#
directive|endif
operator|&&
operator|*
name|path
operator|!=
literal|':'
condition|)
block|{
operator|*
name|sys
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|sys
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|path
operator|-
literal|1
operator|)
operator|==
literal|'@'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|user
argument_list|,
name|system
argument_list|)
expr_stmt|;
comment|/* saw user part of user@host */
name|sys
operator|=
name|system
expr_stmt|;
comment|/* start over */
while|while
condition|(
operator|*
name|path
operator|!=
literal|':'
condition|)
block|{
operator|*
name|sys
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|sys
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMPAT
elseif|else
if|if
condition|(
operator|*
operator|(
name|path
operator|-
literal|1
operator|)
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
operator|*
name|path
operator|!=
literal|':'
condition|)
block|{
operator|*
name|user
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|user
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
else|else
operator|*
name|user
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|path
condition|)
block|{
operator|*
name|dev
operator|++
operator|=
operator|*
name|path
operator|++
expr_stmt|;
block|}
operator|*
name|dev
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_REXEC
comment|/*   *	Execute the remote command using rexec   */
name|READ
argument_list|(
name|i
argument_list|)
operator|=
name|WRITE
argument_list|(
name|i
argument_list|)
operator|=
name|_rmt_rexec
argument_list|(
name|system
argument_list|,
name|login
argument_list|)
expr_stmt|;
if|if
condition|(
name|READ
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/*  *	setup the pipes for the 'rsh' command and fork  */
if|if
condition|(
name|pipe
argument_list|(
name|Ptc
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|pipe
argument_list|(
name|Ctp
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|Ptc
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Ptc
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Ptc
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|Ctp
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Ctp
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Ctp
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|login
condition|)
block|{
name|execl
argument_list|(
literal|"/usr/ucb/rsh"
argument_list|,
literal|"rsh"
argument_list|,
name|system
argument_list|,
literal|"-l"
argument_list|,
name|login
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/remsh"
argument_list|,
literal|"remsh"
argument_list|,
name|system
argument_list|,
literal|"-l"
argument_list|,
name|login
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/rsh"
argument_list|,
literal|"rsh"
argument_list|,
name|system
argument_list|,
literal|"-l"
argument_list|,
name|login
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bsd/rsh"
argument_list|,
literal|"rsh"
argument_list|,
name|system
argument_list|,
literal|"-l"
argument_list|,
name|login
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/nsh"
argument_list|,
literal|"nsh"
argument_list|,
name|system
argument_list|,
literal|"-l"
argument_list|,
name|login
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execl
argument_list|(
literal|"/usr/ucb/rsh"
argument_list|,
literal|"rsh"
argument_list|,
name|system
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/remsh"
argument_list|,
literal|"remsh"
argument_list|,
name|system
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/rsh"
argument_list|,
literal|"rsh"
argument_list|,
name|system
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bsd/rsh"
argument_list|,
literal|"rsh"
argument_list|,
name|system
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/nsh"
argument_list|,
literal|"nsh"
argument_list|,
name|system
argument_list|,
literal|"/etc/rmt"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  *	bad problems if we get here  */
name|perror
argument_list|(
literal|"remote shell exec"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|Ptc
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Ctp
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	now attempt to open the tape device  */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"O%s\n%d\n"
argument_list|,
name|device
argument_list|,
name|oflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|i
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|status
argument_list|(
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|i
operator|+
name|bias
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	_rmt_close --- close a remote magtape unit and shut down  */
end_comment

begin_function
name|int
name|__rmt_close
parameter_list|(
name|fildes
parameter_list|)
name|int
name|fildes
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
literal|"C\n"
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rc
operator|=
name|status
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	_rmt_read --- read a buffer from a remote tape  */
end_comment

begin_function
name|int
name|__rmt_read
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|,
name|nbyte
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|nbyte
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFMAGIC
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"R%d\n"
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|rc
operator|=
name|status
argument_list|(
name|fildes
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rc
condition|;
name|i
operator|+=
name|nbyte
operator|,
name|buf
operator|+=
name|nbyte
control|)
block|{
name|nbyte
operator|=
name|read
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|buf
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbyte
operator|<=
literal|0
condition|)
block|{
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	_rmt_write --- write a buffer to the remote tape  */
end_comment

begin_function
name|int
name|__rmt_write
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|,
name|nbyte
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|nbyte
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFMAGIC
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGNAL_VOID
name|void
function_decl|(
modifier|*
name|pstat
function_decl|)
parameter_list|()
function_decl|;
else|#
directive|else
name|int
function_decl|(
modifier|*
name|pstat
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"W%d\n"
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pstat
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|WRITE
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|buf
argument_list|,
name|nbyte
argument_list|)
operator|==
name|nbyte
condition|)
block|{
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
argument_list|(
name|fildes
argument_list|)
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pstat
argument_list|)
expr_stmt|;
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	_rmt_lseek --- perform an imitation lseek operation remotely  */
end_comment

begin_function
name|long
name|__rmt_lseek
parameter_list|(
name|fildes
parameter_list|,
name|offset
parameter_list|,
name|whence
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|whence
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFMAGIC
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"L%d\n%d\n"
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|status
argument_list|(
name|fildes
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	_rmt_ioctl --- perform raw tape operations remotely  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_RMTIOCTL
end_ifndef

begin_macro
name|__rmt_ioctl
argument_list|(
argument|fildes
argument_list|,
argument|op
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fildes
decl_stmt|,
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|cnt
decl_stmt|;
name|char
name|buffer
index|[
name|BUFMAGIC
index|]
decl_stmt|;
comment|/*  *	MTIOCOP is the easy one. nothing is transfered in binary  */
if|if
condition|(
name|op
operator|==
name|MTIOCTOP
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"I%d\n%d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_op
argument_list|,
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|status
argument_list|(
name|fildes
argument_list|)
operator|)
return|;
block|}
comment|/*  *	we can only handle 2 ops, if not the other one, punt  */
if|if
condition|(
name|op
operator|!=
name|MTIOCGET
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	grab the status and read it directly into the structure  *	this assumes that the status buffer is (hopefully) not  *	padded and that 2 shorts fit in a long without any word  *	alignment problems, ie - the whole struct is contiguous  *	NOTE - this is probably NOT a good assumption.  */
if|if
condition|(
name|command
argument_list|(
name|fildes
argument_list|,
literal|"S"
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|rc
operator|=
name|status
argument_list|(
name|fildes
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
init|;
name|rc
operator|>
literal|0
condition|;
name|rc
operator|-=
name|cnt
operator|,
name|arg
operator|+=
name|cnt
control|)
block|{
name|cnt
operator|=
name|read
argument_list|(
name|READ
argument_list|(
name|fildes
argument_list|)
argument_list|,
name|arg
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
block|{
name|_rmt_panic
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/*  *	now we check for byte position. mt_type is a small integer field  *	(normally) so we will check its magnitude. if it is larger than  *	256, we will assume that the bytes are swapped and go through  *	and reverse all the bytes  */
if|if
condition|(
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_type
operator|<
literal|256
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|rc
condition|;
name|cnt
operator|+=
literal|2
control|)
block|{
name|c
operator|=
name|arg
index|[
name|cnt
index|]
expr_stmt|;
name|arg
index|[
name|cnt
index|]
operator|=
name|arg
index|[
name|cnt
operator|+
literal|1
index|]
expr_stmt|;
name|arg
index|[
name|cnt
operator|+
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_RMTIOCTL */
end_comment

end_unit

