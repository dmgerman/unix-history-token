begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended regular expression matching and search library.    Copyright (C) 1985, 1989-90 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* To test, compile with -Dtest.  This Dtestable feature turns this into    a self-contained program which reads a pattern, describes how it    compiles, then reads a string and searches for it.        On the other hand, if you compile with both -Dtest and -Dcanned you    can run some tests we've already thought of.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|emacs
end_ifdef

begin_comment
comment|/* The `emacs' switch turns on certain special matching commands   that make sense only in emacs. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not emacs */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|BSTRING
end_ifndef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy((d),(s),(n))
end_define

begin_define
define|#
directive|define
name|bcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|memcmp((s1),(s2),(n))
end_define

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|memset((s),0,(n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make alloca work the best possible way.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the syntax stuff, so we can do the \<, \>, etc.  */
end_comment

begin_comment
comment|/* This must be nonzero for the wordchar and notwordchar pattern    commands in re_match_2.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|Sword
end_ifndef

begin_define
define|#
directive|define
name|Sword
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SYNTAX
parameter_list|(
name|c
parameter_list|)
value|re_syntax_table[c]
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYNTAX_TABLE
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|re_syntax_table
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not SYNTAX_TABLE */
end_comment

begin_decl_stmt
specifier|static
name|char
name|re_syntax_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_syntax_once
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return;
name|bzero
argument_list|(
name|re_syntax_table
argument_list|,
sizeof|sizeof
name|re_syntax_table
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'z'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'A'
init|;
name|c
operator|<=
literal|'Z'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
name|re_syntax_table
index|[
name|c
index|]
operator|=
name|Sword
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYNTAX_TABLE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* emacs */
end_comment

begin_comment
comment|/* We write fatal error messages on standard error.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* isalpha(3) etc. are used for the character classes.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Sequents are missing isgraph.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|isgraph
end_ifndef

begin_define
define|#
directive|define
name|isgraph
parameter_list|(
name|c
parameter_list|)
value|(isprint((c))&& !isspace((c)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get the interface, including the syntax bits.  */
end_comment

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_comment
comment|/* These are the command codes that appear in compiled regular    expressions, one per byte.  Some command codes are followed by    argument bytes.  A command code can specify any interpretation    whatsoever for its arguments.  Zero-bytes may appear in the compiled    regular expression.        The value of `exactn' is needed in search.c (search_buffer) in emacs.    So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of    `exactn' we use here must also be 1.  */
end_comment

begin_enum
enum|enum
name|regexpcode
block|{
name|unused
init|=
literal|0
block|,
name|exactn
init|=
literal|1
block|,
comment|/* Followed by one byte giving n, then by n literal bytes.  */
name|begline
block|,
comment|/* Fail unless at beginning of line.  */
name|endline
block|,
comment|/* Fail unless at end of line.  */
name|jump
block|,
comment|/* Followed by two bytes giving relative address to jump to.  */
name|on_failure_jump
block|,
comment|/* Followed by two bytes giving relative address of  			    place to resume at in case of failure.  */
name|finalize_jump
block|,
comment|/* Throw away latest failure point and then jump to  			    address.  */
name|maybe_finalize_jump
block|,
comment|/* Like jump but finalize if safe to do so. 			    This is used to jump back to the beginning 			    of a repeat.  If the command that follows 			    this jump is clearly incompatible with the 			    one at the beginning of the repeat, such that 			    we can be sure that there is no use backtracking 			    out of repetitions already completed, 			    then we finalize.  */
name|dummy_failure_jump
block|,
comment|/* Jump, and push a dummy failure point. This  			    failure point will be thrown away if an attempt                              is made to use it for a failure. A + construct                              makes this before the first repeat.  Also                             use it as an intermediary kind of jump when                             compiling an or construct.  */
name|succeed_n
block|,
comment|/* Used like on_failure_jump except has to succeed n times; 		    then gets turned into an on_failure_jump. The relative                     address following it is useless until then.  The                     address is followed by two bytes containing n.  */
name|jump_n
block|,
comment|/* Similar to jump, but jump n times only; also the relative 		    address following is in turn followed by yet two more bytes                     containing n.  */
name|set_number_at
block|,
comment|/* Set the following relative location to the 			   subsequent number.  */
name|anychar
block|,
comment|/* Matches any (more or less) one character.  */
name|charset
block|,
comment|/* Matches any one char belonging to specified set. 		    First following byte is number of bitmap bytes. 		    Then come bytes for a bitmap saying which chars are in. 		    Bits in each byte are ordered low-bit-first. 		    A character is in the set if its bit is 1. 		    A character too large to have a bit in the map 		    is automatically not in the set.  */
name|charset_not
block|,
comment|/* Same parameters as charset, but match any character                     that is not one of those specified.  */
name|start_memory
block|,
comment|/* Start remembering the text that is matched, for 		    storing in a memory register.  Followed by one                     byte containing the register number.  Register numbers                     must be in the range 0 through RE_NREGS.  */
name|stop_memory
block|,
comment|/* Stop remembering the text that is matched 		    and store it in a memory register.  Followed by                     one byte containing the register number. Register                     numbers must be in the range 0 through RE_NREGS.  */
name|duplicate
block|,
comment|/* Match a duplicate of something remembered. 		    Followed by one byte containing the index of the memory                      register.  */
name|before_dot
block|,
comment|/* Succeeds if before point.  */
name|at_dot
block|,
comment|/* Succeeds if at point.  */
name|after_dot
block|,
comment|/* Succeeds if after point.  */
name|begbuf
block|,
comment|/* Succeeds if at beginning of buffer.  */
name|endbuf
block|,
comment|/* Succeeds if at end of buffer.  */
name|wordchar
block|,
comment|/* Matches any word-constituent character.  */
name|notwordchar
block|,
comment|/* Matches any char that is not a word-constituent.  */
name|wordbeg
block|,
comment|/* Succeeds if at word beginning.  */
name|wordend
block|,
comment|/* Succeeds if at word end.  */
name|wordbound
block|,
comment|/* Succeeds if at a word boundary.  */
name|notwordbound
block|,
comment|/* Succeeds if not at a word boundary.  */
name|syntaxspec
block|,
comment|/* Matches any character whose syntax is specified. 		    followed by a byte which contains a syntax code,                     e.g., Sword.  */
name|notsyntaxspec
comment|/* Matches any character whose syntax differs from                      that specified.  */
block|}
enum|;
end_enum

begin_comment
comment|/* Number of failure points to allocate space for initially,    when matching.  If this number is exceeded, more space is allocated,    so it is not a hard limit.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NFAILURES
end_ifndef

begin_define
define|#
directive|define
name|NFAILURES
value|80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CHAR_UNSIGNED
end_ifdef

begin_define
define|#
directive|define
name|SIGN_EXTEND_CHAR
parameter_list|(
name|c
parameter_list|)
value|((c)>(char)127?(c)-256:(c))
end_define

begin_comment
comment|/* for IBM RT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIGN_EXTEND_CHAR
end_ifndef

begin_define
define|#
directive|define
name|SIGN_EXTEND_CHAR
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
end_comment

begin_define
define|#
directive|define
name|STORE_NUMBER
parameter_list|(
name|destination
parameter_list|,
name|number
parameter_list|)
define|\
value|{ (destination)[0] = (number)& 0377;					\     (destination)[1] = (number)>> 8; }
end_define

begin_comment
comment|/* Same as STORE_NUMBER, except increment the destination pointer to    the byte after where the number is stored.  Watch out that values for    DESTINATION such as p + 1 won't work, whereas p will.  */
end_comment

begin_define
define|#
directive|define
name|STORE_NUMBER_AND_INCR
parameter_list|(
name|destination
parameter_list|,
name|number
parameter_list|)
define|\
value|{ STORE_NUMBER(destination, number);					\     (destination) += 2; }
end_define

begin_comment
comment|/* Put into DESTINATION a number stored in two contingous bytes starting    at SOURCE.  */
end_comment

begin_define
define|#
directive|define
name|EXTRACT_NUMBER
parameter_list|(
name|destination
parameter_list|,
name|source
parameter_list|)
define|\
value|{ (destination) = *(source)& 0377;					\     (destination) += SIGN_EXTEND_CHAR (*(char *)((source) + 1))<< 8; }
end_define

begin_comment
comment|/* Same as EXTRACT_NUMBER, except increment the pointer for source to    point to second byte of SOURCE.  Note that SOURCE has to be a value    such as p, not, e.g., p + 1. */
end_comment

begin_define
define|#
directive|define
name|EXTRACT_NUMBER_AND_INCR
parameter_list|(
name|destination
parameter_list|,
name|source
parameter_list|)
define|\
value|{ EXTRACT_NUMBER (destination, source);				\     (source) += 2; }
end_define

begin_comment
comment|/* Specify the precise syntax of regexps for compilation.  This provides    for compatibility for various utilities which historically have    different, incompatible syntaxes.        The argument SYNTAX is a bit-mask comprised of the various bits    defined in regex.h.  */
end_comment

begin_function
name|int
name|re_set_syntax
parameter_list|(
name|syntax
parameter_list|)
name|int
name|syntax
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|obscure_syntax
expr_stmt|;
name|obscure_syntax
operator|=
name|syntax
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Set by re_set_syntax to the current regexp syntax to recognize.  */
end_comment

begin_decl_stmt
name|int
name|obscure_syntax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Macros for re_compile_pattern, which is found below these definitions.  */
end_comment

begin_define
define|#
directive|define
name|CHAR_CLASS_MAX_LENGTH
value|6
end_define

begin_comment
comment|/* Fetch the next character in the uncompiled pattern, translating it if    necessary.  */
end_comment

begin_define
define|#
directive|define
name|PATFETCH
parameter_list|(
name|c
parameter_list|)
define|\
value|{if (p == pend) goto end_of_pattern;					\   c = * (unsigned char *) p++;						\   if (translate) c = translate[c]; }
end_define

begin_comment
comment|/* Fetch the next character in the uncompiled pattern, with no    translation.  */
end_comment

begin_define
define|#
directive|define
name|PATFETCH_RAW
parameter_list|(
name|c
parameter_list|)
define|\
value|{if (p == pend) goto end_of_pattern;					\   c = * (unsigned char *) p++; }
end_define

begin_define
define|#
directive|define
name|PATUNFETCH
value|p--
end_define

begin_comment
comment|/* If the buffer isn't allocated when it comes in, use this.  */
end_comment

begin_define
define|#
directive|define
name|INIT_BUF_SIZE
value|28
end_define

begin_comment
comment|/* Make sure we have at least N more bytes of space in buffer.  */
end_comment

begin_define
define|#
directive|define
name|GET_BUFFER_SPACE
parameter_list|(
name|n
parameter_list|)
define|\
value|{								        \     while (b - bufp->buffer + (n)>= bufp->allocated)			\       EXTEND_BUFFER;							\   }
end_define

begin_comment
comment|/* Make sure we have one more byte of buffer space and then add CH to it.  */
end_comment

begin_define
define|#
directive|define
name|BUFPUSH
parameter_list|(
name|ch
parameter_list|)
define|\
value|{									\     GET_BUFFER_SPACE (1);						\     *b++ = (char) (ch);							\   }
end_define

begin_comment
comment|/* Extend the buffer by twice its current size via reallociation and    reset the pointers that pointed into the old allocation to point to    the correct places in the new allocation.  If extending the buffer    results in it being larger than 1<< 16, then flag memory exhausted.  */
end_comment

begin_define
define|#
directive|define
name|EXTEND_BUFFER
define|\
value|{ char *old_buffer = bufp->buffer;					\     if (bufp->allocated == (1L<<16)) goto too_big;			\     bufp->allocated *= 2;						\     if (bufp->allocated> (1L<<16)) bufp->allocated = (1L<<16);		\     bufp->buffer = (char *) realloc (bufp->buffer, bufp->allocated);	\     if (bufp->buffer == 0)						\       goto memory_exhausted;						\     b = (b - old_buffer) + bufp->buffer;				\     if (fixup_jump)							\       fixup_jump = (fixup_jump - old_buffer) + bufp->buffer;		\     if (laststart)							\       laststart = (laststart - old_buffer) + bufp->buffer;		\     begalt = (begalt - old_buffer) + bufp->buffer;			\     if (pending_exact)							\       pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\   }
end_define

begin_comment
comment|/* Set the bit for character C in a character set list.  */
end_comment

begin_define
define|#
directive|define
name|SET_LIST_BIT
parameter_list|(
name|c
parameter_list|)
value|(b[(c) / BYTEWIDTH] |= 1<< ((c) % BYTEWIDTH))
end_define

begin_comment
comment|/* Get the next unsigned number in the uncompiled pattern.  */
end_comment

begin_define
define|#
directive|define
name|GET_UNSIGNED_NUMBER
parameter_list|(
name|num
parameter_list|)
define|\
value|{ if (p != pend) 							\       { 								\         PATFETCH (c); 							\ 	while (isdigit (c)) 						\ 	  { 								\ 	    if (num< 0) 						\ 	       num = 0; 						\             num = num * 10 + c - '0'; 					\ 	    if (p == pend) 						\ 	       break; 							\ 	    PATFETCH (c); 						\ 	  } 								\         } 								\   }
end_define

begin_comment
comment|/* Subroutines for re_compile_pattern.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|store_jump
argument_list|()
decl_stmt|,
name|insert_jump
argument_list|()
decl_stmt|,
name|store_jump_n
argument_list|()
decl_stmt|,
name|insert_jump_n
argument_list|()
decl_stmt|,
name|insert_op_2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* re_compile_pattern takes a regular-expression string    and converts it into a buffer full of byte commands for matching.     PATTERN   is the address of the pattern string    SIZE      is the length of it.    BUFP	    is a  struct re_pattern_buffer *  which points to the info 	     on where to store the byte commands. 	     This structure contains a  char *  which points to the 	     actual space, which should have been obtained with malloc. 	     re_compile_pattern may use realloc to grow the buffer space.     The number of bytes of commands can be found out by looking in    the `struct re_pattern_buffer' that bufp pointed to, after    re_compile_pattern returns. */
end_comment

begin_function
name|char
modifier|*
name|re_compile_pattern
parameter_list|(
name|pattern
parameter_list|,
name|size
parameter_list|,
name|bufp
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|b
init|=
name|bufp
operator|->
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
name|char
modifier|*
name|pend
init|=
name|pattern
operator|+
name|size
decl_stmt|;
specifier|register
name|unsigned
name|c
decl_stmt|,
name|c1
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bufp
operator|->
name|translate
decl_stmt|;
comment|/* Address of the count-byte of the most recently inserted `exactn'      command.  This makes it possible to tell whether a new exact-match      character can be added to that command or requires a new `exactn'      command.  */
name|char
modifier|*
name|pending_exact
init|=
literal|0
decl_stmt|;
comment|/* Address of the place where a forward-jump should go to the end of      the containing expression.  Each alternative of an `or', except the      last, ends with a forward-jump of this sort.  */
name|char
modifier|*
name|fixup_jump
init|=
literal|0
decl_stmt|;
comment|/* Address of start of the most recently finished expression.      This tells postfix * where to find the start of its operand.  */
name|char
modifier|*
name|laststart
init|=
literal|0
decl_stmt|;
comment|/* In processing a repeat, 1 means zero matches is allowed.  */
name|char
name|zero_times_ok
decl_stmt|;
comment|/* In processing a repeat, 1 means many matches is allowed.  */
name|char
name|many_times_ok
decl_stmt|;
comment|/* Address of beginning of regexp, or inside of last \(.  */
name|char
modifier|*
name|begalt
init|=
name|b
decl_stmt|;
comment|/* In processing an interval, at least this many matches must be made.  */
name|int
name|lower_bound
decl_stmt|;
comment|/* In processing an interval, at most this many matches can be made.  */
name|int
name|upper_bound
decl_stmt|;
comment|/* Place in pattern (i.e., the {) to which to go back if the interval      is invalid.  */
name|char
modifier|*
name|beg_interval
init|=
literal|0
decl_stmt|;
comment|/* Stack of information saved by \( and restored by \).      Four stack elements are pushed by each \(:        First, the value of b.        Second, the value of fixup_jump.        Third, the value of regnum.        Fourth, the value of begalt.  */
name|int
name|stackb
index|[
literal|40
index|]
decl_stmt|;
name|int
modifier|*
name|stackp
init|=
name|stackb
decl_stmt|;
name|int
modifier|*
name|stacke
init|=
name|stackb
operator|+
literal|40
decl_stmt|;
name|int
modifier|*
name|stackt
decl_stmt|;
comment|/* Counts \('s as they are encountered.  Remembered for the matching \),      where it becomes the register number to put in the stop_memory      command.  */
name|int
name|regnum
init|=
literal|1
decl_stmt|;
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|emacs
ifndef|#
directive|ifndef
name|SYNTAX_TABLE
comment|/* Initialize the syntax table.  */
name|init_syntax_once
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|bufp
operator|->
name|allocated
operator|==
literal|0
condition|)
block|{
name|bufp
operator|->
name|allocated
operator|=
name|INIT_BUF_SIZE
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|buffer
condition|)
comment|/* EXTEND_BUFFER loses when bufp->allocated is 0.  */
name|bufp
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|bufp
operator|->
name|buffer
argument_list|,
name|INIT_BUF_SIZE
argument_list|)
expr_stmt|;
else|else
comment|/* Caller did not allocate a buffer.  Do it for them.  */
name|bufp
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|INIT_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
operator|->
name|buffer
condition|)
goto|goto
name|memory_exhausted
goto|;
name|begalt
operator|=
name|b
operator|=
name|bufp
operator|->
name|buffer
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|!=
name|pend
condition|)
block|{
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
block|{
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
comment|/* When testing what follows the $, 	       look past the \-constructs that don't consume anything.  */
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
while|while
condition|(
name|p1
operator|!=
name|pend
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\\'
operator|&&
name|p1
operator|+
literal|1
operator|!=
name|pend
operator|&&
operator|(
name|p1
index|[
literal|1
index|]
operator|==
literal|'<'
operator|||
name|p1
index|[
literal|1
index|]
operator|==
literal|'>'
operator|||
name|p1
index|[
literal|1
index|]
operator|==
literal|'`'
operator|||
name|p1
index|[
literal|1
index|]
operator|==
literal|'\''
ifdef|#
directive|ifdef
name|emacs
operator|||
name|p1
index|[
literal|1
index|]
operator|==
literal|'='
endif|#
directive|endif
operator|||
name|p1
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|p1
index|[
literal|1
index|]
operator|==
literal|'B'
operator|)
condition|)
name|p1
operator|+=
literal|2
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_TIGHT_VBAR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|p1
operator|!=
name|pend
condition|)
goto|goto
name|normal_char
goto|;
comment|/* Make operand of last vbar end before this `$'.  */
if|if
condition|(
name|fixup_jump
condition|)
name|store_jump
argument_list|(
name|fixup_jump
argument_list|,
name|jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|fixup_jump
operator|=
literal|0
expr_stmt|;
name|BUFPUSH
argument_list|(
name|endline
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* $ means succeed if at end of line, but only in special contexts. 	      If validly in the middle of a pattern, it is a normal character. */
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXTUAL_INVALID_OPS
operator|)
operator|&&
name|p1
operator|!=
name|pend
condition|)
goto|goto
name|invalid_pattern
goto|;
if|if
condition|(
name|p1
operator|==
name|pend
operator|||
operator|*
name|p1
operator|==
literal|'\n'
operator|||
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|||
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
condition|?
operator|*
name|p1
operator|==
literal|')'
else|:
operator|*
name|p1
operator|==
literal|'\\'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|')'
operator|)
operator|||
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_VBAR
condition|?
operator|*
name|p1
operator|==
literal|'|'
else|:
operator|*
name|p1
operator|==
literal|'\\'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'|'
operator|)
condition|)
block|{
name|BUFPUSH
argument_list|(
name|endline
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|normal_char
goto|;
block|}
case|case
literal|'^'
case|:
comment|/* ^ means succeed if at beg of line, but only if no preceding               pattern.  */
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXTUAL_INVALID_OPS
operator|)
operator|&&
name|laststart
condition|)
goto|goto
name|invalid_pattern
goto|;
if|if
condition|(
name|laststart
operator|&&
name|p
operator|-
literal|2
operator|>=
name|pattern
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'\n'
operator|&&
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_TIGHT_VBAR
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|pattern
operator|+
literal|1
operator|&&
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|BUFPUSH
argument_list|(
name|begline
argument_list|)
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
block|}
else|else
name|BUFPUSH
argument_list|(
name|begline
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|||
operator|(
name|obscure_syntax
operator|&
name|RE_LIMITED_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|handle_plus
label|:
case|case
literal|'*'
case|:
comment|/* If there is no previous pattern, char not special. */
if|if
condition|(
operator|!
name|laststart
condition|)
block|{
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_CONTEXTUAL_INVALID_OPS
condition|)
goto|goto
name|invalid_pattern
goto|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
block|}
comment|/* If there is a sequence of repetition chars, 	     collapse it down to just one.  */
name|zero_times_ok
operator|=
literal|0
expr_stmt|;
name|many_times_ok
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|zero_times_ok
operator||=
name|c
operator|!=
literal|'+'
expr_stmt|;
name|many_times_ok
operator||=
name|c
operator|!=
literal|'?'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|c1
decl_stmt|;
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|==
literal|'+'
operator|||
name|c1
operator|==
literal|'?'
operator|)
condition|)
block|{
name|PATUNFETCH
expr_stmt|;
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|c1
expr_stmt|;
block|}
else|else
block|{
name|PATUNFETCH
expr_stmt|;
break|break;
block|}
block|}
comment|/* Star, etc. applied to an empty pattern is equivalent 	     to an empty pattern.  */
if|if
condition|(
operator|!
name|laststart
condition|)
break|break;
comment|/* Now we know whether or not zero matches is allowed 	     and also whether or not two or more matches is allowed.  */
if|if
condition|(
name|many_times_ok
condition|)
block|{
comment|/* If more than one repetition is allowed, put in at the                  end a backward relative jump from b to before the next                  jump we're going to put in below (which jumps from                  laststart to after this jump).  */
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|store_jump
argument_list|(
name|b
argument_list|,
name|maybe_finalize_jump
argument_list|,
name|laststart
operator|-
literal|3
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
comment|/* Because store_jump put stuff here.  */
block|}
comment|/* On failure, jump from laststart to b + 3, which will be the              end of the buffer after this jump is inserted.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|insert_jump
argument_list|(
name|on_failure_jump
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|3
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|zero_times_ok
condition|)
block|{
comment|/* At least one repetition is required, so insert a                  dummy-failure before the initial on-failure-jump                  instruction of the loop. This effects a skip over that                  instruction the first time we hit that loop.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|insert_jump
argument_list|(
name|dummy_failure_jump
argument_list|,
name|laststart
argument_list|,
name|laststart
operator|+
literal|6
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|BUFPUSH
argument_list|(
name|anychar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
if|if
condition|(
name|p
operator|==
name|pend
condition|)
goto|goto
name|invalid_pattern
goto|;
while|while
condition|(
name|b
operator|-
name|bufp
operator|->
name|buffer
operator|>
name|bufp
operator|->
name|allocated
operator|-
literal|3
operator|-
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
condition|)
name|EXTEND_BUFFER
expr_stmt|;
name|laststart
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
block|{
name|BUFPUSH
argument_list|(
name|charset_not
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|BUFPUSH
argument_list|(
name|charset
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
name|BUFPUSH
argument_list|(
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
argument_list|)
expr_stmt|;
comment|/* Clear the whole map */
name|bzero
argument_list|(
name|b
argument_list|,
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
operator|/
name|BYTEWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_HAT_NOT_NEWLINE
operator|)
operator|&&
name|b
index|[
operator|-
literal|2
index|]
operator|==
name|charset_not
condition|)
name|SET_LIST_BIT
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Read in characters and ranges, setting map bits.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Don't translate while fetching, in case it's a range bound. 		 When we set the bit for the character, we translate it.  */
name|PATFETCH_RAW
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* If set, \ escapes characters when inside [...].  */
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_AWK_CLASS_HACK
operator|)
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
name|c1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|p1
operator|+
literal|1
condition|)
block|{
comment|/* If this is an empty bracket expression.  */
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_NO_EMPTY_BRACKETS
operator|)
operator|&&
name|p
operator|==
name|pend
condition|)
goto|goto
name|invalid_pattern
goto|;
block|}
else|else
comment|/* Stop if this isn't merely a ] inside a bracket                        expression, but rather the end of a bracket                        expression.  */
break|break;
block|}
comment|/* Get a range.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
name|PATFETCH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
comment|/* Don't translate the range bounds while fetching them.  */
name|PATFETCH_RAW
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_NO_EMPTY_RANGES
operator|)
operator|&&
name|c
operator|>
name|c1
condition|)
goto|goto
name|invalid_pattern
goto|;
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_NO_HYPHEN_RANGE_END
operator|)
operator|&&
name|c1
operator|==
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
goto|goto
name|invalid_pattern
goto|;
while|while
condition|(
name|c
operator|<=
name|c1
condition|)
block|{
comment|/* Translate each char that's in the range.  */
if|if
condition|(
name|translate
condition|)
name|SET_LIST_BIT
argument_list|(
name|translate
index|[
name|c
index|]
argument_list|)
expr_stmt|;
else|else
name|SET_LIST_BIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_CHAR_CLASSES
operator|)
operator|&&
name|c
operator|==
literal|'['
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Longest valid character class word has six characters.  */
name|char
name|str
index|[
name|CHAR_CLASS_MAX_LENGTH
index|]
decl_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
comment|/* If no ] at end.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
goto|goto
name|invalid_pattern
goto|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Don't translate the ``character class'' characters.  */
name|PATFETCH_RAW
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|']'
operator|||
name|p
operator|==
name|pend
operator|||
name|c1
operator|==
name|CHAR_CLASS_MAX_LENGTH
condition|)
break|break;
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
operator|||
name|c
operator|==
literal|']'
comment|/* End of the bracket expression.  */
operator|||
name|p
index|[
literal|0
index|]
operator|!=
literal|']'
operator|||
name|p
operator|+
literal|1
operator|==
name|pend
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"alpha"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"upper"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"lower"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"digit"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"alnum"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"xdigit"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"space"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"print"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"punct"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"graph"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"cntrl"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Undo the ending character, the letters, and leave                            the leading : and [ (but set bits for them).  */
name|c1
operator|++
expr_stmt|;
while|while
condition|(
name|c1
operator|--
condition|)
name|PATUNFETCH
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|SET_LIST_BIT
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The ] at the end of the character class.  */
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|']'
condition|)
goto|goto
name|invalid_pattern
goto|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"alpha"
argument_list|)
operator|==
literal|0
operator|&&
name|isalpha
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"upper"
argument_list|)
operator|==
literal|0
operator|&&
name|isupper
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"lower"
argument_list|)
operator|==
literal|0
operator|&&
name|islower
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"digit"
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"alnum"
argument_list|)
operator|==
literal|0
operator|&&
name|isalnum
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"xdigit"
argument_list|)
operator|==
literal|0
operator|&&
name|isxdigit
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"space"
argument_list|)
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"print"
argument_list|)
operator|==
literal|0
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"punct"
argument_list|)
operator|==
literal|0
operator|&&
name|ispunct
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"graph"
argument_list|)
operator|==
literal|0
operator|&&
name|isgraph
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"cntrl"
argument_list|)
operator|==
literal|0
operator|&&
name|iscntrl
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|SET_LIST_BIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|translate
condition|)
name|SET_LIST_BIT
argument_list|(
name|translate
index|[
name|c
index|]
argument_list|)
expr_stmt|;
else|else
name|SET_LIST_BIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Discard any character set/class bitmap bytes that are all              0 at the end of the map. Decrement the map-length byte too.  */
while|while
condition|(
operator|(
name|int
operator|)
name|b
index|[
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|b
index|[
name|b
index|[
operator|-
literal|1
index|]
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|b
index|[
operator|-
literal|1
index|]
operator|--
expr_stmt|;
name|b
operator|+=
name|b
index|[
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_open
goto|;
case|case
literal|')'
case|:
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_close
goto|;
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NEWLINE_OR
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_bar
goto|;
case|case
literal|'|'
case|:
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_CONTEXTUAL_INVALID_OPS
operator|)
operator|&&
operator|(
operator|!
name|laststart
operator|||
name|p
operator|==
name|pend
operator|)
condition|)
goto|goto
name|invalid_pattern
goto|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_bar
goto|;
case|case
literal|'{'
case|:
if|if
condition|(
operator|!
operator|(
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_CURLY_BRACES
operator|)
operator|&&
operator|(
name|obscure_syntax
operator|&
name|RE_INTERVALS
operator|)
operator|)
condition|)
goto|goto
name|normal_char
goto|;
else|else
goto|goto
name|handle_interval
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|==
name|pend
condition|)
goto|goto
name|invalid_pattern
goto|;
name|PATFETCH_RAW
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backsl
goto|;
name|handle_open
label|:
if|if
condition|(
name|stackp
operator|==
name|stacke
condition|)
goto|goto
name|nesting_too_deep
goto|;
comment|/* Laststart should point to the start_memory that we are about                  to push (unless the pattern has RE_NREGS or more ('s).  */
operator|*
name|stackp
operator|++
operator|=
name|b
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|regnum
operator|<
name|RE_NREGS
condition|)
block|{
name|BUFPUSH
argument_list|(
name|start_memory
argument_list|)
expr_stmt|;
name|BUFPUSH
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
operator|*
name|stackp
operator|++
operator|=
name|fixup_jump
condition|?
name|fixup_jump
operator|-
name|bufp
operator|->
name|buffer
operator|+
literal|1
else|:
literal|0
expr_stmt|;
operator|*
name|stackp
operator|++
operator|=
name|regnum
operator|++
expr_stmt|;
operator|*
name|stackp
operator|++
operator|=
name|begalt
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
name|fixup_jump
operator|=
literal|0
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_BK_PARENS
condition|)
goto|goto
name|normal_backsl
goto|;
name|handle_close
label|:
if|if
condition|(
name|stackp
operator|==
name|stackb
condition|)
goto|goto
name|unmatched_close
goto|;
name|begalt
operator|=
operator|*
operator|--
name|stackp
operator|+
name|bufp
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|fixup_jump
condition|)
name|store_jump
argument_list|(
name|fixup_jump
argument_list|,
name|jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackp
index|[
operator|-
literal|1
index|]
operator|<
name|RE_NREGS
condition|)
block|{
name|BUFPUSH
argument_list|(
name|stop_memory
argument_list|)
expr_stmt|;
name|BUFPUSH
argument_list|(
name|stackp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|stackp
operator|-=
literal|2
expr_stmt|;
name|fixup_jump
operator|=
operator|*
name|stackp
condition|?
operator|*
name|stackp
operator|+
name|bufp
operator|->
name|buffer
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|laststart
operator|=
operator|*
operator|--
name|stackp
operator|+
name|bufp
operator|->
name|buffer
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
operator|(
name|obscure_syntax
operator|&
name|RE_LIMITED_OPS
operator|)
operator|||
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|)
goto|goto
name|normal_backsl
goto|;
name|handle_bar
label|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
comment|/* Insert before the previous alternative a jump which                  jumps to this alternative if the former fails.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|insert_jump
argument_list|(
name|on_failure_jump
argument_list|,
name|begalt
argument_list|,
name|b
operator|+
literal|6
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
comment|/* The alternative before the previous alternative has a                  jump after it which gets executed if it gets matched.                  Adjust that jump so it will jump to the previous                  alternative's analogous jump (put in below, which in                  turn will jump to the next (if any) alternative's such                  jump, etc.).  The last such jump jumps to the correct                  final destination.  */
if|if
condition|(
name|fixup_jump
condition|)
name|store_jump
argument_list|(
name|fixup_jump
argument_list|,
name|jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Leave space for a jump after previous alternative---to be                   filled in later.  */
name|fixup_jump
operator|=
name|b
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
name|begalt
operator|=
name|b
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_INTERVALS
operator|)
comment|/* Let \{ be a literal.  */
operator|||
operator|(
operator|(
name|obscure_syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_CURLY_BRACES
operator|)
operator|)
comment|/* If it's the string "\{".  */
operator|||
operator|(
name|p
operator|-
literal|2
operator|==
name|pattern
operator|&&
name|p
operator|==
name|pend
operator|)
condition|)
goto|goto
name|normal_backsl
goto|;
name|handle_interval
label|:
name|beg_interval
operator|=
name|p
operator|-
literal|1
expr_stmt|;
comment|/* The {.  */
comment|/* If there is no previous pattern, this isn't an interval.  */
if|if
condition|(
operator|!
name|laststart
condition|)
block|{
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_CONTEXTUAL_INVALID_OPS
condition|)
goto|goto
name|invalid_pattern
goto|;
else|else
goto|goto
name|normal_backsl
goto|;
block|}
comment|/* It also isn't an interval if not preceded by an re                  matching a single character or subexpression, or if                  the current type of intervals can't handle back                  references and the previous thing is a back reference.  */
if|if
condition|(
operator|!
operator|(
operator|*
name|laststart
operator|==
name|anychar
operator|||
operator|*
name|laststart
operator|==
name|charset
operator|||
operator|*
name|laststart
operator|==
name|charset_not
operator|||
operator|*
name|laststart
operator|==
name|start_memory
operator|||
operator|(
operator|*
name|laststart
operator|==
name|exactn
operator|&&
name|laststart
index|[
literal|1
index|]
operator|==
literal|1
operator|)
operator|||
operator|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_REFS
operator|)
operator|&&
operator|*
name|laststart
operator|==
name|duplicate
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_BK_CURLY_BRACES
condition|)
goto|goto
name|normal_char
goto|;
comment|/* Posix extended syntax is handled in previous                      statement; this is for Posix basic syntax.  */
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_INTERVALS
condition|)
goto|goto
name|invalid_pattern
goto|;
goto|goto
name|normal_backsl
goto|;
block|}
name|lower_bound
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* So can see if are set.  */
name|upper_bound
operator|=
operator|-
literal|1
expr_stmt|;
name|GET_UNSIGNED_NUMBER
argument_list|(
name|lower_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|GET_UNSIGNED_NUMBER
argument_list|(
name|upper_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper_bound
operator|<
literal|0
condition|)
name|upper_bound
operator|=
name|RE_DUP_MAX
expr_stmt|;
block|}
if|if
condition|(
name|upper_bound
operator|<
literal|0
condition|)
name|upper_bound
operator|=
name|lower_bound
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_CURLY_BRACES
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
goto|goto
name|invalid_pattern
goto|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'}'
operator|||
name|lower_bound
operator|<
literal|0
operator|||
name|upper_bound
operator|>
name|RE_DUP_MAX
operator|||
name|lower_bound
operator|>
name|upper_bound
operator|||
operator|(
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_CURLY_BRACES
operator|)
operator|&&
name|p
operator|!=
name|pend
operator|&&
operator|*
name|p
operator|==
literal|'{'
operator|)
condition|)
block|{
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_BK_CURLY_BRACES
condition|)
goto|goto
name|unfetch_interval
goto|;
else|else
goto|goto
name|invalid_pattern
goto|;
block|}
comment|/* If upper_bound is zero, don't want to succeed at all;   		 jump from laststart to b + 3, which will be the end of                  the buffer after this jump is inserted.  */
if|if
condition|(
name|upper_bound
operator|==
literal|0
condition|)
block|{
name|GET_BUFFER_SPACE
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|insert_jump
argument_list|(
name|jump
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
literal|3
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* Otherwise, after lower_bound number of succeeds, jump                   to after the jump_n which will be inserted at the end                   of the buffer, and insert that jump_n.  */
else|else
block|{
comment|/* Set to 5 if only one repetition is allowed and 	              hence no jump_n is inserted at the current end of                       the buffer; then only space for the succeed_n is                       needed.  Otherwise, need space for both the                       succeed_n and the jump_n.  */
name|unsigned
name|slots_needed
init|=
name|upper_bound
operator|==
literal|1
condition|?
literal|5
else|:
literal|10
decl_stmt|;
name|GET_BUFFER_SPACE
argument_list|(
name|slots_needed
argument_list|)
expr_stmt|;
comment|/* Initialize the succeed_n to n, even though it will                       be set by its attendant set_number_at, because                       re_compile_fastmap will need to know it.  Jump to                       what the end of buffer will be after inserting                       this succeed_n and possibly appending a jump_n.  */
name|insert_jump_n
argument_list|(
name|succeed_n
argument_list|,
name|laststart
argument_list|,
name|b
operator|+
name|slots_needed
argument_list|,
name|b
argument_list|,
name|lower_bound
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|5
expr_stmt|;
comment|/* Just increment for the succeed_n here.  */
comment|/* More than one repetition is allowed, so put in at 		     the end of the buffer a backward jump from b to the                      succeed_n we put in above.  By the time we've gotten                      to this jump when matching, we'll have matched once                      already, so jump back only upper_bound - 1 times.  */
if|if
condition|(
name|upper_bound
operator|>
literal|1
condition|)
block|{
name|store_jump_n
argument_list|(
name|b
argument_list|,
name|jump_n
argument_list|,
name|laststart
argument_list|,
name|upper_bound
operator|-
literal|1
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|5
expr_stmt|;
comment|/* When hit this when matching, reset the                           preceding jump_n's n to upper_bound - 1.  */
name|BUFPUSH
argument_list|(
name|set_number_at
argument_list|)
expr_stmt|;
name|GET_BUFFER_SPACE
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|STORE_NUMBER_AND_INCR
argument_list|(
name|b
argument_list|,
operator|-
literal|5
argument_list|)
expr_stmt|;
name|STORE_NUMBER_AND_INCR
argument_list|(
name|b
argument_list|,
name|upper_bound
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* When hit this when matching, set the succeed_n's n.  */
name|GET_BUFFER_SPACE
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|insert_op_2
argument_list|(
name|set_number_at
argument_list|,
name|laststart
argument_list|,
name|b
argument_list|,
literal|5
argument_list|,
name|lower_bound
argument_list|)
expr_stmt|;
name|b
operator|+=
literal|5
expr_stmt|;
block|}
name|pending_exact
operator|=
literal|0
expr_stmt|;
name|beg_interval
operator|=
literal|0
expr_stmt|;
break|break;
name|unfetch_interval
label|:
comment|/* If an invalid interval, match the characters as literals.  */
if|if
condition|(
name|beg_interval
condition|)
name|p
operator|=
name|beg_interval
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regex: no interval beginning to which to backtrack.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|beg_interval
operator|=
literal|0
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* normal_char expects char in `c'.  */
goto|goto
name|normal_char
goto|;
break|break;
ifdef|#
directive|ifdef
name|emacs
case|case
literal|'='
case|:
name|BUFPUSH
argument_list|(
name|at_dot
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|BUFPUSH
argument_list|(
name|syntaxspec
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|BUFPUSH
argument_list|(
name|syntax_spec_code
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|BUFPUSH
argument_list|(
name|notsyntaxspec
argument_list|)
expr_stmt|;
name|PATFETCH
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|BUFPUSH
argument_list|(
name|syntax_spec_code
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* emacs */
case|case
literal|'w'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|BUFPUSH
argument_list|(
name|wordchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|laststart
operator|=
name|b
expr_stmt|;
name|BUFPUSH
argument_list|(
name|notwordchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|BUFPUSH
argument_list|(
name|wordbeg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|BUFPUSH
argument_list|(
name|wordend
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|BUFPUSH
argument_list|(
name|wordbound
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|BUFPUSH
argument_list|(
name|notwordbound
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
name|BUFPUSH
argument_list|(
name|begbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|BUFPUSH
argument_list|(
name|endbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_BK_REFS
condition|)
goto|goto
name|normal_char
goto|;
name|c1
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c1
operator|>=
name|regnum
condition|)
block|{
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_NO_EMPTY_BK_REF
condition|)
goto|goto
name|invalid_pattern
goto|;
else|else
goto|goto
name|normal_char
goto|;
block|}
comment|/* Can't back reference to a subexpression if inside of it.  */
for|for
control|(
name|stackt
operator|=
name|stackp
operator|-
literal|2
init|;
name|stackt
operator|>
name|stackb
condition|;
name|stackt
operator|-=
literal|4
control|)
if|if
condition|(
operator|*
name|stackt
operator|==
name|c1
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
name|b
expr_stmt|;
name|BUFPUSH
argument_list|(
name|duplicate
argument_list|)
expr_stmt|;
name|BUFPUSH
argument_list|(
name|c1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|handle_plus
goto|;
else|else
goto|goto
name|normal_backsl
goto|;
break|break;
default|default:
name|normal_backsl
label|:
comment|/* You might think it would be useful for \ to mean 		 not to translate; but if we don't translate it 		 it will never match anything.  */
if|if
condition|(
name|translate
condition|)
name|c
operator|=
name|translate
index|[
name|c
index|]
expr_stmt|;
goto|goto
name|normal_char
goto|;
block|}
break|break;
default|default:
name|normal_char
label|:
comment|/* Expects the character in `c'.  */
if|if
condition|(
operator|!
name|pending_exact
operator|||
name|pending_exact
operator|+
operator|*
name|pending_exact
operator|+
literal|1
operator|!=
name|b
operator|||
operator|*
name|pending_exact
operator|==
literal|0177
operator|||
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'^'
operator|||
operator|(
operator|(
name|obscure_syntax
operator|&
name|RE_BK_PLUS_QM
operator|)
condition|?
operator|*
name|p
operator|==
literal|'\\'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'?'
operator|)
else|:
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|)
operator|)
operator|||
operator|(
operator|(
name|obscure_syntax
operator|&
name|RE_INTERVALS
operator|)
operator|&&
operator|(
operator|(
name|obscure_syntax
operator|&
name|RE_NO_BK_CURLY_BRACES
operator|)
condition|?
operator|*
name|p
operator|==
literal|'{'
else|:
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'{'
operator|)
operator|)
operator|)
condition|)
block|{
name|laststart
operator|=
name|b
expr_stmt|;
name|BUFPUSH
argument_list|(
name|exactn
argument_list|)
expr_stmt|;
name|pending_exact
operator|=
name|b
expr_stmt|;
name|BUFPUSH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|BUFPUSH
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pending_exact
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixup_jump
condition|)
name|store_jump
argument_list|(
name|fixup_jump
argument_list|,
name|jump
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackp
operator|!=
name|stackb
condition|)
goto|goto
name|unmatched_open
goto|;
name|bufp
operator|->
name|used
operator|=
name|b
operator|-
name|bufp
operator|->
name|buffer
expr_stmt|;
return|return
literal|0
return|;
name|invalid_pattern
label|:
return|return
literal|"Invalid regular expression"
return|;
name|unmatched_open
label|:
return|return
literal|"Unmatched \\("
return|;
name|unmatched_close
label|:
return|return
literal|"Unmatched \\)"
return|;
name|end_of_pattern
label|:
return|return
literal|"Premature end of regular expression"
return|;
name|nesting_too_deep
label|:
return|return
literal|"Nesting too deep"
return|;
name|too_big
label|:
return|return
literal|"Regular expression too big"
return|;
name|memory_exhausted
label|:
return|return
literal|"Memory exhausted"
return|;
block|}
end_function

begin_comment
comment|/* Store a jump of the form<OPCODE><relative address>.    Store in the location FROM a jump operation to jump to relative    address FROM - TO.  OPCODE is the opcode to store.  */
end_comment

begin_function
specifier|static
name|void
name|store_jump
parameter_list|(
name|from
parameter_list|,
name|opcode
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|char
name|opcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|from
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|from
operator|+
literal|1
argument_list|,
name|to
operator|-
operator|(
name|from
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Open up space before char FROM, and insert there a jump to TO.    CURRENT_END gives the end of the storage not in use, so we know     how much data to copy up. OP is the opcode of the jump to insert.     If you call this function, you must zero out pending_exact.  */
end_comment

begin_function
specifier|static
name|void
name|insert_jump
parameter_list|(
name|op
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|current_end
parameter_list|)
name|char
name|op
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|,
modifier|*
name|current_end
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|pfrom
init|=
name|current_end
decl_stmt|;
comment|/* Copy from here...  */
specifier|register
name|char
modifier|*
name|pto
init|=
name|current_end
operator|+
literal|3
decl_stmt|;
comment|/* ...to here.  */
while|while
condition|(
name|pfrom
operator|!=
name|from
condition|)
operator|*
operator|--
name|pto
operator|=
operator|*
operator|--
name|pfrom
expr_stmt|;
name|store_jump
argument_list|(
name|from
argument_list|,
name|op
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Store a jump of the form<opcode><relative address><n> .     Store in the location FROM a jump operation to jump to relative    address FROM - TO.  OPCODE is the opcode to store, N is a number the    jump uses, say, to decide how many times to jump.        If you call this function, you must zero out pending_exact.  */
end_comment

begin_function
specifier|static
name|void
name|store_jump_n
parameter_list|(
name|from
parameter_list|,
name|opcode
parameter_list|,
name|to
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|char
name|opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|from
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|from
operator|+
literal|1
argument_list|,
name|to
operator|-
operator|(
name|from
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|from
operator|+
literal|3
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Similar to insert_jump, but handles a jump which needs an extra    number to handle minimum and maximum cases.  Open up space at    location FROM, and insert there a jump to TO.  CURRENT_END gives the    end of the storage in use, so we know how much data to copy up. OP is    the opcode of the jump to insert.     If you call this function, you must zero out pending_exact.  */
end_comment

begin_function
specifier|static
name|void
name|insert_jump_n
parameter_list|(
name|op
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|current_end
parameter_list|,
name|n
parameter_list|)
name|char
name|op
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|,
modifier|*
name|current_end
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|pfrom
init|=
name|current_end
decl_stmt|;
comment|/* Copy from here...  */
specifier|register
name|char
modifier|*
name|pto
init|=
name|current_end
operator|+
literal|5
decl_stmt|;
comment|/* ...to here.  */
while|while
condition|(
name|pfrom
operator|!=
name|from
condition|)
operator|*
operator|--
name|pto
operator|=
operator|*
operator|--
name|pfrom
expr_stmt|;
name|store_jump_n
argument_list|(
name|from
argument_list|,
name|op
argument_list|,
name|to
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Open up space at location THERE, and insert operation OP followed by    NUM_1 and NUM_2.  CURRENT_END gives the end of the storage in use, so    we know how much data to copy up.     If you call this function, you must zero out pending_exact.  */
end_comment

begin_function
specifier|static
name|void
name|insert_op_2
parameter_list|(
name|op
parameter_list|,
name|there
parameter_list|,
name|current_end
parameter_list|,
name|num_1
parameter_list|,
name|num_2
parameter_list|)
name|char
name|op
decl_stmt|;
name|char
modifier|*
name|there
decl_stmt|,
decl|*
name|current_end
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|num_1
decl_stmt|,
name|num_2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|pfrom
init|=
name|current_end
decl_stmt|;
comment|/* Copy from here...  */
specifier|register
name|char
modifier|*
name|pto
init|=
name|current_end
operator|+
literal|5
decl_stmt|;
comment|/* ...to here.  */
while|while
condition|(
name|pfrom
operator|!=
name|there
condition|)
operator|*
operator|--
name|pto
operator|=
operator|*
operator|--
name|pfrom
expr_stmt|;
name|there
index|[
literal|0
index|]
operator|=
name|op
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|there
operator|+
literal|1
argument_list|,
name|num_1
argument_list|)
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|there
operator|+
literal|3
argument_list|,
name|num_2
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Given a pattern, compute a fastmap from it.  The fastmap records    which of the (1<< BYTEWIDTH) possible characters can start a string    that matches the pattern.  This fastmap is used by re_search to skip    quickly over totally implausible text.     The caller must supply the address of a (1<< BYTEWIDTH)-byte data     area as bufp->fastmap.    The other components of bufp describe the pattern to be used.  */
end_comment

begin_function
name|void
name|re_compile_fastmap
parameter_list|(
name|bufp
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|pattern
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bufp
operator|->
name|buffer
decl_stmt|;
name|int
name|size
init|=
name|bufp
operator|->
name|used
decl_stmt|;
specifier|register
name|char
modifier|*
name|fastmap
init|=
name|bufp
operator|->
name|fastmap
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pend
init|=
name|pattern
operator|+
name|size
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bufp
operator|->
name|translate
decl_stmt|;
name|unsigned
name|char
modifier|*
name|stackb
index|[
name|NFAILURES
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|stackp
init|=
name|stackb
decl_stmt|;
name|unsigned
name|is_a_succeed_n
decl_stmt|;
name|bzero
argument_list|(
name|fastmap
argument_list|,
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
argument_list|)
expr_stmt|;
name|bufp
operator|->
name|fastmap_accurate
operator|=
literal|1
expr_stmt|;
name|bufp
operator|->
name|can_be_null
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|is_a_succeed_n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|++
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|++
condition|)
endif|#
directive|endif
block|{
case|case
name|exactn
case|:
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
name|p
index|[
literal|1
index|]
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
name|p
index|[
literal|1
index|]
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|begline
case|:
case|case
name|before_dot
case|:
case|case
name|at_dot
case|:
case|case
name|after_dot
case|:
case|case
name|begbuf
case|:
case|case
name|endbuf
case|:
case|case
name|wordbound
case|:
case|case
name|notwordbound
case|:
case|case
name|wordbeg
case|:
case|case
name|wordend
case|:
continue|continue;
case|case
name|endline
case|:
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
literal|'\n'
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|can_be_null
operator|!=
literal|1
condition|)
name|bufp
operator|->
name|can_be_null
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|jump_n
case|:
case|case
name|finalize_jump
case|:
case|case
name|maybe_finalize_jump
case|:
case|case
name|jump
case|:
case|case
name|dummy_failure_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
continue|continue;
comment|/* Jump backward reached implies we just went through 	     the body of a loop and matched nothing. 	     Opcode jumped to should be an on_failure_jump. 	     Just treat it like an ordinary jump. 	     For a * loop, it has pushed its failure point already; 	     If so, discard that as redundant.  */
if|if
condition|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|!=
name|on_failure_jump
operator|&&
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|!=
name|succeed_n
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|stackp
operator|!=
name|stackb
operator|&&
operator|*
name|stackp
operator|==
name|p
condition|)
name|stackp
operator|--
expr_stmt|;
continue|continue;
case|case
name|on_failure_jump
case|:
name|handle_on_failure_jump
label|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
operator|++
name|stackp
operator|=
name|p
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|is_a_succeed_n
condition|)
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|k
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the n.  */
continue|continue;
case|case
name|succeed_n
case|:
name|is_a_succeed_n
operator|=
literal|1
expr_stmt|;
comment|/* Get to the number of times to succeed.  */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Increment p past the n for when k != 0.  */
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|k
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
name|p
operator|-=
literal|4
expr_stmt|;
goto|goto
name|handle_on_failure_jump
goto|;
block|}
continue|continue;
case|case
name|set_number_at
case|:
name|p
operator|+=
literal|4
expr_stmt|;
continue|continue;
case|case
name|start_memory
case|:
case|case
name|stop_memory
case|:
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
name|duplicate
case|:
name|bufp
operator|->
name|can_be_null
operator|=
literal|1
expr_stmt|;
name|fastmap
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
case|case
name|anychar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|j
operator|!=
literal|'\n'
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|can_be_null
condition|)
return|return;
comment|/* Don't return; check the alternative paths 	     so we can set can_be_null if appropriate.  */
break|break;
case|case
name|wordchar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|==
name|Sword
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|!=
name|Sword
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|emacs
case|case
name|syntaxspec
case|:
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|==
operator|(
expr|enum
name|syntaxcode
operator|)
name|k
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|notsyntaxspec
case|:
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|j
argument_list|)
operator|!=
operator|(
expr|enum
name|syntaxcode
operator|)
name|k
condition|)
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* not emacs */
case|case
name|charset
case|:
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|++
operator|*
name|BYTEWIDTH
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|p
index|[
name|j
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|charset_not
case|:
comment|/* Chars beyond end of map must be allowed */
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|*
name|BYTEWIDTH
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|*
name|p
operator|++
operator|*
name|BYTEWIDTH
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|p
index|[
name|j
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|%
name|BYTEWIDTH
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|translate
condition|)
name|fastmap
index|[
name|translate
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|fastmap
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* Get here means we have successfully found the possible starting          characters of one path of the pattern.  We need not follow this          path any farther.  Instead, look at the next alternative          remembered in the stack.  */
if|if
condition|(
name|stackp
operator|!=
name|stackb
condition|)
name|p
operator|=
operator|*
name|stackp
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like re_search_2, below, but only one string is specified, and    doesn't let you say where to stop matching. */
end_comment

begin_function
name|int
name|re_search
parameter_list|(
name|pbufp
parameter_list|,
name|string
parameter_list|,
name|size
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pbufp
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|,
name|startpos
decl_stmt|,
name|range
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
return|return
name|re_search_2
argument_list|(
name|pbufp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|startpos
argument_list|,
name|range
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Using the compiled pattern in PBUFP->buffer, first tries to match the    virtual concatenation of STRING1 and STRING2, starting first at index    STARTPOS, then at STARTPOS + 1, and so on.  RANGE is the number of    places to try before giving up.  If RANGE is negative, it searches    backwards, i.e., the starting positions tried are STARTPOS, STARTPOS    - 1, etc.  STRING1 and STRING2 are of SIZE1 and SIZE2, respectively.    In REGS, return the indices of the virtual concatenation of STRING1    and STRING2 that matched the entire PBUFP->buffer and its contained    subexpressions.  Do not consider matching one past the index MSTOP in    the virtual concatenation of STRING1 and STRING2.     The value returned is the position in the strings at which the match    was found, or -1 if no match was found, or -2 if error (such as    failure stack overflow).  */
end_comment

begin_function
name|int
name|re_search_2
parameter_list|(
name|pbufp
parameter_list|,
name|string1
parameter_list|,
name|size1
parameter_list|,
name|string2
parameter_list|,
name|size2
parameter_list|,
name|startpos
parameter_list|,
name|range
parameter_list|,
name|regs
parameter_list|,
name|mstop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pbufp
decl_stmt|;
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mstop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|fastmap
init|=
name|pbufp
operator|->
name|fastmap
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pbufp
operator|->
name|translate
decl_stmt|;
name|int
name|total_size
init|=
name|size1
operator|+
name|size2
decl_stmt|;
name|int
name|endpos
init|=
name|startpos
operator|+
name|range
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* Check for out-of-range starting position.  */
if|if
condition|(
name|startpos
operator|<
literal|0
operator|||
name|startpos
operator|>
name|total_size
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Fix up range if it would eventually take startpos outside of the      virtual concatenation of string1 and string2.  */
if|if
condition|(
name|endpos
operator|<
operator|-
literal|1
condition|)
name|range
operator|=
operator|-
literal|1
operator|-
name|startpos
expr_stmt|;
elseif|else
if|if
condition|(
name|endpos
operator|>
name|total_size
condition|)
name|range
operator|=
name|total_size
operator|-
name|startpos
expr_stmt|;
comment|/* Update the fastmap now if not correct already.  */
if|if
condition|(
name|fastmap
operator|&&
operator|!
name|pbufp
operator|->
name|fastmap_accurate
condition|)
name|re_compile_fastmap
argument_list|(
name|pbufp
argument_list|)
expr_stmt|;
comment|/* If the search isn't to be a backwards one, don't waste time in a      long search for a pattern that says it is anchored.  */
if|if
condition|(
name|pbufp
operator|->
name|used
operator|>
literal|0
operator|&&
operator|(
expr|enum
name|regexpcode
operator|)
name|pbufp
operator|->
name|buffer
index|[
literal|0
index|]
operator|==
name|begbuf
operator|&&
name|range
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|startpos
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|range
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If a fastmap is supplied, skip quickly over characters that          cannot possibly be the start of a match.  Note, however, that          if the pattern can possibly match the null string, we must          test it at each starting point so that we take the first null          string we get.  */
if|if
condition|(
name|fastmap
operator|&&
name|startpos
operator|<
name|total_size
operator|&&
name|pbufp
operator|->
name|can_be_null
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|range
operator|>
literal|0
condition|)
comment|/* Searching forwards.  */
block|{
specifier|register
name|int
name|lim
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|irange
init|=
name|range
decl_stmt|;
if|if
condition|(
name|startpos
operator|<
name|size1
operator|&&
name|startpos
operator|+
name|range
operator|>=
name|size1
condition|)
name|lim
operator|=
name|range
operator|-
operator|(
name|size1
operator|-
name|startpos
operator|)
expr_stmt|;
name|p
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|startpos
operator|>=
name|size1
condition|?
name|string2
operator|-
name|size1
else|:
name|string1
operator|)
index|[
name|startpos
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|range
operator|>
name|lim
operator|&&
operator|!
name|fastmap
index|[
name|translate
condition|?
name|translate
index|[
operator|*
name|p
operator|++
index|]
else|:
operator|*
name|p
operator|++
index|]
condition|)
name|range
operator|--
expr_stmt|;
name|startpos
operator|+=
name|irange
operator|-
name|range
expr_stmt|;
block|}
else|else
comment|/* Searching backwards.  */
block|{
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|string1
operator|==
literal|0
operator|||
name|startpos
operator|>=
name|size1
condition|)
name|c
operator|=
name|string2
index|[
name|startpos
operator|-
name|size1
index|]
expr_stmt|;
else|else
name|c
operator|=
name|string1
index|[
name|startpos
index|]
expr_stmt|;
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|translate
condition|?
operator|!
name|fastmap
index|[
name|translate
index|[
name|c
index|]
index|]
else|:
operator|!
name|fastmap
index|[
name|c
index|]
condition|)
goto|goto
name|advance
goto|;
block|}
block|}
if|if
condition|(
name|range
operator|>=
literal|0
operator|&&
name|startpos
operator|==
name|total_size
operator|&&
name|fastmap
operator|&&
name|pbufp
operator|->
name|can_be_null
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|re_match_2
argument_list|(
name|pbufp
argument_list|,
name|string1
argument_list|,
name|size1
argument_list|,
name|string2
argument_list|,
name|size2
argument_list|,
name|startpos
argument_list|,
name|regs
argument_list|,
name|mstop
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
return|return
name|startpos
return|;
if|if
condition|(
name|val
operator|==
operator|-
literal|2
condition|)
return|return
operator|-
literal|2
return|;
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* C_ALLOCA */
name|advance
label|:
if|if
condition|(
operator|!
name|range
condition|)
break|break;
elseif|else
if|if
condition|(
name|range
operator|>
literal|0
condition|)
block|{
name|range
operator|--
expr_stmt|;
name|startpos
operator|++
expr_stmt|;
block|}
else|else
block|{
name|range
operator|++
expr_stmt|;
name|startpos
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_comment
comment|/* emacs never uses this.  */
end_comment

begin_function
name|int
name|re_match
parameter_list|(
name|pbufp
parameter_list|,
name|string
parameter_list|,
name|size
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pbufp
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|,
name|pos
decl_stmt|;
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
block|{
return|return
name|re_match_2
argument_list|(
name|pbufp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|string
argument_list|,
name|size
argument_list|,
name|pos
argument_list|,
name|regs
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_comment
comment|/* The following are used for re_match_2, defined below:  */
end_comment

begin_comment
comment|/* Roughly the maximum number of failure points on the stack.  Would be    exactly that if always pushed MAX_NUM_FAILURE_ITEMS each time we failed.  */
end_comment

begin_decl_stmt
name|int
name|re_max_failures
init|=
literal|2000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routine used by re_match_2.  */
end_comment

begin_function_decl
specifier|static
name|int
name|bcmp_translate
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Structure and accessing macros used in re_match_2:  */
end_comment

begin_struct
struct|struct
name|register_info
block|{
name|unsigned
name|is_active
range|:
literal|1
decl_stmt|;
name|unsigned
name|matched_something
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IS_ACTIVE
parameter_list|(
name|R
parameter_list|)
value|((R).is_active)
end_define

begin_define
define|#
directive|define
name|MATCHED_SOMETHING
parameter_list|(
name|R
parameter_list|)
value|((R).matched_something)
end_define

begin_comment
comment|/* Macros used by re_match_2:  */
end_comment

begin_comment
comment|/* I.e., regstart, regend, and reg_info.  */
end_comment

begin_define
define|#
directive|define
name|NUM_REG_ITEMS
value|3
end_define

begin_comment
comment|/* We push at most this many things on the stack whenever we    fail.  The `+ 2' refers to PATTERN_PLACE and STRING_PLACE, which are    arguments to the PUSH_FAILURE_POINT macro.  */
end_comment

begin_define
define|#
directive|define
name|MAX_NUM_FAILURE_ITEMS
value|(RE_NREGS * NUM_REG_ITEMS + 2)
end_define

begin_comment
comment|/* We push this many things on the stack whenever we fail.  */
end_comment

begin_define
define|#
directive|define
name|NUM_FAILURE_ITEMS
value|(last_used_reg * NUM_REG_ITEMS + 2)
end_define

begin_comment
comment|/* This pushes most of the information about the current state we will want    if we ever fail back to it.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_FAILURE_POINT
parameter_list|(
name|pattern_place
parameter_list|,
name|string_place
parameter_list|)
define|\
value|{									\     short last_used_reg, this_reg;					\ 									\
comment|/* Find out how many registers are active or have been matched.	\        (Aside from register zero, which is only set at the end.)  */
value|\     for (last_used_reg = RE_NREGS - 1; last_used_reg> 0; last_used_reg--)\       if (regstart[last_used_reg] != (unsigned char *) -1)		\         break;								\ 									\     if (stacke - stackp< NUM_FAILURE_ITEMS)				\       {									\ 	unsigned char **stackx;						\ 	unsigned int len = stacke - stackb;				\ 	if (len> re_max_failures * MAX_NUM_FAILURE_ITEMS)		\ 	  return -2;							\ 									\
comment|/* Roughly double the size of the stack.  */
value|\         stackx = (unsigned char **) alloca (2 * len			\                                             * sizeof (unsigned char *));\
comment|/* Only copy what is in use.  */
value|\         bcopy (stackb, stackx, len * sizeof (char *));			\ 	stackp = stackx + (stackp - stackb);				\ 	stackb = stackx;						\ 	stacke = stackb + 2 * len;					\       }									\ 									\
comment|/* Now push the info for each of those registers.  */
value|\     for (this_reg = 1; this_reg<= last_used_reg; this_reg++)		\       {									\         *stackp++ = regstart[this_reg];					\         *stackp++ = regend[this_reg];					\         *stackp++ = (unsigned char *)&reg_info[this_reg];		\       }									\ 									\
comment|/* Push how many registers we saved.  */
value|\     *stackp++ = (unsigned char *) last_used_reg;			\ 									\     *stackp++ = pattern_place;                                          \     *stackp++ = string_place;                                           \   }
end_define

begin_comment
comment|/* This pops what PUSH_FAILURE_POINT pushes.  */
end_comment

begin_define
define|#
directive|define
name|POP_FAILURE_POINT
parameter_list|()
define|\
value|{									\     int temp;								\     stackp -= 2;
comment|/* Remove failure points.  */
value|\     temp = (int) *--stackp;
comment|/* How many regs pushed.  */
value|\     temp *= NUM_REG_ITEMS;
comment|/* How much to take off the stack.  */
value|\     stackp -= temp;
comment|/* Remove the register info.  */
value|\   }
end_define

begin_define
define|#
directive|define
name|MATCHING_IN_FIRST_STRING
value|(dend == end_match_1)
end_define

begin_comment
comment|/* Is true if there is a first string and if PTR is pointing anywhere    inside it or just past the end.  */
end_comment

begin_define
define|#
directive|define
name|IS_IN_FIRST_STRING
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(size1&& string1<= (ptr)&& (ptr)<= string1 + size1)
end_define

begin_comment
comment|/* Call before fetching a character with *d.  This switches over to    string2 if necessary.  */
end_comment

begin_define
define|#
directive|define
name|PREFETCH
define|\
value|while (d == dend)						    	\   {									\
comment|/* end of string2 => fail.  */
value|\     if (dend == end_match_2) 						\       goto fail;							\
comment|/* end of string1 => advance to string2.  */
value|\     d = string2;						        \     dend = end_match_2;							\   }
end_define

begin_comment
comment|/* Call this when have matched something; it sets `matched' flags for the    registers corresponding to the subexpressions of which we currently    are inside.  */
end_comment

begin_define
define|#
directive|define
name|SET_REGS_MATCHED
define|\
value|{ unsigned this_reg; 							\     for (this_reg = 0; this_reg< RE_NREGS; this_reg++) 		\       { 								\         if (IS_ACTIVE(reg_info[this_reg]))				\           MATCHED_SOMETHING(reg_info[this_reg]) = 1;			\         else								\           MATCHED_SOMETHING(reg_info[this_reg]) = 0;			\       } 								\   }
end_define

begin_comment
comment|/* Test if at very beginning or at very end of the virtual concatenation    of string1 and string2.  If there is only one string, we've put it in    string2.  */
end_comment

begin_define
define|#
directive|define
name|AT_STRINGS_BEG
value|(d == (size1 ? string1 : string2)  ||  !size2)
end_define

begin_define
define|#
directive|define
name|AT_STRINGS_END
value|(d == end2)
end_define

begin_define
define|#
directive|define
name|AT_WORD_BOUNDARY
define|\
value|(AT_STRINGS_BEG || AT_STRINGS_END || IS_A_LETTER (d - 1) != IS_A_LETTER (d))
end_define

begin_comment
comment|/* We have two special cases to check for:       1) if we're past the end of string1, we have to look at the first         character in string2;      2) if we're before the beginning of string2, we have to look at the         last character in string1; we assume there is a string1, so use         this in conjunction with AT_STRINGS_BEG.  */
end_comment

begin_define
define|#
directive|define
name|IS_A_LETTER
parameter_list|(
name|d
parameter_list|)
define|\
value|(SYNTAX ((d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d))\    == Sword)
end_define

begin_comment
comment|/* Match the pattern described by PBUFP against the virtual    concatenation of STRING1 and STRING2, which are of SIZE1 and SIZE2,    respectively.  Start the match at index POS in the virtual    concatenation of STRING1 and STRING2.  In REGS, return the indices of    the virtual concatenation of STRING1 and STRING2 that matched the    entire PBUFP->buffer and its contained subexpressions.  Do not    consider matching one past the index MSTOP in the virtual    concatenation of STRING1 and STRING2.     If pbufp->fastmap is nonzero, then it had better be up to date.     The reason that the data to match are specified as two components    which are to be regarded as concatenated is so this function can be    used directly on the contents of an Emacs buffer.     -1 is returned if there is no match.  -2 is returned if there is an    error (such as match stack overflow).  Otherwise the value is the    length of the substring which was matched.  */
end_comment

begin_function
name|int
name|re_match_2
parameter_list|(
name|pbufp
parameter_list|,
name|string1_arg
parameter_list|,
name|size1
parameter_list|,
name|string2_arg
parameter_list|,
name|size2
parameter_list|,
name|pos
parameter_list|,
name|regs
parameter_list|,
name|mstop
parameter_list|)
name|struct
name|re_pattern_buffer
modifier|*
name|pbufp
decl_stmt|;
name|char
modifier|*
name|string1_arg
decl_stmt|,
decl|*
name|string2_arg
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_registers
modifier|*
name|regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mstop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pbufp
operator|->
name|buffer
decl_stmt|;
comment|/* Pointer to beyond end of buffer.  */
specifier|register
name|unsigned
name|char
modifier|*
name|pend
init|=
name|p
operator|+
name|pbufp
operator|->
name|used
decl_stmt|;
name|unsigned
name|char
modifier|*
name|string1
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|string1_arg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|string2
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|string2_arg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end1
decl_stmt|;
comment|/* Just past end of first string.  */
name|unsigned
name|char
modifier|*
name|end2
decl_stmt|;
comment|/* Just past end of second string.  */
comment|/* Pointers into string1 and string2, just past the last characters in      each to consider matching.  */
name|unsigned
name|char
modifier|*
name|end_match_1
decl_stmt|,
modifier|*
name|end_match_2
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|dend
decl_stmt|;
specifier|register
name|int
name|mcnt
decl_stmt|;
comment|/* Multipurpose.  */
name|unsigned
name|char
modifier|*
name|translate
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pbufp
operator|->
name|translate
decl_stmt|;
name|unsigned
name|is_a_jump_n
init|=
literal|0
decl_stmt|;
comment|/* Failure point stack.  Each place that can handle a failure further     down the line pushes a failure point on this stack.  It consists of     restart, regend, and reg_info for all registers corresponding to the     subexpressions we're currently inside, plus the number of such     registers, and, finally, two char *'s.  The first char * is where to     resume scanning the pattern; the second one is where to resume     scanning the strings.  If the latter is zero, the failure point is a     ``dummy''; if a failure happens and the failure point is a dummy, it     gets discarded and the next next one is tried.  */
name|unsigned
name|char
modifier|*
name|initial_stack
index|[
name|MAX_NUM_FAILURE_ITEMS
operator|*
name|NFAILURES
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|stackb
init|=
name|initial_stack
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|stackp
init|=
name|stackb
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|stacke
init|=
operator|&
name|stackb
index|[
name|MAX_NUM_FAILURE_ITEMS
operator|*
name|NFAILURES
index|]
decl_stmt|;
comment|/* Information on the contents of registers. These are pointers into      the input strings; they record just what was matched (on this      attempt) by a subexpression part of the pattern, that is, the      regnum-th regstart pointer points to where in the pattern we began      matching and the regnum-th regend points to right after where we      stopped matching the regnum-th subexpression.  (The zeroth register      keeps track of what the whole pattern matches.)  */
name|unsigned
name|char
modifier|*
name|regstart
index|[
name|RE_NREGS
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|regend
index|[
name|RE_NREGS
index|]
decl_stmt|;
comment|/* The is_active field of reg_info helps us keep track of which (possibly      nested) subexpressions we are currently in. The matched_something      field of reg_info[reg_num] helps us tell whether or not we have      matched any of the pattern so far this time through the reg_num-th      subexpression.  These two fields get reset each time through any      loop their register is in.  */
name|struct
name|register_info
name|reg_info
index|[
name|RE_NREGS
index|]
decl_stmt|;
comment|/* The following record the register info as found in the above      variables when we find a match better than any we've seen before.       This happens as we backtrack through the failure points, which in      turn happens only if we have not yet matched the entire string.  */
name|unsigned
name|best_regs_set
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|best_regstart
index|[
name|RE_NREGS
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|best_regend
index|[
name|RE_NREGS
index|]
decl_stmt|;
comment|/* Initialize subexpression text positions to -1 to mark ones that no      \( or ( and \) or ) has been seen for. Also set all registers to      inactive and mark them as not having matched anything or ever      failed.  */
for|for
control|(
name|mcnt
operator|=
literal|0
init|;
name|mcnt
operator|<
name|RE_NREGS
condition|;
name|mcnt
operator|++
control|)
block|{
name|regstart
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
name|mcnt
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|regs
condition|)
for|for
control|(
name|mcnt
operator|=
literal|0
init|;
name|mcnt
operator|<
name|RE_NREGS
condition|;
name|mcnt
operator|++
control|)
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set up pointers to ends of strings.      Don't allow the second string to be empty unless both are empty.  */
if|if
condition|(
name|size2
operator|==
literal|0
condition|)
block|{
name|string2
operator|=
name|string1
expr_stmt|;
name|size2
operator|=
name|size1
expr_stmt|;
name|string1
operator|=
literal|0
expr_stmt|;
name|size1
operator|=
literal|0
expr_stmt|;
block|}
name|end1
operator|=
name|string1
operator|+
name|size1
expr_stmt|;
name|end2
operator|=
name|string2
operator|+
name|size2
expr_stmt|;
comment|/* Compute where to stop matching, within the two strings.  */
if|if
condition|(
name|mstop
operator|<=
name|size1
condition|)
block|{
name|end_match_1
operator|=
name|string1
operator|+
name|mstop
expr_stmt|;
name|end_match_2
operator|=
name|string2
expr_stmt|;
block|}
else|else
block|{
name|end_match_1
operator|=
name|end1
expr_stmt|;
name|end_match_2
operator|=
name|string2
operator|+
name|mstop
operator|-
name|size1
expr_stmt|;
block|}
comment|/* `p' scans through the pattern as `d' scans through the data. `dend'      is the end of the input string that `d' points within. `d' is      advanced into the following input string whenever necessary, but      this happens before fetching; therefore, at the beginning of the      loop, `d' can be pointing at the end of a string, but it cannot      equal string2.  */
if|if
condition|(
name|size1
operator|!=
literal|0
operator|&&
name|pos
operator|<=
name|size1
condition|)
name|d
operator|=
name|string1
operator|+
name|pos
operator|,
name|dend
operator|=
name|end_match_1
expr_stmt|;
else|else
name|d
operator|=
name|string2
operator|+
name|pos
operator|-
name|size1
operator|,
name|dend
operator|=
name|end_match_2
expr_stmt|;
comment|/* This loops over pattern commands.  It exits by returning from the      function if match is complete, or it drops through if match fails      at this starting point in the input data.  */
while|while
condition|(
literal|1
condition|)
block|{
name|is_a_jump_n
operator|=
literal|0
expr_stmt|;
comment|/* End of pattern means we might have succeeded.  */
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
comment|/* If not end of string, try backtracking.  Otherwise done.  */
if|if
condition|(
name|d
operator|!=
name|end_match_2
condition|)
block|{
if|if
condition|(
name|stackp
operator|!=
name|stackb
condition|)
block|{
comment|/* More failure points to try.  */
name|unsigned
name|in_same_string
init|=
name|IS_IN_FIRST_STRING
argument_list|(
name|best_regend
index|[
literal|0
index|]
argument_list|)
operator|==
name|MATCHING_IN_FIRST_STRING
decl_stmt|;
comment|/* If exceeds best match so far, save it.  */
if|if
condition|(
operator|!
name|best_regs_set
operator|||
operator|(
name|in_same_string
operator|&&
name|d
operator|>
name|best_regend
index|[
literal|0
index|]
operator|)
operator|||
operator|(
operator|!
name|in_same_string
operator|&&
operator|!
name|MATCHING_IN_FIRST_STRING
operator|)
condition|)
block|{
name|best_regs_set
operator|=
literal|1
expr_stmt|;
name|best_regend
index|[
literal|0
index|]
operator|=
name|d
expr_stmt|;
comment|/* Never use regstart[0].  */
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
name|mcnt
operator|<
name|RE_NREGS
condition|;
name|mcnt
operator|++
control|)
block|{
name|best_regstart
index|[
name|mcnt
index|]
operator|=
name|regstart
index|[
name|mcnt
index|]
expr_stmt|;
name|best_regend
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
expr_stmt|;
block|}
block|}
goto|goto
name|fail
goto|;
block|}
comment|/* If no failure points, don't restore garbage.  */
elseif|else
if|if
condition|(
name|best_regs_set
condition|)
block|{
name|restore_best_regs
label|:
comment|/* Restore best match.  */
name|d
operator|=
name|best_regend
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|mcnt
operator|=
literal|0
init|;
name|mcnt
operator|<
name|RE_NREGS
condition|;
name|mcnt
operator|++
control|)
block|{
name|regstart
index|[
name|mcnt
index|]
operator|=
name|best_regstart
index|[
name|mcnt
index|]
expr_stmt|;
name|regend
index|[
name|mcnt
index|]
operator|=
name|best_regend
index|[
name|mcnt
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* If caller wants register contents data back, convert it  	     to indices.  */
if|if
condition|(
name|regs
condition|)
block|{
name|regs
operator|->
name|start
index|[
literal|0
index|]
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|MATCHING_IN_FIRST_STRING
condition|)
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
name|d
operator|-
name|string1
expr_stmt|;
else|else
name|regs
operator|->
name|end
index|[
literal|0
index|]
operator|=
name|d
operator|-
name|string2
operator|+
name|size1
expr_stmt|;
for|for
control|(
name|mcnt
operator|=
literal|1
init|;
name|mcnt
operator|<
name|RE_NREGS
condition|;
name|mcnt
operator|++
control|)
block|{
if|if
condition|(
name|regend
index|[
name|mcnt
index|]
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|IS_IN_FIRST_STRING
argument_list|(
name|regstart
index|[
name|mcnt
index|]
argument_list|)
condition|)
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regstart
index|[
name|mcnt
index|]
operator|-
name|string1
expr_stmt|;
else|else
name|regs
operator|->
name|start
index|[
name|mcnt
index|]
operator|=
name|regstart
index|[
name|mcnt
index|]
operator|-
name|string2
operator|+
name|size1
expr_stmt|;
if|if
condition|(
name|IS_IN_FIRST_STRING
argument_list|(
name|regend
index|[
name|mcnt
index|]
argument_list|)
condition|)
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
operator|-
name|string1
expr_stmt|;
else|else
name|regs
operator|->
name|end
index|[
name|mcnt
index|]
operator|=
name|regend
index|[
name|mcnt
index|]
operator|-
name|string2
operator|+
name|size1
expr_stmt|;
block|}
block|}
return|return
name|d
operator|-
name|pos
operator|-
operator|(
name|MATCHING_IN_FIRST_STRING
condition|?
name|string1
else|:
name|string2
operator|-
name|size1
operator|)
return|;
block|}
comment|/* Otherwise match next pattern command.  */
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|++
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p
operator|++
condition|)
endif|#
directive|endif
block|{
comment|/* \( [or `(', as appropriate] is represented by start_memory,            \) by stop_memory.  Both of those commands are followed by            a register number in the next byte.  The text matched            within the \( and \) is recorded under that number.  */
case|case
name|start_memory
case|:
name|regstart
index|[
operator|*
name|p
index|]
operator|=
name|d
expr_stmt|;
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
name|stop_memory
case|:
name|regend
index|[
operator|*
name|p
index|]
operator|=
name|d
expr_stmt|;
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If just failed to match something this time around with a sub- 	     expression that's in a loop, try to force exit from the loop.  */
if|if
condition|(
operator|(
operator|!
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
operator|*
name|p
index|]
argument_list|)
operator|||
operator|(
expr|enum
name|regexpcode
operator|)
name|p
index|[
operator|-
literal|3
index|]
operator|==
name|start_memory
operator|)
operator|&&
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
name|pend
condition|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p2
init|=
name|p
operator|+
literal|1
decl_stmt|;
name|mcnt
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|p2
operator|++
condition|)
block|{
case|case
name|jump_n
case|:
name|is_a_jump_n
operator|=
literal|1
expr_stmt|;
case|case
name|finalize_jump
case|:
case|case
name|maybe_finalize_jump
case|:
case|case
name|jump
case|:
case|case
name|dummy_failure_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_a_jump_n
condition|)
name|p2
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|p2
operator|+=
name|mcnt
expr_stmt|;
comment|/* If the next operation is a jump backwards in the pattern 	         to an on_failure_jump, exit from the loop by forcing a                  failure after pushing on the stack the on_failure_jump's                   jump in the pattern, and d.  */
if|if
condition|(
name|mcnt
operator|<
literal|0
operator|&&
operator|(
expr|enum
name|regexpcode
operator|)
operator|*
name|p2
operator|++
operator|==
name|on_failure_jump
condition|)
block|{
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|PUSH_FAILURE_POINT
argument_list|(
name|p2
operator|+
name|mcnt
argument_list|,
name|d
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|p
operator|++
expr_stmt|;
break|break;
comment|/* \<digit> has been turned into a `duplicate' command which is            followed by the numeric value of<digit> as the register number.  */
case|case
name|duplicate
case|:
block|{
name|int
name|regno
init|=
operator|*
name|p
operator|++
decl_stmt|;
comment|/* Get which register to match against */
specifier|register
name|unsigned
name|char
modifier|*
name|d2
decl_stmt|,
modifier|*
name|dend2
decl_stmt|;
comment|/* Where in input to try to start matching.  */
name|d2
operator|=
name|regstart
index|[
name|regno
index|]
expr_stmt|;
comment|/* Where to stop matching; if both the place to start and                the place to stop matching are in the same string, then                set to the place to stop, otherwise, for now have to use                the end of the first string.  */
name|dend2
operator|=
operator|(
operator|(
name|IS_IN_FIRST_STRING
argument_list|(
name|regstart
index|[
name|regno
index|]
argument_list|)
operator|==
name|IS_IN_FIRST_STRING
argument_list|(
name|regend
index|[
name|regno
index|]
argument_list|)
operator|)
condition|?
name|regend
index|[
name|regno
index|]
else|:
name|end_match_1
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If necessary, advance to next segment in register                    contents.  */
while|while
condition|(
name|d2
operator|==
name|dend2
condition|)
block|{
if|if
condition|(
name|dend2
operator|==
name|end_match_2
condition|)
break|break;
if|if
condition|(
name|dend2
operator|==
name|regend
index|[
name|regno
index|]
condition|)
break|break;
name|d2
operator|=
name|string2
operator|,
name|dend2
operator|=
name|regend
index|[
name|regno
index|]
expr_stmt|;
comment|/* end of string1 => advance to string2. */
block|}
comment|/* At end of register contents => success */
if|if
condition|(
name|d2
operator|==
name|dend2
condition|)
break|break;
comment|/* If necessary, advance to next segment in data.  */
name|PREFETCH
expr_stmt|;
comment|/* How many characters left in this segment to match.  */
name|mcnt
operator|=
name|dend
operator|-
name|d
expr_stmt|;
comment|/* Want how many consecutive characters we can match in                    one shot, so, if necessary, adjust the count.  */
if|if
condition|(
name|mcnt
operator|>
name|dend2
operator|-
name|d2
condition|)
name|mcnt
operator|=
name|dend2
operator|-
name|d2
expr_stmt|;
comment|/* Compare that many; failure if mismatch, else move                    past them.  */
if|if
condition|(
name|translate
condition|?
name|bcmp_translate
argument_list|(
name|d
argument_list|,
name|d2
argument_list|,
name|mcnt
argument_list|,
name|translate
argument_list|)
else|:
name|bcmp
argument_list|(
name|d
argument_list|,
name|d2
argument_list|,
name|mcnt
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|d
operator|+=
name|mcnt
operator|,
name|d2
operator|+=
name|mcnt
expr_stmt|;
block|}
block|}
break|break;
case|case
name|anychar
case|:
name|PREFETCH
expr_stmt|;
comment|/* Fetch a data character. */
comment|/* Match anything but a newline, maybe even a null.  */
if|if
condition|(
operator|(
name|translate
condition|?
name|translate
index|[
operator|*
name|d
index|]
else|:
operator|*
name|d
operator|)
operator|==
literal|'\n'
operator|||
operator|(
operator|(
name|obscure_syntax
operator|&
name|RE_DOT_NOT_NULL
operator|)
operator|&&
operator|(
name|translate
condition|?
name|translate
index|[
operator|*
name|d
index|]
else|:
operator|*
name|d
operator|)
operator|==
literal|'\000'
operator|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
case|case
name|charset
case|:
case|case
name|charset_not
case|:
block|{
name|int
name|not
init|=
literal|0
decl_stmt|;
comment|/* Nonzero for charset_not.  */
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
operator|(
name|unsigned
name|char
operator|)
name|charset_not
condition|)
name|not
operator|=
literal|1
expr_stmt|;
name|PREFETCH
expr_stmt|;
comment|/* Fetch a data character. */
if|if
condition|(
name|translate
condition|)
name|c
operator|=
name|translate
index|[
operator|*
name|d
index|]
expr_stmt|;
else|else
name|c
operator|=
operator|*
name|d
expr_stmt|;
if|if
condition|(
name|c
operator|<
operator|*
name|p
operator|*
name|BYTEWIDTH
operator|&&
name|p
index|[
literal|1
operator|+
name|c
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|not
operator|=
operator|!
name|not
expr_stmt|;
name|p
operator|+=
literal|1
operator|+
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|not
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
expr_stmt|;
name|d
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|begline
case|:
if|if
condition|(
operator|(
name|size1
operator|!=
literal|0
operator|&&
name|d
operator|==
name|string1
operator|)
operator|||
operator|(
name|size1
operator|==
literal|0
operator|&&
name|size2
operator|!=
literal|0
operator|&&
name|d
operator|==
name|string2
operator|)
operator|||
operator|(
name|d
operator|&&
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|size1
operator|==
literal|0
operator|&&
name|size2
operator|==
literal|0
operator|)
condition|)
break|break;
else|else
goto|goto
name|fail
goto|;
case|case
name|endline
case|:
if|if
condition|(
name|d
operator|==
name|end2
operator|||
operator|(
name|d
operator|==
name|end1
condition|?
operator|(
name|size2
operator|==
literal|0
operator|||
operator|*
name|string2
operator|==
literal|'\n'
operator|)
else|:
operator|*
name|d
operator|==
literal|'\n'
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
comment|/* `or' constructs are handled by starting each alternative with            an on_failure_jump that points to the start of the next            alternative.  Each alternative except the last ends with a            jump to the joining point.  (Actually, each jump except for            the last one really jumps to the following jump, because            tensioning the jumps is a hassle.)  */
comment|/* The start of a stupid repeat has an on_failure_jump that points 	   past the end of the repeat text. This makes a failure point so             that on failure to match a repetition, matching restarts past            as many repetitions have been found with no way to fail and            look for another one.  */
comment|/* A smart repeat is similar but loops back to the on_failure_jump 	   so that each repetition makes another failure point.  */
case|case
name|on_failure_jump
case|:
name|on_failure
label|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|PUSH_FAILURE_POINT
argument_list|(
name|p
operator|+
name|mcnt
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* The end of a smart repeat has a maybe_finalize_jump back. 	   Change it either to a finalize_jump or an ordinary jump.  */
case|case
name|maybe_finalize_jump
case|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p2
init|=
name|p
decl_stmt|;
comment|/* Compare what follows with the beginning of the repeat. 	       If we can establish that there is nothing that they would 	       both match, we can change to finalize_jump.  */
while|while
condition|(
name|p2
operator|+
literal|1
operator|!=
name|pend
operator|&&
operator|(
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|stop_memory
operator|||
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|start_memory
operator|)
condition|)
name|p2
operator|+=
literal|2
expr_stmt|;
comment|/* Skip over reg number.  */
if|if
condition|(
name|p2
operator|==
name|pend
condition|)
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|finalize_jump
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|exactn
operator|||
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|endline
condition|)
block|{
specifier|register
name|int
name|c
init|=
operator|*
name|p2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|endline
condition|?
literal|'\n'
else|:
name|p2
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
init|=
name|p
operator|+
name|mcnt
decl_stmt|;
comment|/* p1[0] ... p1[2] are an on_failure_jump. 		   Examine what follows that.  */
if|if
condition|(
name|p1
index|[
literal|3
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|exactn
operator|&&
name|p1
index|[
literal|5
index|]
operator|!=
name|c
condition|)
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|finalize_jump
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
index|[
literal|3
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|charset
operator|||
name|p1
index|[
literal|3
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|charset_not
condition|)
block|{
name|int
name|not
init|=
name|p1
index|[
literal|3
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|charset_not
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|p1
index|[
literal|4
index|]
operator|*
name|BYTEWIDTH
operator|&&
name|p1
index|[
literal|5
operator|+
name|c
operator|/
name|BYTEWIDTH
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|BYTEWIDTH
operator|)
operator|)
condition|)
name|not
operator|=
operator|!
name|not
expr_stmt|;
comment|/* `not' is 1 if c would match.  */
comment|/* That means it is not safe to finalize.  */
if|if
condition|(
operator|!
name|not
condition|)
name|p
index|[
operator|-
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|finalize_jump
expr_stmt|;
block|}
block|}
block|}
name|p
operator|-=
literal|2
expr_stmt|;
comment|/* Point at relative address again.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|finalize_jump
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|jump
expr_stmt|;
goto|goto
name|nofinalize
goto|;
block|}
comment|/* Note fall through.  */
comment|/* The end of a stupid repeat has a finalize_jump back to the            start, where another failure point will be made which will            point to after all the repetitions found so far.  */
comment|/* Take off failure points put on by matching on_failure_jump             because didn't fail.  Also remove the register information            put on by the on_failure_jump.  */
case|case
name|finalize_jump
case|:
name|POP_FAILURE_POINT
argument_list|()
expr_stmt|;
comment|/* Note fall through.  */
comment|/* Jump without taking off any failure points.  */
case|case
name|jump
case|:
name|nofinalize
label|:
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|mcnt
expr_stmt|;
break|break;
case|case
name|dummy_failure_jump
case|:
comment|/* Normally, the on_failure_jump pushes a failure point, which              then gets popped at finalize_jump.  We will end up at              finalize_jump, also, and with a pattern of, say, `a+', we              are skipping over the on_failure_jump, so we have to push              something meaningless for finalize_jump to pop.  */
name|PUSH_FAILURE_POINT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|nofinalize
goto|;
comment|/* Have to succeed matching what follows at least n times.  Then           just handle like an on_failure_jump.  */
case|case
name|succeed_n
case|:
name|EXTRACT_NUMBER
argument_list|(
name|mcnt
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Originally, this is how many times we HAVE to succeed.  */
if|if
condition|(
name|mcnt
condition|)
block|{
name|mcnt
operator|--
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|STORE_NUMBER_AND_INCR
argument_list|(
name|p
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mcnt
operator|==
literal|0
condition|)
block|{
name|p
index|[
literal|2
index|]
operator|=
name|unused
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|unused
expr_stmt|;
goto|goto
name|on_failure
goto|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regex: the succeed_n's n is not set.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|jump_n
case|:
name|EXTRACT_NUMBER
argument_list|(
name|mcnt
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Originally, this is how many times we CAN jump.  */
if|if
condition|(
name|mcnt
condition|)
block|{
name|mcnt
operator|--
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
goto|goto
name|nofinalize
goto|;
comment|/* Do the jump without taking off 			                any failure points.  */
block|}
comment|/* If don't have to jump any more, skip over the rest of command.  */
else|else
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|set_number_at
case|:
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|+
name|mcnt
expr_stmt|;
name|EXTRACT_NUMBER_AND_INCR
argument_list|(
name|mcnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|STORE_NUMBER
argument_list|(
name|p1
argument_list|,
name|mcnt
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Ignore these.  Used to ignore the n of succeed_n's which            currently have n == 0.  */
case|case
name|unused
case|:
break|break;
case|case
name|wordbound
case|:
if|if
condition|(
name|AT_WORD_BOUNDARY
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|notwordbound
case|:
if|if
condition|(
name|AT_WORD_BOUNDARY
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|wordbeg
case|:
comment|/* Have to check if AT_STRINGS_BEG before looking at d - 1.  */
if|if
condition|(
name|IS_A_LETTER
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|AT_STRINGS_BEG
operator|||
operator|!
name|IS_A_LETTER
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|wordend
case|:
comment|/* Have to check if AT_STRINGS_BEG before looking at d - 1.  */
if|if
condition|(
operator|!
name|AT_STRINGS_BEG
operator|&&
name|IS_A_LETTER
argument_list|(
name|d
operator|-
literal|1
argument_list|)
operator|&&
operator|(
operator|!
name|IS_A_LETTER
argument_list|(
name|d
argument_list|)
operator|||
name|AT_STRINGS_END
operator|)
condition|)
break|break;
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|emacs
case|case
name|before_dot
case|:
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
name|d
argument_list|)
operator|>=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|at_dot
case|:
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
name|d
argument_list|)
operator|!=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|after_dot
case|:
if|if
condition|(
name|PTR_CHAR_POS
argument_list|(
name|d
argument_list|)
operator|<=
name|point
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|wordchar
case|:
name|mcnt
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
goto|goto
name|matchsyntax
goto|;
case|case
name|syntaxspec
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|matchsyntax
label|:
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
operator|*
name|d
operator|++
argument_list|)
operator|!=
operator|(
expr|enum
name|syntaxcode
operator|)
name|mcnt
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
name|mcnt
operator|=
operator|(
name|int
operator|)
name|Sword
expr_stmt|;
goto|goto
name|matchnotsyntax
goto|;
case|case
name|notsyntaxspec
case|:
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|matchnotsyntax
label|:
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
operator|*
name|d
operator|++
argument_list|)
operator|==
operator|(
expr|enum
name|syntaxcode
operator|)
name|mcnt
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
expr_stmt|;
break|break;
else|#
directive|else
comment|/* not emacs */
case|case
name|wordchar
case|:
name|PREFETCH
expr_stmt|;
if|if
condition|(
operator|!
name|IS_A_LETTER
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
expr_stmt|;
break|break;
case|case
name|notwordchar
case|:
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|IS_A_LETTER
argument_list|(
name|d
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|SET_REGS_MATCHED
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* not emacs */
case|case
name|begbuf
case|:
if|if
condition|(
name|AT_STRINGS_BEG
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|endbuf
case|:
if|if
condition|(
name|AT_STRINGS_END
condition|)
break|break;
goto|goto
name|fail
goto|;
case|case
name|exactn
case|:
comment|/* Match the next few pattern characters exactly. 	     mcnt is how many characters to match.  */
name|mcnt
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* This is written out as an if-else so we don't waste time              testing `translate' inside the loop.  */
if|if
condition|(
name|translate
condition|)
block|{
do|do
block|{
name|PREFETCH
expr_stmt|;
if|if
condition|(
name|translate
index|[
operator|*
name|d
operator|++
index|]
operator|!=
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|PREFETCH
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|++
operator|!=
operator|*
name|p
operator|++
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
operator|--
name|mcnt
condition|)
do|;
block|}
name|SET_REGS_MATCHED
expr_stmt|;
break|break;
block|}
continue|continue;
comment|/* Successfully executed one pattern command; keep going.  */
comment|/* Jump here if any matching operation fails. */
name|fail
label|:
if|if
condition|(
name|stackp
operator|!=
name|stackb
condition|)
comment|/* A restart point is known.  Restart there and pop it. */
block|{
name|short
name|last_used_reg
decl_stmt|,
name|this_reg
decl_stmt|;
comment|/* If this failure point is from a dummy_failure_point, just              skip it.  */
if|if
condition|(
operator|!
name|stackp
index|[
operator|-
literal|2
index|]
condition|)
block|{
name|POP_FAILURE_POINT
argument_list|()
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|d
operator|=
operator|*
operator|--
name|stackp
expr_stmt|;
name|p
operator|=
operator|*
operator|--
name|stackp
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|string1
operator|&&
name|d
operator|<=
name|end1
condition|)
name|dend
operator|=
name|end_match_1
expr_stmt|;
comment|/* Restore register info.  */
name|last_used_reg
operator|=
operator|(
name|short
operator|)
operator|*
operator|--
name|stackp
expr_stmt|;
comment|/* Make the ones that weren't saved -1 or 0 again.  */
for|for
control|(
name|this_reg
operator|=
name|RE_NREGS
operator|-
literal|1
init|;
name|this_reg
operator|>
name|last_used_reg
condition|;
name|this_reg
operator|--
control|)
block|{
name|regend
index|[
name|this_reg
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|regstart
index|[
name|this_reg
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|IS_ACTIVE
argument_list|(
name|reg_info
index|[
name|this_reg
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MATCHED_SOMETHING
argument_list|(
name|reg_info
index|[
name|this_reg
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* And restore the rest from the stack.  */
for|for
control|(
init|;
name|this_reg
operator|>
literal|0
condition|;
name|this_reg
operator|--
control|)
block|{
name|reg_info
index|[
name|this_reg
index|]
operator|=
operator|*
operator|(
expr|struct
name|register_info
operator|*
operator|)
operator|*
operator|--
name|stackp
expr_stmt|;
name|regend
index|[
name|this_reg
index|]
operator|=
operator|*
operator|--
name|stackp
expr_stmt|;
name|regstart
index|[
name|this_reg
index|]
operator|=
operator|*
operator|--
name|stackp
expr_stmt|;
block|}
block|}
else|else
break|break;
comment|/* Matching at this starting point really fails.  */
block|}
if|if
condition|(
name|best_regs_set
condition|)
goto|goto
name|restore_best_regs
goto|;
return|return
operator|-
literal|1
return|;
comment|/* Failure to match.  */
block|}
end_block

begin_function
specifier|static
name|int
name|bcmp_translate
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|,
name|translate
parameter_list|)
name|unsigned
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|translate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p1
init|=
name|s1
decl_stmt|,
modifier|*
name|p2
init|=
name|s2
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|translate
index|[
operator|*
name|p1
operator|++
index|]
operator|!=
name|translate
index|[
operator|*
name|p2
operator|++
index|]
condition|)
return|return
literal|1
return|;
name|len
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Entry points compatible with 4.2 BSD regex library.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|emacs
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|re_comp_buf
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|re_comp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
return|return
literal|"No previous regular expression"
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|re_comp_buf
operator|.
name|buffer
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|re_comp_buf
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|200
argument_list|)
operator|)
condition|)
return|return
literal|"Memory exhausted"
return|;
name|re_comp_buf
operator|.
name|allocated
operator|=
literal|200
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|re_comp_buf
operator|.
name|fastmap
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1
operator|<<
name|BYTEWIDTH
argument_list|)
operator|)
condition|)
return|return
literal|"Memory exhausted"
return|;
block|}
return|return
name|re_compile_pattern
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|re_comp_buf
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|re_exec
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
return|return
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|re_comp_buf
argument_list|,
name|s
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not emacs */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|test
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Indexed by a character, gives the upper case equivalent of the    character.  */
end_comment

begin_decl_stmt
name|char
name|upcase
index|[
literal|0400
index|]
init|=
block|{
literal|000
block|,
literal|001
block|,
literal|002
block|,
literal|003
block|,
literal|004
block|,
literal|005
block|,
literal|006
block|,
literal|007
block|,
literal|010
block|,
literal|011
block|,
literal|012
block|,
literal|013
block|,
literal|014
block|,
literal|015
block|,
literal|016
block|,
literal|017
block|,
literal|020
block|,
literal|021
block|,
literal|022
block|,
literal|023
block|,
literal|024
block|,
literal|025
block|,
literal|026
block|,
literal|027
block|,
literal|030
block|,
literal|031
block|,
literal|032
block|,
literal|033
block|,
literal|034
block|,
literal|035
block|,
literal|036
block|,
literal|037
block|,
literal|040
block|,
literal|041
block|,
literal|042
block|,
literal|043
block|,
literal|044
block|,
literal|045
block|,
literal|046
block|,
literal|047
block|,
literal|050
block|,
literal|051
block|,
literal|052
block|,
literal|053
block|,
literal|054
block|,
literal|055
block|,
literal|056
block|,
literal|057
block|,
literal|060
block|,
literal|061
block|,
literal|062
block|,
literal|063
block|,
literal|064
block|,
literal|065
block|,
literal|066
block|,
literal|067
block|,
literal|070
block|,
literal|071
block|,
literal|072
block|,
literal|073
block|,
literal|074
block|,
literal|075
block|,
literal|076
block|,
literal|077
block|,
literal|0100
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0133
block|,
literal|0134
block|,
literal|0135
block|,
literal|0136
block|,
literal|0137
block|,
literal|0140
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0173
block|,
literal|0174
block|,
literal|0175
block|,
literal|0176
block|,
literal|0177
block|,
literal|0200
block|,
literal|0201
block|,
literal|0202
block|,
literal|0203
block|,
literal|0204
block|,
literal|0205
block|,
literal|0206
block|,
literal|0207
block|,
literal|0210
block|,
literal|0211
block|,
literal|0212
block|,
literal|0213
block|,
literal|0214
block|,
literal|0215
block|,
literal|0216
block|,
literal|0217
block|,
literal|0220
block|,
literal|0221
block|,
literal|0222
block|,
literal|0223
block|,
literal|0224
block|,
literal|0225
block|,
literal|0226
block|,
literal|0227
block|,
literal|0230
block|,
literal|0231
block|,
literal|0232
block|,
literal|0233
block|,
literal|0234
block|,
literal|0235
block|,
literal|0236
block|,
literal|0237
block|,
literal|0240
block|,
literal|0241
block|,
literal|0242
block|,
literal|0243
block|,
literal|0244
block|,
literal|0245
block|,
literal|0246
block|,
literal|0247
block|,
literal|0250
block|,
literal|0251
block|,
literal|0252
block|,
literal|0253
block|,
literal|0254
block|,
literal|0255
block|,
literal|0256
block|,
literal|0257
block|,
literal|0260
block|,
literal|0261
block|,
literal|0262
block|,
literal|0263
block|,
literal|0264
block|,
literal|0265
block|,
literal|0266
block|,
literal|0267
block|,
literal|0270
block|,
literal|0271
block|,
literal|0272
block|,
literal|0273
block|,
literal|0274
block|,
literal|0275
block|,
literal|0276
block|,
literal|0277
block|,
literal|0300
block|,
literal|0301
block|,
literal|0302
block|,
literal|0303
block|,
literal|0304
block|,
literal|0305
block|,
literal|0306
block|,
literal|0307
block|,
literal|0310
block|,
literal|0311
block|,
literal|0312
block|,
literal|0313
block|,
literal|0314
block|,
literal|0315
block|,
literal|0316
block|,
literal|0317
block|,
literal|0320
block|,
literal|0321
block|,
literal|0322
block|,
literal|0323
block|,
literal|0324
block|,
literal|0325
block|,
literal|0326
block|,
literal|0327
block|,
literal|0330
block|,
literal|0331
block|,
literal|0332
block|,
literal|0333
block|,
literal|0334
block|,
literal|0335
block|,
literal|0336
block|,
literal|0337
block|,
literal|0340
block|,
literal|0341
block|,
literal|0342
block|,
literal|0343
block|,
literal|0344
block|,
literal|0345
block|,
literal|0346
block|,
literal|0347
block|,
literal|0350
block|,
literal|0351
block|,
literal|0352
block|,
literal|0353
block|,
literal|0354
block|,
literal|0355
block|,
literal|0356
block|,
literal|0357
block|,
literal|0360
block|,
literal|0361
block|,
literal|0362
block|,
literal|0363
block|,
literal|0364
block|,
literal|0365
block|,
literal|0366
block|,
literal|0367
block|,
literal|0370
block|,
literal|0371
block|,
literal|0372
block|,
literal|0373
block|,
literal|0374
block|,
literal|0375
block|,
literal|0376
block|,
literal|0377
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|canned
end_ifdef

begin_include
include|#
directive|include
file|"tests.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|extended_test
block|,
name|basic_test
block|}
name|test_type
typedef|;
end_typedef

begin_comment
comment|/* Use this to run the tests we've thought of.  */
end_comment

begin_function
name|void
name|main
parameter_list|()
block|{
name|test_type
name|t
init|=
name|extended_test
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|basic_test
condition|)
block|{
name|printf
argument_list|(
literal|"Running basic tests:\n\n"
argument_list|)
expr_stmt|;
name|test_posix_basic
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|extended_test
condition|)
block|{
name|printf
argument_list|(
literal|"Running extended tests:\n\n"
argument_list|)
expr_stmt|;
name|test_posix_extended
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not canned */
end_comment

begin_comment
comment|/* Use this to run interactive tests.  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|pat
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|re_pattern_buffer
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|fastmap
index|[
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
index|]
decl_stmt|;
comment|/* Allow a command argument to specify the style of syntax.  */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|obscure_syntax
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|allocated
operator|=
literal|40
expr_stmt|;
name|buf
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|buf
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|buf
operator|.
name|fastmap
operator|=
name|fastmap
expr_stmt|;
name|buf
operator|.
name|translate
operator|=
name|upcase
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|gets
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pat
condition|)
block|{
name|re_compile_pattern
argument_list|(
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buf
operator|.
name|used
condition|;
name|i
operator|++
control|)
name|printchar
argument_list|(
name|buf
operator|.
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d allocated, %d used.\n"
argument_list|,
name|buf
operator|.
name|allocated
argument_list|,
name|buf
operator|.
name|used
argument_list|)
expr_stmt|;
name|re_compile_fastmap
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Allowed by fastmap: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fastmap
index|[
name|i
index|]
condition|)
name|printchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|gets
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Now read the string to match against */
name|i
operator|=
name|re_match
argument_list|(
operator|&
name|buf
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Match value %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_macro
name|print_buf
argument_list|(
argument|bufp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"buf is :\n----------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bufp
operator|->
name|used
condition|;
name|i
operator|++
control|)
name|printchar
argument_list|(
name|bufp
operator|->
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%d allocated, %d used.\n"
argument_list|,
name|bufp
operator|->
name|allocated
argument_list|,
name|bufp
operator|->
name|used
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Allowed by fastmap: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bufp
operator|->
name|fastmap
index|[
name|i
index|]
condition|)
name|printchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nAllowed by translate: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|translate
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|BYTEWIDTH
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bufp
operator|->
name|translate
index|[
name|i
index|]
condition|)
name|printchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nfastmap is%s accurate\n"
argument_list|,
name|bufp
operator|->
name|fastmap_accurate
condition|?
literal|""
else|:
literal|"n't"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"can %s be null\n----------"
argument_list|,
name|bufp
operator|->
name|can_be_null
condition|?
literal|""
else|:
literal|"not"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTDEF */
end_comment

begin_macro
name|printchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|<
literal|040
operator|||
name|c
operator|>=
literal|0177
condition|)
block|{
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|3
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|puts
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* test */
end_comment

end_unit

