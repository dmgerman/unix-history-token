begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985, 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that: (1) source distributions retain this entire copyright  * notice and comment, and (2) distributions including binaries display  * the following acknowledgement:  ``This product includes software  * developed by the University of California, Berkeley and its contributors''  * in the documentation or other materials provided with the distribution  * and in all advertising materials mentioning features or use of this  * software. Neither the name of the University nor the names of its  * contributors may be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/*  * Originally, this program came from Rutgers University, however it  * is based on nslookup and other pieces of named tools, so it needs  * that copyright notice.  */
end_comment

begin_comment
comment|/*  * Rewritten by Eric Wassenaar, Nikhef-H,<e07@nikhef.nl>  *  * The officially maintained source of this program is available  * via anonymous ftp from machine 'ftp.nikhef.nl' [192.16.199.1]  * in the directory '/pub/network' as 'host.tar.Z'  *  * You are kindly requested to report bugs and make suggestions  * for improvements to the author at the given email address,  * and to not re-distribute your own modifications to others.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Version
index|[]
init|=
literal|"@(#)host.c	e07@nikhef.nl (Eric Wassenaar) 930926"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|apollo
argument_list|)
operator|&&
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_define
define|#
directive|define
name|__attribute
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|justfun
end_define

begin_comment
comment|/* this is only for fun */
end_comment

begin_undef
undef|#
directive|undef
name|obsolete
end_undef

begin_comment
comment|/* old code left as a reminder */
end_comment

begin_undef
undef|#
directive|undef
name|notyet
end_undef

begin_comment
comment|/* new code for possible future use */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			New features  *  * - Major overhaul of the entire code.  * - Very rigid error checking, with more verbose error messages.  * - Zone listing section completely rewritten.  * - It is now possible to do recursive listings into delegated zones.  * - Maintain resource record statistics during zone listings.  * - Maintain count of hosts during zone listings.  * - Check for various extraneous conditions during zone listings.  * - Exploit multiple server addresses if available.  * - Option to exploit only primary server for zone transfers.  * - Option to exclude info from names that do not reside in a zone.  * - Implement timeout handling during connect and read.  * - Write resource record output to optional logfile.  * - Special MB tracing by recursively expanding MR and MG records.  * - Special mode to check SOA records at each nameserver for a zone.  * - Special mode to check reverse mappings of host addresses.  * - Extended syntax allows multiple arguments on command line or stdin.  * - Configurable default options in HOST_DEFAULTS environment variable.  * - Code is extensively documented.  */
end_comment

begin_comment
comment|/*  *			Publication history  *  * This information has been moved to the RELEASE_NOTES file.  */
end_comment

begin_comment
comment|/*  *			Compilation options  *  * This program usually compiles without special compilation options,  * but for some platforms you may have to define special settings.  * See the Makefile and the header file port.h for details.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			Miscellaneous notes  *  * This program should be linked explicitly with the BIND resolver library  * in case the default gethostbyname() or gethostbyaddr() routines use a  * non-standard strategy for retrieving information. These functions in the  * resolver library call on the nameserver, and fall back on the hosts file  * only if no nameserver is running (ECONNREFUSED).  *  * You may also want to link this program with the BIND resolver library if  * your default library has not been compiled with DEBUG printout enabled.  *  * The version of the resolver should be BIND 4.8.2 or later. The crucial  * include files are<netdb.h>, (resolv.h>,<arpa/nameser.h>. These files  * are assumed to be present in the /usr/include directory.  *  * The resolver code depends on the definition of the BSD pre-processor  * variable. This variable is usually defined in the file<sys/param.h>.  *  * The definition of this variable determines the method how to handle  * datagram connections. This may not work properly on all platforms.  *  * The hostent struct defined in<netdb.h> is assumed to handle multiple  * addresses in h_addr_list[]. Usually this is true if BSD>= 43.  *  * Your version of the nameserver may not handle queries about top-level  * zones properly. It needs a patch if it appends the default domain  * to single names for which it has no data cached. A fix for this is  * available.  *  * The treatment of TXT records has changed from 4.8.2 to 4.8.3. Formerly,  * the data consisted simply of the text string. Now, the text string is  * preceded by the character count with a maximum of 255, and multiple  * strings are embedded if the total character count exceeds 255.  * We handle only the new situation in this program, assuming that nobody  * uses TXT records before 4.8.3 (unfortunately this is not always true:  * current vendor supplied software may sometimes be even pre-BIND 4.8.2).  *  * Note that in 4.8.3 PACKETSZ from nameser.h is still at 512, which is  * the maximum possible packet size for datagrams, whereas MAXDATA from  * db.h has increased from 256 to 2048. The resolver defines MAXPACKET  * as 1024. The nameserver reads queries in a buffer of size BUFSIZ.  *  * The gethostbyname() routine in 4.8.3 interprets dotted quads (if not  * terminated with a dot) and simulates a gethostbyaddr(), but we will  * not rely on it, and handle dotted quads ourselves.  *  * On some systems a bug in the _doprnt() routine exists which prevents  * printf("%.*s", n, string) to be printed correctly if n == 0.  *  * This program has not been optimized for speed. Especially the memory  * management is simple and straightforward.  */
end_comment

begin_comment
comment|/*  *			Terminology used  *  * Gateway hosts.  * These are hosts that have more than one address registered under  * the same name. Obviously we cannot recognize a gateway host if it  * has different names associated with its different addresses.  *  * Duplicate hosts.  * These are non-gateway hosts of which the address was found earlier  * but with a different name, possibly in a totally different zone.  * Such hosts should not be counted again in the overall host count.  * This situation notably occurs in e.g. the "ac.uk" domain which has  * many names registered in both the long and the abbreviated form,  * such as 'host.department.university.ac.uk' and 'host.dept.un.ac.uk'.  * This is probably not an error per se. It is an error if some domain  * has registered a foreign address under a name within its own domain.  * To recognize duplicate hosts when traversing many zones, we have to  * maintain a global list of host addresses. To simplify things, only  * single-address hosts are handled as such.  *  * Extrazone hosts.  * These are hosts which belong to a zone but which are not residing  * directly within the zone under consideration and which are not  * glue records for a delegated zone of the given zone. E.g. if we are  * processing the zone 'bar' and find 'host.foo.bar' but 'foo.bar' is not  * an NS registered delegated zone of 'bar' then it is considered to be  * an extrazone host. This is not necessarily an error, but it could be.  *  * Lame delegations.  * If we query the SOA record of a zone at a supposedly authoritative  * nameserver for that zone (listed in the NS records for the zone),  * the SOA record should be present and the answer authoritative.  * If not, we flag a lame delegation of the zone to that nameserver.  * This may need refinement in some special cases.  * A lame delegation is also flagged if we discover that a nameserver  * mentioned in an NS record does not exist when looking up its address.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *		Usage: host [options] name [server]  *		Usage: host [options] -x [name ...]  *		Usage: host [options] -X server [name ...]  *  * Regular command line options:  * ----------------------------  *  * -t type	specify query type; default is T_A for normal mode  *  * -a		specify query type T_ANY  *  * -v		print verbose messages (-vv is very verbose)  *  * -d		print debugging output (-dd prints even more)  *  * Special mode options.  * --------------------  *  * -l		special mode to generate zone listing for a zone  *  * -L level	do recursive zone listing/checking this level deep  *  * -p		use primary nameserver of zone for zone transfers  *  * -S		print zone resource record statistics  *  * -H		special mode to count hosts residing in a zone  *  * -G		same as -H but lists gateway hosts in addition  *  * -E		same as -H but lists extrazone hosts in addition  *  * -D		same as -H but lists duplicate hosts in addition  *  * -C		special mode to check SOA records for a zone  *  * -A		special mode to check reverse mappings of host addresses  *  * Miscellaneous options.  * ---------------------  *  * -e		exclude info from names that do not reside in the zone  *  * -f file	log resource record output also in given file  *  * -F file	same as -f, but exchange role of stdout and logfile  *  * -i		generate reverse in-addr.arpa query for dotted quad  *  * -q		be quiet about some non-fatal errors  *  * -T		print ttl value or MX pref during non-verbose output  *  * Seldom used options.  * -------------------  *  * -c class	specify query class; default is C_IN  *  * -m		specify query type T_MAILB and trace MB records  *  * -o		suppress resource record output to stdout  *  * -r		do not use recursion when querying nameserver  *  * -R		repeatedly add search domains to qualify queryname  *  * -s secs	specify timeout value in seconds; default is 2 * 5  *  * -u		use virtual circuit instead of datagram for queries  *  * -w		wait until nameserver becomes available  *  * Undocumented options. (Experimental, subject to change)  * --------------------  *  * -g length	only select names that are at least this long  *  * -B		enforce full BIND behaviour during DNSRCH  *  * -I chars	print illegal resource record names, but allow chars  *  * -M		special mode to list mailable delegated zones of zone  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Usage
index|[]
init|=
literal|"\ Usage:      host [-v] [-a] [-t querytype] [options]  name  [server]\n\ Listing:    host [-v] [-a] [-t querytype] [options]  -l zone  [server]\n\ Hostcount:  host [-v] [options] -H [-D] [-E] [-G] zone\n\ Check soa:  host [-v] [options] -C zone\n\ Addrcheck:  host [-v] [options] -A host\n\ List options:    [-L level] [-S] [-p]\n\ Common options:  [-d] [-e] [-f logfile] [-F logfile] [-i] [-q] [-T]\n\ Other options:   [-c class] [-m] [-o] [-r] [-R] [-s secs] [-u] [-w]\n\ Extended usage:  [-x [name ...]] [-X server [name ...]]\ "
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* not always automatically included */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_undef
undef|#
directive|undef
name|NOERROR
end_undef

begin_comment
comment|/* in<sys/streams.h> on solaris 2.x */
end_comment

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"type.h"
end_include

begin_comment
comment|/* types should be in<arpa/nameser.h> */
end_comment

begin_include
include|#
directive|include
file|"exit.h"
end_include

begin_comment
comment|/* exit codes come from<sysexits.h> */
end_comment

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_comment
comment|/* various portability definitions */
end_comment

begin_define
define|#
directive|define
name|input
end_define

begin_comment
comment|/* read-only input parameter */
end_comment

begin_define
define|#
directive|define
name|output
end_define

begin_comment
comment|/* modified output parameter */
end_comment

begin_typedef
typedef|typedef
name|int
name|bool
typedef|;
end_typedef

begin_comment
comment|/* boolean type */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DATA
end_ifndef

begin_define
define|#
directive|define
name|NO_DATA
value|NO_ADDRESS
end_define

begin_comment
comment|/* used here only in case authoritative */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NO_RREC
value|(NO_DATA + 1)
end_define

begin_comment
comment|/* used for non-authoritative NO_DATA */
end_comment

begin_define
define|#
directive|define
name|NO_HOST
value|(NO_DATA + 2)
end_define

begin_comment
comment|/* used for non-authoritative HOST_NOT_FOUND */
end_comment

begin_define
define|#
directive|define
name|T_NONE
value|0
end_define

begin_comment
comment|/* yet unspecified resource record type */
end_comment

begin_define
define|#
directive|define
name|T_FIRST
value|T_A
end_define

begin_comment
comment|/* first possible type in resource record */
end_comment

begin_define
define|#
directive|define
name|T_LAST
value|(T_AXFR - 1)
end_define

begin_comment
comment|/* last  possible type in resource record */
end_comment

begin_define
define|#
directive|define
name|MAXADDRS
value|35
end_define

begin_comment
comment|/* max address count from gethostnamadr.c */
end_comment

begin_define
define|#
directive|define
name|NOT_DOTTED_QUAD
value|((ipaddr_t)-1)
end_define

begin_define
define|#
directive|define
name|LOCALHOST_ADDR
value|((ipaddr_t)0x7f000001)
end_define

begin_define
define|#
directive|define
name|is_space
parameter_list|(
name|c
parameter_list|)
value|(isascii(c)&& isspace(c))
end_define

begin_define
define|#
directive|define
name|is_alnum
parameter_list|(
name|c
parameter_list|)
value|(isascii(c)&& isalnum(c))
end_define

begin_define
define|#
directive|define
name|bitset
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)& (b)) != 0)
end_define

begin_define
define|#
directive|define
name|sameword
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcasecmp(a,b) == 0)
end_define

begin_define
define|#
directive|define
name|samepart
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strncasecmp(a,b,strlen(b)) == 0)
end_define

begin_define
define|#
directive|define
name|fakename
parameter_list|(
name|a
parameter_list|)
value|(samepart(a,"localhost.") || samepart(a,"loopback."))
end_define

begin_define
define|#
directive|define
name|fakeaddr
parameter_list|(
name|a
parameter_list|)
value|(((a) == 0) || ((a) == htonl(LOCALHOST_ADDR)))
end_define

begin_define
define|#
directive|define
name|incopy
parameter_list|(
name|a
parameter_list|)
value|*((struct in_addr *)a)
end_define

begin_define
define|#
directive|define
name|newlist
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|(t *)xalloc((ptr_t *)a, (siz_t)((n)*sizeof(t)))
end_define

begin_define
define|#
directive|define
name|newstring
parameter_list|(
name|a
parameter_list|)
value|(char *)xalloc((ptr_t *)NULL, (siz_t)(strlen(a)+1))
end_define

begin_define
define|#
directive|define
name|newstr
parameter_list|(
name|a
parameter_list|)
value|strcpy(newstring(a), a)
end_define

begin_define
define|#
directive|define
name|xfree
parameter_list|(
name|a
parameter_list|)
value|(void) free((ptr_t *)a)
end_define

begin_define
define|#
directive|define
name|strlength
parameter_list|(
name|a
parameter_list|)
value|(int)strlen(a)
end_define

begin_if
if|#
directive|if
name|PACKETSZ
operator|>
literal|1024
end_if

begin_define
define|#
directive|define
name|MAXPACKET
value|PACKETSZ
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXPACKET
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|header
decl_stmt|;
name|u_char
name|packet
index|[
name|MAXPACKET
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EXTERN
value|extern
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|EXTERN
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EXTERN
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in gethostnamadr.c */
end_comment

begin_decl_stmt
name|EXTERN
name|res_state_t
name|_res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in res_init.c */
end_comment

begin_decl_stmt
name|int
name|Errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global error count */
end_comment

begin_decl_stmt
name|int
name|record_stats
index|[
name|T_ANY
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of resource records per type */
end_comment

begin_decl_stmt
name|char
name|cnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name to which CNAME is aliased */
end_comment

begin_decl_stmt
name|char
name|mnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name to which MR or MG is aliased */
end_comment

begin_decl_stmt
name|char
name|soanamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|soaname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain name of SOA record */
end_comment

begin_decl_stmt
name|char
name|subnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|subname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain name of NS record */
end_comment

begin_decl_stmt
name|char
name|adrnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|adrname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain name of A record */
end_comment

begin_decl_stmt
name|ipaddr_t
name|address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internet address of A record */
end_comment

begin_decl_stmt
name|char
name|serverbuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|server
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of explicit server to query */
end_comment

begin_decl_stmt
name|char
name|realnamebuf
index|[
literal|2
operator|*
name|MAXDNAME
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|realname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the actual name that was queried */
end_comment

begin_decl_stmt
name|char
modifier|*
name|logfilename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of log file */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|logfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default is stdout only */
end_comment

begin_decl_stmt
name|bool
name|logexchange
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exchange role of logfile and stdout */
end_comment

begin_decl_stmt
name|char
modifier|*
name|illegal
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* give warning about illegal domain names */
end_comment

begin_decl_stmt
name|char
modifier|*
name|queryname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the name about which to query */
end_comment

begin_decl_stmt
name|int
name|querytype
init|=
name|T_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the type of the query */
end_comment

begin_decl_stmt
name|int
name|queryclass
init|=
name|C_IN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the class of the query */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print resolver debugging output */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbose mode for extra output */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|justfun
end_ifdef

begin_decl_stmt
name|int
name|namelen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* select records exceeding this length */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|recursive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recursive listmode maximum level */
end_comment

begin_decl_stmt
name|bool
name|quiet
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* suppress non-fatal warning messages */
end_comment

begin_decl_stmt
name|bool
name|reverse
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generate reverse in-addr.arpa queries */
end_comment

begin_decl_stmt
name|bool
name|primary
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use primary server for zone transfers */
end_comment

begin_decl_stmt
name|bool
name|suppress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* suppress resource record output */
end_comment

begin_decl_stmt
name|bool
name|ttlprint
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print ttl value in non-verbose mode */
end_comment

begin_decl_stmt
name|bool
name|waitmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait until server becomes available */
end_comment

begin_decl_stmt
name|bool
name|mailmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace MG and MR into MB records */
end_comment

begin_decl_stmt
name|bool
name|addrmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check reverse mappings of addresses */
end_comment

begin_decl_stmt
name|bool
name|listmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generate zone listing of a zone */
end_comment

begin_decl_stmt
name|bool
name|hostmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count real hosts residing within zone */
end_comment

begin_decl_stmt
name|bool
name|duplmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list duplicate hosts within zone */
end_comment

begin_decl_stmt
name|bool
name|extrmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list extrazone hosts within zone */
end_comment

begin_decl_stmt
name|bool
name|gatemode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list gateway hosts within zone */
end_comment

begin_decl_stmt
name|bool
name|checkmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check SOA records at each nameserver */
end_comment

begin_decl_stmt
name|bool
name|mxrecmode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list MX records for each delegated zone */
end_comment

begin_decl_stmt
name|bool
name|exclusive
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exclude records that are not in zone */
end_comment

begin_decl_stmt
name|bool
name|statistics
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print resource record statistics */
end_comment

begin_decl_stmt
name|bool
name|bindcompat
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enforce full BIND DNSRCH compatibility */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|optargv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argument list including default options */
end_comment

begin_decl_stmt
name|int
name|optargc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of arguments in new argument list */
end_comment

begin_comment
comment|/* extern */
end_comment

begin_decl_stmt
name|ipaddr_t
name|inet_addr
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inet_ntoa
name|PROTO
argument_list|(
operator|(
expr|struct
name|in_addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostalias
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|getenv
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strcpy
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rindex
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|index
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ptr_t
modifier|*
name|malloc
name|PROTO
argument_list|(
operator|(
name|siz_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ptr_t
modifier|*
name|realloc
name|PROTO
argument_list|(
operator|(
name|ptr_t
operator|*
operator|,
name|siz_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|exit
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* main.c */
end_comment

begin_decl_stmt
name|int
decl|main
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_defaults
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|process_argv
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|process_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|process_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|execute_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|execute
name|PROTO
argument_list|(
operator|(
name|ipaddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_server
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|errmsg
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* info.c */
end_comment

begin_decl_stmt
name|bool
name|get_hostinfo
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|get_domaininfo
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_info
name|PROTO
argument_list|(
operator|(
name|querybuf
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|print_info
name|PROTO
argument_list|(
operator|(
name|querybuf
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|doprintf
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|print_rrec
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|skip_qrec
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list.c */
end_comment

begin_decl_stmt
name|bool
name|list_zone
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|find_servers
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|get_servers
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|get_nsinfo
name|PROTO
argument_list|(
operator|(
name|querybuf
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|transfer_zone
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|in_addr
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|get_zone
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|in_addr
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|get_mxrec
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|get_primary
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|check_zone
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|get_soainfo
name|PROTO
argument_list|(
operator|(
name|querybuf
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|check_soa
name|PROTO
argument_list|(
operator|(
name|querybuf
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|check_dupl
name|PROTO
argument_list|(
operator|(
name|ipaddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addr.c */
end_comment

begin_decl_stmt
name|bool
name|check_addr
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|check_name
name|PROTO
argument_list|(
operator|(
name|ipaddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* util.c */
end_comment

begin_decl_stmt
name|int
name|parse_type
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|parse_class
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|in_addr_arpa
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_host
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|hostent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|show_res
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_statistics
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|clear_statistics
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|show_types
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ns_error
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|decode_error
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_status
name|PROTO
argument_list|(
operator|(
name|querybuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pr_error
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pr_warning
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|want_type
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|want_class
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|indomain
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|samedomain
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|gluerecord
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pr_dotname
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pr_type
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pr_class
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expand_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check_size
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|valid_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* misc.c */
end_comment

begin_decl_stmt
name|ptr_t
modifier|*
name|xalloc
name|PROTO
argument_list|(
operator|(
name|ptr_t
operator|*
operator|,
name|siz_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|itoa
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stoa
name|PROTO
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send.c */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_RES_SEND
end_ifdef

begin_decl_stmt
name|int
name|res_send
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*HOST_RES_SEND*/
end_comment

begin_decl_stmt
name|int
name|_res_connect
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|sockaddr_in
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_res_write
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_res_read
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_res_setaddr
name|PROTO
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_res_perror
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vers.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|condition
parameter_list|)
define|\
value|{\ 	if (!(condition))\ 	{\ 		(void) fprintf(stderr, "assertion botch: ");\ 		(void) fprintf(stderr, "%s(%d): ", __FILE__, __LINE__);\ 		(void) fprintf(stderr, "%s\n", "condition");\ 		exit(EX_SOFTWARE);\ 	}\ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|condition
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* ** MAIN -- Start of program host ** ----------------------------- ** **	Exits: **		EX_OK		Operation successfully completed **		EX_UNAVAILABLE	Could not obtain requested information **		EX_CANTCREAT	Could not create specified logfile **		EX_NOINPUT	No input arguments were found **		EX_NOHOST	Could not lookup explicit server **		EX_OSERR	Could not obtain resources **		EX_USAGE	Improper parameter/option specified **		EX_SOFTWARE	Assertion botch in DEBUG mode */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|input
name|int
name|argc
decl_stmt|;
name|input
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|option
decl_stmt|;
name|res_state_t
name|new_res
decl_stmt|;
comment|/* new resolver database */
name|int
name|result
decl_stmt|;
comment|/* result status of action taken */
name|char
modifier|*
name|program
decl_stmt|;
comment|/* name that host was called with */
name|char
modifier|*
name|servername
init|=
name|NULL
decl_stmt|;
comment|/* name of explicit server */
name|bool
name|extended
init|=
name|FALSE
decl_stmt|;
comment|/* accept extended argument syntax */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
comment|/* paranoid */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* paranoid */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|ipaddr_t
argument_list|)
operator|==
literal|4
argument_list|)
expr_stmt|;
comment|/* but this is critical */
comment|/*  * Synchronize stdout and stderr in case output is redirected.  */
name|linebufmode
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/*  * Initialize resolver. See show_res() for details.  * Pickup current values and set new defaults.  * Query for optional server is also done with new defaults.  * Old defaults are (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)  */
operator|(
name|void
operator|)
name|res_init
argument_list|()
expr_stmt|;
comment|/* we handle default domains ourselves, thank you */
name|_res
operator|.
name|options
operator||=
name|RES_DEFNAMES
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DNSRCH
expr_stmt|;
name|_res
operator|.
name|options
operator||=
name|RES_RECURSE
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_USEVC
expr_stmt|;
name|_res
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
comment|/* number  of retries, default = 4 */
name|_res
operator|.
name|retrans
operator|=
literal|5
expr_stmt|;
comment|/* timeout in seconds, default = 5 or 6 */
comment|/* save new defaults */
name|new_res
operator|=
name|_res
expr_stmt|;
comment|/*  * Check if host was called with a different name.  * Interpolate default options and parameters.  */
name|option
operator|=
name|getenv
argument_list|(
literal|"HOST_DEFAULTS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|!=
name|NULL
condition|)
block|{
name|set_defaults
argument_list|(
name|option
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|=
name|optargc
expr_stmt|;
name|argv
operator|=
name|optargv
expr_stmt|;
block|}
name|program
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|program
operator|++
operator|==
name|NULL
condition|)
name|program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* check for resource record names */
name|querytype
operator|=
name|parse_type
argument_list|(
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
name|querytype
operator|<
literal|0
condition|)
name|querytype
operator|=
name|T_NONE
expr_stmt|;
comment|/* check for zone listing abbreviation */
if|if
condition|(
name|sameword
argument_list|(
name|program
argument_list|,
literal|"zone"
argument_list|)
condition|)
name|listmode
operator|=
name|TRUE
expr_stmt|;
comment|/*  * Scan command line options and flags.  */
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|option
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
init|;
operator|*
name|option
operator|!=
literal|'\0'
condition|;
name|option
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|option
condition|)
block|{
case|case
literal|'w'
case|:
name|waitmode
operator|=
name|TRUE
expr_stmt|;
name|new_res
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
name|new_res
operator|.
name|retrans
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Missing timeout value"
argument_list|)
expr_stmt|;
name|new_res
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
name|new_res
operator|.
name|retrans
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_res
operator|.
name|retrans
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid timeout value %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|new_res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|bindcompat
operator|=
name|TRUE
expr_stmt|;
comment|/* fall through */
case|case
literal|'R'
case|:
name|new_res
operator|.
name|options
operator||=
name|RES_DNSRCH
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|new_res
operator|.
name|options
operator||=
name|RES_USEVC
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|new_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
name|debug
operator|++
expr_stmt|;
comment|/* increment debugging level */
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
comment|/* increment verbosity level */
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|reverse
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|primary
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|suppress
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|exclusive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|statistics
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ttlprint
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|addrmode
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'G'
case|:
if|if
condition|(
operator|*
name|option
operator|==
literal|'D'
condition|)
name|duplmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|option
operator|==
literal|'E'
condition|)
name|extrmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|option
operator|==
literal|'G'
condition|)
name|gatemode
operator|=
name|TRUE
expr_stmt|;
comment|/* fall through */
case|case
literal|'H'
case|:
name|hostmode
operator|=
name|TRUE
expr_stmt|;
name|listmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|querytype
operator|==
name|T_NONE
condition|)
name|querytype
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* suppress zone data output */
break|break;
case|case
literal|'C'
case|:
name|checkmode
operator|=
name|TRUE
expr_stmt|;
name|listmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|querytype
operator|==
name|T_NONE
condition|)
name|querytype
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* suppress zone data output */
break|break;
case|case
literal|'M'
case|:
name|mxrecmode
operator|=
name|TRUE
expr_stmt|;
name|listmode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|querytype
operator|==
name|T_NONE
condition|)
name|querytype
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* suppress zone data output */
break|break;
case|case
literal|'l'
case|:
name|listmode
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Missing recursion level"
argument_list|)
expr_stmt|;
name|recursive
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid recursion level %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|logexchange
operator|=
name|TRUE
expr_stmt|;
comment|/* fall through */
case|case
literal|'f'
case|:
if|if
condition|(
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Missing logfile name"
argument_list|)
expr_stmt|;
name|logfilename
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Missing allowed chars"
argument_list|)
expr_stmt|;
name|illegal
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Missing query class"
argument_list|)
expr_stmt|;
name|queryclass
operator|=
name|parse_class
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryclass
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid query class %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Missing query type"
argument_list|)
expr_stmt|;
name|querytype
operator|=
name|parse_type
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|querytype
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid query type %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|querytype
operator|=
name|T_ANY
expr_stmt|;
comment|/* filter anything available */
break|break;
case|case
literal|'m'
case|:
name|mailmode
operator|=
name|TRUE
expr_stmt|;
name|querytype
operator|=
name|T_MAILB
expr_stmt|;
comment|/* filter MINFO/MG/MR/MB data */
break|break;
ifdef|#
directive|ifdef
name|justfun
case|case
literal|'g'
case|:
if|if
condition|(
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Missing minimum length"
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Invalid minimum length %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'X'
case|:
if|if
condition|(
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Missing server name"
argument_list|)
expr_stmt|;
name|servername
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
comment|/* fall through */
case|case
literal|'x'
case|:
name|extended
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
default|default:
name|fatal
argument_list|(
name|Usage
argument_list|)
expr_stmt|;
block|}
block|}
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
comment|/*  * Check the remaining arguments.  */
comment|/* old syntax must have at least one argument */
if|if
condition|(
operator|!
name|extended
operator|&&
operator|(
name|argc
operator|<
literal|2
operator|||
name|argc
operator|>
literal|3
operator|)
condition|)
name|fatal
argument_list|(
name|Usage
argument_list|)
expr_stmt|;
comment|/* old syntax has explicit server as second argument */
if|if
condition|(
operator|!
name|extended
operator|&&
operator|(
name|argc
operator|>
literal|2
operator|)
condition|)
name|servername
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
comment|/*  * Open log file if requested.  * Exchange role of stdout and logfile if so specified.  */
if|if
condition|(
name|logfilename
operator|!=
name|NULL
condition|)
block|{
name|logfile
operator|=
name|fopen
argument_list|(
name|logfilename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|logfilename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logexchange
condition|)
block|{
ifdef|#
directive|ifdef
name|SWAPFILE_HACK
name|swapfile
argument_list|(
name|logfile
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Option -F not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*  * Check for possible alternative server.  */
if|if
condition|(
name|servername
operator|!=
name|NULL
condition|)
name|set_server
argument_list|(
name|servername
argument_list|)
expr_stmt|;
comment|/* set new resolver values changed by command options */
name|_res
operator|.
name|retry
operator|=
name|new_res
operator|.
name|retry
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|new_res
operator|.
name|retrans
expr_stmt|;
name|_res
operator|.
name|options
operator|=
name|new_res
operator|.
name|options
expr_stmt|;
comment|/* show the new resolver database */
if|if
condition|(
name|debug
operator|>
literal|1
operator|||
name|verbose
operator|>
literal|1
condition|)
name|show_res
argument_list|()
expr_stmt|;
comment|/* show customized default domain */
name|option
operator|=
name|getenv
argument_list|(
literal|"LOCALDOMAIN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|!=
name|NULL
operator|&&
name|verbose
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"Explicit local domain %s\n\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
comment|/*  * Process command line argument(s) depending on syntax.  */
if|if
condition|(
operator|!
name|extended
condition|)
comment|/* only one argument */
name|result
operator|=
name|process_name
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
comment|/* no arguments */
name|result
operator|=
name|process_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
comment|/* multiple command line arguments */
name|result
operator|=
name|process_argv
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** SET_DEFAULTS -- Interpolate default options and parameters in argv ** ------------------------------------------------------------------ ** **	Returns: **		None. ** **	Outputs: **		Creates new optargv vector with optargc arguments. */
end_comment

begin_function
name|void
name|set_defaults
parameter_list|(
name|option
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|input
name|char
modifier|*
name|option
decl_stmt|;
comment|/* option string */
name|input
name|int
name|argc
decl_stmt|;
name|input
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/*  * Allocate new argument vector.  */
name|optargv
operator|=
name|newlist
argument_list|(
name|NULL
argument_list|,
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|optargv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|optargc
operator|=
literal|1
expr_stmt|;
comment|/*  * Construct argument list from option string.  */
for|for
control|(
name|p
operator|=
name|newstr
argument_list|(
name|option
argument_list|)
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|=
name|q
control|)
block|{
while|while
condition|(
name|is_space
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
operator|!
name|is_space
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|q
operator|!=
literal|'\0'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|optargv
operator|=
name|newlist
argument_list|(
name|optargv
argument_list|,
name|optargc
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|optargv
index|[
name|optargc
index|]
operator|=
name|p
expr_stmt|;
name|optargc
operator|++
expr_stmt|;
block|}
comment|/*  * Append command line arguments.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|optargv
operator|=
name|newlist
argument_list|(
name|optargv
argument_list|,
name|optargc
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|optargv
index|[
name|optargc
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|optargc
operator|++
expr_stmt|;
block|}
comment|/* and terminate */
name|optargv
index|[
name|optargc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PROCESS_ARGV -- Process command line arguments ** ---------------------------------------------- ** **	Returns: **		EX_OK if information was obtained successfully. **		Appropriate exit code otherwise. */
end_comment

begin_function
name|int
name|process_argv
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|input
name|int
name|argc
decl_stmt|;
name|input
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* result status of action taken */
name|int
name|excode
init|=
name|EX_NOINPUT
decl_stmt|;
comment|/* overall result status */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* process a single argument */
name|result
operator|=
name|process_name
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* maintain overall result */
if|if
condition|(
name|result
operator|!=
name|EX_OK
operator|||
name|excode
operator|==
name|EX_NOINPUT
condition|)
name|excode
operator|=
name|result
expr_stmt|;
block|}
comment|/* return overall result */
return|return
operator|(
name|excode
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PROCESS_FILE -- Process arguments from input file ** ------------------------------------------------- ** **	Returns: **		EX_OK if information was obtained successfully. **		Appropriate exit code otherwise. */
end_comment

begin_function
name|int
name|process_file
parameter_list|(
name|fp
parameter_list|)
name|input
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* input file with query names */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* result status of action taken */
name|int
name|excode
init|=
name|EX_NOINPUT
decl_stmt|;
comment|/* overall result status */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* extract names separated by whitespace */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|=
name|q
control|)
block|{
while|while
condition|(
name|is_space
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* ignore comment lines */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'#'
operator|||
operator|*
name|p
operator|==
literal|';'
condition|)
break|break;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
operator|!
name|is_space
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|q
operator|!=
literal|'\0'
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* process a single argument */
name|result
operator|=
name|process_name
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* maintain overall result */
if|if
condition|(
name|result
operator|!=
name|EX_OK
operator|||
name|excode
operator|==
name|EX_NOINPUT
condition|)
name|excode
operator|=
name|result
expr_stmt|;
block|}
block|}
comment|/* return overall result */
return|return
operator|(
name|excode
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PROCESS_NAME -- Process a single command line argument ** ------------------------------------------------------ ** **	Returns: **		EX_OK if information was obtained successfully. **		Appropriate exit code otherwise. ** **	Wrapper for execute_name() to hide administrative tasks. */
end_comment

begin_function
name|int
name|process_name
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* command line argument */
block|{
name|int
name|result
decl_stmt|;
comment|/* result status of action taken */
specifier|static
name|int
name|save_querytype
decl_stmt|;
specifier|static
name|bool
name|save_reverse
decl_stmt|;
specifier|static
name|bool
name|firstname
init|=
name|TRUE
decl_stmt|;
comment|/* separate subsequent pieces of output */
if|if
condition|(
operator|!
name|firstname
operator|&&
operator|(
name|verbose
operator|||
name|debug
operator|||
name|checkmode
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*  * Some global variables are redefined further on. Save their initial  * values in the first pass, and restore them during subsequent passes.  */
if|if
condition|(
name|firstname
condition|)
block|{
name|save_querytype
operator|=
name|querytype
expr_stmt|;
name|save_reverse
operator|=
name|reverse
expr_stmt|;
name|firstname
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|querytype
operator|=
name|save_querytype
expr_stmt|;
name|reverse
operator|=
name|save_reverse
expr_stmt|;
block|}
comment|/*  * Do the real work.  */
name|result
operator|=
name|execute_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** EXECUTE_NAME -- Process a single command line argument ** ------------------------------------------------------ ** **	Returns: **		EX_OK if information was obtained successfully. **		Appropriate exit code otherwise. ** **	Outputs: **		Defines queryname appropriately. ** **	Side effects: **		May redefine querytype and reverse if necessary. */
end_comment

begin_function
name|int
name|execute_name
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* command line argument */
block|{
name|ipaddr_t
name|addr
decl_stmt|;
comment|/* explicit address of query */
name|bool
name|result
decl_stmt|;
comment|/* result status of action taken */
comment|/* check for nonsense input name */
if|if
condition|(
name|strlength
argument_list|(
name|name
argument_list|)
operator|>
name|MAXDNAME
condition|)
block|{
name|errmsg
argument_list|(
literal|"Query name %s too long"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
comment|/*  * Analyze name and type to be queried about.  * In regular mode, the querytype is used to formulate the nameserver  * query, and any response is filtered out when processing the answer.  * In listmode, the querytype is used to filter out the proper records.  */
name|queryname
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|queryname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|queryname
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|queryname
argument_list|,
literal|"."
argument_list|)
condition|)
name|addr
operator|=
name|NOT_DOTTED_QUAD
expr_stmt|;
else|else
name|addr
operator|=
name|inet_addr
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
comment|/* invert dotted quad if so requested */
if|if
condition|(
operator|(
name|addr
operator|!=
name|NOT_DOTTED_QUAD
operator|)
operator|&&
name|reverse
condition|)
block|{
name|queryname
operator|=
name|in_addr_arpa
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryname
operator|==
name|NULL
condition|)
block|{
name|errmsg
argument_list|(
literal|"Invalid dotted quad %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
name|addr
operator|=
name|NOT_DOTTED_QUAD
expr_stmt|;
block|}
else|else
name|reverse
operator|=
name|FALSE
expr_stmt|;
comment|/* set querytype for regular mode if unspecified */
if|if
condition|(
operator|(
name|querytype
operator|==
name|T_NONE
operator|)
operator|&&
operator|!
name|listmode
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|!=
name|NOT_DOTTED_QUAD
operator|)
operator|||
name|reverse
condition|)
name|querytype
operator|=
name|T_PTR
expr_stmt|;
else|else
name|querytype
operator|=
name|T_A
expr_stmt|;
block|}
comment|/* cannot have dotted quad in listmode */
if|if
condition|(
name|listmode
operator|&&
operator|(
name|addr
operator|!=
name|NOT_DOTTED_QUAD
operator|)
condition|)
block|{
name|errmsg
argument_list|(
literal|"Invalid query name %s"
argument_list|,
name|queryname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
comment|/* must have regular name or dotted quad in addrmode */
if|if
condition|(
name|addrmode
operator|&&
name|reverse
condition|)
block|{
name|errmsg
argument_list|(
literal|"Invalid query name %s"
argument_list|,
name|queryname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
comment|/* show what we are going to query about */
if|if
condition|(
name|verbose
condition|)
name|show_types
argument_list|(
name|queryname
argument_list|,
name|querytype
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
comment|/*  * All set. Perform requested function.  */
name|result
operator|=
name|execute
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
condition|?
name|EX_OK
else|:
name|EX_UNAVAILABLE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** EXECUTE -- Perform the requested function ** ----------------------------------------- ** **	Returns: **		TRUE if information was obtained successfully. **		FALSE otherwise. ** **	The whole environment has been set up and checked. */
end_comment

begin_function
name|bool
name|execute
parameter_list|(
name|addr
parameter_list|)
name|input
name|ipaddr_t
name|addr
decl_stmt|;
comment|/* explicit address of query */
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
name|newnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|NULL
decl_stmt|;
comment|/* name to which CNAME is aliased */
name|int
name|ncnames
init|=
literal|0
decl_stmt|;
comment|/* count of CNAMEs in chain */
name|bool
name|result
decl_stmt|;
comment|/* result status of action taken */
comment|/*  * Special mode to check reverse mappings of host addresses.  */
if|if
condition|(
name|addrmode
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|NOT_DOTTED_QUAD
condition|)
name|result
operator|=
name|check_addr
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|check_name
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Special mode to list contents of specified zone.  */
if|if
condition|(
name|listmode
condition|)
block|{
name|result
operator|=
name|list_zone
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Regular mode to query about specified host.  */
name|result
operator|=
name|FALSE
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
comment|/* retry until positive result or permanent failure */
while|while
condition|(
name|result
operator|==
name|FALSE
operator|&&
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
block|{
comment|/* reset before each query */
name|realname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NOT_DOTTED_QUAD
condition|)
block|{
comment|/* reset CNAME indicator */
name|cname
operator|=
name|NULL
expr_stmt|;
comment|/* lookup the name in question */
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
name|result
operator|=
name|get_hostinfo
argument_list|(
name|queryname
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|get_hostinfo
argument_list|(
name|newname
argument_list|)
expr_stmt|;
comment|/* recurse on CNAMEs, but not too deep */
if|if
condition|(
name|cname
operator|&&
operator|(
name|querytype
operator|!=
name|T_CNAME
operator|)
condition|)
block|{
name|newname
operator|=
name|strcpy
argument_list|(
name|newnamebuf
argument_list|,
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ncnames
operator|>
literal|5
condition|)
block|{
name|errmsg
argument_list|(
literal|"Possible CNAME loop"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|result
operator|=
name|FALSE
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|print_host
argument_list|(
literal|"Name"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* only retry if so requested */
if|if
condition|(
operator|!
name|waitmode
condition|)
break|break;
block|}
comment|/* use actual name if available */
if|if
condition|(
name|realname
operator|!=
name|NULL
condition|)
name|queryname
operator|=
name|realname
expr_stmt|;
comment|/* explain the reason of a failure */
if|if
condition|(
name|result
operator|==
name|FALSE
condition|)
name|ns_error
argument_list|(
name|queryname
argument_list|,
name|querytype
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** SET_SERVER -- Override default nameserver with explicit server ** -------------------------------------------------------------- ** **	Returns: **		None. **		Aborts the program if an unknown host was given. ** **	Side effects: **		The global variable server is set to indicate **		that an explicit server is being used. ** **	The default nameserver addresses in the resolver database **	which are initialized by res_init() from /etc/resolv.conf **	are replaced with the (possibly multiple) addresses of an **	explicitly named server host. If a dotted quad is given, **	only that single address will be used. */
end_comment

begin_function
name|void
name|set_server
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of server to be queried */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|ipaddr_t
name|addr
decl_stmt|;
comment|/* explicit address of server */
comment|/* check for nonsense input name */
if|if
condition|(
name|strlength
argument_list|(
name|name
argument_list|)
operator|>
name|MAXDNAME
condition|)
block|{
name|errmsg
argument_list|(
literal|"Server name %s too long"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|inet_addr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|inaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NOT_DOTTED_QUAD
condition|)
block|{
comment|/* lookup all of its addresses; this must not fail */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_A
argument_list|,
name|C_IN
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|"Error in looking up server name"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOHOST
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNS
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_addr
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|_res
operator|.
name|nscount
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
comment|/* lookup the name, but use only the given address */
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|nslist
argument_list|(
literal|0
argument_list|)
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nslist
argument_list|(
literal|0
argument_list|)
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|nslist
argument_list|(
literal|0
argument_list|)
operator|.
name|sin_addr
operator|=
name|inaddr
expr_stmt|;
name|_res
operator|.
name|nscount
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|server
operator|=
name|strcpy
argument_list|(
name|serverbuf
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|print_host
argument_list|(
literal|"Server"
argument_list|,
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|server
operator|=
name|strcpy
argument_list|(
name|serverbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Server: %s\n\n"
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** FATAL -- Abort program when illegal option encountered ** ------------------------------------------------------ ** **	Returns: **		Aborts after issuing error message. */
end_comment

begin_function
name|void
comment|/*VARARGS1*/
name|fatal
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
name|input
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_function

begin_comment
comment|/* optional arguments */
end_comment

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** ERRMSG -- Issue error message to error output ** --------------------------------------------- ** **	Returns: **		None. ** **	Side effects: **		Increments the global error count. */
end_comment

begin_function
name|void
comment|/*VARARGS1*/
name|errmsg
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
name|input
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_function

begin_comment
comment|/* optional arguments */
end_comment

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* flag an error */
name|Errors
operator|++
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** GET_HOSTINFO -- Principal routine to query about given name ** ----------------------------------------------------------- ** **	Returns: **		TRUE if requested info was obtained successfully. **		FALSE otherwise. ** **	This is the equivalent of the resolver module res_search(). ** **	In this program RES_DEFNAMES is always on, and RES_DNSRCH **	is off by default. This means that single names without dot **	are always, and only, tried within the own default domain, **	and compound names are assumed to be already fully qualified. ** **	The default BIND behaviour can be simulated by turning on **	RES_DNSRCH with -R. The given name, whether or not compound, **	is then	first tried within the possible search domains. ** **	Note. In the latter case, the search terminates in case the **	specified name exists but does not have the desired type. **	The BIND behaviour is to continue the search. This can be **	simulated with the undocumented option -B. */
end_comment

begin_function
name|bool
name|get_hostinfo
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name to query about */
block|{
specifier|register
name|char
modifier|*
modifier|*
name|domain
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|dot
decl_stmt|;
comment|/* number of dots in query name */
name|bool
name|result
decl_stmt|;
comment|/* result status of action taken */
name|char
name|oldnamebuf
index|[
literal|2
operator|*
name|MAXDNAME
operator|+
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
comment|/* saved actual name when NO_DATA */
name|int
name|nodata
init|=
literal|0
decl_stmt|;
comment|/* NO_DATA status during DNSRCH */
name|int
name|nquery
init|=
literal|0
decl_stmt|;
comment|/* number of extra search queries */
comment|/*  * Single dot means root zone.  */
if|if
condition|(
name|sameword
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|result
operator|=
name|get_domaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Count number of dots. Move to the end of the name.  */
for|for
control|(
name|dot
operator|=
literal|0
operator|,
name|cp
operator|=
name|name
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
name|dot
operator|++
expr_stmt|;
comment|/*  * Check for aliases of single name.  * Note that the alias is supposed to be fully qualified.  */
if|if
condition|(
name|dot
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|hostalias
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Aliased to \"%s\"\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_domaininfo
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Trailing dot means absolute (fully qualified) address.  */
if|if
condition|(
name|dot
operator|!=
literal|0
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|get_domaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*  * Append own default domain and other search domains if appropriate.  */
if|if
condition|(
operator|(
name|dot
operator|==
literal|0
operator|&&
name|bitset
argument_list|(
name|RES_DEFNAMES
argument_list|,
name|_res
operator|.
name|options
argument_list|)
operator|)
operator|||
operator|(
name|dot
operator|!=
literal|0
operator|&&
name|bitset
argument_list|(
name|RES_DNSRCH
argument_list|,
name|_res
operator|.
name|options
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|domain
operator|=
name|_res
operator|.
name|dnsrch
init|;
operator|*
name|domain
condition|;
name|domain
operator|++
control|)
block|{
name|result
operator|=
name|get_domaininfo
argument_list|(
name|name
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* keep count of extra search queries */
name|nquery
operator|++
expr_stmt|;
comment|/* in case nameserver not present */
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if no further search desired (single name) */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DNSRCH
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
break|break;
comment|/* if name exists but has not requested type */
if|if
condition|(
name|h_errno
operator|==
name|NO_DATA
operator|||
name|h_errno
operator|==
name|NO_RREC
condition|)
block|{
if|if
condition|(
name|bindcompat
condition|)
block|{
comment|/* remember status and search up */
name|oldname
operator|=
name|strcpy
argument_list|(
name|oldnamebuf
argument_list|,
name|realname
argument_list|)
expr_stmt|;
name|nodata
operator|=
name|h_errno
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* retry only if name does not exist at all */
if|if
condition|(
name|h_errno
operator|!=
name|HOST_NOT_FOUND
operator|&&
name|h_errno
operator|!=
name|NO_HOST
condition|)
break|break;
block|}
block|}
comment|/*  * Single name lookup failed.  */
if|if
condition|(
name|dot
operator|==
literal|0
condition|)
block|{
comment|/* unclear what actual name should be */
if|if
condition|(
name|nquery
operator|!=
literal|1
condition|)
name|realname
operator|=
name|NULL
expr_stmt|;
comment|/* restore nodata status from search */
if|if
condition|(
name|bindcompat
operator|&&
name|nodata
condition|)
block|{
name|realname
operator|=
name|strcpy
argument_list|(
name|realnamebuf
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|nodata
expr_stmt|;
block|}
comment|/* set status in case we never queried */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DEFNAMES
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|h_errno
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Rest means fully qualified.  */
name|result
operator|=
name|get_domaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* restore nodata status from search */
if|if
condition|(
operator|!
name|result
operator|&&
name|bindcompat
operator|&&
name|nodata
condition|)
block|{
name|realname
operator|=
name|strcpy
argument_list|(
name|realnamebuf
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|nodata
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_DOMAININFO -- Fetch and print desired info about name in domain ** ------------------------------------------------------------------- ** **	Returns: **		TRUE if requested info was obtained successfully. **		FALSE otherwise. ** **	Side effects: **		Sets global variable realname to actual name queried. ** **	This is the equivalent of the resolver module res_querydomain(). ** **	Things get a little complicated in case RES_DNSRCH is on. **	If we get an answer but the data is corrupted, an error will be **	returned and NO_RECOVERY will be set. This will terminate the **	extra search loop, but a compound name will still be tried as-is. **	The same holds if the query times out or we have a server failure, **	in which case an error will be returned and TRY_AGAIN will be set. **	For now we take this for granted. Normally RES_DNSRCH is disabled. **	In this default case we do only one query and we have no problem. */
end_comment

begin_function
name|bool
name|get_domaininfo
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name to query about */
name|input
name|char
modifier|*
name|domain
decl_stmt|;
comment|/* domain to which name is relative */
block|{
name|char
name|namebuf
index|[
literal|2
operator|*
name|MAXDNAME
operator|+
literal|2
index|]
decl_stmt|;
comment|/* buffer to store full domain name */
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
name|bool
name|result
decl_stmt|;
comment|/* result status of action taken */
comment|/*  * Show what we are about to query.  */
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|domain
operator|==
name|NULL
operator|||
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"Trying %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Trying %s within %s"
argument_list|,
name|name
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|&&
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|" at server %s"
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ...\n"
argument_list|)
expr_stmt|;
block|}
comment|/*  * Construct the actual domain name.  * A null domain means the given name is already fully qualified.  * If the composite name is too long, res_mkquery() will fail.  */
if|if
condition|(
name|domain
operator|==
name|NULL
operator|||
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%.*s"
argument_list|,
name|MAXDNAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"%.*s.%.*s"
argument_list|,
name|MAXDNAME
argument_list|,
name|name
argument_list|,
name|MAXDNAME
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|name
operator|=
name|namebuf
expr_stmt|;
comment|/*  * Fetch the desired info.  */
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|querytype
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
name|result
operator|=
name|anslen
operator|<
literal|0
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
comment|/*  * Print the relevant data.  * If we got a positive answer, the data may still be corrupted.  */
if|if
condition|(
name|result
condition|)
name|result
operator|=
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  * Remember the actual name that was queried.  * Must be at the end to avoid clobbering during recursive calls.  */
name|realname
operator|=
name|strcpy
argument_list|(
name|realnamebuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_INFO -- Basic routine to issue a nameserver query ** ----------------------------------------------------- ** **	Returns: **		Length of nameserver answer buffer, if obtained. **		-1 if an error occurred (h_errno is set appropriately). ** **	This is the equivalent of the resolver module res_query(). */
end_comment

begin_function
name|int
name|get_info
parameter_list|(
name|answerbuf
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|)
name|output
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of buffer to store answer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name to query about */
name|input
name|int
name|type
decl_stmt|;
comment|/* specific resource record type */
name|input
name|int
name|class
decl_stmt|;
comment|/* specific resource record class */
block|{
name|querybuf
name|query
decl_stmt|;
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|ancount
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
comment|/*  * Construct query, and send it to the nameserver.  * res_send() will fail if no nameserver responded. In this case the possible  * values for errno are ECONNREFUSED and ETIMEDOUT. If we did get an answer,  * errno should be reset, since res_send() may have left an errno in case it  * has used datagrams. Our private version of res_send() will leave also other  * error statuses, and will clear errno if an answer was obtained.  */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* reset before querying nameserver */
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|rrec_data_t
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
sizeof|sizeof
argument_list|(
name|querybuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_mkquery failed\n"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|res_send
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
name|n
argument_list|,
operator|(
name|char
operator|*
operator|)
name|answerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|querybuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_send failed\n"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* reset after we got an answer */
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
condition|)
block|{
name|pr_error
argument_list|(
literal|"answer length %s too short"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  * Analyze the status of the answer from the nameserver.  */
if|if
condition|(
name|debug
operator|||
name|verbose
condition|)
name|print_status
argument_list|(
name|answerbuf
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|ancount
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|bp
operator|->
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* distinguish between authoritative or not */
name|h_errno
operator|=
name|bp
operator|->
name|aa
condition|?
name|HOST_NOT_FOUND
else|:
name|NO_HOST
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
comment|/* distinguish between authoritative or not */
name|h_errno
operator|=
name|bp
operator|->
name|aa
condition|?
name|NO_DATA
else|:
name|NO_RREC
expr_stmt|;
break|break;
case|case
name|SERVFAIL
case|:
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
case|case
name|NOCHANGE
case|:
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
break|break;
default|default:
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|h_errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_INFO -- Check resource records in answer and print relevant data ** ---------------------------------------------------------------------- ** **	Returns: **		TRUE if answer buffer was processed successfully. **		FALSE otherwise. ** **	Side effects: **		Will recurse on MAILB records if appropriate. **		See also side effects of the print_rrec() routine. */
end_comment

begin_function
name|bool
name|print_info
parameter_list|(
name|answerbuf
parameter_list|,
name|answerlen
parameter_list|,
name|name
parameter_list|,
name|listing
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
name|input
name|int
name|answerlen
decl_stmt|;
comment|/* length of answer buffer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name we are querying about */
name|input
name|bool
name|listing
decl_stmt|;
comment|/* set if this is a zone listing */
block|{
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|eom
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
name|answerlen
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
comment|/*  * Skip the query section in the response (present only in normal queries).  */
if|if
condition|(
name|qdcount
condition|)
block|{
while|while
condition|(
name|qdcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
comment|/* cp += dn_skipname(cp, eom) + QFIXEDSZ; */
name|cp
operator|=
name|skip_qrec
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|qdcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|qdcount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid qdcount in response"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/*  * Process the actual answer section in the response.  * During zone transfers, this is the only section available.  */
if|if
condition|(
name|ancount
condition|)
block|{
if|if
condition|(
operator|!
name|listing
operator|&&
name|verbose
operator|&&
operator|!
name|bp
operator|->
name|aa
condition|)
name|printf
argument_list|(
literal|"The following answer is not authoritative:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ancount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|print_rrec
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|listing
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|ancount
operator|--
expr_stmt|;
comment|/* 		 * When we ask for address and there is a CNAME, it returns 		 * both the CNAME and the address.  Since we trace down the 		 * CNAME chain ourselves, we don't really want to print the 		 * address at this point. 		 */
if|if
condition|(
operator|!
name|listmode
operator|&&
operator|!
name|verbose
operator|&&
name|cname
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* 		 * Recursively expand MR or MG records into MB records. 		 */
if|if
condition|(
operator|!
name|listmode
operator|&&
name|mailmode
operator|&&
name|mname
condition|)
block|{
name|char
name|newnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|newname
operator|=
name|strcpy
argument_list|(
name|newnamebuf
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|get_hostinfo
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ancount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid ancount in response"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/*  * The nameserver and additional info section are normally not processed.  * Both sections shouldn't exist in zone transfers.  */
if|if
condition|(
operator|!
name|verbose
operator|||
name|exclusive
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|nscount
condition|)
block|{
name|printf
argument_list|(
literal|"Authoritative nameservers:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|nscount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|print_rrec
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|nscount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nscount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid nscount in response"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
if|if
condition|(
name|arcount
condition|)
block|{
name|printf
argument_list|(
literal|"Additional information:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|arcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|print_rrec
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|arcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|arcount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid arcount in response"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** DOPRINTF -- Output resource record data if this record is wanted ** ---------------------------------------------------------------- ** **	Returns: **		None. ** **	Inputs: **		The global variable doprint is set by print_rrec() **		if we need to print the data. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|doprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether or not to print */
end_comment

begin_function
name|void
comment|/*VARARGS1*/
name|doprintf
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
name|input
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_function

begin_comment
comment|/* optional arguments */
end_comment

begin_block
block|{
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
operator|!
name|suppress
condition|)
name|printf
argument_list|(
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_RREC -- Decode single resource record and output relevant data ** -------------------------------------------------------------------- ** **	Returns: **		Pointer to position in answer buffer after current record. **		NULL if there was a format error in the current record. ** **	Outputs: **		The global variable doprint is set appropriately **		for use by doprintf(). ** **	Side effects: **		Updates resource record statistics in record_stats[]. **		Sets soaname if this is an SOA record. **		Sets subname if this is an NS record. **		Sets adrname if this is an A record. **		Sets address if this is an A record. **		Sets cname if this is a valid CNAME record. **		Sets mname if this is a valid MAILB record. **		These variables must have been cleared before calling **		print_info() and may be checked afterwards. */
end_comment

begin_define
define|#
directive|define
name|pr_name
parameter_list|(
name|x
parameter_list|)
value|(listing ? pr_dotname(x) : x)
end_define

begin_function
name|u_char
modifier|*
name|print_rrec
parameter_list|(
name|name
parameter_list|,
name|cp
parameter_list|,
name|msg
parameter_list|,
name|eom
parameter_list|,
name|listing
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name we are querying about */
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in answer buf */
name|input
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_comment
comment|/* begin and end of answer buf */
end_comment

begin_decl_stmt
name|input
name|bool
name|listing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if this is a zone listing */
end_comment

begin_block
block|{
name|char
name|rname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* record name in LHS */
name|char
name|dname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* domain name in RHS */
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|ttl
decl_stmt|,
name|dlen
decl_stmt|;
comment|/* fixed values in every record */
name|u_char
modifier|*
name|eor
decl_stmt|;
comment|/* predicted position of next record */
name|bool
name|classmatch
decl_stmt|;
comment|/* set if we want to see this class */
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|struct
name|protoent
modifier|*
name|protocol
decl_stmt|;
name|struct
name|servent
modifier|*
name|service
decl_stmt|;
comment|/*  * Pickup the standard values present in each resource record.  */
name|n
operator|=
name|expand_name
argument_list|(
name|name
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|eor
operator|=
name|cp
operator|+
name|dlen
expr_stmt|;
comment|/*  * Decide whether or not to print this resource record.  */
if|if
condition|(
name|listing
condition|)
block|{
name|classmatch
operator|=
name|want_class
argument_list|(
name|class
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
name|doprint
operator|=
name|classmatch
operator|&&
name|want_type
argument_list|(
name|type
argument_list|,
name|querytype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|classmatch
operator|=
name|want_class
argument_list|(
name|class
argument_list|,
name|C_ANY
argument_list|)
expr_stmt|;
name|doprint
operator|=
name|classmatch
operator|&&
name|want_type
argument_list|(
name|type
argument_list|,
name|T_ANY
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|obsolete
if|if
condition|(
name|doprint
operator|&&
name|exclusive
operator|&&
operator|!
name|samedomain
argument_list|(
name|rname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|doprint
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|doprint
operator|&&
name|exclusive
operator|&&
operator|!
name|indomain
argument_list|(
name|rname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|doprint
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|doprint
operator|&&
name|exclusive
operator|&&
name|fakename
argument_list|(
name|rname
argument_list|)
condition|)
name|doprint
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|justfun
if|if
condition|(
name|namelen
operator|&&
operator|(
name|strlength
argument_list|(
name|rname
argument_list|)
operator|<
name|namelen
operator|)
condition|)
name|doprint
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/*  * Print name and common values, if appropriate.  */
if|if
condition|(
name|verbose
condition|)
name|doprintf
argument_list|(
literal|"%-20s\t%s\t%s\t%s"
argument_list|,
name|pr_name
argument_list|(
name|rname
argument_list|)
argument_list|,
name|itoa
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ttlprint
condition|)
name|doprintf
argument_list|(
literal|"%-20s\t%s\t%s"
argument_list|,
name|pr_name
argument_list|(
name|rname
argument_list|)
argument_list|,
name|itoa
argument_list|(
name|ttl
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|"%-20s\t%s"
argument_list|,
name|pr_name
argument_list|(
name|rname
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  * Update resource record statistics for zone listing.  */
if|if
condition|(
name|listing
operator|&&
name|classmatch
condition|)
block|{
if|if
condition|(
name|type
operator|>=
name|T_FIRST
operator|&&
name|type
operator|<=
name|T_LAST
condition|)
name|record_stats
index|[
name|type
index|]
operator|++
expr_stmt|;
block|}
comment|/*  * Save the domain name of an SOA or NS or A record for zone listing.  */
if|if
condition|(
name|listing
operator|&&
name|classmatch
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_A
condition|)
name|adrname
operator|=
name|strcpy
argument_list|(
name|adrnamebuf
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|T_NS
condition|)
name|subname
operator|=
name|strcpy
argument_list|(
name|subnamebuf
argument_list|,
name|rname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|soaname
operator|=
name|strcpy
argument_list|(
name|soanamebuf
argument_list|,
name|rname
argument_list|)
expr_stmt|;
block|}
comment|/*  * Print type specific data, if appropriate.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
case|case
name|C_HS
case|:
if|if
condition|(
name|dlen
operator|==
sizeof|sizeof
argument_list|(
name|ipaddr_t
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|inaddr
operator|.
name|s_addr
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|dlen
operator|==
sizeof|sizeof
argument_list|(
name|ipaddr_t
argument_list|)
operator|+
literal|3
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|address
operator|=
name|inaddr
operator|.
name|s_addr
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|cp
index|[
literal|4
index|]
expr_stmt|;
name|doprintf
argument_list|(
literal|", protocol = %s"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|cp
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
name|cp
index|[
literal|6
index|]
expr_stmt|;
name|doprintf
argument_list|(
literal|", port = %s"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
name|address
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|address
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|T_MX
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|ttlprint
condition|)
name|doprintf
argument_list|(
literal|"\t%s "
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"%s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
case|case
name|T_CNAME
case|:
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|" (\n\t\t\t%s\t;serial (version)"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|n
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\n\t\t\t%s\t;refresh period"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|n
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\n\t\t\t%s\t;retry refresh time"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|n
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\n\t\t\t%s\t;expiration period"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|n
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\n\t\t\t%s\t;default ttl\n\t\t\t)"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_WKS
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
sizeof|sizeof
argument_list|(
name|ipaddr_t
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|ipaddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|protocol
operator|=
name|getprotobynumber
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|!=
name|NULL
condition|)
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|protocol
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|eor
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|&
literal|0200
condition|)
block|{
if|if
condition|(
name|protocol
operator|!=
name|NULL
condition|)
name|service
operator|=
name|getservbyport
argument_list|(
name|htons
argument_list|(
name|n
argument_list|)
argument_list|,
name|protocol
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|service
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|service
operator|!=
name|NULL
condition|)
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|service
operator|->
name|s_name
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|n
operator|&
literal|07
condition|)
do|;
block|}
name|doprintf
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t\"%s\""
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t\"%s\""
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_MD
case|:
case|case
name|T_MF
case|:
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|obsolete
case|case
name|T_TXT
case|:
if|if
condition|(
name|dlen
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|dlen
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|T_TXT
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t\"%s"
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|eor
condition|)
block|{
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|doprintf
argument_list|(
literal|"%s"
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
name|doprintf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UINFO
case|:
name|doprintf
argument_list|(
literal|"\t\"%s\""
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|dlen
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
if|if
condition|(
name|dlen
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|n
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
break|break;
case|case
name|T_UNSPEC
case|:
case|case
name|T_NULL
case|:
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
case|case
name|T_RP
case|:
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|" %s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_RT
case|:
case|case
name|T_AFSDB
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|ttlprint
condition|)
name|doprintf
argument_list|(
literal|"\t%s "
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|doprintf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|doprintf
argument_list|(
literal|"%s"
argument_list|,
name|pr_name
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_X25
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|T_ISDN
case|:
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|<
name|eor
condition|)
block|{
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|doprintf
argument_list|(
literal|"\t%s"
argument_list|,
name|stoa
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
block|}
break|break;
case|case
name|T_NSAP
case|:
case|case
name|T_NSAPPTR
case|:
name|doprintf
argument_list|(
literal|"\t(not yet implemented)"
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
default|default:
name|doprintf
argument_list|(
literal|"\t???"
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
name|doprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*  * Check validity of the name of this resource record.  * Currently only during zone listing and if requested.  */
if|if
condition|(
name|listing
operator|&&
name|illegal
operator|&&
operator|!
name|valid_name
argument_list|(
name|rname
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"illegal %s record name %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rname
argument_list|)
expr_stmt|;
block|}
comment|/*  * Save the CNAME alias for cname chain tracing.  * Save the MR or MG alias for MB chain tracing.  */
if|if
condition|(
operator|!
name|listmode
operator|&&
name|classmatch
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|==
name|T_CNAME
operator|)
operator|&&
name|n
operator|>
literal|0
operator|&&
name|cp
operator|==
name|eor
condition|)
name|cname
operator|=
name|strcpy
argument_list|(
name|cnamebuf
argument_list|,
name|dname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|T_MR
operator|||
name|type
operator|==
name|T_MG
operator|)
operator|&&
name|n
operator|>
literal|0
operator|&&
name|cp
operator|==
name|eor
condition|)
name|mname
operator|=
name|strcpy
argument_list|(
name|mnamebuf
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
comment|/*  * Check if we have reached the exact end of this record.  */
if|if
condition|(
name|cp
operator|!=
name|eor
condition|)
block|{
name|pr_error
argument_list|(
literal|"size error in %s record for %s, off by = %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rname
argument_list|,
name|itoa
argument_list|(
name|cp
operator|-
name|eor
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we believe value of dlen; should perhaps return(NULL) */
name|cp
operator|=
name|eor
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** SKIP_QREC -- Skip the query record in the nameserver answer buffer ** ------------------------------------------------------------------ ** **	Returns: **		Pointer to position in answer buffer after current record. **		NULL if there was a format error in the current record. */
end_comment

begin_function
name|u_char
modifier|*
name|skip_qrec
parameter_list|(
name|name
parameter_list|,
name|cp
parameter_list|,
name|msg
parameter_list|,
name|eom
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name we are querying about */
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in answer buf */
name|input
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_comment
comment|/* begin and end of answer buf */
end_comment

begin_block
block|{
name|char
name|rname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* record name in LHS */
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
comment|/* fixed values in query record */
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|name
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%-20s\t%s\t%s\n"
argument_list|,
name|rname
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Nameserver information.  * Stores names and addresses of all servers that are to be queried  * for a zone transfer of the desired zone. Normally these are the  * authoritative primary and/or secondary nameservers for the zone.  */
end_comment

begin_define
define|#
directive|define
name|MAXNSNAME
value|16
end_define

begin_comment
comment|/* maximum count of nameservers per zone */
end_comment

begin_define
define|#
directive|define
name|MAXIPADDR
value|10
end_define

begin_comment
comment|/* maximum count of addresses per nameserver */
end_comment

begin_decl_stmt
name|char
name|nsname
index|[
name|MAXNSNAME
index|]
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nameserver hostname */
end_comment

begin_decl_stmt
name|struct
name|in_addr
name|ipaddr
index|[
name|MAXNSNAME
index|]
index|[
name|MAXIPADDR
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nameserver addresses */
end_comment

begin_decl_stmt
name|int
name|naddrs
index|[
name|MAXNSNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of addresses */
end_comment

begin_decl_stmt
name|int
name|nservers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of nameservers */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_typedef
typedef|typedef
struct|struct
name|ns_data
block|{
name|char
name|nsname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* nameserver hostname */
name|struct
name|in_addr
name|ipaddr
index|[
name|MAXIPADDR
index|]
decl_stmt|;
comment|/* nameserver addresses */
name|int
name|naddrs
decl_stmt|;
comment|/* count of addresses */
block|}
name|ns_data_t
typedef|;
end_typedef

begin_decl_stmt
name|ns_data_t
name|nsinfo
index|[
name|MAXNSNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nameserver info */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|bool
name|authserver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server is supposed to be authoritative */
end_comment

begin_comment
comment|/*  * Host information.  * Stores names and (single) addresses encountered during the zone listing  * of all A records that belong to the zone. Non-authoritative glue records  * that do not belong to the zone are not stored. Glue records that belong  * to a delegated zone will be filtered out later during the host count scan.  * The host names are allocated dynamically. #ifdef notyet  * The host data should have been allocated dynamically to avoid static  * limits, but this is less important since it is not saved across calls. #endif  */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTS
value|25000
end_define

begin_comment
comment|/* maximum count of hostnames per zone */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hostname
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname of host in zone */
end_comment

begin_decl_stmt
name|ipaddr_t
name|hostaddr
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first host address */
end_comment

begin_decl_stmt
name|bool
name|multaddr
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if this is a multiple address host */
end_comment

begin_decl_stmt
name|int
name|hostcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of hosts in zone */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_typedef
typedef|typedef
struct|struct
name|host_data
block|{
name|char
modifier|*
name|hostname
decl_stmt|;
comment|/* hostname of host in zone */
name|ipaddr_t
name|hostaddr
decl_stmt|;
comment|/* first host address */
name|bool
name|multaddr
decl_stmt|;
comment|/* set if this is a multiple address host */
block|}
name|host_data_t
typedef|;
end_typedef

begin_decl_stmt
name|host_data_t
name|hostlist
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* info on hosts in zone */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Delegated zone information.  * Stores the names of the delegated zones encountered during the zone  * listing. The names and the list itself are allocated dynamically.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|zonename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of delegated zones within zone */
end_comment

begin_decl_stmt
name|int
name|zonecount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of delegated zones within zone */
end_comment

begin_comment
comment|/*  * Address information.  * Stores the (single) addresses of hosts found in all zones traversed.  * Used to search for duplicate hosts (same address but different name).  * The list of addresses is allocated dynamically, and remains allocated.  * This has now been implemented as a hashed list, using the low-order  * address bits as the hash key.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|obsolete
end_ifdef

begin_decl_stmt
name|ipaddr_t
modifier|*
name|addrlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global list of addresses */
end_comment

begin_decl_stmt
name|int
name|addrcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of global addresses */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|addr_data
block|{
name|ipaddr_t
modifier|*
name|addrlist
decl_stmt|;
comment|/* global list of addresses */
name|int
name|addrcount
decl_stmt|;
comment|/* count of global addresses */
block|}
name|addr_data_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|AHASHSIZE
value|0x2000
end_define

begin_define
define|#
directive|define
name|AHASHMASK
value|0x1fff
end_define

begin_decl_stmt
name|addr_data_t
name|hlist
index|[
name|AHASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash list of global addresses */
end_comment

begin_comment
comment|/*  * SOA record information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|soa_data
block|{
name|char
name|pname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* name of primary server */
name|char
name|mname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* name of hostmaster mailbox */
name|int
name|serial
decl_stmt|;
comment|/* serial (version) number */
name|int
name|refresh
decl_stmt|;
comment|/* refresh time in seconds */
name|int
name|retry
decl_stmt|;
comment|/* refresh retry time in seconds */
name|int
name|expire
decl_stmt|;
comment|/* expiration time in seconds */
name|int
name|defttl
decl_stmt|;
comment|/* default time_to_live */
block|}
name|soa_data_t
typedef|;
end_typedef

begin_decl_stmt
name|soa_data_t
name|soa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer to store soa data */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ** LIST_ZONE -- Basic routine to do complete zone listing and checking ** ------------------------------------------------------------------- ** **	Returns: **		TRUE if the requested info was processed successfully. **		FALSE otherwise. */
end_comment

begin_decl_stmt
name|int
name|total_calls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of calls for zone processing */
end_comment

begin_decl_stmt
name|int
name|total_check
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of zones successfully processed */
end_comment

begin_decl_stmt
name|int
name|total_tries
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of zone transfer attempts */
end_comment

begin_decl_stmt
name|int
name|total_zones
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of successful zone transfers */
end_comment

begin_decl_stmt
name|int
name|total_hosts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of hosts in all traversed zones */
end_comment

begin_decl_stmt
name|int
name|total_dupls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of duplicates in all zones */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|justfun
end_ifdef

begin_decl_stmt
name|char
name|longname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* longest hostname found */
end_comment

begin_decl_stmt
name|int
name|longsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of longest hostname */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|recursion_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current recursion level */
end_comment

begin_function
name|bool
name|list_zone
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to process */
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nzones
decl_stmt|;
comment|/* count of delegated zones */
name|int
name|nhosts
decl_stmt|;
comment|/* count of real hostnames */
name|int
name|ndupls
decl_stmt|;
comment|/* count of duplicate hosts */
name|int
name|nextrs
decl_stmt|;
comment|/* count of extrazone hosts */
name|int
name|ngates
decl_stmt|;
comment|/* count of gateway hosts */
name|total_calls
operator|+=
literal|1
expr_stmt|;
comment|/* update zone processing calls */
comment|/*  * Normalize to not have trailing dot, unless it is the root zone.  */
name|n
operator|=
name|strlength
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|name
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|name
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*  * Indicate whether we are processing an "in-addr.arpa" reverse zone.  * In this case we will suppress accumulating host count statistics.  */
name|reverse
operator|=
name|indomain
argument_list|(
name|name
argument_list|,
literal|"in-addr.arpa"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*  * Find the nameservers for the given zone.  */
operator|(
name|void
operator|)
name|find_servers
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nservers
operator|<
literal|1
condition|)
block|{
name|errmsg
argument_list|(
literal|"No nameservers for %s found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Make sure we have an address for at least one nameserver.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|naddrs
index|[
name|n
index|]
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|n
operator|>=
name|nservers
condition|)
block|{
name|errmsg
argument_list|(
literal|"No addresses of nameservers for %s found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Without an explicit server on the command line, the servers we  * have looked up are supposed to be authoritative for the zone.  */
name|authserver
operator|=
name|server
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
comment|/*  * Check SOA records at each of the nameservers.  * Temporarily save our current server info from the resolver database.  * Turn off nameserver recursion and make sure answer is authoritative.  */
if|if
condition|(
name|checkmode
condition|)
block|{
name|res_state_t
name|save_res
decl_stmt|;
comment|/* saved copy of resolver database */
name|char
modifier|*
name|save_server
decl_stmt|;
comment|/* saved copy of server name */
comment|/* save resolver database */
name|save_res
operator|=
name|_res
expr_stmt|;
name|save_server
operator|=
name|server
expr_stmt|;
comment|/* turn off nameserver recursion */
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|naddrs
index|[
name|n
index|]
operator|<
literal|1
condition|)
continue|continue;
comment|/* shortcut */
name|server
operator|=
name|nsname
index|[
name|n
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNS
operator|&&
name|i
operator|<
name|naddrs
index|[
name|n
index|]
condition|;
name|i
operator|++
control|)
block|{
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_addr
operator|=
name|ipaddr
index|[
name|n
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|_res
operator|.
name|nscount
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|check_zone
argument_list|(
name|name
argument_list|)
condition|)
continue|continue;
comment|/* SOA query failed */
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_SOA
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
comment|/* non-authoritative denial: assume lame delegation */
if|if
condition|(
name|h_errno
operator|==
name|NO_RREC
operator|||
name|h_errno
operator|==
name|NO_HOST
condition|)
block|{
if|if
condition|(
name|authserver
condition|)
name|errmsg
argument_list|(
literal|"%s has lame delegation to %s"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* authoritative denial: probably misconfiguration */
if|if
condition|(
name|h_errno
operator|==
name|NO_DATA
operator|||
name|h_errno
operator|==
name|HOST_NOT_FOUND
condition|)
block|{
if|if
condition|(
name|authserver
condition|)
name|errmsg
argument_list|(
literal|"%s has lame delegation to %s"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* restore resolver database */
name|_res
operator|=
name|save_res
expr_stmt|;
name|server
operator|=
name|save_server
expr_stmt|;
name|total_check
operator|+=
literal|1
expr_stmt|;
comment|/* update zones processed */
comment|/* all done if maximum recursion level reached */
if|if
condition|(
operator|!
name|recursive
operator|||
operator|(
name|recursion_level
operator|>=
name|recursive
operator|)
condition|)
return|return
operator|(
name|Errors
operator|==
literal|0
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
comment|/*  * Ask zone transfer to the nameservers, until one responds.  * If we have queried an authoritative server, it should respond positively.  * If it responds with an error, we may have a lame delegation.  * Always continue with the next server to avoid missing entire zones.  */
name|total_tries
operator|+=
literal|1
expr_stmt|;
comment|/* update zone transfer attempts */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
index|[
name|n
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying server %s (%s) ...\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ipaddr
index|[
name|n
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|transfer_zone
argument_list|(
name|name
argument_list|,
name|queryclass
argument_list|,
name|ipaddr
index|[
name|n
index|]
index|[
name|i
index|]
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* double break */
comment|/* zone transfer failed */
if|if
condition|(
name|h_errno
operator|!=
name|TRY_AGAIN
condition|)
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_AXFR
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
comment|/* non-authoritative denial: assume lame delegation */
if|if
condition|(
name|h_errno
operator|==
name|NO_RREC
operator|||
name|h_errno
operator|==
name|NO_HOST
condition|)
block|{
if|if
condition|(
name|authserver
condition|)
name|errmsg
argument_list|(
literal|"%s has lame delegation to %s"
argument_list|,
name|name
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* authoritative denial: probably misconfiguration */
if|if
condition|(
name|h_errno
operator|==
name|NO_DATA
operator|||
name|h_errno
operator|==
name|HOST_NOT_FOUND
condition|)
block|{
if|if
condition|(
name|authserver
condition|)
name|errmsg
argument_list|(
literal|"%s has lame delegation to %s"
argument_list|,
name|name
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* terminate on irrecoverable errors */
if|if
condition|(
name|h_errno
operator|!=
name|TRY_AGAIN
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
ifdef|#
directive|ifdef
name|notyet
comment|/* in case nameserver not present */
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
break|break;
endif|#
directive|endif
block|}
block|}
name|done
label|:
if|if
condition|(
name|n
operator|>=
name|nservers
condition|)
block|{
if|if
condition|(
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_AXFR
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|"No nameservers for %s responded"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|total_zones
operator|+=
literal|1
expr_stmt|;
comment|/* update successful zone transfers */
comment|/*  * Print resource record statistics if so requested.  */
if|if
condition|(
name|statistics
condition|)
name|print_statistics
argument_list|(
name|name
argument_list|,
name|querytype
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
comment|/*  * Accumulate host count statistics for this zone.  */
name|nzones
operator|=
name|zonecount
expr_stmt|;
name|nhosts
operator|=
literal|0
operator|,
name|ndupls
operator|=
literal|0
operator|,
name|nextrs
operator|=
literal|0
operator|,
name|ngates
operator|=
literal|0
expr_stmt|;
name|i
operator|=
operator|(
name|verbose
operator|||
name|statistics
operator|||
name|hostmode
operator|)
condition|?
literal|0
else|:
name|hostcount
expr_stmt|;
for|for
control|(
name|n
operator|=
name|i
init|;
name|n
operator|<
name|hostcount
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|in_addr
name|inaddr
decl_stmt|;
comment|/* skip fake hosts using a very rudimentary test */
if|if
condition|(
name|fakename
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
operator|||
name|fakeaddr
argument_list|(
name|hostaddr
index|[
name|n
index|]
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|justfun
comment|/* save longest hostname encountered so far */
if|if
condition|(
name|strlength
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
operator|>
name|longsize
condition|)
block|{
name|longsize
operator|=
name|strlength
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|longname
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* skip apparent glue records */
if|if
condition|(
name|gluerecord
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|,
name|name
argument_list|,
name|zonename
argument_list|,
name|nzones
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s is glue record\n"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* otherwise count as host */
name|nhosts
operator|++
expr_stmt|;
name|inaddr
operator|.
name|s_addr
operator|=
name|hostaddr
index|[
name|n
index|]
expr_stmt|;
comment|/* 	 * Mark hosts not residing directly in the zone as extrazone host. 	 */
if|if
condition|(
operator|!
name|samedomain
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|nextrs
operator|++
expr_stmt|;
if|if
condition|(
name|extrmode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"%s is extrazone host\n"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mark hosts with more than one address as gateway host. 	 * These are not checked for duplicate addresses. 	 */
if|if
condition|(
name|multaddr
index|[
name|n
index|]
condition|)
block|{
name|ngates
operator|++
expr_stmt|;
if|if
condition|(
name|gatemode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"%s is gateway host\n"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Compare single address hosts against global list of addresses. 	 * Multiple address hosts are too complicated to handle this way. 	 */
if|if
condition|(
name|check_dupl
argument_list|(
name|hostaddr
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|ndupls
operator|++
expr_stmt|;
if|if
condition|(
name|duplmode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"%s is duplicate host with address %s\n"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Print statistics for this zone.  */
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|hostmode
condition|)
block|{
name|printf
argument_list|(
literal|"Found %d host%s within %s\n"
argument_list|,
name|nhosts
argument_list|,
name|nhosts
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ndupls
operator|>
literal|0
operator|)
operator|||
name|duplmode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"Found %d duplicate host%s within %s\n"
argument_list|,
name|ndupls
argument_list|,
name|ndupls
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nextrs
operator|>
literal|0
operator|)
operator|||
name|extrmode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"Found %d extrazone host%s within %s\n"
argument_list|,
name|nextrs
argument_list|,
name|nextrs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ngates
operator|>
literal|0
operator|)
operator|||
name|gatemode
operator|||
operator|(
name|verbose
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"Found %d gateway host%s within %s\n"
argument_list|,
name|ngates
argument_list|,
name|ngates
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|total_hosts
operator|+=
name|nhosts
expr_stmt|;
comment|/* update total number of hosts */
name|total_dupls
operator|+=
name|ndupls
expr_stmt|;
comment|/* update total number of duplicates */
if|if
condition|(
operator|!
name|checkmode
condition|)
name|total_check
operator|+=
literal|1
expr_stmt|;
comment|/* update zones processed */
if|if
condition|(
name|verbose
operator|||
name|statistics
condition|)
name|printf
argument_list|(
literal|"Found %d delegated zone%s within %s\n"
argument_list|,
name|nzones
argument_list|,
name|nzones
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/*  * The names of the hosts were allocated dynamically.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hostcount
condition|;
name|n
operator|++
control|)
name|xfree
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
comment|/*  * Check for mailable delegated zones within this zone.  * This is based on ordinary MX lookup, and not on the MX info  * which may be present in the zone listing, to reduce zone transfers.  */
if|if
condition|(
name|mxrecmode
condition|)
block|{
if|if
condition|(
name|recursion_level
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_mxrec
argument_list|(
name|name
argument_list|)
condition|)
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_MX
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nzones
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_mxrec
argument_list|(
name|zonename
index|[
name|n
index|]
argument_list|)
condition|)
name|ns_error
argument_list|(
name|zonename
index|[
name|n
index|]
argument_list|,
name|T_MX
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Do recursion on delegated zones if requested and any were found.  * Temporarily save zonename list, and force allocation of new list.  */
if|if
condition|(
name|recursive
operator|&&
operator|(
name|recursion_level
operator|<
name|recursive
operator|)
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nzones
condition|;
name|n
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|newzone
decl_stmt|;
comment|/* local copy of list */
name|newzone
operator|=
name|zonename
expr_stmt|;
name|zonename
operator|=
name|NULL
expr_stmt|;
comment|/* allocate new list */
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|checkmode
operator|||
name|hostmode
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Entering zone %s\n"
argument_list|,
name|newzone
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|recursion_level
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|list_zone
argument_list|(
name|newzone
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|recursion_level
operator|--
expr_stmt|;
name|zonename
operator|=
name|newzone
expr_stmt|;
comment|/* restore */
block|}
block|}
comment|/*  * The names of the delegated zones were allocated dynamically.  * The list of delegated zone names was also allocated dynamically.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nzones
condition|;
name|n
operator|++
control|)
name|xfree
argument_list|(
name|zonename
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonename
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|zonename
argument_list|)
expr_stmt|;
name|zonename
operator|=
name|NULL
expr_stmt|;
comment|/*  * Print final overall statistics.  */
if|if
condition|(
name|recursive
operator|&&
operator|(
name|recursion_level
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|checkmode
operator|||
name|hostmode
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|hostmode
condition|)
name|printf
argument_list|(
literal|"Encountered %d host%s in %d zone%s within %s\n"
argument_list|,
name|total_hosts
argument_list|,
name|total_hosts
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total_zones
argument_list|,
name|total_zones
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|hostmode
condition|)
name|printf
argument_list|(
literal|"Encountered %d duplicate host%s in %d zone%s within %s\n"
argument_list|,
name|total_dupls
argument_list|,
name|total_dupls
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total_zones
argument_list|,
name|total_zones
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|checkmode
condition|)
name|printf
argument_list|(
literal|"Transferred %d zone%s out of %d attempt%s\n"
argument_list|,
name|total_zones
argument_list|,
name|total_zones
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total_tries
argument_list|,
name|total_tries
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|statistics
operator|||
name|checkmode
condition|)
name|printf
argument_list|(
literal|"Processed %d zone%s out of %d request%s\n"
argument_list|,
name|total_check
argument_list|,
name|total_check
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total_calls
argument_list|,
name|total_calls
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|justfun
if|if
condition|(
name|verbose
operator|&&
operator|(
name|longsize
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"Longest hostname %s\t%d\n"
argument_list|,
name|longname
argument_list|,
name|longsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* indicate whether any errors were encountered */
return|return
operator|(
name|Errors
operator|==
literal|0
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** FIND_SERVERS -- Fetch names and addresses of authoritative servers ** ------------------------------------------------------------------ ** **	Returns: **		TRUE if servers could be determined successfully. **		FALSE otherwise. ** **	Inputs: **		The global variable server, if set, contains the name **		of the explicit server to be contacted. **		The global variable primary, if set, indicates that **		we must use the primary nameserver for the zone. ** **	Outputs: **		Names are stored in the nsname[] database. **		Addresses are stored in the ipaddr[] database. **		Address counts are stored in the naddrs[] database. **		The count of nameservers is stored in nservers. */
end_comment

begin_function
name|bool
name|find_servers
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to find servers for */
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/*  * Use the explicit server if given on the command line.  * Its addresses are stored in the resolver state struct.  * This server may not be authoritative for the given zone.  */
if|if
condition|(
name|server
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nsname
index|[
literal|0
index|]
argument_list|,
name|server
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXIPADDR
operator|&&
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
name|ipaddr
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_addr
expr_stmt|;
name|naddrs
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|nservers
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*  * Fetch primary nameserver info if so requested.  * Get its name from the SOA record for the zone, and do a regular  * host lookup to fetch its addresses. We are assuming here that the  * SOA record is a proper one. This is not necessarily true.  * Obviously this server should be authoritative.  */
if|if
condition|(
name|primary
condition|)
block|{
name|char
modifier|*
name|primaryname
decl_stmt|;
name|primaryname
operator|=
name|get_primary
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|primaryname
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_SOA
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
name|nservers
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|hp
operator|=
name|gethostbyname
argument_list|(
name|primaryname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|primaryname
argument_list|,
name|T_A
argument_list|,
name|C_IN
argument_list|)
expr_stmt|;
name|nservers
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nsname
index|[
literal|0
index|]
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXIPADDR
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|ipaddr
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|naddrs
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d address%s for %s\n"
argument_list|,
name|naddrs
index|[
literal|0
index|]
argument_list|,
name|naddrs
index|[
literal|0
index|]
operator|==
literal|1
condition|?
literal|"  "
else|:
literal|"es"
argument_list|,
name|nsname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nservers
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*  * Otherwise we have to find the nameservers for the zone.  * These are supposed to be authoritative, but sometimes we  * encounter lame delegations, perhaps due to misconfiguration.  */
if|if
condition|(
operator|!
name|get_servers
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_NS
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
name|nservers
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Usually we'll get addresses for all the servers in the additional  * info section.  But in case we don't, look up their addresses.  * If we get no addresses by extra query, and this is authoritative,  * we flag a lame delegation to that server.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|naddrs
index|[
name|n
index|]
operator|==
literal|0
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXIPADDR
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|ipaddr
index|[
name|n
index|]
index|[
name|i
index|]
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|naddrs
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d address%s for %s by extra query\n"
argument_list|,
name|naddrs
index|[
name|n
index|]
argument_list|,
name|naddrs
index|[
name|n
index|]
operator|==
literal|1
condition|?
literal|"  "
else|:
literal|"es"
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
comment|/* server name lookup failed */
name|ns_error
argument_list|(
name|nsname
index|[
name|n
index|]
argument_list|,
name|T_A
argument_list|,
name|C_IN
argument_list|)
expr_stmt|;
comment|/* authoritative denial: probably misconfiguration */
if|if
condition|(
name|h_errno
operator|==
name|NO_DATA
operator|||
name|h_errno
operator|==
name|HOST_NOT_FOUND
condition|)
block|{
name|errmsg
argument_list|(
literal|"%s has lame delegation to %s"
argument_list|,
name|name
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d address%s for %s\n"
argument_list|,
name|naddrs
index|[
name|n
index|]
argument_list|,
name|naddrs
index|[
name|n
index|]
operator|==
literal|1
condition|?
literal|"  "
else|:
literal|"es"
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Issue warning if only one server has been discovered.  * This is not an error per se, but not much redundancy in that case.  */
if|if
condition|(
name|nservers
operator|==
literal|1
condition|)
name|pr_warning
argument_list|(
literal|"only one nameserver for %s found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|nservers
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_SERVERS -- Fetch names and addresses of authoritative servers ** ----------------------------------------------------------------- ** **	Returns: **		TRUE if servers could be determined successfully. **		FALSE otherwise. ** **	Side effects: **		Names are stored in the nsname[] database. **		Addresses are stored in the ipaddr[] database. **		Address counts are stored in the naddrs[] database. **		The count of nameservers is stored in nservers. */
end_comment

begin_function
name|bool
name|get_servers
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to find servers for */
block|{
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
name|bool
name|result
decl_stmt|;
comment|/* result status of action taken */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Finding nameservers for %s ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|T_NS
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|anslen
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|result
operator|=
name|get_nsinfo
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_NSINFO -- Extract nameserver data from nameserver answer buffer ** ------------------------------------------------------------------- ** **	Returns: **		TRUE if servers could be determined successfully. **		FALSE otherwise. ** **	Outputs: **		Names are stored in the nsname[] database. **		Addresses are stored in the ipaddr[] database. **		Address counts are stored in the naddrs[] database. **		The count of nameservers is stored in nservers. */
end_comment

begin_function
name|bool
name|get_nsinfo
parameter_list|(
name|answerbuf
parameter_list|,
name|answerlen
parameter_list|,
name|name
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
name|input
name|int
name|answerlen
decl_stmt|;
comment|/* length of answer buffer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to find servers for */
block|{
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|;
name|int
name|rrcount
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|nservers
operator|=
literal|0
expr_stmt|;
comment|/* count of nameservers */
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|eom
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
name|answerlen
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|skip_qrec
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|qdcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|qdcount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid qdcount in response"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * If the answer is authoritative, the names are found in the  * answer section, and the nameserver section is empty.  * If not, there may be duplicate names in both sections.  * Addresses are found in the additional info section both cases.  */
name|rrcount
operator|=
name|ancount
operator|+
name|nscount
operator|+
name|arcount
expr_stmt|;
while|while
condition|(
name|rrcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|char
name|rname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|ttl
decl_stmt|,
name|dlen
decl_stmt|;
name|u_char
modifier|*
name|eor
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|name
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|eor
operator|=
name|cp
operator|+
name|dlen
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%-20s\t%d\t%s\t%s\n"
argument_list|,
name|rname
argument_list|,
name|ttl
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|type
operator|==
name|T_NS
operator|)
operator|&&
name|sameword
argument_list|(
name|rname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nservers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
name|dname
argument_list|)
condition|)
break|break;
comment|/* duplicate */
if|if
condition|(
name|i
operator|>=
name|nservers
operator|&&
name|nservers
operator|<
name|MAXNSNAME
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nsname
index|[
name|nservers
index|]
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|naddrs
index|[
name|nservers
index|]
operator|=
literal|0
expr_stmt|;
name|nservers
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|T_A
operator|)
operator|&&
name|dlen
operator|==
sizeof|sizeof
argument_list|(
name|ipaddr_t
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nservers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
name|rname
argument_list|)
condition|)
break|break;
comment|/* found */
if|if
condition|(
name|i
operator|<
name|nservers
operator|&&
name|naddrs
index|[
name|i
index|]
operator|<
name|MAXIPADDR
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ipaddr
index|[
name|i
index|]
index|[
name|naddrs
index|[
name|i
index|]
index|]
operator|=
name|inaddr
expr_stmt|;
name|naddrs
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
else|else
name|cp
operator|+=
name|dlen
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|eor
condition|)
block|{
name|pr_error
argument_list|(
literal|"size error in %s record for %s, off by = %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rname
argument_list|,
name|itoa
argument_list|(
name|cp
operator|-
name|eor
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|rrcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rrcount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid rrcount in response"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** TRANSFER_ZONE -- Wrapper for get_zone() to hide administrative tasks ** -------------------------------------------------------------------- ** **	Returns: **		See get_zone() for details. ** **	Side effects: **		See get_zone() for details. ** **	This routine may be called repeatedly with different server **	addresses, until one of the servers responds. Various items **	must be reset on every try to continue with a clean slate. */
end_comment

begin_function
name|bool
name|transfer_zone
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|inaddr
parameter_list|,
name|host
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to do zone xfer for */
name|input
name|int
name|class
decl_stmt|;
comment|/* specific resource record class */
name|input
name|struct
name|in_addr
name|inaddr
decl_stmt|;
comment|/* address of server to be queried */
name|input
name|char
modifier|*
name|host
decl_stmt|;
comment|/* name of server to be queried */
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/*  * Reset the resource record statistics before each try.  */
name|clear_statistics
argument_list|()
expr_stmt|;
comment|/*  * Perform the actual zone transfer.  */
if|if
condition|(
name|get_zone
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|inaddr
argument_list|,
name|host
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/*  * Failure to get the zone. Free any memory that may have been allocated.  * On success it is the responsibility of the caller to free the memory.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hostcount
condition|;
name|n
operator|++
control|)
name|xfree
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|zonecount
condition|;
name|n
operator|++
control|)
name|xfree
argument_list|(
name|zonename
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonename
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|zonename
argument_list|)
expr_stmt|;
name|zonename
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_ZONE -- Perform a zone transfer from server at specific address ** ------------------------------------------------------------------- ** **	Returns: **		TRUE if the zone data have been retrieved successfully. **		FALSE if an error occurred (h_errno is set appropriately). **		Set TRY_AGAIN wherever possible to try the next server. ** **	Side effects: **		Stores list of delegated zones found in zonename[], **		and the count of delegated zones in zonecount. **		Stores list of hostnames  found in hostname[], **		and the count of hostnames in hostcount. **		Updates resource record statistics in record_stats[]. **		This array must have been cleared before. */
end_comment

begin_function
name|bool
name|get_zone
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|inaddr
parameter_list|,
name|host
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to do zone xfer for */
name|input
name|int
name|class
decl_stmt|;
comment|/* specific resource record class */
name|input
name|struct
name|in_addr
name|inaddr
decl_stmt|;
comment|/* address of server to be queried */
name|input
name|char
modifier|*
name|host
decl_stmt|;
comment|/* name of server to be queried */
block|{
name|querybuf
name|query
decl_stmt|;
name|querybuf
name|answer
decl_stmt|;
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|ancount
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nrecords
init|=
literal|0
decl_stmt|;
comment|/* number of records processed */
name|int
name|soacount
init|=
literal|0
decl_stmt|;
comment|/* count of SOA records */
name|zonecount
operator|=
literal|0
expr_stmt|;
comment|/* count of delegated zones */
name|hostcount
operator|=
literal|0
expr_stmt|;
comment|/* count of hostnames */
comment|/*  * Construct query, and connect to the given server.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|T_AXFR
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|rrec_data_t
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
sizeof|sizeof
argument_list|(
name|querybuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_mkquery failed\n"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"get_zone()\n"
argument_list|)
expr_stmt|;
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|inaddr
expr_stmt|;
name|_res_setaddr
argument_list|(
operator|&
name|sin
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|_res_perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|_res_connect
argument_list|(
name|sock
argument_list|,
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug
operator|||
name|verbose
condition|)
name|_res_perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Asking zone transfer for %s ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/*  * Send the query buffer.  */
if|if
condition|(
name|_res_write
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|query
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Process all incoming records, each record in a separate packet.  */
while|while
condition|(
operator|(
name|n
operator|=
name|_res_read
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|answer
argument_list|,
sizeof|sizeof
argument_list|(
name|querybuf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
condition|)
block|{
name|pr_error
argument_list|(
literal|"answer length %s too short"
argument_list|,
name|itoa
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"got answer:\n"
argument_list|)
expr_stmt|;
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|answer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Analyze the contents of the answer and check for errors. 	 * An error can be expected only in the very first packet. 	 */
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|&
name|answer
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|ancount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|print_status
argument_list|(
operator|&
name|answer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* distinguish between authoritative or not */
name|h_errno
operator|=
name|bp
operator|->
name|aa
condition|?
name|HOST_NOT_FOUND
else|:
name|NO_HOST
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
comment|/* distinguish between authoritative or not */
name|h_errno
operator|=
name|bp
operator|->
name|aa
condition|?
name|NO_DATA
else|:
name|NO_RREC
expr_stmt|;
break|break;
default|default:
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nrecords
operator|!=
literal|0
condition|)
name|pr_error
argument_list|(
literal|"unexpected error in answer"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|h_errno
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|nscount
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|pr_error
argument_list|(
literal|"nonzero nscount in answer"
argument_list|)
expr_stmt|;
name|i
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|arcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|pr_error
argument_list|(
literal|"nonzero arcount in answer"
argument_list|)
expr_stmt|;
comment|/* 	 * Valid packet received. Print contents if appropriate. 	 */
name|nrecords
operator|++
expr_stmt|;
name|soaname
operator|=
name|NULL
expr_stmt|;
name|subname
operator|=
name|NULL
expr_stmt|;
name|adrname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|n
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Terminate upon the second SOA record for this zone. 	 */
if|if
condition|(
name|soaname
operator|&&
name|sameword
argument_list|(
name|soaname
argument_list|,
name|name
argument_list|)
condition|)
if|if
condition|(
name|soacount
operator|++
condition|)
break|break;
comment|/* the nameserver balks on this one */
if|if
condition|(
name|soaname
operator|&&
operator|!
name|sameword
argument_list|(
name|soaname
argument_list|,
name|name
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous SOA record for %s within %s"
argument_list|,
name|soaname
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Save encountered delegated zone name for recursive listing. 	 */
if|if
condition|(
name|subname
operator|&&
name|indomain
argument_list|(
name|subname
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zonecount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|zonename
index|[
name|i
index|]
argument_list|,
name|subname
argument_list|)
condition|)
break|break;
comment|/* duplicate */
if|if
condition|(
name|i
operator|>=
name|zonecount
condition|)
block|{
name|zonename
operator|=
name|newlist
argument_list|(
name|zonename
argument_list|,
name|zonecount
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|zonename
index|[
name|zonecount
index|]
operator|=
name|newstr
argument_list|(
name|subname
argument_list|)
expr_stmt|;
name|zonecount
operator|++
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|obsolete
comment|/* not sure whether this is illegal or not (no, it's not) */
if|if
condition|(
name|subname
operator|&&
operator|!
name|samedomain
argument_list|(
name|subname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous NS record for %s within %s"
argument_list|,
name|subname
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* warn about strange delegated zones */
if|if
condition|(
name|subname
operator|&&
operator|!
name|indomain
argument_list|(
name|subname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous NS record for %s within %s"
argument_list|,
name|subname
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Save encountered name of A record for hostname count. 	 */
if|if
condition|(
name|adrname
operator|&&
name|indomain
argument_list|(
name|adrname
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
operator|&&
operator|!
name|reverse
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hostcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|hostname
index|[
name|i
index|]
argument_list|,
name|adrname
argument_list|)
condition|)
break|break;
comment|/* duplicate */
if|if
condition|(
name|i
operator|<
name|hostcount
operator|&&
name|address
operator|!=
name|hostaddr
index|[
name|i
index|]
condition|)
name|multaddr
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|hostcount
operator|&&
name|hostcount
operator|<
name|MAXHOSTS
condition|)
block|{
name|hostname
index|[
name|hostcount
index|]
operator|=
name|newstr
argument_list|(
name|adrname
argument_list|)
expr_stmt|;
name|hostaddr
index|[
name|hostcount
index|]
operator|=
name|address
expr_stmt|;
name|multaddr
index|[
name|hostcount
index|]
operator|=
name|FALSE
expr_stmt|;
name|hostcount
operator|++
expr_stmt|;
if|if
condition|(
name|hostcount
operator|==
name|MAXHOSTS
condition|)
name|pr_error
argument_list|(
literal|"maximum number of %s hostnames reached"
argument_list|,
name|itoa
argument_list|(
name|hostcount
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check for unauthoritative glue records */
if|if
condition|(
name|adrname
operator|&&
operator|!
name|indomain
argument_list|(
name|adrname
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous glue record for %s within %s"
argument_list|,
name|adrname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*  * End of zone transfer at second SOA record or zero length read.  */
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/*  * Check for the anomaly that the whole transfer consisted of the  * SOA records only. Could occur if we queried the victim of a lame  * delegation which happened to have the SOA record present.  */
if|if
condition|(
name|nrecords
operator|<=
name|soacount
condition|)
block|{
name|pr_error
argument_list|(
literal|"empty transfer for %s from %s"
argument_list|,
name|name
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RREC
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Do extra check for hostnames also defined as delegated zones.  * They may have been defined in the child zone, and crept in  * the parent zone, or may have been defined as glue records.  * This is not necessarily an error, but the hostname count may  * be actually wrong. Leave it in for the time being.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hostcount
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zonecount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sameword
argument_list|(
name|hostname
index|[
name|n
index|]
argument_list|,
name|zonename
index|[
name|i
index|]
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"extraneous A record for %s within %s"
argument_list|,
name|hostname
index|[
name|n
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Transfer complete, %d records received for %s\n"
argument_list|,
name|nrecords
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_MXREC -- Fetch MX records of a domain ** ----------------------------------------- ** **	Returns: **		TRUE if MX records were found. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|get_mxrec
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* domain name to get mx for */
block|{
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Finding MX records for %s ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|T_MX
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|anslen
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_PRIMARY -- Fetch name of primary nameserver for a zone ** ---------------------------------------------------------- ** **	Returns: **		Pointer to the name of the primary server, if found. **		NULL if the server could not be determined. */
end_comment

begin_function
name|char
modifier|*
name|get_primary
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to get soa for */
block|{
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Finding primary nameserver for %s ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|T_SOA
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|anslen
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|soaname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|get_soainfo
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soaname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|soa
operator|.
name|pname
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_ZONE -- Fetch and analyze SOA record of a zone ** ---------------------------------------------------- ** **	Returns: **		TRUE if the SOA record was found at the given server. **		FALSE otherwise. ** **	Inputs: **		The global variable server must contain the name **		of the server that was queried. */
end_comment

begin_function
name|bool
name|check_zone
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to get soa for */
block|{
name|querybuf
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Checking SOA for %s at server %s\n"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|authserver
condition|)
name|printf
argument_list|(
literal|"%-20s\tNS\t%s\n"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\t(%s)\n"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|anslen
operator|=
name|get_info
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|,
name|T_SOA
argument_list|,
name|queryclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|anslen
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|print_info
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|soaname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|get_soainfo
argument_list|(
operator|&
name|answer
argument_list|,
name|anslen
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soaname
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|check_soa
argument_list|(
operator|&
name|answer
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GET_SOAINFO -- Extract SOA data from nameserver answer buffer ** ------------------------------------------------------------- ** **	Returns: **		TRUE if the SOA record was found successfully. **		FALSE otherwise. ** **	Outputs: **		The global struct soa is filled with the soa data. ** **	Side effects: **		Sets soaname if this is a valid SOA record. **		This variable must have been cleared before calling **		get_soainfo() and may be checked afterwards. */
end_comment

begin_function
name|bool
name|get_soainfo
parameter_list|(
name|answerbuf
parameter_list|,
name|answerlen
parameter_list|,
name|name
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
name|input
name|int
name|answerlen
decl_stmt|;
comment|/* length of answer buffer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to get soa for */
block|{
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|eom
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
name|answerlen
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answerbuf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdcount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
name|skip_qrec
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|qdcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|qdcount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid qdcount in response"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*  * Check answer section only.  * The nameserver section may contain the nameservers for the zone,  * and the additional section their addresses, but not guaranteed.  */
while|while
condition|(
name|ancount
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|char
name|rname
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|ttl
decl_stmt|,
name|dlen
decl_stmt|;
name|u_char
modifier|*
name|eor
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|name
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|T_NONE
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|eor
operator|=
name|cp
operator|+
name|dlen
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%-20s\t%d\t%s\t%s\n"
argument_list|,
name|rname
argument_list|,
name|ttl
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_SOA
case|:
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|soa
operator|.
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|expand_name
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eom
argument_list|,
name|soa
operator|.
name|mname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_size
argument_list|(
name|rname
argument_list|,
name|type
argument_list|,
name|cp
argument_list|,
name|msg
argument_list|,
name|eor
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|soa
operator|.
name|serial
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|soa
operator|.
name|refresh
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|soa
operator|.
name|retry
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|soa
operator|.
name|expire
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|soa
operator|.
name|defttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
comment|/* valid complete soa record found */
name|soaname
operator|=
name|strcpy
argument_list|(
name|soanamebuf
argument_list|,
name|rname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|!=
name|eor
condition|)
block|{
name|pr_error
argument_list|(
literal|"size error in %s record for %s, off by = %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|rname
argument_list|,
name|itoa
argument_list|(
name|cp
operator|-
name|eor
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|ancount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ancount
condition|)
block|{
name|pr_error
argument_list|(
literal|"invalid ancount in response"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_SOA -- Analyze retrieved SOA records of a zone ** ---------------------------------------------------- ** **	Returns: **		None. ** **	Inputs: **		The global variable server must contain the name **		of the server that was queried. **		The global struct soa must contain the soa data. */
end_comment

begin_function
name|void
name|check_soa
parameter_list|(
name|answerbuf
parameter_list|,
name|name
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone to check soa for */
block|{
specifier|static
name|char
name|oldnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|oldname
init|=
name|NULL
decl_stmt|;
comment|/* previous name of zone */
specifier|static
name|char
modifier|*
name|oldserver
init|=
name|NULL
decl_stmt|;
comment|/* previous name of server */
specifier|static
name|soa_data_t
name|oldsoa
decl_stmt|;
comment|/* previous soa data */
specifier|register
name|int
name|n
decl_stmt|;
name|HEADER
modifier|*
name|bp
decl_stmt|;
comment|/*  * Print the various SOA fields in abbreviated form.  * Values are actually unsigned, but we print them as signed integers.  */
name|printf
argument_list|(
literal|"%s\t%s\t(%d %d %d %d %d)\n"
argument_list|,
name|soa
operator|.
name|pname
argument_list|,
name|soa
operator|.
name|mname
argument_list|,
name|soa
operator|.
name|serial
argument_list|,
name|soa
operator|.
name|refresh
argument_list|,
name|soa
operator|.
name|retry
argument_list|,
name|soa
operator|.
name|expire
argument_list|,
name|soa
operator|.
name|defttl
argument_list|)
expr_stmt|;
comment|/*  * We are supposed to have queried an authoritative nameserver, and since  * nameserver recursion has been turned off, answer must be authoritative.  */
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|->
name|aa
condition|)
block|{
if|if
condition|(
name|authserver
condition|)
name|pr_error
argument_list|(
literal|"SOA record for %s at %s is not authoritative"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|pr_warning
argument_list|(
literal|"SOA record for %s at %s is not authoritative"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|authserver
condition|)
name|errmsg
argument_list|(
literal|"%s has lame delegation to %s"
argument_list|,
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
comment|/*  * Check whether we are switching to a new zone.  * The old name must have been saved in static storage.  */
if|if
condition|(
name|oldname
operator|!=
name|NULL
operator|&&
operator|!
name|sameword
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|)
condition|)
name|oldname
operator|=
name|NULL
expr_stmt|;
comment|/*  * Make few timer consistency checks only for the first one in a series.  * Compare the primary field against the list of authoritative servers.  * Explicitly check the hostmaster field for illegal characters ('@').  */
if|if
condition|(
name|oldname
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nservers
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|soa
operator|.
name|pname
argument_list|,
name|nsname
index|[
name|n
index|]
argument_list|)
condition|)
break|break;
comment|/* found */
if|if
condition|(
name|n
operator|>=
name|nservers
operator|&&
name|authserver
condition|)
name|pr_warning
argument_list|(
literal|"SOA for %s has extraneous primary"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_name
argument_list|(
name|soa
operator|.
name|mname
argument_list|,
name|FALSE
argument_list|)
condition|)
name|pr_warning
argument_list|(
literal|"SOA for %s has illegal hostmaster"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa
operator|.
name|serial
operator|<
literal|0
condition|)
name|pr_warning
argument_list|(
literal|"SOA for %s has extraneous serial"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa
operator|.
name|retry
operator|>
name|soa
operator|.
name|refresh
condition|)
name|pr_warning
argument_list|(
literal|"SOA for %s has retry exceeding refresh"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa
operator|.
name|refresh
operator|+
name|soa
operator|.
name|retry
operator|>
name|soa
operator|.
name|expire
condition|)
name|pr_warning
argument_list|(
literal|"SOA for %s has refresh+retry exceeding expire"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*  * Compare various fields with those of the previous query, if any.  * Different serial numbers may be present if secondaries have not yet  * refreshed the data from the primary. Issue only a warning in that case.  */
if|if
condition|(
name|oldname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|soa
operator|.
name|pname
argument_list|,
name|oldsoa
operator|.
name|pname
argument_list|)
condition|)
name|pr_error
argument_list|(
literal|"%s has different primary than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|soa
operator|.
name|mname
argument_list|,
name|oldsoa
operator|.
name|mname
argument_list|)
condition|)
name|pr_error
argument_list|(
literal|"%s has different hostmaster than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa
operator|.
name|serial
operator|!=
name|oldsoa
operator|.
name|serial
condition|)
name|pr_warning
argument_list|(
literal|"%s has different serial than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa
operator|.
name|refresh
operator|!=
name|oldsoa
operator|.
name|refresh
condition|)
name|pr_error
argument_list|(
literal|"%s has different refresh than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa
operator|.
name|retry
operator|!=
name|oldsoa
operator|.
name|retry
condition|)
name|pr_error
argument_list|(
literal|"%s has different retry than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa
operator|.
name|expire
operator|!=
name|oldsoa
operator|.
name|expire
condition|)
name|pr_error
argument_list|(
literal|"%s has different expire than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa
operator|.
name|defttl
operator|!=
name|oldsoa
operator|.
name|defttl
condition|)
name|pr_error
argument_list|(
literal|"%s has different defttl than %s"
argument_list|,
name|server
argument_list|,
name|oldserver
argument_list|)
expr_stmt|;
block|}
comment|/*  * Save the current information.  */
name|oldname
operator|=
name|strcpy
argument_list|(
name|oldnamebuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|oldserver
operator|=
name|server
expr_stmt|;
name|oldsoa
operator|=
name|soa
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_DUPL -- Check global address list for duplicates ** ------------------------------------------------------ ** **	Returns: **		TRUE if the given host address already exists. **		FALSE otherwise. ** **	Side effects: **		Adds the host address to the list if not present. */
end_comment

begin_function
name|bool
name|check_dupl
parameter_list|(
name|addr
parameter_list|)
name|input
name|ipaddr_t
name|addr
decl_stmt|;
comment|/* address of host to check */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|addr_data_t
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|&
name|hlist
index|[
name|ntohl
argument_list|(
name|addr
argument_list|)
operator|&
name|AHASHMASK
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|addrcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|h
operator|->
name|addrlist
index|[
name|i
index|]
operator|==
name|addr
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* duplicate */
name|h
operator|->
name|addrlist
operator|=
name|newlist
argument_list|(
name|h
operator|->
name|addrlist
argument_list|,
name|h
operator|->
name|addrcount
operator|+
literal|1
argument_list|,
name|ipaddr_t
argument_list|)
expr_stmt|;
name|h
operator|->
name|addrlist
index|[
name|h
operator|->
name|addrcount
index|]
operator|=
name|addr
expr_stmt|;
name|h
operator|->
name|addrcount
operator|++
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|obsolete
end_ifdef

begin_define
define|#
directive|define
name|NETWORK_MASK
value|((ipaddr_t)0xffff0000)
end_define

begin_define
define|#
directive|define
name|nethash
parameter_list|(
name|a
parameter_list|)
value|((a)& htonl(NETWORK_MASK))
end_define

begin_function
name|bool
name|check_dupl
parameter_list|(
name|addr
parameter_list|)
name|input
name|ipaddr_t
name|addr
decl_stmt|;
comment|/* address of host to check */
block|{
name|ipaddr_t
name|network
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|net_data_t
modifier|*
name|h
decl_stmt|;
comment|/*  * Extract the (peudo) network part from the address.  */
name|network
operator|=
name|nethash
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/*  * Check whether we already have a list for this network.  * If not, allocate a new empty address list.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|netcount
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|netlist
index|[
name|n
index|]
operator|.
name|network
operator|==
name|network
condition|)
break|break;
comment|/* network is known */
if|if
condition|(
name|n
operator|>=
name|netcount
condition|)
block|{
name|netlist
operator|=
name|newlist
argument_list|(
name|netlist
argument_list|,
name|netcount
operator|+
literal|1
argument_list|,
name|net_data_t
argument_list|)
expr_stmt|;
name|netlist
index|[
name|netcount
index|]
operator|.
name|network
operator|=
name|network
expr_stmt|;
name|netlist
index|[
name|netcount
index|]
operator|.
name|addrlist
operator|=
name|NULL
expr_stmt|;
name|netlist
index|[
name|netcount
index|]
operator|.
name|addrcount
operator|=
literal|0
expr_stmt|;
name|netcount
operator|++
expr_stmt|;
block|}
comment|/* the hash list for this network */
name|h
operator|=
operator|&
name|netlist
index|[
name|n
index|]
expr_stmt|;
comment|/*  * Check whether the address exists on the list for that network.  * If not, add it to the address list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|addrcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|h
operator|->
name|addrlist
index|[
name|i
index|]
operator|==
name|addr
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* duplicate */
name|h
operator|->
name|addrlist
operator|=
name|newlist
argument_list|(
name|h
operator|->
name|addrlist
argument_list|,
name|h
operator|->
name|addrcount
operator|+
literal|1
argument_list|,
name|ipaddr_t
argument_list|)
expr_stmt|;
name|h
operator|->
name|addrlist
index|[
name|h
operator|->
name|addrcount
index|]
operator|=
name|addr
expr_stmt|;
name|h
operator|->
name|addrcount
operator|++
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|check_dupl
parameter_list|(
name|addr
parameter_list|)
name|input
name|ipaddr_t
name|addr
decl_stmt|;
comment|/* address of host to check */
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|addrlist
index|[
name|i
index|]
operator|==
name|addr
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* duplicate */
name|addrlist
operator|=
name|newlist
argument_list|(
name|addrlist
argument_list|,
name|addrcount
operator|+
literal|1
argument_list|,
name|ipaddr_t
argument_list|)
expr_stmt|;
name|addrlist
index|[
name|addrcount
index|]
operator|=
name|addr
expr_stmt|;
name|addrcount
operator|++
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_ADDR -- Check if reverse address mappings revert to host ** -------------------------------------------------------------- ** **	Returns: **		TRUE if all addresses of host map back to host. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|check_addr
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* hostname to check addresses for */
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|in_addr
name|inaddr
index|[
name|MAXADDRS
index|]
decl_stmt|;
name|int
name|naddr
decl_stmt|;
name|char
name|hnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|hname
decl_stmt|;
name|int
name|matched
decl_stmt|;
comment|/*  * Look up the specified host to fetch its addresses.  */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|name
argument_list|,
name|T_A
argument_list|,
name|C_IN
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|hname
operator|=
name|strcpy
argument_list|(
name|hnamebuf
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXADDRS
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|inaddr
index|[
name|i
index|]
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|naddr
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d address%s for %s\n"
argument_list|,
name|naddr
argument_list|,
name|naddr
operator|==
literal|1
condition|?
literal|""
else|:
literal|"es"
argument_list|,
name|hname
argument_list|)
expr_stmt|;
comment|/*  * Map back the addresses found, and check if they revert to host.  */
for|for
control|(
name|matched
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddr
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|iname
init|=
name|inet_ntoa
argument_list|(
name|inaddr
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|ipaddr_t
name|addr
init|=
name|inaddr
index|[
name|i
index|]
operator|.
name|s_addr
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Checking %s address %s\n"
argument_list|,
name|hname
argument_list|,
name|iname
argument_list|)
expr_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
name|ns_error
argument_list|(
name|iname
argument_list|,
name|T_PTR
argument_list|,
name|C_IN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
name|hname
argument_list|)
condition|)
name|pr_error
argument_list|(
literal|"address %s of %s maps to %s"
argument_list|,
name|iname
argument_list|,
name|hname
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
else|else
name|matched
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|matched
operator|==
name|naddr
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_NAME -- Check if address belongs to host addresses ** -------------------------------------------------------- ** **	Returns: **		TRUE if given address was found among host addresses. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|check_name
parameter_list|(
name|addr
parameter_list|)
name|input
name|ipaddr_t
name|addr
decl_stmt|;
comment|/* address of host to check */
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|char
name|hnamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|hname
decl_stmt|;
name|char
name|inamebuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|iname
decl_stmt|;
name|int
name|matched
decl_stmt|;
comment|/*  * Check if the address is registered by fetching its hostname.  */
name|inaddr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|iname
operator|=
name|strcpy
argument_list|(
name|inamebuf
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|iname
argument_list|,
name|T_PTR
argument_list|,
name|C_IN
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|hname
operator|=
name|strcpy
argument_list|(
name|hnamebuf
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Address %s maps to %s\n"
argument_list|,
name|iname
argument_list|,
name|hname
argument_list|)
expr_stmt|;
comment|/*  * Lookup the hostname found to fetch its addresses.  * Check if the given address is listed among the known addresses.  */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|hname
argument_list|,
name|T_A
argument_list|,
name|C_IN
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
for|for
control|(
name|matched
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|inaddr
operator|=
name|incopy
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Checking %s address %s\n"
argument_list|,
name|hname
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inaddr
operator|.
name|s_addr
operator|==
name|addr
condition|)
name|matched
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
name|pr_error
argument_list|(
literal|"address %s does not belong to %s"
argument_list|,
name|iname
argument_list|,
name|hname
argument_list|)
expr_stmt|;
return|return
operator|(
name|matched
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PARSE_TYPE -- Decode rr type from input string ** ---------------------------------------------- ** **	Returns: **		Value of resource record type. **		-1 if specified record name is invalid. ** **	Note.	T_MD, T_MF, T_MAILA are obsolete, but recognized. **		T_AXFR is not allowed to be specified as query type. */
end_comment

begin_function
name|int
name|parse_type
parameter_list|(
name|str
parameter_list|)
name|input
name|char
modifier|*
name|str
decl_stmt|;
comment|/* input string with record type */
block|{
specifier|register
name|int
name|type
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"A"
argument_list|)
condition|)
return|return
operator|(
name|T_A
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"NS"
argument_list|)
condition|)
return|return
operator|(
name|T_NS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MD"
argument_list|)
condition|)
return|return
operator|(
name|T_MD
operator|)
return|;
comment|/* obsolete */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MF"
argument_list|)
condition|)
return|return
operator|(
name|T_MF
operator|)
return|;
comment|/* obsolete */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"CNAME"
argument_list|)
condition|)
return|return
operator|(
name|T_CNAME
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"SOA"
argument_list|)
condition|)
return|return
operator|(
name|T_SOA
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MB"
argument_list|)
condition|)
return|return
operator|(
name|T_MB
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MG"
argument_list|)
condition|)
return|return
operator|(
name|T_MG
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MR"
argument_list|)
condition|)
return|return
operator|(
name|T_MR
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"NULL"
argument_list|)
condition|)
return|return
operator|(
name|T_NULL
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"WKS"
argument_list|)
condition|)
return|return
operator|(
name|T_WKS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"PTR"
argument_list|)
condition|)
return|return
operator|(
name|T_PTR
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"HINFO"
argument_list|)
condition|)
return|return
operator|(
name|T_HINFO
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MINFO"
argument_list|)
condition|)
return|return
operator|(
name|T_MINFO
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MX"
argument_list|)
condition|)
return|return
operator|(
name|T_MX
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"TXT"
argument_list|)
condition|)
return|return
operator|(
name|T_TXT
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"RP"
argument_list|)
condition|)
return|return
operator|(
name|T_RP
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"AFSDB"
argument_list|)
condition|)
return|return
operator|(
name|T_AFSDB
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"X25"
argument_list|)
condition|)
return|return
operator|(
name|T_X25
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"ISDN"
argument_list|)
condition|)
return|return
operator|(
name|T_ISDN
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"RT"
argument_list|)
condition|)
return|return
operator|(
name|T_RT
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"NSAP"
argument_list|)
condition|)
return|return
operator|(
name|T_NSAP
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"NSAP-PTR"
argument_list|)
condition|)
return|return
operator|(
name|T_NSAPPTR
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"UINFO"
argument_list|)
condition|)
return|return
operator|(
name|T_UINFO
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"UID"
argument_list|)
condition|)
return|return
operator|(
name|T_UID
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"GID"
argument_list|)
condition|)
return|return
operator|(
name|T_GID
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"UNSPEC"
argument_list|)
condition|)
return|return
operator|(
name|T_UNSPEC
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"AXFR"
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* illegal */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MAILB"
argument_list|)
condition|)
return|return
operator|(
name|T_MAILB
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"MAILA"
argument_list|)
condition|)
return|return
operator|(
name|T_MAILA
operator|)
return|;
comment|/* obsolete */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"ANY"
argument_list|)
condition|)
return|return
operator|(
name|T_ANY
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"*"
argument_list|)
condition|)
return|return
operator|(
name|T_ANY
operator|)
return|;
name|type
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|T_FIRST
operator|&&
name|type
operator|<=
name|T_LAST
condition|)
return|return
operator|(
name|type
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PARSE_CLASS -- Decode rr class from input string ** ------------------------------------------------ ** **	Returns: **		Value of resource class. **		-1 if specified class name is invalid. ** **	Note.	C_CSNET is obsolete, but recognized. */
end_comment

begin_function
name|int
name|parse_class
parameter_list|(
name|str
parameter_list|)
name|input
name|char
modifier|*
name|str
decl_stmt|;
comment|/* input string with resource class */
block|{
specifier|register
name|int
name|class
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"IN"
argument_list|)
condition|)
return|return
operator|(
name|C_IN
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"INTERNET"
argument_list|)
condition|)
return|return
operator|(
name|C_IN
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"CS"
argument_list|)
condition|)
return|return
operator|(
name|C_CSNET
operator|)
return|;
comment|/* obsolete */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"CSNET"
argument_list|)
condition|)
return|return
operator|(
name|C_CSNET
operator|)
return|;
comment|/* obsolete */
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"CH"
argument_list|)
condition|)
return|return
operator|(
name|C_CHAOS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"CHAOS"
argument_list|)
condition|)
return|return
operator|(
name|C_CHAOS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"HS"
argument_list|)
condition|)
return|return
operator|(
name|C_HS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"HESIOD"
argument_list|)
condition|)
return|return
operator|(
name|C_HS
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"ANY"
argument_list|)
condition|)
return|return
operator|(
name|C_ANY
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|str
argument_list|,
literal|"*"
argument_list|)
condition|)
return|return
operator|(
name|C_ANY
operator|)
return|;
name|class
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|>
literal|0
condition|)
return|return
operator|(
name|class
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** IN_ADDR_ARPA -- Convert dotted quad string to reverse in-addr.arpa ** ------------------------------------------------------------------ ** **	Returns: **		Pointer to reverse in-addr.arpa. zone name **		with trailing dot to force absolute domain name. **		NULL in case of invalid dotted quad input string. */
end_comment

begin_function
name|char
modifier|*
name|in_addr_arpa
parameter_list|(
name|dottedquad
parameter_list|)
name|input
name|char
modifier|*
name|dottedquad
decl_stmt|;
comment|/* input string with dotted quad */
block|{
specifier|static
name|char
name|addrbuf
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|int
name|a
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|dottedquad
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
operator|&
name|a
index|[
literal|0
index|]
argument_list|,
operator|&
name|a
index|[
literal|1
index|]
argument_list|,
operator|&
name|a
index|[
literal|2
index|]
argument_list|,
operator|&
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|4
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addrbuf
argument_list|,
literal|"%u.%u.%u.%u.in-addr.arpa."
argument_list|,
name|a
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addrbuf
argument_list|,
literal|"%u.%u.%u.in-addr.arpa."
argument_list|,
name|a
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addrbuf
argument_list|,
literal|"%u.%u.in-addr.arpa."
argument_list|,
name|a
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|a
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addrbuf
argument_list|,
literal|"%u.in-addr.arpa."
argument_list|,
name|a
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
name|a
index|[
name|n
index|]
operator|>
literal|255
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|addrbuf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_HOST -- Print hostname and address of hostent struct ** ---------------------------------------------------------- ** **	Returns: **		None. */
end_comment

begin_function
name|void
name|print_host
parameter_list|(
name|heading
parameter_list|,
name|hp
parameter_list|)
name|input
name|char
modifier|*
name|heading
decl_stmt|;
comment|/* header string */
name|input
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
comment|/* address of hostent struct */
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|printf
argument_list|(
literal|"%s: %s"
argument_list|,
name|heading
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|hp
operator|->
name|h_addr_list
init|;
name|ap
operator|&&
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|==
name|hp
operator|->
name|h_addr_list
condition|)
name|printf
argument_list|(
literal|"\nAddress:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|incopy
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ap
operator|=
name|hp
operator|->
name|h_aliases
init|;
name|ap
operator|&&
operator|*
name|ap
operator|&&
operator|*
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|==
name|hp
operator|->
name|h_aliases
condition|)
name|printf
argument_list|(
literal|"\nAliases:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** SHOW_RES -- Show resolver database information ** ---------------------------------------------- ** **	Returns: **		None. ** **	Inputs: **		The resolver database _res is localized in the resolver. */
end_comment

begin_function
name|void
name|show_res
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|domain
decl_stmt|;
comment|/*  * The default domain is defined by the "domain" entry in /etc/resolv.conf  * if not overridden by the environment variable "LOCALDOMAIN".  * If still not defined, gethostname() may yield a fully qualified hostname.  */
name|printf
argument_list|(
literal|"Default domain:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_res
operator|.
name|defdname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|_res
operator|.
name|defdname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*  * The search domains are extracted from the default domain components,  * but may be overridden by "search" directives in /etc/resolv.conf  * since 4.8.3.  */
name|printf
argument_list|(
literal|"Search domains:"
argument_list|)
expr_stmt|;
for|for
control|(
name|domain
operator|=
name|_res
operator|.
name|dnsrch
init|;
operator|*
name|domain
condition|;
name|domain
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*  * The routine res_send() will do _res.retry tries to contact each of the  * _res.nscount nameserver addresses before giving up when using datagrams.  * The first try will timeout after _res.retrans seconds. Each following  * try will timeout after ((_res.retrans<< try) / _res.nscount) seconds.  * Note. When we contact an explicit server the addresses will be replaced  * by the multiple addresses of the same server.  * When doing a zone transfer _res.retrans is used for the connect timeout.  */
name|printf
argument_list|(
literal|"Timeout per retry: %d secs\n"
argument_list|,
name|_res
operator|.
name|retrans
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Number of retries: %d\n"
argument_list|,
name|_res
operator|.
name|retry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Number of addresses: %d\n"
argument_list|,
name|_res
operator|.
name|nscount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|nslist
argument_list|(
name|i
argument_list|)
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  * The resolver options are initialized by res_init() to contain the  * defaults settings (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)  * The various options have the following meaning:  *  *	RES_INIT	set after res_init() has been called  *	RES_DEBUG	let the resolver modules print debugging info  *	RES_AAONLY	want authoritative answers only (not implemented)  *	RES_USEVC	use tcp virtual circuit instead of udp datagrams  *	RES_PRIMARY	use primary nameserver only (not implemented)  *	RES_IGNTC	ignore datagram truncation; don't switch to tcp  *	RES_RECURSE	forward query if answer not locally available  *	RES_DEFNAMES	add default domain to queryname without dot  *	RES_STAYOPEN	keep tcp socket open for subsequent queries  *	RES_DNSRCH	append search domains even to queryname with dot  */
name|printf
argument_list|(
literal|"Options set:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_INIT
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" INIT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_DEBUG
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_AAONLY
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" AAONLY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_USEVC
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" USEVC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_PRIMARY
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PRIMARY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_IGNTC
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" IGNTC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_RECURSE
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" RECURSE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_DEFNAMES
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DEFNAMES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_STAYOPEN
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" STAYOPEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RES_DNSRCH
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DNSRCH"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Options clr:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_INIT
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" INIT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DEBUG
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_AAONLY
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" AAONLY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_USEVC
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" USEVC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_PRIMARY
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" PRIMARY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_IGNTC
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" IGNTC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_RECURSE
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" RECURSE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DEFNAMES
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DEFNAMES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_STAYOPEN
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" STAYOPEN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_DNSRCH
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
name|printf
argument_list|(
literal|" DNSRCH"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_STATISTICS -- Print resource record statistics ** ---------------------------------------------------- ** **	Returns: **		None. ** **	Inputs: **		The record_stats[] counts have been updated by print_rrec(). */
end_comment

begin_function
name|void
name|print_statistics
parameter_list|(
name|name
parameter_list|,
name|filter
parameter_list|,
name|class
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of zone we are listing */
name|input
name|int
name|filter
decl_stmt|;
comment|/* type of records we want to see */
name|input
name|int
name|class
decl_stmt|;
comment|/* class of records we want to see */
block|{
specifier|register
name|int
name|type
decl_stmt|;
name|int
name|nrecords
decl_stmt|;
for|for
control|(
name|type
operator|=
name|T_FIRST
init|;
name|type
operator|<=
name|T_LAST
condition|;
name|type
operator|++
control|)
block|{
name|nrecords
operator|=
name|record_stats
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|nrecords
operator|>
literal|0
operator|||
operator|(
name|filter
operator|!=
name|T_ANY
operator|&&
name|want_type
argument_list|(
name|type
argument_list|,
name|filter
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Found %4d %-5s record%s"
argument_list|,
name|nrecords
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|nrecords
operator|==
literal|1
condition|?
literal|" "
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|printf
argument_list|(
literal|" in class %s"
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" within %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** CLEAR_STATISTICS -- Clear resource record statistics ** ---------------------------------------------------- ** **	Returns: **		None. */
end_comment

begin_function
name|void
name|clear_statistics
parameter_list|()
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|record_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|record_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** SHOW_TYPES -- Show resource record types wanted ** ----------------------------------------------- ** **	Returns: **		None. */
end_comment

begin_function
name|void
name|show_types
parameter_list|(
name|name
parameter_list|,
name|filter
parameter_list|,
name|class
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name we want to query about */
name|input
name|int
name|filter
decl_stmt|;
comment|/* type of records we want to see */
name|input
name|int
name|class
decl_stmt|;
comment|/* class of records we want to see */
block|{
specifier|register
name|int
name|type
decl_stmt|;
if|if
condition|(
name|filter
operator|>=
name|T_NONE
condition|)
block|{
name|printf
argument_list|(
literal|"Query about %s for record types"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|==
name|T_ANY
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|pr_type
argument_list|(
name|T_ANY
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|type
operator|=
name|T_FIRST
init|;
name|type
operator|<=
name|T_LAST
condition|;
name|type
operator|++
control|)
if|if
condition|(
name|want_type
argument_list|(
name|type
argument_list|,
name|filter
argument_list|)
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|printf
argument_list|(
literal|" in class %s"
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** NS_ERROR -- Print error message from errno and h_errno ** ------------------------------------------------------ ** **	Returns: **		None. ** **	Inputs: **		The global variable server, if set, contains **		the name of the server that was contacted. */
end_comment

begin_function
name|void
name|ns_error
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* full name we queried about */
name|input
name|int
name|type
decl_stmt|;
comment|/* record type we queried about */
name|input
name|int
name|class
decl_stmt|;
comment|/* record class we queried about */
block|{
specifier|static
name|char
modifier|*
name|auth
init|=
literal|"Authoritative answer"
decl_stmt|;
comment|/*  * If res_send() fails, it will leave errno in either of the first two  * following states when using datagrams. Note that this depends on the  * proper handling of connected datagram sockets, which is usually true  * if BSD>= 43 (see res_send.c for details; it may need a patch).  * Note. If it succeeds, it may leave errno in the state EAFNOSUPPORT  * if it has disconnected a previously connected datagram socket, since  * the dummy address used to disconnect does not have a proper family set.  * Always clear errno after getting a reply, or patch res_send().  * Our private version of res_send() will leave also other error statuses.  */
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ECONNREFUSED
case|:
comment|/* 		 * The contacted host does not have a nameserver running. 		 * The standard res_send() also returns this if none of 		 * the intended hosts could be reached via datagrams. 		 */
if|if
condition|(
name|server
condition|)
name|errmsg
argument_list|(
literal|"Nameserver %s not running"
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"Nameserver not running"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIMEDOUT
case|:
comment|/* 		 * The contacted server did not give any reply at all 		 * within the specified time frame. 		 */
if|if
condition|(
name|server
condition|)
name|errmsg
argument_list|(
literal|"Nameserver %s not responding"
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"Nameserver not responding"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
comment|/* 		 * The host to be contacted or its network can not be reached. 		 * Our private res_send() also returns this using datagrams. 		 */
if|if
condition|(
name|server
condition|)
name|errmsg
argument_list|(
literal|"Nameserver %s not reachable"
argument_list|,
name|server
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"Nameserver not reachable"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  * Print the message associated with the particular nameserver error.  */
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
comment|/* 		 * The specified name does definitely not exist at all. 		 * In this case the answer is always authoritative. 		 * Nameserver status: NXDOMAIN 		 */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|errmsg
argument_list|(
literal|"%s does not exist in class %s (%s)"
argument_list|,
name|name
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|auth
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"%s does not exist (%s)"
argument_list|,
name|name
argument_list|,
name|auth
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_HOST
case|:
comment|/* 		 * The specified name does not exist, but the answer 		 * was not authoritative, so it is still undecided. 		 * Happens when querying unknown name for class C_ANY. 		 * Nameserver status: NXDOMAIN 		 */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|errmsg
argument_list|(
literal|"%s does not exist in class %s, try again"
argument_list|,
name|name
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"%s does not exist, try again"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
comment|/* 		 * Some intermediate server failure, e.g. timeout, or when 		 * the server is not authoritative for a specific class. 		 * Nameserver status: SERVFAIL 		 */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|errmsg
argument_list|(
literal|"%s %s record in class %s not found, try again"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"%s %s record not found, try again"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
comment|/* 		 * Some irrecoverable format error, or server refusal. 		 * Nameserver status: FORMERR NOTIMP REFUSED NOCHANGE 		 */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|errmsg
argument_list|(
literal|"%s %s record in class %s not found, no recovery"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"%s %s record not found, no recovery"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_DATA
case|:
comment|/* 		 * The name is valid, but the specified type does not exist. 		 * This status is here returned only in case authoritative. 		 * Nameserver status: NOERROR 		 */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|errmsg
argument_list|(
literal|"%s has no %s record in class %s (%s)"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|auth
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"%s has no %s record (%s)"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|auth
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_RREC
case|:
comment|/* 		 * The specified type does not exist, but we don't know whether 		 * the name is valid or not. The answer was not authoritative. 		 * Perhaps recursion was off, and no data was cached locally. 		 * Nameserver status: NOERROR 		 */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|errmsg
argument_list|(
literal|"%s %s record in class %s currently not present"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"%s %s record currently not present"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Unknown cause for server failure. 		 */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
name|errmsg
argument_list|(
literal|"%s %s record in class %s not found"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|errmsg
argument_list|(
literal|"%s %s record not found"
argument_list|,
name|name
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** DECODE_ERROR -- Convert nameserver error code to error message ** -------------------------------------------------------------- ** **	Returns: **		Pointer to appropriate error message. */
end_comment

begin_function
name|char
modifier|*
name|decode_error
parameter_list|(
name|error
parameter_list|)
name|input
name|int
name|error
decl_stmt|;
comment|/* error code from bp->rcode */
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|NOERROR
case|:
return|return
operator|(
literal|"no error"
operator|)
return|;
case|case
name|FORMERR
case|:
return|return
operator|(
literal|"format error"
operator|)
return|;
case|case
name|SERVFAIL
case|:
return|return
operator|(
literal|"server failed"
operator|)
return|;
case|case
name|NXDOMAIN
case|:
return|return
operator|(
literal|"non-existent domain"
operator|)
return|;
case|case
name|NOTIMP
case|:
return|return
operator|(
literal|"not implemented"
operator|)
return|;
case|case
name|REFUSED
case|:
return|return
operator|(
literal|"query refused"
operator|)
return|;
case|case
name|NOCHANGE
case|:
return|return
operator|(
literal|"no change"
operator|)
return|;
block|}
return|return
operator|(
literal|"unknown error"
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PRINT_STATUS -- Print result status after nameserver query ** ---------------------------------------------------------- ** **	Returns: **		None. ** **	Conditions: **		The size of the answer buffer must have been **		checked before to be of sufficient length, **		i.e. to contain at least the buffer header. */
end_comment

begin_function
name|void
name|print_status
parameter_list|(
name|answerbuf
parameter_list|)
name|input
name|querybuf
modifier|*
name|answerbuf
decl_stmt|;
comment|/* address of answer buffer */
block|{
name|HEADER
modifier|*
name|bp
decl_stmt|;
name|int
name|ancount
decl_stmt|;
name|bool
name|failed
decl_stmt|;
name|bp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answerbuf
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|bp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|failed
operator|=
operator|(
name|bp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|ancount
operator|==
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Query %s, %d answer%s%s, %sstatus: %s\n"
argument_list|,
name|failed
condition|?
literal|"failed"
else|:
literal|"done"
argument_list|,
name|ancount
argument_list|,
name|ancount
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|bp
operator|->
name|tc
condition|?
literal|" (truncated)"
else|:
literal|""
argument_list|,
name|bp
operator|->
name|aa
condition|?
literal|"authoritative "
else|:
literal|""
argument_list|,
name|decode_error
argument_list|(
operator|(
name|int
operator|)
name|bp
operator|->
name|rcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PR_ERROR -- Print error message about encountered inconsistencies ** ----------------------------------------------------------------- ** **	We are supposed to have an error condition which is fatal **	for normal continuation, and the message is always printed. ** **	Returns: **		None. ** **	Side effects: **		Increments the global error count. */
end_comment

begin_function
name|void
comment|/*VARARGS1*/
name|pr_error
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
name|input
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_function

begin_comment
comment|/* optional arguments */
end_comment

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" *** "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* flag an error */
name|Errors
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** PR_WARNING -- Print warning message about encountered inconsistencies ** --------------------------------------------------------------------- ** **	We are supposed to have an error condition which is non-fatal **	for normal continuation, and the message is suppressed in case **	quiet mode has been selected. ** **	Returns: **		None. */
end_comment

begin_function
name|void
comment|/*VARARGS1*/
name|pr_warning
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|input
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format of message */
name|input
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_function

begin_comment
comment|/* optional arguments */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" !!! "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** WANT_TYPE -- Indicate whether the rr type matches the desired filter ** -------------------------------------------------------------------- ** **	Returns: **		TRUE if the resource record type matches the filter. **		FALSE otherwise. ** **	In regular mode, the querytype is used to formulate the query, **	and the filter is set to T_ANY to filter out any response. **	In listmode, we get everything, so the filter is set to the **	querytype to filter out the proper responses. **	Note that T_NONE is the default querytype in listmode. */
end_comment

begin_function
name|bool
name|want_type
parameter_list|(
name|type
parameter_list|,
name|filter
parameter_list|)
name|input
name|int
name|type
decl_stmt|;
comment|/* resource record type */
name|input
name|int
name|filter
decl_stmt|;
comment|/* type of records we want to see */
block|{
if|if
condition|(
name|type
operator|==
name|filter
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|T_ANY
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|T_NONE
operator|&&
operator|(
name|type
operator|==
name|T_A
operator|||
name|type
operator|==
name|T_NS
operator|||
name|type
operator|==
name|T_PTR
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|T_MAILB
operator|&&
operator|(
name|type
operator|==
name|T_MB
operator|||
name|type
operator|==
name|T_MR
operator|||
name|type
operator|==
name|T_MG
operator|||
name|type
operator|==
name|T_MINFO
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|T_MAILA
operator|&&
operator|(
name|type
operator|==
name|T_MD
operator|||
name|type
operator|==
name|T_MF
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** WANT_CLASS -- Indicate whether the rr class matches the desired filter ** ---------------------------------------------------------------------- ** **	Returns: **		TRUE if the resource record class matches the filter. **		FALSE otherwise. ** **	In regular mode, the queryclass is used to formulate the query, **	and the filter is set to C_ANY to filter out any response. **	In listmode, we get everything, so the filter is set to the **	queryclass to filter out the proper responses. **	Note that C_IN is the default queryclass in listmode. */
end_comment

begin_function
name|bool
name|want_class
parameter_list|(
name|class
parameter_list|,
name|filter
parameter_list|)
name|input
name|int
name|class
decl_stmt|;
comment|/* resource record class */
name|input
name|int
name|filter
decl_stmt|;
comment|/* class of records we want to see */
block|{
if|if
condition|(
name|class
operator|==
name|filter
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|filter
operator|==
name|C_ANY
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** INDOMAIN -- Check whether a name belongs to a zone ** -------------------------------------------------- ** **	Returns: **		TRUE if the given name lies anywhere in the zone, or **		if the given name is the same as the zone and may be so. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|indomain
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|,
name|equal
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name under consideration */
name|input
name|char
modifier|*
name|domain
decl_stmt|;
comment|/* the name of the zone */
name|input
name|bool
name|equal
decl_stmt|;
comment|/* set if name may be same as zone */
block|{
specifier|register
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|equal
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|dot
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sameword
argument_list|(
name|dot
operator|+
literal|1
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|dot
operator|=
name|index
argument_list|(
name|dot
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** SAMEDOMAIN -- Check whether a name belongs to a zone ** ---------------------------------------------------- ** **	Returns: **		TRUE if the given name lies directly in the zone, or **		if the given name is the same as the zone and may be so. **		FALSE otherwise. */
end_comment

begin_function
name|bool
name|samedomain
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|,
name|equal
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name under consideration */
name|input
name|char
modifier|*
name|domain
decl_stmt|;
comment|/* the name of the zone */
name|input
name|bool
name|equal
decl_stmt|;
comment|/* set if name may be same as zone */
block|{
specifier|register
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|name
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|equal
operator|)
return|;
name|dot
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|NULL
condition|)
return|return
operator|(
name|sameword
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
operator|)
return|;
if|if
condition|(
name|sameword
argument_list|(
name|dot
operator|+
literal|1
argument_list|,
name|domain
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** GLUERECORD -- Check whether a name is a glue record ** --------------------------------------------------- ** **	Returns: **		TRUE is this is a glue record. **		FALSE otherwise. ** **	The name is supposed to be the name of an address record. **	If it lies directly in the given zone, it is considered **	an ordinary host within that zone, and not a glue record. **	If it does not belong to the given dzone at all, is it **	here considered to be a glue record. **	If it lies in the given zone, but not directly, it is **	considered a glue record if it belongs to any of the known **	delegated zones of the given zone. **	In the root zone itself are no hosts, only glue records. */
end_comment

begin_function
name|bool
name|gluerecord
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|,
name|zone
parameter_list|,
name|nzones
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name under consideration */
name|input
name|char
modifier|*
name|domain
decl_stmt|;
comment|/* name of zone being processed */
name|input
name|char
modifier|*
name|zone
index|[]
decl_stmt|;
comment|/* list of known delegated zones */
name|input
name|int
name|nzones
decl_stmt|;
comment|/* number of known delegated zones */
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|sameword
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|samedomain
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|indomain
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nzones
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|indomain
argument_list|(
name|name
argument_list|,
name|zone
index|[
name|n
index|]
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PR_DOTNAME -- Return domain name with trailing dot ** -------------------------------------------------- ** **	Returns: **		Pointer to new domain name. */
end_comment

begin_function
name|char
modifier|*
name|pr_dotname
parameter_list|(
name|name
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* domain name to append to */
block|{
specifier|static
name|char
name|buf
index|[
name|MAXDNAME
operator|+
literal|2
index|]
decl_stmt|;
comment|/* buffer to store new domain name */
specifier|register
name|int
name|n
decl_stmt|;
comment|/* return original if trailing dot present */
name|n
operator|=
name|strlength
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|name
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
operator|(
name|name
operator|)
return|;
comment|/* construct name with trailing dot */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.*s."
argument_list|,
name|MAXDNAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PR_TYPE -- Return name of resource record type ** ---------------------------------------------- ** **	Returns: **		Pointer to name of resource record type. */
end_comment

begin_function
name|char
modifier|*
name|pr_type
parameter_list|(
name|type
parameter_list|)
name|input
name|int
name|type
decl_stmt|;
comment|/* resource record type */
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
return|return
operator|(
literal|"A"
operator|)
return|;
comment|/* internet address */
case|case
name|T_NS
case|:
return|return
operator|(
literal|"NS"
operator|)
return|;
comment|/* authoritative server */
case|case
name|T_MD
case|:
return|return
operator|(
literal|"MD"
operator|)
return|;
comment|/* mail destination */
case|case
name|T_MF
case|:
return|return
operator|(
literal|"MF"
operator|)
return|;
comment|/* mail forwarder */
case|case
name|T_CNAME
case|:
return|return
operator|(
literal|"CNAME"
operator|)
return|;
comment|/* canonical name */
case|case
name|T_SOA
case|:
return|return
operator|(
literal|"SOA"
operator|)
return|;
comment|/* start of auth zone */
case|case
name|T_MB
case|:
return|return
operator|(
literal|"MB"
operator|)
return|;
comment|/* mailbox domain name */
case|case
name|T_MG
case|:
return|return
operator|(
literal|"MG"
operator|)
return|;
comment|/* mail group member */
case|case
name|T_MR
case|:
return|return
operator|(
literal|"MR"
operator|)
return|;
comment|/* mail rename name */
case|case
name|T_NULL
case|:
return|return
operator|(
literal|"NULL"
operator|)
return|;
comment|/* null resource record */
case|case
name|T_WKS
case|:
return|return
operator|(
literal|"WKS"
operator|)
return|;
comment|/* well known service */
case|case
name|T_PTR
case|:
return|return
operator|(
literal|"PTR"
operator|)
return|;
comment|/* domain name pointer */
case|case
name|T_HINFO
case|:
return|return
operator|(
literal|"HINFO"
operator|)
return|;
comment|/* host information */
case|case
name|T_MINFO
case|:
return|return
operator|(
literal|"MINFO"
operator|)
return|;
comment|/* mailbox information */
case|case
name|T_MX
case|:
return|return
operator|(
literal|"MX"
operator|)
return|;
comment|/* mail routing info */
case|case
name|T_TXT
case|:
return|return
operator|(
literal|"TXT"
operator|)
return|;
comment|/* descriptive text */
case|case
name|T_RP
case|:
return|return
operator|(
literal|"RP"
operator|)
return|;
comment|/* responsible person */
case|case
name|T_AFSDB
case|:
return|return
operator|(
literal|"AFSDB"
operator|)
return|;
comment|/* afs database location */
case|case
name|T_X25
case|:
return|return
operator|(
literal|"X25"
operator|)
return|;
comment|/* x25 address */
case|case
name|T_ISDN
case|:
return|return
operator|(
literal|"ISDN"
operator|)
return|;
comment|/* isdn address */
case|case
name|T_RT
case|:
return|return
operator|(
literal|"RT"
operator|)
return|;
comment|/* route through host */
case|case
name|T_NSAP
case|:
return|return
operator|(
literal|"NSAP"
operator|)
return|;
comment|/* nsap address */
case|case
name|T_NSAPPTR
case|:
return|return
operator|(
literal|"NSAP-PTR"
operator|)
return|;
comment|/* nsap pointer */
case|case
name|T_UINFO
case|:
return|return
operator|(
literal|"UINFO"
operator|)
return|;
comment|/* user information */
case|case
name|T_UID
case|:
return|return
operator|(
literal|"UID"
operator|)
return|;
comment|/* user ident */
case|case
name|T_GID
case|:
return|return
operator|(
literal|"GID"
operator|)
return|;
comment|/* group ident */
case|case
name|T_UNSPEC
case|:
return|return
operator|(
literal|"UNSPEC"
operator|)
return|;
comment|/* unspecified binary data */
case|case
name|T_AXFR
case|:
return|return
operator|(
literal|"AXFR"
operator|)
return|;
comment|/* zone transfer */
case|case
name|T_MAILB
case|:
return|return
operator|(
literal|"MAILB"
operator|)
return|;
comment|/* matches MB/MR/MG/MINFO */
case|case
name|T_MAILA
case|:
return|return
operator|(
literal|"MAILA"
operator|)
return|;
comment|/* matches MD/MF */
case|case
name|T_ANY
case|:
return|return
operator|(
literal|"ANY"
operator|)
return|;
comment|/* matches any type */
case|case
name|T_NONE
case|:
return|return
operator|(
literal|"resource"
operator|)
return|;
comment|/* not yet determined */
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** PR_CLASS -- Return name of resource record class ** ------------------------------------------------ ** **	Returns: **		Pointer to name of resource record class. */
end_comment

begin_function
name|char
modifier|*
name|pr_class
parameter_list|(
name|class
parameter_list|)
name|input
name|int
name|class
decl_stmt|;
comment|/* resource record class */
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
return|return
operator|(
literal|"IN"
operator|)
return|;
comment|/* internet */
case|case
name|C_CSNET
case|:
return|return
operator|(
literal|"CS"
operator|)
return|;
comment|/* csnet */
case|case
name|C_CHAOS
case|:
return|return
operator|(
literal|"CH"
operator|)
return|;
comment|/* chaosnet */
case|case
name|C_HS
case|:
return|return
operator|(
literal|"HS"
operator|)
return|;
comment|/* hesiod */
case|case
name|C_ANY
case|:
return|return
operator|(
literal|"ANY"
operator|)
return|;
comment|/* any class */
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** EXPAND_NAME -- Expand compressed domain name in a recource record ** ----------------------------------------------------------------- ** **	Returns: **		Number of bytes advanced in answer buffer. **		-1 if there was a format error. */
end_comment

begin_function
name|int
name|expand_name
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|cp
parameter_list|,
name|msg
parameter_list|,
name|eom
parameter_list|,
name|namebuf
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of resource record */
name|input
name|int
name|type
decl_stmt|;
comment|/* type of resource record */
name|input
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in answer buf */
name|input
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_comment
comment|/* begin and end of answer buf */
end_comment

begin_decl_stmt
name|output
name|char
modifier|*
name|namebuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of buf to expand name in */
end_comment

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|namebuf
argument_list|,
name|MAXDNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|pr_error
argument_list|(
literal|"expand error in %s record for %s, offset = %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
name|itoa
argument_list|(
name|cp
operator|-
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* change root to single dot */
if|if
condition|(
name|namebuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|namebuf
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|namebuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|type
operator|!=
name|T_NONE
operator|)
operator|&&
name|illegal
operator|&&
operator|!
name|valid_name
argument_list|(
name|namebuf
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"illegal name %s in %s record for %s"
argument_list|,
name|namebuf
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** CHECK_SIZE -- Check whether resource record is of sufficient length ** ------------------------------------------------------------------- ** **	Returns: **		Requested size if current record is long enough. **		-1 if current record does not have this many bytes. ** **	Note that HINFO records are very often incomplete since only **	one of the two data fields has been filled in and the second **	field is missing. So we generate only a warning message. */
end_comment

begin_function
name|int
name|check_size
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|cp
parameter_list|,
name|msg
parameter_list|,
name|eor
parameter_list|,
name|size
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of resource record */
name|input
name|int
name|type
decl_stmt|;
comment|/* type of resource record */
name|input
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in answer buf */
name|input
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eor
decl_stmt|;
end_function

begin_comment
comment|/* begin and end of answer buf */
end_comment

begin_decl_stmt
name|input
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* required record size remaining */
end_comment

begin_block
block|{
if|if
condition|(
name|cp
operator|+
name|size
operator|>
name|eor
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|T_HINFO
condition|)
name|pr_error
argument_list|(
literal|"incomplete %s record for %s, offset = %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
name|itoa
argument_list|(
name|cp
operator|-
name|msg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pr_warning
argument_list|(
literal|"incomplete %s record for %s, offset = %s"
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
name|itoa
argument_list|(
name|cp
operator|-
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** VALID_NAME -- Check whether domain name contains invalid characters ** ------------------------------------------------------------------- ** **	Returns: **		TRUE if the name is valid. **		FALSE otherwise. ** **	The total size of a compound name should not exceed MAXDNAME. **	We assume that this is true. Its individual components between **	dots should not be longer than 64. This is not checked here. **	Only alphanumeric characters and dash '-' may be used (dash **	only in the middle). We only check the individual characters. ** **	The label '*' can in principle be used anywhere to indicate **	wildcarding. It is valid only in the LHS resource record name. **	In definitions in zone files only as the first component. **	Used primarily in wildcard MX record definitions. */
end_comment

begin_function
name|bool
name|valid_name
parameter_list|(
name|name
parameter_list|,
name|wildcard
parameter_list|)
name|input
name|char
modifier|*
name|name
decl_stmt|;
comment|/* domain name to check */
name|input
name|bool
name|wildcard
decl_stmt|;
comment|/* set if wildcard is allowed */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|is_alnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|)
condition|)
continue|continue;
comment|/* start of a new component */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
continue|continue;
comment|/* allow '*' for use in wildcard names */
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|)
operator|&&
name|wildcard
condition|)
continue|continue;
comment|/* silently allowed widespread exceptions */
if|if
condition|(
name|illegal
operator|&&
name|index
argument_list|(
name|illegal
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** XALLOC -- Allocate or reallocate additional memory ** -------------------------------------------------- ** **	Returns: **		Pointer to (re)allocated buffer space. **		Aborts if the requested memory could not be obtained. */
end_comment

begin_function
name|ptr_t
modifier|*
name|xalloc
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
specifier|register
name|ptr_t
modifier|*
name|buf
decl_stmt|;
comment|/* current start of buffer space */
name|input
name|siz_t
name|size
decl_stmt|;
comment|/* number of bytes to allocate */
block|{
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|errmsg
argument_list|(
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** ITOA -- Convert integer value to ascii string ** --------------------------------------------- ** **	Returns: **		Pointer to string. */
end_comment

begin_function
name|char
modifier|*
name|itoa
parameter_list|(
name|n
parameter_list|)
name|input
name|int
name|n
decl_stmt|;
comment|/* value to convert */
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** STOA -- Extract partial ascii string ** ------------------------------------ ** **	Returns: **		Pointer to string. */
end_comment

begin_function
name|char
modifier|*
name|stoa
parameter_list|(
name|str
parameter_list|,
name|n
parameter_list|)
name|input
name|u_char
modifier|*
name|str
decl_stmt|;
comment|/* input string to extract from */
name|input
name|int
name|n
decl_stmt|;
comment|/* number of characters to extract */
block|{
specifier|static
name|char
name|buf
index|[
name|MAXPACKET
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXPACKET
condition|)
name|n
operator|=
name|MAXPACKET
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.*s"
argument_list|,
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

