begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_main.c	4.55 (Berkeley) 7/1/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_main.c,v 4.9.1.8 1993/12/06 00:43:02 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986, 1989, 1990  * -  * Copyright (c) 1986, 1989, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1986, 1989, 1990 The Regents of the University of California.\n\  portions Copyright (c) 1993 Digital Equipment Corporation\n\  portions Copyright (c) 1993 Berkeley Network Software Consortium\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Internet Name server (see rfc883& others).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|&&
name|defined
argument_list|(
name|XXX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SYSV */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|TIME_H_INCLUDED
end_define

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
end_if

begin_define
define|#
directive|define
name|_SOCKADDR_LEN
end_define

begin_comment
comment|/* XXX - should be in portability.h but that 				 * would need to be included before socket.h 				 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYSV
argument_list|)
end_if

begin_comment
comment|/* Solaris 2 */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAIN_PROGRAM
end_define

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_undef
undef|#
directive|undef
name|MAIN_PROGRAM
end_undef

begin_undef
undef|#
directive|undef
name|nsaddr
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|SO_RCVBUF
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|rbufsize
init|=
literal|8
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* UDP recive buffer size */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|nsaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|local_ns_port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our service port */
end_comment

begin_decl_stmt
specifier|static
name|fd_set
name|mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* open descriptors */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|Argv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|LastArg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of argv */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|qstream
modifier|*
name|sqadd
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sq_query
name|__P
argument_list|(
operator|(
expr|struct
name|qstream
operator|*
operator|)
argument_list|)
decl_stmt|,
name|opensocket
name|__P
argument_list|(
operator|(
expr|struct
name|qdatagram
operator|*
operator|)
argument_list|)
decl_stmt|,
ifdef|#
directive|ifdef
name|DEBUG
name|printnetinfo
name|__P
argument_list|(
operator|(
expr|struct
name|netinfo
operator|*
operator|)
argument_list|)
decl_stmt|,
endif|#
directive|endif
name|setdebug
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sq_here
name|__P
argument_list|(
operator|(
expr|struct
name|qstream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIG_FN
name|onintr
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
name|maint_alarm
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
name|setdumpflg
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
name|onhup
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
if|#
directive|if
name|defined
argument_list|(
name|QRYLOG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
name|setQrylogFlg
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
endif|#
directive|endif
name|setIncrDbgFlg
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
name|setNoDbgFlg
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
name|sigprof
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
name|setchkptflg
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|,
name|setstatsflg
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: named [-d #] [-q] [-r] [-p port[/localport]] [[-b] bootfile]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|void
decl|main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|,
modifier|*
name|envp
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|udpcnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
specifier|register
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|qdatagram
modifier|*
name|dqp
decl_stmt|;
name|struct
name|qstream
modifier|*
name|nextsp
decl_stmt|;
name|int
name|nfds
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|rfd
decl_stmt|,
name|size
decl_stmt|;
name|time_t
name|lasttime
decl_stmt|,
name|maxctime
decl_stmt|;
name|u_char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|SYSV
name|struct
name|sigvec
name|vec
decl_stmt|;
endif|#
directive|endif
name|fd_set
name|tmpmask
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|struct
name|qstream
modifier|*
name|candidate
init|=
name|QSTREAM_NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
ifdef|#
directive|ifdef
name|PID_FIX
name|char
name|oldpid
index|[
literal|10
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WANT_PIDFILE
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* file descriptor for pid file */
endif|#
directive|endif
name|local_ns_port
operator|=
name|ns_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
comment|/* 	**  Save start and extent of argv for setproctitle. 	*/
name|Argv
operator|=
name|argp
operator|=
name|argv
expr_stmt|;
while|while
condition|(
operator|*
name|argp
condition|)
name|argp
operator|++
expr_stmt|;
name|LastArg
operator|=
name|argp
index|[
operator|-
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|argp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
comment|/* XXX - should use getopt here */
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|arg
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|arg
condition|)
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|bootfile
operator|=
name|savestr
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
name|argv
operator|--
expr_stmt|;
break|break;
block|}
name|debug
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|<=
literal|0
condition|)
name|debug
operator|=
literal|1
expr_stmt|;
name|setdebug
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* use nonstandard port number. 					 * usage: -p remote/local 					 * remote is the port number to which 					 * we send queries.  local is the port 					 * on which we listen for queries. 					 * local defaults to same as remote. 					 */
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|ns_port
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|local_ns_port
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|local_ns_port
operator|=
name|ns_port
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|QRYLOG
case|case
literal|'q'
case|:
name|qrylog
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'r'
case|:
name|NoRecurse
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|bootfile
operator|=
name|savestr
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|debug
condition|)
for|for
control|(
name|n
operator|=
name|getdtablesize
argument_list|()
operator|-
literal|1
init|;
name|n
operator|>
literal|2
condition|;
name|n
operator|--
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* don't use my_close() here */
ifdef|#
directive|ifdef
name|DEBUG
else|else
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Debug turned ON, Level %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Version = %s\t"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"bootfile = %s\n"
argument_list|,
name|bootfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"named"
argument_list|,
name|LOG_PID
operator||
name|LOG_CONS
operator||
name|LOG_NDELAY
argument_list|,
name|LOGFAC
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"named"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WANT_PIDFILE
comment|/* tuck my process id away */
ifdef|#
directive|ifdef
name|PID_FIX
name|fp
operator|=
name|fopen
argument_list|(
name|PidFile
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|oldpid
argument_list|,
sizeof|sizeof
argument_list|(
name|oldpid
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/*PID_FIX*/
name|fp
operator|=
name|fopen
argument_list|(
name|PidFile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*PID_FIX*/
endif|#
directive|endif
comment|/*WANT_PIDFILE*/
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"starting.  %s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator||
name|RES_RECURSE
operator|)
expr_stmt|;
name|nsaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nsaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|nsaddr
operator|.
name|sin_port
operator|=
name|local_ns_port
expr_stmt|;
comment|/* 	** Open stream port. 	*/
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|vs
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(SOCK_STREAM): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|vs
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(vs, reuseaddr): %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|vs
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bind
argument_list|(
name|vs
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nsaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|nsaddr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
operator|||
name|n
operator|>
literal|4
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"There may be a name server already running"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"exiting"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind(vs, [%s].%d): %m"
argument_list|,
name|inet_ntoa
argument_list|(
name|nsaddr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|nsaddr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|WANT_PIDFILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|PID_FIX
argument_list|)
comment|/* put old pid back */
if|if
condition|(
name|atoi
argument_list|(
name|oldpid
argument_list|)
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|PidFile
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|oldpid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*WANT_PIDFILE&& PID_FIX*/
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Retry opening the socket a few times */
name|my_close
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|listen
argument_list|(
name|vs
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"listen(vs, 5): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get list of local addresses and set up datagram sockets. 	 */
name|getnetconf
argument_list|()
expr_stmt|;
comment|/* 	** Initialize and load database. 	*/
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|buildservicelist
argument_list|()
expr_stmt|;
name|buildprotolist
argument_list|()
expr_stmt|;
name|ns_init
argument_list|(
name|bootfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Network and sort list:\n"
argument_list|)
expr_stmt|;
name|printnetinfo
argument_list|(
name|nettab
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|time
argument_list|(
operator|&
name|boottime
argument_list|)
expr_stmt|;
name|resettime
operator|=
name|boottime
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
comment|/* wierd DEC Hesiodism, harmless */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|endxfer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|maint_alarm
argument_list|)
expr_stmt|;
else|#
directive|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|vec
argument_list|,
sizeof|sizeof
argument_list|(
name|vec
argument_list|)
argument_list|)
expr_stmt|;
name|vec
operator|.
name|sv_handler
operator|=
name|maint_alarm
expr_stmt|;
name|vec
operator|.
name|sv_mask
operator|=
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|vec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|vec
operator|.
name|sv_handler
operator|=
name|endxfer
expr_stmt|;
name|vec
operator|.
name|sv_mask
operator|=
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|vec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|sigprof
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|setdumpflg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|setchkptflg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|setstatsflg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
comment|/* Catch SIGTERM so we can dump the database upon shutdown if it            has changed since it was last dumped/booted */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|setIncrDbgFlg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|setNoDbgFlg
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SIGUSR1&&SIGUSR2 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|setIncrDbgFlg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|setNoDbgFlg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGUSR1&&SIGUSR2 */
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|QRYLOG
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|setQrylogFlg
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"database initialized\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Fork and go into background now that 	 * we've done any slow initialization 	 * and are ready to answer queries. 	 */
ifdef|#
directive|ifdef
name|USE_SETSID
if|if
condition|(
operator|!
name|debug
operator|||
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
operator|>
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setsid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
block|{
name|n
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|n
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|2
condition|)
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|debug
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_DAEMON
name|daemon
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|0
case|:
comment|/* child */
break|break;
default|default:
comment|/* parent */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|n
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|2
condition|)
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|n
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|setpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
block|{
name|struct
name|itimerval
name|ival
decl_stmt|;
comment|/* 			 * The open below may hang on pseudo ttys if the person 			 * who starts named logs out before this point. 			 * 			 * needmaint may get set inapropriately if the open 			 * hangs, but all that will happen is we will see that 			 * no maintenance is required. 			 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ival
argument_list|,
sizeof|sizeof
argument_list|(
name|ival
argument_list|)
argument_list|)
expr_stmt|;
name|ival
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|120
expr_stmt|;
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
name|open
argument_list|(
name|_PATH_TTY
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ival
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|n
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYSV */
endif|#
directive|endif
comment|/* HAVE_DAEMON */
block|}
endif|#
directive|endif
comment|/* USE_SETSID */
ifdef|#
directive|ifdef
name|WANT_PIDFILE
comment|/* tuck my process id away again */
name|fp
operator|=
name|fopen
argument_list|(
name|PidFile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Ready to answer queries.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Ready to answer queries.\n"
argument_list|)
expr_stmt|;
name|prime_cache
argument_list|()
expr_stmt|;
name|nfds
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
comment|/* get the number of file descriptors */
if|if
condition|(
name|nfds
operator|>
name|FD_SETSIZE
condition|)
block|{
name|nfds
operator|=
name|FD_SETSIZE
expr_stmt|;
comment|/* Bulletproofing */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Return from getdtablesize()> FD_SETSIZE"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Return from getdtablesize()> FD_SETSIZE\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|FD_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|vs
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|dqp
operator|=
name|datagramq
init|;
name|dqp
operator|!=
name|QDATAGRAM_NULL
condition|;
name|dqp
operator|=
name|dqp
operator|->
name|dq_next
control|)
name|FD_SET
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ddt
operator|&&
name|debug
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Debug turned OFF\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|ddt
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
if|if
condition|(
name|needToExit
condition|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|sigblock
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* 					 * Block all blockable signals 					 * to ensure a consistant 					 * state during final dump 					 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Received shutdown signal\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|zp
operator|=
name|zones
init|;
name|zp
operator|<
operator|&
name|zones
index|[
name|nzones
index|]
condition|;
name|zp
operator|++
control|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_state
operator|&
name|Z_CHANGED
condition|)
name|zonedump
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALLOW_UPDATES */
if|if
condition|(
name|needreload
condition|)
block|{
name|needreload
operator|=
literal|0
expr_stmt|;
name|db_reload
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|needStatsDump
condition|)
block|{
name|needStatsDump
operator|=
literal|0
expr_stmt|;
name|ns_stats
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|needzoneload
condition|)
block|{
name|needzoneload
operator|=
literal|0
expr_stmt|;
name|loadxfer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|needmaint
condition|)
block|{
name|needmaint
operator|=
literal|0
expr_stmt|;
name|ns_maint
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|needToChkpt
condition|)
block|{
name|needToChkpt
operator|=
literal|0
expr_stmt|;
name|doachkpt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|needToDoadump
condition|)
block|{
name|needToDoadump
operator|=
literal|0
expr_stmt|;
name|doadump
argument_list|()
expr_stmt|;
block|}
comment|/* 		** Wait until a query arrives 		*/
if|if
condition|(
name|retryqp
operator|!=
name|NULL
condition|)
block|{
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
comment|/* 			** The tv_sec field might be unsigned  			** and thus cannot be negative. 			*/
if|if
condition|(
operator|(
name|int32_t
operator|)
name|retryqp
operator|->
name|q_time
operator|<=
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|retry
argument_list|(
name|retryqp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|t
operator|.
name|tv_sec
operator|=
operator|(
name|int32_t
operator|)
name|retryqp
operator|->
name|q_time
operator|-
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|=
operator|&
name|t
expr_stmt|;
block|}
else|else
name|tp
operator|=
name|NULL
expr_stmt|;
name|tmpmask
operator|=
name|mask
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|nfds
argument_list|,
operator|&
name|tmpmask
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select: %m"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"select error\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
empty_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|dqp
operator|=
name|datagramq
init|;
name|dqp
operator|!=
name|QDATAGRAM_NULL
condition|;
name|dqp
operator|=
name|dqp
operator|->
name|dq_next
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
operator|&
name|tmpmask
argument_list|)
condition|)
for|for
control|(
name|udpcnt
operator|=
literal|0
init|;
name|udpcnt
operator|<
literal|25
condition|;
name|udpcnt
operator|++
control|)
block|{
name|from_len
operator|=
sizeof|sizeof
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|recvfrom
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from_addr
argument_list|,
operator|&
name|from_len
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|PORT_WOULDBLK
operator|)
condition|)
break|break;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"recvfrom: %m"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
name|stats
index|[
name|S_INPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"\ndatagram from [%s].%d, fd %d, len %d; now %s"
operator|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|from_addr
operator|.
name|sin_port
argument_list|)
operator|,
name|dqp
operator|->
name|dq_dfd
operator|,
name|n
operator|,
name|ctime
argument_list|(
operator|&
name|tt
operator|.
name|tv_sec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			     * Consult database to get the answer. 			     */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|ns_req
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|PACKETSZ
argument_list|,
name|QSTREAM_NULL
argument_list|,
operator|&
name|from_addr
argument_list|,
name|dqp
operator|->
name|dq_dfd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		** Process stream connection 		*/
if|if
condition|(
name|FD_ISSET
argument_list|(
name|vs
argument_list|,
operator|&
name|tmpmask
argument_list|)
condition|)
block|{
name|from_len
operator|=
sizeof|sizeof
argument_list|(
name|from_addr
argument_list|)
expr_stmt|;
name|rfd
operator|=
name|accept
argument_list|(
name|vs
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from_addr
argument_list|,
operator|&
name|from_len
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EMFILE
operator|&&
name|streamq
operator|!=
name|NULL
condition|)
block|{
name|maxctime
operator|=
literal|0
expr_stmt|;
name|candidate
operator|=
name|QSTREAM_NULL
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|streamq
init|;
name|sp
operator|!=
name|QSTREAM_NULL
condition|;
name|sp
operator|=
name|nextsp
control|)
block|{
name|nextsp
operator|=
name|sp
operator|->
name|s_next
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_refcnt
operator|!=
literal|0
condition|)
continue|continue;
name|lasttime
operator|=
name|tt
operator|.
name|tv_sec
operator|-
name|sp
operator|->
name|s_time
expr_stmt|;
if|if
condition|(
name|lasttime
operator|>=
literal|900
condition|)
name|sqrm
argument_list|(
name|sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lasttime
operator|>
name|maxctime
condition|)
block|{
name|candidate
operator|=
name|sp
expr_stmt|;
name|maxctime
operator|=
name|lasttime
expr_stmt|;
block|}
block|}
name|rfd
operator|=
name|accept
argument_list|(
name|vs
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from_addr
argument_list|,
operator|&
name|from_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rfd
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EMFILE
operator|)
operator|&&
name|candidate
operator|!=
name|QSTREAM_NULL
condition|)
block|{
name|sqrm
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|rfd
operator|=
name|accept
argument_list|(
name|vs
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from_addr
argument_list|,
operator|&
name|from_len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rfd
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"accept: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|fcntl
argument_list|(
name|rfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(rfd, F_GETFL): %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|rfd
argument_list|,
name|F_SETFL
argument_list|,
name|n
operator||
name|PORT_NONBLOCK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(rfd, non-blocking): %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(rfd, keepalive): %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|sqadd
argument_list|()
operator|)
operator|==
name|QSTREAM_NULL
condition|)
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sp
operator|->
name|s_rfd
operator|=
name|rfd
expr_stmt|;
comment|/* stream file descriptor */
name|sp
operator|->
name|s_size
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* amount of data to receive */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
comment|/* last transaction time */
name|sp
operator|->
name|s_from
operator|=
name|from_addr
expr_stmt|;
comment|/* address to respond to */
name|sp
operator|->
name|s_bufp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sp
operator|->
name|s_tempsize
expr_stmt|;
name|FD_SET
argument_list|(
name|rfd
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|rfd
argument_list|,
operator|&
name|tmpmask
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"\nTCP connection from [%s].%d (fd %d)\n"
operator|,
name|inet_ntoa
argument_list|(
name|sp
operator|->
name|s_from
operator|.
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|sp
operator|->
name|s_from
operator|.
name|sin_port
argument_list|)
operator|,
name|rfd
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|streamq
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"streamq  = x%x\n"
operator|,
name|streamq
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|streamq
init|;
name|sp
operator|!=
name|QSTREAM_NULL
condition|;
name|sp
operator|=
name|nextsp
control|)
block|{
name|nextsp
operator|=
name|sp
operator|->
name|s_next
expr_stmt|;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|tmpmask
argument_list|)
condition|)
continue|continue;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"sp x%x rfd %d size %d time %d next x%x\n"
operator|,
name|sp
operator|,
name|sp
operator|->
name|s_rfd
operator|,
name|sp
operator|->
name|s_size
operator|,
name|sp
operator|->
name|s_time
operator|,
name|sp
operator|->
name|s_next
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"\tbufsize %d buf x%x bufp x%x\n"
operator|,
name|sp
operator|->
name|s_bufsize
operator|,
name|sp
operator|->
name|s_buf
operator|,
name|sp
operator|->
name|s_bufp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|-
operator|(
name|sp
operator|->
name|s_bufp
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sp
operator|->
name|s_tempsize
operator|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
operator|&&
operator|(
name|n
operator|=
name|read
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|sp
operator|->
name|s_bufp
argument_list|,
name|size
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|sp
operator|->
name|s_bufp
operator|+=
name|n
expr_stmt|;
name|size
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|PORT_WOULDBLK
operator|)
condition|)
continue|continue;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|sqrm
argument_list|(
name|sp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|s_bufp
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sp
operator|->
name|s_tempsize
operator|)
operator|==
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
condition|)
block|{
name|sp
operator|->
name|s_size
operator|=
name|htons
argument_list|(
name|sp
operator|->
name|s_tempsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_bufsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|s_buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|s_buf
operator|=
name|buf
expr_stmt|;
name|sp
operator|->
name|s_size
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_bufsize
operator|=
name|BUFSIZ
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|s_size
operator|>
name|sp
operator|->
name|s_bufsize
operator|&&
name|sp
operator|->
name|s_bufsize
operator|!=
literal|0
condition|)
block|{
name|sp
operator|->
name|s_buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|s_buf
argument_list|,
operator|(
name|unsigned
operator|)
name|sp
operator|->
name|s_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_buf
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|s_buf
operator|=
name|buf
expr_stmt|;
name|sp
operator|->
name|s_bufsize
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_size
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|s_bufsize
operator|=
name|sp
operator|->
name|s_size
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|s_bufp
operator|=
name|sp
operator|->
name|s_buf
expr_stmt|;
block|}
block|}
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
while|while
condition|(
name|sp
operator|->
name|s_size
operator|>
literal|0
operator|&&
operator|(
name|n
operator|=
name|read
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|sp
operator|->
name|s_bufp
argument_list|,
name|sp
operator|->
name|s_size
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|sp
operator|->
name|s_bufp
operator|+=
name|n
expr_stmt|;
name|sp
operator|->
name|s_size
operator|-=
name|n
expr_stmt|;
block|}
comment|/* 			 * we don't have enough memory for the query. 			 * if we have a query id, then we will send an 			 * error back to the user. 			 */
if|if
condition|(
name|sp
operator|->
name|s_bufsize
operator|==
literal|0
operator|&&
operator|(
name|sp
operator|->
name|s_bufp
operator|-
name|sp
operator|->
name|s_buf
operator|>
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
condition|)
block|{
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|sp
operator|->
name|s_buf
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
operator|(
name|void
operator|)
name|writemsg
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
name|sp
operator|->
name|s_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|n
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|PORT_WOULDBLK
operator|)
condition|)
continue|continue;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|sqrm
argument_list|(
name|sp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Consult database to get the answer. 			 */
if|if
condition|(
name|sp
operator|->
name|s_size
operator|==
literal|0
condition|)
block|{
name|sq_query
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ns_req
argument_list|(
name|sp
operator|->
name|s_buf
argument_list|,
name|sp
operator|->
name|s_bufp
operator|-
name|sp
operator|->
name|s_buf
argument_list|,
name|sp
operator|->
name|s_bufsize
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|s_from
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* ns_req() can call sqrm() - check for it */
if|if
condition|(
name|sq_here
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|sp
operator|->
name|s_bufp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sp
operator|->
name|s_tempsize
expr_stmt|;
name|sp
operator|->
name|s_size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
block|}
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_function
name|void
name|getnetconf
parameter_list|()
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|ontp
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|,
modifier|*
name|ifr
decl_stmt|;
name|struct
name|qdatagram
modifier|*
name|dqp
decl_stmt|,
modifier|*
name|pqp
decl_stmt|,
modifier|*
name|nqp
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cplim
decl_stmt|;
name|u_int32_t
name|nm
decl_stmt|;
name|time_t
name|my_generation
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface configuration: %m - exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ntp
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AF_LINK
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|RISCOS_BSD
argument_list|)
define|#
directive|define
name|my_max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a> b ? a : b)
define|#
directive|define
name|my_size
parameter_list|(
name|p
parameter_list|)
value|my_max((p).sa_len, sizeof(p))
else|#
directive|else
define|#
directive|define
name|my_size
parameter_list|(
name|p
parameter_list|)
value|(sizeof (p))
endif|#
directive|endif
name|cplim
operator|=
name|buf
operator|+
name|ifc
operator|.
name|ifc_len
expr_stmt|;
comment|/*skip over if's with big ifr_addr's */
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|cplim
condition|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
operator|+
name|my_size
argument_list|(
name|ifr
operator|->
name|ifr_addr
argument_list|)
control|)
block|{
undef|#
directive|undef
name|my_size
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
operator|||
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|ifreq
operator|=
operator|*
name|ifr
expr_stmt|;
comment|/* 		 * Don't test IFF_UP, packets may still be received at this 		 * address if any other interface is up. 		 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
operator|(
name|BSD
operator|<
literal|199103
operator|)
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface addr: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"considering [%s]\n"
operator|,
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* build datagram queue */
comment|/*  		 * look for an already existing source interface address. 		 * This happens mostly when reinitializing.  Also, if 		 * the machine has multiple point to point interfaces, then  		 * the local address may appear more than once. 		 */
if|if
condition|(
name|dqp
operator|=
name|aIsUs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"dup interface address %s on %s\n"
operator|,
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
argument_list|)
operator|,
name|ifreq
operator|.
name|ifr_name
operator|)
argument_list|)
expr_stmt|;
name|dqp
operator|->
name|dq_gen
operator|=
name|my_generation
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Skip over address 0.0.0.0 since this will conflict 		 * with binding to wildcard address later.  Interfaces 		 * which are not completely configured can have this addr. 		 */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0x00000000
condition|)
block|{
comment|/* XXX */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"skipping address 0.0.0.0 on %s\n"
operator|,
name|ifreq
operator|.
name|ifr_name
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|dqp
operator|=
operator|(
expr|struct
name|qdatagram
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qdatagram
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"getnetconf: malloc error\n"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getnetconf: Out Of Memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
name|dqp
operator|->
name|dq_next
operator|=
name|datagramq
expr_stmt|;
name|datagramq
operator|=
name|dqp
expr_stmt|;
name|dqp
operator|->
name|dq_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|dqp
operator|->
name|dq_gen
operator|=
name|my_generation
expr_stmt|;
name|opensocket
argument_list|(
name|dqp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"listening [%s]\n"
operator|,
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Add interface to list of directly-attached (sub)nets 		 * for use in sorting addresses. 		 */
if|if
condition|(
name|ntp
operator|==
name|NULL
condition|)
block|{
name|ntp
operator|=
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ntp
operator|->
name|my_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|SIOCGIFNETMASK
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get netmask: %m"
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|mask
operator|=
name|net_mask
argument_list|(
name|ntp
operator|->
name|my_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|ntp
operator|->
name|mask
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|#
directive|else
comment|/* 4.2 does not support subnets */
name|ntp
operator|->
name|mask
operator|=
name|net_mask
argument_list|(
name|ntp
operator|->
name|my_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface flags: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|IFF_LOOPBACK
if|if
condition|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_LOOPBACK
condition|)
else|#
directive|else
comment|/* test against 127.0.0.1 (yuck!!) */
if|if
condition|(
name|ntp
operator|->
name|my_addr
operator|.
name|s_addr
operator|==
name|inet_addr
argument_list|(
literal|"127.0.0.1"
argument_list|)
condition|)
comment|/* XXX */
endif|#
directive|endif
block|{
if|if
condition|(
name|netloop
operator|.
name|my_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|netloop
operator|.
name|my_addr
operator|=
name|ntp
operator|->
name|my_addr
expr_stmt|;
name|netloop
operator|.
name|mask
operator|=
literal|0xffffffff
expr_stmt|;
name|netloop
operator|.
name|net
operator|=
name|ntp
operator|->
name|my_addr
operator|.
name|s_addr
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"loopback address: x%lx\n"
operator|,
name|netloop
operator|.
name|my_addr
operator|.
name|s_addr
operator|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|vs
argument_list|,
name|SIOCGIFDSTADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get dst addr: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ntp
operator|->
name|mask
operator|=
literal|0xffffffff
expr_stmt|;
name|ntp
operator|->
name|net
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
else|else
block|{
name|ntp
operator|->
name|net
operator|=
name|ntp
operator|->
name|mask
operator|&
name|ntp
operator|->
name|my_addr
operator|.
name|s_addr
expr_stmt|;
block|}
comment|/* 		 * Place on end of list of locally-attached (sub)nets, 		 * but before logical nets for subnetted nets. 		 */
name|ntp
operator|->
name|next
operator|=
operator|*
name|elocal
expr_stmt|;
operator|*
name|elocal
operator|=
name|ntp
expr_stmt|;
if|if
condition|(
name|elocal
operator|==
name|enettab
condition|)
name|enettab
operator|=
operator|&
name|ntp
operator|->
name|next
expr_stmt|;
name|elocal
operator|=
operator|&
name|ntp
operator|->
name|next
expr_stmt|;
name|ntp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ntp
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ntp
argument_list|)
expr_stmt|;
comment|/* 	 * now go through the datagramq and delete anything that 	 * does not have the current generation number.  this is 	 * how we catch interfaces that go away or change their 	 * addresses.  note that 0.0.0.0 is the wildcard element 	 * and should never be deleted by this code. 	 * 	 * XXX - need to update enettab/elocal as well. 	 */
for|for
control|(
name|pqp
operator|=
name|NULL
operator|,
name|dqp
operator|=
name|datagramq
init|;
name|dqp
operator|!=
name|NULL
condition|;
name|pqp
operator|=
name|dqp
operator|,
name|dqp
operator|=
name|nqp
control|)
block|{
name|nqp
operator|=
name|dqp
operator|->
name|dq_next
expr_stmt|;
if|if
condition|(
operator|(
name|dqp
operator|->
name|dq_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|)
operator|&&
operator|(
name|dqp
operator|->
name|dq_gen
operator|!=
name|my_generation
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"bye, bye, interface [%s]"
operator|,
name|inet_ntoa
argument_list|(
name|dqp
operator|->
name|dq_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"interface [%s] missing; deleting"
argument_list|,
name|inet_ntoa
argument_list|(
name|dqp
operator|->
name|dq_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pqp
operator|!=
name|NULL
condition|)
name|pqp
operator|->
name|dq_next
operator|=
name|dqp
operator|->
name|dq_next
expr_stmt|;
else|else
name|datagramq
operator|=
name|dqp
operator|->
name|dq_next
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|dqp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Create separate qdatagram structure for socket 	 * wildcard address. 	 */
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
operator|(
name|dqp
operator|=
operator|(
expr|struct
name|qdatagram
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dqp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"getnetconf: malloc error\n"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getnetconf: Out Of Memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
name|dqp
operator|->
name|dq_next
operator|=
name|datagramq
expr_stmt|;
name|datagramq
operator|=
name|dqp
expr_stmt|;
name|dqp
operator|->
name|dq_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|opensocket
argument_list|(
name|dqp
argument_list|)
expr_stmt|;
name|ds
operator|=
name|dqp
operator|->
name|dq_dfd
expr_stmt|;
block|}
comment|/* 	 * Compute logical networks to which we're connected 	 * based on attached subnets; 	 * used for sorting based on network configuration. 	 */
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
name|nm
operator|=
name|net_mask
argument_list|(
name|ntp
operator|->
name|my_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|!=
name|ntp
operator|->
name|mask
condition|)
block|{
if|if
condition|(
name|findnetinfo
argument_list|(
name|ntp
operator|->
name|my_addr
argument_list|)
condition|)
continue|continue;
name|ontp
operator|=
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ontp
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"getnetconf: malloc error\n"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getnetconf: Out Of Memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
name|ontp
operator|->
name|my_addr
operator|=
name|ntp
operator|->
name|my_addr
expr_stmt|;
name|ontp
operator|->
name|mask
operator|=
name|nm
expr_stmt|;
name|ontp
operator|->
name|net
operator|=
name|ontp
operator|->
name|my_addr
operator|.
name|s_addr
operator|&
name|nm
expr_stmt|;
name|ontp
operator|->
name|next
operator|=
operator|*
name|enettab
expr_stmt|;
operator|*
name|enettab
operator|=
name|ontp
expr_stmt|;
name|enettab
operator|=
operator|&
name|ontp
operator|->
name|next
expr_stmt|;
block|}
block|}
name|first
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find netinfo structure for logical network implied by address "addr",  * if it's on list of local/favored networks.  */
end_comment

begin_function
name|struct
name|netinfo
modifier|*
name|findnetinfo
parameter_list|(
name|addr
parameter_list|)
name|struct
name|in_addr
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
name|u_int32_t
name|net
decl_stmt|,
name|mask
decl_stmt|;
name|mask
operator|=
name|net_mask
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|net
operator|=
name|addr
operator|.
name|s_addr
operator|&
name|mask
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
if|if
condition|(
name|ntp
operator|->
name|net
operator|==
name|net
operator|&&
name|ntp
operator|->
name|mask
operator|==
name|mask
condition|)
return|return
operator|(
name|ntp
operator|)
return|;
return|return
operator|(
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|printnetinfo
parameter_list|(
name|ntp
parameter_list|)
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
block|{
for|for
control|(
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"net x%lx mask x%lx"
argument_list|,
name|ntp
operator|->
name|net
argument_list|,
name|ntp
operator|->
name|mask
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|" my_addr x%lx"
argument_list|,
name|ntp
operator|->
name|my_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|" %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ntp
operator|->
name|my_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|opensocket
parameter_list|(
name|dqp
parameter_list|)
specifier|register
name|struct
name|qdatagram
modifier|*
name|dqp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
comment|/* 	 * Open datagram sockets bound to interface address. 	 */
if|if
condition|(
operator|(
name|dqp
operator|->
name|dq_dfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket(SOCK_DGRAM): %m - exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"dqp->dq_addr %s d_dfd %d\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|dqp
operator|->
name|dq_addr
argument_list|)
argument_list|,
name|dqp
operator|->
name|dq_dfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|setsockopt
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt(dqp->dq_dfd, reuseaddr): %m"
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, this is not too serious. */
block|}
ifdef|#
directive|ifdef
name|SO_RCVBUF
name|m
operator|=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* note: this depends on short-circuit evaluation, which is in the 	 * C standards, but tricky nonetheless. (vix) 	 */
if|if
condition|(
operator|(
name|getsockopt
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|m
operator|==
sizeof|sizeof
argument_list|(
name|n
argument_list|)
operator|)
operator|&&
operator|(
name|n
operator|<
name|rbufsize
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rbufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|rbufsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SO_RCVBUF */
if|if
condition|(
operator|(
name|n
operator|=
name|fcntl
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(dfd, F_GETFL): %m"
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, but this really is a problem. */
block|}
elseif|else
if|if
condition|(
name|fcntl
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
name|F_SETFL
argument_list|,
name|n
operator||
name|PORT_NONBLOCK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(dqp->dq_dfd, non-blocking): %m"
argument_list|)
expr_stmt|;
comment|/* XXX press on regardless, but this really is a problem. */
block|}
comment|/* 	 *   NOTE: Some versions of SunOS have problems with the following 	 *   call to bind.  Bind still seems to function on these systems 	 *   if you comment out the exit inside the if.  This may cause 	 *   Suns with multiple interfaces to reply strangely. 	 */
name|nsaddr
operator|.
name|sin_addr
operator|=
name|dqp
operator|->
name|dq_addr
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|dqp
operator|->
name|dq_dfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nsaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|nsaddr
argument_list|)
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind(dfd=%d, [%s].%d): %m - exiting"
argument_list|,
name|dqp
operator|->
name|dq_dfd
argument_list|,
name|inet_ntoa
argument_list|(
name|nsaddr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|nsaddr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* ** Set flag saying to reload database upon receiving SIGHUP. ** Must make sure that someone isn't walking through a data ** structure at the time. */
end_comment

begin_function
specifier|static
name|SIG_FN
name|onhup
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|needreload
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Set flag saying to call ns_maint() ** Must make sure that someone isn't walking through a data ** structure at the time. */
end_comment

begin_function
specifier|static
name|SIG_FN
name|maint_alarm
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|maint_alarm
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|needmaint
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
end_ifdef

begin_comment
comment|/*  * Signal handler to schedule shutdown.  Just set flag, to ensure a consistent  * state during dump.  */
end_comment

begin_function
specifier|static
name|SIG_FN
name|onintr
parameter_list|()
block|{
name|needToExit
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALLOW_UPDATES */
end_comment

begin_comment
comment|/*  * Signal handler to schedule a data base dump.  Do this instead of dumping the  * data base immediately, to avoid seeing it in a possibly inconsistent state  * (due to updates), and to avoid long disk I/O delays at signal-handler  * level  */
end_comment

begin_function
specifier|static
name|SIG_FN
name|setdumpflg
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|setdumpflg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|needToDoadump
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Turn on or off debuging by open or closeing the debug file */
end_comment

begin_function
specifier|static
name|void
name|setdebug
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|code
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|code
condition|)
block|{
name|int
name|n
decl_stmt|;
name|ddt
operator|=
name|freopen
argument_list|(
name|debugfile
argument_list|,
literal|"w+"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddt
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"can't open debug file %s: %m"
argument_list|,
name|debugfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
name|setvbuf
argument_list|(
name|ddt
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|ddt
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fcntl(ddt, F_GETFL): %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|ddt
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|n
operator||
name|O_APPEND
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|debug
operator|=
literal|0
expr_stmt|;
comment|/* delay closing ddt, we might interrupt someone */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** Catch a special signal and set debug level. ** **  If debuging is off then turn on debuging else increment the level. ** ** Handy for looking in on long running name servers. */
end_comment

begin_function
specifier|static
name|SIG_FN
name|setIncrDbgFlg
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|setIncrDbgFlg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
block|{
name|debug
operator|++
expr_stmt|;
name|setdebug
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Debug turned ON, Level %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** Catch a special signal to turn off debugging */
end_comment

begin_function
specifier|static
name|SIG_FN
name|setNoDbgFlg
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|setNoDbgFlg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|setdebug
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|QRYLOG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
end_if

begin_comment
comment|/* ** Set flag for query logging */
end_comment

begin_function
specifier|static
name|SIG_FN
name|setQrylogFlg
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|setQrylogFlg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|qrylog
operator|=
operator|!
name|qrylog
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"query log %s\n"
argument_list|,
name|qrylog
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*QRYLOG&& SIGWINCH*/
end_comment

begin_comment
comment|/* ** Set flag for statistics dump */
end_comment

begin_function
specifier|static
name|SIG_FN
name|setstatsflg
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|setstatsflg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|needStatsDump
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|SIG_FN
name|setchkptflg
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|setchkptflg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
name|needToChkpt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Catch a special signal SIGSYS ** **  this is setup to fork and exit to drop to /usr/tmp/gmon.out **   and keep the server running */
end_comment

begin_function
specifier|static
name|SIG_FN
name|sigprof
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|sigprof
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sigprof()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|_PATH_TMPDIR
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Routines for managing stream queue */
end_comment

begin_function
specifier|static
name|struct
name|qstream
modifier|*
name|sqadd
parameter_list|()
block|{
specifier|register
name|struct
name|qstream
modifier|*
name|sqp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sqp
operator|=
operator|(
expr|struct
name|qstream
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qstream
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"sqadd: calloc error\n"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sqadd: Out Of Memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|QSTREAM_NULL
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"sqadd(x%x)\n"
operator|,
name|sqp
operator|)
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|s_next
operator|=
name|streamq
expr_stmt|;
name|streamq
operator|=
name|sqp
expr_stmt|;
return|return
operator|(
name|sqp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sqrm(qp)  *	remove stream queue structure `qp'.  *	no current queries may refer to this stream when it is removed.  * side effects:  *	memory is deallocated.  sockets are closed.  lists are relinked.  */
end_comment

begin_function
name|void
name|sqrm
parameter_list|(
name|qp
parameter_list|)
specifier|register
name|struct
name|qstream
modifier|*
name|qp
decl_stmt|;
block|{
specifier|register
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"sqrm(%#x, %d ) rfcnt=%d\n"
operator|,
name|qp
operator|,
name|qp
operator|->
name|s_rfd
operator|,
name|qp
operator|->
name|s_refcnt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|s_bufsize
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|qp
operator|->
name|s_buf
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|qp
operator|->
name|s_rfd
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|qp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|streamq
condition|)
block|{
name|streamq
operator|=
name|qp
operator|->
name|s_next
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|qsp
operator|=
name|streamq
init|;
name|qsp
operator|&&
operator|(
name|qsp
operator|->
name|s_next
operator|!=
name|qp
operator|)
condition|;
name|qsp
operator|=
name|qsp
operator|->
name|s_next
control|)
empty_stmt|;
if|if
condition|(
name|qsp
condition|)
block|{
name|qsp
operator|->
name|s_next
operator|=
name|qp
operator|->
name|s_next
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sqflush()  *	call sqrm() on all open streams  * side effects:  *	global list `streamq' becomes empty  */
end_comment

begin_function
name|void
name|sqflush
parameter_list|()
block|{
specifier|register
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|,
modifier|*
name|spnext
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|streamq
init|;
name|sp
operator|!=
name|QSTREAM_NULL
condition|;
name|sp
operator|=
name|spnext
control|)
block|{
name|spnext
operator|=
name|sp
operator|->
name|s_next
expr_stmt|;
name|sqrm
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* int  * sq_here(sp)  *	determine whether stream 'sp' is still on the streamq  * return:  *	boolean: is it here?  */
end_comment

begin_function
specifier|static
name|int
name|sq_here
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|struct
name|qstream
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|streamq
init|;
name|t
operator|!=
name|QSTREAM_NULL
condition|;
name|t
operator|=
name|t
operator|->
name|s_next
control|)
if|if
condition|(
name|t
operator|==
name|sp
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate query on stream;  * mark as referenced and stop selecting for input.  */
end_comment

begin_function
specifier|static
name|void
name|sq_query
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
block|{
name|sp
operator|->
name|s_refcnt
operator|++
expr_stmt|;
name|FD_CLR
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note that the current request on a stream has completed,  * and that we should continue looking for requests on the stream.  */
end_comment

begin_function
name|void
name|sq_done
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|struct
name|qstream
modifier|*
name|sp
decl_stmt|;
block|{
name|sp
operator|->
name|s_refcnt
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|FD_SET
argument_list|(
name|sp
operator|->
name|s_rfd
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setproctitle
parameter_list|(
name|a
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|int
name|s
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|cp
operator|=
name|Argv
index|[
literal|0
index|]
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
operator|&
name|size
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"-%s [%s]"
argument_list|,
name|a
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"getpeername: %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"-%s"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
name|LastArg
operator|-
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|LastArg
condition|)
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|net_mask
parameter_list|(
name|in
parameter_list|)
name|struct
name|in_addr
name|in
decl_stmt|;
block|{
specifier|register
name|u_int32_t
name|i
init|=
name|ntohl
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|i
argument_list|)
condition|)
return|return
operator|(
name|htonl
argument_list|(
name|IN_CLASSA_NET
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|i
argument_list|)
condition|)
return|return
operator|(
name|htonl
argument_list|(
name|IN_CLASSB_NET
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|htonl
argument_list|(
name|IN_CLASSC_NET
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD43_BSD43_NFS
argument_list|)
end_if

begin_comment
comment|/* junk needed for old Sun NFS licensees */
end_comment

begin_undef
undef|#
directive|undef
name|dn_skipname
end_undef

begin_function_decl
specifier|extern
name|char
modifier|*
name|dn_skipname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
function_decl|(
modifier|*
name|hack_skipname
function_decl|)
parameter_list|()
init|=
name|dn_skipname
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

end_unit

