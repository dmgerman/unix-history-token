begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* opncls.c -- open and close a BFD.    Copyright (C) 1990-1991 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_function_decl
specifier|extern
name|void
name|bfd_cache_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|bfd_open_file
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* fdopen is a loser -- we should use stdio exclusively.  Unfortunately    if we do that we can't use fcntl.  */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|bfd_xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Return a new BFD.  All BFD's are allocated through this routine.  */
end_comment

begin_function
name|bfd
modifier|*
name|new_bfd
parameter_list|()
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
operator|(
name|bfd
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nbfd
condition|)
return|return
literal|0
return|;
name|bfd_check_init
argument_list|()
expr_stmt|;
name|obstack_begin
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nbfd
operator|->
name|memory
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|nbfd
operator|->
name|arch_info
operator|=
operator|&
name|bfd_default_arch_struct
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|no_direction
expr_stmt|;
name|nbfd
operator|->
name|iostream
operator|=
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|where
operator|=
literal|0
expr_stmt|;
name|nbfd
operator|->
name|sections
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|format
operator|=
name|bfd_unknown
expr_stmt|;
name|nbfd
operator|->
name|my_archive
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|origin
operator|=
literal|0
expr_stmt|;
name|nbfd
operator|->
name|opened_once
operator|=
name|false
expr_stmt|;
name|nbfd
operator|->
name|output_has_begun
operator|=
name|false
expr_stmt|;
name|nbfd
operator|->
name|section_count
operator|=
literal|0
expr_stmt|;
name|nbfd
operator|->
name|usrdata
operator|=
operator|(
name|PTR
operator|)
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|sections
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|nbfd
operator|->
name|cacheable
operator|=
name|false
expr_stmt|;
name|nbfd
operator|->
name|flags
operator|=
name|NO_FLAGS
expr_stmt|;
name|nbfd
operator|->
name|mtime_set
operator|=
name|false
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new BFD as a member of archive OBFD.  */
end_comment

begin_function
name|bfd
modifier|*
name|new_bfd_contained_in
parameter_list|(
name|obfd
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
init|=
name|new_bfd
argument_list|()
decl_stmt|;
name|nbfd
operator|->
name|xvec
operator|=
name|obfd
operator|->
name|xvec
expr_stmt|;
name|nbfd
operator|->
name|my_archive
operator|=
name|obfd
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
name|nbfd
operator|->
name|target_defaulted
operator|=
name|obfd
operator|->
name|target_defaulted
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* SECTION 	Opening and Closing BFDs  */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_openr  SYNOPSIS         bfd *bfd_openr(CONST char *filename, CONST char*target);  DESCRIPTION 	This function opens the file supplied (using<<fopen>>) with the target 	supplied, it returns a pointer to the created BFD.  	If NULL is returned then an error has occured. Possible errors 	are<<no_memory>>,<<invalid_target>> or<<system_call>> error. */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|bfd_openr
argument_list|,
operator|(
name|filename
operator|,
name|target
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|filename
name|AND
name|CONST
name|char
operator|*
name|target
argument_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|nbfd
operator|=
name|new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|invalid_target
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
if|if
condition|(
name|bfd_open_file
argument_list|(
name|nbfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
comment|/* File didn't exist, or some such */
name|bfd_release
argument_list|(
name|nbfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Don't try to `optimize' this function:     o - We lock using stack space so that interrupting the locking        won't cause a storage leak.    o - We open the file stream last, since we don't want to have to        close it if anything goes wrong.  Closing the stream means closing        the file descriptor too, even though we didn't open it.  */
end_comment

begin_comment
comment|/* FUNCTION          bfd_fdopenr  SYNOPSIS          bfd *bfd_fdopenr(CONST char *filename, CONST char *target, int fd);  DESCRIPTION          bfd_fdopenr is to bfd_fopenr much like  fdopen is to fopen. 	 It opens a BFD on a file already described by the @var{fd} 	 supplied.            Possible errors are no_memory, invalid_target and system_call 	 error. */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|bfd_fdopenr
argument_list|,
operator|(
name|filename
operator|,
name|target
operator|,
name|fd
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|filename
name|AND
name|CONST
name|char
operator|*
name|target
name|AND
name|int
name|fd
argument_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|int
name|fdflags
decl_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_FCNTL
name|fdflags
operator|=
name|O_RDWR
expr_stmt|;
comment|/* Assume full access */
else|#
directive|else
name|fdflags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|=
name|new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|invalid_target
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|char
operator|*
operator|)
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* (O_ACCMODE) parens are to avoid Ultrix header file bug */
switch|switch
condition|(
name|fdflags
operator|&
operator|(
name|O_ACCMODE
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|char
operator|*
operator|)
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|char
operator|*
operator|)
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|nbfd
operator|->
name|iostream
operator|=
operator|(
name|char
operator|*
operator|)
name|fdopen
argument_list|(
name|fd
argument_list|,
name|FOPEN_RUB
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|nbfd
operator|->
name|iostream
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|obstack_free
argument_list|(
operator|&
name|nbfd
operator|->
name|memory
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* OK, put everything where it belongs */
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
comment|/* As a special case we allow a FD open for read/write to      be written through, although doing so requires that we end      the previous clause with a preposition.  */
comment|/* (O_ACCMODE) parens are to avoid Ultrix header file bug */
switch|switch
condition|(
name|fdflags
operator|&
operator|(
name|O_ACCMODE
operator|)
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|nbfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|nbfd
operator|->
name|direction
operator|=
name|both_direction
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|bfd_cache_init
argument_list|(
name|nbfd
argument_list|)
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** bfd_openw -- open for writing.   Returns a pointer to a freshly-allocated BFD on success, or NULL.    See comment by bfd_fdopenr before you try to modify this function. */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_openw  SYNOPSIS 	bfd *bfd_openw(CONST char *filename, CONST char *target);  DESCRIPTION 	Creates a BFD, associated with file @var{filename}, using the 	file format @var{target}, and returns a pointer to it.  	Possible errors are system_call_error, no_memory, 	invalid_target.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|bfd_openw
argument_list|,
operator|(
name|filename
operator|,
name|target
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|filename
name|AND
name|CONST
name|char
operator|*
name|target
argument_list|)
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|bfd_target
modifier|*
name|target_vec
decl_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
comment|/* nbfd has to point to head of malloc'ed block so that bfd_close may      reclaim it correctly. */
name|nbfd
operator|=
name|new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|target_vec
operator|=
name|bfd_find_target
argument_list|(
name|target
argument_list|,
name|nbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|write_direction
expr_stmt|;
if|if
condition|(
name|bfd_open_file
argument_list|(
name|nbfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
comment|/* File not writeable, etc */
operator|(
name|void
operator|)
name|obstack_free
argument_list|(
operator|&
name|nbfd
operator|->
name|memory
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  FUNCTION 	bfd_close  SYNOPSIS 	boolean bfd_close(bfd *);  DESCRIPTION  	This function closes a BFD. If the BFD was open for writing, 	then pending operations are completed and the file written out 	and closed. If the created file is executable, then<<chmod>> is called to mark it as such.  	All memory attached to the BFD's obstacks is released.   RETURNS<<true>> is returned if all is ok, otherwise<<false>>. */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_close
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
if|if
condition|(
operator|!
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
condition|)
if|if
condition|(
name|BFD_SEND_FMT
argument_list|(
name|abfd
argument_list|,
name|_bfd_write_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
operator|!=
name|true
condition|)
return|return
name|false
return|;
if|if
condition|(
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_close_and_cleanup
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
operator|!=
name|true
condition|)
return|return
name|false
return|;
name|bfd_cache_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* If the file was open for writing and is now executable,      make it so */
if|if
condition|(
name|abfd
operator|->
name|direction
operator|==
name|write_direction
operator|&&
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_IXUSR
define|#
directive|define
name|S_IXUSR
value|0100
comment|/* Execute by owner.  */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|S_IXGRP
define|#
directive|define
name|S_IXGRP
value|0010
comment|/* Execute by group.  */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|S_IXOTH
define|#
directive|define
name|S_IXOTH
value|0001
comment|/* Execute by others.  */
endif|#
directive|endif
name|chmod
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
literal|0777
operator|&
operator|(
name|buf
operator|.
name|st_mode
operator||
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|obstack_free
argument_list|(
operator|&
name|abfd
operator|->
name|memory
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_close_all_done  SYNOPSIS 	boolean bfd_close_all_done(bfd *);  DESCRIPTION 	This function closes a BFD. It differs from<<bfd_close>> 	since it does not complete any pending operations.  This 	routine would be used if the application had just used BFD for 	swapping and didn't want to use any of the writing code.  	If the created file is executable, then<<chmod>> is called 	to mark it as such.  	All memory attached to the BFD's obstacks is released.   RETURNS<<true>> is returned if all is ok, otherwise<<false>>.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_close_all_done
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|bfd_cache_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* If the file was open for writing and is now executable,      make it so */
if|if
condition|(
name|abfd
operator|->
name|direction
operator|==
name|write_direction
operator|&&
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_IXUSR
define|#
directive|define
name|S_IXUSR
value|0100
comment|/* Execute by owner.  */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|S_IXGRP
define|#
directive|define
name|S_IXGRP
value|0010
comment|/* Execute by group.  */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|S_IXOTH
define|#
directive|define
name|S_IXOTH
value|0001
comment|/* Execute by others.  */
endif|#
directive|endif
name|chmod
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
literal|0x777
operator|&
operator|(
name|buf
operator|.
name|st_mode
operator||
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|obstack_free
argument_list|(
operator|&
name|abfd
operator|->
name|memory
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION	 	bfd_alloc_size  SYNOPSIS 	bfd_size_type bfd_alloc_size(bfd *abfd);  DESCRIPTION         Return the number of bytes in the obstacks connected to the 	supplied BFD.  */
end_comment

begin_decl_stmt
name|bfd_size_type
name|DEFUN
argument_list|(
name|bfd_alloc_size
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|struct
name|_obstack_chunk
modifier|*
name|chunk
init|=
name|abfd
operator|->
name|memory
operator|.
name|chunk
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|chunk
condition|)
block|{
name|size
operator|+=
name|chunk
operator|->
name|limit
operator|-
operator|&
operator|(
name|chunk
operator|->
name|contents
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|chunk
operator|=
name|chunk
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_create  SYNOPSIS 	bfd *bfd_create(CONST char *filename, bfd *template);  DESCRIPTION 	This routine creates a new BFD in the manner of<<bfd_openw>>, but without opening a file. The new BFD 	takes the target from the target used by @var{template}. The 	format is always set to<<bfd_object>>.   */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|bfd_create
argument_list|,
operator|(
name|filename
operator|,
name|template
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|filename
name|AND
name|bfd
operator|*
name|template
argument_list|)
block|{
name|bfd
modifier|*
name|nbfd
init|=
name|new_bfd
argument_list|()
decl_stmt|;
if|if
condition|(
name|nbfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|bfd
operator|*
operator|)
name|NULL
return|;
block|}
name|nbfd
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|template
condition|)
block|{
name|nbfd
operator|->
name|xvec
operator|=
name|template
operator|->
name|xvec
expr_stmt|;
block|}
name|nbfd
operator|->
name|direction
operator|=
name|no_direction
expr_stmt|;
name|bfd_set_format
argument_list|(
name|nbfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  INTERNAL_FUNCTION 	bfd_alloc_by_size_t  SYNOPSIS 	PTR bfd_alloc_by_size_t(bfd *abfd, size_t wanted);  DESCRIPTION 	This function allocates a block of memory in the obstack 	attatched to<<abfd>> and returns a pointer to it. */
end_comment

begin_decl_stmt
name|PTR
name|DEFUN
argument_list|(
name|bfd_alloc_by_size_t
argument_list|,
operator|(
name|abfd
operator|,
name|size
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|size_t
name|size
argument_list|)
block|{
name|PTR
name|res
init|=
name|obstack_alloc
argument_list|(
operator|&
operator|(
name|abfd
operator|->
name|memory
operator|)
argument_list|,
name|size
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
argument|void bfd_alloc_grow
argument_list|,
argument|(abfd, ptr, size)
argument_list|,
argument|bfd *abfd AND       PTR ptr AND       bfd_size_type size
argument_list|)
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|obstack_grow
argument_list|(
operator|&
operator|(
name|abfd
operator|->
name|memory
operator|)
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
argument|PTR bfd_alloc_finish
argument_list|,
argument|(abfd)
argument_list|,
argument|bfd *abfd
argument_list|)
end_macro

begin_block
block|{
return|return
name|obstack_finish
argument_list|(
operator|&
operator|(
name|abfd
operator|->
name|memory
operator|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
argument|PTR bfd_alloc
argument_list|,
argument|(abfd, size)
argument_list|,
argument|bfd *abfd AND       bfd_size_type size
argument_list|)
end_macro

begin_block
block|{
return|return
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
argument|PTR bfd_zalloc
argument_list|,
argument|(abfd, size)
argument_list|,
argument|bfd *abfd AND       bfd_size_type size
argument_list|)
end_macro

begin_block
block|{
name|PTR
name|res
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
argument|PTR bfd_realloc
argument_list|,
argument|(abfd, old, size)
argument_list|,
argument|bfd *abfd AND       PTR old AND       bfd_size_type size
argument_list|)
end_macro

begin_block
block|{
name|PTR
name|res
init|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
name|old
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

end_unit

