begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Intel 960 b.out binaries.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"seclet.h"
end_include

begin_include
include|#
directive|include
file|"bout.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_decl_stmt
specifier|extern
name|bfd_error_vector_type
name|bfd_error_vector
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PROTO
argument_list|(
specifier|static
name|boolean
argument_list|,
name|b_out_squirt_out_relocs
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|section
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
specifier|static
name|bfd_target
operator|*
argument_list|,
name|b_out_callback
argument_list|,
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|aout_32_slurp_symbol_table
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|aout_32_write_syms
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Swaps the information in an executable header taken from a raw byte    stream memory image, into the internal exec_header structure.  */
end_comment

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|bout_swap_exec_header_in
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|external_exec
operator|*
name|raw_bytes
operator|,
expr|struct
name|internal_exec
operator|*
name|execp
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bout_swap_exec_header_in
argument_list|,
operator|(
name|abfd
operator|,
name|raw_bytes
operator|,
name|execp
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|external_exec
operator|*
name|raw_bytes
name|AND
expr|struct
name|internal_exec
operator|*
name|execp
argument_list|)
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* Now fill in fields in the execp, from the bytes in the raw data.  */
name|execp
operator|->
name|a_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_text
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_syms
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_entry
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_trsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_drsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_tload
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_tload
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_dload
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_dload
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_talign
operator|=
name|bytes
operator|->
name|e_talign
index|[
literal|0
index|]
expr_stmt|;
name|execp
operator|->
name|a_dalign
operator|=
name|bytes
operator|->
name|e_dalign
index|[
literal|0
index|]
expr_stmt|;
name|execp
operator|->
name|a_balign
operator|=
name|bytes
operator|->
name|e_balign
index|[
literal|0
index|]
expr_stmt|;
name|execp
operator|->
name|a_relaxable
operator|=
name|bytes
operator|->
name|e_relaxable
index|[
literal|0
index|]
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Swaps the information in an internal exec header structure into the    supplied buffer ready for writing to disk.  */
end_comment

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|bout_swap_exec_header_out
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|internal_exec
operator|*
name|execp
operator|,
expr|struct
name|external_exec
operator|*
name|raw_bytes
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bout_swap_exec_header_out
argument_list|,
operator|(
name|abfd
operator|,
name|execp
operator|,
name|raw_bytes
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|internal_exec
operator|*
name|execp
name|AND
expr|struct
name|external_exec
operator|*
name|raw_bytes
argument_list|)
block|{
name|struct
name|external_exec
modifier|*
name|bytes
init|=
operator|(
expr|struct
name|external_exec
operator|*
operator|)
name|raw_bytes
decl_stmt|;
comment|/* Now fill in fields in the raw data, from the fields in the exec struct. */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_info
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_text
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_data
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_bss
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_syms
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_entry
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_trsize
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_drsize
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_tload
argument_list|,
name|bytes
operator|->
name|e_tload
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_dload
argument_list|,
name|bytes
operator|->
name|e_dload
argument_list|)
expr_stmt|;
name|bytes
operator|->
name|e_talign
index|[
literal|0
index|]
operator|=
name|execp
operator|->
name|a_talign
expr_stmt|;
name|bytes
operator|->
name|e_dalign
index|[
literal|0
index|]
operator|=
name|execp
operator|->
name|a_dalign
expr_stmt|;
name|bytes
operator|->
name|e_balign
index|[
literal|0
index|]
operator|=
name|execp
operator|->
name|a_balign
expr_stmt|;
name|bytes
operator|->
name|e_relaxable
index|[
literal|0
index|]
operator|=
name|execp
operator|->
name|a_relaxable
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|bfd_target
modifier|*
name|b_out_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|internal_exec
name|anexec
decl_stmt|;
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|exec_bytes
argument_list|,
literal|1
argument_list|,
name|EXEC_BYTES_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|EXEC_BYTES_SIZE
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
name|anexec
operator|.
name|a_info
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|exec_bytes
operator|.
name|e_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|anexec
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bout_swap_exec_header_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|exec_bytes
argument_list|,
operator|&
name|anexec
argument_list|)
expr_stmt|;
return|return
name|aout_32_some_aout_object_p
argument_list|(
name|abfd
argument_list|,
operator|&
name|anexec
argument_list|,
name|b_out_callback
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish up the opening of a b.out file for reading.  Fill in all the    fields that are not handled by common code.  */
end_comment

begin_function
specifier|static
name|bfd_target
modifier|*
name|b_out_callback
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|bss_start
decl_stmt|;
comment|/* Architecture and machine type */
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_i960
argument_list|,
comment|/* B.out only used on i960 */
name|bfd_mach_i960_core
comment|/* Default */
argument_list|)
expr_stmt|;
comment|/* The positions of the string table and symbol table.  */
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_STROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_SYMOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The alignments of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_talign
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_dalign
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_balign
expr_stmt|;
comment|/* The starting addresses of the sections.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|execp
operator|->
name|a_tload
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|execp
operator|->
name|a_dload
expr_stmt|;
comment|/* And reload the sizes, since the aout module zaps them */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|execp
operator|->
name|a_text
expr_stmt|;
name|bss_start
operator|=
name|execp
operator|->
name|a_dload
operator|+
name|execp
operator|->
name|a_data
expr_stmt|;
comment|/* BSS = end of data section */
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|align_power
argument_list|(
name|bss_start
argument_list|,
name|execp
operator|->
name|a_balign
argument_list|)
expr_stmt|;
comment|/* The file positions of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_TXTOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_DATOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file positions of the relocation info */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_TROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_DROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable. */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable. */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
if|if
condition|(
name|execp
operator|->
name|a_relaxable
condition|)
name|abfd
operator|->
name|flags
operator||=
name|BFD_IS_RELAXABLE
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_struct
struct|struct
name|bout_data_struct
block|{
name|struct
name|aoutdata
name|a
decl_stmt|;
name|struct
name|internal_exec
name|e
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|boolean
name|b_out_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|bout_data_struct
modifier|*
name|rawptr
decl_stmt|;
name|rawptr
operator|=
operator|(
expr|struct
name|bout_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bout_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|abfd
operator|->
name|tdata
operator|.
name|bout_data
operator|=
name|rawptr
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|&
name|rawptr
operator|->
name|e
expr_stmt|;
comment|/* For simplicity's sake we just make all the sections right here. */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|b_out_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|external_exec
name|swapped_hdr
decl_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_info
operator|=
name|BMAGIC
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_text
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_data
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_bss
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|=
operator|(
operator|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|=
operator|(
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_talign
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_dalign
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_balign
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_tload
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_dload
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|bout_swap_exec_header_out
argument_list|(
name|abfd
argument_list|,
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|&
name|swapped_hdr
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|swapped_hdr
argument_list|,
literal|1
argument_list|,
name|EXEC_BYTES_SIZE
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* Now write out reloc info, followed by syms and strings */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_SYMOFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|aout_32_write_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_TROFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_out_squirt_out_relocs
argument_list|(
name|abfd
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_DROFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b_out_squirt_out_relocs
argument_list|(
name|abfd
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Some reloc hackery */
end_comment

begin_define
define|#
directive|define
name|CALLS
value|0x66003800
end_define

begin_comment
comment|/* Template for 'calls' instruction	*/
end_comment

begin_define
define|#
directive|define
name|BAL
value|0x0b000000
end_define

begin_comment
comment|/* Template for 'bal' instruction */
end_comment

begin_define
define|#
directive|define
name|BALX
value|0x85000000
end_define

begin_comment
comment|/* Template for 'balx' instruction	*/
end_comment

begin_define
define|#
directive|define
name|BAL_MASK
value|0x00ffffff
end_define

begin_define
define|#
directive|define
name|CALL
value|0x09000000
end_define

begin_define
define|#
directive|define
name|PCREL13_MASK
value|0x1fff
end_define

begin_comment
comment|/* Magic to turn callx into calljx */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|DEFUN
argument_list|(
name|calljx_callback
argument_list|,
operator|(
name|abfd
operator|,
name|reloc_entry
operator|,
name|src
operator|,
name|dst
operator|,
name|input_section
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|arelent
operator|*
name|reloc_entry
name|AND
name|PTR
name|src
name|AND
name|PTR
name|dst
name|AND
name|asection
operator|*
name|input_section
argument_list|)
block|{
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
init|=
operator|*
operator|(
name|reloc_entry
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|aout_symbol_type
modifier|*
name|symbol
init|=
name|aout_symbol
argument_list|(
name|symbol_in
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_CALLNAME
argument_list|(
name|symbol
operator|->
name|other
argument_list|)
condition|)
block|{
name|aout_symbol_type
modifier|*
name|balsym
init|=
name|symbol
operator|+
literal|1
decl_stmt|;
name|int
name|inst
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|-
literal|4
argument_list|)
decl_stmt|;
comment|/* The next symbol should be an N_BALNAME */
name|BFD_ASSERT
argument_list|(
name|IS_BALNAME
argument_list|(
name|balsym
operator|->
name|other
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|&=
name|BAL_MASK
expr_stmt|;
name|inst
operator||=
name|BALX
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|inst
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|dst
operator|-
literal|4
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|balsym
expr_stmt|;
block|}
name|word
operator|+=
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
operator|+
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|symbol
operator|.
name|value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|word
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Magic to turn call into callj */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|DEFUN
argument_list|(
name|callj_callback
argument_list|,
operator|(
name|abfd
operator|,
name|reloc_entry
operator|,
name|data
operator|,
name|srcidx
operator|,
name|dstidx
operator|,
name|input_section
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|arelent
operator|*
name|reloc_entry
name|AND
name|PTR
name|data
name|AND
name|unsigned
name|int
name|srcidx
name|AND
name|unsigned
name|int
name|dstidx
name|AND
name|asection
operator|*
name|input_section
argument_list|)
block|{
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|srcidx
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
init|=
operator|*
operator|(
name|reloc_entry
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|aout_symbol_type
modifier|*
name|symbol
init|=
name|aout_symbol
argument_list|(
name|symbol_in
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_OTHER
argument_list|(
name|symbol
operator|->
name|other
argument_list|)
condition|)
block|{
comment|/* Call to a system procedure - replace code with system        procedure number */
name|word
operator|=
name|CALLS
operator||
operator|(
name|symbol
operator|->
name|other
operator|-
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_CALLNAME
argument_list|(
name|symbol
operator|->
name|other
argument_list|)
condition|)
block|{
name|aout_symbol_type
modifier|*
name|balsym
init|=
name|symbol
operator|+
literal|1
decl_stmt|;
comment|/* The next symbol should be an N_BALNAME */
name|BFD_ASSERT
argument_list|(
name|IS_BALNAME
argument_list|(
name|balsym
operator|->
name|other
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are calling a leaf - so replace the call instruction        with a bal */
name|word
operator|=
name|BAL
operator||
operator|(
operator|(
operator|(
name|word
operator|&
name|BAL_MASK
operator|)
operator|+
name|balsym
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
operator|+
name|balsym
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|balsym
operator|->
name|symbol
operator|.
name|value
operator|+
name|reloc_entry
operator|->
name|addend
operator|-
name|dstidx
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
operator|)
operator|&
name|BAL_MASK
operator|)
expr_stmt|;
block|}
else|else
block|{
name|word
operator|=
name|CALL
operator||
operator|(
operator|(
operator|(
name|word
operator|&
name|BAL_MASK
operator|)
operator|+
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
operator|+
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|symbol
operator|.
name|value
operator|+
name|reloc_entry
operator|->
name|addend
operator|-
name|dstidx
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
operator|)
operator|&
name|BAL_MASK
operator|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|word
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|dstidx
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_decl_stmt

begin_comment
comment|/* type rshift size  bitsize  	pcrel	bitpos  absolute overflow check*/
end_comment

begin_define
define|#
directive|define
name|ABS32CODE
value|0
end_define

begin_define
define|#
directive|define
name|ABS32CODE_SHRUNK
value|1
end_define

begin_define
define|#
directive|define
name|PCREL24
value|2
end_define

begin_define
define|#
directive|define
name|CALLJ
value|3
end_define

begin_define
define|#
directive|define
name|ABS32
value|4
end_define

begin_define
define|#
directive|define
name|PCREL13
value|5
end_define

begin_define
define|#
directive|define
name|ABS32_MAYBE_RELAXABLE
value|1
end_define

begin_define
define|#
directive|define
name|ABS32_WAS_RELAXABLE
value|2
end_define

begin_define
define|#
directive|define
name|ALIGNER
value|10
end_define

begin_define
define|#
directive|define
name|ALIGNDONE
value|11
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_callj
init|=
name|HOWTO
argument_list|(
name|CALLJ
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"callj"
argument_list|,
name|true
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_abs32
init|=
name|HOWTO
argument_list|(
name|ABS32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"abs32"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_pcrel24
init|=
name|HOWTO
argument_list|(
name|PCREL24
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"pcrel24"
argument_list|,
name|true
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_pcrel13
init|=
name|HOWTO
argument_list|(
name|PCREL13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"pcrel13"
argument_list|,
name|true
argument_list|,
literal|0x00001fff
argument_list|,
literal|0x00001fff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_abs32codeshrunk
init|=
name|HOWTO
argument_list|(
name|ABS32CODE_SHRUNK
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"callx->callj"
argument_list|,
name|true
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_abs32code
init|=
name|HOWTO
argument_list|(
name|ABS32CODE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
literal|"callx"
argument_list|,
name|true
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_align_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|ALIGNER
argument_list|,
literal|0
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"align16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNER
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"align32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNER
argument_list|,
literal|0
argument_list|,
literal|0x7
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"align64"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNER
argument_list|,
literal|0
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"align128"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_done_align_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|ALIGNDONE
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"donealign16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNDONE
argument_list|,
literal|0x3
argument_list|,
literal|0x3
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"donealign32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNDONE
argument_list|,
literal|0x7
argument_list|,
literal|0x7
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"donealign64"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNDONE
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|"donealign128"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|b_out_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|BFD_RELOC_I960_CALLJ
case|:
return|return
operator|&
name|howto_reloc_callj
return|;
case|case
name|BFD_RELOC_32
case|:
return|return
operator|&
name|howto_reloc_abs32
return|;
case|case
name|BFD_RELOC_24_PCREL
case|:
return|return
operator|&
name|howto_reloc_pcrel24
return|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate enough room for all the reloc entries, plus pointers to them all */
end_comment

begin_function
specifier|static
name|boolean
name|b_out_slurp_reloc_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
specifier|register
name|struct
name|relocation_info
modifier|*
name|rptr
decl_stmt|;
name|unsigned
name|int
name|counter
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|int
name|extern_mask
decl_stmt|,
name|pcrel_mask
decl_stmt|,
name|callj_mask
decl_stmt|,
name|length_shift
decl_stmt|;
name|int
name|incode_mask
decl_stmt|;
name|int
name|size_mask
decl_stmt|;
name|bfd_vma
name|prev_addr
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|size_t
name|reloc_size
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|aout_32_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
name|doit
label|:
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|asect
operator|->
name|rel_filepos
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|count
operator|=
name|reloc_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|relocs
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|bfd_xmalloc
argument_list|(
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocs
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_xmalloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_cache
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|relocs
argument_list|)
expr_stmt|;
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|relocs
argument_list|,
literal|1
argument_list|,
name|reloc_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|reloc_size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
name|free
argument_list|(
name|reloc_cache
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
block|{
comment|/* big-endian bit field allocation order */
name|pcrel_mask
operator|=
literal|0x80
expr_stmt|;
name|extern_mask
operator|=
literal|0x10
expr_stmt|;
name|incode_mask
operator|=
literal|0x08
expr_stmt|;
name|callj_mask
operator|=
literal|0x02
expr_stmt|;
name|size_mask
operator|=
literal|0x20
expr_stmt|;
name|length_shift
operator|=
literal|5
expr_stmt|;
block|}
else|else
block|{
comment|/* little-endian bit field allocation order */
name|pcrel_mask
operator|=
literal|0x01
expr_stmt|;
name|extern_mask
operator|=
literal|0x08
expr_stmt|;
name|incode_mask
operator|=
literal|0x10
expr_stmt|;
name|callj_mask
operator|=
literal|0x40
expr_stmt|;
name|size_mask
operator|=
literal|0x02
expr_stmt|;
name|length_shift
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|rptr
operator|=
name|relocs
operator|,
name|cache_ptr
operator|=
name|reloc_cache
operator|,
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rptr
decl_stmt|;
name|unsigned
name|int
name|symnum
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|raw
operator|+
literal|0
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
block|{
name|symnum
operator|=
operator|(
name|raw
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|raw
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|6
index|]
expr_stmt|;
block|}
else|else
block|{
name|symnum
operator|=
operator|(
name|raw
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|raw
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|4
index|]
expr_stmt|;
block|}
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|extern_mask
condition|)
block|{
comment|/* if this is set then the r_index is a index into the symbol table;        * if the bit is not set then r_index contains a section map.        * we either fill in the sym entry with a pointer to the symbol,        * or point to the correct section        */
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|symnum
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* in a.out symbols are relative to the beginning of the        * file rather than sections ?        * (look in translate_from_native_sym_flags)        * the reloc entry addend has added to it the offset into the        * file of the data, so subtract the base to make the reloc        * section relative */
name|int
name|s
decl_stmt|;
block|{
comment|/* sign-extend symnum from 24 bits to whatever host uses */
name|s
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
name|s
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|s
operator||=
operator|(
operator|~
literal|0
operator|)
operator|<<
literal|24
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
operator|-
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
operator|-
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
operator|-
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
comment|/* .align */
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|pcrel_mask
condition|)
block|{
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_align_table
index|[
operator|(
name|raw
index|[
literal|7
index|]
operator|>>
name|length_shift
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|bfd_abs_symbol
expr_stmt|;
block|}
else|else
block|{
comment|/* .org? */
name|abort
argument_list|()
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* the i960 only has a few relocation types:        abs 32-bit and pcrel 24bit.   except for callj's!  */
if|if
condition|(
name|cache_ptr
operator|->
name|howto
operator|!=
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|callj_mask
condition|)
block|{
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_callj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|pcrel_mask
condition|)
block|{
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|size_mask
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_pcrel13
expr_stmt|;
else|else
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_pcrel24
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|incode_mask
condition|)
block|{
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_abs32code
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_abs32
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cache_ptr
operator|->
name|address
operator|<
name|prev_addr
condition|)
block|{
comment|/* Ouch! this reloc is out of order, insert into the right place        */
name|arelent
name|tmp
decl_stmt|;
name|arelent
modifier|*
name|cursor
init|=
name|cache_ptr
operator|-
literal|1
decl_stmt|;
name|bfd_vma
name|stop
init|=
name|cache_ptr
operator|->
name|address
decl_stmt|;
name|tmp
operator|=
operator|*
name|cache_ptr
expr_stmt|;
while|while
condition|(
name|cursor
operator|->
name|address
operator|>
name|stop
operator|&&
name|cursor
operator|>=
name|reloc_cache
condition|)
block|{
name|cursor
index|[
literal|1
index|]
operator|=
name|cursor
index|[
literal|0
index|]
expr_stmt|;
name|cursor
operator|--
expr_stmt|;
block|}
name|cursor
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|prev_addr
operator|=
name|cache_ptr
operator|->
name|address
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|count
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|b_out_squirt_out_relocs
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|arelent
modifier|*
modifier|*
name|generic
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|int
name|r_idx
decl_stmt|;
name|int
name|incode_mask
decl_stmt|;
name|int
name|len_1
decl_stmt|;
name|unsigned
name|int
name|count
init|=
name|section
operator|->
name|reloc_count
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|native
decl_stmt|,
modifier|*
name|natptr
decl_stmt|;
name|size_t
name|natsize
init|=
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
decl_stmt|;
name|int
name|extern_mask
decl_stmt|,
name|pcrel_mask
decl_stmt|,
name|len_2
decl_stmt|,
name|callj_mask
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|generic
operator|=
name|section
operator|->
name|orelocation
expr_stmt|;
name|native
operator|=
operator|(
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|bfd_xmalloc
argument_list|(
name|natsize
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|native
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
block|{
comment|/* Big-endian bit field allocation order */
name|pcrel_mask
operator|=
literal|0x80
expr_stmt|;
name|extern_mask
operator|=
literal|0x10
expr_stmt|;
name|len_2
operator|=
literal|0x40
expr_stmt|;
name|len_1
operator|=
literal|0x20
expr_stmt|;
name|callj_mask
operator|=
literal|0x02
expr_stmt|;
name|incode_mask
operator|=
literal|0x08
expr_stmt|;
block|}
else|else
block|{
comment|/* Little-endian bit field allocation order */
name|pcrel_mask
operator|=
literal|0x01
expr_stmt|;
name|extern_mask
operator|=
literal|0x08
expr_stmt|;
name|len_2
operator|=
literal|0x04
expr_stmt|;
name|len_1
operator|=
literal|0x02
expr_stmt|;
name|callj_mask
operator|=
literal|0x40
expr_stmt|;
name|incode_mask
operator|=
literal|0x10
expr_stmt|;
block|}
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
operator|,
operator|++
name|natptr
operator|,
operator|++
name|generic
control|)
block|{
name|arelent
modifier|*
name|g
init|=
operator|*
name|generic
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|natptr
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|raw
argument_list|)
expr_stmt|;
comment|/* Find a type in the output format which matches the input howto -       * at the moment we assume input format == output format FIXME!!      */
comment|/* FIXME:  Need callj stuff here, and to check the howto entries to        be sure they are real for this architecture.  */
if|if
condition|(
name|g
operator|->
name|howto
operator|==
operator|&
name|howto_reloc_callj
condition|)
block|{
name|raw
index|[
literal|7
index|]
operator|=
name|callj_mask
operator|+
name|pcrel_mask
operator|+
name|len_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|howto
operator|==
operator|&
name|howto_reloc_pcrel24
condition|)
block|{
name|raw
index|[
literal|7
index|]
operator|=
name|pcrel_mask
operator|+
name|len_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|howto
operator|==
operator|&
name|howto_reloc_pcrel13
condition|)
block|{
name|raw
index|[
literal|7
index|]
operator|=
name|pcrel_mask
operator|+
name|len_1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|howto
operator|==
operator|&
name|howto_reloc_abs32code
condition|)
block|{
name|raw
index|[
literal|7
index|]
operator|=
name|len_2
operator|+
name|incode_mask
expr_stmt|;
block|}
else|else
block|{
name|raw
index|[
literal|7
index|]
operator|=
name|len_2
expr_stmt|;
block|}
if|if
condition|(
name|output_section
operator|==
operator|&
name|bfd_com_section
operator|||
name|output_section
operator|==
operator|&
name|bfd_abs_section
operator|||
name|output_section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
if|if
condition|(
name|bfd_abs_section
operator|.
name|symbol
operator|==
name|sym
condition|)
block|{
comment|/* Whoops, looked like an abs symbol, but is really an offset 	   from the abs section */
name|r_idx
operator|=
literal|0
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in symbol */
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_idx
operator|=
name|stoi
argument_list|(
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just an ordinary section */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_idx
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|header_byteorder_big_p
condition|)
block|{
name|raw
index|[
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|raw
index|[
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|raw
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|raw
index|[
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|raw
index|[
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_extern
condition|)
name|raw
index|[
literal|7
index|]
operator||=
name|extern_mask
expr_stmt|;
block|}
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|native
argument_list|,
literal|1
argument_list|,
name|natsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|natsize
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|native
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|native
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is stupid.  This function should be a boolean predicate */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|b_out_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tblptr
operator|||
name|b_out_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
if|if
condition|(
operator|!
name|tblptr
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|b_out_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|)
return|;
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|)
return|;
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|boolean
name|b_out_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
comment|/* set by bfd.c handler */
if|if
condition|(
operator|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|)
comment|/*||         (obj_textsec (abfd)->_cooked_size == 0) || (obj_datasec (abfd)->_cooked_size == 0)*/
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
expr_stmt|;
block|}
comment|/* regardless, once we know what we're doing, we might as well get going */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|==
name|count
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|b_out_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|bfd_arch_unknown
condition|)
comment|/* Unknown machine arch is OK */
return|return
name|true
return|;
if|if
condition|(
name|arch
operator|==
name|bfd_arch_i960
condition|)
comment|/* i960 default is OK */
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|bfd_mach_i960_core
case|:
case|case
name|bfd_mach_i960_kb_sb
case|:
case|case
name|bfd_mach_i960_mc
case|:
case|case
name|bfd_mach_i960_xa
case|:
case|case
name|bfd_mach_i960_ca
case|:
case|case
name|bfd_mach_i960_ka_sa
case|:
case|case
literal|0
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|b_out_sizeof_headers
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|ignore
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|boolean
name|ignore
argument_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|internal_exec
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|DEFUN
argument_list|(
name|get_value
argument_list|,
operator|(
name|reloc
operator|,
name|seclet
operator|)
argument_list|,
name|arelent
operator|*
name|reloc
name|AND
name|bfd_seclet_type
operator|*
name|seclet
argument_list|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|asymbol
modifier|*
name|symbol
init|=
operator|*
operator|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
comment|/* A symbol holds a pointer to a section, and an offset from the      base of the section.  To relocate, we find where the section will      live in the output and add that in */
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
comment|/* Ouch, this is an undefined symbol.. */
name|bfd_error_vector
operator|.
name|undefined_symbol
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
expr_stmt|;
name|value
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* Add the value contained in the relocation */
name|value
operator|+=
call|(
name|short
call|)
argument_list|(
operator|(
name|reloc
operator|->
name|addend
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|perform_slip
argument_list|,
operator|(
name|s
operator|,
name|slip
operator|,
name|input_section
operator|,
name|value
operator|)
argument_list|,
name|asymbol
operator|*
operator|*
name|s
name|AND
name|unsigned
name|int
name|slip
name|AND
name|asection
operator|*
name|input_section
name|AND
name|bfd_vma
name|value
argument_list|)
block|{
comment|/* Find all symbols past this point, and make them know      what's happened */
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|input_section
condition|)
block|{
comment|/* This was pointing into this section, so mangle it */
if|if
condition|(
name|p
operator|->
name|value
operator|>
name|value
condition|)
block|{
name|p
operator|->
name|value
operator|-=
name|slip
expr_stmt|;
block|}
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* This routine works out if the thing we want to get to can be    reached with a 24bit offset instead of a 32 bit one.    If it can, then it changes the amode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|abs32code
argument_list|,
operator|(
name|input_section
operator|,
name|symbols
operator|,
name|r
operator|,
name|shrink
operator|)
argument_list|,
name|asection
operator|*
name|input_section
name|AND
name|asymbol
operator|*
operator|*
name|symbols
name|AND
name|arelent
operator|*
name|r
name|AND
name|unsigned
name|int
name|shrink
argument_list|)
block|{
name|bfd_vma
name|value
init|=
name|get_value
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bfd_vma
name|dot
init|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|r
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|gap
decl_stmt|;
comment|/* See if the address we're looking at within 2^23 bytes of where      we are, if so then we can use a small branch rather than the      jump we were going to */
name|gap
operator|=
name|value
operator|-
operator|(
name|dot
operator|-
name|shrink
operator|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|<<
literal|23
operator|<
operator|(
name|long
operator|)
name|gap
operator|&&
operator|(
name|long
operator|)
name|gap
operator|<
literal|1
operator|<<
literal|23
condition|)
block|{
comment|/* Change the reloc type from 32bitcode possible 24, to 24bit        possible 32 */
name|r
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_abs32codeshrunk
expr_stmt|;
comment|/* The place to relc moves back by four bytes */
name|r
operator|->
name|address
operator|-=
literal|4
expr_stmt|;
comment|/* This will be four bytes smaller in the long run */
name|shrink
operator|+=
literal|4
expr_stmt|;
name|perform_slip
argument_list|(
name|symbols
argument_list|,
literal|4
argument_list|,
name|input_section
argument_list|,
name|r
operator|->
name|address
operator|-
name|shrink
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|shrink
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|aligncode
argument_list|,
operator|(
name|input_section
operator|,
name|symbols
operator|,
name|r
operator|,
name|shrink
operator|)
argument_list|,
name|asection
operator|*
name|input_section
name|AND
name|asymbol
operator|*
operator|*
name|symbols
name|AND
name|arelent
operator|*
name|r
name|AND
name|unsigned
name|int
name|shrink
argument_list|)
block|{
name|bfd_vma
name|dot
init|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|r
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|gap
decl_stmt|;
name|bfd_vma
name|old_end
decl_stmt|;
name|bfd_vma
name|new_end
decl_stmt|;
name|int
name|shrink_delta
decl_stmt|;
name|int
name|size
init|=
name|r
operator|->
name|howto
operator|->
name|size
decl_stmt|;
comment|/* Reduce the size of the alignment so that it's still aligned but      smaller  - the current size is already the same size as or bigger      than the alignment required.  */
comment|/* calculate the first byte following the padding before we optimize */
name|old_end
operator|=
operator|(
operator|(
name|dot
operator|+
name|size
operator|)
operator|&
operator|~
name|size
operator|)
operator|+
name|size
operator|+
literal|1
expr_stmt|;
comment|/* work out where the new end will be - remember that we're smaller      than we used to be */
name|new_end
operator|=
operator|(
operator|(
name|dot
operator|-
name|shrink
operator|+
name|size
operator|)
operator|&
operator|~
name|size
operator|)
expr_stmt|;
comment|/* This is the new end */
name|gap
operator|=
name|old_end
operator|-
operator|(
operator|(
name|dot
operator|+
name|size
operator|)
operator|&
operator|~
name|size
operator|)
expr_stmt|;
name|shrink_delta
operator|=
operator|(
name|old_end
operator|-
name|new_end
operator|)
operator|-
name|shrink
expr_stmt|;
if|if
condition|(
name|shrink_delta
condition|)
block|{
comment|/* Change the reloc so that it knows how far to align to */
name|r
operator|->
name|howto
operator|=
name|howto_done_align_table
operator|+
operator|(
name|r
operator|->
name|howto
operator|-
name|howto_align_table
operator|)
expr_stmt|;
comment|/* Encode the stuff into the addend - for future use we need to        know how big the reloc used to be */
name|r
operator|->
name|addend
operator|=
name|old_end
expr_stmt|;
comment|/* This will be N bytes smaller in the long run, adjust all the symbols */
name|perform_slip
argument_list|(
name|symbols
argument_list|,
name|shrink_delta
argument_list|,
name|input_section
argument_list|,
name|r
operator|->
name|address
operator|-
name|shrink
argument_list|)
expr_stmt|;
name|shrink
operator|+=
name|shrink_delta
expr_stmt|;
block|}
return|return
name|shrink
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|b_out_relax_section
argument_list|,
operator|(
name|abfd
operator|,
name|i
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|i
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|i
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|i
decl_stmt|;
name|int
name|shrink
init|=
literal|0
decl_stmt|;
name|boolean
name|new
init|=
name|false
decl_stmt|;
name|bfd_size_type
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|reloc_size
argument_list|)
decl_stmt|;
comment|/* Get the relocs and think about them */
if|if
condition|(
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
condition|;
name|parent
operator|++
control|)
block|{
name|arelent
modifier|*
name|r
init|=
operator|*
name|parent
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|ALIGNER
case|:
comment|/* An alignment reloc */
name|shrink
operator|=
name|aligncode
argument_list|(
name|input_section
argument_list|,
name|symbols
argument_list|,
name|r
argument_list|,
name|shrink
argument_list|)
expr_stmt|;
name|new
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ABS32CODE
case|:
comment|/* A 32bit reloc in an addressing mode */
name|shrink
operator|=
name|abs32code
argument_list|(
name|input_section
argument_list|,
name|symbols
argument_list|,
name|r
argument_list|,
name|shrink
argument_list|)
expr_stmt|;
name|new
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ABS32CODE_SHRUNK
case|:
name|shrink
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
block|}
name|input_section
operator|->
name|_cooked_size
operator|=
name|input_section
operator|->
name|_raw_size
operator|-
name|shrink
expr_stmt|;
return|return
name|new
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|DEFUN
argument_list|(
name|b_out_get_relocated_section_contents
argument_list|,
operator|(
name|in_abfd
operator|,
name|seclet
operator|,
name|data
operator|)
argument_list|,
name|bfd
operator|*
name|in_abfd
name|AND
name|bfd_seclet_type
operator|*
name|seclet
name|AND
name|bfd_byte
operator|*
name|data
argument_list|)
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd_size_type
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|reloc_size
argument_list|)
decl_stmt|;
comment|/* read in the section */
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|symbols
argument_list|)
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
init|=
name|reloc_vector
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|unsigned
name|int
name|dst_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|src_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|run
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
comment|/* Find how long a run we can do */
while|while
condition|(
name|dst_address
operator|<
name|seclet
operator|->
name|size
condition|)
block|{
name|reloc
operator|=
operator|*
name|parent
expr_stmt|;
if|if
condition|(
name|reloc
condition|)
block|{
comment|/* Note that the relaxing didn't tie up the addresses in the 	   relocation, so we use the original address to work out the 	   run of non-relocated data */
name|run
operator|=
name|reloc
operator|->
name|address
operator|-
name|src_address
expr_stmt|;
name|parent
operator|++
expr_stmt|;
block|}
else|else
block|{
name|run
operator|=
name|seclet
operator|->
name|size
operator|-
name|dst_address
expr_stmt|;
block|}
comment|/* Copy the bytes */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|run
condition|;
name|idx
operator|++
control|)
block|{
name|data
index|[
name|dst_address
operator|++
index|]
operator|=
name|data
index|[
name|src_address
operator|++
index|]
expr_stmt|;
block|}
comment|/* Now do the relocation */
if|if
condition|(
name|reloc
condition|)
block|{
switch|switch
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|ABS32CODE
case|:
name|calljx_callback
argument_list|(
name|in_abfd
argument_list|,
name|reloc
argument_list|,
name|src_address
operator|+
name|data
argument_list|,
name|dst_address
operator|+
name|data
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|ABS32
case|:
name|bfd_put_32
argument_list|(
name|in_abfd
argument_list|,
name|get_value
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|CALLJ
case|:
name|callj_callback
argument_list|(
name|in_abfd
argument_list|,
name|reloc
argument_list|,
name|data
argument_list|,
name|src_address
argument_list|,
name|dst_address
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|ALIGNDONE
case|:
name|src_address
operator|=
name|reloc
operator|->
name|addend
expr_stmt|;
name|dst_address
operator|=
operator|(
name|dst_address
operator|+
name|reloc
operator|->
name|howto
operator|->
name|size
operator|)
operator|&
operator|~
name|reloc
operator|->
name|howto
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|ABS32CODE_SHRUNK
case|:
comment|/* This used to be a callx, but we've found out that a 	     callj will reach, so do the right thing */
name|callj_callback
argument_list|(
name|in_abfd
argument_list|,
name|reloc
argument_list|,
name|data
argument_list|,
name|src_address
operator|+
literal|4
argument_list|,
name|dst_address
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|PCREL24
case|:
block|{
name|long
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|in_abfd
argument_list|,
name|data
operator|+
name|src_address
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|symbol
init|=
operator|*
operator|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|word
operator|=
operator|(
name|word
operator|&
operator|~
name|BAL_MASK
operator|)
operator||
operator|(
operator|(
operator|(
name|word
operator|&
name|BAL_MASK
operator|)
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|value
operator|+
name|reloc
operator|->
name|addend
operator|-
name|dst_address
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
operator|)
operator|&
name|BAL_MASK
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|in_abfd
argument_list|,
name|word
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|PCREL13
case|:
block|{
name|long
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|in_abfd
argument_list|,
name|data
operator|+
name|src_address
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|symbol
init|=
operator|*
operator|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|word
operator|=
operator|(
name|word
operator|&
operator|~
name|PCREL13_MASK
operator|)
operator||
operator|(
operator|(
operator|(
name|word
operator|&
name|PCREL13_MASK
operator|)
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|value
operator|+
name|reloc
operator|->
name|addend
operator|-
name|dst_address
operator|-
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
operator|)
operator|&
name|PCREL13_MASK
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|in_abfd
argument_list|,
name|word
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|data
return|;
block|}
end_decl_stmt

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* Build the transfer vectors for Big and Little-Endian B.OUT files.  */
end_comment

begin_comment
comment|/* We don't have core files.  */
end_comment

begin_define
define|#
directive|define
name|aout_32_core_file_failing_command
value|_bfd_dummy_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|aout_32_core_file_failing_signal
value|_bfd_dummy_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|aout_32_core_file_matches_executable_p
define|\
value|_bfd_dummy_core_file_matches_executable_p
end_define

begin_comment
comment|/* We use BSD-Unix generic archive files.  */
end_comment

begin_define
define|#
directive|define
name|aout_32_openr_next_archived_file
value|bfd_generic_openr_next_archived_file
end_define

begin_define
define|#
directive|define
name|aout_32_generic_stat_arch_elt
value|bfd_generic_stat_arch_elt
end_define

begin_define
define|#
directive|define
name|aout_32_slurp_armap
value|bfd_slurp_bsd_armap
end_define

begin_define
define|#
directive|define
name|aout_32_slurp_extended_name_table
value|bfd_true
end_define

begin_define
define|#
directive|define
name|aout_32_write_armap
value|bsd_write_armap
end_define

begin_define
define|#
directive|define
name|aout_32_truncate_arname
value|bfd_bsd_truncate_arname
end_define

begin_comment
comment|/* We override these routines from the usual a.out file routines.  */
end_comment

begin_define
define|#
directive|define
name|aout_32_canonicalize_reloc
value|b_out_canonicalize_reloc
end_define

begin_define
define|#
directive|define
name|aout_32_get_reloc_upper_bound
value|b_out_get_reloc_upper_bound
end_define

begin_define
define|#
directive|define
name|aout_32_set_section_contents
value|b_out_set_section_contents
end_define

begin_define
define|#
directive|define
name|aout_32_set_arch_mach
value|b_out_set_arch_mach
end_define

begin_define
define|#
directive|define
name|aout_32_sizeof_headers
value|b_out_sizeof_headers
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_debug_info_accumulate
value|(PROTO(void,(*),(bfd*, struct sec *))) bfd_void
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_get_relocated_section_contents
value|b_out_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|aout_32_bfd_relax_section
value|b_out_relax_section
end_define

begin_decl_stmt
name|bfd_target
name|b_out_vec_big_host
init|=
block|{
literal|"b.out.big"
block|,
comment|/* name */
name|bfd_target_aout_flavour
block|,
name|false
block|,
comment|/* data byte order is little */
name|true
block|,
comment|/* hdr byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|'_'
block|,
comment|/* symbol leading char */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|2
block|,
comment|/* minumum alignment power */
name|_do_getl64
block|,
name|_do_putl64
block|,
name|_do_getl32
block|,
name|_do_putl32
block|,
name|_do_getl16
block|,
name|_do_putl16
block|,
comment|/* data */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|b_out_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|b_out_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|b_out_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|JUMP_TABLE
argument_list|(
name|aout_32
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* COFF stuff?! */
name|b_out_reloc_type_lookup
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_target
name|b_out_vec_little_host
init|=
block|{
literal|"b.out.little"
block|,
comment|/* name */
name|bfd_target_aout_flavour
block|,
name|false
block|,
comment|/* data byte order is little */
name|false
block|,
comment|/* header byte order is little */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|'_'
block|,
comment|/* symbol leading char */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|2
block|,
comment|/* minum align */
name|_do_getl64
block|,
name|_do_putl64
block|,
name|_do_getl32
block|,
name|_do_putl32
block|,
name|_do_getl16
block|,
name|_do_putl16
block|,
comment|/* data */
name|_do_getl64
block|,
name|_do_putl64
block|,
name|_do_getl32
block|,
name|_do_putl32
block|,
name|_do_getl16
block|,
name|_do_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|b_out_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|b_out_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|b_out_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|JUMP_TABLE
argument_list|(
name|aout_32
argument_list|)
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* COFF stuff?! */
name|b_out_reloc_type_lookup
block|, }
decl_stmt|;
end_decl_stmt

end_unit

