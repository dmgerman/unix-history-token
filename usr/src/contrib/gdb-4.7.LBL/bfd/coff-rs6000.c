begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for IBM RS/6000 "XCOFF" files.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Written by Metin G. Ozisik, Mimi Phûông-Thåo Võ, and John Gilmore.    Archive support from Damon A. Permezel.    Contributed by IBM Corporation and Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This port currently only handles reading object files, except when    compiled on an RS/6000 host.  -- no archive support, no core files.    In all cases, it does not support writing.     FIXMEmgo comments are left from Metin Ozisik's original port.  */
end_comment

begin_comment
comment|/* Internalcoff.h and coffcode.h modify themselves based on this flag.  */
end_comment

begin_define
define|#
directive|define
name|RS6000COFF_C
value|1
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/rs6000.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* The main body of code is in coffcode.h.  */
end_comment

begin_comment
comment|/* Can't read rs6000 relocs */
end_comment

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_define
define|#
directive|define
name|coff_archive_p
value|bfd_generic_archive_p
end_define

begin_define
define|#
directive|define
name|coff_mkarchive
value|_bfd_generic_mkarchive
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ARCHIVES_PLEASE
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*	Support for archive file stuff..				    */
end_comment

begin_comment
comment|/*	Stolen from Damon A. Permezel's `bfd' portation.		    */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_undef
undef|#
directive|undef
name|coff_openr_next_archived_file
end_undef

begin_define
define|#
directive|define
name|coff_openr_next_archived_file
value|rs6000coff_openr_next_archived_file
end_define

begin_undef
undef|#
directive|undef
name|coff_write_armap
end_undef

begin_define
define|#
directive|define
name|coff_write_armap
value|rs6000coff_write_armap
end_define

begin_undef
undef|#
directive|undef
name|coff_stat_arch_elt
end_undef

begin_define
define|#
directive|define
name|coff_stat_arch_elt
value|rs6000coff_stat_arch_elt
end_define

begin_undef
undef|#
directive|undef
name|coff_snarf_ar_hdr
end_undef

begin_define
define|#
directive|define
name|coff_snarf_ar_hdr
value|rs6000coff_snarf_ar_hdr
end_define

begin_undef
undef|#
directive|undef
name|coff_mkarchive
end_undef

begin_define
define|#
directive|define
name|coff_mkarchive
value|rs6000coff_mkarchive
end_define

begin_undef
undef|#
directive|undef
name|coff_archive_p
end_undef

begin_define
define|#
directive|define
name|coff_archive_p
value|rs6000coff_archive_p
end_define

begin_include
include|#
directive|include
file|"/usr/include/ar.h"
end_include

begin_comment
comment|/*<ar.h> doesn't do it.	*/
end_comment

begin_define
define|#
directive|define
name|arch_hdr
parameter_list|(
name|bfd
parameter_list|)
define|\
value|((struct ar_hdr *)	\ 	 (((struct areltdata *)((bfd)->arelt_data))->arch_header))
end_define

begin_function
specifier|static
name|boolean
name|rs6000coff_mkarchive
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
comment|/* write not supported	*/
block|}
end_function

begin_comment
comment|/* This functions reads an arch header and returns an areltdata pointer, or    NULL on error.     Presumes the file pointer is already in the right place (ie pointing    to the ar_hdr in the file).   Moves the file pointer; on success it    should be pointing to the front of the file contents; on failure it    could have been moved arbitrarily. */
end_comment

begin_function
name|struct
name|areltdata
modifier|*
name|rs6000coff_snarf_ar_hdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
struct|struct
block|{
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|char
name|namebuf
index|[
literal|256
index|]
decl_stmt|;
block|}
name|h
struct|;
name|int
name|size
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ared
decl_stmt|;
name|unsigned
name|int
name|namelen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|allocptr
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|h
operator|.
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|h
operator|.
name|hdr
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
name|bfd_error
operator|=
name|no_more_archived_files
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|size
operator|=
name|atoi
argument_list|(
name|h
operator|.
name|hdr
operator|.
name|ar_namlen
argument_list|)
expr_stmt|;
comment|/* ar_name[] length	*/
name|size
operator|+=
name|size
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|h
operator|.
name|hdr
operator|.
name|_ar_name
operator|.
name|ar_name
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
name|bfd_error
operator|=
name|no_more_archived_files
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|h
operator|.
name|hdr
operator|.
name|_ar_name
operator|.
name|ar_fmag
operator|+
name|size
argument_list|,
name|AIAFMAG
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|h
operator|.
name|hdr
operator|.
name|_ar_name
operator|.
name|ar_name
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
comment|/* terminate filename	*/
comment|/* 	 * if the filename is NULL, we're (probably) at the end. 	 */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|no_more_archived_files
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|h
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|allocptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ared
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ared
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|allocptr
expr_stmt|;
name|ared
operator|->
name|arch_header
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|allocptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ared
operator|->
name|arch_header
argument_list|,
operator|&
name|h
operator|.
name|hdr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ared
operator|->
name|parsed_size
operator|=
name|atoi
argument_list|(
name|h
operator|.
name|hdr
operator|.
name|ar_size
argument_list|)
expr_stmt|;
name|ared
operator|->
name|filename
operator|=
operator|(
operator|(
name|AR_HDR
operator|*
operator|)
name|ared
operator|->
name|arch_header
operator|)
operator|->
name|_ar_name
operator|.
name|ar_name
expr_stmt|;
return|return
name|ared
return|;
block|}
end_function

begin_comment
comment|/* Stolen directly from archive.c, except it calls rs6000coff_snarf_ar_hdr.    Why wasn't this part of the transfer vector?  */
end_comment

begin_function
name|bfd
modifier|*
name|rs6000coff_get_elt_at_filepos
parameter_list|(
name|archive
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|new_areldata
decl_stmt|;
name|bfd
modifier|*
name|n_nfd
decl_stmt|;
name|n_nfd
operator|=
name|look_for_bfd_in_cache
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_nfd
condition|)
return|return
name|n_nfd
return|;
if|if
condition|(
literal|0
operator|!=
name|bfd_seek
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|new_areldata
operator|=
name|rs6000coff_snarf_ar_hdr
argument_list|(
name|archive
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|n_nfd
operator|=
name|_bfd_create_empty_archive_element_shell
argument_list|(
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_nfd
operator|==
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|new_areldata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n_nfd
operator|->
name|origin
operator|=
name|bfd_tell
argument_list|(
name|archive
argument_list|)
expr_stmt|;
name|n_nfd
operator|->
name|arelt_data
operator|=
operator|(
name|PTR
operator|)
name|new_areldata
expr_stmt|;
name|n_nfd
operator|->
name|filename
operator|=
name|new_areldata
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|add_bfd_to_cache
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|,
name|n_nfd
argument_list|)
condition|)
return|return
name|n_nfd
return|;
comment|/* huh? */
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|n_nfd
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|new_areldata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * xcoff_openr_next_archived_file -	xcoff has nxt/prv seek addrs.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|rs6000coff_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|,
decl|*
name|last_file
decl_stmt|;
end_function

begin_block
block|{
name|file_ptr
name|filestart
decl_stmt|;
if|if
condition|(
operator|!
name|last_file
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
name|filestart
operator|=
name|atol
argument_list|(
name|arch_hdr
argument_list|(
name|last_file
argument_list|)
operator|->
name|ar_nxtmem
argument_list|)
expr_stmt|;
return|return
name|rs6000coff_get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filestart
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|bfd_target
modifier|*
name|rs6000coff_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|fl_hdr
name|hdr
decl_stmt|;
specifier|register
name|struct
name|artdata
modifier|*
name|art
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|hdr
operator|.
name|fl_magic
argument_list|,
name|AIAMAG
argument_list|,
name|SAIAMAG
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * bfd_ardata() accesses the bfd->tdata field. 	 */
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
name|void
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|art
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|art
operator|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
literal|0
return|;
block|}
name|art
operator|->
name|first_file_filepos
operator|=
name|atoi
argument_list|(
name|hdr
operator|.
name|fl_fstmoff
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|fl_hdr
operator|*
operator|)
operator|(
literal|1
operator|+
name|art
operator|)
operator|=
name|hdr
expr_stmt|;
comment|/* Someday... 	 * slurp in the member table, which I think is the armap equivalent. 	xcoff_slurp_armap(abfd); 	 */
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rs6000coff_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|aloser
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|hdr
operator|=
name|arch_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
define|#
directive|define
name|foo
parameter_list|(
name|arelt
parameter_list|,
name|stelt
parameter_list|,
name|size
parameter_list|)
define|\
value|buf->stelt = strtol (hdr->arelt,&aloser, size); \ 		if (aloser == hdr->arelt) return -1;
name|foo
argument_list|(
name|ar_date
argument_list|,
name|st_mtime
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_uid
argument_list|,
name|st_uid
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_gid
argument_list|,
name|st_gid
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_mode
argument_list|,
name|st_mode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_size
argument_list|,
name|st_size
argument_list|,
literal|10
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|foo
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|rs6000coff_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARCHIVES_PLEASE */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|COREFILES_PLEASE
end_ifdef

begin_function_decl
specifier|extern
name|bfd_target
modifier|*
name|rs6000coff_core_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean
name|rs6000coff_get_section_contents
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean
name|rs6000coff_core_file_matches_executable_p
parameter_list|()
function_decl|;
end_function_decl

begin_undef
undef|#
directive|undef
name|coff_core_file_matches_executable_p
end_undef

begin_define
define|#
directive|define
name|coff_core_file_matches_executable_p
define|\
value|rs6000coff_core_file_matches_executable_p
end_define

begin_undef
undef|#
directive|undef
name|coff_get_section_contents
end_undef

begin_define
define|#
directive|define
name|coff_get_section_contents
value|rs6000coff_get_section_contents
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The transfer vector that leads the outside world to all of the above. */
end_comment

begin_decl_stmt
name|bfd_target
name|rs6000coff_vec
init|=
block|{
literal|"aixcoff-rs6000"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|true
block|,
comment|/* data byte order is big */
name|true
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading char */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen??? FIXMEmgo */
literal|3
block|,
comment|/* default alignment power */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* data */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|coff_archive_p
block|,
ifdef|#
directive|ifdef
name|COREFILES_PLEASE
name|rs6000coff_core_p
else|#
directive|else
name|_bfd_dummy_target
endif|#
directive|endif
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|coff_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|JUMP_TABLE
argument_list|(
name|coff
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|}
decl_stmt|;
end_decl_stmt

end_unit

