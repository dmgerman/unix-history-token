begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bfd back-end for HP PA-RISC SOM objects.    Copyright (C) 1990-1991 Free Software Foundation, Inc.     Contributed by the Center for Software Science at the    University of Utah (pa-gdb-bugs@cs.utah.edu).  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|hp9000s800
end_ifdef

begin_include
include|#
directive|include
file|<sysdep.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_comment
comment|/* #include "aout/hppa.h" */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|hpux
end_ifndef

begin_include
include|#
directive|include
file|<aout/hppa.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<hpux/hpux.h>
end_include

begin_define
define|#
directive|define
name|USRSTACK
value|0x68FF3000
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_struct
struct|struct
name|container
block|{
name|struct
name|header
name|f
decl_stmt|;
name|struct
name|som_exec_auxhdr
name|e
decl_stmt|;
block|}
struct|;
end_struct

begin_undef
undef|#
directive|undef
name|USIZE
end_undef

begin_undef
undef|#
directive|undef
name|UPAGES
end_undef

begin_define
define|#
directive|define
name|USIZE
value|3
end_define

begin_define
define|#
directive|define
name|UPAGES
value|7
end_define

begin_function
name|void
name|fill_spaces
parameter_list|(
name|abfd
parameter_list|,
name|file_hdr
parameter_list|,
name|dbx_subspace
parameter_list|,
name|dbx_strings_subspace
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|header
modifier|*
name|file_hdr
decl_stmt|;
name|struct
name|subspace_dictionary_record
modifier|*
name|dbx_subspace
decl_stmt|,
decl|*
name|dbx_strings_subspace
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|space_strings
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|file_hdr
operator|->
name|space_strings_size
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* for millicode games. */
name|struct
name|space_dictionary_record
name|space
decl_stmt|;
name|struct
name|subspace_dictionary_record
name|subspace
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* indices of subspace entries for $TEXT$ and $GDB_DEBUG$ */
name|int
name|text_index
init|=
literal|0
decl_stmt|,
name|gdb_debug_index
init|=
literal|0
decl_stmt|;
comment|/* initialize in case we don't find any dbx symbols. */
name|dbx_subspace
operator|->
name|subspace_length
operator|=
name|dbx_strings_subspace
operator|->
name|subspace_length
operator|=
literal|0
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|file_hdr
operator|->
name|space_strings_location
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|space_strings
argument_list|,
literal|1
argument_list|,
name|file_hdr
operator|->
name|space_strings_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|file_hdr
operator|->
name|space_strings_size
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
comment|/* space strings table corrupted. */
return|return;
block|}
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|file_hdr
operator|->
name|space_location
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_hdr
operator|->
name|space_total
condition|;
name|i
operator|++
control|)
block|{
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|space
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|space
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|file_hdr
operator|->
name|subspace_location
operator|+
operator|(
name|space
operator|.
name|subspace_index
operator|*
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|space_strings
operator|+
name|space
operator|.
name|name
operator|.
name|n_strx
argument_list|,
literal|"$TEXT$"
argument_list|)
condition|)
name|text_index
operator|=
name|index
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|space_strings
operator|+
name|space
operator|.
name|name
operator|.
name|n_strx
argument_list|,
literal|"$GDB_DEBUG$"
argument_list|)
condition|)
name|gdb_debug_index
operator|=
name|index
expr_stmt|;
block|}
comment|/* search out the beginning and end if millicode */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|text_index
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|subspace
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|space_strings
operator|+
name|subspace
operator|.
name|name
operator|.
name|n_strx
argument_list|,
literal|"$MILLICODE$"
argument_list|)
condition|)
block|{
name|millicode_start
operator|=
name|subspace
operator|.
name|subspace_start
expr_stmt|;
name|millicode_end
operator|=
operator|(
name|millicode_start
operator|+
name|subspace
operator|.
name|subspace_length
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* read symbols subspace and strings subspace in possibly arbitrary      order. */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|gdb_debug_index
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|subspace
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|space_strings
operator|+
name|subspace
operator|.
name|name
operator|.
name|n_strx
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|)
condition|)
block|{
operator|*
name|dbx_strings_subspace
operator|=
name|subspace
expr_stmt|;
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|dbx_subspace
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dbx_subspace
operator|=
name|subspace
expr_stmt|;
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|dbx_strings_subspace
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subspace_dictionary_record
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|hppa_object_setup
argument_list|,
operator|(
name|abfd
operator|,
name|file_hdrp
operator|,
name|aux_hdrp
operator|,
name|dbx_subspace
operator|,
name|dbx_strings_subspace
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|header
operator|*
name|file_hdrp
name|AND
expr|struct
name|som_exec_auxhdr
operator|*
name|aux_hdrp
name|AND
expr|struct
name|subspace_dictionary_record
operator|*
name|dbx_subspace
name|AND
expr|struct
name|subspace_dictionary_record
operator|*
name|dbx_strings_subspace
argument_list|)
block|{
name|struct
name|container
modifier|*
name|rawptr
decl_stmt|;
name|struct
name|header
modifier|*
name|f
decl_stmt|;
name|struct
name|hppa_data_struct
modifier|*
name|rawptr1
decl_stmt|;
name|rawptr
operator|=
operator|(
expr|struct
name|container
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|container
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rawptr1
operator|=
operator|(
expr|struct
name|hppa_data_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hppa_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr1
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
literal|0
return|;
block|}
name|abfd
operator|->
name|tdata
operator|.
name|hppa_data
operator|=
name|rawptr1
expr_stmt|;
name|obj_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|&
name|rawptr
operator|->
name|f
expr_stmt|;
name|obj_aux_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|&
name|rawptr
operator|->
name|e
expr_stmt|;
operator|*
name|obj_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|*
name|file_hdrp
expr_stmt|;
operator|*
name|obj_aux_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|*
name|aux_hdrp
expr_stmt|;
comment|/* Set the file flags */
name|abfd
operator|->
name|flags
operator|=
name|NO_FLAGS
expr_stmt|;
if|if
condition|(
name|file_hdrp
operator|->
name|entry_offset
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
if|if
condition|(
name|file_hdrp
operator|->
name|symbol_total
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
expr_stmt|;
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|aux_hdrp
operator|->
name|exec_entry
expr_stmt|;
name|obj_hp_symbol_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
expr_stmt|;
name|obj_dbx_symbol_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
literal|12
expr_stmt|;
name|obj_pa_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|hppa_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_hp_sym_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_total
expr_stmt|;
name|obj_dbx_sym_count
argument_list|(
name|abfd
argument_list|)
operator|=
name|dbx_subspace
operator|->
name|subspace_length
operator|/
name|obj_dbx_symbol_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|obj_hp_sym_count
argument_list|(
name|abfd
argument_list|)
operator|+
name|obj_dbx_sym_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* create the sections.  This is raunchy, but bfd_close wants to reclaim      them */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".bss"
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|aux_hdrp
operator|->
name|exec_dsize
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|aux_hdrp
operator|->
name|exec_bsize
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|aux_hdrp
operator|->
name|exec_tsize
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
comment|/* The virtual memory addresses of the sections */
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|aux_hdrp
operator|->
name|exec_dmem
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|aux_hdrp
operator|->
name|exec_bfill
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|aux_hdrp
operator|->
name|exec_tmem
expr_stmt|;
comment|/* The file offsets of the sections */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|aux_hdrp
operator|->
name|exec_tfile
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|aux_hdrp
operator|->
name|exec_dfile
expr_stmt|;
comment|/* The file offsets of the relocation info */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
comment|/* The file offsets of the string table and symbol table.  */
name|obj_hp_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_location
expr_stmt|;
name|obj_hp_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_strings_location
expr_stmt|;
name|obj_dbx_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|dbx_subspace
operator|->
name|file_loc_init_value
expr_stmt|;
name|obj_dbx_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|dbx_strings_subspace
operator|->
name|file_loc_init_value
expr_stmt|;
name|obj_hp_stringtab_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_strings_size
expr_stmt|;
name|obj_dbx_stringtab_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|dbx_strings_subspace
operator|->
name|subspace_length
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|hppa_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|struct
name|header
name|file_hdr
decl_stmt|;
name|struct
name|som_exec_auxhdr
name|aux_hdr
decl_stmt|;
name|struct
name|subspace_dictionary_record
name|dbx_subspace
decl_stmt|;
name|struct
name|subspace_dictionary_record
name|dbx_strings_subspace
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|file_hdr
argument_list|,
literal|1
argument_list|,
name|FILE_HDR_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|FILE_HDR_SIZE
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|aux_hdr
argument_list|,
literal|1
argument_list|,
name|AUX_HDR_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|AUX_HDR_SIZE
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fill_spaces
argument_list|(
name|abfd
argument_list|,
operator|&
name|file_hdr
argument_list|,
operator|&
name|dbx_subspace
argument_list|,
operator|&
name|dbx_strings_subspace
argument_list|)
expr_stmt|;
return|return
name|hppa_object_setup
argument_list|(
name|abfd
argument_list|,
operator|&
name|file_hdr
argument_list|,
operator|&
name|aux_hdr
argument_list|,
operator|&
name|dbx_subspace
argument_list|,
operator|&
name|dbx_strings_subspace
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|hppa_mkobject
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_mkobject unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|hppa_write_object_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_write_object_contents unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|hppa_get_symtab_upper_bound
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_get_symtab_upper_bound unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|hppa_get_reloc_upper_bound
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_get_reloc_upper_bound unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|hppa_canonicalize_reloc
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|relptr
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|arelent
operator|*
operator|*
name|relptr
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_canonicalize_reloc unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_target
name|hppa_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|hppa_get_symtab
argument_list|,
operator|(
name|abfd
operator|,
name|location
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|location
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_get_symtab unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|hppa_make_empty_symbol
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|hppa_symbol_type
modifier|*
name|new
init|=
operator|(
name|hppa_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|hppa_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|hppa_print_symbol
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|afile
operator|,
name|symbol
operator|,
name|how
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|PTR
name|afile
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|bfd_print_symbol_type
name|how
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_print_symbol unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|hppa_new_section_hook
argument_list|,
operator|(
name|abfd
operator|,
name|newsect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|newsect
argument_list|)
block|{
comment|/* align to double at least */
name|newsect
operator|->
name|alignment_power
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
block|{
if|if
condition|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
condition|)
block|{
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
condition|)
block|{
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
name|newsect
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* We allow more than three sections internally */
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|hppa_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_set_section_contents unimplimented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|hppa_set_arch_mach
argument_list|,
operator|(
name|abfd
operator|,
name|arch
operator|,
name|machine
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_set_arch_mach unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Allow any architecture to be supported by the hppa backend */
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|hppa_find_nearest_line
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|symbols
operator|,
name|offset
operator|,
name|filename_ptr
operator|,
name|functionname_ptr
operator|,
name|line_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|asymbol
operator|*
operator|*
name|symbols
name|AND
name|bfd_vma
name|offset
name|AND
name|CONST
name|char
operator|*
operator|*
name|filename_ptr
name|AND
name|CONST
name|char
operator|*
operator|*
name|functionname_ptr
name|AND
name|unsigned
name|int
operator|*
name|line_ptr
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_find_nearest_line unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|hppa_sizeof_headers
argument_list|,
operator|(
name|abfd
operator|,
name|reloc
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|reloc
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hppa_sizeof_headers unimplemented\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_define
define|#
directive|define
name|hppa_core_file_p
value|_bfd_dummy_target
end_define

begin_else
else|#
directive|else
end_else

begin_function
name|bfd_target
modifier|*
name|hppa_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|struct
name|hpuxuser
name|u
decl_stmt|;
name|unsigned
name|int
name|reg_offset
decl_stmt|,
name|fp_reg_offset
decl_stmt|;
comment|/* This struct is just for allocating two things with one zalloc, so      they will be freed together, without violating alignment constraints. */
struct|struct
name|core_user
block|{
name|struct
name|hppa_core_struct
name|coredata
decl_stmt|;
name|struct
name|hpuxuser
name|u
decl_stmt|;
block|}
modifier|*
name|rawptr
struct|;
name|val
operator|=
name|bfd_read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|u
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|u
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|u
condition|)
return|return
literal|0
return|;
comment|/* Too small to be a core file */
comment|/* Sanity check perhaps??? */
if|if
condition|(
name|u
operator|.
name|u_dsize
operator|>
literal|0x1000000
condition|)
comment|/* Remember, it's in pages... */
return|return
literal|0
return|;
if|if
condition|(
name|u
operator|.
name|u_ssize
operator|>
literal|0x1000000
condition|)
return|return
literal|0
return|;
comment|/* Check that the size claimed is no greater than the file size. FIXME. */
comment|/* OK, we believe you.  You're a core file (sure, sure).  */
comment|/* Allocate both the upage and the struct core_data at once, so      a single free() will free them both.  */
name|rawptr
operator|=
operator|(
expr|struct
name|core_user
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|core_user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
literal|0
return|;
block|}
name|abfd
operator|->
name|tdata
operator|.
name|hppa_core_data
operator|=
operator|&
name|rawptr
operator|->
name|coredata
expr_stmt|;
name|core_upage
argument_list|(
name|abfd
argument_list|)
operator|=
operator|&
name|rawptr
operator|->
name|u
expr_stmt|;
operator|*
name|core_upage
argument_list|(
name|abfd
argument_list|)
operator|=
name|u
expr_stmt|;
comment|/* Save that upage! */
comment|/* Create the sections.  This is raunchy, but bfd_close wants to free      them separately.  */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|loser
label|:
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rawptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|loser1
label|:
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loser
goto|;
block|}
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|asection
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|loser2
label|:
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|core_datasec
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|loser1
goto|;
block|}
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".stack"
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|=
literal|".reg"
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|NBPG
operator|*
name|u
operator|.
name|u_dsize
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|_raw_size
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
comment|/* Larger than sizeof struct u */
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|u
operator|.
name|hpuxu_exdata
operator|.
name|somexec
operator|.
name|a_Dmem
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|USRSTACK
expr_stmt|;
comment|/* from sys/param */
comment|/* This is tricky.  As the "register section", we give them the entire      upage and stack.  u.u_ar0 points to where "register 0" is stored.      There are two tricks with this, though.  One is that the rest of the      registers might be at positive or negative (or both) displacements      from *u_ar0.  The other is that u_ar0 is sometimes an absolute address      in kernel memory, and on other systems it is an offset from the beginning      of the `struct user'.       As a practical matter, we don't know where the registers actually are,      so we have to pass the whole area to GDB.  We encode the value of u_ar0      by setting the .regs section up so that its virtual memory address      0 is at the place pointed to by u_ar0 (by setting the vma of the start      of the section to -u_ar0).  GDB uses this info to locate the regs,      using minor trickery to get around the offset-or-absolute-addr problem. */
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
operator|-
name|NBPG
operator|*
name|USIZE
expr_stmt|;
comment|/* -u_ar0  */
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|NBPG
operator|*
name|UPAGES
operator|)
operator|+
name|NBPG
operator|*
name|u
operator|.
name|u_dsize
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
literal|0
expr_stmt|;
comment|/* Register segment is the upage */
comment|/* Align to word at least */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|abfd
operator|->
name|sections
operator|=
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_datasec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|next
operator|=
name|core_regsec
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|section_count
operator|=
literal|3
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_define
define|#
directive|define
name|hppa_core_file_failing_command
value|(char *(*)())(bfd_nullvoidptr)
end_define

begin_else
else|#
directive|else
end_else

begin_function
name|char
modifier|*
name|hppa_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NO_CORE_COMMAND
if|if
condition|(
operator|*
name|core_upage
argument_list|(
name|abfd
argument_list|)
operator|->
name|u_comm
condition|)
return|return
name|core_upage
argument_list|(
name|abfd
argument_list|)
operator|->
name|u_comm
return|;
else|else
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|hppa_core_file_failing_signal
parameter_list|(
name|ignore_abfd
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
block|{
return|return
operator|-
literal|1
return|;
comment|/* FIXME, where is it? */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|boolean
name|hppa_core_file_matches_executable_p
parameter_list|(
name|core_bfd
parameter_list|,
name|exec_bfd
parameter_list|)
name|bfd
modifier|*
name|core_bfd
decl_stmt|,
decl|*
name|exec_bfd
decl_stmt|;
end_function

begin_block
block|{
return|return
name|true
return|;
comment|/* FIXME, We have no way of telling at this point */
block|}
end_block

begin_define
define|#
directive|define
name|hppa_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|hppa_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|hppa_bfd_debug_info_accumulate
value|(PROTO(void,(*),(bfd*, struct sec *))) bfd_void
end_define

begin_define
define|#
directive|define
name|hppa_openr_next_archived_file
value|bfd_generic_openr_next_archived_file
end_define

begin_define
define|#
directive|define
name|hppa_generic_stat_arch_elt
value|bfd_generic_stat_arch_elt
end_define

begin_define
define|#
directive|define
name|hppa_slurp_armap
value|bfd_false
end_define

begin_define
define|#
directive|define
name|hppa_slurp_extended_name_table
value|_bfd_slurp_extended_name_table
end_define

begin_define
define|#
directive|define
name|hppa_truncate_arname
value|(void (*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|hppa_write_armap
value|0
end_define

begin_define
define|#
directive|define
name|hppa_get_lineno
value|(struct lineno_cache_entry *(*)())bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|hppa_close_and_cleanup
value|bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|hppa_get_section_contents
value|bfd_generic_get_section_contents
end_define

begin_define
define|#
directive|define
name|hppa_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|hppa_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_comment
comment|/*SUPPRESS 460 */
end_comment

begin_decl_stmt
name|bfd_target
name|hppa_vec
init|=
block|{
literal|"hppa"
block|,
comment|/* name */
name|bfd_target_hppa_flavour
block|,
name|true
block|,
comment|/* target byte order */
name|true
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|DYNAMIC
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
literal|3
block|,
comment|/* minimum alignment */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* data */
name|_do_getb64
block|,
name|_do_putb64
block|,
name|_do_getb32
block|,
name|_do_putb32
block|,
name|_do_getb16
block|,
name|_do_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|hppa_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|hppa_core_file_p
block|,      }
block|,
block|{
name|bfd_false
block|,
name|hppa_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|hppa_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
undef|#
directive|undef
name|hppa
name|JUMP_TABLE
argument_list|(
argument|hppa
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* notdef hp9000s800 */
end_comment

begin_comment
comment|/* Prevent "empty translation unit" warnings from the idiots at X3J11. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ansi_c_idiots
init|=
literal|69
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hp9000s800 */
end_comment

end_unit

