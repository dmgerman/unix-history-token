begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for the generic parts of most COFF variants, for BFD.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  Most of this hacked by  Steve Chamberlain, 			sac@cygnus.com  */
end_comment

begin_comment
comment|/*  SECTION 	coff backends  	BFD supports a number of different flavours of coff format. 	The major difference between formats are the sizes and 	alignments of fields in structures on disk, and the occasional 	extra field.    	Coff in all its varieties is implimented with a few common 	files and a number of implementation specific files. For 	example, The 88k bcs coff format is implemented in the file 	@code{coff-m88k.c}. This file @code{#include}s 	@code{coff-m88k.h} which defines the external structure of the 	coff format for the 88k, and @code{internalcoff.h} which 	defines the internal structure. @code{coff-m88k.c} also 	defines pthe relocations used by the 88k format 	@xref{Relocations}. Then the major portion of coff code is 	included (@code{coffcode.h}) which defines the methods used to 	act upon the types defined in @code{coff-m88k.h} and 	@code{internalcoff.h}.   	The Intel i960 processor version of coff is implemented in 	@code{coff-i960.c}. This file has the same structure as 	@code{coff-m88k.c}, except that it includes @code{coff-i960.h} 	rather than @code{coff-m88k.h}.   SUBSECTION 	Porting To A New Version of Coff  	The recommended method is to select from the existing 	implimentations the version of coff which is most like the one 	you want to use, for our purposes, we'll say that i386 coff is 	the one you select, and that your coff flavour is called foo. 	Copy the @code{i386coff.c} to @code{foocoff.c}, copy 	@code{../include/i386coff.h} to @code{../include/foocoff.h} 	and add the lines to @code{targets.c} and @code{Makefile.in} 	so that your new back end is used. Alter the shapes of the 	structures in @code{../include/foocoff.h} so that they match 	what you need. You will probably also have to add 	@code{#ifdef}s to the code in @code{internalcoff.h} and 	@code{coffcode.h} if your version of coff is too wild.   	You can verify that your new BFD backend works quite simply by 	building @code{objdump} from the @code{binutils} directory, 	and making sure that its version of what's going on at your 	host systems idea (assuming it has the pretty standard coff 	dump utility (usually called @code{att-dump} or just 	@code{dump})) are the same.  Then clean up your code, and send 	what you've done to Cygnus. Then your stuff will be in the 	next release, and you won't have to keep integrating it.  SUBSECTION 	How The Coff Backend Works  SUBSUBSECTION 	Bit Twiddling  	Each flavour of coff supported in BFD has its own header file 	descibing the external layout of the structures. There is also 	an internal description of the coff layout (in 	@code{internalcoff.h}) file (@code{}). A major function of the 	coff backend is swapping the bytes and twiddling the bits to 	translate the external form of the structures into the normal 	internal form. This is all performed in the 	@code{bfd_swap}_@i{thing}_@i{direction} routines. Some 	elements are different sizes between different versions of 	coff, it is the duty of the coff version specific include file 	to override the definitions of various packing routines in 	@code{coffcode.h}. Eg the size of line number entry in coff is 	sometimes 16 bits, and sometimes 32 bits. @code{#define}ing 	@code{PUT_LNSZ_LNNO} and @code{GET_LNSZ_LNNO} will select the 	correct one. No doubt, some day someone will find a version of 	coff which has a varying field size not catered for at the 	moment. To port BFD, that person will have to add more @code{#defines}.   	Three of the bit twiddling routines are exported to 	@code{gdb}; @code{coff_swap_aux_in}, @code{coff_swap_sym_in} 	and @code{coff_swap_linno_in}. @code{GDB} reads the symbol 	table on its own, but uses BFD to fix things up.  More of the 	bit twiddlers are exported for @code{gas}; 	@code{coff_swap_aux_out}, @code{coff_swap_sym_out}, 	@code{coff_swap_lineno_out}, @code{coff_swap_reloc_out}, 	@code{coff_swap_filehdr_out}, @code{coff_swap_aouthdr_out}, 	@code{coff_swap_scnhdr_out}. @code{Gas} currently keeps track 	of all the symbol table and reloc drudgery itself, thereby 	saving the internal BFD overhead, but uses BFD to swap things 	on the way out, making cross ports much safer.  This also 	allows BFD (and thus the linker) to use the same header files 	as @code{gas}, which makes one avenue to disaster disappear.  SUBSUBSECTION 	Symbol Reading  	The simple canonical form for symbols used by BFD is not rich 	enough to keep all the information available in a coff symbol 	table. The back end gets around this by keeping the original 	symbol table around, "behind the scenes".   	When a symbol table is requested (through a call to 	@code{bfd_canonicalize_symtab}, a request gets through to 	@code{get_normalized_symtab}. This reads the symbol table from 	the coff file and swaps all the structures inside into the 	internal form. It also fixes up all the pointers in the table 	(represented in the file by offsets from the first symbol in 	the table) into physical pointers to elements in the new 	internal table. This involves some work since the meanings of 	fields changes depending upon context; a field that is a 	pointer to another structure in the symbol table at one moment 	may be the size in bytes of a structure in the next.  Another 	pass is made over the table. All symbols which mark file names 	(<<C_FILE>> symbols) are modified so that the internal 	string points to the value in the auxent (the real filename) 	rather than the normal text associated with the symbol 	(@code{".file"}).   	At this time the symbol names are moved around. Coff stores 	all symbols less than nine characters long physically 	within the symbol table, longer strings are kept at the end of 	the file in the string 	table. This pass moves all strings 	into memory, and replaces them with pointers to the strings.   	The symbol table is massaged once again, this time to create 	the canonical table used by the BFD application. Each symbol 	is inspected in turn, and a decision made (using the 	@code{sclass} field) about the various flags to set in the 	@code{asymbol} @xref{Symbols}. The generated canonical table 	shares strings with the hidden internal symbol table.   	Any linenumbers are read from the coff file too, and attached 	to the symbols which own the functions the linenumbers belong to.   SUBSUBSECTION 	Symbol Writing  	Writing a symbol to a coff file which didn't come from a coff 	file will lose any debugging information. The @code{asymbol} 	structure remembers the BFD from which was born, and on output 	the back end makes sure that the same destination target as 	source target is present.  	When the symbols have come from a coff file then all the 	debugging information is preserved.  	Symbol tables are provided for writing to the back end in a 	vector of pointers to pointers. This allows applications like 	the linker to accumulate and output large symbol tables 	without having to do too much byte copying.  	This function runs through the provided symbol table and 	patches each symbol marked as a file place holder 	(@code{C_FILE}) to point to the next file place holder in the 	list. It also marks each @code{offset} field in the list with 	the offset from the first symbol of the current symbol.  	Another function of this procedure is to turn the canonical 	value form of BFD into the form used by coff. Internally, BFD 	expects symbol values to be offsets from a section base; so a 	symbol physically at 0x120, but in a section starting at 	0x100, would have the value 0x20. Coff expects symbols to 	contain their final value, so symbols have their values 	changed at this point to reflect their sum with their owning 	section. Note that this transformation uses the<<output_section>> field of the @code{asymbol}'s 	@code{asection} @xref{Sections}.   	o coff_mangle_symbols  	This routine runs though the provided symbol table and uses 	the offsets generated by the previous pass and the pointers 	generated when the symbol table was read in to create the 	structured hierachy required by coff. It changes each pointer 	to a symbol to an index into the symbol table of the symbol 	being referenced.   	o coff_write_symbols  	This routine runs through the symbol table and patches up the 	symbols from their internal form into the coff way, calls the 	bit twiddlers and writes out the tabel to the file.   */
end_comment

begin_comment
comment|/* INTERNAL_DEFINITION 	coff_symbol_type  DESCRIPTION 	The hidden information for an asymbol is described in a 	coff_ptr_struct, which is typedefed to a combined_entry_type  CODE_FRAGMENT . .typedef struct coff_ptr_struct  .{ . .       {* Remembers the offset from the first symbol in the file for .          this symbol. Generated by coff_renumber_symbols. *} .unsigned int offset; . .       {* Should the tag field of this symbol be renumbered. .          Created by coff_pointerize_aux. *} .char fix_tag; . .       {* Should the endidx field of this symbol be renumbered. .          Created by coff_pointerize_aux. *} .char fix_end; . .       {* The container for the symbol structure as read and translated .           from the file. *} . .union { .   union internal_auxent auxent; .   struct internal_syment syment; . } u; .} combined_entry_type; . . .{* Each canonical asymbol really looks like this: *} . .typedef struct coff_symbol_struct .{ .   {* The actual symbol which the rest of BFD works with *} .asymbol symbol; . .   {* A pointer to the hidden information for this symbol *} .combined_entry_type *native; . .   {* A pointer to the linenumber information for this symbol *} .struct lineno_cache_entry *lineno; . .   {* Have the line numbers been relocated yet ? *} .boolean done_lineno; .} coff_symbol_type;   */
end_comment

begin_include
include|#
directive|include
file|"seclet.h"
end_include

begin_decl_stmt
specifier|extern
name|bfd_error_vector_type
name|bfd_error_vector
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PUTWORD
value|bfd_h_put_32
end_define

begin_define
define|#
directive|define
name|PUTHALF
value|bfd_h_put_16
end_define

begin_define
define|#
directive|define
name|PUTBYTE
value|bfd_h_put_8
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|GET_FCN_LNNOPTR
end_ifndef

begin_define
define|#
directive|define
name|GET_FCN_LNNOPTR
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GET_FCN_ENDNDX
end_ifndef

begin_define
define|#
directive|define
name|GET_FCN_ENDNDX
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_get_32(abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_FCN_LNNOPTR
end_ifndef

begin_define
define|#
directive|define
name|PUT_FCN_LNNOPTR
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ext
parameter_list|)
value|PUTWORD(abfd,  in, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_lnnoptr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_FCN_ENDNDX
end_ifndef

begin_define
define|#
directive|define
name|PUT_FCN_ENDNDX
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ext
parameter_list|)
value|PUTWORD(abfd, in, (bfd_byte *) ext->x_sym.x_fcnary.x_fcn.x_endndx)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GET_LNSZ_LNNO
end_ifndef

begin_define
define|#
directive|define
name|GET_LNSZ_LNNO
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_misc.x_lnsz.x_lnno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GET_LNSZ_SIZE
end_ifndef

begin_define
define|#
directive|define
name|GET_LNSZ_SIZE
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_get_16(abfd, (bfd_byte *) ext->x_sym.x_misc.x_lnsz.x_size)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_LNSZ_LNNO
end_ifndef

begin_define
define|#
directive|define
name|PUT_LNSZ_LNNO
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_put_16(abfd, in, (bfd_byte *)ext->x_sym.x_misc.x_lnsz.x_lnno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_LNSZ_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PUT_LNSZ_SIZE
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_put_16(abfd, in, (bfd_byte*) ext->x_sym.x_misc.x_lnsz.x_size)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GET_SCN_SCNLEN
end_ifndef

begin_define
define|#
directive|define
name|GET_SCN_SCNLEN
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_get_32(abfd, (bfd_byte *) ext->x_scn.x_scnlen)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GET_SCN_NRELOC
end_ifndef

begin_define
define|#
directive|define
name|GET_SCN_NRELOC
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_get_16(abfd, (bfd_byte *)ext->x_scn.x_nreloc)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GET_SCN_NLINNO
end_ifndef

begin_define
define|#
directive|define
name|GET_SCN_NLINNO
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_get_16(abfd, (bfd_byte *)ext->x_scn.x_nlinno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SCN_SCNLEN
end_ifndef

begin_define
define|#
directive|define
name|PUT_SCN_SCNLEN
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_put_32(abfd, in, (bfd_byte *) ext->x_scn.x_scnlen)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SCN_NRELOC
end_ifndef

begin_define
define|#
directive|define
name|PUT_SCN_NRELOC
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_put_16(abfd, in, (bfd_byte *)ext->x_scn.x_nreloc)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SCN_NLINNO
end_ifndef

begin_define
define|#
directive|define
name|PUT_SCN_NLINNO
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_put_16(abfd,in, (bfd_byte  *) ext->x_scn.x_nlinno)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GET_LINENO_LNNO
end_ifndef

begin_define
define|#
directive|define
name|GET_LINENO_LNNO
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_get_16(abfd, (bfd_byte *) (ext->l_lnno));
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_LINENO_LNNO
end_ifndef

begin_define
define|#
directive|define
name|PUT_LINENO_LNNO
parameter_list|(
name|abfd
parameter_list|,
name|val
parameter_list|,
name|ext
parameter_list|)
value|bfd_h_put_16(abfd,val,  (bfd_byte *) (ext->l_lnno));
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* void warning(); */
end_comment

begin_comment
comment|/*  * Return a word with STYP_* (scnhdr.s_flags) flags set to represent the  * incoming SEC_* flags.  The inverse of this function is styp_to_sec_flags().  * NOTE: If you add to/change this routine, you should mirror the changes  * 	in styp_to_sec_flags().  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|DEFUN
argument_list|(
name|sec_to_styp_flags
argument_list|,
operator|(
name|sec_name
operator|,
name|sec_flags
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|sec_name
name|AND
name|flagword
name|sec_flags
argument_list|)
block|{
name|long
name|styp_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_TEXT
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|long
operator|)
name|STYP_TEXT
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_DATA
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|long
operator|)
name|STYP_DATA
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_BSS
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|long
operator|)
name|STYP_BSS
operator|)
return|;
ifdef|#
directive|ifdef
name|_COMMENT
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec_name
argument_list|,
name|_COMMENT
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|long
operator|)
name|STYP_INFO
operator|)
return|;
endif|#
directive|endif
comment|/* _COMMENT */
block|}
comment|/* Try and figure out what it should be */
if|if
condition|(
name|sec_flags
operator|&
name|SEC_CODE
condition|)
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
if|if
condition|(
name|sec_flags
operator|&
name|SEC_DATA
condition|)
name|styp_flags
operator|=
name|STYP_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_READONLY
condition|)
ifdef|#
directive|ifdef
name|STYP_LIT
comment|/* 29k readonly text/data section */
name|styp_flags
operator|=
name|STYP_LIT
expr_stmt|;
else|#
directive|else
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
endif|#
directive|endif
comment|/* STYP_LIT */
elseif|else
if|if
condition|(
name|sec_flags
operator|&
name|SEC_LOAD
condition|)
name|styp_flags
operator|=
name|STYP_TEXT
expr_stmt|;
if|if
condition|(
name|styp_flags
operator|==
literal|0
condition|)
name|styp_flags
operator|=
name|STYP_BSS
expr_stmt|;
return|return
operator|(
name|styp_flags
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Return a word with SEC_* flags set to represent the incoming  * STYP_* flags (from scnhdr.s_flags).   The inverse of this  * function is sec_to_styp_flags().  * NOTE: If you add to/change this routine, you should mirror the changes  *      in sec_to_styp_flags().  */
end_comment

begin_decl_stmt
specifier|static
name|flagword
name|DEFUN
argument_list|(
name|styp_to_sec_flags
argument_list|,
operator|(
name|styp_flags
operator|)
argument_list|,
name|long
name|styp_flags
argument_list|)
block|{
name|flagword
name|sec_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_TEXT
operator|)
operator|||
operator|(
name|styp_flags
operator|&
name|STYP_DATA
operator|)
condition|)
block|{
name|sec_flags
operator|=
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_BSS
condition|)
block|{
name|sec_flags
operator|=
name|SEC_ALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|styp_flags
operator|&
name|STYP_INFO
condition|)
block|{
name|sec_flags
operator|=
name|SEC_NEVER_LOAD
expr_stmt|;
block|}
else|else
block|{
name|sec_flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STYP_LIT
comment|/* A29k readonly text/data section type */
if|if
condition|(
operator|(
name|styp_flags
operator|&
name|STYP_LIT
operator|)
operator|==
name|STYP_LIT
condition|)
block|{
name|sec_flags
operator|=
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STYP_LIT */
ifdef|#
directive|ifdef
name|STYP_OTHER_LOAD
comment|/* Other loaded sections */
if|if
condition|(
name|styp_flags
operator|&
name|STYP_OTHER_LOAD
condition|)
block|{
name|sec_flags
operator|=
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STYP_SDATA */
return|return
operator|(
name|sec_flags
operator|)
return|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|get_index
parameter_list|(
name|symbol
parameter_list|)
value|((int) (symbol)->udata)
end_define

begin_define
define|#
directive|define
name|set_index
parameter_list|(
name|symbol
parameter_list|,
name|idx
parameter_list|)
value|((symbol)->udata =(PTR) (idx))
end_define

begin_comment
comment|/*  ********************************************************************** Here are all the routines for swapping the structures seen in the outside world into the internal forms. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_swap_reloc_in
argument_list|,
operator|(
name|abfd
operator|,
name|reloc_src
operator|,
name|reloc_dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|RELOC
operator|*
name|reloc_src
name|AND
expr|struct
name|internal_reloc
operator|*
name|reloc_dst
argument_list|)
block|{
name|reloc_dst
operator|->
name|r_vaddr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|reloc_src
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|reloc_dst
operator|->
name|r_symndx
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|reloc_src
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RS6000COFF_C
name|reloc_dst
operator|->
name|r_type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_type
argument_list|)
expr_stmt|;
name|reloc_dst
operator|->
name|r_size
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|reloc_dst
operator|->
name|r_type
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|reloc_src
operator|->
name|r_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SWAP_IN_RELOC_OFFSET
name|reloc_dst
operator|->
name|r_offset
operator|=
name|SWAP_IN_RELOC_OFFSET
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|reloc_src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_swap_reloc_out
argument_list|,
operator|(
name|abfd
operator|,
name|src
operator|,
name|dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|src
name|AND
name|PTR
name|dst
argument_list|)
block|{
name|struct
name|internal_reloc
modifier|*
name|reloc_src
init|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|reloc_dst
init|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|dst
decl_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_vaddr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|reloc_dst
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_symndx
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|reloc_dst
operator|->
name|r_symndx
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_type
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|reloc_dst
operator|->
name|r_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SWAP_OUT_RELOC_OFFSET
name|SWAP_OUT_RELOC_OFFSET
argument_list|(
name|abfd
argument_list|,
name|reloc_src
operator|->
name|r_offset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|reloc_dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SWAP_OUT_RELOC_EXTRA
name|SWAP_OUT_RELOC_EXTRA
argument_list|(
name|abfd
argument_list|,
name|reloc_src
argument_list|,
name|reloc_dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|external_reloc
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_swap_filehdr_in
argument_list|,
operator|(
name|abfd
operator|,
name|filehdr_src
operator|,
name|filehdr_dst
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|FILHDR
operator|*
name|filehdr_src
name|AND
expr|struct
name|internal_filehdr
operator|*
name|filehdr_dst
argument_list|)
block|{
name|filehdr_dst
operator|->
name|f_magic
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_src
operator|->
name|f_magic
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_nscns
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_src
operator|->
name|f_nscns
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_timdat
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_src
operator|->
name|f_timdat
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_symptr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_src
operator|->
name|f_symptr
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_nsyms
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_src
operator|->
name|f_nsyms
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_opthdr
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_src
operator|->
name|f_opthdr
argument_list|)
expr_stmt|;
name|filehdr_dst
operator|->
name|f_flags
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_src
operator|->
name|f_flags
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_swap_filehdr_out
argument_list|,
operator|(
name|abfd
operator|,
name|in
operator|,
name|out
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|in
name|AND
name|PTR
name|out
argument_list|)
block|{
name|struct
name|internal_filehdr
modifier|*
name|filehdr_in
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|in
decl_stmt|;
name|FILHDR
modifier|*
name|filehdr_out
init|=
operator|(
name|FILHDR
operator|*
operator|)
name|out
decl_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_magic
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_out
operator|->
name|f_magic
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_nscns
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_out
operator|->
name|f_nscns
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_timdat
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_out
operator|->
name|f_timdat
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_symptr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_out
operator|->
name|f_symptr
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_nsyms
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_out
operator|->
name|f_nsyms
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_opthdr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_out
operator|->
name|f_opthdr
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|filehdr_in
operator|->
name|f_flags
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|filehdr_out
operator|->
name|f_flags
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|FILHDR
argument_list|)
return|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_swap_sym_in
argument_list|,
operator|(
name|abfd
operator|,
name|ext1
operator|,
name|in1
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|ext1
name|AND
name|PTR
name|in1
argument_list|)
block|{
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|in1
decl_stmt|;
if|if
condition|(
name|ext
operator|->
name|e
operator|.
name|e_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|SYMNMLEN
operator|!=
name|E_SYMNMLEN
operator|->
name|Error
operator|,
name|we
name|need
name|to
name|cope
name|with
name|truncating
name|or
name|extending
name|SYMNMLEN
operator|!
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|ext
operator|->
name|e
operator|.
name|e_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|in
operator|->
name|n_value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_scnum
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ext
operator|->
name|e_type
argument_list|)
operator|==
literal|2
condition|)
block|{
name|in
operator|->
name|n_type
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|n_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
block|}
name|in
operator|->
name|n_sclass
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|in
operator|->
name|n_numaux
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_swap_sym_out
argument_list|,
operator|(
name|abfd
operator|,
name|inp
operator|,
name|extp
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|inp
name|AND
name|PTR
name|extp
argument_list|)
block|{
name|struct
name|internal_syment
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|inp
decl_stmt|;
name|SYMENT
modifier|*
name|ext
init|=
operator|(
name|SYMENT
operator|*
operator|)
name|extp
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|_n
operator|.
name|_n_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_zeroes
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e
operator|.
name|e
operator|.
name|e_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|SYMNMLEN
operator|!=
name|E_SYMNMLEN
operator|->
name|Error
operator|,
name|we
name|need
name|to
name|cope
name|with
name|truncating
name|or
name|extending
name|SYMNMLEN
operator|!
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|ext
operator|->
name|e
operator|.
name|e_name
argument_list|,
name|in
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_value
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_scnum
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_scnum
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ext
operator|->
name|e_type
argument_list|)
operator|==
literal|2
condition|)
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_type
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_type
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|e_type
argument_list|)
expr_stmt|;
block|}
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_sclass
argument_list|,
name|ext
operator|->
name|e_sclass
argument_list|)
expr_stmt|;
name|bfd_h_put_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|n_numaux
argument_list|,
name|ext
operator|->
name|e_numaux
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|SYMENT
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_swap_aux_in
argument_list|,
operator|(
name|abfd
operator|,
name|ext1
operator|,
name|type
operator|,
name|class
operator|,
name|in1
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|ext1
name|AND
name|int
name|type
name|AND
name|int
name|class
name|AND
name|PTR
name|in1
argument_list|)
block|{
name|AUXENT
modifier|*
name|ext
init|=
operator|(
name|AUXENT
operator|*
operator|)
name|ext1
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|in1
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|=
literal|0
expr_stmt|;
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|FILNMLEN
operator|!=
name|E_FILNMLEN
operator|->
name|Error
operator|,
name|we
name|need
name|to
name|cope
name|with
name|truncating
name|or
name|extending
name|FILNMLEN
operator|!
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
comment|/* RS/6000 "csect" auxents */
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_parmhash
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_snhash
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|)
expr_stmt|;
comment|/* We don't have to hack bitfields in x_smtyp because it's defined by 	 shifts-and-ands, which are equivalent on all byte orders.  */
name|in
operator|->
name|x_csect
operator|.
name|x_smtyp
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_smclas
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_stab
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_csect
operator|.
name|x_snstab
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|C_STAT
case|:
ifdef|#
directive|ifdef
name|C_LEAFSTAT
case|case
name|C_LEAFSTAT
case|:
endif|#
directive|endif
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|in
operator|->
name|x_scn
operator|.
name|x_scnlen
operator|=
name|GET_SCN_SCNLEN
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_nreloc
operator|=
name|GET_SCN_NRELOC
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_scn
operator|.
name|x_nlinno
operator|=
name|GET_SCN_NLINNO
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|in
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_TVNDX
name|in
operator|->
name|x_sym
operator|.
name|x_tvndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ISARY
argument_list|(
name|type
argument_list|)
operator|||
name|class
operator|==
name|C_BLOCK
condition|)
block|{
if|#
directive|if
name|DIMNUM
operator|!=
name|E_DIMNUM
operator|->
name|Error
operator|,
name|we
name|need
name|to
name|cope
name|with
name|truncating
name|or
name|extending
name|DIMNUM
operator|!
expr_stmt|;
else|#
directive|else
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
name|GET_FCN_LNNOPTR
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|GET_FCN_ENDNDX
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
operator|=
name|GET_LNSZ_LNNO
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
operator|=
name|GET_LNSZ_SIZE
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_swap_aux_out
argument_list|,
operator|(
name|abfd
operator|,
name|inp
operator|,
name|type
operator|,
name|class
operator|,
name|extp
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|inp
name|AND
name|int
name|type
name|AND
name|int
name|class
name|AND
name|PTR
name|extp
argument_list|)
block|{
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|inp
decl_stmt|;
name|AUXENT
modifier|*
name|ext
init|=
operator|(
name|AUXENT
operator|*
operator|)
name|extp
decl_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_FILE
case|:
if|if
condition|(
name|in
operator|->
name|x_file
operator|.
name|x_fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|FILNMLEN
operator|!=
name|E_FILNMLEN
operator|->
name|Error
operator|,
name|we
name|need
name|to
name|cope
name|with
name|truncating
name|or
name|extending
name|FILNMLEN
operator|!
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|ext
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|in
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
ifdef|#
directive|ifdef
name|RS6000COFF_C
comment|/* RS/6000 "csect" auxents */
case|case
name|C_EXT
case|:
case|case
name|C_HIDEXT
case|:
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_scnlen
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_scnlen
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_parmhash
argument_list|)
expr_stmt|;
name|PUTHALF
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snhash
argument_list|)
expr_stmt|;
comment|/* We don't have to hack bitfields in x_smtyp because it's defined by        shifts-and-ands, which are equivalent on all byte orders.  */
name|PUTBYTE
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smtyp
argument_list|)
expr_stmt|;
name|PUTBYTE
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_smclas
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_stab
argument_list|)
expr_stmt|;
name|PUTHALF
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|,
name|ext
operator|->
name|x_csect
operator|.
name|x_snstab
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|C_STAT
case|:
ifdef|#
directive|ifdef
name|C_LEAFSTAT
case|case
name|C_LEAFSTAT
case|:
endif|#
directive|endif
case|case
name|C_HIDDEN
case|:
if|if
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|PUT_SCN_SCNLEN
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_scnlen
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_SCN_NRELOC
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_nreloc
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_SCN_NLINNO
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_scn
operator|.
name|x_nlinno
argument_list|,
name|ext
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_tagndx
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_TVNDX
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_tvndx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|)
expr_stmt|;
name|PUT_FCN_LNNOPTR
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_FCN_ENDNDX
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ISARY
argument_list|(
name|type
argument_list|)
operator|||
name|class
operator|==
name|C_BLOCK
condition|)
block|{
if|#
directive|if
name|DIMNUM
operator|!=
name|E_DIMNUM
operator|->
name|Error
operator|,
name|we
name|need
name|to
name|cope
name|with
name|truncating
name|or
name|extending
name|DIMNUM
operator|!
expr_stmt|;
else|#
directive|else
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|PUT_LNSZ_LNNO
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_LNSZ_SIZE
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_FCN_LNNOPTR
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|PUT_FCN_ENDNDX
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
block|}
return|return
sizeof|sizeof
argument_list|(
name|AUXENT
argument_list|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_SYMBOLS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_LINENOS
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_swap_lineno_in
argument_list|,
operator|(
name|abfd
operator|,
name|ext1
operator|,
name|in1
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|ext1
name|AND
name|PTR
name|in1
argument_list|)
block|{
name|LINENO
modifier|*
name|ext
init|=
operator|(
name|LINENO
operator|*
operator|)
name|ext1
decl_stmt|;
name|struct
name|internal_lineno
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_lineno
operator|*
operator|)
name|in1
decl_stmt|;
name|in
operator|->
name|l_addr
operator|.
name|l_symndx
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
name|in
operator|->
name|l_lnno
operator|=
name|GET_LINENO_LNNO
argument_list|(
name|abfd
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_swap_lineno_out
argument_list|,
operator|(
name|abfd
operator|,
name|inp
operator|,
name|outp
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|inp
name|AND
name|PTR
name|outp
argument_list|)
block|{
name|struct
name|internal_lineno
modifier|*
name|in
init|=
operator|(
expr|struct
name|internal_lineno
operator|*
operator|)
name|inp
decl_stmt|;
name|struct
name|external_lineno
modifier|*
name|ext
init|=
operator|(
expr|struct
name|external_lineno
operator|*
operator|)
name|outp
decl_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ext
operator|->
name|l_addr
operator|.
name|l_symndx
argument_list|)
expr_stmt|;
name|PUT_LINENO_LNNO
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|l_lnno
argument_list|,
name|ext
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|external_lineno
argument_list|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_LINENOS */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_swap_aouthdr_in
argument_list|,
operator|(
name|abfd
operator|,
name|aouthdr_ext1
operator|,
name|aouthdr_int1
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|aouthdr_ext1
name|AND
name|PTR
name|aouthdr_int1
argument_list|)
block|{
name|AOUTHDR
modifier|*
name|aouthdr_ext
init|=
operator|(
name|AOUTHDR
operator|*
operator|)
name|aouthdr_ext1
decl_stmt|;
name|struct
name|internal_aouthdr
modifier|*
name|aouthdr_int
init|=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|aouthdr_int1
decl_stmt|;
name|aouthdr_int
operator|->
name|magic
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|magic
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|vstamp
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|vstamp
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|tsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|tsize
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|dsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|dsize
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|bsize
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|bsize
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|entry
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|entry
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|text_start
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|text_start
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|data_start
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|data_start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I960
name|aouthdr_int
operator|->
name|tagentries
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_ext
operator|->
name|tagentries
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RS6000COFF_C
name|aouthdr_int
operator|->
name|o_toc
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_toc
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_snentry
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_snentry
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_sntext
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_sntext
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_sndata
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_sndata
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_sntoc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_sntoc
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_snloader
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_snloader
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_snbss
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_snbss
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_algntext
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_algntext
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_algndata
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_algndata
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_modtype
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_modtype
argument_list|)
expr_stmt|;
name|aouthdr_int
operator|->
name|o_maxstack
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_ext
operator|->
name|o_maxstack
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_swap_aouthdr_out
argument_list|,
operator|(
name|abfd
operator|,
name|in
operator|,
name|out
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|in
name|AND
name|PTR
name|out
argument_list|)
block|{
name|struct
name|internal_aouthdr
modifier|*
name|aouthdr_in
init|=
operator|(
expr|struct
name|internal_aouthdr
operator|*
operator|)
name|in
decl_stmt|;
name|AOUTHDR
modifier|*
name|aouthdr_out
init|=
operator|(
name|AOUTHDR
operator|*
operator|)
name|out
decl_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|magic
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|magic
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|vstamp
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|vstamp
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|tsize
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|tsize
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|dsize
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|dsize
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|bsize
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|bsize
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|entry
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|entry
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|text_start
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|text_start
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|data_start
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|data_start
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I960
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|aouthdr_in
operator|->
name|tagentries
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|aouthdr_out
operator|->
name|tagentries
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
sizeof|sizeof
argument_list|(
name|AOUTHDR
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_swap_scnhdr_in
argument_list|,
operator|(
name|abfd
operator|,
name|scnhdr_ext
operator|,
name|scnhdr_int
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|SCNHDR
operator|*
name|scnhdr_ext
name|AND
expr|struct
name|internal_scnhdr
operator|*
name|scnhdr_int
argument_list|)
block|{
name|memcpy
argument_list|(
name|scnhdr_int
operator|->
name|s_name
argument_list|,
name|scnhdr_ext
operator|->
name|s_name
argument_list|,
sizeof|sizeof
argument_list|(
name|scnhdr_int
operator|->
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_vaddr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_vaddr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_paddr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_paddr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_size
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_scnptr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_scnptr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_relptr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_relptr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_lnnoptr
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_lnnoptr
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_flags
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|M88
argument_list|)
name|scnhdr_int
operator|->
name|s_nreloc
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_nlnno
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
else|#
directive|else
name|scnhdr_int
operator|->
name|s_nreloc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
name|scnhdr_int
operator|->
name|s_nlnno
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960
name|scnhdr_int
operator|->
name|s_align
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_swap_scnhdr_out
argument_list|,
operator|(
name|abfd
operator|,
name|in
operator|,
name|out
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|in
name|AND
name|PTR
name|out
argument_list|)
block|{
name|struct
name|internal_scnhdr
modifier|*
name|scnhdr_int
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|in
decl_stmt|;
name|SCNHDR
modifier|*
name|scnhdr_ext
init|=
operator|(
name|SCNHDR
operator|*
operator|)
name|out
decl_stmt|;
name|memcpy
argument_list|(
name|scnhdr_ext
operator|->
name|s_name
argument_list|,
name|scnhdr_int
operator|->
name|s_name
argument_list|,
sizeof|sizeof
argument_list|(
name|scnhdr_int
operator|->
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_vaddr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_vaddr
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_paddr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_paddr
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_size
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_size
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_scnptr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_scnptr
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_relptr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_relptr
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_lnnoptr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_lnnoptr
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_flags
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|M88
argument_list|)
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_nlnno
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_nreloc
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
else|#
directive|else
name|PUTHALF
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_nlnno
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
name|PUTHALF
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_nreloc
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|I960
argument_list|)
name|PUTWORD
argument_list|(
name|abfd
argument_list|,
name|scnhdr_int
operator|->
name|s_align
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|scnhdr_ext
operator|->
name|s_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
sizeof|sizeof
argument_list|(
name|SCNHDR
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*    initialize a section structure with information peculiar to this    particular implementation of coff */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_new_section_hook
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
argument_list|)
block|{
name|section
operator|->
name|alignment_power
operator|=
name|abfd
operator|->
name|xvec
operator|->
name|align_power_min
expr_stmt|;
comment|/* Allocate aux records for section symbols, to store size and      related info.       @@ Shouldn't use constant multiplier here!  */
name|coffsymbol
argument_list|(
name|section
operator|->
name|symbol
argument_list|)
operator|->
name|native
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
name|bfd_debug_section
init|=
block|{
literal|"*DEBUG*"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Take a section header read from a coff file (in HOST byte order),    and make a BFD "section" out of it.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|make_a_section_from_file
argument_list|,
operator|(
name|abfd
operator|,
name|hdr
operator|,
name|target_index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|internal_scnhdr
operator|*
name|hdr
name|AND
name|unsigned
name|int
name|target_index
argument_list|)
block|{
name|asection
modifier|*
name|return_section
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Assorted wastage to null-terminate the name, thanks AT&T! */
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|strncpy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
operator|->
name|s_name
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
name|name
index|[
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|s_name
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|return_section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_section
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* s_paddr is presumed to be = to s_vaddr */
name|return_section
operator|->
name|vma
operator|=
name|hdr
operator|->
name|s_vaddr
expr_stmt|;
name|return_section
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|s_size
expr_stmt|;
name|return_section
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|s_scnptr
expr_stmt|;
name|return_section
operator|->
name|rel_filepos
operator|=
name|hdr
operator|->
name|s_relptr
expr_stmt|;
name|return_section
operator|->
name|reloc_count
operator|=
name|hdr
operator|->
name|s_nreloc
expr_stmt|;
ifdef|#
directive|ifdef
name|I960
comment|/* FIXME, use a temp var rather than alignment_power */
name|return_section
operator|->
name|alignment_power
operator|=
name|hdr
operator|->
name|s_align
expr_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|>=
call|(
name|int
call|)
argument_list|(
name|return_section
operator|->
name|alignment_power
argument_list|)
condition|)
block|{
name|return_section
operator|->
name|alignment_power
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|return_section
operator|->
name|line_filepos
operator|=
name|hdr
operator|->
name|s_lnnoptr
expr_stmt|;
comment|/*     return_section->linesize =   hdr->s_nlnno * sizeof (struct lineno);     */
name|return_section
operator|->
name|lineno_count
operator|=
name|hdr
operator|->
name|s_nlnno
expr_stmt|;
name|return_section
operator|->
name|userdata
operator|=
name|NULL
expr_stmt|;
name|return_section
operator|->
name|next
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|return_section
operator|->
name|flags
operator|=
name|styp_to_sec_flags
argument_list|(
name|hdr
operator|->
name|s_flags
argument_list|)
expr_stmt|;
name|return_section
operator|->
name|target_index
operator|=
name|target_index
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|s_nreloc
operator|!=
literal|0
condition|)
name|return_section
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
comment|/* FIXME: should this check 'hdr->s_size> 0' */
if|if
condition|(
name|hdr
operator|->
name|s_scnptr
operator|!=
literal|0
condition|)
name|return_section
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_mkobject
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|=
operator|(
expr|struct
name|coff_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|coff_data_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|==
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|relocbase
operator|=
literal|0
expr_stmt|;
comment|/*  make_abs_section(abfd);*/
return|return
name|true
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|coff_real_object_p
argument_list|,
operator|(
name|abfd
operator|,
name|nscns
operator|,
name|internal_f
operator|,
name|internal_a
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|nscns
name|AND
expr|struct
name|internal_filehdr
operator|*
name|internal_f
name|AND
expr|struct
name|internal_aouthdr
operator|*
name|internal_a
argument_list|)
block|{
name|coff_data_type
modifier|*
name|coff
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|long
name|machine
decl_stmt|;
name|size_t
name|readsize
decl_stmt|;
comment|/* length of file_info */
name|SCNHDR
modifier|*
name|external_sections
decl_stmt|;
comment|/* Build a play area */
if|if
condition|(
name|coff_mkobject
argument_list|(
name|abfd
argument_list|)
operator|!=
name|true
condition|)
return|return
literal|0
return|;
name|coff
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|external_sections
operator|=
operator|(
name|SCNHDR
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|readsize
operator|=
operator|(
name|nscns
operator|*
name|SCNHSZ
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|external_sections
argument_list|,
literal|1
argument_list|,
name|readsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|readsize
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
comment|/* Now copy data as required; construct all asections etc */
name|coff
operator|->
name|symbol_index_slew
operator|=
literal|0
expr_stmt|;
name|coff
operator|->
name|relocbase
operator|=
literal|0
expr_stmt|;
name|coff
operator|->
name|raw_syment_count
operator|=
literal|0
expr_stmt|;
name|coff
operator|->
name|raw_linenos
operator|=
literal|0
expr_stmt|;
name|coff
operator|->
name|raw_syments
operator|=
literal|0
expr_stmt|;
name|coff
operator|->
name|sym_filepos
operator|=
literal|0
expr_stmt|;
name|coff
operator|->
name|flags
operator|=
name|internal_f
operator|->
name|f_flags
expr_stmt|;
if|if
condition|(
name|nscns
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscns
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|internal_scnhdr
name|tmp
decl_stmt|;
name|coff_swap_scnhdr_in
argument_list|(
name|abfd
argument_list|,
name|external_sections
operator|+
name|i
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|make_a_section_from_file
argument_list|(
name|abfd
argument_list|,
operator|&
name|tmp
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  make_abs_section(abfd);*/
comment|/* Determine the machine architecture and type.  */
name|machine
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_magic
condition|)
block|{
ifdef|#
directive|ifdef
name|I386MAGIC
case|case
name|I386MAGIC
case|:
name|arch
operator|=
name|bfd_arch_i386
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|A29K_MAGIC_BIG
case|case
name|A29K_MAGIC_BIG
case|:
case|case
name|A29K_MAGIC_LITTLE
case|:
name|arch
operator|=
name|bfd_arch_a29k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS
case|case
name|MIPS_MAGIC_1
case|:
case|case
name|MIPS_MAGIC_2
case|:
case|case
name|MIPS_MAGIC_3
case|:
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC68MAGIC
case|case
name|MC68MAGIC
case|:
case|case
name|M68MAGIC
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
literal|68020
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC88MAGIC
case|case
name|MC88MAGIC
case|:
case|case
name|MC88DMAGIC
case|:
case|case
name|MC88OMAGIC
case|:
name|arch
operator|=
name|bfd_arch_m88k
expr_stmt|;
name|machine
operator|=
literal|88100
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Z8KMAGIC
case|case
name|Z8KMAGIC
case|:
name|arch
operator|=
name|bfd_arch_z8k
expr_stmt|;
switch|switch
condition|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_MACHMASK
condition|)
block|{
case|case
name|F_Z8001
case|:
name|machine
operator|=
name|bfd_mach_z8001
expr_stmt|;
break|break;
case|case
name|F_Z8002
case|:
name|machine
operator|=
name|bfd_mach_z8002
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960
ifdef|#
directive|ifdef
name|I960ROMAGIC
case|case
name|I960ROMAGIC
case|:
case|case
name|I960RWMAGIC
case|:
name|arch
operator|=
name|bfd_arch_i960
expr_stmt|;
switch|switch
condition|(
name|F_I960TYPE
operator|&
name|internal_f
operator|->
name|f_flags
condition|)
block|{
default|default:
case|case
name|F_I960CORE
case|:
name|machine
operator|=
name|bfd_mach_i960_core
expr_stmt|;
break|break;
case|case
name|F_I960KB
case|:
name|machine
operator|=
name|bfd_mach_i960_kb_sb
expr_stmt|;
break|break;
case|case
name|F_I960MC
case|:
name|machine
operator|=
name|bfd_mach_i960_mc
expr_stmt|;
break|break;
case|case
name|F_I960XA
case|:
name|machine
operator|=
name|bfd_mach_i960_xa
expr_stmt|;
break|break;
case|case
name|F_I960CA
case|:
name|machine
operator|=
name|bfd_mach_i960_ca
expr_stmt|;
break|break;
case|case
name|F_I960KA
case|:
name|machine
operator|=
name|bfd_mach_i960_ka_sa
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|U802ROMAGIC
case|case
name|U802ROMAGIC
case|:
case|case
name|U802WRMAGIC
case|:
case|case
name|U802TOCMAGIC
case|:
name|arch
operator|=
name|bfd_arch_rs6000
expr_stmt|;
name|machine
operator|=
literal|6000
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WE32KMAGIC
case|case
name|WE32KMAGIC
case|:
name|arch
operator|=
name|bfd_arch_we32k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300MAGIC
case|case
name|H8300MAGIC
case|:
name|arch
operator|=
name|bfd_arch_h8300
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Unreadable input file type */
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
break|break;
block|}
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_RELFLG
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
if|if
condition|(
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_EXEC
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_LNNO
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|internal_f
operator|->
name|f_flags
operator|&
name|F_LSYMS
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LOCALS
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_f
operator|->
name|f_nsyms
expr_stmt|;
if|if
condition|(
name|internal_f
operator|->
name|f_nsyms
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
name|coff
operator|->
name|sym_filepos
operator|=
name|internal_f
operator|->
name|f_symptr
expr_stmt|;
comment|/* These members communicate important constants about the symbol table     to GDB's symbol-reading code.  These `constants' unfortunately vary       from coff implementation to implementation...  */
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
name|coff
operator|->
name|local_n_btmask
operator|=
name|N_BTMASK
expr_stmt|;
name|coff
operator|->
name|local_n_btshft
operator|=
name|N_BTSHFT
expr_stmt|;
name|coff
operator|->
name|local_n_tmask
operator|=
name|N_TMASK
expr_stmt|;
name|coff
operator|->
name|local_n_tshift
operator|=
name|N_TSHIFT
expr_stmt|;
name|coff
operator|->
name|local_symesz
operator|=
name|SYMESZ
expr_stmt|;
name|coff
operator|->
name|local_auxesz
operator|=
name|AUXESZ
expr_stmt|;
name|coff
operator|->
name|local_linesz
operator|=
name|LINESZ
expr_stmt|;
endif|#
directive|endif
name|coff
operator|->
name|symbols
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal_f
operator|->
name|f_opthdr
condition|?
name|internal_a
operator|->
name|entry
else|:
literal|0
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|fail
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|coff
argument_list|)
expr_stmt|;
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_target
modifier|*
name|DEFUN
argument_list|(
name|coff_object_p
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|int
name|nscns
decl_stmt|;
name|FILHDR
name|filehdr
decl_stmt|;
name|AOUTHDR
name|opthdr
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
comment|/* figure out how much to read */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|filehdr
argument_list|,
literal|1
argument_list|,
name|FILHSZ
argument_list|,
name|abfd
argument_list|)
operator|!=
name|FILHSZ
condition|)
return|return
literal|0
return|;
name|bfd_swap_filehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|filehdr
argument_list|,
operator|&
name|internal_f
argument_list|)
expr_stmt|;
if|if
condition|(
name|BADMAG
argument_list|(
name|internal_f
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nscns
operator|=
name|internal_f
operator|.
name|f_nscns
expr_stmt|;
if|if
condition|(
name|internal_f
operator|.
name|f_opthdr
condition|)
block|{
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|opthdr
argument_list|,
literal|1
argument_list|,
name|AOUTSZ
argument_list|,
name|abfd
argument_list|)
operator|!=
name|AOUTSZ
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bfd_swap_aouthdr_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|opthdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|internal_a
argument_list|)
expr_stmt|;
block|}
comment|/* Seek past the opt hdr stuff */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|internal_f
operator|.
name|f_opthdr
operator|+
name|FILHSZ
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* if the optional header is NULL or not the correct size then      quit; the only difference I can see between m88k dgux headers (MC88DMAGIC)      and Intel 960 readwrite headers (I960WRMAGIC) is that the      optional header is of a different size.       But the mips keeps extra stuff in it's opthdr, so dont check      when doing that      */
if|#
directive|if
name|defined
argument_list|(
name|M88
argument_list|)
operator|||
name|defined
argument_list|(
name|I960
argument_list|)
if|if
condition|(
name|internal_f
operator|.
name|f_opthdr
operator|!=
literal|0
operator|&&
name|AOUTSZ
operator|!=
name|internal_f
operator|.
name|f_opthdr
condition|)
return|return
operator|(
name|bfd_target
operator|*
operator|)
name|NULL
return|;
endif|#
directive|endif
return|return
name|coff_real_object_p
argument_list|(
name|abfd
argument_list|,
name|nscns
argument_list|,
operator|&
name|internal_f
argument_list|,
operator|&
name|internal_a
argument_list|)
return|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_LINENOS
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_count_linenumbers
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|int
name|limit
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|asection
modifier|*
name|s
init|=
name|abfd
operator|->
name|sections
operator|->
name|output_section
decl_stmt|;
while|while
condition|(
name|s
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|lineno_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|q_maybe
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|q_maybe
operator|->
name|the_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_coff_flavour
condition|)
block|{
name|coff_symbol_type
modifier|*
name|q
init|=
name|coffsymbol
argument_list|(
name|q_maybe
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|lineno
condition|)
block|{
comment|/* 	  This symbol has a linenumber, increment the owning 	  section's linenumber count 	  */
name|alent
modifier|*
name|l
init|=
name|q
operator|->
name|lineno
decl_stmt|;
name|q
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|lineno_count
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
condition|)
block|{
name|q
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|lineno_count
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_LINENOS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
end_ifndef

begin_comment
comment|/*   Takes a bfd and a symbol, returns a pointer to the coff specific area   of the symbol if there is one.   */
end_comment

begin_decl_stmt
specifier|static
name|coff_symbol_type
modifier|*
name|DEFUN
argument_list|(
name|coff_symbol_from
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|symbol
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|symbol
argument_list|)
block|{
if|if
condition|(
name|symbol
operator|->
name|the_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
name|symbol
operator|->
name|the_bfd
operator|->
name|tdata
operator|.
name|coff_obj_data
operator|==
operator|(
name|coff_data_type
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
return|;
return|return
operator|(
name|coff_symbol_type
operator|*
operator|)
name|symbol
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|fixup_symbol_value
argument_list|,
operator|(
name|coff_symbol_ptr
operator|,
name|syment
operator|)
argument_list|,
name|coff_symbol_type
operator|*
name|coff_symbol_ptr
name|AND
expr|struct
name|internal_syment
operator|*
name|syment
argument_list|)
block|{
comment|/* Normalize the symbol flags */
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|==
operator|&
name|bfd_com_section
condition|)
block|{
comment|/* a common symbol is undefined with a value */
name|syment
operator|->
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
name|syment
operator|->
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
condition|)
block|{
name|syment
operator|->
name|n_scnum
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
operator|+
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
operator|+
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This can happen, but I don't know why yet (steve@cygnus.com) */
name|syment
operator|->
name|n_scnum
operator|=
name|N_ABS
expr_stmt|;
name|syment
operator|->
name|n_value
operator|=
name|coff_symbol_ptr
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* run through all the symbols in the symbol table and work out what    their indexes into the symbol table will be when output   Coff requires that each C_FILE symbol points to the next one in the  chain, and that the last one points to the first external symbol. We  do that here too.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_renumber_symbols
argument_list|,
operator|(
name|bfd_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|bfd_ptr
argument_list|)
block|{
name|unsigned
name|int
name|symbol_count
init|=
name|bfd_get_symcount
argument_list|(
name|bfd_ptr
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_ptr_ptr
init|=
name|bfd_ptr
operator|->
name|outsymbols
decl_stmt|;
name|unsigned
name|int
name|native_index
init|=
literal|0
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|last_file
init|=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|NULL
decl_stmt|;
name|unsigned
name|int
name|symbol_index
decl_stmt|;
comment|/* COFF demands that undefined symbols come after all other symbols.      Since we don't need to impose this extra knowledge on all our client      programs, deal with that here.  Sort the symbol table; just move the      undefined symbols to the end, leaving the rest alone.  */
comment|/* @@ Do we have some condition we could test for, so we don't always      have to do this?  I don't think relocatability is quite right, but      I'm not certain.  [raeburn:19920508.1711EST]  */
block|{
name|asymbol
modifier|*
modifier|*
name|newsyms
decl_stmt|;
name|int
name|i
decl_stmt|;
name|newsyms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|bfd_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|*
operator|(
name|symbol_count
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bfd_ptr
operator|->
name|outsymbols
operator|=
name|newsyms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
operator|!=
operator|&
name|bfd_und_section
condition|)
operator|*
name|newsyms
operator|++
operator|=
name|symbol_ptr_ptr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symbol_ptr_ptr
index|[
name|i
index|]
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
operator|*
name|newsyms
operator|++
operator|=
name|symbol_ptr_ptr
index|[
name|i
index|]
expr_stmt|;
operator|*
name|newsyms
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
expr_stmt|;
name|symbol_ptr_ptr
operator|=
name|bfd_ptr
operator|->
name|outsymbols
expr_stmt|;
block|}
for|for
control|(
name|symbol_index
operator|=
literal|0
init|;
name|symbol_index
operator|<
name|symbol_count
condition|;
name|symbol_index
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|coff_symbol_ptr
init|=
name|coff_symbol_from
argument_list|(
name|bfd_ptr
argument_list|,
name|symbol_ptr_ptr
index|[
name|symbol_index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|coff_symbol_ptr
operator|&&
name|coff_symbol_ptr
operator|->
name|native
condition|)
block|{
name|combined_entry_type
modifier|*
name|s
init|=
name|coff_symbol_ptr
operator|->
name|native
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
if|if
condition|(
name|last_file
operator|!=
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|NULL
condition|)
block|{
name|last_file
operator|->
name|n_value
operator|=
name|native_index
expr_stmt|;
block|}
name|last_file
operator|=
operator|&
operator|(
name|s
operator|->
name|u
operator|.
name|syment
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Modify the symbol values according to their section and 	       type */
name|fixup_symbol_value
argument_list|(
name|coff_symbol_ptr
argument_list|,
operator|&
operator|(
name|s
operator|->
name|u
operator|.
name|syment
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|s
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|native_index
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|native_index
operator|++
expr_stmt|;
block|}
block|}
name|obj_conv_table_size
argument_list|(
name|bfd_ptr
argument_list|)
operator|=
name|native_index
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  Run thorough the symbol table again, and fix it so that all pointers to  entries are changed to the entries' index in the output symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_mangle_symbols
argument_list|,
operator|(
name|bfd_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|bfd_ptr
argument_list|)
block|{
name|unsigned
name|int
name|symbol_count
init|=
name|bfd_get_symcount
argument_list|(
name|bfd_ptr
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_ptr_ptr
init|=
name|bfd_ptr
operator|->
name|outsymbols
decl_stmt|;
name|unsigned
name|int
name|symbol_index
decl_stmt|;
for|for
control|(
name|symbol_index
operator|=
literal|0
init|;
name|symbol_index
operator|<
name|symbol_count
condition|;
name|symbol_index
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|coff_symbol_ptr
init|=
name|coff_symbol_from
argument_list|(
name|bfd_ptr
argument_list|,
name|symbol_ptr_ptr
index|[
name|symbol_index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|coff_symbol_ptr
operator|&&
name|coff_symbol_ptr
operator|->
name|native
condition|)
block|{
name|int
name|i
decl_stmt|;
name|combined_entry_type
modifier|*
name|s
init|=
name|coff_symbol_ptr
operator|->
name|native
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|i
operator|++
control|)
block|{
name|combined_entry_type
modifier|*
name|a
init|=
name|s
operator|+
name|i
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|fix_tag
condition|)
block|{
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|=
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|->
name|offset
expr_stmt|;
name|a
operator|->
name|fix_tag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|fix_end
condition|)
block|{
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
operator|=
name|a
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|->
name|offset
expr_stmt|;
name|a
operator|->
name|fix_end
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|string_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_fix_symbol_name
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|symbol
operator|,
name|native
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|combined_entry_type
operator|*
name|native
argument_list|)
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|auxent
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|symbol
operator|->
name|name
operator|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* coff symbols always have names, so we'll make one up */
name|symbol
operator|->
name|name
operator|=
literal|"strange"
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|symbol
operator|->
name|name
expr_stmt|;
block|}
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
name|strncpy
argument_list|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
literal|".file"
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|auxent
operator|=
operator|&
operator|(
name|native
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_LONG_FILENAMES
if|if
condition|(
name|name_length
operator|<=
name|FILNMLEN
condition|)
block|{
name|strncpy
argument_list|(
name|auxent
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|name
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auxent
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
operator|=
name|string_size
operator|+
literal|4
expr_stmt|;
name|auxent
operator|->
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|=
literal|0
expr_stmt|;
name|string_size
operator|+=
name|name_length
operator|+
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|strncpy
argument_list|(
name|auxent
operator|->
name|x_file
operator|.
name|x_fname
argument_list|,
name|name
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|FILNMLEN
condition|)
block|{
name|name
index|[
name|FILNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* NOT A C_FILE SYMBOL */
if|if
condition|(
name|name_length
operator|<=
name|SYMNMLEN
condition|)
block|{
comment|/* This name will fit into the symbol neatly */
name|strncpy
argument_list|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
name|string_size
operator|+
literal|4
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
name|string_size
operator|+=
name|name_length
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_write_symbol
argument_list|,
operator|(
name|abfd
operator|,
name|symbol
operator|,
name|native
operator|,
name|written
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|combined_entry_type
operator|*
name|native
name|AND
name|unsigned
name|int
name|written
argument_list|)
block|{
name|unsigned
name|int
name|numaux
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
decl_stmt|;
name|int
name|type
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
decl_stmt|;
name|int
name|class
init|=
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
decl_stmt|;
name|SYMENT
name|buf
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* @@ bfd_debug_section isn't accessible outside this file, but we know      that C_FILE symbols belong there.  So move them.  */
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
name|symbol
operator|->
name|section
operator|=
operator|&
name|bfd_debug_section
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_abs_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_debug_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_DEBUG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
block|}
else|else
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
name|coff_fix_symbol_name
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|native
argument_list|)
expr_stmt|;
name|coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|native
operator|->
name|u
operator|.
name|syment
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buf
argument_list|,
literal|1
argument_list|,
name|SYMESZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|j
operator|++
control|)
block|{
name|AUXENT
name|buf1
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
name|coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
operator|(
name|native
operator|+
name|j
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|buf1
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|&
name|buf1
argument_list|)
argument_list|,
literal|1
argument_list|,
name|AUXESZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
comment|/*     Reuse somewhere in the symbol to keep the index     */
name|set_index
argument_list|(
name|symbol
argument_list|,
name|written
argument_list|)
expr_stmt|;
return|return
name|written
operator|+
literal|1
operator|+
name|numaux
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_write_alien_symbol
argument_list|,
operator|(
name|abfd
operator|,
name|symbol
operator|,
name|written
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|unsigned
name|int
name|written
argument_list|)
block|{
comment|/*     This symbol has been created by the loader, or come from a non     coff format. It  has no native element to inherit, make our     own     */
name|combined_entry_type
modifier|*
name|native
decl_stmt|;
name|combined_entry_type
name|dummy
decl_stmt|;
name|native
operator|=
operator|&
name|dummy
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
name|T_NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|I960
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_com_section
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|N_UNDEF
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
comment|/* 	remove name so it doesn't take up any space 	*/
name|symbol
operator|->
name|name
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|I960
comment|/* Copy the any flags from the the file hdr into the symbol  */
block|{
name|coff_symbol_type
modifier|*
name|c
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
operator|=
name|c
operator|->
name|symbol
operator|.
name|the_bfd
operator|->
name|flags
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|HASPAD1
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|pad1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|pad1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
else|else
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_EXT
expr_stmt|;
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|=
literal|0
expr_stmt|;
return|return
name|coff_write_symbol
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|native
argument_list|,
name|written
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_write_native_symbol
argument_list|,
operator|(
name|abfd
operator|,
name|symbol
operator|,
name|written
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|coff_symbol_type
operator|*
name|symbol
name|AND
name|unsigned
name|int
name|written
argument_list|)
block|{
comment|/*     Does this symbol have an ascociated line number - if so then     make it remember this symbol index. Also tag the auxent of     this symbol to point to the right place in the lineno table     */
name|combined_entry_type
modifier|*
name|native
init|=
name|symbol
operator|->
name|native
decl_stmt|;
name|alent
modifier|*
name|lineno
init|=
name|symbol
operator|->
name|lineno
decl_stmt|;
if|if
condition|(
name|lineno
operator|&&
operator|!
name|symbol
operator|->
name|done_lineno
condition|)
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|lineno
index|[
name|count
index|]
operator|.
name|u
operator|.
name|offset
operator|=
name|written
expr_stmt|;
if|if
condition|(
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
name|union
name|internal_auxent
modifier|*
name|a
init|=
operator|&
operator|(
operator|(
name|native
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
decl_stmt|;
name|a
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|moving_line_filepos
expr_stmt|;
block|}
comment|/*       And count and relocate all other linenumbers       */
name|count
operator|++
expr_stmt|;
while|while
condition|(
name|lineno
index|[
name|count
index|]
operator|.
name|line_number
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 13 april 92. sac  I've been told this, but still need proof:> The second bug is also in `bfd/coffcode.h'.  This bug causes the linker to screw> up the pc-relocations for all the line numbers in COFF code.  This bug isn't> only specific to A29K implementations, but affects all systems using COFF> format binaries.  Note that in COFF object files, the line number core offsets> output by the assembler are relative to the start of each procedure, not> to the start of the .text section.  This patch relocates the line numbers> relative to the `native->u.syment.n_value' instead of the section virtual> address.  modular!olson@cs.arizona.edu (Jon Olson) */
block|lineno[count].u.offset += native->u.syment.n_value;
else|#
directive|else
name|lineno
index|[
name|count
index|]
operator|.
name|u
operator|.
name|offset
operator|+=
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_offset
expr_stmt|;
endif|#
directive|endif
name|count
operator|++
expr_stmt|;
block|}
name|symbol
operator|->
name|done_lineno
operator|=
name|true
expr_stmt|;
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|->
name|output_section
operator|->
name|moving_line_filepos
operator|+=
name|count
operator|*
name|LINESZ
expr_stmt|;
block|}
return|return
name|coff_write_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
name|symbol
operator|->
name|symbol
operator|)
argument_list|,
name|native
argument_list|,
name|written
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_write_symbols
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|limit
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|written
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
name|string_size
operator|=
literal|0
expr_stmt|;
comment|/* Seek to the right place */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Output all the symbols we have */
name|written
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|symbol
init|=
operator|*
name|p
decl_stmt|;
name|coff_symbol_type
modifier|*
name|c_symbol
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|c_symbol
operator|==
operator|(
name|coff_symbol_type
operator|*
operator|)
name|NULL
operator|||
name|c_symbol
operator|->
name|native
operator|==
operator|(
name|combined_entry_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|written
operator|=
name|coff_write_alien_symbol
argument_list|(
name|abfd
argument_list|,
name|symbol
argument_list|,
name|written
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|written
operator|=
name|coff_write_native_symbol
argument_list|(
name|abfd
argument_list|,
name|c_symbol
argument_list|,
name|written
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|written
expr_stmt|;
comment|/* Now write out strings */
if|if
condition|(
name|string_size
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|string_size
operator|+
literal|4
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|outsymbols
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|asymbol
modifier|*
name|q
init|=
operator|*
name|p
decl_stmt|;
name|size_t
name|name_length
init|=
name|strlen
argument_list|(
name|q
operator|->
name|name
argument_list|)
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|coff_symbol_type
modifier|*
name|c_symbol
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|q
argument_list|)
decl_stmt|;
name|maxlen
operator|=
operator|(
operator|(
name|c_symbol
operator|!=
name|NULL
operator|&&
name|c_symbol
operator|->
name|native
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|c_symbol
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
operator|)
operator|)
condition|?
name|FILNMLEN
else|:
name|SYMNMLEN
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|maxlen
condition|)
block|{
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
name|q
operator|->
name|name
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name_length
operator|+
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We would normally not write anything here, but we'll write        out 4 so that any stupid coff reader which tries to read        the string table even when there isn't one won't croak.        */
name|uint32e_type
name|size
init|=
literal|4
decl_stmt|;
name|size
operator|=
name|size
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|size
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* SUBSUBSECTION 	Writing Relocations  	To write relocations, all the back end does is step though the 	canonical relocation table, and create an 	@code{internal_reloc}. The symbol index to use is removed from 	the @code{offset} field in the symbol table supplied, the 	address comes directly from the sum of the section base 	address and the relocation offset and the type is dug directly 	from the howto field.  Then the @code{internal_reloc} is 	swapped into the shape of an @code{external_reloc} and written 	out to disk.   */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_write_relocs
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|external_reloc
name|dst
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
init|=
name|s
operator|->
name|orelocation
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|internal_reloc
name|n
decl_stmt|;
name|arelent
modifier|*
name|q
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|.
name|r_vaddr
operator|=
name|q
operator|->
name|address
operator|+
name|s
operator|->
name|vma
expr_stmt|;
comment|/* The 29k const/consth reloc pair is a real kludge - the consth 	 part doesn't have a symbol - it has an offset. So rebuilt 	 that here */
ifdef|#
directive|ifdef
name|R_IHCONST
if|if
condition|(
name|q
operator|->
name|howto
operator|->
name|type
operator|==
name|R_IHCONST
condition|)
name|n
operator|.
name|r_symndx
operator|=
name|q
operator|->
name|addend
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
condition|)
block|{
name|n
operator|.
name|r_symndx
operator|=
name|get_index
argument_list|(
operator|(
operator|*
operator|(
name|q
operator|->
name|sym_ptr_ptr
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Take notice if the symbol reloc points to a symbol we don't have 	   in our symbol table.  What should we do for this??  */
if|if
condition|(
name|n
operator|.
name|r_symndx
operator|>
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SELECT_RELOC
comment|/* Work out reloc type from what is required */
name|SELECT_RELOC
argument_list|(
name|n
operator|.
name|r_type
argument_list|,
name|q
operator|->
name|howto
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|.
name|r_type
operator|=
name|q
operator|->
name|howto
operator|->
name|type
expr_stmt|;
endif|#
directive|endif
name|coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|dst
argument_list|,
literal|1
argument_list|,
name|RELSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_SYMBOLS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_LINENOS
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_write_linenumbers
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|lineno_count
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|q
init|=
name|abfd
operator|->
name|outsymbols
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|line_filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Find all the linenumbers in this section */
while|while
condition|(
operator|*
name|q
condition|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|q
decl_stmt|;
name|alent
modifier|*
name|l
init|=
name|BFD_SEND
argument_list|(
name|p
operator|->
name|the_bfd
argument_list|,
name|_get_lineno
argument_list|,
operator|(
name|p
operator|->
name|the_bfd
expr|,
name|p
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
condition|)
block|{
comment|/* Found a linenumber entry, output */
name|struct
name|internal_lineno
name|out
decl_stmt|;
name|LINENO
name|buff
decl_stmt|;
name|memset
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|l_lnno
operator|=
literal|0
expr_stmt|;
name|out
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
name|l
operator|->
name|u
operator|.
name|offset
expr_stmt|;
name|coff_swap_lineno_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|buff
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
literal|1
argument_list|,
name|LINESZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
condition|)
block|{
name|out
operator|.
name|l_lnno
operator|=
name|l
operator|->
name|line_number
expr_stmt|;
name|out
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
name|l
operator|->
name|u
operator|.
name|offset
expr_stmt|;
name|coff_swap_lineno_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|buff
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
literal|1
argument_list|,
name|LINESZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
name|q
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|alent
modifier|*
name|DEFUN
argument_list|(
name|coff_get_lineno
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|symbol
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|asymbol
operator|*
name|symbol
argument_list|)
block|{
return|return
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_LINENOS */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|coff_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|coff_symbol_type
modifier|*
name|new
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|native
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
end_ifndef

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|DEFUN
argument_list|(
name|coff_make_debug_symbol
argument_list|,
operator|(
name|abfd
operator|,
name|ptr
operator|,
name|sz
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|PTR
name|ptr
name|AND
name|unsigned
name|long
name|sz
argument_list|)
block|{
name|coff_symbol_type
modifier|*
name|new
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
comment|/* @@ This shouldn't be using a constant multiplier.  */
name|new
operator|->
name|native
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_debug_section
expr_stmt|;
name|new
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_print_symbol
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|filep
operator|,
name|symbol
operator|,
name|how
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|PTR
name|filep
name|AND
name|asymbol
operator|*
name|symbol
name|AND
name|bfd_print_symbol_type
name|how
argument_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"coff %lx %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_nm
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s %s %s"
argument_list|,
name|section_name
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|?
literal|"n"
else|:
literal|"g"
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
condition|?
literal|"l"
else|:
literal|" "
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|bfd_print_symbol_all
case|:
comment|/* Print out the symbols in a reasonable way */
block|{
name|CONST
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|)
block|{
name|unsigned
name|int
name|aux
decl_stmt|;
name|combined_entry_type
modifier|*
name|combined
init|=
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
decl_stmt|;
name|combined_entry_type
modifier|*
name|root
init|=
name|obj_raw_syments
argument_list|(
name|ignore_abfd
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%3d]"
argument_list|,
name|combined
operator|-
name|root
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(sc %2d)(fl%4x)(ty%3x)(sc%3d) nx(%d) %08x %s"
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_flags
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
argument_list|,
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|aux
operator|=
literal|0
init|;
name|aux
operator|<
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|aux
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|combined
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
condition|)
block|{
case|case
name|C_FILE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"File "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"AUX lnno %x size %x tagndx %x"
argument_list|,
name|combined
index|[
name|aux
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
argument_list|,
name|combined
index|[
name|aux
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
argument_list|,
name|combined
index|[
name|aux
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|{
name|struct
name|lineno_cache_entry
modifier|*
name|l
init|=
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
decl_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s :"
argument_list|,
name|l
operator|->
name|u
operator|.
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
while|while
condition|(
name|l
operator|->
name|line_number
condition|)
block|{
name|printf
argument_list|(
literal|"\n%4d : %x"
argument_list|,
name|l
operator|->
name|line_number
argument_list|,
name|l
operator|->
name|u
operator|.
name|offset
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s %s %s"
argument_list|,
name|section_name
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|native
condition|?
literal|"n"
else|:
literal|"g"
argument_list|,
name|coffsymbol
argument_list|(
name|symbol
argument_list|)
operator|->
name|lineno
condition|?
literal|"l"
else|:
literal|" "
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_SYMBOLS */
end_comment

begin_comment
comment|/* Set flags and magic number of a coff file from architecture and machine    type.  Result is true if we can represent the arch&type, false if not.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_set_flags
argument_list|,
operator|(
name|abfd
operator|,
name|magicp
operator|,
name|flagsp
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
operator|*
name|magicp
name|AND
name|unsigned
name|short
operator|*
name|flagsp
argument_list|)
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|Z8KMAGIC
case|case
name|bfd_arch_z8k
case|:
operator|*
name|magicp
operator|=
name|Z8KMAGIC
expr_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_z8001
case|:
operator|*
name|flagsp
operator|=
name|F_Z8001
expr_stmt|;
break|break;
case|case
name|bfd_mach_z8002
case|:
operator|*
name|flagsp
operator|=
name|F_Z8002
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|true
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I960ROMAGIC
case|case
name|bfd_arch_i960
case|:
block|{
name|unsigned
name|flags
decl_stmt|;
operator|*
name|magicp
operator|=
name|I960ROMAGIC
expr_stmt|;
comment|/* 	  ((bfd_get_file_flags(abfd)& WP_TEXT) ? I960ROMAGIC : 	  I960RWMAGIC);   FIXME??? 	  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_i960_core
case|:
name|flags
operator|=
name|F_I960CORE
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_kb_sb
case|:
name|flags
operator|=
name|F_I960KB
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_mc
case|:
name|flags
operator|=
name|F_I960MC
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_xa
case|:
name|flags
operator|=
name|F_I960XA
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_ca
case|:
name|flags
operator|=
name|F_I960CA
expr_stmt|;
break|break;
case|case
name|bfd_mach_i960_ka_sa
case|:
name|flags
operator|=
name|F_I960KA
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
operator|*
name|flagsp
operator|=
name|flags
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS
case|case
name|bfd_arch_mips
case|:
operator|*
name|magicp
operator|=
name|MIPS_MAGIC_2
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I386MAGIC
case|case
name|bfd_arch_i386
case|:
operator|*
name|magicp
operator|=
name|I386MAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC68MAGIC
case|case
name|bfd_arch_m68k
case|:
operator|*
name|magicp
operator|=
name|MC68MAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MC88MAGIC
case|case
name|bfd_arch_m88k
case|:
operator|*
name|magicp
operator|=
name|MC88OMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|H8300MAGIC
case|case
name|bfd_arch_h8300
case|:
operator|*
name|magicp
operator|=
name|H8300MAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|A29K_MAGIC_BIG
case|case
name|bfd_arch_a29k
case|:
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
condition|)
operator|*
name|magicp
operator|=
name|A29K_MAGIC_BIG
expr_stmt|;
else|else
operator|*
name|magicp
operator|=
name|A29K_MAGIC_LITTLE
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WE32KMAGIC
case|case
name|bfd_arch_we32k
case|:
operator|*
name|magicp
operator|=
name|WE32KMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|U802TOCMAGIC
case|case
name|bfd_arch_rs6000
case|:
operator|*
name|magicp
operator|=
name|U802TOCMAGIC
expr_stmt|;
return|return
name|true
return|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Unknown architecture */
comment|/* return false;  -- fall through to "return false" below, to avoid        "statement never reached" errors on the one below. */
break|break;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_set_arch_mach
argument_list|,
operator|(
name|abfd
operator|,
name|arch
operator|,
name|machine
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|enum
name|bfd_architecture
name|arch
name|AND
name|unsigned
name|long
name|machine
argument_list|)
block|{
name|unsigned
name|dummy1
decl_stmt|;
name|unsigned
name|short
name|dummy2
decl_stmt|;
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
name|bfd_arch_unknown
operator|&&
name|coff_set_flags
argument_list|(
name|abfd
argument_list|,
operator|&
name|dummy1
argument_list|,
operator|&
name|dummy2
argument_list|)
operator|!=
name|true
condition|)
return|return
name|false
return|;
comment|/* We can't represent this type */
return|return
name|true
return|;
comment|/* We're easy ... */
block|}
end_decl_stmt

begin_comment
comment|/* Calculate the file position for each section. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_compute_section_file_positions
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|asection
modifier|*
name|previous
init|=
operator|(
name|asection
operator|*
operator|)
name|NULL
decl_stmt|;
name|file_ptr
name|sofar
init|=
name|FILHSZ
decl_stmt|;
name|file_ptr
name|old_sofar
decl_stmt|;
if|if
condition|(
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/*  A start address may have been added to the original file. In this 	case it will need an optional header to record it.  */
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|sofar
operator|+=
name|AOUTSZ
expr_stmt|;
name|sofar
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|SCNHSZ
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
comment|/* Only deal with sections which have contents */
if|if
condition|(
operator|!
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
condition|)
continue|continue;
comment|/* Align the sections in the file to the same boundary on 	 which they are aligned in virtual memory.  I960 doesn't 	 do this (FIXME) so we can stay in sync with Intel.  960 	 doesn't yet page from files... */
ifndef|#
directive|ifndef
name|I960
block|{
comment|/* make sure this section is aligned on the right boundary - by 	 padding the previous section up if necessary */
name|old_sofar
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|previous
operator|->
name|_raw_size
operator|+=
name|sofar
operator|-
name|old_sofar
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FIXME, in demand paged files, the low order bits of the file 	 offset must match the low order bits of the virtual address. 	 "Low order" is apparently implementation defined.  Add code 	 here to round sofar up to match the virtual address.  */
name|current
operator|->
name|filepos
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|+=
name|current
operator|->
name|_raw_size
expr_stmt|;
ifndef|#
directive|ifndef
name|I960
comment|/* make sure that this section is of the right size too */
name|old_sofar
operator|=
name|sofar
expr_stmt|;
name|sofar
operator|=
name|BFD_ALIGN
argument_list|(
name|sofar
argument_list|,
literal|1
operator|<<
name|current
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
name|current
operator|->
name|_raw_size
operator|+=
name|sofar
operator|-
name|old_sofar
expr_stmt|;
endif|#
directive|endif
name|previous
operator|=
name|current
expr_stmt|;
block|}
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
operator|=
name|sofar
expr_stmt|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
end_ifndef

begin_function
specifier|static
name|asymbol
modifier|*
name|coff_section_symbol
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|combined_entry_type
modifier|*
name|csym
decl_stmt|;
name|sym
operator|=
name|sec
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
condition|)
name|csym
operator|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|->
name|native
expr_stmt|;
else|else
name|csym
operator|=
literal|0
expr_stmt|;
comment|/* Make sure back-end COFF stuff is there.  */
if|if
condition|(
name|csym
operator|==
literal|0
condition|)
block|{
struct|struct
name|foo
block|{
name|coff_symbol_type
name|sym
decl_stmt|;
comment|/* @@FIXME This shouldn't use a fixed size!!  */
name|combined_entry_type
name|e
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|foo
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|(
expr|struct
name|foo
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
operator|->
name|native
operator|=
name|csym
operator|=
name|f
operator|->
name|e
expr_stmt|;
block|}
name|csym
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_STAT
expr_stmt|;
name|csym
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|=
literal|1
expr_stmt|;
comment|/*  SF_SET_STATICS (sym);	@@ ??? */
if|if
condition|(
name|sec
condition|)
block|{
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_scnlen
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_nreloc
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_nlinno
operator|=
name|sec
operator|->
name|lineno_count
expr_stmt|;
block|}
else|else
block|{
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_scnlen
operator|=
literal|0
expr_stmt|;
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_nreloc
operator|=
literal|0
expr_stmt|;
name|csym
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_scn
operator|.
name|x_nlinno
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_function

begin_comment
comment|/* If .file, .text, .data, .bss symbols are missing, add them.  */
end_comment

begin_comment
comment|/* @@ Should we only be adding missing symbols, or overriding the aux    values for existing section symbols?  */
end_comment

begin_function
specifier|static
name|void
name|coff_add_missing_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|int
name|nsyms
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sympp
init|=
name|abfd
operator|->
name|outsymbols
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sympp2
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|need_text
init|=
literal|1
decl_stmt|,
name|need_data
init|=
literal|1
decl_stmt|,
name|need_bss
init|=
literal|1
decl_stmt|,
name|need_file
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|coff_symbol_type
modifier|*
name|csym
init|=
name|coff_symbol_from
argument_list|(
name|abfd
argument_list|,
name|sympp
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|csym
condition|)
block|{
comment|/* only do this if there is a coff representation of the input 	   symbol */
if|if
condition|(
name|csym
operator|->
name|native
operator|&&
name|csym
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
name|need_file
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|csym
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|_TEXT
argument_list|)
condition|)
name|need_text
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|_DATA
argument_list|)
condition|)
name|need_data
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|_BSS
argument_list|)
condition|)
name|need_bss
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now i == bfd_get_symcount (abfd).  */
comment|/* @@ For now, don't deal with .file symbol.  */
name|need_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|need_text
operator|&&
operator|!
name|need_data
operator|&&
operator|!
name|need_bss
operator|&&
operator|!
name|need_file
condition|)
return|return;
name|nsyms
operator|+=
name|need_text
operator|+
name|need_data
operator|+
name|need_bss
operator|+
name|need_file
expr_stmt|;
name|sympp2
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc_by_size_t
argument_list|(
name|abfd
argument_list|,
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sympp2
argument_list|,
name|sympp
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_file
condition|)
block|{
comment|/* @@ Generate fake .file symbol, in sympp2[i], and increment i.  */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|need_text
condition|)
name|sympp2
index|[
name|i
operator|++
index|]
operator|=
name|coff_section_symbol
argument_list|(
name|abfd
argument_list|,
name|_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_data
condition|)
name|sympp2
index|[
name|i
operator|++
index|]
operator|=
name|coff_section_symbol
argument_list|(
name|abfd
argument_list|,
name|_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_bss
condition|)
name|sympp2
index|[
name|i
operator|++
index|]
operator|=
name|coff_section_symbol
argument_list|(
name|abfd
argument_list|,
name|_BSS
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|i
operator|==
name|nsyms
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|sympp2
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_SYMBOLS */
end_comment

begin_comment
comment|/* SUPPRESS 558 */
end_comment

begin_comment
comment|/* SUPPRESS 529 */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_write_object_contents
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|asection
modifier|*
name|current
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|boolean
name|hasrelocs
init|=
name|false
decl_stmt|;
name|boolean
name|haslinno
init|=
name|false
decl_stmt|;
name|file_ptr
name|reloc_base
decl_stmt|;
name|file_ptr
name|lineno_base
decl_stmt|;
name|file_ptr
name|sym_base
decl_stmt|;
name|file_ptr
name|scn_base
decl_stmt|;
name|file_ptr
name|data_base
decl_stmt|;
name|unsigned
name|long
name|reloc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|lnno_size
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|text_sec
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|data_sec
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|bss_sec
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_filehdr
name|internal_f
decl_stmt|;
name|struct
name|internal_aouthdr
name|internal_a
decl_stmt|;
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
comment|/* Number the output sections, starting from one on the first section      with a name which doesn't start with a *.      @@ The code doesn't make this check.  Is it supposed to be done,      or isn't it??  */
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|current
operator|->
name|target_index
operator|=
name|count
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
block|{
name|coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|->
name|sections
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|scn_base
operator|=
name|abfd
operator|->
name|sections
operator|->
name|filepos
expr_stmt|;
block|}
else|else
block|{
name|scn_base
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|scn_base
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|reloc_base
operator|=
name|obj_relocbase
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Make a pass through the symbol table to count line number entries and      put them into the correct asections */
ifndef|#
directive|ifndef
name|NO_COFF_LINENOS
name|coff_count_linenumbers
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data_base
operator|=
name|scn_base
expr_stmt|;
comment|/* Work out the size of the reloc and linno areas */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
comment|/* We give section headers to +ve indexes */
if|if
condition|(
name|current
operator|->
name|target_index
operator|>
literal|0
condition|)
block|{
name|reloc_size
operator|+=
name|current
operator|->
name|reloc_count
operator|*
name|RELSZ
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_COFF_LINENOS
name|lnno_size
operator|+=
name|current
operator|->
name|lineno_count
operator|*
name|LINESZ
expr_stmt|;
endif|#
directive|endif
name|data_base
operator|+=
name|SCNHSZ
expr_stmt|;
block|}
block|}
name|lineno_base
operator|=
name|reloc_base
operator|+
name|reloc_size
expr_stmt|;
name|sym_base
operator|=
name|lineno_base
operator|+
name|lnno_size
expr_stmt|;
comment|/* Indicate in each section->line_filepos its actual file address */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|target_index
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|lineno_count
condition|)
block|{
name|current
operator|->
name|line_filepos
operator|=
name|lineno_base
expr_stmt|;
name|current
operator|->
name|moving_line_filepos
operator|=
name|lineno_base
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_COFF_LINENOS
name|lineno_base
operator|+=
name|current
operator|->
name|lineno_count
operator|*
name|LINESZ
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|current
operator|->
name|line_filepos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|->
name|reloc_count
condition|)
block|{
name|current
operator|->
name|rel_filepos
operator|=
name|reloc_base
expr_stmt|;
name|reloc_base
operator|+=
name|current
operator|->
name|reloc_count
operator|*
name|RELSZ
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|rel_filepos
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Write section headers to the file.  */
name|internal_f
operator|.
name|f_nscns
operator|=
literal|0
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
condition|?
operator|(
name|FILHSZ
operator|+
name|AOUTSZ
operator|)
else|:
name|FILHSZ
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|{
if|#
directive|if
literal|0
block|unsigned int    pad = abfd->flags& D_PAGED ? data_base : 0;
endif|#
directive|endif
name|unsigned
name|int
name|pad
init|=
literal|0
decl_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|sections
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|struct
name|internal_scnhdr
name|section
decl_stmt|;
if|if
condition|(
name|current
operator|->
name|target_index
operator|>
literal|0
condition|)
block|{
name|internal_f
operator|.
name|f_nscns
operator|++
expr_stmt|;
name|strncpy
argument_list|(
operator|&
operator|(
name|section
operator|.
name|s_name
index|[
literal|0
index|]
operator|)
argument_list|,
name|current
operator|->
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|section
operator|.
name|s_vaddr
operator|=
name|current
operator|->
name|vma
operator|+
name|pad
expr_stmt|;
name|section
operator|.
name|s_paddr
operator|=
name|current
operator|->
name|vma
operator|+
name|pad
expr_stmt|;
name|section
operator|.
name|s_size
operator|=
name|current
operator|->
name|_raw_size
operator|-
name|pad
expr_stmt|;
comment|/* 	  If this section has no size or is unloadable then the scnptr 	  will be 0 too 	  */
if|if
condition|(
name|current
operator|->
name|_raw_size
operator|-
name|pad
operator|==
literal|0
operator|||
operator|(
name|current
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
block|{
name|section
operator|.
name|s_scnptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|section
operator|.
name|s_scnptr
operator|=
name|current
operator|->
name|filepos
expr_stmt|;
block|}
name|section
operator|.
name|s_relptr
operator|=
name|current
operator|->
name|rel_filepos
expr_stmt|;
name|section
operator|.
name|s_lnnoptr
operator|=
name|current
operator|->
name|line_filepos
expr_stmt|;
name|section
operator|.
name|s_nreloc
operator|=
name|current
operator|->
name|reloc_count
expr_stmt|;
name|section
operator|.
name|s_nlnno
operator|=
name|current
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
name|hasrelocs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|lineno_count
operator|!=
literal|0
condition|)
name|haslinno
operator|=
name|true
expr_stmt|;
name|section
operator|.
name|s_flags
operator|=
name|sec_to_styp_flags
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|current
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_TEXT
argument_list|)
condition|)
block|{
name|text_sec
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_DATA
argument_list|)
condition|)
block|{
name|data_sec
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|current
operator|->
name|name
argument_list|,
name|_BSS
argument_list|)
condition|)
block|{
name|bss_sec
operator|=
name|current
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|I960
name|section
operator|.
name|s_align
operator|=
operator|(
name|current
operator|->
name|alignment_power
condition|?
literal|1
operator|<<
name|current
operator|->
name|alignment_power
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
block|{
name|SCNHDR
name|buff
decl_stmt|;
name|coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|section
argument_list|,
operator|&
name|buff
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
call|(
name|PTR
call|)
argument_list|(
operator|&
name|buff
argument_list|)
argument_list|,
literal|1
argument_list|,
name|SCNHSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
name|pad
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* OK, now set up the filehdr... */
comment|/* Don't include the internal abs section in the section count */
comment|/*     We will NOT put a fucking timestamp in the header here. Every time you     put it back, I will come in and take it out again. I'm sorry. This     field does not belong here.  We fill it with a 0 so it compares the     same but is not a reasonable time. -- gnu@cygnus.com     */
comment|/*     Well, I like it, and now we have *customers* who have requested it,     so I'm conditionally compiling it in.      sac@cygnus.com     */
ifndef|#
directive|ifndef
name|NOCOFF_TIMESTAMP
name|internal_f
operator|.
name|f_timdat
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|internal_f
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
name|internal_f
operator|.
name|f_symptr
operator|=
name|sym_base
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_symptr
operator|=
literal|0
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_opthdr
operator|=
name|AOUTSZ
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_opthdr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hasrelocs
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_RELFLG
expr_stmt|;
if|if
condition|(
operator|!
name|haslinno
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LNNO
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_LSYMS
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_EXEC
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|xvec
operator|->
name|byteorder_big_p
condition|)
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32WR
expr_stmt|;
else|else
name|internal_f
operator|.
name|f_flags
operator||=
name|F_AR32W
expr_stmt|;
comment|/*     FIXME, should do something about the other byte orders and     architectures.     */
comment|/* Set up architecture-dependent stuff */
block|{
name|unsigned
name|int
name|magic
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|flags
init|=
literal|0
decl_stmt|;
name|coff_set_flags
argument_list|(
name|abfd
argument_list|,
operator|&
name|magic
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_magic
operator|=
name|magic
expr_stmt|;
name|internal_f
operator|.
name|f_flags
operator||=
name|flags
expr_stmt|;
comment|/* ...and the "opt"hdr... */
ifdef|#
directive|ifdef
name|A29K
ifdef|#
directive|ifdef
name|ULTRA3
comment|/* NYU's machine */
comment|/* FIXME: This is a bogus check.  I really want to see if there    * is a .shbss or a .shdata section, if so then set the magic    * number to indicate a shared data executable.    */
if|if
condition|(
name|internal_f
operator|.
name|f_nscns
operator|>=
literal|7
condition|)
name|internal_a
operator|.
name|magic
operator|=
name|SHMAGIC
expr_stmt|;
comment|/* Shared magic */
else|else
endif|#
directive|endif
comment|/* ULTRA3 */
name|internal_a
operator|.
name|magic
operator|=
name|NMAGIC
expr_stmt|;
comment|/* Assume separate i/d */
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* A29K */
ifdef|#
directive|ifdef
name|I960
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|magic
operator|==
name|I960ROMAGIC
condition|?
name|NMAGIC
else|:
name|OMAGIC
operator|)
expr_stmt|;
define|#
directive|define
name|__A_MAGIC_SET__
endif|#
directive|endif
comment|/* I960 */
if|#
directive|if
name|M88
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|PAGEMAGICBCS
expr_stmt|;
endif|#
directive|endif
comment|/* M88 */
if|#
directive|if
name|M68
operator|||
name|MIPS
operator|||
name|WE32K
define|#
directive|define
name|__A_MAGIC_SET__
comment|/* Never was anything here for the 68k */
endif|#
directive|endif
comment|/* M68 || MIPS || WE32K */
if|#
directive|if
name|I386
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
name|ZMAGIC
expr_stmt|;
endif|#
directive|endif
comment|/* I386 */
if|#
directive|if
name|RS6000COFF_C
define|#
directive|define
name|__A_MAGIC_SET__
name|internal_a
operator|.
name|magic
operator|=
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
condition|?
name|RS6K_AOUTHDR_ZMAGIC
else|:
operator|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
operator|)
condition|?
name|RS6K_AOUTHDR_NMAGIC
else|:
name|RS6K_AOUTHDR_OMAGIC
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|__A_MAGIC_SET__
include|#
directive|include
file|"Your aouthdr magic number is not being set!"
else|#
directive|else
undef|#
directive|undef
name|__A_MAGIC_SET__
endif|#
directive|endif
block|}
comment|/* Now should write relocs, strings, syms */
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym_base
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|coff_add_missing_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff_renumber_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff_mangle_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff_write_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff_write_linenumbers
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|coff_write_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NO_COFF_SYMBOLS */
if|if
condition|(
name|text_sec
condition|)
block|{
name|internal_a
operator|.
name|tsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|text_sec
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|text_start
operator|=
name|internal_a
operator|.
name|tsize
condition|?
name|text_sec
operator|->
name|vma
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data_sec
condition|)
block|{
name|internal_a
operator|.
name|dsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|data_sec
argument_list|)
expr_stmt|;
name|internal_a
operator|.
name|data_start
operator|=
name|internal_a
operator|.
name|dsize
condition|?
name|data_sec
operator|->
name|vma
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bss_sec
condition|)
block|{
name|internal_a
operator|.
name|bsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|bss_sec
argument_list|)
expr_stmt|;
block|}
name|internal_a
operator|.
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|internal_f
operator|.
name|f_nsyms
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* now write them */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|{
name|FILHDR
name|buff
decl_stmt|;
name|coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_f
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
literal|1
argument_list|,
name|FILHSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
name|AOUTHDR
name|buff
decl_stmt|;
name|coff_swap_aouthdr_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_a
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|buff
argument_list|,
literal|1
argument_list|,
name|AOUTSZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
end_ifndef

begin_comment
comment|/* this function transforms the offsets into the symbol table into pointers to syments. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_pointerize_aux
argument_list|,
operator|(
name|ignore_abfd
operator|,
name|table_base
operator|,
name|type
operator|,
name|class
operator|,
name|auxent
operator|)
argument_list|,
name|bfd
operator|*
name|ignore_abfd
name|AND
name|combined_entry_type
operator|*
name|table_base
name|AND
name|int
name|type
name|AND
name|int
name|class
name|AND
name|combined_entry_type
operator|*
name|auxent
argument_list|)
block|{
comment|/* Don't bother if this is a file or a section */
if|if
condition|(
name|class
operator|==
name|C_STAT
operator|&&
name|type
operator|==
name|T_NULL
condition|)
return|return;
if|if
condition|(
name|class
operator|==
name|C_FILE
condition|)
return|return;
comment|/* Otherwise patch up */
if|if
condition|(
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
operator|||
name|class
operator|==
name|C_BLOCK
condition|)
block|{
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|p
operator|=
name|table_base
operator|+
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_endndx
operator|.
name|l
expr_stmt|;
name|auxent
operator|->
name|fix_end
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
operator|!=
literal|0
condition|)
block|{
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
operator|=
name|table_base
operator|+
name|auxent
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_tagndx
operator|.
name|l
expr_stmt|;
name|auxent
operator|->
name|fix_tag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_SYMBOLS */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_set_section_contents
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|location
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|PTR
name|location
name|AND
name|file_ptr
name|offset
name|AND
name|bfd_size_type
name|count
argument_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
operator|==
name|false
condition|)
comment|/* set by bfd.c handler */
name|coff_compute_section_file_positions
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|bfd_write
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|==
name|count
operator|)
condition|?
name|true
else|:
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static          boolean coff_close_and_cleanup(abfd)     bfd            *abfd; {   if (!bfd_read_p(abfd))     switch (abfd->format) {     case bfd_archive:       if (!_bfd_write_archive_contents(abfd)) 	return false;       break;     case bfd_object:       if (!coff_write_object_contents(abfd)) 	return false;       break;     default:       bfd_error = invalid_operation;       return false;     }
comment|/* We depend on bfd_close to free all the memory on the obstack.  */
end_comment

begin_comment
comment|/* FIXME if bfd_release is not using obstacks! */
end_comment

begin_endif
unit|return true; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|PTR
name|buy_and_read
parameter_list|(
name|abfd
parameter_list|,
name|where
parameter_list|,
name|seek_direction
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|where
decl_stmt|;
name|int
name|seek_direction
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|area
init|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|area
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|seek_direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|area
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
return|return
operator|(
name|area
operator|)
return|;
block|}
end_function

begin_comment
comment|/* buy_and_read() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|build_string_table
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
name|string_table_size_buffer
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|string_table_size
decl_stmt|;
name|char
modifier|*
name|string_table
decl_stmt|;
comment|/* At this point we should be "seek"'d to the end of the      symbols === the symbol table size.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|string_table_size_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|string_table_size_buffer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|string_table_size
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
name|string_table_size
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|string_table_size_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|string_table
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|string_table_size
operator|-=
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on mallocation error */
if|if
condition|(
name|bfd_read
argument_list|(
name|string_table
argument_list|,
name|string_table_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|string_table_size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
name|string_table
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Allocate space for the ".debug" section, and read it.    We did not read the debug section until now, because    we didn't want to go to the trouble until someone needed it. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|build_debug_section
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|char
modifier|*
name|debug_section
decl_stmt|;
name|long
name|position
decl_stmt|;
name|asection
modifier|*
name|sect
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sect
condition|)
block|{
name|bfd_error
operator|=
name|no_debug_section
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|debug_section
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_section
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Seek to the beginning of the `.debug' section and read it.       Save the current position first; it is needed by our caller.      Then read debug section and reset the file pointer.  */
name|position
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|sect
operator|->
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|debug_section
argument_list|,
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sect
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|position
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
name|debug_section
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return a pointer to a malloc'd copy of 'name'.  'name' may not be  \0-terminated, but will not exceed 'maxlen' characters.  The copy *will*  be \0-terminated.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|DEFUN
argument_list|(
name|copy_name
argument_list|,
operator|(
name|abfd
operator|,
name|name
operator|,
name|maxlen
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|name
name|AND
name|int
name|maxlen
argument_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|maxlen
condition|;
operator|++
name|len
control|)
block|{
if|if
condition|(
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|newname
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strncpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|newname
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Read a symbol table into freshly bfd_allocated memory, swap it, and    knit the symbol names into a normalized form.  By normalized here I    mean that all symbols have an n_offset pointer that points to a null-    terminated string.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYMNAME_IN_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|SYMNAME_IN_DEBUG
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|combined_entry_type
modifier|*
name|DEFUN
argument_list|(
name|get_normalized_symtab
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|combined_entry_type
modifier|*
name|internal
decl_stmt|;
name|combined_entry_type
modifier|*
name|internal_ptr
decl_stmt|;
name|combined_entry_type
modifier|*
name|symbol_ptr
decl_stmt|;
name|combined_entry_type
modifier|*
name|internal_end
decl_stmt|;
name|SYMENT
modifier|*
name|raw
decl_stmt|;
name|SYMENT
modifier|*
name|raw_src
decl_stmt|;
name|SYMENT
modifier|*
name|raw_end
decl_stmt|;
name|char
modifier|*
name|string_table
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|debug_section
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|int
name|raw_size
decl_stmt|;
if|if
condition|(
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|!=
operator|(
name|combined_entry_type
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|size
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|combined_entry_type
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|no_symbols
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|internal
operator|=
operator|(
name|combined_entry_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|internal_end
operator|=
name|internal
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|raw_size
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
name|SYMESZ
expr_stmt|;
name|raw
operator|=
operator|(
name|SYMENT
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw
argument_list|,
name|raw_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|raw_size
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* mark the end of the symbols */
name|raw_end
operator|=
name|raw
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/*     FIXME SOMEDAY.  A string table size of zero is very weird, but     probably possible.  If one shows up, it will probably kill us.     */
comment|/* Swap all the raw entries */
for|for
control|(
name|raw_src
operator|=
name|raw
operator|,
name|internal_ptr
operator|=
name|internal
init|;
name|raw_src
operator|<
name|raw_end
condition|;
name|raw_src
operator|++
operator|,
name|internal_ptr
operator|++
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_src
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|internal_ptr
operator|->
name|u
operator|.
name|syment
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|fix_tag
operator|=
literal|0
expr_stmt|;
name|internal_ptr
operator|->
name|fix_end
operator|=
literal|0
expr_stmt|;
name|symbol_ptr
operator|=
name|internal_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|;
name|i
operator|++
control|)
block|{
name|internal_ptr
operator|++
expr_stmt|;
name|raw_src
operator|++
expr_stmt|;
name|internal_ptr
operator|->
name|fix_tag
operator|=
literal|0
expr_stmt|;
name|internal_ptr
operator|->
name|fix_end
operator|=
literal|0
expr_stmt|;
name|coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|raw_src
operator|)
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
operator|&
operator|(
name|internal_ptr
operator|->
name|u
operator|.
name|auxent
operator|)
argument_list|)
expr_stmt|;
comment|/* Remember that bal entries arn't pointerized */
if|if
condition|(
name|i
operator|!=
literal|1
operator|||
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|!=
name|C_LEAFPROC
condition|)
block|{
name|coff_pointerize_aux
argument_list|(
name|abfd
argument_list|,
name|internal
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
argument_list|,
name|symbol_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|,
name|internal_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Free all the raw stuff */
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|raw
argument_list|)
expr_stmt|;
for|for
control|(
name|internal_ptr
operator|=
name|internal
init|;
name|internal_ptr
operator|<
name|internal_end
condition|;
name|internal_ptr
operator|++
control|)
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
comment|/* make a file symbol point to the name in the auxent, since 	   the text ".file" is redundant */
if|if
condition|(
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_zeroes
operator|==
literal|0
condition|)
block|{
comment|/* the filename is a long one, point into the string table */
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
block|{
name|string_table
operator|=
name|build_string_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|string_table
operator|-
literal|4
operator|+
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_n
operator|.
name|x_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ordinary short filename, put into memory anyway */
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
name|int
operator|)
name|copy_name
argument_list|(
name|abfd
argument_list|,
operator|(
name|internal_ptr
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|.
name|x_file
operator|.
name|x_fname
argument_list|,
name|FILNMLEN
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|!=
literal|0
condition|)
block|{
comment|/* This is a "short" name.  Make it long.  */
name|unsigned
name|long
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|newstring
init|=
name|NULL
decl_stmt|;
comment|/* find the length of this string without walking into memory 	       that isn't ours.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
comment|/* if end of string */
block|}
comment|/* possible lengths of this string. */
if|if
condition|(
operator|(
name|newstring
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|++
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* on error */
name|memset
argument_list|(
name|newstring
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newstring
argument_list|,
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_name
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
operator|(
name|int
operator|)
name|newstring
expr_stmt|;
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|SYMNAME_IN_DEBUG
argument_list|(
operator|&
name|internal_ptr
operator|->
name|u
operator|.
name|syment
argument_list|)
condition|)
block|{
comment|/* Long name already.  Point symbol at the string in the table.  */
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
block|{
name|string_table
operator|=
name|build_string_table
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|string_table
operator|-
literal|4
operator|+
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Long name in debug section.  Very similar.  */
if|if
condition|(
name|debug_section
operator|==
name|NULL
condition|)
block|{
name|debug_section
operator|=
name|build_debug_section
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|=
call|(
name|int
call|)
argument_list|(
name|debug_section
operator|+
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
argument_list|)
expr_stmt|;
block|}
block|}
name|internal_ptr
operator|+=
name|internal_ptr
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
block|}
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|=
name|internal
expr_stmt|;
return|return
operator|(
name|internal
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* get_normalized_symtab() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_SYMBOLS */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sec
modifier|*
name|DEFUN
argument_list|(
name|section_from_bfd_index
argument_list|,
operator|(
name|abfd
operator|,
name|index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|index
argument_list|)
block|{
name|struct
name|sec
modifier|*
name|answer
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|N_ABS
condition|)
block|{
return|return
operator|&
name|bfd_abs_section
return|;
block|}
if|if
condition|(
name|index
operator|==
name|N_UNDEF
condition|)
block|{
return|return
operator|&
name|bfd_und_section
return|;
block|}
if|if
condition|(
name|index
operator|==
name|N_DEBUG
condition|)
block|{
return|return
operator|&
name|bfd_debug_section
return|;
block|}
while|while
condition|(
name|answer
condition|)
block|{
if|if
condition|(
name|answer
operator|->
name|target_index
operator|==
name|index
condition|)
return|return
name|answer
return|;
name|answer
operator|=
name|answer
operator|->
name|next
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|&
name|bfd_und_section
return|;
comment|/* For gcc -W and lint.  Never executed. */
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_LINENOS
end_ifndef

begin_comment
comment|/* SUBSUBSECTION  	Reading Linenumbers  	Creating the linenumber table is done by reading in the entire 	coff linenumber table, and creating another table for internal use.  	A coff line number table is structured so that each function 	is marked as having a line number of 0. Each line within the 	function is an offset from the first line in the function. The 	base of the line number information for the table is stored in 	the symbol associated with the function.   	The information is copied from the external to the internal 	table, and each symbol which marks a function is marked by 	pointing its...  	How does this work ?  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_slurp_line_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
block|{
name|LINENO
modifier|*
name|native_lineno
decl_stmt|;
name|alent
modifier|*
name|lineno_cache
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|lineno
operator|==
operator|(
name|alent
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|native_lineno
operator|=
operator|(
name|LINENO
operator|*
operator|)
name|buy_and_read
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|line_filepos
argument_list|,
name|SEEK_SET
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|LINESZ
operator|*
name|asect
operator|->
name|lineno_count
argument_list|)
argument_list|)
expr_stmt|;
name|lineno_cache
operator|=
operator|(
name|alent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|asect
operator|->
name|lineno_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|alent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineno_cache
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|alent
modifier|*
name|cache_ptr
init|=
name|lineno_cache
decl_stmt|;
name|LINENO
modifier|*
name|src
init|=
name|native_lineno
decl_stmt|;
while|while
condition|(
name|counter
operator|<
name|asect
operator|->
name|lineno_count
condition|)
block|{
name|struct
name|internal_lineno
name|dst
decl_stmt|;
name|coff_swap_lineno_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|line_number
operator|=
name|dst
operator|.
name|l_lnno
expr_stmt|;
if|if
condition|(
name|cache_ptr
operator|->
name|line_number
operator|==
literal|0
condition|)
block|{
name|coff_symbol_type
modifier|*
name|sym
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
operator|(
name|dst
operator|.
name|l_addr
operator|.
name|l_symndx
operator|+
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|)
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
decl_stmt|;
name|cache_ptr
operator|->
name|u
operator|.
name|sym
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|sym
expr_stmt|;
name|sym
operator|->
name|lineno
operator|=
name|cache_ptr
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|u
operator|.
name|offset
operator|=
name|dst
operator|.
name|l_addr
operator|.
name|l_paddr
operator|-
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
block|}
comment|/* If no linenumber expect a symbol index */
name|cache_ptr
operator|++
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|line_number
operator|=
literal|0
expr_stmt|;
block|}
name|asect
operator|->
name|lineno
operator|=
name|lineno_cache
expr_stmt|;
comment|/* FIXME, free native_lineno here, or use alloca or something. */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* coff_slurp_line_table() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_LINENOS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_LINENOS
end_ifndef

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_slurp_symbol_table
argument_list|,
operator|(
name|abfd
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|combined_entry_type
modifier|*
name|native_symbols
decl_stmt|;
name|coff_symbol_type
modifier|*
name|cached_area
decl_stmt|;
name|unsigned
name|int
modifier|*
name|table_ptr
decl_stmt|;
name|unsigned
name|int
name|number_of_symbols
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|true
return|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Read in the symbol table */
if|if
condition|(
operator|(
name|native_symbols
operator|=
name|get_normalized_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* on error */
comment|/* Allocate enough room for all the symbols in cached form */
name|cached_area
operator|=
operator|(
name|coff_symbol_type
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|coff_symbol_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_area
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* on error */
name|table_ptr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table_ptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|coff_symbol_type
modifier|*
name|dst
init|=
name|cached_area
decl_stmt|;
name|unsigned
name|int
name|last_native_index
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|this_index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|this_index
operator|<
name|last_native_index
condition|)
block|{
name|combined_entry_type
modifier|*
name|src
init|=
name|native_symbols
operator|+
name|this_index
decl_stmt|;
name|table_ptr
index|[
name|this_index
index|]
operator|=
name|number_of_symbols
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|)
expr_stmt|;
comment|/* 	We use the native name field to point to the cached field 	*/
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|=
operator|(
name|int
operator|)
name|dst
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
name|section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|done_lineno
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
condition|)
block|{
ifdef|#
directive|ifdef
name|I960
case|case
name|C_LEAFEXT
case|:
if|#
directive|if
literal|0
block|dst->symbol.value = src->u.syment.n_value - dst->symbol.section->vma; 	dst->symbol.flags = BSF_EXPORT | BSF_GLOBAL; 	dst->symbol.flags |= BSF_NOT_AT_END;
endif|#
directive|endif
comment|/* Fall through to next case */
endif|#
directive|endif
case|case
name|C_EXT
case|:
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_HIDEXT
case|:
endif|#
directive|endif
if|if
condition|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
operator|==
literal|0
condition|)
block|{
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_und_section
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|symbol
operator|.
name|section
operator|=
operator|&
name|bfd_com_section
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	    Base the value as an index from the base of the 	    section 	    */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_type
operator|)
argument_list|)
condition|)
block|{
comment|/* 	      A function ext does not go at the end of a file 	      */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_NOT_AT_END
expr_stmt|;
block|}
block|}
break|break;
case|case
name|C_STAT
case|:
comment|/* static			 */
ifdef|#
directive|ifdef
name|I960
case|case
name|C_LEAFSTAT
case|:
comment|/* static leaf procedure        */
endif|#
directive|endif
case|case
name|C_LABEL
case|:
comment|/* label			 */
if|if
condition|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_scnum
operator|==
operator|-
literal|2
condition|)
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
else|else
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
comment|/* 	  Base the value as an index from the base of the section, if 	  there is one 	  */
if|if
condition|(
name|dst
operator|->
name|symbol
operator|.
name|section
condition|)
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
else|else
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
case|case
name|C_MOS
case|:
comment|/* member of structure	 */
case|case
name|C_EOS
case|:
comment|/* end of structure		 */
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* C_AUTOARG has the same value */
ifdef|#
directive|ifdef
name|C_GLBLREG
case|case
name|C_GLBLREG
case|:
comment|/* A29k-specific storage class */
endif|#
directive|endif
endif|#
directive|endif
case|case
name|C_REGPARM
case|:
comment|/* register parameter		 */
case|case
name|C_REG
case|:
comment|/* register variable		 */
ifdef|#
directive|ifdef
name|C_AUTOARG
case|case
name|C_AUTOARG
case|:
comment|/* 960-specific storage class */
endif|#
directive|endif
case|case
name|C_TPDEF
case|:
comment|/* type definition		 */
case|case
name|C_ARG
case|:
case|case
name|C_AUTO
case|:
comment|/* automatic variable */
case|case
name|C_FIELD
case|:
comment|/* bit field */
case|case
name|C_ENTAG
case|:
comment|/* enumeration tag		 */
case|case
name|C_MOE
case|:
comment|/* member of enumeration	 */
case|case
name|C_MOU
case|:
comment|/* member of union		 */
case|case
name|C_UNTAG
case|:
comment|/* union tag			 */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
case|case
name|C_FILE
case|:
comment|/* file name			 */
case|case
name|C_STRTAG
case|:
comment|/* structure tag		 */
ifdef|#
directive|ifdef
name|RS6000COFF_C
case|case
name|C_BINCL
case|:
comment|/* beginning of include file     */
case|case
name|C_EINCL
case|:
comment|/* ending of include file        */
case|case
name|C_GSYM
case|:
case|case
name|C_LSYM
case|:
case|case
name|C_PSYM
case|:
case|case
name|C_RSYM
case|:
case|case
name|C_RPSYM
case|:
case|case
name|C_STSYM
case|:
case|case
name|C_DECL
case|:
case|case
name|C_ENTRY
case|:
case|case
name|C_FUN
case|:
case|case
name|C_BSTAT
case|:
case|case
name|C_ESTAT
case|:
endif|#
directive|endif
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
case|case
name|C_BLOCK
case|:
comment|/* ".bb" or ".eb"		 */
case|case
name|C_FCN
case|:
comment|/* ".bf" or ".ef"		 */
case|case
name|C_EFCN
case|:
comment|/* physical end of function	 */
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
comment|/* 	  Base the value as an index from the base of the section 	  */
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
operator|-
name|dst
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|C_NULL
case|:
case|case
name|C_EXTDEF
case|:
comment|/* external definition		 */
case|case
name|C_ULABEL
case|:
comment|/* undefined label		 */
case|case
name|C_USTATIC
case|:
comment|/* undefined static		 */
case|case
name|C_LINE
case|:
comment|/* line # reformatted as symbol table entry */
case|case
name|C_ALIAS
case|:
comment|/* duplicate tag		 */
case|case
name|C_HIDDEN
case|:
comment|/* ext symbol in dmert public lib */
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized storage class %d\n"
argument_list|,
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
argument_list|)
expr_stmt|;
comment|/*	abort();*/
name|dst
operator|->
name|symbol
operator|.
name|flags
operator|=
name|BSF_DEBUGGING
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|value
operator|=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_value
operator|)
expr_stmt|;
break|break;
block|}
comment|/*      BFD_ASSERT(dst->symbol.flags != 0);*/
name|dst
operator|->
name|native
operator|=
name|src
expr_stmt|;
name|dst
operator|->
name|symbol
operator|.
name|udata
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|lineno
operator|=
operator|(
name|alent
operator|*
operator|)
name|NULL
expr_stmt|;
name|this_index
operator|+=
operator|(
name|src
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
operator|)
operator|+
literal|1
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|number_of_symbols
operator|++
expr_stmt|;
block|}
comment|/* walk the native symtab */
block|}
comment|/* bfdize the native symtab */
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|cached_area
expr_stmt|;
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|=
name|native_symbols
expr_stmt|;
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|number_of_symbols
expr_stmt|;
name|obj_convert
argument_list|(
name|abfd
argument_list|)
operator|=
name|table_ptr
expr_stmt|;
comment|/* Slurp the line tables for each section too */
block|{
name|asection
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|coff_slurp_line_table
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* coff_slurp_symbol_table() */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|coff_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|coff_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_get_symtab
argument_list|,
operator|(
name|abfd
operator|,
name|alocation
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asymbol
operator|*
operator|*
name|alocation
argument_list|)
block|{
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|coff_symbol_type
modifier|*
name|symbase
decl_stmt|;
name|coff_symbol_type
modifier|*
modifier|*
name|location
init|=
operator|(
name|coff_symbol_type
operator|*
operator|*
operator|)
operator|(
name|alocation
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|0
return|;
name|symbase
operator|=
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
while|while
condition|(
name|counter
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* This nasty code looks at the symbol to decide whether or 	   not it is descibes a constructor/destructor entry point. It 	   is structured this way to (hopefully) speed non matches */
if|#
directive|if
literal|0
block|if (0&& symbase->symbol.name[9] == '$')  	{ 	    bfd_constructor_entry(abfd,  				 (asymbol **)location, 				  symbase->symbol.name[10] == 'I' ? 				  "CTOR" : "DTOR"); 	}
endif|#
directive|endif
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
name|symbase
operator|++
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
operator|*
name|location
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_SYMBOLS */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|coff_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* SUBSUBSECTION  	Reading Relocations  	Coff relocations are easily transformed into the internal BFD form 	(@code{arelent}).  	Reading a coff relocation table is done in the following stages:  	o The entire coff relocation table is read into memory.  	o Each relocation is processed in turn, first it is swapped from the 	external to the internal form.  	o The symbol referenced in the relocation's symbol index is 	turned intoa pointer into the canonical symbol table. Note 	that this table is the same as the one returned by a call to 	@code{bfd_canonicalize_symtab}. The back end will call the 	routine and save the result if a canonicalization hasn't been done.  	o The reloc index is turned into a pointer to a howto 	structure, in a back end specific way. For instance, the 386 	and 960 use the @code{r_type} to directly produce an index 	into a howto table vector; the 88k subtracts a number from the 	@code{r_type} field and creates an addend field.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CALC_ADDEND
end_ifndef

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|if (ptr&& ptr->the_bfd == abfd		\&& ((ptr->flags& BSF_OLD_COMMON)== 0))	\ 	    {						\ 		cache_ptr->addend = -(ptr->section->vma + ptr->value);	\ 	    }						\ 	    else {					\ 		cache_ptr->addend = 0;			\ 	    }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_slurp_reloc_table
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
name|RELOC
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
name|true
return|;
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
if|if
condition|(
operator|!
name|coff_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
endif|#
directive|endif
name|native_relocs
operator|=
operator|(
name|RELOC
operator|*
operator|)
name|buy_and_read
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|RELSZ
operator|*
name|asect
operator|->
name|reloc_count
argument_list|)
argument_list|)
expr_stmt|;
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|asect
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_cache
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|asect
operator|->
name|reloc_count
condition|;
name|idx
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RELOC_PROCESSING
name|struct
name|internal_reloc
name|dst
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|src
decl_stmt|;
name|cache_ptr
operator|=
name|reloc_cache
operator|+
name|idx
expr_stmt|;
name|src
operator|=
name|native_relocs
operator|+
name|idx
expr_stmt|;
name|bfd_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|RELOC_PROCESSING
argument_list|(
name|cache_ptr
argument_list|,
operator|&
name|dst
argument_list|,
name|symbols
argument_list|,
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|internal_reloc
name|dst
decl_stmt|;
name|asymbol
modifier|*
name|ptr
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|src
decl_stmt|;
name|cache_ptr
operator|=
name|reloc_cache
operator|+
name|idx
expr_stmt|;
name|src
operator|=
name|native_relocs
operator|+
name|idx
expr_stmt|;
name|bfd_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
name|dst
operator|.
name|r_vaddr
expr_stmt|;
if|if
condition|(
name|dst
operator|.
name|r_symndx
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* @@ Should never be greater than count of symbols!  */
if|if
condition|(
name|dst
operator|.
name|r_symndx
operator|>=
name|obj_conv_table_size
argument_list|(
name|abfd
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|obj_convert
argument_list|(
name|abfd
argument_list|)
index|[
name|dst
operator|.
name|r_symndx
index|]
expr_stmt|;
name|ptr
operator|=
operator|*
operator|(
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section
operator|.
name|symbol_ptr_ptr
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	The symbols definitions that we have read in have been 	relocated as if their sections started at 0. But the offsets 	refering to the symbols in the raw data have not been 	modified, so we have to have a negative addend to compensate. 	 	Note that symbols which used to be common must be left alone */
comment|/* Calculate any reloc addend by looking at the symbol */
name|CALC_ADDEND
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|,
name|dst
argument_list|,
name|cache_ptr
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|address
operator|-=
name|asect
operator|->
name|vma
expr_stmt|;
comment|/* !!     cache_ptr->section = (asection *) NULL;*/
comment|/* Fill in the cache_ptr->howto field from dst.r_type */
name|RTYPE2HOWTO
argument_list|(
name|cache_ptr
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This is stupid.  This function should be a boolean predicate */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|coff_canonicalize_reloc
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|relptr
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|section
name|AND
name|arelent
operator|*
operator|*
name|relptr
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
comment|/* this section has relocs made up by us, they are not in the        file, so take them out of their chain and place them into        the data area provided */
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|coff_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
if|if
condition|(
operator|!
name|tblptr
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COFF_SYMBOLS
end_ifndef

begin_comment
comment|/* provided a BFD, a section and an offset into the section, calculate and return the name of the source file and the line nearest to the wanted location. */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|coff_find_nearest_line
argument_list|,
operator|(
name|abfd
operator|,
name|section
operator|,
name|ignore_symbols
operator|,
name|offset
operator|,
name|filename_ptr
operator|,
name|functionname_ptr
operator|,
name|line_ptr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|section
name|AND
name|asymbol
operator|*
operator|*
name|ignore_symbols
name|AND
name|bfd_vma
name|offset
name|AND
name|CONST
name|char
operator|*
operator|*
name|filename_ptr
name|AND
name|CONST
name|char
operator|*
operator|*
name|functionname_ptr
name|AND
name|unsigned
name|int
operator|*
name|line_ptr
argument_list|)
block|{
specifier|static
name|bfd
modifier|*
name|cache_abfd
decl_stmt|;
specifier|static
name|asection
modifier|*
name|cache_section
decl_stmt|;
specifier|static
name|bfd_vma
name|cache_offset
decl_stmt|;
specifier|static
name|unsigned
name|int
name|cache_i
decl_stmt|;
specifier|static
name|alent
modifier|*
name|cache_l
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|coff_data_type
modifier|*
name|cof
init|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Run through the raw syments if available */
name|combined_entry_type
modifier|*
name|p
decl_stmt|;
name|alent
modifier|*
name|l
decl_stmt|;
name|unsigned
name|int
name|line_base
init|=
literal|0
decl_stmt|;
operator|*
name|filename_ptr
operator|=
literal|0
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
literal|0
expr_stmt|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
comment|/* Don't try and find line numbers in a non coff file */
if|if
condition|(
name|abfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_coff_flavour
condition|)
return|return
name|false
return|;
if|if
condition|(
name|cof
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|p
operator|=
name|cof
operator|->
name|raw_syments
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cof
operator|->
name|raw_syment_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_FILE
condition|)
block|{
comment|/* File name has been moved into symbol */
operator|*
name|filename_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
break|break;
block|}
name|p
operator|+=
literal|1
operator|+
name|p
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
block|}
comment|/* Now wander though the raw linenumbers of the section */
comment|/*     If this is the same BFD as we were previously called with and this is     the same section, and the offset we want is further down then we can     prime the lookup loop     */
if|if
condition|(
name|abfd
operator|==
name|cache_abfd
operator|&&
name|section
operator|==
name|cache_section
operator|&&
name|offset
operator|>=
name|cache_offset
condition|)
block|{
name|i
operator|=
name|cache_i
expr_stmt|;
name|l
operator|=
name|cache_l
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|section
operator|->
name|lineno
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|section
operator|->
name|lineno_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|->
name|line_number
operator|==
literal|0
condition|)
block|{
comment|/* Get the symbol this line number points at */
name|coff_symbol_type
modifier|*
name|coff
init|=
operator|(
name|coff_symbol_type
operator|*
operator|)
operator|(
name|l
operator|->
name|u
operator|.
name|sym
operator|)
decl_stmt|;
operator|*
name|functionname_ptr
operator|=
name|coff
operator|->
name|symbol
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|coff
operator|->
name|native
condition|)
block|{
name|combined_entry_type
modifier|*
name|s
init|=
name|coff
operator|->
name|native
decl_stmt|;
name|s
operator|=
name|s
operator|+
literal|1
operator|+
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
expr_stmt|;
comment|/* 	  S should now point to the .bf of the function 	  */
if|if
condition|(
name|s
operator|->
name|u
operator|.
name|syment
operator|.
name|n_numaux
condition|)
block|{
comment|/* 	    The linenumber is stored in the auxent 	    */
name|union
name|internal_auxent
modifier|*
name|a
init|=
operator|&
operator|(
operator|(
name|s
operator|+
literal|1
operator|)
operator|->
name|u
operator|.
name|auxent
operator|)
decl_stmt|;
name|line_base
operator|=
name|a
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|l
operator|->
name|u
operator|.
name|offset
operator|>
name|offset
condition|)
break|break;
operator|*
name|line_ptr
operator|=
name|l
operator|->
name|line_number
operator|+
name|line_base
operator|+
literal|1
expr_stmt|;
block|}
name|l
operator|++
expr_stmt|;
block|}
name|cache_abfd
operator|=
name|abfd
expr_stmt|;
name|cache_section
operator|=
name|section
expr_stmt|;
name|cache_offset
operator|=
name|offset
expr_stmt|;
name|cache_i
operator|=
name|i
expr_stmt|;
name|cache_l
operator|=
name|l
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GNU960
end_ifdef

begin_function
name|file_ptr
name|coff_sym_filepos
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_COFF_SYMBOLS */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|coff_sizeof_headers
argument_list|,
operator|(
name|abfd
operator|,
name|reloc
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|boolean
name|reloc
argument_list|)
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|reloc
operator|==
name|false
condition|)
block|{
name|size
operator|=
name|FILHSZ
operator|+
name|AOUTSZ
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|FILHSZ
expr_stmt|;
block|}
name|size
operator|+=
name|abfd
operator|->
name|section_count
operator|*
name|SCNHSZ
expr_stmt|;
return|return
name|size
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|DEFUN
argument_list|(
name|get_value
argument_list|,
operator|(
name|reloc
operator|,
name|seclet
operator|)
argument_list|,
name|arelent
operator|*
name|reloc
name|AND
name|bfd_seclet_type
operator|*
name|seclet
argument_list|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|asymbol
modifier|*
name|symbol
init|=
operator|*
operator|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
comment|/* A symbol holds a pointer to a section, and an offset from the      base of the section.  To relocate, we find where the section will      live in the output and add that in */
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
comment|/* Ouch, this is an undefined symbol.. */
name|bfd_error_vector
operator|.
name|undefined_symbol
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
expr_stmt|;
name|value
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* Add the value contained in the relocation */
name|value
operator|+=
call|(
name|short
call|)
argument_list|(
operator|(
name|reloc
operator|->
name|addend
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|perform_slip
argument_list|,
operator|(
name|s
operator|,
name|slip
operator|,
name|input_section
operator|,
name|value
operator|)
argument_list|,
name|asymbol
operator|*
operator|*
name|s
name|AND
name|unsigned
name|int
name|slip
name|AND
name|asection
operator|*
name|input_section
name|AND
name|bfd_vma
name|value
argument_list|)
block|{
comment|/* Find all symbols past this point, and make them know      what's happened */
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|input_section
condition|)
block|{
comment|/* This was pointing into this section, so mangle it */
if|if
condition|(
name|p
operator|->
name|value
operator|>
name|value
condition|)
block|{
name|p
operator|->
name|value
operator|-=
name|slip
expr_stmt|;
block|}
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|movb1
argument_list|,
operator|(
name|input_section
operator|,
name|symbols
operator|,
name|r
operator|,
name|shrink
operator|)
argument_list|,
name|asection
operator|*
name|input_section
name|AND
name|asymbol
operator|*
operator|*
name|symbols
name|AND
name|arelent
operator|*
name|r
name|AND
name|unsigned
name|int
name|shrink
argument_list|)
block|{
name|bfd_vma
name|value
init|=
name|get_value
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0xff00
condition|)
block|{
comment|/* Change the reloc type from 16bit, possible 8 to 8bit        possible 16 */
name|r
operator|->
name|howto
operator|=
name|r
operator|->
name|howto
operator|+
literal|1
expr_stmt|;
comment|/* The place to relc moves back by one */
name|r
operator|->
name|address
operator|-=
literal|1
expr_stmt|;
comment|/* This will be two bytes smaller in the long run */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|perform_slip
argument_list|(
name|symbols
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|r
operator|->
name|address
operator|-
name|shrink
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|shrink
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|jmp1
argument_list|,
operator|(
name|input_section
operator|,
name|symbols
operator|,
name|r
operator|,
name|shrink
operator|)
argument_list|,
name|asection
operator|*
name|input_section
name|AND
name|asymbol
operator|*
operator|*
name|symbols
name|AND
name|arelent
operator|*
name|r
name|AND
name|unsigned
name|int
name|shrink
argument_list|)
block|{
name|bfd_vma
name|value
init|=
name|get_value
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bfd_vma
name|dot
init|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|r
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|gap
decl_stmt|;
comment|/* See if the address we're looking at within 127 bytes of where      we are, if so then we can use a small branch rather than the      jump we were going to */
name|gap
operator|=
name|value
operator|-
operator|(
name|dot
operator|-
name|shrink
operator|)
expr_stmt|;
if|if
condition|(
operator|-
literal|120
operator|<
operator|(
name|long
operator|)
name|gap
operator|&&
operator|(
name|long
operator|)
name|gap
operator|<
literal|120
condition|)
block|{
comment|/* Change the reloc type from 16bit, possible 8 to 8bit        possible 16 */
name|r
operator|->
name|howto
operator|=
name|r
operator|->
name|howto
operator|+
literal|1
expr_stmt|;
comment|/* The place to relc moves back by one */
name|r
operator|->
name|address
operator|-=
literal|1
expr_stmt|;
comment|/* This will be two bytes smaller in the long run */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|perform_slip
argument_list|(
name|symbols
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|r
operator|->
name|address
operator|-
name|shrink
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|shrink
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|DEFUN
argument_list|(
name|bfd_coff_relax_section
argument_list|,
operator|(
name|abfd
operator|,
name|i
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|asection
operator|*
name|i
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|i
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|i
decl_stmt|;
name|int
name|shrink
init|=
literal|0
decl_stmt|;
name|boolean
name|new
init|=
name|false
decl_stmt|;
name|bfd_size_type
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_xmalloc
argument_list|(
name|reloc_size
argument_list|)
decl_stmt|;
comment|/* Get the relocs and think about them */
if|if
condition|(
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
condition|;
name|parent
operator|++
control|)
block|{
name|arelent
modifier|*
name|r
init|=
operator|*
name|parent
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_MOVB2
case|:
case|case
name|R_JMP2
case|:
name|shrink
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|R_MOVB1
case|:
name|shrink
operator|=
name|movb1
argument_list|(
name|input_section
argument_list|,
name|symbols
argument_list|,
name|r
argument_list|,
name|shrink
argument_list|)
expr_stmt|;
name|new
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|R_JMP1
case|:
name|shrink
operator|=
name|jmp1
argument_list|(
name|input_section
argument_list|,
name|symbols
argument_list|,
name|r
argument_list|,
name|shrink
argument_list|)
expr_stmt|;
name|new
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
name|input_section
operator|->
name|_cooked_size
operator|-=
name|shrink
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|DEFUN
argument_list|(
name|bfd_coff_get_relocated_section_contents
argument_list|,
operator|(
name|in_abfd
operator|,
name|seclet
operator|,
name|data
operator|)
argument_list|,
name|bfd
operator|*
name|in_abfd
name|AND
name|bfd_seclet_type
operator|*
name|seclet
name|AND
name|bfd_byte
operator|*
name|data
argument_list|)
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd_size_type
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_xmalloc
argument_list|(
name|reloc_size
argument_list|)
decl_stmt|;
comment|/* read in the section */
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|symbols
argument_list|)
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
init|=
name|reloc_vector
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|unsigned
name|int
name|dst_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|src_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|run
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
comment|/* Find how long a run we can do */
while|while
condition|(
name|dst_address
operator|<
name|seclet
operator|->
name|size
condition|)
block|{
name|reloc
operator|=
operator|*
name|parent
expr_stmt|;
if|if
condition|(
name|reloc
condition|)
block|{
comment|/* Note that the relaxing didn't tie up the addresses in the 	   relocation, so we use the original address to work out the 	   run of non-relocated data */
name|run
operator|=
name|reloc
operator|->
name|address
operator|-
name|src_address
expr_stmt|;
name|parent
operator|++
expr_stmt|;
block|}
else|else
block|{
name|run
operator|=
name|seclet
operator|->
name|size
operator|-
name|dst_address
expr_stmt|;
block|}
comment|/* Copy the bytes */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|run
condition|;
name|idx
operator|++
control|)
block|{
name|data
index|[
name|dst_address
operator|++
index|]
operator|=
name|data
index|[
name|src_address
operator|++
index|]
expr_stmt|;
block|}
comment|/* Now do the relocation */
if|if
condition|(
name|reloc
condition|)
block|{
switch|switch
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_JMP2
case|:
comment|/* Speciial relaxed type */
block|{
name|bfd_vma
name|dot
init|=
name|seclet
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
name|int
name|gap
init|=
name|get_value
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
operator|-
name|dot
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|gap
operator|&
operator|~
literal|0xff
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|gap
operator|&
literal|0xff00
operator|)
operator|!=
literal|0xff00
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bfd_put_8
argument_list|(
name|in_abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|0x5e
case|:
comment|/* jsr -> bsr */
name|bfd_put_8
argument_list|(
name|in_abfd
argument_list|,
literal|0x55
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5a
case|:
comment|/* jmp ->bra */
name|bfd_put_8
argument_list|(
name|in_abfd
argument_list|,
literal|0x40
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|dst_address
operator|++
expr_stmt|;
name|src_address
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
case|case
name|R_MOVB2
case|:
comment|/* Special relaxed type, there will be a gap between where we 	     get stuff from and where we put stuff to now  	      	     for a mov.b @aa:16 -> mov.b @aa:8 	     opcode 0x6a 0x0y offset 	     ->     0x2y off 	     */
if|if
condition|(
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
operator|!=
literal|0x6a
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|data
index|[
name|src_address
index|]
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* Src is memory */
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
operator|=
operator|(
name|data
index|[
name|src_address
index|]
operator|&
literal|0xf
operator|)
operator||
literal|0x20
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
comment|/* Src is reg */
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
operator|=
operator|(
name|data
index|[
name|src_address
index|]
operator|&
literal|0xf
operator|)
operator||
literal|0x30
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* the offset must fit ! after all, what was all the relaxing 	     about ? */
name|bfd_put_8
argument_list|(
name|in_abfd
argument_list|,
name|get_value
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
comment|/* Note the magic - src goes up by two bytes, but dst by only 	     one */
name|dst_address
operator|+=
literal|1
expr_stmt|;
name|src_address
operator|+=
literal|3
expr_stmt|;
break|break;
comment|/* PCrel 8 bits */
case|case
name|R_PCRBYTE
case|:
block|{
name|bfd_vma
name|dot
init|=
name|seclet
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|seclet
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
decl_stmt|;
name|int
name|gap
init|=
name|get_value
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
operator|-
name|dot
decl_stmt|;
if|if
condition|(
name|gap
operator|>
literal|127
operator|||
name|gap
operator|<
operator|-
literal|128
condition|)
block|{
name|bfd_error_vector
operator|.
name|reloc_value_truncated
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
expr_stmt|;
block|}
name|bfd_put_8
argument_list|(
name|in_abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|++
expr_stmt|;
name|src_address
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|R_RELBYTE
case|:
block|{
name|unsigned
name|int
name|gap
init|=
name|get_value
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
decl_stmt|;
if|if
condition|(
name|gap
operator|>
literal|0xff
operator|&&
name|gap
operator|<
operator|~
literal|0xff
condition|)
block|{
name|bfd_error_vector
operator|.
name|reloc_value_truncated
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
expr_stmt|;
block|}
name|bfd_put_8
argument_list|(
name|in_abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|1
expr_stmt|;
name|src_address
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_JMP1
case|:
comment|/* A relword which would have like to have been a pcrel */
case|case
name|R_MOVB1
case|:
comment|/* A relword which would like to have been modified but 	     didn't make it */
case|case
name|R_RELWORD
case|:
name|bfd_put_16
argument_list|(
name|in_abfd
argument_list|,
name|get_value
argument_list|(
name|reloc
argument_list|,
name|seclet
argument_list|)
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|2
expr_stmt|;
name|src_address
operator|+=
literal|2
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EXTRA_CASES
name|EXTRA_CASES
else|#
directive|else
default|default:
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|coff_core_file_failing_command
value|_bfd_dummy_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|coff_core_file_failing_signal
value|_bfd_dummy_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|coff_core_file_matches_executable_p
value|_bfd_dummy_core_file_matches_executable_p
end_define

begin_define
define|#
directive|define
name|coff_slurp_armap
value|bfd_slurp_coff_armap
end_define

begin_define
define|#
directive|define
name|coff_slurp_extended_name_table
value|_bfd_slurp_extended_name_table
end_define

begin_define
define|#
directive|define
name|coff_truncate_arname
value|bfd_dont_truncate_arname
end_define

begin_define
define|#
directive|define
name|coff_openr_next_archived_file
value|bfd_generic_openr_next_archived_file
end_define

begin_define
define|#
directive|define
name|coff_generic_stat_arch_elt
value|bfd_generic_stat_arch_elt
end_define

begin_define
define|#
directive|define
name|coff_get_section_contents
value|bfd_generic_get_section_contents
end_define

begin_define
define|#
directive|define
name|coff_close_and_cleanup
value|bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|coff_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|coff_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|coff_bfd_debug_info_accumulate
value|(PROTO(void,(*),(bfd*, struct sec *))) bfd_void
end_define

begin_define
define|#
directive|define
name|coff_bfd_get_relocated_section_contents
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|coff_bfd_relax_section
value|bfd_generic_relax_section
end_define

end_unit

