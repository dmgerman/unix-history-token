begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for archive files (libraries).    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Written by Cygnus Support.  Mostly Gumby Henkel-Wallace's fault.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* @setfilename archive-info SECTION 	Archives  DESCRIPTION 	Archives are supported in BFD in<<archive.c>>.  	An archive (or library) is just another BFD.  It has a symbol 	table, although there's not much a user program will do with it.  	The big difference between an archive BFD and an ordinary BFD 	is that the archive doesn't have sections.  Instead it has a 	chain of BFDs considered its contents.  These BFDs can be 	manipulated just like any other.  The BFDs contained in an 	archive opened for reading will all be opened for reading; you 	may put either input or output BFDs into an archive opened for 	output; it will be handled correctly when the archive is closed.  	Use<<bfd_openr_next_archived_file>> to step through all 	the contents of an archive opened for input.  It's not 	required that you read the entire archive if you don't want 	to!  Read it until you find what you want.  	Archive contents of output BFDs are chained through the<<next>> pointer in a BFD.  The first one is findable through 	the<<archive_head>> slot of the archive.  Set it with<<set_archive_head>> (q.v.).  A given BFD may be in only one 	open output archive at a time.  	As expected, the BFD archive code is more general than the 	archive code of any given environment.  BFD archives may 	contain files of different formats (eg a.out and coff) and 	even different architectures.  You may even place archives 	recursively into archives!  	This can cause unexpected confusion, since some archive 	formats are more expressive than others.  For instance intel 	COFF archives can preserve long filenames; Sun a.out archives 	cannot.  If you move a file from the first to the second 	format and back again, the filename may be truncated. 	Likewise, different a.out environments have different 	conventions as to how they truncate filenames, whether they 	preserve directory names in filenames, etc.  When 	interoperating with native tools, be sure your files are 	homogeneous.  	Beware: most of these formats do not react well to the 	presence of spaces in filenames.  We do the best we can, but 	can't always handle this due to restrctions in the format of 	archives.  Many unix utilities are braindead in regards to 	spaces and such in filenames anyway, so this shouldn't be much 	of a restriction. */
end_comment

begin_comment
comment|/* Assumes:    o - all archive elements start on an even boundary, newline padded;    o - all arch headers are char *;    o - all arch headers are the same size (across architectures). */
end_comment

begin_comment
comment|/* Some formats provide a way to cram a long filename into the short    (16 chars) space provided by a bsd archive.  The trick is: make a    special "file" in the front of the archive, sort of like the SYMDEF    entry.  If the filename is too long to fit, put it in the extended    name table, and use its index as the filename.  To prevent    confusion prepend the index with a space.  This means you can't    have filenames that start with a space, but then again, many unix    utilities can't handle that anyway.     This scheme unfortunately requires that you stand on your head in    order to write an archive since you need to put a magic file at the    front, and need to touch every entry to do so.  C'est la vie. */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"aout/ranlib.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GNU960
end_ifdef

begin_define
define|#
directive|define
name|BFD_GNU960_ARMAG
parameter_list|(
name|abfd
parameter_list|)
value|(BFD_COFF_FILE_P((abfd)) ? ARMAG : ARMAGB)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We keep a cache of archive filepointers to archive elements to    speed up searching the archive by filepos.  We only add an entry to    the cache when we actually read one.  We also don't sort the cache;    it's generally short enough to search linearly.    Note that the pointers here point to the front of the ar_hdr, not    to the front of the contents! */
end_comment

begin_struct
struct|struct
name|ar_cache
block|{
name|file_ptr
name|ptr
decl_stmt|;
name|bfd
modifier|*
name|arelt
decl_stmt|;
name|struct
name|ar_cache
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ar_padchar
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->ar_pad_char)
end_define

begin_define
define|#
directive|define
name|ar_maxnamelen
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->xvec->ar_max_namelen)
end_define

begin_define
define|#
directive|define
name|arch_hdr
parameter_list|(
name|bfd
parameter_list|)
value|((struct ar_hdr *)   \ 		       (((struct areltdata *)((bfd)->arelt_data))->arch_header))
end_define

begin_escape
end_escape

begin_function
name|boolean
name|_bfd_generic_mkarchive
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_next_mapent  SYNOPSIS 	symindex bfd_get_next_mapent(bfd *, symindex previous, carsym ** sym);  DESCRIPTION 	This function steps through an archive's symbol table (if it 	has one).  Successively updates<<sym>> with the next symbol's 	information, returning that symbol's (internal) index into the 	symbol table.  	Supply BFD_NO_MORE_SYMBOLS as the<<previous>> entry to get 	the first one; returns BFD_NO_MORE_SYMBOLS when you're already 	got the last one.  	A<<carsym>> is a canonical archive symbol.  The only 	user-visible element is its name, a null-terminated string. */
end_comment

begin_decl_stmt
name|symindex
name|DEFUN
argument_list|(
name|bfd_get_next_mapent
argument_list|,
operator|(
name|abfd
operator|,
name|prev
operator|,
name|entry
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|symindex
name|prev
name|AND
name|carsym
operator|*
operator|*
name|entry
argument_list|)
block|{
if|if
condition|(
operator|!
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|BFD_NO_MORE_SYMBOLS
return|;
block|}
if|if
condition|(
name|prev
operator|==
name|BFD_NO_MORE_SYMBOLS
condition|)
name|prev
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|prev
operator|>=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdef_count
condition|)
return|return
name|BFD_NO_MORE_SYMBOLS
return|;
operator|*
name|entry
operator|=
operator|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|+
name|prev
operator|)
expr_stmt|;
return|return
name|prev
return|;
block|}
end_decl_stmt

begin_comment
comment|/* To be called by backends only */
end_comment

begin_function
name|bfd
modifier|*
name|_bfd_create_empty_archive_element_shell
parameter_list|(
name|obfd
parameter_list|)
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|nbfd
operator|=
name|new_bfd_contained_in
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|nbfd
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_archive_head  SYNOPSIS 	boolean bfd_set_archive_head(bfd *output, bfd *new_head);  DESCRIPTION 	Used whilst processing archives. Sets the head of the chain of 	BFDs contained in an archive to @var{new_head}.  */
end_comment

begin_decl_stmt
name|boolean
name|DEFUN
argument_list|(
name|bfd_set_archive_head
argument_list|,
operator|(
name|output_archive
operator|,
name|new_head
operator|)
argument_list|,
name|bfd
operator|*
name|output_archive
name|AND
name|bfd
operator|*
name|new_head
argument_list|)
block|{
name|output_archive
operator|->
name|archive_head
operator|=
name|new_head
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_function
name|bfd
modifier|*
name|look_for_bfd_in_cache
parameter_list|(
name|arch_bfd
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|arch_bfd
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|struct
name|ar_cache
modifier|*
name|current
decl_stmt|;
for|for
control|(
name|current
operator|=
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
if|if
condition|(
name|current
operator|->
name|ptr
operator|==
name|filepos
condition|)
return|return
name|current
operator|->
name|arelt
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Kind of stupid to call cons for each one, but we don't do too many */
end_comment

begin_function
name|boolean
name|add_bfd_to_cache
parameter_list|(
name|arch_bfd
parameter_list|,
name|filepos
parameter_list|,
name|new_elt
parameter_list|)
name|bfd
modifier|*
name|arch_bfd
decl_stmt|,
decl|*
name|new_elt
decl_stmt|;
end_function

begin_decl_stmt
name|file_ptr
name|filepos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ar_cache
modifier|*
name|new_cache
init|=
operator|(
expr|struct
name|ar_cache
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|arch_bfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_cache
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_cache
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
name|new_cache
operator|->
name|ptr
operator|=
name|filepos
expr_stmt|;
name|new_cache
operator|->
name|arelt
operator|=
name|new_elt
expr_stmt|;
name|new_cache
operator|->
name|next
operator|=
operator|(
expr|struct
name|ar_cache
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
operator|==
name|NULL
condition|)
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
operator|=
name|new_cache
expr_stmt|;
else|else
block|{
name|struct
name|ar_cache
modifier|*
name|current
init|=
name|bfd_ardata
argument_list|(
name|arch_bfd
argument_list|)
operator|->
name|cache
decl_stmt|;
for|for
control|(
init|;
name|current
operator|->
name|next
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
empty_stmt|;
name|current
operator|->
name|next
operator|=
name|new_cache
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The name begins with space.  Hence the rest of the name is an index into    the string table. */
end_comment

begin_function
name|char
modifier|*
name|get_extended_arelt_filename
parameter_list|(
name|arch
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|long
name|index
init|=
literal|0
decl_stmt|;
comment|/* Should extract string so that I can guarantee not to overflow into      the next region, but I"m too lazy. */
name|errno
operator|=
literal|0
expr_stmt|;
name|index
operator|=
name|strtol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|bfd_ardata
argument_list|(
name|arch
argument_list|)
operator|->
name|extended_names
operator|+
name|index
return|;
block|}
end_function

begin_comment
comment|/* This functions reads an arch header and returns an areltdata pointer, or    NULL on error.     Presumes the file pointer is already in the right place (ie pointing    to the ar_hdr in the file).   Moves the file pointer; on success it    should be pointing to the front of the file contents; on failure it    could have been moved arbitrarily. */
end_comment

begin_function
name|struct
name|areltdata
modifier|*
name|snarf_ar_hdr
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|errno
specifier|extern
name|int
name|errno
decl_stmt|;
endif|#
directive|endif
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|char
modifier|*
name|hdrp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ared
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|namelen
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|allocsize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|allocptr
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|hdrp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|no_more_archived_files
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|hdr
operator|.
name|ar_fmag
operator|)
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|parsed_size
operator|=
name|strtol
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* extract the filename from the archive - there are two ways to        specify an extendend name table, either the first char of the        name is a space, or it's a slash  */
if|if
condition|(
operator|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|' '
operator|)
operator|&&
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|get_extended_arelt_filename
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|.
name|ar_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
comment|/* We judge the end of the name by looking for a space or a 	       padchar */
name|namelen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|namelen
operator|<
operator|(
name|unsigned
operator|)
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|hdr
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
literal|0
operator|&&
name|hdr
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
literal|' '
operator|&&
name|hdr
operator|.
name|ar_name
index|[
name|namelen
index|]
operator|!=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
operator|)
condition|)
block|{
name|namelen
operator|++
expr_stmt|;
block|}
name|allocsize
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
block|}
name|allocptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|allocsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocptr
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ared
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|allocptr
expr_stmt|;
name|ared
operator|->
name|arch_header
operator|=
name|allocptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ared
operator|->
name|arch_header
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ared
operator|->
name|parsed_size
operator|=
name|parsed_size
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|ared
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
else|else
block|{
name|ared
operator|->
name|filename
operator|=
name|allocptr
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|namelen
condition|)
name|memcpy
argument_list|(
name|ared
operator|->
name|filename
argument_list|,
name|hdr
operator|.
name|ar_name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|ared
operator|->
name|filename
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|ared
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is an internal function; it's mainly used when indexing    through the archive symbol table, but also used to get the next    element, since it handles the bookkeeping so nicely for us. */
end_comment

begin_function
name|bfd
modifier|*
name|get_elt_at_filepos
parameter_list|(
name|archive
parameter_list|,
name|filepos
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|new_areldata
decl_stmt|;
name|bfd
modifier|*
name|n_nfd
decl_stmt|;
name|n_nfd
operator|=
name|look_for_bfd_in_cache
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_nfd
condition|)
return|return
name|n_nfd
return|;
if|if
condition|(
literal|0
operator|>
name|bfd_seek
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|new_areldata
operator|=
name|snarf_ar_hdr
argument_list|(
name|archive
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|n_nfd
operator|=
name|_bfd_create_empty_archive_element_shell
argument_list|(
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_nfd
operator|==
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|new_areldata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n_nfd
operator|->
name|origin
operator|=
name|bfd_tell
argument_list|(
name|archive
argument_list|)
expr_stmt|;
name|n_nfd
operator|->
name|arelt_data
operator|=
operator|(
name|PTR
operator|)
name|new_areldata
expr_stmt|;
name|n_nfd
operator|->
name|filename
operator|=
name|new_areldata
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|add_bfd_to_cache
argument_list|(
name|archive
argument_list|,
name|filepos
argument_list|,
name|n_nfd
argument_list|)
condition|)
return|return
name|n_nfd
return|;
comment|/* huh? */
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|n_nfd
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|archive
argument_list|,
operator|(
name|PTR
operator|)
name|new_areldata
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_get_elt_at_index  SYNOPSIS 	bfd *bfd_get_elt_at_index(bfd * archive, int index);  DESCRIPTION 	Return the bfd which is referenced by the symbol indexed by<<index>>.<<index>> should have been returned by<<bfd_get_next_mapent>> (q.v.).  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|bfd_get_elt_at_index
argument_list|,
operator|(
name|abfd
operator|,
name|index
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|int
name|index
argument_list|)
block|{
name|bfd
modifier|*
name|result
init|=
name|get_elt_at_filepos
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symdefs
operator|+
name|index
operator|)
operator|->
name|file_offset
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_openr_next_archived_file  SYNOPSIS 	bfd* bfd_openr_next_archived_file(bfd *archive, bfd *previous);  DESCRIPTION 	Initially provided a BFD containing an archive and NULL, opens 	an inpout BFD on the first contained element and returns that. 	Subsequent calls to bfd_openr_next_archived_file should pass 	the archive and the previous return value to return a created 	BFD to the next contained element. NULL is returned when there 	are no more.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|DEFUN
argument_list|(
name|bfd_openr_next_archived_file
argument_list|,
operator|(
name|archive
operator|,
name|last_file
operator|)
argument_list|,
name|bfd
operator|*
name|archive
name|AND
name|bfd
operator|*
name|last_file
argument_list|)
block|{
if|if
condition|(
operator|(
name|bfd_get_format
argument_list|(
name|archive
argument_list|)
operator|!=
name|bfd_archive
operator|)
operator|||
operator|(
name|archive
operator|->
name|direction
operator|==
name|write_direction
operator|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|BFD_SEND
argument_list|(
name|archive
argument_list|,
name|openr_next_archived_file
argument_list|,
operator|(
name|archive
operator|,
name|last_file
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
name|bfd
modifier|*
name|bfd_generic_openr_next_archived_file
parameter_list|(
name|archive
parameter_list|,
name|last_file
parameter_list|)
name|bfd
modifier|*
name|archive
decl_stmt|;
name|bfd
modifier|*
name|last_file
decl_stmt|;
block|{
name|file_ptr
name|filestart
decl_stmt|;
if|if
condition|(
operator|!
name|last_file
condition|)
name|filestart
operator|=
name|bfd_ardata
argument_list|(
name|archive
argument_list|)
operator|->
name|first_file_filepos
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|size
init|=
name|arelt_size
argument_list|(
name|last_file
argument_list|)
decl_stmt|;
comment|/* Pad to an even boundary... */
name|filestart
operator|=
name|last_file
operator|->
name|origin
operator|+
name|size
operator|+
name|size
operator|%
literal|2
expr_stmt|;
block|}
return|return
name|get_elt_at_filepos
argument_list|(
name|archive
argument_list|,
name|filestart
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_target
modifier|*
name|bfd_generic_archive_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|armag
index|[
name|SARMAG
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|armag
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|abfd
argument_list|)
operator|!=
name|SARMAG
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|GNU960
if|if
condition|(
name|strncmp
argument_list|(
name|armag
argument_list|,
name|BFD_GNU960_ARMAG
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SARMAG
argument_list|)
condition|)
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|armag
argument_list|,
name|ARMAGB
argument_list|,
name|SARMAG
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* We are setting bfd_ardata(abfd) here, but since bfd_ardata      involves a cast, we can't do it as the left operand of assignment. */
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
operator|(
expr|struct
name|artdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|artdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|SARMAG
expr_stmt|;
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_slurp_armap
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_slurp_extended_name_table
argument_list|,
operator|(
name|abfd
operator|)
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_ar_data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_function
name|boolean
name|bfd_slurp_bsd_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|raw_armap
decl_stmt|,
modifier|*
name|rbase
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
comment|/* FIXME, if the read fails, this routine quietly returns "true"!!        It should probably do that if the read gives 0 bytes (empty archive),        but fail for any other size... */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
operator|==
literal|16
condition|)
block|{
comment|/* The archive has at least 16 bytes in it */
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* This should be using RANLIBMAG, but at least it can be grepped for 	       in this comment.  */
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"__.SYMDEF       "
argument_list|,
literal|16
argument_list|)
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|mapdata
operator|=
name|snarf_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|raw_armap
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|mapdata
operator|->
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|mapdata
operator|->
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|mapdata
operator|->
name|parsed_size
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
name|byebyebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
name|ardata
operator|->
name|symdef_count
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdef_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symdef
argument_list|)
operator|>
name|mapdata
operator|->
name|parsed_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|raw_armap
argument_list|)
condition|)
block|{
comment|/* Probably we're using the wrong byte ordering.  */
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
goto|goto
name|byebyebye
goto|;
block|}
name|ardata
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
name|rbase
operator|=
name|raw_armap
operator|+
literal|1
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|rbase
expr_stmt|;
name|stringbase
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ardata
operator|->
name|symdefs
operator|+
name|ardata
operator|->
name|symdef_count
operator|)
operator|)
operator|+
literal|4
expr_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|ardata
operator|->
name|symdef_count
condition|;
name|counter
operator|++
control|)
block|{
name|struct
name|symdef
modifier|*
name|sym
init|=
operator|(
operator|(
expr|struct
name|symdef
operator|*
operator|)
name|rbase
operator|)
operator|+
name|counter
decl_stmt|;
name|sym
operator|->
name|s
operator|.
name|name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|&
operator|(
name|sym
operator|->
name|s
operator|.
name|string_offset
operator|)
argument_list|)
argument_list|)
operator|+
name|stringbase
expr_stmt|;
name|sym
operator|->
name|file_offset
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
operator|&
operator|(
name|sym
operator|->
name|file_offset
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* FIXME, we should provide some way to free raw_ardata when 	       we are done using the strings from it.  For now, it seems 	       to be allocated on an obstack anyway... */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_function
name|boolean
name|bfd_slurp_coff_armap
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|areltdata
modifier|*
name|mapdata
decl_stmt|;
name|char
name|nextname
decl_stmt|;
name|int
modifier|*
name|raw_armap
decl_stmt|,
modifier|*
name|rawptr
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|unsigned
name|int
name|stringsize
decl_stmt|;
name|carsym
modifier|*
name|carsyms
decl_stmt|;
name|int
name|result
decl_stmt|;
name|bfd_vma
function_decl|(
modifier|*
name|swap
function_decl|)
parameter_list|()
function_decl|;
name|result
operator|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|nextname
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|1
operator|||
name|nextname
operator|!=
literal|'/'
condition|)
block|{
comment|/* Actually I think this is an error for a COFF archive */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|false
expr_stmt|;
return|return
name|true
return|;
block|}
name|mapdata
operator|=
name|snarf_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|raw_armap
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|mapdata
operator|->
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_armap
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|mapdata
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* read in the raw map */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|,
literal|1
argument_list|,
name|mapdata
operator|->
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|mapdata
operator|->
name|parsed_size
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
name|oops
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
comment|/* The coff armap must be read sequentially.  So we construct a bsd-style      one in core all at once, for simplicity.             It seems that all numeric information in a coff archive is always      in big endian format, nomatter the host or target. */
name|stringsize
operator|=
name|mapdata
operator|->
name|parsed_size
operator|-
operator|(
literal|4
operator|*
operator|(
name|_do_getb32
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
operator|)
operator|)
operator|-
literal|4
expr_stmt|;
comment|/* Except that some archive formats are broken, and it may be our      fault - the i960 little endian coff sometimes has big and sometimes      little, because our tools changed.  Here's a horrible hack to clean      up the crap      */
name|swap
operator|=
name|_do_getb32
expr_stmt|;
if|if
condition|(
name|stringsize
operator|>
literal|0xfffff
condition|)
block|{
comment|/* This looks dangerous, let's do it the other way around */
name|stringsize
operator|=
name|mapdata
operator|->
name|parsed_size
operator|-
operator|(
literal|4
operator|*
operator|(
name|_do_getl32
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
operator|)
operator|)
operator|-
literal|4
expr_stmt|;
name|swap
operator|=
name|_do_getl32
expr_stmt|;
block|}
block|{
name|unsigned
name|int
name|nsymz
init|=
name|swap
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|carsym_size
init|=
operator|(
name|nsymz
operator|*
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|ptrsize
init|=
operator|(
literal|4
operator|*
name|nsymz
operator|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
operator|(
name|carsym
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|carsym_size
operator|+
name|stringsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ardata
operator|->
name|symdefs
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
name|carsyms
operator|=
name|ardata
operator|->
name|symdefs
expr_stmt|;
name|stringbase
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|ardata
operator|->
name|symdefs
operator|)
operator|+
name|carsym_size
expr_stmt|;
name|memcpy
argument_list|(
name|stringbase
argument_list|,
operator|(
name|char
operator|*
operator|)
name|raw_armap
operator|+
name|ptrsize
operator|+
literal|4
argument_list|,
name|stringsize
argument_list|)
expr_stmt|;
comment|/* OK, build the carsyms */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsymz
condition|;
name|i
operator|++
control|)
block|{
name|rawptr
operator|=
name|raw_armap
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|carsyms
operator|->
name|file_offset
operator|=
name|swap
argument_list|(
operator|(
name|PTR
operator|)
name|rawptr
argument_list|)
expr_stmt|;
name|carsyms
operator|->
name|name
operator|=
name|stringbase
expr_stmt|;
for|for
control|(
init|;
operator|*
operator|(
name|stringbase
operator|++
operator|)
condition|;
control|)
empty_stmt|;
name|carsyms
operator|++
expr_stmt|;
block|}
operator|*
name|stringbase
operator|=
literal|0
expr_stmt|;
block|}
name|ardata
operator|->
name|symdef_count
operator|=
name|swap
argument_list|(
operator|(
name|PTR
operator|)
name|raw_armap
argument_list|)
expr_stmt|;
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Pad to an even boundary if you have to */
name|ardata
operator|->
name|first_file_filepos
operator|+=
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* We'd like to release these allocations, but we have allocated stuff      since then (using the same obstack, if bfd_release is obstack based).      So they will stick around until the BFD is closed.  */
comment|/*  bfd_release (abfd, (PTR)raw_armap);       bfd_release (abfd, (PTR)mapdata);  */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Extended name table.    Normally archives support only 14-character filenames.    Intel has extended the format: longer names are stored in a special   element (the first in the archive, or second if there is an armap);   the name in the ar_hdr is replaced by<space><index into filename   element>.  Index is the P.R. of an int (decimal).  Data General have   extended the format by using the prefix // for the special element */
end_comment

begin_comment
comment|/* Returns false on error, true otherwise */
end_comment

begin_function
name|boolean
name|_bfd_slurp_extended_name_table
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|namedata
decl_stmt|;
comment|/* FIXME:  Formatting sucks here, and in case of failure of BFD_READ,      we probably don't want to return true.  */
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|nextname
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|abfd
argument_list|)
operator|==
literal|16
condition|)
block|{
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"ARFILENAMES/    "
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|nextname
argument_list|,
literal|"//              "
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
name|namedata
operator|=
name|snarf_ar_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|namedata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|namedata
operator|->
name|parsed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
name|byebye
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|namedata
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
argument_list|,
literal|1
argument_list|,
name|namedata
operator|->
name|parsed_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|namedata
operator|->
name|parsed_size
condition|)
block|{
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
operator|=
name|NULL
expr_stmt|;
goto|goto
name|byebye
goto|;
block|}
comment|/* Since the archive is supposed to be printable if it contains        text, the entries in the list are newline-padded, not null        padded. We'll fix that there..  */
block|{
name|char
modifier|*
name|temp
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|extended_names
decl_stmt|;
for|for
control|(
init|;
operator|*
name|temp
operator|!=
literal|'\0'
condition|;
operator|++
name|temp
control|)
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\n'
condition|)
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Pad to an even boundary if you have to */
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|+=
operator|(
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|first_file_filepos
operator|)
operator|%
literal|2
expr_stmt|;
comment|/* FIXME, we can't release namedata here because it was allocated        below extended_names on the obstack... */
comment|/* bfd_release (abfd, namedata); */
block|}
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* Return a copy of the stuff in the filename between any :]> and a    semicolon */
end_comment

begin_decl_stmt
specifier|static
name|CONST
name|char
modifier|*
name|DEFUN
argument_list|(
name|normalize
argument_list|,
operator|(
name|file
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|file
argument_list|)
block|{
name|CONST
name|char
modifier|*
name|first
decl_stmt|;
name|CONST
name|char
modifier|*
name|last
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|first
operator|=
name|file
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|-
literal|1
expr_stmt|;
name|last
operator|=
name|first
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|first
operator|!=
name|file
condition|)
block|{
if|if
condition|(
operator|*
name|first
operator|==
literal|';'
condition|)
name|last
operator|=
name|first
expr_stmt|;
if|if
condition|(
operator|*
name|first
operator|==
literal|':'
operator|||
operator|*
name|first
operator|==
literal|']'
operator|||
operator|*
name|first
operator|==
literal|'>'
condition|)
block|{
name|first
operator|++
expr_stmt|;
break|break;
block|}
name|first
operator|--
expr_stmt|;
block|}
name|copy
operator|=
name|malloc
argument_list|(
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|first
argument_list|,
name|last
operator|-
name|first
argument_list|)
expr_stmt|;
name|copy
index|[
name|last
operator|-
name|first
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|copy
return|;
block|}
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|CONST
name|char
modifier|*
name|normalize
parameter_list|(
name|file
parameter_list|)
name|CONST
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|filename
operator|++
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|file
expr_stmt|;
block|}
return|return
name|filename
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Follows archive_head and produces an extended name table if necessary.    Returns (in tabloc) a pointer to an extended name table, and in tablen    the length of the table.  If it makes an entry it clobbers the filename    so that the element may be written without further massage.    Returns true if it ran successfully, false if something went wrong.    A successful return may still involve a zero-length tablen!    */
end_comment

begin_function
name|boolean
name|bfd_construct_extended_name_table
parameter_list|(
name|abfd
parameter_list|,
name|tabloc
parameter_list|,
name|tablen
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|tabloc
decl_stmt|;
name|unsigned
name|int
modifier|*
name|tablen
decl_stmt|;
block|{
name|unsigned
name|int
name|maxname
init|=
name|abfd
operator|->
name|xvec
operator|->
name|ar_max_namelen
decl_stmt|;
name|unsigned
name|int
name|total_namelen
init|=
literal|0
decl_stmt|;
name|bfd
modifier|*
name|current
decl_stmt|;
name|char
modifier|*
name|strptr
decl_stmt|;
operator|*
name|tablen
operator|=
literal|0
expr_stmt|;
comment|/* Figure out how long the table should be */
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|thislen
init|=
name|strlen
argument_list|(
name|normalize
argument_list|(
name|current
operator|->
name|filename
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|thislen
operator|>
name|maxname
condition|)
name|total_namelen
operator|+=
name|thislen
operator|+
literal|1
expr_stmt|;
comment|/* leave room for \n */
block|}
if|if
condition|(
name|total_namelen
operator|==
literal|0
condition|)
return|return
name|true
return|;
operator|*
name|tabloc
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|total_namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tabloc
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|tablen
operator|=
name|total_namelen
expr_stmt|;
name|strptr
operator|=
operator|*
name|tabloc
expr_stmt|;
for|for
control|(
name|current
operator|=
name|abfd
operator|->
name|archive_head
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|CONST
name|char
modifier|*
name|normal
init|=
name|normalize
argument_list|(
name|current
operator|->
name|filename
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|thislen
init|=
name|strlen
argument_list|(
name|normal
argument_list|)
decl_stmt|;
if|if
condition|(
name|thislen
operator|>
name|maxname
condition|)
block|{
comment|/* Works for now; may need to be re-engineered if we encounter an oddball 	 archive format and want to generalise this hack. */
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
name|arch_hdr
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|strptr
argument_list|,
name|normal
argument_list|)
expr_stmt|;
name|strptr
index|[
name|thislen
index|]
operator|=
literal|'\n'
expr_stmt|;
name|hdr
operator|->
name|ar_name
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* We know there will always be enough room (one of the few cases 	 where you may safely use sprintf). */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_name
operator|)
operator|+
literal|1
argument_list|,
literal|"%-d"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|strptr
operator|-
operator|*
name|tabloc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kinda Kludgy.   We should just use the returned value of sprintf 	 but not all implementations get this right */
block|{
name|char
modifier|*
name|temp
init|=
name|hdr
operator|->
name|ar_name
operator|+
literal|2
decl_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|hdr
operator|->
name|ar_name
operator|+
name|maxname
condition|;
name|temp
operator|++
control|)
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\0'
condition|)
operator|*
name|temp
operator|=
literal|' '
expr_stmt|;
block|}
name|strptr
operator|+=
name|thislen
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** A couple of functions for creating ar_hdrs */
end_comment

begin_comment
comment|/* Takes a filename, returns an arelt_data for it, or NULL if it can't make one.    The filename must refer to a filename in the filesystem.    The filename field of the ar_hdr will NOT be initialized */
end_comment

begin_decl_stmt
name|struct
name|areltdata
modifier|*
name|DEFUN
argument_list|(
name|bfd_ar_hdr_from_filesystem
argument_list|,
operator|(
name|abfd
operator|,
name|filename
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|CONST
name|char
operator|*
name|filename
argument_list|)
block|{
name|struct
name|stat
name|status
decl_stmt|;
name|struct
name|areltdata
modifier|*
name|ared
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp1
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ared
operator|=
operator|(
expr|struct
name|areltdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ared
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ared
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|areltdata
argument_list|)
operator|)
expr_stmt|;
comment|/* ar headers are space padded, not null padded! */
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
name|temp1
operator|=
name|temp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|temp1
condition|;
operator|*
operator|(
name|temp
operator|++
operator|)
operator|=
literal|' '
control|)
empty_stmt|;
name|strncpy
argument_list|(
name|hdr
operator|->
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Goddamned sprintf doesn't permit MAXIMUM field lengths */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_date
operator|)
argument_list|,
literal|"%-12ld"
argument_list|,
name|status
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_uid
operator|)
argument_list|,
literal|"%d"
argument_list|,
name|status
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_gid
operator|)
argument_list|,
literal|"%d"
argument_list|,
name|status
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_mode
operator|)
argument_list|,
literal|"%-8o"
argument_list|,
operator|(
name|unsigned
operator|)
name|status
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|->
name|ar_size
operator|)
argument_list|,
literal|"%-10ld"
argument_list|,
name|status
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* Correct for a lossage in sprintf whereby it null-terminates.  I cannot      understand how these C losers could design such a ramshackle bunch of      IO operations */
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
name|temp1
operator|=
name|temp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|temp
operator|<
name|temp1
condition|;
name|temp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\0'
condition|)
operator|*
name|temp
operator|=
literal|' '
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|hdr
operator|->
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ared
operator|->
name|parsed_size
operator|=
name|status
operator|.
name|st_size
expr_stmt|;
name|ared
operator|->
name|arch_header
operator|=
operator|(
name|char
operator|*
operator|)
name|hdr
expr_stmt|;
return|return
name|ared
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This is magic required by the "ar" program.  Since it's     undocumented, it's undocumented.   You may think that it would     take a strong stomach to write this, and it does, but it takes     even a stronger stomach to try to code around such a thing! */
end_comment

begin_decl_stmt
name|struct
name|ar_hdr
modifier|*
name|DEFUN
argument_list|(
name|bfd_special_undocumented_glue
argument_list|,
operator|(
name|abfd
operator|,
name|filename
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|filename
argument_list|)
block|{
name|struct
name|areltdata
modifier|*
name|ar_elt
init|=
name|bfd_ar_hdr_from_filesystem
argument_list|(
name|abfd
argument_list|,
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|ar_elt
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|ar_elt
operator|->
name|arch_header
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Analogous to stat call */
end_comment

begin_function
name|int
name|bfd_generic_stat_arch_elt
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|aloser
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|arelt_data
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|hdr
operator|=
name|arch_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
define|#
directive|define
name|foo
parameter_list|(
name|arelt
parameter_list|,
name|stelt
parameter_list|,
name|size
parameter_list|)
define|\
value|buf->stelt = strtol (hdr->arelt,&aloser, size); \   if (aloser == hdr->arelt) return -1;
name|foo
argument_list|(
name|ar_date
argument_list|,
name|st_mtime
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_uid
argument_list|,
name|st_uid
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_gid
argument_list|,
name|st_gid
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_mode
argument_list|,
name|st_mode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|foo
argument_list|(
name|ar_size
argument_list|,
name|st_size
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bfd_dont_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
comment|/* FIXME: This interacts unpleasantly with ar's quick-append option.      Fortunately ic960 users will never use that option.  Fixing this      is very hard; fortunately I know how to do it and will do so once      intel's release is out the door. */
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CONST
name|char
modifier|*
name|filename
init|=
name|normalize
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|maxlen
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|bfd_bsd_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|pathname
expr_stmt|;
else|else
operator|++
name|filename
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* pathname: meet procrustes */
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|length
operator|=
name|maxlen
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
name|maxlen
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store name into ar header.  Truncates the name to fit.    1> strip pathname to be just the basename.    2> if it's short enuf to fit, stuff it in.    3> If it doesn't end with .o, truncate it to fit    4> truncate it before the .o, append .o, stuff THAT in. */
end_comment

begin_comment
comment|/* This is what gnu ar does.  It's better but incompatible with the bsd ar. */
end_comment

begin_function
name|void
name|bfd_gnu_truncate_arname
parameter_list|(
name|abfd
parameter_list|,
name|pathname
parameter_list|,
name|arhdr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|CONST
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|arhdr
decl_stmt|;
block|{
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|arhdr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CONST
name|char
modifier|*
name|filename
init|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|ar_maxnamelen
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|pathname
expr_stmt|;
else|else
operator|++
name|filename
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|maxlen
condition|)
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* pathname: meet procrustes */
name|memcpy
argument_list|(
name|hdr
operator|->
name|ar_name
argument_list|,
name|filename
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filename
index|[
name|length
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|filename
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|)
condition|)
block|{
name|hdr
operator|->
name|ar_name
index|[
name|maxlen
operator|-
literal|2
index|]
operator|=
literal|'.'
expr_stmt|;
name|hdr
operator|->
name|ar_name
index|[
name|maxlen
operator|-
literal|1
index|]
operator|=
literal|'o'
expr_stmt|;
block|}
name|length
operator|=
name|maxlen
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
literal|16
condition|)
operator|(
name|hdr
operator|->
name|ar_name
operator|)
index|[
name|length
index|]
operator|=
name|ar_padchar
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|compute_and_write_armap
argument_list|,
operator|(
name|bfd
operator|*
name|arch
operator|,
name|unsigned
name|int
name|elength
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The BFD is open for write and has its format set to bfd_archive */
end_comment

begin_function
name|boolean
name|_bfd_write_archive_contents
parameter_list|(
name|arch
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
block|{
name|bfd
modifier|*
name|current
decl_stmt|;
name|char
modifier|*
name|etable
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|elength
init|=
literal|0
decl_stmt|;
name|boolean
name|makemap
init|=
name|bfd_has_map
argument_list|(
name|arch
argument_list|)
decl_stmt|;
name|boolean
name|hasobjects
init|=
name|false
decl_stmt|;
comment|/* if no .o's, don't bother to make a map */
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Verify the viability of all entries; if any of them live in the      filesystem (as opposed to living in an archive open for input)      then construct a fresh ar_hdr for them.      */
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bfd_write_p
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|current
operator|->
name|arelt_data
condition|)
block|{
name|current
operator|->
name|arelt_data
operator|=
operator|(
name|PTR
operator|)
name|bfd_ar_hdr_from_filesystem
argument_list|(
name|arch
argument_list|,
name|current
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
operator|->
name|arelt_data
condition|)
return|return
name|false
return|;
comment|/* Put in the file name */
name|BFD_SEND
argument_list|(
name|arch
argument_list|,
name|_bfd_truncate_arname
argument_list|,
operator|(
name|arch
operator|,
name|current
operator|->
name|filename
operator|,
operator|(
name|char
operator|*
operator|)
name|arch_hdr
argument_list|(
name|current
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|makemap
condition|)
block|{
comment|/* don't bother if we won't make a map! */
if|if
condition|(
operator|(
name|bfd_check_format
argument_list|(
name|current
argument_list|,
name|bfd_object
argument_list|)
operator|)
if|#
directive|if
literal|0
comment|/* FIXME -- these are not set correctly */
condition|&& ((bfd_get_file_flags (current)& HAS_SYMS))
endif|#
directive|endif
condition|)
name|hasobjects
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bfd_construct_extended_name_table
argument_list|(
name|arch
argument_list|,
operator|&
name|etable
argument_list|,
operator|&
name|elength
argument_list|)
condition|)
return|return
name|false
return|;
name|bfd_seek
argument_list|(
name|arch
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GNU960
name|bfd_write
argument_list|(
name|BFD_GNU960_ARMAG
argument_list|(
name|arch
argument_list|)
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|arch
argument_list|)
expr_stmt|;
else|#
directive|else
name|bfd_write
argument_list|(
name|ARMAG
argument_list|,
literal|1
argument_list|,
name|SARMAG
argument_list|,
name|arch
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|makemap
operator|&&
name|hasobjects
condition|)
block|{
if|if
condition|(
name|compute_and_write_armap
argument_list|(
name|arch
argument_list|,
name|elength
argument_list|)
operator|!=
name|true
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|elength
operator|!=
literal|0
condition|)
block|{
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
operator|(
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|)
argument_list|,
literal|"ARFILENAMES/"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
operator|(
name|hdr
operator|.
name|ar_size
index|[
literal|0
index|]
operator|)
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|elength
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|etable
argument_list|,
literal|1
argument_list|,
name|elength
argument_list|,
name|arch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elength
operator|%
literal|2
operator|)
operator|==
literal|1
condition|)
name|bfd_write
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
name|char
name|buffer
index|[
name|DEFAULT_BUFFERSIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|remaining
init|=
name|arelt_size
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|struct
name|ar_hdr
modifier|*
name|hdr
init|=
name|arch_hdr
argument_list|(
name|current
argument_list|)
decl_stmt|;
comment|/* write ar header */
if|if
condition|(
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|syserr
label|:
name|bfd_error
operator|=
name|system_call_error
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|current
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|syserr
goto|;
while|while
condition|(
name|remaining
condition|)
block|{
name|unsigned
name|int
name|amt
init|=
name|DEFAULT_BUFFERSIZE
decl_stmt|;
if|if
condition|(
name|amt
operator|>
name|remaining
condition|)
block|{
name|amt
operator|=
name|remaining
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|buffer
argument_list|,
name|amt
argument_list|,
literal|1
argument_list|,
name|current
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|errno
condition|)
goto|goto
name|syserr
goto|;
comment|/* Looks like a truncated archive. */
name|bfd_error
operator|=
name|malformed_archive
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|amt
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|syserr
goto|;
name|remaining
operator|-=
name|amt
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|%
literal|2
operator|)
operator|==
literal|1
condition|)
name|bfd_write
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note that the namidx for the first symbol is 0 */
end_comment

begin_function
name|boolean
name|compute_and_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
block|{
name|bfd
modifier|*
name|current
decl_stmt|;
name|file_ptr
name|elt_no
init|=
literal|0
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|int
name|orl_max
init|=
literal|15000
decl_stmt|;
comment|/* fine initial default */
name|int
name|orl_count
init|=
literal|0
decl_stmt|;
name|int
name|stridx
init|=
literal|0
decl_stmt|;
comment|/* string index */
comment|/* Dunno if this is the best place for this info... */
if|if
condition|(
name|elength
operator|!=
literal|0
condition|)
name|elength
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
name|elength
operator|+=
name|elength
operator|%
literal|2
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|orl
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|arch
argument_list|,
name|orl_max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|orl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Drop all the files called __.SYMDEF, we're going to make our        own */
while|while
condition|(
name|arch
operator|->
name|archive_head
operator|&&
name|strcmp
argument_list|(
name|arch
operator|->
name|archive_head
operator|->
name|filename
argument_list|,
literal|"__.SYMDEF"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arch
operator|->
name|archive_head
operator|=
name|arch
operator|->
name|archive_head
operator|->
name|next
expr_stmt|;
block|}
comment|/* Map over each element */
for|for
control|(
name|current
operator|=
name|arch
operator|->
name|archive_head
init|;
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
operator|,
name|elt_no
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bfd_check_format
argument_list|(
name|current
argument_list|,
name|bfd_object
argument_list|)
operator|==
name|true
operator|)
operator|&&
operator|(
operator|(
name|bfd_get_file_flags
argument_list|(
name|current
argument_list|)
operator|&
name|HAS_SYMS
operator|)
operator|)
condition|)
block|{
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|unsigned
name|int
name|storage
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|unsigned
name|int
name|src_count
decl_stmt|;
name|storage
operator|=
name|get_symtab_upper_bound
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|!=
literal|0
condition|)
block|{
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|arch
argument_list|,
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
block|{
name|bfd_error
operator|=
name|no_memory
expr_stmt|;
comment|/* FIXME -- memory leak */
return|return
name|false
return|;
block|}
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|current
argument_list|,
name|syms
argument_list|)
expr_stmt|;
comment|/* Now map over all the symbols, picking out the ones we want */
for|for
control|(
name|src_count
operator|=
literal|0
init|;
name|src_count
operator|<
name|symcount
condition|;
name|src_count
operator|++
control|)
block|{
name|flagword
name|flags
init|=
operator|(
name|syms
index|[
name|src_count
index|]
operator|)
operator|->
name|flags
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|syms
index|[
name|src_count
index|]
operator|->
name|section
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|||
operator|(
name|flags
operator|&
name|BSF_INDIRECT
operator|)
operator|||
operator|(
name|sec
operator|==
operator|&
name|bfd_com_section
operator|)
condition|)
block|{
comment|/* This symbol will go into the archive header */
if|if
condition|(
name|orl_count
operator|==
name|orl_max
condition|)
block|{
name|orl_max
operator|*=
literal|2
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|orl
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|arch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|map
argument_list|,
name|orl_max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|orl
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|map
index|[
name|orl_count
index|]
operator|)
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
operator|(
operator|(
name|syms
index|[
name|src_count
index|]
operator|)
operator|->
name|name
operator|)
expr_stmt|;
operator|(
name|map
index|[
name|orl_count
index|]
operator|)
operator|.
name|pos
operator|=
operator|(
name|file_ptr
operator|)
name|current
expr_stmt|;
operator|(
name|map
index|[
name|orl_count
index|]
operator|)
operator|.
name|namidx
operator|=
name|stridx
expr_stmt|;
name|stridx
operator|+=
name|strlen
argument_list|(
operator|(
name|syms
index|[
name|src_count
index|]
operator|)
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|++
name|orl_count
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* OK, now we have collected all the data, let's write them out */
if|if
condition|(
operator|!
name|BFD_SEND
argument_list|(
name|arch
argument_list|,
name|write_armap
argument_list|,
operator|(
name|arch
operator|,
name|elength
operator|,
name|map
operator|,
name|orl_count
operator|,
name|stridx
operator|)
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|boolean
name|bsd_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|orl_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|orl_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
name|int
name|padit
init|=
name|stridx
operator|&
literal|1
decl_stmt|;
name|unsigned
name|int
name|ranlibsize
init|=
name|orl_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ranlib
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stringsize
init|=
name|stridx
operator|+
name|padit
decl_stmt|;
comment|/* Include 8 bytes to store ranlibsize and stringsize in output. */
name|unsigned
name|int
name|mapsize
init|=
name|ranlibsize
operator|+
name|stringsize
operator|+
literal|8
decl_stmt|;
name|file_ptr
name|firstreal
decl_stmt|;
name|bfd
modifier|*
name|current
init|=
name|arch
operator|->
name|archive_head
decl_stmt|;
name|bfd
modifier|*
name|last_elt
init|=
name|current
decl_stmt|;
comment|/* last element arch seen */
name|int
name|temp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|firstreal
operator|=
name|mapsize
operator|+
name|elength
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|SARMAG
expr_stmt|;
name|stat
argument_list|(
name|arch
operator|->
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
name|RANLIBMAG
argument_list|)
expr_stmt|;
comment|/* write the timestamp of the archive header to be just a little bit      later than the timestamp of the file, otherwise the linker will      complain that the index is out of date.      */
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
name|statbuf
operator|.
name|st_mtime
operator|+
literal|60
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_uid
argument_list|,
literal|"%d"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_gid
argument_list|,
literal|"%d"
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
name|ranlibsize
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|temp
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|&
name|temp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|orl_count
condition|;
name|count
operator|++
control|)
block|{
name|struct
name|symdef
name|outs
decl_stmt|;
name|struct
name|symdef
modifier|*
name|outp
init|=
operator|&
name|outs
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
operator|)
operator|!=
name|last_elt
condition|)
block|{
do|do
block|{
name|firstreal
operator|+=
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
name|firstreal
operator|+=
name|firstreal
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
condition|)
do|;
block|}
comment|/* if new archive element */
name|last_elt
operator|=
name|current
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|namidx
operator|)
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|outs
operator|.
name|s
operator|.
name|string_offset
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
name|firstreal
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|outs
operator|.
name|file_offset
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|outs
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
comment|/* now write the strings themselves */
name|bfd_h_put_32
argument_list|(
name|arch
argument_list|,
name|stringsize
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|temp
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|temp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|orl_count
condition|;
name|count
operator|++
control|)
name|bfd_write
argument_list|(
operator|*
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|name
operator|)
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
operator|*
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|name
operator|)
argument_list|)
operator|+
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
comment|/* The spec sez this should be a newline.  But in order to be      bug-compatible for sun's ar we use a null. */
if|if
condition|(
name|padit
condition|)
name|bfd_write
argument_list|(
literal|"\0"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A coff armap looks like :  lARMAG  struct ar_hdr with name = '/'   number of symbols  offset of file for symbol 0  offset of file for symbol 1   offset of file for symbol n-1  symbol name 0  symbol name 1	    symbol name n-1  */
end_comment

begin_function
name|boolean
name|coff_write_armap
parameter_list|(
name|arch
parameter_list|,
name|elength
parameter_list|,
name|map
parameter_list|,
name|symbol_count
parameter_list|,
name|stridx
parameter_list|)
name|bfd
modifier|*
name|arch
decl_stmt|;
name|unsigned
name|int
name|elength
decl_stmt|;
name|struct
name|orl
modifier|*
name|map
decl_stmt|;
name|unsigned
name|int
name|symbol_count
decl_stmt|;
name|int
name|stridx
decl_stmt|;
block|{
comment|/* The size of the ranlib is the number of exported symbols in the        archive * the number of bytes in a int, + an int for the count */
name|unsigned
name|int
name|ranlibsize
init|=
operator|(
name|symbol_count
operator|*
literal|4
operator|)
operator|+
literal|4
decl_stmt|;
name|unsigned
name|int
name|stringsize
init|=
name|stridx
decl_stmt|;
name|unsigned
name|int
name|mapsize
init|=
name|stringsize
operator|+
name|ranlibsize
decl_stmt|;
name|file_ptr
name|archive_member_file_ptr
decl_stmt|;
name|bfd
modifier|*
name|current
init|=
name|arch
operator|->
name|archive_head
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|padit
init|=
name|mapsize
operator|&
literal|1
decl_stmt|;
if|if
condition|(
name|padit
condition|)
name|mapsize
operator|++
expr_stmt|;
comment|/* work out where the first object file will go in the archive */
name|archive_member_file_ptr
operator|=
name|mapsize
operator|+
name|elength
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|SARMAG
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|mapsize
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This, at least, is what Intel coff sets the values to.: */
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_uid
operator|)
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_gid
operator|)
argument_list|,
literal|"%d"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|hdr
operator|.
name|ar_mode
operator|)
argument_list|,
literal|"%-7o"
argument_list|,
operator|(
name|unsigned
operator|)
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
comment|/* Write the ar header for this item and the number of symbols */
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|&
name|hdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|bfd_write_bigendian_4byte_int
argument_list|(
name|arch
argument_list|,
name|symbol_count
argument_list|)
expr_stmt|;
comment|/* Two passes, first write the file offsets for each symbol -        remembering that each offset is on a two byte boundary.  */
comment|/* Write out the file offset for the file associated with each        symbol, and remember to keep the offsets padded out.  */
name|current
operator|=
name|arch
operator|->
name|archive_head
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
name|count
operator|<
name|symbol_count
condition|)
block|{
comment|/* For each symbol which is used defined in this object, write out 	   the object file's address in the archive */
while|while
condition|(
operator|(
operator|(
name|bfd
operator|*
operator|)
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|pos
operator|)
operator|==
name|current
condition|)
block|{
name|bfd_write_bigendian_4byte_int
argument_list|(
name|arch
argument_list|,
name|archive_member_file_ptr
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Add size of this archive entry */
name|archive_member_file_ptr
operator|+=
name|arelt_size
argument_list|(
name|current
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* remember aboout the even alignment */
name|archive_member_file_ptr
operator|+=
name|archive_member_file_ptr
operator|%
literal|2
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
comment|/* now write the strings themselves */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|symbol_count
condition|;
name|count
operator|++
control|)
block|{
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
operator|*
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|name
operator|)
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
operator|*
operator|(
operator|(
name|map
index|[
name|count
index|]
operator|)
operator|.
name|name
operator|)
argument_list|)
operator|+
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
comment|/* The spec sez this should be a newline.  But in order to be        bug-compatible for arc960 we use a null. */
if|if
condition|(
name|padit
condition|)
name|bfd_write
argument_list|(
literal|"\0"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

