begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory-access and commands for remote VxWorks processes, for GDB.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Contributed by Wind River Systems and Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for struct complaint */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_define
define|#
directive|define
name|malloc
value|bogon_malloc
end_define

begin_comment
comment|/* Sun claims "char *malloc()" not void * */
end_comment

begin_define
define|#
directive|define
name|free
value|bogon_free
end_define

begin_comment
comment|/* Sun claims "int free()" not void */
end_comment

begin_define
define|#
directive|define
name|realloc
value|bogon_realloc
end_define

begin_comment
comment|/* Sun claims "char *realloc()", not void * */
end_comment

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* UTek's<rpc/rpc.h> doesn't #incl this */
end_comment

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"vx-share/ptrace.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/xdr_ptrace.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/xdr_ld.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/xdr_rdb.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/dbgRpcLib.h"
end_include

begin_include
include|#
directive|include
file|"vx-share/reg.h"
end_include

begin_include
include|#
directive|include
file|<symtab.h>
end_include

begin_function_decl
specifier|extern
name|void
name|symbol_file_command
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|stop_soon_quietly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for wait_for_inferior */
end_comment

begin_function_decl
specifier|static
name|int
name|net_ptrace_clnt_call
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Forward decl */
end_comment

begin_function_decl
specifier|static
name|enum
name|clnt_stat
name|net_clnt_call
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Forward decl */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|vx_ops
decl_stmt|,
name|vx_run_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_comment
comment|/* Saved name of target host and called function for "info files".    Both malloc'd.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vx_host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vx_running
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called function */
end_comment

begin_comment
comment|/* Nonzero means target that is being debugged remotely has a floating    point processor.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_has_fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default error message when the network is forking up.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rpcerr
index|[]
init|=
literal|"network target debugging:  rpc error"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CLIENT
modifier|*
name|pClient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* client used in net debugging */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ptraceSock
init|=
name|RPC_ANYSOCK
decl_stmt|;
end_decl_stmt

begin_function_decl
name|enum
name|clnt_stat
name|net_clnt_call
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_args
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|rpcTimeout
init|=
block|{
literal|10
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|skip_white_space
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_white_space
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Tell the VxWorks target system to download a file.    The load addresses of the text, data, and bss segments are    stored in *pTextAddr, *pDataAddr, and *pBssAddr (respectively).    Returns 0 for success, -1 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|net_load
parameter_list|(
name|filename
parameter_list|,
name|pTextAddr
parameter_list|,
name|pDataAddr
parameter_list|,
name|pBssAddr
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
modifier|*
name|pTextAddr
decl_stmt|;
name|CORE_ADDR
modifier|*
name|pDataAddr
decl_stmt|;
name|CORE_ADDR
modifier|*
name|pBssAddr
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|struct
name|ldfile
name|ldstruct
decl_stmt|;
name|struct
name|timeval
name|load_timeout
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ldstruct
argument_list|,
sizeof|sizeof
argument_list|(
name|ldstruct
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We invoke clnt_call () here directly, instead of through        net_clnt_call (), because we need to set a large timeout value.        The load on the target side can take quite a while, easily        more than 10 seconds.  The user can kill this call by typing        CTRL-C if there really is a problem with the load.           Do not change the tv_sec value without checking -- select() imposes        a limit of 10**8 on it for no good reason that I can see...  */
name|load_timeout
operator|.
name|tv_sec
operator|=
literal|99999999
expr_stmt|;
comment|/* A large number, effectively inf. */
name|load_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|clnt_call
argument_list|(
name|pClient
argument_list|,
name|VX_LOAD
argument_list|,
name|xdr_wrapstring
argument_list|,
operator|&
name|filename
argument_list|,
name|xdr_ldfile
argument_list|,
operator|&
name|ldstruct
argument_list|,
name|load_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RPC_SUCCESS
condition|)
block|{
if|if
condition|(
operator|*
name|ldstruct
operator|.
name|name
operator|==
literal|0
condition|)
comment|/* load failed on VxWorks side */
return|return
operator|-
literal|1
return|;
operator|*
name|pTextAddr
operator|=
name|ldstruct
operator|.
name|txt_addr
expr_stmt|;
operator|*
name|pDataAddr
operator|=
name|ldstruct
operator|.
name|data_addr
expr_stmt|;
operator|*
name|pBssAddr
operator|=
name|ldstruct
operator|.
name|bss_addr
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* returns 0 if successful, errno if RPC failed or VxWorks complains. */
end_comment

begin_function
specifier|static
name|int
name|net_break
parameter_list|(
name|addr
parameter_list|,
name|procnum
parameter_list|)
name|int
name|addr
decl_stmt|;
name|u_long
name|procnum
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|int
name|break_status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
comment|/* XXX This is stupid.  It doesn't need to be a ptrace                            structure.  How about something smaller? */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|break_status
operator|=
literal|0
expr_stmt|;
name|ptrace_in
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|procnum
argument_list|,
name|xdr_rptrace
argument_list|,
operator|&
name|ptrace_in
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|break_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|break_status
operator|==
operator|-
literal|1
condition|)
return|return
name|ENOMEM
return|;
return|return
name|break_status
return|;
comment|/* probably (FIXME) zero */
block|}
end_function

begin_comment
comment|/* returns 0 if successful, errno otherwise */
end_comment

begin_function
specifier|static
name|int
name|vx_insert_breakpoint
parameter_list|(
name|addr
parameter_list|)
name|int
name|addr
decl_stmt|;
block|{
return|return
name|net_break
argument_list|(
name|addr
argument_list|,
name|VX_BREAK_ADD
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* returns 0 if successful, errno otherwise */
end_comment

begin_function
specifier|static
name|int
name|vx_remove_breakpoint
parameter_list|(
name|addr
parameter_list|)
name|int
name|addr
decl_stmt|;
block|{
return|return
name|net_break
argument_list|(
name|addr
argument_list|,
name|VX_BREAK_DELETE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Start an inferior process and sets inferior_pid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.    Returns process id.  Errors reported with error().    On VxWorks, we ignore exec_file.  */
end_comment

begin_function
specifier|static
name|void
name|vx_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|arg_array
name|passArgs
decl_stmt|;
name|TASK_START
name|taskStart
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|passArgs
argument_list|,
sizeof|sizeof
argument_list|(
name|passArgs
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|taskStart
argument_list|,
sizeof|sizeof
argument_list|(
name|taskStart
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse arguments, put them in passArgs */
name|parse_args
argument_list|(
name|args
argument_list|,
operator|&
name|passArgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|passArgs
operator|.
name|arg_array_len
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"You must specify a function name to run, and arguments if any"
argument_list|)
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|PROCESS_START
argument_list|,
name|xdr_arg_array
argument_list|,
operator|&
name|passArgs
argument_list|,
name|xdr_TASK_START
argument_list|,
operator|&
name|taskStart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|RPC_SUCCESS
operator|)
operator|||
operator|(
name|taskStart
operator|.
name|status
operator|==
operator|-
literal|1
operator|)
condition|)
name|error
argument_list|(
literal|"Can't create process on remote target machine"
argument_list|)
expr_stmt|;
comment|/* Save the name of the running function */
name|vx_running
operator|=
name|savestring
argument_list|(
name|passArgs
operator|.
name|arg_array_val
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|passArgs
operator|.
name|arg_array_val
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CREATE_INFERIOR_HOOK
name|CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|push_target
argument_list|(
operator|&
name|vx_run_ops
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|taskStart
operator|.
name|pid
expr_stmt|;
comment|/* We will get a trace trap after one instruction.      Insert breakpoints and continue.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Get the task spawn event */
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill ARGSTRUCT in argc/argv form with the arguments from the    argument string ARGSTRING.  */
end_comment

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|arg_string
parameter_list|,
name|arg_struct
parameter_list|)
specifier|register
name|char
modifier|*
name|arg_string
decl_stmt|;
name|arg_array
modifier|*
name|arg_struct
decl_stmt|;
block|{
specifier|register
name|int
name|arg_count
init|=
literal|0
decl_stmt|;
comment|/* number of arguments */
specifier|register
name|int
name|arg_index
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p0
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg_struct
argument_list|,
sizeof|sizeof
argument_list|(
name|arg_array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first count how many arguments there are */
name|p0
operator|=
name|arg_string
expr_stmt|;
while|while
condition|(
operator|*
name|p0
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p0
operator|=
name|skip_white_space
argument_list|(
name|p0
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
break|break;
name|p0
operator|=
name|find_white_space
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|arg_count
operator|++
expr_stmt|;
block|}
name|arg_struct
operator|->
name|arg_array_len
operator|=
name|arg_count
expr_stmt|;
name|arg_struct
operator|->
name|arg_array_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|arg_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now copy argument strings into arg_struct.  */
while|while
condition|(
operator|*
operator|(
name|arg_string
operator|=
name|skip_white_space
argument_list|(
name|arg_string
argument_list|)
operator|)
condition|)
block|{
name|p0
operator|=
name|find_white_space
argument_list|(
name|arg_string
argument_list|)
expr_stmt|;
name|arg_struct
operator|->
name|arg_array_val
index|[
name|arg_index
operator|++
index|]
operator|=
name|savestring
argument_list|(
name|arg_string
argument_list|,
name|p0
operator|-
name|arg_string
argument_list|)
expr_stmt|;
name|arg_string
operator|=
name|p0
expr_stmt|;
block|}
name|arg_struct
operator|->
name|arg_array_val
index|[
name|arg_count
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance a string pointer across whitespace and return a pointer    to the first non-white character.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skip_white_space
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Search for the first unquoted whitespace character in a string.    Returns a pointer to the character, or to the null terminator    if no whitespace is found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_white_space
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
name|c
operator|&&
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Poll the VxWorks target system for an event related    to the debugged task.    Returns -1 if remote wait failed, task status otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|net_wait
parameter_list|(
name|pEvent
parameter_list|)
name|RDB_EVENT
modifier|*
name|pEvent
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pEvent
argument_list|,
sizeof|sizeof
argument_list|(
name|RDB_EVENT
argument_list|)
argument_list|)
expr_stmt|;
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|PROCESS_WAIT
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|pid
argument_list|,
name|xdr_RDB_EVENT
argument_list|,
name|pEvent
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|RPC_SUCCESS
operator|)
condition|?
name|pEvent
operator|->
name|status
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Suspend the remote task.    Returns -1 if suspend fails on target system, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|net_quit
parameter_list|()
block|{
name|int
name|pid
decl_stmt|;
name|int
name|quit_status
decl_stmt|;
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|quit_status
operator|=
literal|0
expr_stmt|;
comment|/* don't let rdbTask suspend itself by passing a pid of 0 */
if|if
condition|(
operator|(
name|pid
operator|=
name|inferior_pid
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_TASK_SUSPEND
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|pid
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|quit_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|RPC_SUCCESS
operator|)
condition|?
name|quit_status
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read a register or registers from the remote system.  */
end_comment

begin_function
specifier|static
name|void
name|vx_read_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|C_bytes
name|in_data
decl_stmt|;
name|C_bytes
name|out_data
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME, eventually only get the ones we need.  */
name|registers_fetched
argument_list|()
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|ptrace_out
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|out_data
expr_stmt|;
ifndef|#
directive|ifndef
name|I80960
name|out_data
operator|.
name|len
operator|=
literal|18
operator|*
name|REGISTER_RAW_SIZE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME 68k hack */
else|#
directive|else
name|out_data
operator|.
name|len
operator|=
operator|(
literal|16
operator|+
literal|16
operator|+
literal|3
operator|)
operator|*
name|REGISTER_RAW_SIZE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out_data
operator|.
name|bytes
operator|=
operator|(
name|caddr_t
operator|)
name|registers
expr_stmt|;
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_GETREGS
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"net_ptrace_clnt_call(PTRACE_GETREGS)"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|I80960
block|{
comment|/* If the target has floating point registers, fetch them.        Otherwise, zero the floating point register values in        registers[] for good measure, even though we might not        need to.  */
comment|/* @@ Can't use this -- the rdb library for the 960 target        doesn't support setting or retrieving FP regs.  KR  */
if|#
directive|if
literal|0
block|struct fp_status inferior_fp_registers;      if (target_has_fp)       { 	ptrace_in.pid = inferior_pid; 	ptrace_out.info.more_data = (caddr_t)&inferior_fp_registers; 	status = net_ptrace_clnt_call (PTRACE_GETFPREGS,&ptrace_in,&ptrace_out); 	if (status) 	  error (rpcerr); 	if (ptrace_out.status == -1) 	  { 	    errno = ptrace_out.errno; 	    perror_with_name ("net_ptrace_clnt_call(PTRACE_GETFPREGS)"); 	  }  	bcopy (&inferior_fp_registers,&registers[REGISTER_BYTE (FP0_REGNUM)], 	       REGISTER_RAW_SIZE (FP0_REGNUM) * 4);       }     else       { 	bzero ((char *)&registers[REGISTER_BYTE (FP0_REGNUM)], 	       REGISTER_RAW_SIZE (FP0_REGNUM) * 4);       }
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* not 960, thus must be 68000:  FIXME!  */
if|if
condition|(
name|target_has_fp
condition|)
block|{
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|ptrace_out
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|out_data
expr_stmt|;
name|out_data
operator|.
name|len
operator|=
literal|8
operator|*
name|REGISTER_RAW_SIZE
argument_list|(
name|FP0_REGNUM
argument_list|)
comment|/* FIXME */
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
operator|)
expr_stmt|;
name|out_data
operator|.
name|bytes
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
expr_stmt|;
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"net_ptrace_clnt_call(PTRACE_GETFPREGS)"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bzero
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
literal|8
operator|*
name|REGISTER_RAW_SIZE
argument_list|(
name|FP0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* various architectures */
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  Since we will store all of them,    read out their current values now.  */
end_comment

begin_function
specifier|static
name|void
name|vx_prepare_to_store
parameter_list|()
block|{
comment|/* Fetch all registers, if any of them are not yet fetched.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_comment
comment|/* FIXME, look at REGNO to save time here */
end_comment

begin_function
specifier|static
name|void
name|vx_write_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|C_bytes
name|in_data
decl_stmt|;
name|C_bytes
name|out_data
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|ttype
operator|=
name|DATA
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|in_data
expr_stmt|;
name|in_data
operator|.
name|bytes
operator|=
name|registers
expr_stmt|;
ifdef|#
directive|ifdef
name|I80960
name|in_data
operator|.
name|len
operator|=
operator|(
literal|16
operator|+
literal|16
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not 960 -- assume 68k -- FIXME */
name|in_data
operator|.
name|len
operator|=
literal|18
operator|*
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Different register sets */
comment|/* XXX change second param to be a proc number */
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_SETREGS
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"net_ptrace_clnt_call(PTRACE_SETREGS)"
argument_list|)
expr_stmt|;
block|}
comment|/* Store floating point registers if the target has them.  */
if|if
condition|(
name|target_has_fp
condition|)
block|{
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|ttype
operator|=
name|DATA
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|in_data
expr_stmt|;
ifdef|#
directive|ifdef
name|I80960
if|#
directive|if
literal|0
comment|/* @@ Not supported by target.  */
block|in_data.bytes =&registers[REGISTER_BYTE (FP0_REGNUM)];       in_data.len = 4 * REGISTER_RAW_SIZE (FP0_REGNUM);
endif|#
directive|endif
else|#
directive|else
comment|/* not 960 -- assume 68k -- FIXME */
name|in_data
operator|.
name|bytes
operator|=
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
expr_stmt|;
name|in_data
operator|.
name|len
operator|=
operator|(
literal|8
operator|*
name|REGISTER_RAW_SIZE
argument_list|(
name|FP0_REGNUM
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* Different register sets */
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"net_ptrace_clnt_call(PTRACE_SETFPREGS)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copy LEN bytes to or from remote inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  WRITE is true if writing to the    inferior.    Result is the number of bytes written or read (zero if error).  The    protocol allows us to return a negative count, indicating that we can't    handle the current address but can handle one N bytes further, but    vxworks doesn't give us that information.  */
end_comment

begin_function
specifier|static
name|int
name|vx_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|C_bytes
name|data
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
comment|/* XXX pid unnecessary for READDATA */
name|ptrace_in
operator|.
name|addr
operator|=
operator|(
name|int
operator|)
name|memaddr
expr_stmt|;
comment|/* Where from */
name|ptrace_in
operator|.
name|data
operator|=
name|len
expr_stmt|;
comment|/* How many bytes */
if|if
condition|(
name|write
condition|)
block|{
name|ptrace_in
operator|.
name|info
operator|.
name|ttype
operator|=
name|DATA
expr_stmt|;
name|ptrace_in
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|data
expr_stmt|;
name|data
operator|.
name|bytes
operator|=
operator|(
name|caddr_t
operator|)
name|myaddr
expr_stmt|;
comment|/* Where from */
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* How many bytes (again, for XDR) */
comment|/* XXX change second param to be a proc number */
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_WRITEDATA
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptrace_out
operator|.
name|info
operator|.
name|more_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|data
expr_stmt|;
name|data
operator|.
name|bytes
operator|=
name|myaddr
expr_stmt|;
comment|/* Where to */
name|data
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* How many (again, for XDR) */
comment|/* XXX change second param to be a proc number */
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_READDATA
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
comment|/* No bytes moved */
block|}
return|return
name|len
return|;
comment|/* Moved *all* the bytes */
block|}
end_function

begin_function
specifier|static
name|void
name|vx_files_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\tAttached to host `%s'"
argument_list|,
name|vx_host
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", which has %sfloating point"
argument_list|,
name|target_has_fp
condition|?
literal|""
else|:
literal|"no "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_run_files_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\tRunning %s VxWorks process %s"
argument_list|,
name|vx_running
condition|?
literal|"child"
else|:
literal|"attached"
argument_list|,
name|local_hex_string
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vx_running
condition|)
name|printf
argument_list|(
literal|", function `%s'"
argument_list|,
name|vx_running
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vx_resume
parameter_list|(
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|siggnal
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
if|if
condition|(
name|siggnal
operator|!=
literal|0
operator|&&
name|siggnal
operator|!=
name|stop_signal
condition|)
name|error
argument_list|(
literal|"Cannot send signals to VxWorks processes"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|ptrace_in
operator|.
name|addr
operator|=
literal|1
expr_stmt|;
comment|/* Target side insists on this, or it panics.  */
comment|/* XXX change second param to be a proc number */
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|step
condition|?
name|PTRACE_SINGLESTEP
else|:
name|PTRACE_CONT
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"Resuming remote process"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vx_mourn_inferior
parameter_list|()
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* Pop back to no-child state */
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function allows the addition of incrementally linked object files.  */
end_comment

begin_function
specifier|static
name|void
name|vx_load_command
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|CORE_ADDR
name|data_addr
decl_stmt|;
name|CORE_ADDR
name|bss_addr
decl_stmt|;
if|if
condition|(
name|arg_string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The load command takes a file name"
argument_list|)
expr_stmt|;
name|arg_string
operator|=
name|tilde_expand
argument_list|(
name|arg_string
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|QUIT
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
if|if
condition|(
name|net_load
argument_list|(
name|arg_string
argument_list|,
operator|&
name|text_addr
argument_list|,
operator|&
name|data_addr
argument_list|,
operator|&
name|bss_addr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Load failed on target machine"
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
comment|/* FIXME, for now we ignore data_addr and bss_addr.  */
name|symbol_file_add
argument_list|(
name|arg_string
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FIXME
end_ifdef

begin_comment
comment|/* Not ready for prime time */
end_comment

begin_comment
comment|/* Single step the target program at the source or machine level.    Takes an error exit if rpc fails.    Returns -1 if remote single-step operation fails, else 0.  */
end_comment

begin_function
specifier|static
name|int
name|net_step
parameter_list|()
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|int
name|step_status
decl_stmt|;
name|SOURCE_STEP
name|source_step
decl_stmt|;
name|source_step
operator|.
name|taskId
operator|=
name|inferior_pid
expr_stmt|;
if|if
condition|(
name|step_range_end
condition|)
block|{
name|source_step
operator|.
name|startAddr
operator|=
name|step_range_start
expr_stmt|;
name|source_step
operator|.
name|endAddr
operator|=
name|step_range_end
expr_stmt|;
block|}
else|else
block|{
name|source_step
operator|.
name|startAddr
operator|=
literal|0
expr_stmt|;
name|source_step
operator|.
name|endAddr
operator|=
literal|0
expr_stmt|;
block|}
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_SOURCE_STEP
argument_list|,
name|xdr_SOURCE_STEP
argument_list|,
operator|&
name|source_step
argument_list|,
name|xdr_int
argument_list|,
operator|&
name|step_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|RPC_SUCCESS
condition|)
return|return
name|step_status
return|;
else|else
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Emulate ptrace using RPC calls to the VxWorks target system.    Returns nonzero (-1) if RPC status to VxWorks is bad, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|net_ptrace_clnt_call
parameter_list|(
name|request
parameter_list|,
name|pPtraceIn
parameter_list|,
name|pPtraceOut
parameter_list|)
name|enum
name|ptracereq
name|request
decl_stmt|;
name|Rptrace
modifier|*
name|pPtraceIn
decl_stmt|;
name|Ptrace_return
modifier|*
name|pPtraceOut
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|request
argument_list|,
name|xdr_rptrace
argument_list|,
name|pPtraceIn
argument_list|,
name|xdr_ptrace_return
argument_list|,
name|pPtraceOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Query the target for the name of the file from which VxWorks was    booted.  pBootFile is the address of a pointer to the buffer to    receive the file name; if the pointer pointed to by pBootFile is     NULL, memory for the buffer will be allocated by XDR.    Returns -1 if rpc failed, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|net_get_boot_file
parameter_list|(
name|pBootFile
parameter_list|)
name|char
modifier|*
modifier|*
name|pBootFile
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_BOOT_FILE_INQ
argument_list|,
name|xdr_void
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|xdr_wrapstring
argument_list|,
name|pBootFile
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|RPC_SUCCESS
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fetch a list of loaded object modules from the VxWorks target.    Returns -1 if rpc failed, 0 otherwise    There's no way to check if the returned loadTable is correct.    VxWorks doesn't check it.  */
end_comment

begin_function
specifier|static
name|int
name|net_get_symbols
parameter_list|(
name|pLoadTable
parameter_list|)
name|ldtabl
modifier|*
name|pLoadTable
decl_stmt|;
comment|/* return pointer to ldtabl here */
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pLoadTable
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ldtabl
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_STATE_INQ
argument_list|,
name|xdr_void
argument_list|,
literal|0
argument_list|,
name|xdr_ldtabl
argument_list|,
name|pLoadTable
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|RPC_SUCCESS
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Look up a symbol in the VxWorks target's symbol table.    Returns status of symbol read on target side (0=success, -1=fail)    Returns -1 and complain()s if rpc fails.  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|cant_contact_target
init|=
block|{
literal|"Lost contact with VxWorks target"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vx_lookup_symbol
parameter_list|(
name|name
parameter_list|,
name|pAddr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* symbol name */
name|CORE_ADDR
modifier|*
name|pAddr
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|SYMBOL_ADDR
name|symbolAddr
decl_stmt|;
operator|*
name|pAddr
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolAddr
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolAddr
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_SYMBOL_INQ
argument_list|,
name|xdr_wrapstring
argument_list|,
operator|&
name|name
argument_list|,
name|xdr_SYMBOL_ADDR
argument_list|,
operator|&
name|symbolAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
block|{
name|complain
argument_list|(
operator|&
name|cant_contact_target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|pAddr
operator|=
name|symbolAddr
operator|.
name|addr
expr_stmt|;
return|return
name|symbolAddr
operator|.
name|status
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the VxWorks target has a floating point coprocessor.    Returns 1 if target has floating point processor, 0 otherwise.    Calls error() if rpc fails.  */
end_comment

begin_function
specifier|static
name|int
name|net_check_for_fp
parameter_list|()
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|bool_t
name|fp
init|=
literal|0
decl_stmt|;
comment|/* true if fp processor is present on target board */
name|status
operator|=
name|net_clnt_call
argument_list|(
name|VX_FP_INQUIRE
argument_list|,
name|xdr_void
argument_list|,
literal|0
argument_list|,
name|xdr_bool
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Establish an RPC connection with the VxWorks target system.    Calls error () if unable to establish connection.  */
end_comment

begin_function
specifier|static
name|void
name|net_connect
parameter_list|(
name|host
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|destAddr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|destHost
decl_stmt|;
comment|/* get the internet address for the given host */
if|if
condition|(
operator|(
name|destHost
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|gethostbyname
argument_list|(
name|host
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Invalid hostname.  Couldn't find remote host address."
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|destAddr
argument_list|,
sizeof|sizeof
argument_list|(
name|destAddr
argument_list|)
argument_list|)
expr_stmt|;
name|destAddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
name|destHost
operator|->
name|h_addr
expr_stmt|;
name|destAddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|destAddr
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* set to actual port that remote 			           ptrace is listening on.  */
comment|/* Create a tcp client transport on which to issue      calls to the remote ptrace server.  */
name|ptraceSock
operator|=
name|RPC_ANYSOCK
expr_stmt|;
name|pClient
operator|=
name|clnttcp_create
argument_list|(
operator|&
name|destAddr
argument_list|,
name|RDBPROG
argument_list|,
name|RDBVERS
argument_list|,
operator|&
name|ptraceSock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME, here is where we deal with different version numbers of the proto */
if|if
condition|(
name|pClient
operator|==
name|NULL
condition|)
block|{
name|clnt_pcreateerror
argument_list|(
literal|"\tnet_connect"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Couldn't connect to remote target."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sleep for the specified number of milliseconds   * (assumed to be less than 1000).  * If select () is interrupted, returns immediately;  * takes an error exit if select () fails for some other reason.  */
end_comment

begin_function
specifier|static
name|void
name|sleep_ms
parameter_list|(
name|ms
parameter_list|)
name|long
name|ms
decl_stmt|;
block|{
name|struct
name|timeval
name|select_timeout
decl_stmt|;
name|int
name|status
decl_stmt|;
name|select_timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|select_timeout
operator|.
name|tv_usec
operator|=
name|ms
operator|*
literal|1000
expr_stmt|;
name|status
operator|=
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|select_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|perror_with_name
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for control to return from inferior to debugger.    If inferior gets a signal, we may decide to start it up again    instead of returning.  That is why there is a loop in this function.    When this function actually returns it means the inferior    should be left stopped and GDB should read more commands.  */
end_comment

begin_comment
comment|/* For network debugging with VxWorks.  * VxWorks knows when tasks hit breakpoints, receive signals, exit, etc,  * so vx_wait() receives this information directly from  * VxWorks instead of trying to figure out what happenned via a wait() call.  */
end_comment

begin_function
specifier|static
name|int
name|vx_wait
parameter_list|(
name|status
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
block|{
specifier|register
name|int
name|pid
decl_stmt|;
name|WAITTYPE
name|w
decl_stmt|;
name|RDB_EVENT
name|rdbEvent
decl_stmt|;
name|int
name|quit_failed
decl_stmt|;
do|do
block|{
comment|/* If CTRL-C is hit during this loop, 	 suspend the inferior process.  */
name|quit_failed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|quit_flag
condition|)
block|{
name|quit_failed
operator|=
operator|(
name|net_quit
argument_list|()
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If a net_quit () or net_wait () call has failed, 	 allow the user to break the connection with the target. 	 We can't simply error () out of this loop, since the  	 data structures representing the state of the inferior 	 are in an inconsistent state.  */
if|if
condition|(
name|quit_failed
operator|||
name|net_wait
argument_list|(
operator|&
name|rdbEvent
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Can't %s.  Disconnect from target system? "
argument_list|,
operator|(
name|quit_failed
operator|)
condition|?
literal|"suspend remote task"
else|:
literal|"get status of remote task"
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Use the \"target\" command to reconnect."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminal_inferior
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
name|pid
operator|=
name|rdbEvent
operator|.
name|taskId
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|sleep_ms
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* FIXME Don't kill the network too badly */
block|}
elseif|else
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
name|fatal
argument_list|(
literal|"Bad pid for debugged task: %s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid
operator|==
literal|0
condition|)
do|;
comment|/* FIXME, eventually do more then SIGTRAP on everything...  */
switch|switch
condition|(
name|rdbEvent
operator|.
name|eventType
condition|)
block|{
case|case
name|EVENT_EXIT
case|:
name|WSETEXIT
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME is it possible to distinguish between a 	 XXX   normal vs abnormal exit in VxWorks? */
break|break;
case|case
name|EVENT_START
case|:
comment|/* Task was just started. */
name|WSETSTOP
argument_list|(
name|w
argument_list|,
name|SIGTRAP
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVENT_STOP
case|:
name|WSETSTOP
argument_list|(
name|w
argument_list|,
name|SIGTRAP
argument_list|)
expr_stmt|;
comment|/* XXX was it stopped by a signal?  act accordingly */
break|break;
case|case
name|EVENT_BREAK
case|:
comment|/* Breakpoint was hit. */
name|WSETSTOP
argument_list|(
name|w
argument_list|,
name|SIGTRAP
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVENT_SUSPEND
case|:
comment|/* Task was suspended, probably by ^C. */
name|WSETSTOP
argument_list|(
name|w
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVENT_BUS_ERR
case|:
comment|/* Task made evil nasty reference. */
name|WSETSTOP
argument_list|(
name|w
argument_list|,
name|SIGBUS
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVENT_ZERO_DIV
case|:
comment|/* Division by zero */
name|WSETSTOP
argument_list|(
name|w
argument_list|,
name|SIGFPE
argument_list|)
expr_stmt|;
comment|/* Like Unix, call it a float exception. */
break|break;
case|case
name|EVENT_SIGNAL
case|:
comment|/* The target is not running Unix, and its 	 faults/traces do not map nicely into Unix signals. 	 Make sure they do not get confused with Unix signals 	 by numbering them with values higher than the highest 	 legal Unix signal.  code in the arch-dependent PRINT_RANDOM_SIGNAL 	 routine will interpret the value for wait_for_inferior.  */
name|WSETSTOP
argument_list|(
name|w
argument_list|,
name|rdbEvent
operator|.
name|sigType
operator|+
name|NSIG
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
operator|*
name|status
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|w
expr_stmt|;
comment|/* Grumble union wait crap Grumble */
return|return
name|pid
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|symbol_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|symbol_file_command
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_symbol_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ldfile
modifier|*
name|pLoadFile
init|=
operator|(
expr|struct
name|ldfile
operator|*
operator|)
name|arg
decl_stmt|;
name|printf
argument_list|(
literal|"\t%s: "
argument_list|,
name|pLoadFile
operator|->
name|name
argument_list|)
expr_stmt|;
name|symbol_file_add
argument_list|(
name|pLoadFile
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|pLoadFile
operator|->
name|txt_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Target command for VxWorks target systems.     Used in vxgdb.  Takes the name of a remote target machine    running vxWorks and connects to it to initialize remote network    debugging.  */
end_comment

begin_function
specifier|static
name|void
name|vx_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|extern
name|int
name|close
parameter_list|()
function_decl|;
name|char
modifier|*
name|bootFile
decl_stmt|;
specifier|extern
name|char
modifier|*
name|source_path
decl_stmt|;
name|struct
name|ldtabl
name|loadTable
decl_stmt|;
name|struct
name|ldfile
modifier|*
name|pLoadFile
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|CLIENT
modifier|*
name|pClient
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"target machine name"
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|vx_ops
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Attaching remote machine across net...\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Allow the user to kill the connect attempt by typing ^C.      Wait until the call to target_has_fp () completes before      disallowing an immediate quit, since even if net_connect ()      is successful, the remote debug server might be hung.  */
name|immediate_quit
operator|++
expr_stmt|;
name|net_connect
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|target_has_fp
operator|=
name|net_check_for_fp
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Connected to %s.\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|vx_ops
argument_list|)
expr_stmt|;
comment|/* Save a copy of the target host's name.  */
name|vx_host
operator|=
name|savestring
argument_list|(
name|args
argument_list|,
name|strlen
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find out the name of the file from which the target was booted      and load its symbol table.  */
name|printf_filtered
argument_list|(
literal|"Looking in Unix path for all loaded modules:\n"
argument_list|)
expr_stmt|;
name|bootFile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|net_get_boot_file
argument_list|(
operator|&
name|bootFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|bootFile
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%s: "
argument_list|,
name|bootFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|catch_errors
argument_list|(
name|symbol_stub
argument_list|,
name|bootFile
argument_list|,
literal|"Error while reading symbols from boot file:\n"
argument_list|)
condition|)
name|puts_filtered
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"VxWorks kernel symbols not loaded.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Can't retrieve boot file name from target machine."
argument_list|)
expr_stmt|;
name|clnt_freeres
argument_list|(
name|pClient
argument_list|,
name|xdr_wrapstring
argument_list|,
operator|&
name|bootFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|net_get_symbols
argument_list|(
operator|&
name|loadTable
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Can't read loaded modules from target machine"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|loadTable
operator|.
name|tbl_size
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* FIXME, avoids clnt_freeres below:  mem leak */
name|pLoadFile
operator|=
operator|&
name|loadTable
operator|.
name|tbl_ent
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|WRS_ORIG
block|{
specifier|register
name|int
name|desc
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|fullname
init|=
name|NULL
decl_stmt|;
name|desc
operator|=
name|openp
argument_list|(
name|source_path
argument_list|,
literal|0
argument_list|,
name|pLoadFile
operator|->
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|pLoadFile
operator|->
name|name
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|close
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|add_file_at_addr
argument_list|(
name|fullname
argument_list|,
name|desc
argument_list|,
name|pLoadFile
operator|->
name|txt_addr
argument_list|,
name|pLoadFile
operator|->
name|data_addr
argument_list|,
name|pLoadFile
operator|->
name|bss_addr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Botches, FIXME: 	 (1)  Searches the PATH, not the source path. 	 (2)  data and bss are assumed to be at the usual offsets from text.  */
name|catch_errors
argument_list|(
name|add_symbol_stub
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pLoadFile
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|printf_filtered
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
name|clnt_freeres
argument_list|(
name|pClient
argument_list|,
name|xdr_ldtabl
argument_list|,
operator|&
name|loadTable
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Takes a task started up outside of gdb and ``attaches'' to it.    This stops it cold in its tracks and allows us to start tracing it.  */
end_comment

begin_function
specifier|static
name|void
name|vx_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|cptr
init|=
literal|0
decl_stmt|;
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|strtol
argument_list|(
name|args
argument_list|,
operator|&
name|cptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|==
name|args
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|!=
literal|'\0'
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid process-id -- give a single number in decimal or 0xhex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Attaching pid %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_ATTACH
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"Attaching remote process"
argument_list|)
expr_stmt|;
block|}
comment|/* It worked... */
name|push_target
argument_list|(
operator|&
name|vx_run_ops
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|vx_running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* detach_command --    takes a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|vx_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|int
name|signal
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to VxWorks \"detach\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Detaching pid %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
comment|/* FIXME, should be possible to leave suspended */
name|signal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_DETACH
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"Detaching VxWorks process"
argument_list|)
expr_stmt|;
block|}
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
comment|/* go back to non-executing VxWorks connection */
block|}
end_function

begin_comment
comment|/* vx_kill -- takes a running task and wipes it out.  */
end_comment

begin_function
specifier|static
name|void
name|vx_kill
parameter_list|()
block|{
name|Rptrace
name|ptrace_in
decl_stmt|;
name|Ptrace_return
name|ptrace_out
decl_stmt|;
name|int
name|status
decl_stmt|;
name|printf
argument_list|(
literal|"Killing pid %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_in
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_in
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ptrace_out
argument_list|,
sizeof|sizeof
argument_list|(
name|ptrace_out
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace_in
operator|.
name|pid
operator|=
name|inferior_pid
expr_stmt|;
name|status
operator|=
name|net_ptrace_clnt_call
argument_list|(
name|PTRACE_KILL
argument_list|,
operator|&
name|ptrace_in
argument_list|,
operator|&
name|ptrace_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
name|rpcerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace_out
operator|.
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ptrace_out
operator|.
name|errno
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"Killing VxWorks process"
argument_list|)
expr_stmt|;
block|}
comment|/* If it gives good status, the process is *gone*, no events remain.  */
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
comment|/* go back to non-executing VxWorks connection */
block|}
end_function

begin_comment
comment|/* Clean up from the VxWorks process target as it goes away.  */
end_comment

begin_function
specifier|static
name|void
name|vx_proc_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* No longer have a process.  */
if|if
condition|(
name|vx_running
condition|)
name|free
argument_list|(
name|vx_running
argument_list|)
expr_stmt|;
name|vx_running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an RPC call to the VxWorks target.    Returns RPC status.  */
end_comment

begin_function
specifier|static
name|enum
name|clnt_stat
name|net_clnt_call
parameter_list|(
name|procNum
parameter_list|,
name|inProc
parameter_list|,
name|in
parameter_list|,
name|outProc
parameter_list|,
name|out
parameter_list|)
name|enum
name|ptracereq
name|procNum
decl_stmt|;
name|xdrproc_t
name|inProc
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|;
name|xdrproc_t
name|outProc
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
block|{
name|enum
name|clnt_stat
name|status
decl_stmt|;
name|status
operator|=
name|clnt_call
argument_list|(
name|pClient
argument_list|,
name|procNum
argument_list|,
name|inProc
argument_list|,
name|in
argument_list|,
name|outProc
argument_list|,
name|out
argument_list|,
name|rpcTimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|RPC_SUCCESS
condition|)
name|clnt_perrno
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Clean up before losing control.  */
end_comment

begin_function
specifier|static
name|void
name|vx_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|pClient
condition|)
name|clnt_destroy
argument_list|(
name|pClient
argument_list|)
expr_stmt|;
comment|/* The net connection */
name|pClient
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vx_host
condition|)
name|free
argument_list|(
name|vx_host
argument_list|)
expr_stmt|;
comment|/* The hostname */
name|vx_host
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A vxprocess target should be started via "run" not "target".  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|vx_proc_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a VxWorks process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Target ops structure for accessing memory and such over the net */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|vx_ops
init|=
block|{
literal|"vxworks"
block|,
literal|"VxWorks target memory via RPC over TCP/IP"
block|,
literal|"Use VxWorks target memory.  \n\ Specify the name of the machine to connect to."
block|,
name|vx_open
block|,
name|vx_close
block|,
name|vx_attach
block|,
literal|0
block|,
comment|/* vx_detach, */
literal|0
block|,
literal|0
block|,
comment|/* resume, wait */
literal|0
block|,
literal|0
block|,
comment|/* read_reg, write_reg */
literal|0
block|,
comment|/* prep_to_store, */
name|vx_xfer_memory
block|,
name|vx_files_info
block|,
literal|0
block|,
literal|0
block|,
comment|/* insert_breakpoint, remove_breakpoint */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* terminal stuff */
literal|0
block|,
comment|/* vx_kill, */
name|vx_load_command
block|,
name|vx_lookup_symbol
block|,
name|vx_create_inferior
block|,
literal|0
block|,
comment|/* mourn_inferior */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|core_stratum
block|,
literal|0
block|,
comment|/* next */
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* Section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target ops structure for accessing VxWorks child processes over the net */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|vx_run_ops
init|=
block|{
literal|"vxprocess"
block|,
literal|"VxWorks process"
block|,
literal|"VxWorks process, started by the \"run\" command."
block|,
name|vx_proc_open
block|,
name|vx_proc_close
block|,
literal|0
block|,
name|vx_detach
block|,
comment|/* vx_attach */
name|vx_resume
block|,
name|vx_wait
block|,
name|vx_read_register
block|,
name|vx_write_register
block|,
name|vx_prepare_to_store
block|,
name|vx_xfer_memory
block|,
name|vx_run_files_info
block|,
name|vx_insert_breakpoint
block|,
name|vx_remove_breakpoint
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* terminal stuff */
name|vx_kill
block|,
name|vx_load_command
block|,
name|vx_lookup_symbol
block|,
literal|0
block|,
name|vx_mourn_inferior
block|,
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|process_stratum
block|,
literal|0
block|,
comment|/* next */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* all mem, mem, stack, regs, exec */
comment|/* all_mem is off to avoid spurious msg in "i files" */
literal|0
block|,
literal|0
block|,
comment|/* Section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==> Remember when reading at end of file, there are two "ops" structs here. */
end_comment

begin_escape
end_escape

begin_function
name|void
name|_initialize_vx
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|vx_ops
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|vx_run_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

