begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* General utility routines for GDB, the GNU debugger.    Copyright 1986, 1989, 1990, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_MALLOC_CHECK
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|malloc_botch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MALLOC_CHECK  */
end_comment

begin_function_decl
specifier|static
name|void
name|fatal_dump_core
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Can't prototype with<varargs.h> usage... */
end_comment

begin_decl_stmt
specifier|static
name|void
name|prompt_for_continue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_width_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Chain of cleanup actions established with make_cleanup,    to be executed if an error happens.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|cleanup_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a quit has been requested.  */
end_comment

begin_decl_stmt
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means quit immediately if Control-C is typed now,    rather than waiting until QUIT is executed.  */
end_comment

begin_decl_stmt
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that encoded C++ names should be printed out in their    C++ form rather than raw.  */
end_comment

begin_decl_stmt
name|int
name|demangle
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that encoded C++ names should be printed out in their    C++ form even in assembler language displays.  If this is set, but    DEMANGLE is zero, names are printed raw, i.e. DEMANGLE controls.  */
end_comment

begin_decl_stmt
name|int
name|asm_demangle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that strings with character values>0x7F should be printed    as octal escapes.  Zero means just print the value (e.g. it's an    international character, and the terminal or window can cope.)  */
end_comment

begin_decl_stmt
name|int
name|sevenbit_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String to be printed before error messages, if any.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|error_pre_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|warning_pre_print
init|=
literal|"\nwarning: "
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Add a new cleanup to the cleanup_chain,    and return the previous chain pointer    to be passed later to do_cleanups or discard_cleanups.    Args are FUNCTION to clean up with, and ARG to pass to it.  */
end_comment

begin_function_decl
name|struct
name|cleanup
modifier|*
name|make_cleanup
parameter_list|(
name|function
parameter_list|,
name|arg
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*function
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|new
init|=
operator|(
expr|struct
name|cleanup
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cleanup
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|cleanup_chain
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|cleanup_chain
expr_stmt|;
name|new
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|new
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|cleanup_chain
operator|=
name|new
expr_stmt|;
return|return
name|old_chain
return|;
block|}
end_block

begin_comment
comment|/* Discard cleanups and do the actions they describe    until we get back to the point OLD_CHAIN in the cleanup_chain.  */
end_comment

begin_function
name|void
name|do_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
name|cleanup_chain
operator|)
operator|!=
name|old_chain
condition|)
block|{
name|cleanup_chain
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
comment|/* Do this first incase recursion */
call|(
modifier|*
name|ptr
operator|->
name|function
call|)
argument_list|(
name|ptr
operator|->
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Discard cleanups, not doing the actions they describe,    until we get back to the point OLD_CHAIN in the cleanup_chain.  */
end_comment

begin_function
name|void
name|discard_cleanups
parameter_list|(
name|old_chain
parameter_list|)
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|=
name|cleanup_chain
operator|)
operator|!=
name|old_chain
condition|)
block|{
name|cleanup_chain
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the cleanup_chain to 0, and return the old cleanup chain.  */
end_comment

begin_function
name|struct
name|cleanup
modifier|*
name|save_cleanups
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|cleanup_chain
decl_stmt|;
name|cleanup_chain
operator|=
literal|0
expr_stmt|;
return|return
name|old_chain
return|;
block|}
end_function

begin_comment
comment|/* Restore the cleanup chain from a previously saved chain.  */
end_comment

begin_function
name|void
name|restore_cleanups
parameter_list|(
name|chain
parameter_list|)
name|struct
name|cleanup
modifier|*
name|chain
decl_stmt|;
block|{
name|cleanup_chain
operator|=
name|chain
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is useful for cleanups.    Do       foo = xmalloc (...);      old_chain = make_cleanup (free_current_contents,&foo);     to arrange to free the object thus allocated.  */
end_comment

begin_function
name|void
name|free_current_contents
parameter_list|(
name|location
parameter_list|)
name|char
modifier|*
modifier|*
name|location
decl_stmt|;
block|{
name|free
argument_list|(
operator|*
name|location
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Provide a known function that does nothing, to use as a base for    for a possibly long chain of cleanups.  This is useful where we    use the cleanup chain for handling normal cleanups as well as dealing    with cleanups that need to be done as a result of a call to error().    In such cases, we may not be certain where the first cleanup is, unless    we have a do-nothing one to always use as the base. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|null_cleanup
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide a hook for modules wishing to print their own warning messages    to set up the terminal state in a compatible way, without them having    to import all the target_<...> macros. */
end_comment

begin_function
name|void
name|warning_setup
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning message.    The first argument STRING is the warning message, used as a fprintf string,    and the remaining args are passed as arguments to it.    The primary difference between warnings and errors is that a warning    does not force the return to command level. */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|warning
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_pre_print
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|warning_pre_print
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and return to command level.    The first argument STRING is the error message, used as a fprintf string,    and the remaining args are passed as arguments to it.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|NORETURN
name|void
name|error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_pre_print
condition|)
name|fprintf_filtered
argument_list|(
name|stderr
argument_list|,
name|error_pre_print
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and exit reporting failure.    This is for a error that we cannot continue from.    The arguments are printed a la printf.     This function cannot be declared volatile (NORETURN) in an    ANSI environment because exit() is not declared volatile. */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|NORETURN
name|void
name|fatal
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ngdb: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message and exit, dumping core.    The arguments are printed a la printf ().  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|fatal_dump_core
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* "internal error" is always correct, since GDB should never dump      core, no matter what the input.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ngdb internal error: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
comment|/* We should never get here, but just in case...  */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The strerror() function can return NULL for errno values that are    out of range.  Provide a "safe" version that always returns a    printable string. */
end_comment

begin_function
name|char
modifier|*
name|safe_strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(undocumented errno %d)"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The strsignal() function can return NULL for signal values that are    out of range.  Provide a "safe" version that always returns a    printable string. */
end_comment

begin_function
name|char
modifier|*
name|safe_strsignal
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|strsignal
argument_list|(
name|signo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(undocumented signal %d)"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print the system error message for errno, and also mention STRING    as the file name for which the error was encountered.    Then return to command level.  */
end_comment

begin_function
name|void
name|perror_with_name
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|safe_strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* I understand setting these is a matter of taste.  Still, some people      may clear errno but not know about bfd_error.  Doing this here is not      unreasonable. */
name|bfd_error
operator|=
name|no_error
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s."
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the system error message for ERRCODE, and also mention STRING    as the file name for which the error was encountered.  */
end_comment

begin_function
name|void
name|print_sys_errmsg
parameter_list|(
name|string
parameter_list|,
name|errcode
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|errcode
decl_stmt|;
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|combined
decl_stmt|;
name|err
operator|=
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
name|combined
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|combined
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|combined
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.\n"
argument_list|,
name|combined
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Control C eventually causes this to be called, at a convenient time.  */
end_comment

begin_function
name|void
name|quit
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Force out any pending output */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TCFLSH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TERMIO */
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCFLUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|error
argument_list|(
literal|"Quit"
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Quit (expect signal %d when inferior is resumed)"
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Control C comes here */
end_comment

begin_function
name|void
name|request_quit
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|quit_flag
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
comment|/* Restore the signal handler.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|immediate_quit
condition|)
name|quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memory management stuff (malloc friends).  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
end_if

begin_function
name|PTR
name|mmalloc
parameter_list|(
name|md
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|PTR
name|mrealloc
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
comment|/* Guard against old realloc's */
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
else|else
return|return
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mfree
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MMALLOC */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_MMALLOC
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_MMALLOC_CHECK
argument_list|)
end_if

begin_function
name|void
name|init_malloc
parameter_list|(
name|md
parameter_list|)
name|PTR
name|md
decl_stmt|;
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* have mmalloc and want corruption checking  */
end_comment

begin_function
specifier|static
name|void
name|malloc_botch
parameter_list|()
block|{
name|fatal_dump_core
argument_list|(
literal|"Memory corruption"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to install hooks in mmalloc/mrealloc/mfree for the heap specified    by MD, to detect memory corruption.  Note that MD may be NULL to specify    the default heap that grows via sbrk.     Note that for freshly created regions, we must call mmcheck prior to any    mallocs in the region.  Otherwise, any region which was allocated prior to    installing the checking hooks, which is later reallocated or freed, will    fail the checks!  The mmcheck function only allows initial hooks to be    installed before the first mmalloc.  However, anytime after we have called    mmcheck the first time to install the checking hooks, we can call it again    to update the function pointer to the memory corruption handler.     Returns zero on failure, non-zero on success. */
end_comment

begin_function
name|void
name|init_malloc
parameter_list|(
name|md
parameter_list|)
name|PTR
name|md
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|mmcheck
argument_list|(
name|md
argument_list|,
name|malloc_botch
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"internal error: failed to install memory consistency checks"
argument_list|)
expr_stmt|;
block|}
name|mmtrace
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Have mmalloc and want corruption checking  */
end_comment

begin_comment
comment|/* Called when a memory allocation fails, with the number of bytes of    memory requested in SIZE. */
end_comment

begin_function
name|NORETURN
name|void
name|nomem
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"virtual memory exhausted: can't allocate %ld bytes."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"virtual memory exhausted."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like mmalloc but get error if no storage available, and protect against    the caller wanting to allocate zero bytes.  Whether to return NULL for    a zero byte request, or translate the request into a request for one    byte of zero'd storage, is a religious issue. */
end_comment

begin_function
name|PTR
name|xmmalloc
parameter_list|(
name|md
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like mrealloc but get error if no storage available.  */
end_comment

begin_function
name|PTR
name|xmrealloc
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|val
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|val
operator|=
name|mrealloc
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|mmalloc
argument_list|(
name|md
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like malloc but get error if no storage available, and protect against    the caller wanting to allocate zero bytes.  */
end_comment

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
name|xmmalloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like mrealloc but get error if no storage available.  */
end_comment

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
name|xmrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* My replacement for the read system call.    Used like `read' but keeps going if `read' returns too soon.  */
end_comment

begin_function
name|int
name|myread
parameter_list|(
name|desc
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
name|int
name|orglen
init|=
name|len
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
name|val
return|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
name|orglen
operator|-
name|len
return|;
name|len
operator|-=
name|val
expr_stmt|;
name|addr
operator|+=
name|val
expr_stmt|;
block|}
return|return
name|orglen
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of the string at PTR with SIZE characters    (and add a null character at the end in the copy).    Uses malloc to get the space.  Returns the address of the copy.  */
end_comment

begin_function
name|char
modifier|*
name|savestring
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|msavestring
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|md
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|xmmalloc
argument_list|(
name|md
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* The "const" is so it compiles under DGUX (which prototypes strsave    in<string.h>.  FIXME: This should be named "xstrsave", shouldn't it?    Doesn't real strsave return NULL if out of memory?  */
end_comment

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|ptr
parameter_list|)
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
return|return
name|savestring
argument_list|(
name|ptr
argument_list|,
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|mstrsave
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|)
name|void
modifier|*
name|md
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
return|return
operator|(
name|msavestring
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|,
name|strlen
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_spaces
parameter_list|(
name|n
parameter_list|,
name|file
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask user a y-or-n question and return 1 iff answer is yes.    Takes three args which are given to printf to print the question.    The first, a control string, should end in "? ".    It should not say how to answer, because we do that.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|int
name|query
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|ctlstr
decl_stmt|;
specifier|register
name|int
name|answer
decl_stmt|;
specifier|register
name|int
name|ans2
decl_stmt|;
comment|/* Automatically answer "yes" if input is not from a terminal.  */
if|if
condition|(
operator|!
name|input_from_terminal_p
argument_list|()
condition|)
return|return
literal|1
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush any buffered output */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|ctlstr
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stdout
argument_list|,
name|ctlstr
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(y or n) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|answer
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
comment|/* in case of C-d */
if|if
condition|(
name|answer
operator|==
name|EOF
condition|)
comment|/* C-d */
return|return
literal|1
return|;
if|if
condition|(
name|answer
operator|!=
literal|'\n'
condition|)
comment|/* Eat rest of input line, to EOF or newline */
do|do
block|{
name|ans2
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ans2
operator|!=
name|EOF
operator|&&
name|ans2
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|answer
operator|>=
literal|'a'
condition|)
name|answer
operator|-=
literal|040
expr_stmt|;
if|if
condition|(
name|answer
operator|==
literal|'Y'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|answer
operator|==
literal|'N'
condition|)
return|return
literal|0
return|;
name|printf_filtered
argument_list|(
literal|"Please answer y or n.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse a C escape sequence.  STRING_PTR points to a variable    containing a pointer to the string to parse.  That pointer    should point to the character after the \.  That pointer    is updated past the characters we use.  The value of the    escape sequence is returned.     A negative value means the sequence \ newline was seen,    which is supposed to be equivalent to nothing at all.     If \ is followed by a null character, we return a negative    value and leave the string pointer pointing at the null character.     If \ is followed by 000, we return 0 and leave the string pointer    after the zeros.  A value of 0 does not mean end of string.  */
end_comment

begin_function
name|int
name|parse_escape
parameter_list|(
name|string_ptr
parameter_list|)
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
return|return
literal|007
return|;
comment|/* Bell (alert) char */
case|case
literal|'b'
case|:
return|return
literal|'\b'
return|;
case|case
literal|'e'
case|:
comment|/* Escape character */
return|return
literal|033
return|;
case|case
literal|'f'
case|:
return|return
literal|'\f'
return|;
case|case
literal|'n'
case|:
return|return
literal|'\n'
return|;
case|case
literal|'r'
case|:
return|return
literal|'\r'
return|;
case|case
literal|'t'
case|:
return|return
literal|'\t'
return|;
case|case
literal|'v'
case|:
return|return
literal|'\v'
return|;
case|case
literal|'\n'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|0
case|:
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'^'
case|:
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|parse_escape
argument_list|(
name|string_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
return|return
literal|0177
return|;
return|return
operator|(
name|c
operator|&
literal|0200
operator|)
operator||
operator|(
name|c
operator|&
literal|037
operator|)
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
specifier|register
name|int
name|i
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|*=
literal|8
expr_stmt|;
name|i
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
default|default:
return|return
name|c
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the character C on STREAM as part of the contents    of a literal string whose delimiter is QUOTER.  */
end_comment

begin_function
name|void
name|printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|,
name|quoter
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|quoter
decl_stmt|;
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|c
operator|<
literal|0x20
operator|||
comment|/* Low control chars */
operator|(
name|c
operator|>=
literal|0x7F
operator|&&
name|c
operator|<
literal|0xA0
operator|)
operator|||
comment|/* DEL, High controls */
operator|(
name|sevenbit_strings
operator|&&
name|c
operator|>=
literal|0x80
operator|)
condition|)
block|{
comment|/* high order bit set */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|fputs_filtered
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|fputs_filtered
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%X"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Number of lines per page or UINT_MAX if paging is disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lines_per_page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars per line or UNIT_MAX is line folding is disabled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|chars_per_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current count of lines printed on this page, chars on this line.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|lines_printed
decl_stmt|,
name|chars_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer and start column of buffered text, for doing smarter word-    wrapping.  When someone calls wrap_here(), we start buffering output    that comes through fputs_filtered().  If we see a newline, we just    spit it out and forget about the wrap_here().  If we see another    wrap_here(), we spit it out and remember the newer one.  If we see    the end of the line, we spit out a newline, the indent, and then    the buffered output.     wrap_column is the column number on the screen where wrap_buffer begins.      When wrap_column is zero, wrapping is not in effect.    wrap_buffer is malloc'd with chars_per_line+2 bytes.       When wrap_buffer[0] is null, the buffer is empty.    wrap_pointer points into it at the next character to fill.    wrap_indent is the string that should be used as indentation if the      wrap occurs.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wrap_buffer
decl_stmt|,
modifier|*
name|wrap_pointer
decl_stmt|,
modifier|*
name|wrap_indent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_width_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|wrap_buffer
condition|)
block|{
name|wrap_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|chars_per_line
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|wrap_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|wrap_buffer
argument_list|,
name|chars_per_line
operator|+
literal|2
argument_list|)
expr_stmt|;
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
comment|/* Start it at the beginning */
block|}
end_function

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|instream_cleanup
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|instream
operator|=
name|stream
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prompt_for_continue
parameter_list|()
block|{
if|if
condition|(
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|&&
name|ISATTY
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|instream_cleanup
argument_list|,
name|instream
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|instream
operator|=
name|stdin
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|cp
operator|=
name|gdb_readline
argument_list|(
literal|"---Type<return> to continue---"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|chars_printed
operator|=
name|lines_printed
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Forget prev cmd -- CR won't repeat it. */
block|}
block|}
end_function

begin_comment
comment|/* Reinitialize filter; ie. tell it to reset to original values.  */
end_comment

begin_function
name|void
name|reinitialize_more_filter
parameter_list|()
block|{
name|lines_printed
operator|=
literal|0
expr_stmt|;
name|chars_printed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that if the next sequence of characters overflows the line,    a newline should be inserted here rather than when it hits the end.     If INDENT is nonzero, it is a string to be printed to indent the    wrapped part on the next line.  INDENT must remain accessible until    the next call to wrap_here() or until a newline is printed through    fputs_filtered().     If the line is already overfull, we immediately print a newline and    the indentation, and disable further wrapping.     If we don't know the width of lines, but we know the page height,    we must not wrap words, but should still keep track of newlines    that were explicitly printed.     INDENT should not contain tabs, as that    will mess up the char count on the next line.  FIXME.  */
end_comment

begin_function
name|void
name|wrap_here
parameter_list|(
name|indent
parameter_list|)
name|char
modifier|*
name|indent
decl_stmt|;
block|{
if|if
condition|(
name|wrap_buffer
index|[
literal|0
index|]
condition|)
block|{
operator|*
name|wrap_pointer
operator|=
literal|'\0'
expr_stmt|;
name|fputs
argument_list|(
name|wrap_buffer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chars_per_line
operator|==
name|UINT_MAX
condition|)
comment|/* No line overflow checking */
block|{
name|wrap_column
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chars_printed
operator|>=
name|chars_per_line
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|wrap_column
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wrap_column
operator|=
name|chars_printed
expr_stmt|;
name|wrap_indent
operator|=
name|indent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like fputs but pause after every screenful, and can wrap at points    other than the final character of a line.    Unlike fputs, fputs_filtered does not return a value.    It is OK for LINEBUFFER to be NULL, in which case just don't print    anything.     Note that a longjmp to top level may occur in this routine    (since prompt_for_continue may do so) so this routine should not be    called when cleanups are not in place.  */
end_comment

begin_function
name|void
name|fputs_filtered
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
specifier|const
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|lineptr
decl_stmt|;
if|if
condition|(
name|linebuffer
operator|==
literal|0
condition|)
return|return;
comment|/* Don't do any filtering if it is disabled.  */
if|if
condition|(
name|stream
operator|!=
name|stdout
operator|||
operator|(
name|lines_per_page
operator|==
name|UINT_MAX
operator|&&
name|chars_per_line
operator|==
name|UINT_MAX
operator|)
condition|)
block|{
name|fputs
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Go through and output each character.  Show line extension      when this is necessary; prompt user for new page when this is      necessary.  */
name|lineptr
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
condition|)
block|{
comment|/* Possible new page.  */
if|if
condition|(
name|lines_printed
operator|>=
name|lines_per_page
operator|-
literal|1
condition|)
name|prompt_for_continue
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
operator|&&
operator|*
name|lineptr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Print a single line.  */
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|wrap_column
condition|)
operator|*
name|wrap_pointer
operator|++
operator|=
literal|'\t'
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Shifting right by 3 produces the number of tab stops 	         we have already passed, and then adding one and 		 shifting left 3 advances to the next tab stop.  */
name|chars_printed
operator|=
operator|(
operator|(
name|chars_printed
operator|>>
literal|3
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wrap_column
condition|)
operator|*
name|wrap_pointer
operator|++
operator|=
operator|*
name|lineptr
expr_stmt|;
else|else
name|putc
argument_list|(
operator|*
name|lineptr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chars_printed
operator|++
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chars_printed
operator|>=
name|chars_per_line
condition|)
block|{
name|unsigned
name|int
name|save_chars
init|=
name|chars_printed
decl_stmt|;
name|chars_printed
operator|=
literal|0
expr_stmt|;
name|lines_printed
operator|++
expr_stmt|;
comment|/* If we aren't actually wrapping, don't output newline -- 		 if chars_per_line is right, we probably just overflowed 		 anyway; if it's wrong, let us keep going.  */
if|if
condition|(
name|wrap_column
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Possible new page.  */
if|if
condition|(
name|lines_printed
operator|>=
name|lines_per_page
operator|-
literal|1
condition|)
name|prompt_for_continue
argument_list|()
expr_stmt|;
comment|/* Now output indentation and wrapped string */
if|if
condition|(
name|wrap_column
condition|)
block|{
if|if
condition|(
name|wrap_indent
condition|)
name|fputs
argument_list|(
name|wrap_indent
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|*
name|wrap_pointer
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate saved stuff */
name|fputs
argument_list|(
name|wrap_buffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* and eject it */
comment|/* FIXME, this strlen is what prevents wrap_indent from 		     containing tabs.  However, if we recurse to print it 		     and count its chars, we risk trouble if wrap_indent is 		     longer than (the user settable) chars_per_line.  		     Note also that this can set chars_printed> chars_per_line 		     if we are printing a long string.  */
name|chars_printed
operator|=
name|strlen
argument_list|(
name|wrap_indent
argument_list|)
operator|+
operator|(
name|save_chars
operator|-
name|wrap_column
operator|)
expr_stmt|;
name|wrap_pointer
operator|=
name|wrap_buffer
expr_stmt|;
comment|/* Reset buffer */
name|wrap_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_column
operator|=
literal|0
expr_stmt|;
comment|/* And disable fancy wrap */
block|}
block|}
block|}
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\n'
condition|)
block|{
name|chars_printed
operator|=
literal|0
expr_stmt|;
name|wrap_here
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Spit out chars, cancel further wraps */
name|lines_printed
operator|++
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* fputs_demangled is a variant of fputs_filtered that    demangles g++ names.*/
end_comment

begin_function
name|void
name|fputs_demangled
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|,
name|arg_mode
parameter_list|)
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|arg_mode
decl_stmt|;
block|{
define|#
directive|define
name|SYMBOL_MAX
value|1024
define|#
directive|define
name|SYMBOL_CHAR
parameter_list|(
name|c
parameter_list|)
value|(isascii(c) \&& (isalnum(c) || (c) == '_' || (c) == CPLUS_MARKER))
name|char
name|buf
index|[
name|SYMBOL_MAX
operator|+
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|DMSLOP
value|5
comment|/* How much room to leave in buf */
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|linebuffer
operator|==
name|NULL
condition|)
return|return;
comment|/* If user wants to see raw output, no problem.  */
if|if
condition|(
operator|!
name|demangle
condition|)
block|{
name|fputs_filtered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
operator|(
name|char
operator|)
literal|0
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* collect non-interesting characters into buf */
while|while
condition|(
operator|*
name|p
operator|!=
operator|(
name|char
operator|)
literal|0
operator|&&
operator|!
name|SYMBOL_CHAR
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|DMSLOP
condition|)
block|{
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* output the non-interesting characters without demangling */
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|fputs_filtered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* reset buf */
block|}
comment|/* and now the interesting characters */
while|while
condition|(
name|i
operator|<
name|SYMBOL_MAX
operator|&&
operator|*
name|p
operator|!=
operator|(
name|char
operator|)
literal|0
operator|&&
name|SYMBOL_CHAR
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|DMSLOP
condition|)
block|{
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|cplus_demangle
argument_list|(
name|buf
argument_list|,
name|arg_mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|result
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs_filtered
argument_list|(
name|buf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print a variable number of ARGS using format FORMAT.  If this    information is going to put the amount written (since the last call    to REINITIALIZE_MORE_FILTER or the last page break) over the page size,    print out a pause message and do a gdb_readline to get the users    permision to continue.     Unlike fprintf, this function does not return a value.     We implement three variants, vfprintf (takes a vararg list and stream),    fprintf (takes a stream to write on), and printf (the usual).     Note that this routine has a restriction that the length of the    final output line must be less than 255 characters *or* it must be    less than twice the size of the format string.  This is a very    arbitrary restriction, but it is an internal restriction, so I'll    put it in.  This means that the %s format specifier is almost    useless; unless the caller can GUARANTEE that the string is short    enough, fputs_filtered should be used instead.     Note also that a longjmp to top level may occur in this routine    (since prompt_for_continue may do so) so this routine should not be    called when cleanups are not in place.  */
end_comment

begin_define
define|#
directive|define
name|MIN_LINEBUF
value|255
end_define

begin_function
name|void
name|vfprintf_filtered
parameter_list|(
name|stream
parameter_list|,
name|format
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|char
name|line_buf
index|[
name|MIN_LINEBUF
operator|+
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|linebuffer
init|=
name|line_buf
decl_stmt|;
name|int
name|format_length
decl_stmt|;
name|format_length
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
comment|/* Reallocate buffer to a larger size if this is necessary.  */
if|if
condition|(
name|format_length
operator|*
literal|2
operator|>
name|MIN_LINEBUF
condition|)
block|{
name|linebuffer
operator|=
name|alloca
argument_list|(
literal|10
operator|+
name|format_length
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* This won't blow up if the restrictions described above are      followed.   */
name|vsprintf
argument_list|(
name|linebuffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|fprintf_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stream
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* This won't blow up if the restrictions described above are      followed.   */
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like fprintf_filtered, but prints it's result indent.    Called as fprintfi_filtered (spaces, format, arg1, arg2, ...); */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|fprintfi_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|spaces
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|stream
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
name|spaces
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* This won't blow up if the restrictions described above are      followed.   */
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|printf_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like printf_filtered, but prints it's result indented.    Called as printfi_filtered (spaces, format, arg1, arg2, ...); */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|printfi_filtered
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|spaces
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|spaces
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
name|spaces
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Easy -- but watch out!     This routine is *not* a replacement for puts()!  puts() appends a newline.    This one doesn't, and had better not!  */
end_comment

begin_function
name|void
name|puts_filtered
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
name|string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to N spaces and a null.  The pointer is good    until the next call to here.  */
end_comment

begin_function
name|char
modifier|*
name|n_spaces
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
modifier|*
name|spaces
decl_stmt|;
specifier|static
name|int
name|max_spaces
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|max_spaces
condition|)
block|{
if|if
condition|(
name|spaces
condition|)
name|free
argument_list|(
name|spaces
argument_list|)
expr_stmt|;
name|spaces
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|spaces
operator|+
name|n
init|;
name|t
operator|!=
name|spaces
condition|;
control|)
operator|*
operator|--
name|t
operator|=
literal|' '
expr_stmt|;
name|spaces
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|max_spaces
operator|=
name|n
expr_stmt|;
block|}
return|return
name|spaces
operator|+
name|max_spaces
operator|-
name|n
return|;
block|}
end_function

begin_comment
comment|/* Print N spaces.  */
end_comment

begin_function
name|void
name|print_spaces_filtered
parameter_list|(
name|n
parameter_list|,
name|stream
parameter_list|)
name|int
name|n
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
name|n_spaces
argument_list|(
name|n
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* C++ demangler stuff.  */
end_comment

begin_comment
comment|/* Make a copy of a symbol, applying C++ demangling if demangling is enabled    and a demangled version exists.  Note that the value returned from    cplus_demangle is already allocated in malloc'd memory. */
end_comment

begin_function
name|char
modifier|*
name|strdup_demangled
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|demangle
condition|)
block|{
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|demangled
operator|!=
name|NULL
operator|)
condition|?
name|demangled
else|:
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print NAME on STREAM, demangling if necessary.  */
end_comment

begin_function
name|void
name|fprint_symbol
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|demangle
operator|)
operator|||
name|NULL
operator|==
operator|(
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
operator|)
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs_filtered
argument_list|(
name|demangled
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do a strcmp() type operation on STRING1 and STRING2, ignoring any    differences in whitespace.  Returns 0 if they match, non-zero if they    don't (slightly different than strcmp()'s range of return values).        As an extra hack, string1=="FOO(ARGS)" matches string2=="FOO".    This "feature" is useful for demangle_and_match(), which is used    when searching for matching C++ function names (such as if the    user types 'break FOO', where FOO is a mangled C++ function). */
end_comment

begin_function
name|int
name|strcmp_iw
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
specifier|const
name|char
modifier|*
name|string1
decl_stmt|;
specifier|const
name|char
modifier|*
name|string2
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string1
argument_list|)
condition|)
block|{
name|string1
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string2
argument_list|)
condition|)
block|{
name|string2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
operator|*
name|string2
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|string1
operator|!=
literal|'\0'
condition|)
block|{
name|string1
operator|++
expr_stmt|;
name|string2
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|*
name|string1
operator|!=
literal|'\0'
operator|&&
operator|*
name|string1
operator|!=
literal|'('
operator|)
operator|||
operator|(
operator|*
name|string2
operator|!=
literal|'\0'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Demangle NAME and compare the result with LOOKFOR, ignoring any differences    in whitespace.        If a match is found, returns a pointer to the demangled version of NAME    in malloc'd memory, which needs to be freed by the caller after use.    If a match is not found, returns NULL.     OPTIONS is a flags word that controls the demangling process and is just    passed on to the demangler.     When the caller sees a non-NULL result, it knows that NAME is the mangled    equivalent of LOOKFOR, and it can use either NAME, the "official demangled"    version of NAME (the return value) or the "unofficial demangled" version    of NAME (LOOKFOR, which it already knows). */
end_comment

begin_function
name|char
modifier|*
name|demangle_and_match
parameter_list|(
name|name
parameter_list|,
name|lookfor
parameter_list|,
name|options
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|lookfor
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
if|if
condition|(
operator|(
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|name
argument_list|,
name|options
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp_iw
argument_list|(
name|demangled
argument_list|,
name|lookfor
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|demangled
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGWINSZ
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_function
specifier|static
name|void
name|sigwinch
parameter_list|()
block|{
name|struct
name|winsize
name|win
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"TIOCGWINSZ"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lines_per_page
operator|=
name|win
operator|.
name|ws_row
expr_stmt|;
name|chars_per_line
operator|=
name|win
operator|.
name|ws_col
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SIGWINCH_HANDLER
end_ifndef

begin_define
define|#
directive|define
name|SIGWINCH_HANDLER
value|sigwinch
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|termdim
argument_list|()
end_macro

begin_block
block|{
name|SIGWINCH_HANDLER
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIGWINCH_HANDLER
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Initialize the screen height and width from termcap.  */
end_comment

begin_macro
name|termdim
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|v
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 2048 is large enough for all known terminals, according to the 	   GNU termcap manual.  */
name|char
name|term_buffer
index|[
literal|2048
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|termtype
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|tgetent
argument_list|(
name|term_buffer
argument_list|,
name|cp
argument_list|)
operator|<=
literal|0
condition|)
return|return;
name|v
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>=
literal|0
condition|)
name|lines_per_page
operator|=
name|v
expr_stmt|;
else|else
comment|/* The number of lines per page is not mentioned 		   in the terminal description.  This probably means 		   that paging is not useful (e.g. emacs shell window), 		   so disable paging.  */
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
name|v
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>=
literal|0
condition|)
name|chars_per_line
operator|=
name|v
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|_initialize_utils
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"width"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chars_per_line
argument_list|,
literal|"Set number of characters gdb thinks are in a line."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_width_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"height"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lines_per_page
argument_list|,
literal|"Set number of lines gdb thinks are in a page."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* These defaults will be used if we are unable to get the correct      values from termcap.  */
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|lines_per_page
operator|=
name|ScreenRows
argument_list|()
expr_stmt|;
name|chars_per_line
operator|=
name|ScreenCols
argument_list|()
expr_stmt|;
else|#
directive|else
name|lines_per_page
operator|=
literal|24
expr_stmt|;
name|chars_per_line
operator|=
literal|80
expr_stmt|;
name|termdim
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If the output is not a terminal, don't paginate it.  */
if|if
condition|(
operator|!
name|ISATTY
argument_list|(
name|stdout
argument_list|)
condition|)
name|lines_per_page
operator|=
name|UINT_MAX
expr_stmt|;
name|set_width_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"demangle"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|demangle
argument_list|,
literal|"Set demangling of encoded C++ names when displaying symbols."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"sevenbit-strings"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sevenbit_strings
argument_list|,
literal|"Set printing of 8-bit characters in strings as \\nnn."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"asm-demangle"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|asm_demangle
argument_list|,
literal|"Set demangling of C++ names in disassembly listings."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Machine specific function to handle SIGWINCH signal. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH_HANDLER_BODY
end_ifdef

begin_macro
name|SIGWINCH_HANDLER_BODY
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

