begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface to ptrace, for GDB when running under Unix.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some USG-esque systems (some of which are BSD-esque enough so that USG    is not defined) want this header, and it won't do any harm.  */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|kill_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|terminal_ours_1
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are debugging an attached outside process    rather than an inferior.  */
end_comment

begin_decl_stmt
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Record terminal status separately for debugger and inferior.  */
end_comment

begin_comment
comment|/* Does GDB have a terminal (on stdin)?  */
end_comment

begin_decl_stmt
name|int
name|gdb_has_a_terminal
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|TERMINAL
name|sg_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TERMINAL
name|sg_ours
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|tflags_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tflags_ours
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|tc_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|tc_ours
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGLTC_BROKEN
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|ltc_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|ltc_ours
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCLGET
end_ifdef

begin_comment
comment|/* The line discipline flags.  Note that even when gdb_has_a_terminal    is true, the ioctl's to get and set the line discipline flags may    fail.  An example is running gdb under "script" using the streams    based interface under SVR4.  So we keep track of whether or not    the flags we get are valid by setting the *_valid flag, and don't    try to reset them unless they are valid. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lmode_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lmode_inferior_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lmode_ours
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lmode_ours_valid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGPGRP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SHORT_PGRP
end_ifdef

begin_decl_stmt
specifier|static
name|short
name|pgrp_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|pgrp_ours
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not def SHORT_PGRP */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pgrp_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pgrp_ours
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not def SHORT_PGRP */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not def TIOCGPGRP */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|sigint_ours
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|sigquit_ours
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGPGRP */
end_comment

begin_comment
comment|/* The name of the tty (from the `tty' command) that we gave to the inferior    when it was last started.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inferior_thisrun_terminal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if our terminal settings are in effect.    Zero if the inferior's settings are in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|terminal_is_ours
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro for printing errors from ioctl operations */
end_comment

begin_define
define|#
directive|define
name|OOPSY
parameter_list|(
name|what
parameter_list|)
define|\
value|if (result == -1)	\     fprintf(stderr, "[%s failed in terminal_inferior: %s]\n", \ 	    what, strerror (errno))
end_define

begin_function_decl
specifier|static
name|void
name|terminal_ours_1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Initialize the terminal settings we record for the inferior,    before we actually run the inferior.  */
end_comment

begin_function
name|void
name|terminal_init_inferior
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|sg_inferior
operator|=
name|sg_ours
expr_stmt|;
name|tflags_inferior
operator|=
name|tflags_ours
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|tc_inferior
operator|=
name|tc_ours
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGLTC_BROKEN
argument_list|)
name|ltc_inferior
operator|=
name|ltc_ours
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|lmode_inferior
operator|=
name|lmode_ours
expr_stmt|;
name|lmode_inferior_valid
operator|=
name|lmode_ours_valid
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|pgrp_inferior
operator|=
name|inferior_pid
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
endif|#
directive|endif
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put the inferior's terminal settings into effect.    This is preparation for starting or resuming the inferior.  */
end_comment

begin_function
name|void
name|terminal_inferior
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|int
name|result
decl_stmt|;
if|if
condition|(
name|gdb_has_a_terminal
operator|&&
name|terminal_is_ours
operator|&&
name|inferior_thisrun_terminal
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_inferior
argument_list|)
expr_stmt|;
name|result
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_inferior
argument_list|)
expr_stmt|;
name|OOPSY
argument_list|(
literal|"fcntl F_SETFL"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|sg_inferior
argument_list|)
expr_stmt|;
name|OOPSY
argument_list|(
literal|"ioctl TIOCSETN"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tc_inferior
argument_list|)
expr_stmt|;
name|OOPSY
argument_list|(
literal|"ioctl TIOCSETC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGLTC_BROKEN
argument_list|)
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc_inferior
argument_list|)
expr_stmt|;
name|OOPSY
argument_list|(
literal|"ioctl TIOCSLTC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLSET
if|if
condition|(
name|lmode_inferior_valid
condition|)
block|{
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|lmode_inferior
argument_list|)
expr_stmt|;
name|OOPSY
argument_list|(
literal|"ioctl TIOCLSET"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pgrp_inferior
argument_list|)
expr_stmt|;
comment|/* If we attached to the process, we might or might not be sharing 	 a terminal.  Avoid printing error msg if we are unable to set our 	 terminal's process group to his process group ID.  */
if|if
condition|(
operator|!
name|attach_flag
condition|)
block|{
name|OOPSY
argument_list|(
literal|"ioctl TIOCSPGRP"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|sigint_ours
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigquit_ours
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
block|}
endif|#
directive|endif
name|terminal_is_ours
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put some of our terminal settings into effect,    enough to get proper results from our output,    but do not change into or out of RAW mode    so that no input is discarded.     After doing this, either terminal_ours or terminal_inferior    should be called to get back to a normal state of affairs.  */
end_comment

begin_function
name|void
name|terminal_ours_for_output
parameter_list|()
block|{
name|terminal_ours_1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put our terminal settings into effect.    First record the inferior's terminal settings    so they can be restored properly later.  */
end_comment

begin_function
name|void
name|terminal_ours
parameter_list|()
block|{
name|terminal_ours_1
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|terminal_ours_1
parameter_list|(
name|output_only
parameter_list|)
name|int
name|output_only
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGPGRP
comment|/* Ignore this signal since it will happen when we try to set the pgrp.  */
name|void
function_decl|(
modifier|*
name|osigttou
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
comment|/* Checking inferior_thisrun_terminal is necessary so that      if GDB is running in the background, it won't block trying      to do the ioctl()'s below.  Checking gdb_has_a_terminal      avoids attempting all the ioctl's when running in batch.  */
if|if
condition|(
name|inferior_thisrun_terminal
operator|!=
literal|0
operator|||
name|gdb_has_a_terminal
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|terminal_is_ours
condition|)
block|{
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|osigttou
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|pgrp_inferior
argument_list|)
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pgrp_ours
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|osigttou
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint_ours
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigquit_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
name|tflags_inferior
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg_inferior
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tc_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGLTC_BROKEN
argument_list|)
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltc_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|lmode_inferior
argument_list|)
expr_stmt|;
name|lmode_inferior_valid
operator|=
operator|(
name|result
operator|==
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|sg_ours
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
if|if
condition|(
name|output_only
operator|&&
operator|!
operator|(
name|sg_inferior
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
condition|)
name|sg_ours
operator|.
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TERMIO */
name|sg_ours
operator|.
name|sg_flags
operator|&=
operator|~
name|RAW
operator|&
operator|~
name|CBREAK
expr_stmt|;
if|if
condition|(
name|output_only
condition|)
name|sg_ours
operator|.
name|sg_flags
operator||=
operator|(
name|RAW
operator||
name|CBREAK
operator|)
operator|&
name|sg_inferior
operator|.
name|sg_flags
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
name|result
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_ours
argument_list|)
expr_stmt|;
name|result
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_ours
argument_list|)
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|sg_ours
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGLTC_BROKEN
argument_list|)
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
if|if
condition|(
name|lmode_ours_valid
condition|)
block|{
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|lmode_ours
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|sg_ours
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TERMIO */
name|sg_ours
operator|.
name|sg_flags
operator|&=
operator|~
name|RAW
operator|&
operator|~
name|CBREAK
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
name|result
operator|=
name|result
expr_stmt|;
comment|/* lint */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|term_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|target_terminal_info
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|child_terminal_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|gdb_has_a_terminal
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"This GDB does not control a terminal.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|printf_filtered
argument_list|(
literal|"Inferior's terminal status (currently saved by GDB):\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"owner pgrp = %d, fcntl flags = 0x%x.\n"
argument_list|,
name|pgrp_inferior
argument_list|,
name|tflags_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|printf_filtered
argument_list|(
literal|"c_iflag = 0x%x, c_oflag = 0x%x,\n"
argument_list|,
name|sg_inferior
operator|.
name|c_iflag
argument_list|,
name|sg_inferior
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"c_cflag = 0x%x, c_lflag = 0x%x, c_line = 0x%x.\n"
argument_list|,
name|sg_inferior
operator|.
name|c_cflag
argument_list|,
name|sg_inferior
operator|.
name|c_lflag
argument_list|,
name|sg_inferior
operator|.
name|c_line
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"c_cc: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NCC
operator|)
condition|;
name|i
operator|+=
literal|1
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
name|sg_inferior
operator|.
name|c_cc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TERMIO */
name|printf_filtered
argument_list|(
literal|"sgttyb.sg_flags = 0x%x.\n"
argument_list|,
name|sg_inferior
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|printf_filtered
argument_list|(
literal|"tchars: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|tchars
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|tc_inferior
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGLTC_BROKEN
argument_list|)
name|printf_filtered
argument_list|(
literal|"ltchars: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ltchars
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|ltc_inferior
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|printf_filtered
argument_list|(
literal|"lmode:  0x%x\n"
argument_list|,
name|lmode_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"This is a DOS machine; there is no terminal state\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* NEW_TTY_PREFORK is called before forking a new child process,    so we can record the state of ttys in the child to be formed.    TTYNAME is null if we are to share the terminal with gdb;    or points to a string containing the name of the desired tty.     NEW_TTY is called in new child processes under Unix, which will    become debugger target processes.  This actually switches to    the terminal specified in the NEW_TTY_PREFORK call.  */
end_comment

begin_function
name|void
name|new_tty_prefork
parameter_list|(
name|ttyname
parameter_list|)
name|char
modifier|*
name|ttyname
decl_stmt|;
block|{
comment|/* Save the name for later, for determining whether we and the child      are sharing a tty.  */
name|inferior_thisrun_terminal
operator|=
name|ttyname
expr_stmt|;
block|}
end_function

begin_function
name|void
name|new_tty
parameter_list|()
block|{
specifier|register
name|int
name|tty
decl_stmt|;
name|void
function_decl|(
modifier|*
name|osigttou
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|inferior_thisrun_terminal
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
ifdef|#
directive|ifdef
name|TIOCNOTTY
comment|/* Disconnect the child process from our controlling terminal.  On some      systems (SVR4 for example), this may cause a SIGTTOU, so temporarily      ignore SIGTTOU. */
name|tty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|>
literal|0
condition|)
block|{
name|osigttou
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCNOTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tty
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|osigttou
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now open the specified new terminal.  */
ifdef|#
directive|ifdef
name|USE_O_NOCTTY
name|tty
operator|=
name|open
argument_list|(
name|inferior_thisrun_terminal
argument_list|,
name|O_RDWR
operator||
name|O_NOCTTY
argument_list|)
expr_stmt|;
else|#
directive|else
name|tty
operator|=
name|open
argument_list|(
name|inferior_thisrun_terminal
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tty
operator|==
operator|-
literal|1
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|inferior_thisrun_terminal
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Avoid use of dup2; doesn't exist on all systems.  */
if|if
condition|(
name|tty
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|!=
literal|2
condition|)
block|{
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|>
literal|2
condition|)
name|close
argument_list|(
name|tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !go32*/
endif|o
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|kill_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The program is not being run."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Kill the inferior process? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|target_kill
argument_list|()
expr_stmt|;
comment|/* Killing off the inferior can leave us with a core file.  If so,      print the state we are left in.  */
if|if
condition|(
name|target_has_stack
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"In %s,\n"
argument_list|,
name|current_target
operator|->
name|to_longname
argument_list|)
expr_stmt|;
if|if
condition|(
name|selected_frame
operator|==
name|NULL
condition|)
name|fputs_filtered
argument_list|(
literal|"No selected stack frame.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The inferior process has died.  Long live the inferior!  */
end_comment

begin_function
name|void
name|generic_mourn_inferior
parameter_list|()
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR_DEFERRED_STORES
comment|/* Delete any pending stores to the inferior... */
name|CLEAR_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
name|reopen_exec_file
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_has_stack
condition|)
block|{
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_current_frame
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
operator|(
name|FRAME
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* It is confusing to the user for ignore counts to stick around      from previous runs of the inferior.  So clear them.  */
name|breakpoint_clear_ignore_counts
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This function is just for testing, and on some systems (Sony NewsOS    3.2)<sys/user.h> also includes<sys/time.h> which leads to errors    (since on this system at least sys/time.h is not protected against    multiple inclusion).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_comment
unit|static void try_writing_regs_command (arg, from_tty)      char *arg;      int from_tty; {   register int i;   register int value;    if (inferior_pid == 0)     error ("There is no inferior process now.");
comment|/* A Sun 3/50 or 3/60 (at least) running SunOS 4.0.3 will have a      kernel panic if we try to write past the end of the user area.      Presumably Sun will fix this bug (it has been reported), but it      is tacky to crash the system, so at least on SunOS4 we need to      stop writing when we hit the end of the user area.  */
end_comment

begin_endif
unit|for (i = 0; i< sizeof (struct user); i += 2)     {       QUIT;       errno = 0;       value = call_ptrace (3, inferior_pid, (PTRACE_ARG3_TYPE) i, 0);       call_ptrace (6, inferior_pid, (PTRACE_ARG3_TYPE) i, value);       if (errno == 0) 	{ 	  printf (" Succeeded with address 0x%x; value 0x%x (%d).\n", 		  i, value, value); 	}       else if ((i& 0377) == 0) 	printf (" Failed at 0x%x.\n", i);     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|_initialize_inflow
parameter_list|()
block|{
name|int
name|result
decl_stmt|;
name|add_info
argument_list|(
literal|"terminal"
argument_list|,
name|term_info
argument_list|,
literal|"Print inferior's saved terminal status."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_com ("try-writing-regs", class_obscure, try_writing_regs_command, 	   "Try writing all locations in inferior's system block.\n\ Report which ones can be written.");
endif|#
directive|endif
name|add_com
argument_list|(
literal|"kill"
argument_list|,
name|class_run
argument_list|,
name|kill_command
argument_list|,
literal|"Kill execution of program being debugged."
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* Get all the current tty settings (including whether we have a tty at      all!).  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|tflags_ours
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg_ours
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|gdb_has_a_terminal
operator|=
literal|1
expr_stmt|;
comment|/* Get the rest of the tty settings, then... */
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGLTC_BROKEN
argument_list|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|result
operator|=
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|lmode_ours
argument_list|)
expr_stmt|;
name|lmode_ours_valid
operator|=
operator|(
name|result
operator|==
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|pgrp_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
block|}
else|else
block|{
name|gdb_has_a_terminal
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|gdb_has_a_terminal
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

