begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i80960 instruction disassembler for GDB.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output goes here */
end_comment

begin_function_decl
specifier|static
name|void
name|print_addr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctrl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cobr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ea
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dstop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|regop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pinsn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|put_abs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Print the i960 instruction at address 'memaddr' in debugged memory,    on stream 's'.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|s
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|int
name|word1
decl_stmt|,
name|word2
decl_stmt|;
name|stream
operator|=
name|s
expr_stmt|;
name|word1
operator|=
name|read_memory_integer
argument_list|(
name|memaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|word2
operator|=
name|read_memory_integer
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|pinsn
argument_list|(
name|memaddr
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the i960 instruction at 'memaddr' and return the address of     the next instruction after that, or 0 if 'memaddr' is not the    address of a valid instruction.  The first word of the instruction    is stored at 'pword1', and the second word, if any, is stored at    'pword2'.  */
end_comment

begin_function
name|CORE_ADDR
name|next_insn
parameter_list|(
name|memaddr
parameter_list|,
name|pword1
parameter_list|,
name|pword2
parameter_list|)
name|unsigned
name|long
modifier|*
name|pword1
decl_stmt|,
decl|*
name|pword2
decl_stmt|;
end_function

begin_decl_stmt
name|CORE_ADDR
name|memaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|unsigned
name|long
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* Read the two (potential) words of the instruction at once,      to eliminate the overhead of two calls to read_memory ().      TODO: read more instructions at once and cache them.  */
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pword1
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|pword1
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pword2
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|pword2
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Divide instruction set into classes based on high 4 bits of opcode*/
switch|switch
condition|(
operator|(
operator|*
name|pword1
operator|>>
literal|28
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
comment|/* ctrl */
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
comment|/* cobr */
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
comment|/* reg */
name|len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
case|case
literal|0xc
case|:
name|len
operator|=
name|mem
argument_list|(
name|memaddr
argument_list|,
operator|*
name|pword1
argument_list|,
operator|*
name|pword2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* invalid instruction */
name|len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
condition|)
return|return
name|memaddr
operator|+
name|len
return|;
else|else
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_define
define|#
directive|define
name|IN_GDB
end_define

begin_comment
comment|/*****************************************************************************  *	All code below this point should be identical with that of  *	the disassembler in gdmp960.  *****************************************************************************/
end_comment

begin_struct
struct|struct
name|tabent
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|numops
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|pinsn
parameter_list|(
name|memaddr
parameter_list|,
name|word1
parameter_list|,
name|word2
parameter_list|)
name|unsigned
name|long
name|memaddr
decl_stmt|;
name|unsigned
name|long
name|word1
decl_stmt|,
name|word2
decl_stmt|;
block|{
name|int
name|instr_len
decl_stmt|;
name|instr_len
operator|=
literal|4
expr_stmt|;
name|put_abs
argument_list|(
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
comment|/* Divide instruction set into classes based on high 4 bits of opcode*/
switch|switch
condition|(
operator|(
name|word1
operator|>>
literal|28
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
name|ctrl
argument_list|(
name|memaddr
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
name|cobr
argument_list|(
name|memaddr
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
name|reg
argument_list|(
name|word1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
case|case
literal|0xc
case|:
name|instr_len
operator|=
name|mem
argument_list|(
name|memaddr
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* invalid instruction, print as data word */
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|instr_len
return|;
block|}
end_function

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/* CTRL format				*/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|void
name|ctrl
parameter_list|(
name|memaddr
parameter_list|,
name|word1
parameter_list|,
name|word2
parameter_list|)
name|unsigned
name|long
name|memaddr
decl_stmt|;
name|unsigned
name|long
name|word1
decl_stmt|,
name|word2
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|tabent
name|ctrl_tab
index|[]
init|=
block|{
name|NULL
block|,
literal|0
block|,
comment|/* 0x00 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x01 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x02 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x03 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x04 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x05 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x06 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x07 */
literal|"b"
block|,
literal|1
block|,
comment|/* 0x08 */
literal|"call"
block|,
literal|1
block|,
comment|/* 0x09 */
literal|"ret"
block|,
literal|0
block|,
comment|/* 0x0a */
literal|"bal"
block|,
literal|1
block|,
comment|/* 0x0b */
name|NULL
block|,
literal|0
block|,
comment|/* 0x0c */
name|NULL
block|,
literal|0
block|,
comment|/* 0x0d */
name|NULL
block|,
literal|0
block|,
comment|/* 0x0e */
name|NULL
block|,
literal|0
block|,
comment|/* 0x0f */
literal|"bno"
block|,
literal|1
block|,
comment|/* 0x10 */
literal|"bg"
block|,
literal|1
block|,
comment|/* 0x11 */
literal|"be"
block|,
literal|1
block|,
comment|/* 0x12 */
literal|"bge"
block|,
literal|1
block|,
comment|/* 0x13 */
literal|"bl"
block|,
literal|1
block|,
comment|/* 0x14 */
literal|"bne"
block|,
literal|1
block|,
comment|/* 0x15 */
literal|"ble"
block|,
literal|1
block|,
comment|/* 0x16 */
literal|"bo"
block|,
literal|1
block|,
comment|/* 0x17 */
literal|"faultno"
block|,
literal|0
block|,
comment|/* 0x18 */
literal|"faultg"
block|,
literal|0
block|,
comment|/* 0x19 */
literal|"faulte"
block|,
literal|0
block|,
comment|/* 0x1a */
literal|"faultge"
block|,
literal|0
block|,
comment|/* 0x1b */
literal|"faultl"
block|,
literal|0
block|,
comment|/* 0x1c */
literal|"faultne"
block|,
literal|0
block|,
comment|/* 0x1d */
literal|"faultle"
block|,
literal|0
block|,
comment|/* 0x1e */
literal|"faulto"
block|,
literal|0
block|,
comment|/* 0x1f */
block|}
decl_stmt|;
name|i
operator|=
operator|(
name|word1
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|ctrl_tab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|word1
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs_filtered
argument_list|(
name|ctrl_tab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|2
condition|)
block|{
comment|/* Predicts branch not taken */
name|fputs_filtered
argument_list|(
literal|".f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctrl_tab
index|[
name|i
index|]
operator|.
name|numops
operator|==
literal|1
condition|)
block|{
comment|/* EXTRACT DISPLACEMENT AND CONVERT TO ADDRESS */
name|word1
operator|&=
literal|0x00ffffff
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|0x00800000
condition|)
block|{
comment|/* Sign bit is set */
name|word1
operator||=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xffffff
operator|)
expr_stmt|;
comment|/* Sign extend */
block|}
name|fputs_filtered
argument_list|(
literal|"\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_addr
argument_list|(
name|word1
operator|+
name|memaddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/* COBR format				*/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|void
name|cobr
parameter_list|(
name|memaddr
parameter_list|,
name|word1
parameter_list|,
name|word2
parameter_list|)
name|unsigned
name|long
name|memaddr
decl_stmt|;
name|unsigned
name|long
name|word1
decl_stmt|,
name|word2
decl_stmt|;
block|{
name|int
name|src1
decl_stmt|;
name|int
name|src2
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|tabent
name|cobr_tab
index|[]
init|=
block|{
literal|"testno"
block|,
literal|1
block|,
comment|/* 0x20 */
literal|"testg"
block|,
literal|1
block|,
comment|/* 0x21 */
literal|"teste"
block|,
literal|1
block|,
comment|/* 0x22 */
literal|"testge"
block|,
literal|1
block|,
comment|/* 0x23 */
literal|"testl"
block|,
literal|1
block|,
comment|/* 0x24 */
literal|"testne"
block|,
literal|1
block|,
comment|/* 0x25 */
literal|"testle"
block|,
literal|1
block|,
comment|/* 0x26 */
literal|"testo"
block|,
literal|1
block|,
comment|/* 0x27 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x28 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x29 */
name|NULL
block|,
literal|0
block|,
comment|/* 0x2a */
name|NULL
block|,
literal|0
block|,
comment|/* 0x2b */
name|NULL
block|,
literal|0
block|,
comment|/* 0x2c */
name|NULL
block|,
literal|0
block|,
comment|/* 0x2d */
name|NULL
block|,
literal|0
block|,
comment|/* 0x2e */
name|NULL
block|,
literal|0
block|,
comment|/* 0x2f */
literal|"bbc"
block|,
literal|3
block|,
comment|/* 0x30 */
literal|"cmpobg"
block|,
literal|3
block|,
comment|/* 0x31 */
literal|"cmpobe"
block|,
literal|3
block|,
comment|/* 0x32 */
literal|"cmpobge"
block|,
literal|3
block|,
comment|/* 0x33 */
literal|"cmpobl"
block|,
literal|3
block|,
comment|/* 0x34 */
literal|"cmpobne"
block|,
literal|3
block|,
comment|/* 0x35 */
literal|"cmpoble"
block|,
literal|3
block|,
comment|/* 0x36 */
literal|"bbs"
block|,
literal|3
block|,
comment|/* 0x37 */
literal|"cmpibno"
block|,
literal|3
block|,
comment|/* 0x38 */
literal|"cmpibg"
block|,
literal|3
block|,
comment|/* 0x39 */
literal|"cmpibe"
block|,
literal|3
block|,
comment|/* 0x3a */
literal|"cmpibge"
block|,
literal|3
block|,
comment|/* 0x3b */
literal|"cmpibl"
block|,
literal|3
block|,
comment|/* 0x3c */
literal|"cmpibne"
block|,
literal|3
block|,
comment|/* 0x3d */
literal|"cmpible"
block|,
literal|3
block|,
comment|/* 0x3e */
literal|"cmpibo"
block|,
literal|3
block|,
comment|/* 0x3f */
block|}
decl_stmt|;
name|i
operator|=
operator|(
operator|(
name|word1
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x20
expr_stmt|;
if|if
condition|(
name|cobr_tab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs
argument_list|(
name|cobr_tab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|2
condition|)
block|{
comment|/* Predicts branch not taken */
name|fputs_filtered
argument_list|(
literal|".f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"\t"
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|src1
operator|=
operator|(
name|word1
operator|>>
literal|19
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|src2
operator|=
operator|(
name|word1
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|0x02000
condition|)
block|{
comment|/* M1 is 1 */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|src1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* M1 is 0 */
name|fputs_filtered
argument_list|(
name|reg_names
index|[
name|src1
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cobr_tab
index|[
name|i
index|]
operator|.
name|numops
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|word1
operator|&
literal|1
condition|)
block|{
comment|/* S2 is 1 */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",sf%d,"
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* S1 is 0 */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",%s,"
argument_list|,
name|reg_names
index|[
name|src2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Extract displacement and convert to address 		 */
name|word1
operator|&=
literal|0x00001ffc
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|0x00001000
condition|)
block|{
comment|/* Negative displacement */
name|word1
operator||=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0x1fff
operator|)
expr_stmt|;
comment|/* Sign extend */
block|}
name|print_addr
argument_list|(
name|memaddr
operator|+
name|word1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/* MEM format				*/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|int
comment|/* returns instruction length: 4 or 8 */
name|mem
parameter_list|(
name|memaddr
parameter_list|,
name|word1
parameter_list|,
name|word2
parameter_list|,
name|noprint
parameter_list|)
name|unsigned
name|long
name|memaddr
decl_stmt|;
name|unsigned
name|long
name|word1
decl_stmt|,
name|word2
decl_stmt|;
name|int
name|noprint
decl_stmt|;
comment|/* If TRUE, return instruction length, but 				   don't output any text.  */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|reg1
decl_stmt|,
modifier|*
name|reg2
decl_stmt|,
modifier|*
name|reg3
decl_stmt|;
comment|/* This lookup table is too sparse to make it worth typing in, but not 	 * so large as to make a sparse array necessary.  We allocate the 	 * table at runtime, initialize all entries to empty, and copy the 	 * real ones in from an initialization table. 	 * 	 * NOTE: In this table, the meaning of 'numops' is: 	 *	 1: single operand 	 *	 2: 2 operands, load instruction 	 *	-2: 2 operands, store instruction 	 */
specifier|static
name|struct
name|tabent
modifier|*
name|mem_tab
init|=
name|NULL
decl_stmt|;
specifier|static
struct|struct
block|{
name|int
name|opcode
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|numops
decl_stmt|;
block|}
name|mem_init
index|[]
init|=
block|{
define|#
directive|define
name|MEM_MIN
value|0x80
literal|0x80
block|,
literal|"ldob"
block|,
literal|2
block|,
literal|0x82
block|,
literal|"stob"
block|,
operator|-
literal|2
block|,
literal|0x84
block|,
literal|"bx"
block|,
literal|1
block|,
literal|0x85
block|,
literal|"balx"
block|,
literal|2
block|,
literal|0x86
block|,
literal|"callx"
block|,
literal|1
block|,
literal|0x88
block|,
literal|"ldos"
block|,
literal|2
block|,
literal|0x8a
block|,
literal|"stos"
block|,
operator|-
literal|2
block|,
literal|0x8c
block|,
literal|"lda"
block|,
literal|2
block|,
literal|0x90
block|,
literal|"ld"
block|,
literal|2
block|,
literal|0x92
block|,
literal|"st"
block|,
operator|-
literal|2
block|,
literal|0x98
block|,
literal|"ldl"
block|,
literal|2
block|,
literal|0x9a
block|,
literal|"stl"
block|,
operator|-
literal|2
block|,
literal|0xa0
block|,
literal|"ldt"
block|,
literal|2
block|,
literal|0xa2
block|,
literal|"stt"
block|,
operator|-
literal|2
block|,
literal|0xb0
block|,
literal|"ldq"
block|,
literal|2
block|,
literal|0xb2
block|,
literal|"stq"
block|,
operator|-
literal|2
block|,
literal|0xc0
block|,
literal|"ldib"
block|,
literal|2
block|,
literal|0xc2
block|,
literal|"stib"
block|,
operator|-
literal|2
block|,
literal|0xc8
block|,
literal|"ldis"
block|,
literal|2
block|,
literal|0xca
block|,
literal|"stis"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|MEM_MAX
value|0xca
define|#
directive|define
name|MEM_SIZ
value|((MEM_MAX-MEM_MIN+1) * sizeof(struct tabent))
literal|0
block|,
name|NULL
block|,
literal|0
block|}
struct|;
if|if
condition|(
name|mem_tab
operator|==
name|NULL
condition|)
block|{
name|mem_tab
operator|=
operator|(
expr|struct
name|tabent
operator|*
operator|)
name|xmalloc
argument_list|(
name|MEM_SIZ
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mem_tab
argument_list|,
name|MEM_SIZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mem_init
index|[
name|i
index|]
operator|.
name|opcode
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|mem_init
index|[
name|i
index|]
operator|.
name|opcode
operator|-
name|MEM_MIN
expr_stmt|;
name|mem_tab
index|[
name|j
index|]
operator|.
name|name
operator|=
name|mem_init
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|mem_tab
index|[
name|j
index|]
operator|.
name|numops
operator|=
name|mem_init
index|[
name|i
index|]
operator|.
name|numops
expr_stmt|;
block|}
block|}
name|i
operator|=
operator|(
operator|(
name|word1
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|-
name|MEM_MIN
expr_stmt|;
name|mode
operator|=
operator|(
name|word1
operator|>>
literal|10
operator|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
operator|(
name|mem_tab
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|)
comment|/* Valid instruction */
operator|&&
operator|(
operator|(
name|mode
operator|==
literal|5
operator|)
operator|||
operator|(
name|mode
operator|>=
literal|12
operator|)
operator|)
condition|)
block|{
comment|/* With 32-bit displacement */
name|len
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|noprint
condition|)
block|{
return|return
name|len
return|;
block|}
if|if
condition|(
operator|(
name|mem_tab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mode
operator|==
literal|6
operator|)
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s\t"
argument_list|,
name|mem_tab
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|reg_names
index|[
operator|(
name|word1
operator|>>
literal|19
operator|)
operator|&
literal|0x1f
index|]
expr_stmt|;
comment|/* MEMB only */
name|reg2
operator|=
name|reg_names
index|[
operator|(
name|word1
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
index|]
expr_stmt|;
name|reg3
operator|=
name|reg_names
index|[
name|word1
operator|&
literal|0x1f
index|]
expr_stmt|;
comment|/* MEMB only */
name|offset
operator|=
name|word1
operator|&
literal|0xfff
expr_stmt|;
comment|/* MEMA only  */
switch|switch
condition|(
name|mem_tab
index|[
name|i
index|]
operator|.
name|numops
condition|)
block|{
case|case
literal|2
case|:
comment|/* LOAD INSTRUCTION */
if|if
condition|(
name|mode
operator|&
literal|4
condition|)
block|{
comment|/* MEMB FORMAT */
name|ea
argument_list|(
name|memaddr
argument_list|,
name|mode
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MEMA FORMAT */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|8
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|2
case|:
comment|/* STORE INSTRUCTION */
if|if
condition|(
name|mode
operator|&
literal|4
condition|)
block|{
comment|/* MEMB FORMAT */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s,"
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
name|ea
argument_list|(
name|memaddr
argument_list|,
name|mode
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MEMA FORMAT */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s,0x%x"
argument_list|,
name|reg1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|8
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|1
case|:
comment|/* BX/CALLX INSTRUCTION */
if|if
condition|(
name|mode
operator|&
literal|4
condition|)
block|{
comment|/* MEMB FORMAT */
name|ea
argument_list|(
name|memaddr
argument_list|,
name|mode
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MEMA FORMAT */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|8
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/****************************************/
end_comment

begin_comment
comment|/* REG format				*/
end_comment

begin_comment
comment|/****************************************/
end_comment

begin_function
specifier|static
name|void
name|reg
parameter_list|(
name|word1
parameter_list|)
name|unsigned
name|long
name|word1
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|fp
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|int
name|src
decl_stmt|,
name|src2
decl_stmt|,
name|dst
decl_stmt|;
name|char
modifier|*
name|mnemp
decl_stmt|;
comment|/* This lookup table is too sparse to make it worth typing in, but not 	 * so large as to make a sparse array necessary.  We allocate the 	 * table at runtime, initialize all entries to empty, and copy the 	 * real ones in from an initialization table. 	 * 	 * NOTE: In this table, the meaning of 'numops' is: 	 *	 1: single operand, which is NOT a destination. 	 *	-1: single operand, which IS a destination. 	 *	 2: 2 operands, the 2nd of which is NOT a destination. 	 *	-2: 2 operands, the 2nd of which IS a destination. 	 *	 3: 3 operands 	 * 	 *	If an opcode mnemonic begins with "F", it is a floating-point 	 *	opcode (the "F" is not printed). 	 */
specifier|static
name|struct
name|tabent
modifier|*
name|reg_tab
init|=
name|NULL
decl_stmt|;
specifier|static
struct|struct
block|{
name|int
name|opcode
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|numops
decl_stmt|;
block|}
name|reg_init
index|[]
init|=
block|{
define|#
directive|define
name|REG_MIN
value|0x580
literal|0x580
block|,
literal|"notbit"
block|,
literal|3
block|,
literal|0x581
block|,
literal|"and"
block|,
literal|3
block|,
literal|0x582
block|,
literal|"andnot"
block|,
literal|3
block|,
literal|0x583
block|,
literal|"setbit"
block|,
literal|3
block|,
literal|0x584
block|,
literal|"notand"
block|,
literal|3
block|,
literal|0x586
block|,
literal|"xor"
block|,
literal|3
block|,
literal|0x587
block|,
literal|"or"
block|,
literal|3
block|,
literal|0x588
block|,
literal|"nor"
block|,
literal|3
block|,
literal|0x589
block|,
literal|"xnor"
block|,
literal|3
block|,
literal|0x58a
block|,
literal|"not"
block|,
operator|-
literal|2
block|,
literal|0x58b
block|,
literal|"ornot"
block|,
literal|3
block|,
literal|0x58c
block|,
literal|"clrbit"
block|,
literal|3
block|,
literal|0x58d
block|,
literal|"notor"
block|,
literal|3
block|,
literal|0x58e
block|,
literal|"nand"
block|,
literal|3
block|,
literal|0x58f
block|,
literal|"alterbit"
block|,
literal|3
block|,
literal|0x590
block|,
literal|"addo"
block|,
literal|3
block|,
literal|0x591
block|,
literal|"addi"
block|,
literal|3
block|,
literal|0x592
block|,
literal|"subo"
block|,
literal|3
block|,
literal|0x593
block|,
literal|"subi"
block|,
literal|3
block|,
literal|0x598
block|,
literal|"shro"
block|,
literal|3
block|,
literal|0x59a
block|,
literal|"shrdi"
block|,
literal|3
block|,
literal|0x59b
block|,
literal|"shri"
block|,
literal|3
block|,
literal|0x59c
block|,
literal|"shlo"
block|,
literal|3
block|,
literal|0x59d
block|,
literal|"rotate"
block|,
literal|3
block|,
literal|0x59e
block|,
literal|"shli"
block|,
literal|3
block|,
literal|0x5a0
block|,
literal|"cmpo"
block|,
literal|2
block|,
literal|0x5a1
block|,
literal|"cmpi"
block|,
literal|2
block|,
literal|0x5a2
block|,
literal|"concmpo"
block|,
literal|2
block|,
literal|0x5a3
block|,
literal|"concmpi"
block|,
literal|2
block|,
literal|0x5a4
block|,
literal|"cmpinco"
block|,
literal|3
block|,
literal|0x5a5
block|,
literal|"cmpinci"
block|,
literal|3
block|,
literal|0x5a6
block|,
literal|"cmpdeco"
block|,
literal|3
block|,
literal|0x5a7
block|,
literal|"cmpdeci"
block|,
literal|3
block|,
literal|0x5ac
block|,
literal|"scanbyte"
block|,
literal|2
block|,
literal|0x5ae
block|,
literal|"chkbit"
block|,
literal|2
block|,
literal|0x5b0
block|,
literal|"addc"
block|,
literal|3
block|,
literal|0x5b2
block|,
literal|"subc"
block|,
literal|3
block|,
literal|0x5cc
block|,
literal|"mov"
block|,
operator|-
literal|2
block|,
literal|0x5d8
block|,
literal|"eshro"
block|,
literal|3
block|,
literal|0x5dc
block|,
literal|"movl"
block|,
operator|-
literal|2
block|,
literal|0x5ec
block|,
literal|"movt"
block|,
operator|-
literal|2
block|,
literal|0x5fc
block|,
literal|"movq"
block|,
operator|-
literal|2
block|,
literal|0x600
block|,
literal|"synmov"
block|,
literal|2
block|,
literal|0x601
block|,
literal|"synmovl"
block|,
literal|2
block|,
literal|0x602
block|,
literal|"synmovq"
block|,
literal|2
block|,
literal|0x603
block|,
literal|"cmpstr"
block|,
literal|3
block|,
literal|0x604
block|,
literal|"movqstr"
block|,
literal|3
block|,
literal|0x605
block|,
literal|"movstr"
block|,
literal|3
block|,
literal|0x610
block|,
literal|"atmod"
block|,
literal|3
block|,
literal|0x612
block|,
literal|"atadd"
block|,
literal|3
block|,
literal|0x613
block|,
literal|"inspacc"
block|,
operator|-
literal|2
block|,
literal|0x614
block|,
literal|"ldphy"
block|,
operator|-
literal|2
block|,
literal|0x615
block|,
literal|"synld"
block|,
operator|-
literal|2
block|,
literal|0x617
block|,
literal|"fill"
block|,
literal|3
block|,
literal|0x630
block|,
literal|"sdma"
block|,
literal|3
block|,
literal|0x631
block|,
literal|"udma"
block|,
literal|0
block|,
literal|0x640
block|,
literal|"spanbit"
block|,
operator|-
literal|2
block|,
literal|0x641
block|,
literal|"scanbit"
block|,
operator|-
literal|2
block|,
literal|0x642
block|,
literal|"daddc"
block|,
literal|3
block|,
literal|0x643
block|,
literal|"dsubc"
block|,
literal|3
block|,
literal|0x644
block|,
literal|"dmovt"
block|,
operator|-
literal|2
block|,
literal|0x645
block|,
literal|"modac"
block|,
literal|3
block|,
literal|0x646
block|,
literal|"condrec"
block|,
operator|-
literal|2
block|,
literal|0x650
block|,
literal|"modify"
block|,
literal|3
block|,
literal|0x651
block|,
literal|"extract"
block|,
literal|3
block|,
literal|0x654
block|,
literal|"modtc"
block|,
literal|3
block|,
literal|0x655
block|,
literal|"modpc"
block|,
literal|3
block|,
literal|0x656
block|,
literal|"receive"
block|,
operator|-
literal|2
block|,
literal|0x659
block|,
literal|"sysctl"
block|,
literal|3
block|,
literal|0x660
block|,
literal|"calls"
block|,
literal|1
block|,
literal|0x662
block|,
literal|"send"
block|,
literal|3
block|,
literal|0x663
block|,
literal|"sendserv"
block|,
literal|1
block|,
literal|0x664
block|,
literal|"resumprcs"
block|,
literal|1
block|,
literal|0x665
block|,
literal|"schedprcs"
block|,
literal|1
block|,
literal|0x666
block|,
literal|"saveprcs"
block|,
literal|0
block|,
literal|0x668
block|,
literal|"condwait"
block|,
literal|1
block|,
literal|0x669
block|,
literal|"wait"
block|,
literal|1
block|,
literal|0x66a
block|,
literal|"signal"
block|,
literal|1
block|,
literal|0x66b
block|,
literal|"mark"
block|,
literal|0
block|,
literal|0x66c
block|,
literal|"fmark"
block|,
literal|0
block|,
literal|0x66d
block|,
literal|"flushreg"
block|,
literal|0
block|,
literal|0x66f
block|,
literal|"syncf"
block|,
literal|0
block|,
literal|0x670
block|,
literal|"emul"
block|,
literal|3
block|,
literal|0x671
block|,
literal|"ediv"
block|,
literal|3
block|,
literal|0x673
block|,
literal|"ldtime"
block|,
operator|-
literal|1
block|,
literal|0x674
block|,
literal|"Fcvtir"
block|,
operator|-
literal|2
block|,
literal|0x675
block|,
literal|"Fcvtilr"
block|,
operator|-
literal|2
block|,
literal|0x676
block|,
literal|"Fscalerl"
block|,
literal|3
block|,
literal|0x677
block|,
literal|"Fscaler"
block|,
literal|3
block|,
literal|0x680
block|,
literal|"Fatanr"
block|,
literal|3
block|,
literal|0x681
block|,
literal|"Flogepr"
block|,
literal|3
block|,
literal|0x682
block|,
literal|"Flogr"
block|,
literal|3
block|,
literal|0x683
block|,
literal|"Fremr"
block|,
literal|3
block|,
literal|0x684
block|,
literal|"Fcmpor"
block|,
literal|2
block|,
literal|0x685
block|,
literal|"Fcmpr"
block|,
literal|2
block|,
literal|0x688
block|,
literal|"Fsqrtr"
block|,
operator|-
literal|2
block|,
literal|0x689
block|,
literal|"Fexpr"
block|,
operator|-
literal|2
block|,
literal|0x68a
block|,
literal|"Flogbnr"
block|,
operator|-
literal|2
block|,
literal|0x68b
block|,
literal|"Froundr"
block|,
operator|-
literal|2
block|,
literal|0x68c
block|,
literal|"Fsinr"
block|,
operator|-
literal|2
block|,
literal|0x68d
block|,
literal|"Fcosr"
block|,
operator|-
literal|2
block|,
literal|0x68e
block|,
literal|"Ftanr"
block|,
operator|-
literal|2
block|,
literal|0x68f
block|,
literal|"Fclassr"
block|,
literal|1
block|,
literal|0x690
block|,
literal|"Fatanrl"
block|,
literal|3
block|,
literal|0x691
block|,
literal|"Flogeprl"
block|,
literal|3
block|,
literal|0x692
block|,
literal|"Flogrl"
block|,
literal|3
block|,
literal|0x693
block|,
literal|"Fremrl"
block|,
literal|3
block|,
literal|0x694
block|,
literal|"Fcmporl"
block|,
literal|2
block|,
literal|0x695
block|,
literal|"Fcmprl"
block|,
literal|2
block|,
literal|0x698
block|,
literal|"Fsqrtrl"
block|,
operator|-
literal|2
block|,
literal|0x699
block|,
literal|"Fexprl"
block|,
operator|-
literal|2
block|,
literal|0x69a
block|,
literal|"Flogbnrl"
block|,
operator|-
literal|2
block|,
literal|0x69b
block|,
literal|"Froundrl"
block|,
operator|-
literal|2
block|,
literal|0x69c
block|,
literal|"Fsinrl"
block|,
operator|-
literal|2
block|,
literal|0x69d
block|,
literal|"Fcosrl"
block|,
operator|-
literal|2
block|,
literal|0x69e
block|,
literal|"Ftanrl"
block|,
operator|-
literal|2
block|,
literal|0x69f
block|,
literal|"Fclassrl"
block|,
literal|1
block|,
literal|0x6c0
block|,
literal|"Fcvtri"
block|,
operator|-
literal|2
block|,
literal|0x6c1
block|,
literal|"Fcvtril"
block|,
operator|-
literal|2
block|,
literal|0x6c2
block|,
literal|"Fcvtzri"
block|,
operator|-
literal|2
block|,
literal|0x6c3
block|,
literal|"Fcvtzril"
block|,
operator|-
literal|2
block|,
literal|0x6c9
block|,
literal|"Fmovr"
block|,
operator|-
literal|2
block|,
literal|0x6d9
block|,
literal|"Fmovrl"
block|,
operator|-
literal|2
block|,
literal|0x6e1
block|,
literal|"Fmovre"
block|,
operator|-
literal|2
block|,
literal|0x6e2
block|,
literal|"Fcpysre"
block|,
literal|3
block|,
literal|0x6e3
block|,
literal|"Fcpyrsre"
block|,
literal|3
block|,
literal|0x701
block|,
literal|"mulo"
block|,
literal|3
block|,
literal|0x708
block|,
literal|"remo"
block|,
literal|3
block|,
literal|0x70b
block|,
literal|"divo"
block|,
literal|3
block|,
literal|0x741
block|,
literal|"muli"
block|,
literal|3
block|,
literal|0x748
block|,
literal|"remi"
block|,
literal|3
block|,
literal|0x749
block|,
literal|"modi"
block|,
literal|3
block|,
literal|0x74b
block|,
literal|"divi"
block|,
literal|3
block|,
literal|0x78b
block|,
literal|"Fdivr"
block|,
literal|3
block|,
literal|0x78c
block|,
literal|"Fmulr"
block|,
literal|3
block|,
literal|0x78d
block|,
literal|"Fsubr"
block|,
literal|3
block|,
literal|0x78f
block|,
literal|"Faddr"
block|,
literal|3
block|,
literal|0x79b
block|,
literal|"Fdivrl"
block|,
literal|3
block|,
literal|0x79c
block|,
literal|"Fmulrl"
block|,
literal|3
block|,
literal|0x79d
block|,
literal|"Fsubrl"
block|,
literal|3
block|,
literal|0x79f
block|,
literal|"Faddrl"
block|,
literal|3
block|,
define|#
directive|define
name|REG_MAX
value|0x79f
define|#
directive|define
name|REG_SIZ
value|((REG_MAX-REG_MIN+1) * sizeof(struct tabent))
literal|0
block|,
name|NULL
block|,
literal|0
block|}
struct|;
if|if
condition|(
name|reg_tab
operator|==
name|NULL
condition|)
block|{
name|reg_tab
operator|=
operator|(
expr|struct
name|tabent
operator|*
operator|)
name|xmalloc
argument_list|(
name|REG_SIZ
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_tab
argument_list|,
name|REG_SIZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_init
index|[
name|i
index|]
operator|.
name|opcode
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|reg_init
index|[
name|i
index|]
operator|.
name|opcode
operator|-
name|REG_MIN
expr_stmt|;
name|reg_tab
index|[
name|j
index|]
operator|.
name|name
operator|=
name|reg_init
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|reg_tab
index|[
name|j
index|]
operator|.
name|numops
operator|=
name|reg_init
index|[
name|i
index|]
operator|.
name|numops
expr_stmt|;
block|}
block|}
name|opcode
operator|=
operator|(
operator|(
name|word1
operator|>>
literal|20
operator|)
operator|&
literal|0xff0
operator|)
operator||
operator|(
operator|(
name|word1
operator|>>
literal|7
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|i
operator|=
name|opcode
operator|-
name|REG_MIN
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|<
name|REG_MIN
operator|)
operator|||
operator|(
name|opcode
operator|>
name|REG_MAX
operator|)
operator|||
operator|(
name|reg_tab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
name|mnemp
operator|=
name|reg_tab
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|mnemp
operator|==
literal|'F'
condition|)
block|{
name|fp
operator|=
literal|1
expr_stmt|;
name|mnemp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
literal|0
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|mnemp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|s1
operator|=
operator|(
name|word1
operator|>>
literal|5
operator|)
operator|&
literal|1
expr_stmt|;
name|s2
operator|=
operator|(
name|word1
operator|>>
literal|6
operator|)
operator|&
literal|1
expr_stmt|;
name|m1
operator|=
operator|(
name|word1
operator|>>
literal|11
operator|)
operator|&
literal|1
expr_stmt|;
name|m2
operator|=
operator|(
name|word1
operator|>>
literal|12
operator|)
operator|&
literal|1
expr_stmt|;
name|m3
operator|=
operator|(
name|word1
operator|>>
literal|13
operator|)
operator|&
literal|1
expr_stmt|;
name|src
operator|=
name|word1
operator|&
literal|0x1f
expr_stmt|;
name|src2
operator|=
operator|(
name|word1
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|dst
operator|=
operator|(
name|word1
operator|>>
literal|19
operator|)
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|reg_tab
index|[
name|i
index|]
operator|.
name|numops
operator|!=
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\t"
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg_tab
index|[
name|i
index|]
operator|.
name|numops
condition|)
block|{
case|case
literal|1
case|:
name|regop
argument_list|(
name|m1
argument_list|,
name|s1
argument_list|,
name|src
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|dstop
argument_list|(
name|m3
argument_list|,
name|dst
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|regop
argument_list|(
name|m1
argument_list|,
name|s1
argument_list|,
name|src
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|regop
argument_list|(
name|m2
argument_list|,
name|s2
argument_list|,
name|src2
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|regop
argument_list|(
name|m1
argument_list|,
name|s1
argument_list|,
name|src
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|dstop
argument_list|(
name|m3
argument_list|,
name|dst
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|regop
argument_list|(
name|m1
argument_list|,
name|s1
argument_list|,
name|src
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|regop
argument_list|(
name|m2
argument_list|,
name|s2
argument_list|,
name|src2
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|dstop
argument_list|(
name|m3
argument_list|,
name|dst
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print out effective address for memb instructions.  */
end_comment

begin_function
specifier|static
name|void
name|ea
parameter_list|(
name|memaddr
parameter_list|,
name|mode
parameter_list|,
name|reg2
parameter_list|,
name|reg3
parameter_list|,
name|word1
parameter_list|,
name|word2
parameter_list|)
name|unsigned
name|long
name|memaddr
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|char
modifier|*
name|reg2
decl_stmt|,
decl|*
name|reg3
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|int
name|word2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|scale
decl_stmt|;
specifier|static
name|int
name|scale_tab
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|}
decl_stmt|;
name|scale
operator|=
operator|(
name|word1
operator|>>
literal|7
operator|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
operator|(
name|scale
operator|>
literal|4
operator|)
operator|||
operator|(
operator|(
name|word1
operator|>>
literal|5
operator|)
operator|&
literal|0x03
operator|!=
literal|0
operator|)
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
name|scale
operator|=
name|scale_tab
index|[
name|scale
index|]
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|4
case|:
comment|/* (reg) */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* displ+8(ip) */
name|print_addr
argument_list|(
name|word2
operator|+
literal|8
operator|+
name|memaddr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* (reg)[index*scale] */
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)[%s]"
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)[%s*%d]"
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|12
case|:
comment|/* displacement */
name|print_addr
argument_list|(
name|word2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* displ(reg) */
name|print_addr
argument_list|(
name|word2
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* displ[index*scale] */
name|print_addr
argument_list|(
name|word2
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"[%s]"
argument_list|,
name|reg3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"[%s*%d]"
argument_list|,
name|reg3
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|15
case|:
comment|/* displ(reg)[index*scale] */
name|print_addr
argument_list|(
name|word2
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)[%s]"
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s)[%s*%d]"
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/************************************************/
end_comment

begin_comment
comment|/* Register Instruction Operand  		*/
end_comment

begin_comment
comment|/************************************************/
end_comment

begin_function
specifier|static
name|void
name|regop
parameter_list|(
name|mode
parameter_list|,
name|spec
parameter_list|,
name|reg
parameter_list|,
name|fp
parameter_list|)
name|int
name|mode
decl_stmt|,
name|spec
decl_stmt|,
name|reg
decl_stmt|,
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
condition|)
block|{
comment|/* FLOATING POINT INSTRUCTION */
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
block|{
comment|/* FP operand */
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|0
case|:
name|fputs_filtered
argument_list|(
literal|"fp0"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs_filtered
argument_list|(
literal|"fp1"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fputs_filtered
argument_list|(
literal|"fp2"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fputs_filtered
argument_list|(
literal|"fp3"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|fputs_filtered
argument_list|(
literal|"0f0.0"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|fputs_filtered
argument_list|(
literal|"0f1.0"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs_filtered
argument_list|(
literal|"?"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Non-FP register */
name|fputs_filtered
argument_list|(
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* NOT FLOATING POINT */
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
block|{
comment|/* Literal */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Register */
if|if
condition|(
name|spec
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"sf%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/************************************************/
end_comment

begin_comment
comment|/* Register Instruction Destination Operand	*/
end_comment

begin_comment
comment|/************************************************/
end_comment

begin_function
specifier|static
name|void
name|dstop
parameter_list|(
name|mode
parameter_list|,
name|reg
parameter_list|,
name|fp
parameter_list|)
name|int
name|mode
decl_stmt|,
name|reg
decl_stmt|,
name|fp
decl_stmt|;
block|{
comment|/* 'dst' operand can't be a literal. On non-FP instructions,  register 	 * mode is assumed and "m3" acts as if were "s3";  on FP-instructions, 	 * sf registers are not allowed so m3 acts normally. 	 */
if|if
condition|(
name|fp
condition|)
block|{
name|regop
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|regop
argument_list|(
literal|0
argument_list|,
name|mode
argument_list|,
name|reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|invalid
parameter_list|(
name|word1
parameter_list|)
name|int
name|word1
decl_stmt|;
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|".word\t0x%08x"
argument_list|,
name|word1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_addr
parameter_list|(
name|a
parameter_list|)
block|{
name|print_address
argument_list|(
name|a
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_abs
parameter_list|(
name|word1
parameter_list|,
name|word2
parameter_list|)
name|unsigned
name|long
name|word1
decl_stmt|,
name|word2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IN_GDB
return|return;
else|#
directive|else
name|int
name|len
decl_stmt|;
switch|switch
condition|(
operator|(
name|word1
operator|>>
literal|28
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
case|case
literal|0xc
case|:
comment|/* MEM format instruction */
name|len
operator|=
name|mem
argument_list|(
literal|0
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|len
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|8
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%08x %08x\t"
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%08x         \t"
argument_list|,
name|word1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

