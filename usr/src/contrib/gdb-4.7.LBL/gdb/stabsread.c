begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for decoding "stabs" debugging information format.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Support routines for reading and decoding debugging information in    the "stabs" format.  This format is used with many systems that use    the a.out object file format, as well as some systems that use    COFF or ELF where the stabs data is placed in a special section.    Avoid placing any object file format specific code in this file. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* Needed for "struct complaint" */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* We always use GNU stabs, not native */
end_comment

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_comment
comment|/* Ask stabsread.h to define the vars it normally declares `extern'.  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/**/
end_comment

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_comment
comment|/* Our own declarations */
end_comment

begin_undef
undef|#
directive|undef
name|EXTERN
end_undef

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|dbx_alloc_type
name|PARAMS
argument_list|(
operator|(
name|int
index|[
literal|2
index|]
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_huge_number
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|long
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|patch_block_stabs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|pending
operator|*
operator|,
expr|struct
name|pending_stabs
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_common_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|read_range_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
index|[
literal|2
index|]
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|read_sun_builtin_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
index|[
literal|2
index|]
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|read_sun_floating_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
index|[
literal|2
index|]
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|read_array_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|read_args
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vptr_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'v'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
name|CPLUS_MARKER
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vb_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'v'
block|,
literal|'b'
block|,
name|CPLUS_MARKER
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define this as 1 if a pcc declaration of a char or short argument    gives the correct address.  Otherwise assume pcc gives the    address of the corresponding int, which is not the same on a    big-endian machine.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BELIEVE_PCC_PROMOTION
end_ifndef

begin_define
define|#
directive|define
name|BELIEVE_PCC_PROMOTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* During some calls to read_type (and thus to read_range_type), this    contains the name of the type being defined.  Range types are only    used in C as basic types.  We use the name to distinguish the otherwise    identical basic types "int" and "long" and their unsigned versions.    FIXME, this should disappear with better type management.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|long_kludge_name
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct complaint dbx_class_complaint = {   "encountered DBX-style class variable debugging information.\n\ You seem to have compiled your program with \ \"g++ -g0\" instead of \"g++ -g\".\n\ Therefore GDB will not know about your class variables", 0, 0 };
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|complaint
name|invalid_cpp_abbrev_complaint
init|=
block|{
literal|"invalid C++ abbreviation `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|invalid_cpp_type_complaint
init|=
block|{
literal|"C++ abbreviated type name unknown at symtab pos %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|member_fn_complaint
init|=
block|{
literal|"member function type missing, got '%c'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|const_vol_complaint
init|=
block|{
literal|"const/volatile indicator missing, got '%c'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|error_type_complaint
init|=
block|{
literal|"debug info mismatch between compiler and debugger"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|invalid_member_complaint
init|=
block|{
literal|"invalid (minimal) member type data format at symtab pos %d."
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|range_type_base_complaint
init|=
block|{
literal|"base type %d of range type is not defined"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|reg_value_complaint
init|=
block|{
literal|"register number too large in symbol %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a list of forward references which haven't been defined.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|undef_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|undef_types_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|undef_types_length
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|int
name|hashname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|;
specifier|register
name|int
name|total
init|=
name|p
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|total
operator|+=
name|p
index|[
literal|3
index|]
operator|<<
literal|6
expr_stmt|;
block|}
block|}
comment|/* Ensure result is positive.  */
if|if
condition|(
name|total
operator|<
literal|0
condition|)
block|{
name|total
operator|+=
operator|(
literal|1000
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|%
name|HASHSIZE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up a dbx type-number pair.  Return the address of the slot    where the type for that number-pair is stored.    The number-pair is in TYPENUMS.     This can be used for finding the type associated with that pair    or for associating a new type with the pair.  */
end_comment

begin_function
name|struct
name|type
modifier|*
modifier|*
name|dbx_lookup_type
parameter_list|(
name|typenums
parameter_list|)
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
block|{
specifier|register
name|int
name|filenum
init|=
name|typenums
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|index
init|=
name|typenums
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|old_len
decl_stmt|;
specifier|register
name|int
name|real_filenum
decl_stmt|;
specifier|register
name|struct
name|header_file
modifier|*
name|f
decl_stmt|;
name|int
name|f_orig_length
decl_stmt|;
if|if
condition|(
name|filenum
operator|==
operator|-
literal|1
condition|)
comment|/* -1,-1 is for temporary types.  */
return|return
literal|0
return|;
if|if
condition|(
name|filenum
operator|<
literal|0
operator|||
name|filenum
operator|>=
name|n_this_object_header_files
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: type number (%d,%d) out of range at symtab pos %d."
argument_list|,
name|filenum
argument_list|,
name|index
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|filenum
operator|==
literal|0
condition|)
block|{
comment|/* Type is defined outside of header files. 	 Find it in this object file's type vector.  */
if|if
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|old_len
operator|=
name|type_vector_length
expr_stmt|;
if|if
condition|(
name|old_len
operator|==
literal|0
condition|)
block|{
name|type_vector_length
operator|=
name|INITIAL_TYPE_VECTOR_LENGTH
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|type_vector_length
operator|*=
literal|2
expr_stmt|;
block|}
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_vector
argument_list|,
operator|(
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|type_vector
index|[
name|old_len
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|type_vector_length
operator|-
name|old_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|type_vector
index|[
name|index
index|]
operator|)
return|;
block|}
else|else
block|{
name|real_filenum
operator|=
name|this_object_header_files
index|[
name|filenum
index|]
expr_stmt|;
if|if
condition|(
name|real_filenum
operator|>=
name|n_header_files
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|f
operator|=
operator|&
name|header_files
index|[
name|real_filenum
index|]
expr_stmt|;
name|f_orig_length
operator|=
name|f
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|f_orig_length
condition|)
block|{
while|while
condition|(
name|index
operator|>=
name|f
operator|->
name|length
condition|)
block|{
name|f
operator|->
name|length
operator|*=
literal|2
expr_stmt|;
block|}
name|f
operator|->
name|vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|vector
argument_list|,
name|f
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|f
operator|->
name|vector
index|[
name|f_orig_length
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|f
operator|->
name|length
operator|-
name|f_orig_length
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|f
operator|->
name|vector
index|[
name|index
index|]
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Make sure there is a type allocated for type numbers TYPENUMS    and return the type object.    This can create an empty (zeroed) type object.    TYPENUMS may be (-1, -1) to return a new type object that is not    put into the type vector, and so may not be referred to by number. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dbx_alloc_type
parameter_list|(
name|typenums
parameter_list|,
name|objfile
parameter_list|)
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
modifier|*
name|type_addr
decl_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|alloc_type
argument_list|(
name|objfile
argument_list|)
operator|)
return|;
block|}
name|type_addr
operator|=
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
comment|/* If we are referring to a type not known at all yet,      allocate an empty type for it.      We will fill it in later if we find out how.  */
if|if
condition|(
operator|*
name|type_addr
operator|==
literal|0
condition|)
block|{
operator|*
name|type_addr
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|type_addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* for all the stabs in a given stab vector, build appropriate types     and fix their symbols in given symbol vector. */
end_comment

begin_function
specifier|static
name|void
name|patch_block_stabs
parameter_list|(
name|symbols
parameter_list|,
name|stabs
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|pending
modifier|*
name|symbols
decl_stmt|;
name|struct
name|pending_stabs
modifier|*
name|stabs
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|stabs
condition|)
block|{
comment|/* for all the stab entries, find their corresponding symbols and  	 patch their types! */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|stabs
operator|->
name|count
condition|;
operator|++
name|ii
control|)
block|{
name|name
operator|=
name|stabs
operator|->
name|stab
index|[
name|ii
index|]
expr_stmt|;
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_symbol_in_list
argument_list|(
name|symbols
argument_list|,
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
block|{
ifndef|#
directive|ifndef
name|IBM6000_TARGET
name|printf
argument_list|(
literal|"ERROR! stab symbol not found!\n"
argument_list|)
expr_stmt|;
comment|/* FIXME */
endif|#
directive|endif
block|}
else|else
block|{
name|pp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'F'
operator|||
operator|*
operator|(
name|pp
operator|-
literal|1
operator|)
operator|==
literal|'f'
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a number by which a type is referred to in dbx data,    or perhaps read a pair (FILENUM, TYPENUM) in parentheses.    Just a single number N is equivalent to (0,N).    Return the two numbers by storing them in the vector TYPENUMS.    TYPENUMS will then be used as an argument to dbx_lookup_type.  */
end_comment

begin_function
name|void
name|read_type_number
parameter_list|(
name|pp
parameter_list|,
name|typenums
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
modifier|*
name|typenums
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'('
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|typenums
index|[
literal|0
index|]
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|typenums
index|[
literal|1
index|]
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typenums
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|typenums
index|[
literal|1
index|]
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* To handle GNU C++ typename abbreviation, we need to be able to    fill in a type's name as soon as space for that type is allocated.    `type_synonym_name' is the name of the type being allocated.    It is cleared as soon as it is used (lest all allocated types    get this name).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|type_synonym_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|define_symbol
parameter_list|(
name|valu
parameter_list|,
name|string
parameter_list|,
name|desc
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|unsigned
name|int
name|valu
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|string
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|int
name|deftype
decl_stmt|;
name|int
name|synonym
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|temptype
decl_stmt|;
comment|/* We would like to eliminate nameless symbols, but keep their types.      E.g. stab entry ":t10=*2" should produce a type 10, which is a pointer      to type 2, but, should not creat a symbol to address that type. Since      the symbol will be nameless, there is no way any user can refer to it. */
name|int
name|nameless
decl_stmt|;
comment|/* Ignore syms with empty names.  */
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Ignore old-style symbols from cc -go  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If a nameless stab entry, all we need is the type, not the symbol.      e.g. ":t10=*2" */
name|nameless
operator|=
operator|(
name|p
operator|==
name|string
operator|)
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_gcc_compilation
condition|)
block|{
comment|/* GCC 2.x puts the line number in desc.  SunOS apparently puts in the 	 number of bytes occupied by a type or object, which we ignore.  */
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|desc
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* unknown */
block|}
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
name|CPLUS_MARKER
condition|)
block|{
comment|/* Special GNU C++ names.  */
switch|switch
condition|(
name|string
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'t'
case|:
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"this"
argument_list|,
name|strlen
argument_list|(
literal|"this"
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* $vtbl_ptr_type */
comment|/* Was: SYMBOL_NAME (sym) = "vptr"; */
goto|goto
name|normal
goto|;
case|case
literal|'e'
case|:
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
literal|"eh_throw"
argument_list|,
name|strlen
argument_list|(
literal|"eh_throw"
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* This was an anonymous type that was never fixed up.  */
goto|goto
name|normal
goto|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|normal
label|:
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
operator|(
operator|(
name|p
operator|-
name|string
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Open-coded bcopy--saves function call time.  */
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|p
condition|)
block|{
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
operator|*
name|p2
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|p
operator|++
expr_stmt|;
comment|/* Determine the type of name being defined.  */
comment|/* The Acorn RISC machine's compiler can put out locals that don't      start with "234=" or "(3,4)=", so assume anything other than the      deftypes we know how to handle is a local.  */
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"cfFGpPrStTvVXCR"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|deftype
operator|=
literal|'l'
expr_stmt|;
else|else
name|deftype
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* c is a special case, not followed by a type-number.      SYMBOL:c=iVALUE for an integer constant symbol.      SYMBOL:c=rVALUE for a floating constant symbol.      SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.         e.g. "b:c=e6,0" for "const b = blob1" 	(where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
if|if
condition|(
name|deftype
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'='
condition|)
name|error
argument_list|(
literal|"Invalid symbol data at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
block|{
name|double
name|d
init|=
name|atof
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dbl_valu
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
expr_stmt|;
name|dbl_valu
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dbl_valu
argument_list|,
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|dbl_valu
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
operator|=
name|dbl_valu
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST_BYTES
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol. 	     e.g. "b:c=e6,0" for "const b = blob1" 	     (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
block|{
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|read_type_number
argument_list|(
operator|&
name|p
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: no comma in enum const symbol"
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid symbol data at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
comment|/* Now usually comes a number that says which data type,      and possibly more stuff to define the type      (all of which is handled by read_type)  */
if|if
condition|(
name|deftype
operator|==
literal|'p'
operator|&&
operator|*
name|p
operator|==
literal|'F'
condition|)
comment|/* pF is a two-letter code that means a function parameter in Fortran.        The type-number specifies the type of the return value.        Translate it into a pointer-to-function type.  */
block|{
name|p
operator|++
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The symbol class letter is followed by a type (typically the 	 type of the symbol, or its return-type, or etc).  Read it.  */
name|synonym
operator|=
operator|*
name|p
operator|==
literal|'t'
expr_stmt|;
if|if
condition|(
name|synonym
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
name|type_synonym_name
operator|=
name|obsavestring
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
block|}
comment|/* Here we save the name of the symbol for read_range_type, which 	 ends up reading in the basic types.  In stabs, unfortunately there 	 is no distinction between "int" and "long" types except their 	 names.  Until we work out a saner type policy (eliminating most 	 builtin types and using the names specified in the files), we 	 save away the name so that far away from here in read_range_type, 	 we can examine it to decide between "int" and "long".  FIXME.  */
name|long_kludge_name
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|deftype
condition|)
block|{
case|case
literal|'C'
case|:
comment|/* The name of a caught exception.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LABEL
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* A static function definition.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
comment|/* fall into process_function_types.  */
name|process_function_types
label|:
comment|/* Function result types are described as the result type in stabs. 	 We need to convert this to the function-returning-type-X type 	 in GDB.  E.g. "int" is converted to "function returning int".  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This code doesn't work -- it needs to realloc and can't.  */
comment|/* Attempt to set up to record a function prototype... */
block|struct type *new = alloc_type (objfile);
comment|/* Generate a template for the type of this function.  The  	     types of the arguments will be added as we read the symbol  	     table. */
block|*new = *lookup_function_type (SYMBOL_TYPE(sym)); 	  SYMBOL_TYPE(sym) = new; 	  TYPE_OBJFILE (new) = objfile; 	  in_function_type = new;
else|#
directive|else
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* fall into process_prototype_types */
name|process_prototype_types
label|:
comment|/* Sun acc puts declared types of arguments here.  We don't care 	 about their actual types (FIXME -- we should remember the whole 	 function prototype), but the list may define some new types 	 that we have to remember, so we must scan it now.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|read_type
argument_list|(
operator|&
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* A global function definition.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
goto|goto
name|process_function_types
goto|;
case|case
literal|'G'
case|:
comment|/* For a class G (global) symbol, it appears that the 	 value is not correct.  It is necessary to search for the 	 corresponding linker definition to find the value. 	 These definitions appear at the end of the namelist.  */
name|i
operator|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|global_sym_chain
index|[
name|i
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
comment|/* This case is faked by a conditional above, 	 when there is no code letter in the dbx data. 	 Dbx data never actually contains 'l'.  */
case|case
literal|'l'
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Normally this is a parameter, a LOC_ARG.  On the i960, it 	 can also be a LOC_LOCAL_ARG depending on symbol type.  */
ifndef|#
directive|ifndef
name|DBX_PARM_SYMBOL_CLASS
define|#
directive|define
name|DBX_PARM_SYMBOL_CLASS
parameter_list|(
name|type
parameter_list|)
value|LOC_ARG
endif|#
directive|endif
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|DBX_PARM_SYMBOL_CLASS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This doesn't work yet.  */
block|add_param_to_type (&in_function_type, sym);
endif|#
directive|endif
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
comment|/* If it's gcc-compiled, if it says `short', believe it.  */
if|if
condition|(
name|processing_gcc_compilation
operator|||
name|BELIEVE_PCC_PROMOTION
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION_TYPE
argument_list|)
comment|/* This macro is defined on machines (e.g. sparc) where 	 we should believe the type of a PCC 'short' argument, 	 but shouldn't believe the address (the address is 	 the address of the corresponding int).  Note that 	 this is only different from the BELIEVE_PCC_PROMOTION 	 case on big-endian machines.  	 My guess is that this correction, as opposed to changing 	 the parameter to an 'int' (as done below, for PCC 	 on most machines), is the right thing to do 	 on all machines, but I don't want to risk breaking 	 something that already works.  On most PCC machines, 	 the sparc problem doesn't come up because the calling 	 function has to zero the top bytes (not knowing whether 	 the called function wants an int or a short), so there 	 is no practical difference between an int and a short 	 (except perhaps what happens when the GDB user types 	 "print short_arg = 0x10000;").   	 Hacked for SunOS 4.1 by gnu@cygnus.com.  In 4.1, the compiler 	 actually produces the correct address (we don't need to fix it 	 up).  I made this code adapt so that it will offset the symbol 	 if it was pointing at an int-aligned location and not 	 otherwise.  This way you can use the same gdb for 4.0.x and 	 4.1 systems.  	If the parameter is shorter than an int, and is integral 	(e.g. char, short, or unsigned equivalent), and is claimed to 	be passed on an integer boundary, don't believe it!  Offset the 	parameter's address to the tail-end of that integer.  */
name|temptype
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
literal|0
operator|==
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|%
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
else|#
directive|else
comment|/* no BELIEVE_PCC_PROMOTION_TYPE.  */
comment|/* If PCC says a parameter is a short or a char, 	 it is really an int.  */
name|temptype
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|temptype
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|?
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
else|:
name|temptype
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* no BELIEVE_PCC_PROMOTION_TYPE.  */
case|case
literal|'P'
case|:
comment|/* acc seems to use P to delare the prototypes of functions that          are referenced by this file.  gdb is not prepared to deal          with this extra information.  FIXME, it ought to.  */
if|if
condition|(
name|type
operator|==
name|N_FUN
condition|)
goto|goto
name|process_prototype_types
goto|;
comment|/* Parameter which is in a register.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|>=
name|NUM_REGS
condition|)
block|{
name|complain
argument_list|(
operator|&
name|reg_value_complaint
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Known safe, though useless */
block|}
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
comment|/* Register variable (either global or local).  */
comment|/* XXX */
ifdef|#
directive|ifdef
name|sparc
if|if
condition|(
operator|!
name|processing_gcc_compilation
condition|)
block|{
name|struct
name|symbol
modifier|*
name|s0
decl_stmt|;
comment|/* 	       * If we see a parm decl immediately followed by a reg decl of 	       * the same name (and in the same block), we change it to a 	       * single instance of a reg parm.  Sun's cc will generate these. 	       */
if|if
condition|(
name|local_symbols
operator|&&
operator|(
name|s0
operator|=
name|local_symbols
operator|->
name|symbol
index|[
name|local_symbols
operator|->
name|nsyms
operator|-
literal|1
index|]
operator|)
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|s0
argument_list|)
operator|==
name|LOC_ARG
operator|&&
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|s0
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|s0
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s0
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s0
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
return|return
name|s0
return|;
block|}
block|}
endif|#
directive|endif
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|valu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|>=
name|NUM_REGS
condition|)
block|{
name|complain
argument_list|(
operator|&
name|reg_value_complaint
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
comment|/* Known safe, though useless */
block|}
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|within_function
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Static symbol at top level of file */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* For a nameless type, we don't want a create a symbol, thus we 	 did not use `sym'. Return without further processing. */
if|if
condition|(
name|nameless
condition|)
return|return
name|NULL
return|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* C++ vagaries: we may have a type which is derived from 	a base type which did not have its name defined when the 	derived class was output.  We fill in the derived class's 	base part member's name here in that case.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
name|TYPE_N_BASECLASSES
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|TYPE_BASECLASS_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_BASECLASS_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* For a nameless type, we don't want a create a symbol, thus we 	 did not use `sym'. Return without further processing. */
if|if
condition|(
name|nameless
condition|)
return|return
name|NULL
return|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|""
argument_list|,
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|?
literal|"enum "
else|:
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|?
literal|"struct "
else|:
literal|"union "
operator|)
operator|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|synonym
condition|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|typedef_sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|typedef_sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|typedef_sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
comment|/* Static symbol of local scope */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Reference parameter */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used by Sun FORTRAN for "function result value". 	 Sun claims ("dbx and dbxtool interfaces", 2nd ed) 	 that Pascal uses it too, but when I tried it Pascal used 	 "x:3" (local symbol) instead.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|valu
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid symbol data: unknown symbol-type code `%c' at symtab pos %d."
argument_list|,
name|deftype
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip rest of this symbol and return an error type.     General notes on error recovery:  error_type always skips to the    end of the symbol (modulo cretinous dbx symbol name continuation).    Thus code like this:     if (*(*pp)++ != ';')      return error_type (pp);     is wrong because if *pp starts out pointing at '\0' (typically as the    result of an earlier error), it will be incremented to point to the    start of the next symbol, which might produce strange results, at least    if you run off the end of the string table.  Instead use     if (**pp != ';')      return error_type (pp);    ++*pp;     or     if (**pp != ';')      foo = error_type (pp);    else      ++*pp;     And in case it isn't obvious, the point of all this hair is so the compiler    can define new types and new syntaxes, and old versions of the    debugger will be able to read the new symbol tables.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|error_type
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|complain
argument_list|(
operator|&
name|error_type_complaint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Skip to end of symbol.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
return|return
name|builtin_type_error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a dbx type reference or definition;    return the type that is meant.    This can be just a number, in which case it references    a type already defined and placed in type_vector.    Or the number can be followed by an =, in which case    it means to define a new type according to the text that    follows the =.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|read_type
parameter_list|(
name|pp
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|int
name|xtypenums
index|[
literal|2
index|]
decl_stmt|;
comment|/* Read type number if present.  The type number may be omitted.      for instance in a two-dimensional array declared with type      "ar1;1;10;ar1;1;10;4".  */
if|if
condition|(
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'('
condition|)
block|{
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
comment|/* Type is not being defined here.  Either it already exists, 	 or this is a forward reference to it.  dbx_alloc_type handles 	 both cases.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'='
condition|)
return|return
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
return|;
comment|/* Type is being defined here.  */
if|#
directive|if
literal|0
comment|/* Callers aren't prepared for a NULL result!  FIXME -- metin!  */
block|{ 	struct type *tt;
comment|/* if such a type already exists, this is an unnecessary duplication 	   of the stab string, which is common in (RS/6000) xlc generated 	   objects.  In that case, simply return NULL and let the caller take 	   care of it. */
block|tt = *dbx_lookup_type (typenums); 	if (tt&& tt->length&& tt->code) 	  return NULL;       }
endif|#
directive|endif
operator|*
name|pp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 'typenums=' not present, type is anonymous.  Read and return 	 the definition, but don't put it in the type vector.  */
name|typenums
index|[
literal|0
index|]
operator|=
name|typenums
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
block|{
name|enum
name|type_code
name|code
decl_stmt|;
comment|/* Used to index through file_symbols.  */
name|struct
name|pending
modifier|*
name|ppt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Name including "struct", etc.  */
name|char
modifier|*
name|type_name
decl_stmt|;
comment|/* Name without "struct", etc.  */
name|char
modifier|*
name|type_name_only
decl_stmt|;
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
comment|/* Set the type code according to the following letter.  */
switch|switch
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|prefix
operator|=
literal|"struct "
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
name|prefix
operator|=
literal|"union "
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|prefix
operator|=
literal|"enum "
expr_stmt|;
break|break;
default|default:
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
name|to
operator|=
name|type_name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
operator|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|':'
argument_list|)
operator|-
operator|(
operator|*
name|pp
operator|)
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the prefix.  */
name|from
operator|=
name|prefix
expr_stmt|;
while|while
condition|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
condition|)
empty_stmt|;
name|to
operator|--
expr_stmt|;
name|type_name_only
operator|=
name|to
expr_stmt|;
comment|/* Copy the name.  */
name|from
operator|=
operator|*
name|pp
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
operator|)
operator|!=
literal|':'
condition|)
empty_stmt|;
operator|*
operator|--
name|to
operator|=
literal|'\0'
expr_stmt|;
comment|/* Set the pointer ahead of the name which we just read.  */
operator|*
name|pp
operator|=
name|from
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The following hack is clearly wrong, because it doesn't 	     check whether we are in a baseclass.  I tried to reproduce 	     the case that it is trying to fix, but I couldn't get 	     g++ to put out a cross reference to a basetype.  Perhaps 	     it doesn't do it anymore.  */
comment|/* Note: for C++, the cross reference may be to a base type which 	     has not yet been seen.  In this case, we skip to the comma, 	     which will mark the end of the base class name.  (The ':' 	     at the end of the base class name will be skipped as well.) 	     But sometimes (ie. when the cross ref is the last thing on 	     the line) there will be no ','.  */
block|from = (char *) strchr (*pp, ','); 	  if (from) 	    *pp = from;
endif|#
directive|endif
comment|/* 0 */
block|}
comment|/* Now check to see whether the type has already been declared.  */
comment|/* This is necessary at least in the case where the 	   program says something like 	     struct foo bar[5]; 	   The compiler puts out a cross-reference; we better find 	   set the length of the structure correctly so we can 	   set the length of the array.  */
for|for
control|(
name|ppt
operator|=
name|file_symbols
init|;
name|ppt
condition|;
name|ppt
operator|=
name|ppt
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|ppt
operator|->
name|symbol
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|code
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type_name_only
argument_list|)
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
comment|/* Didn't find the type to which this refers, so we must 	   be dealing with a forward reference.  Allocate a type 	   structure for it, and keep track of it so we can 	   fill in the rest of the fields when we get the full 	   type.  */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|code
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|type_name
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
name|add_undefined_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
ifdef|#
directive|ifdef
name|IBM6000_HOST
case|case
literal|'-'
case|:
comment|/* RS/6000 built-in type */
operator|(
operator|*
name|pp
operator|)
operator|--
expr_stmt|;
name|type
operator|=
name|builtin_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* (in xcoffread.c) */
goto|goto
name|after_digits
goto|;
endif|#
directive|endif
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'('
case|:
operator|(
operator|*
name|pp
operator|)
operator|--
expr_stmt|;
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|xtypenums
argument_list|)
expr_stmt|;
name|type
operator|=
operator|*
name|dbx_lookup_type
argument_list|(
name|xtypenums
argument_list|)
expr_stmt|;
comment|/* fall through */
name|after_digits
label|:
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|type
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
comment|/* In the following types, we must be sure to overwrite any existing        type that the typenums refer to, rather than allocating a new one        and making the typenums point to the new one.  This is because there        may already be pointers to the existing type (if it had been        forward-referenced), and we must change it to a pointer, function,        reference, or whatever, *in-place*.  */
case|case
literal|'*'
case|:
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_pointer_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* Reference to another type */
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_reference_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Function returning another type */
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|make_function_type
argument_list|(
name|type1
argument_list|,
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Const qualifier on some type (Sun) */
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME! For now, we ignore const and volatile qualifiers.  */
break|break;
case|case
literal|'B'
case|:
comment|/* Volatile qual on some type (Sun) */
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME! For now, we ignore const and volatile qualifiers.  */
break|break;
comment|/* FIXME -- we should be doing smash_to_XXX types here.  */
case|case
literal|'@'
case|:
comment|/* Member (class& variable) type */
block|{
name|struct
name|type
modifier|*
name|domain
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Invalid member type data format.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
name|memtype
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* Method (class& fn) type */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
comment|/* We'll get the parameter types from the name.  */
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|return_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|!=
literal|';'
condition|)
name|complain
argument_list|(
operator|&
name|invalid_member_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symnum
argument_list|)
expr_stmt|;
name|type
operator|=
name|allocate_stub_method
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|domain
init|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|!=
literal|','
condition|)
name|error
argument_list|(
literal|"invalid member type data format, at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|return_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|args
operator|=
name|read_args
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_method_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|return_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* Range type */
name|type
operator|=
name|read_range_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Sun ACC builtin int type */
name|type
operator|=
name|read_sun_builtin_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Sun ACC builtin float type */
name|type
operator|=
name|read_sun_floating_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Enumeration type */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_enum_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Struct type */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|type_synonym_name
expr_stmt|;
name|type_synonym_name
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|read_struct_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Union type */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|type_synonym_name
expr_stmt|;
name|type_synonym_name
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|read_struct_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Array type */
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'r'
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_array_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|--
operator|*
name|pp
expr_stmt|;
comment|/* Go back to the symbol in error */
comment|/* Particularly important if it was \0! */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines of read_type.  */
end_comment

begin_comment
comment|/* Read the description of a structure (or union type)    and return an object describing the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|(
name|pp
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* Total number of methods defined in this class.      If the class defines two `f' methods, and one `g' method,      then this will have the value 3.  */
name|int
name|total_length
init|=
literal|0
decl_stmt|;
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|int
name|visibility
decl_stmt|;
comment|/* 0=public, 1=protected, 2=public */
name|struct
name|field
name|field
decl_stmt|;
block|}
struct|;
struct|struct
name|next_fnfield
block|{
name|struct
name|next_fnfield
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_field
name|fn_field
decl_stmt|;
block|}
struct|;
struct|struct
name|next_fnfieldlist
block|{
name|struct
name|next_fnfieldlist
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_fieldlist
name|fn_fieldlist
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|nextfield
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|nfields
init|=
literal|0
decl_stmt|;
name|int
name|non_public_fields
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|next_fnfieldlist
modifier|*
name|mainlist
init|=
literal|0
decl_stmt|;
name|int
name|nfn_fields
init|=
literal|0
decl_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
comment|/* First comes the total size in bytes.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* C++: Now, if the class is a derived class, then the next character      will be a '!', followed by the number of base classes derived from.      Each element in the list contains visibility information,      the offset of this base class in the derived structure,      and then the base type. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'!'
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|type
modifier|*
name|baseclass
decl_stmt|;
name|int
name|via_public
decl_stmt|;
comment|/* Nonzero if it is a virtual baseclass, i.e.,  	 struct A{}; 	 struct B{}; 	 struct C : public B, public virtual A {};  	 B is a baseclass of C; A is a virtual baseclass for C.  This is a C++ 	 2.0 language feature.  */
name|int
name|via_virtual
decl_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* Some stupid compilers have trouble with the following, so break 	 it up into simpler expressions.  */
if|#
directive|if
literal|0
block|TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *) 	TYPE_ALLOC (type, B_BYTES (n_baseclasses));
else|#
directive|else
block|{
name|int
name|num_bytes
init|=
name|B_BYTES
argument_list|(
name|n_baseclasses
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pointer
decl_stmt|;
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|pointer
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 0 */
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|n_baseclasses
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
name|via_virtual
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|via_virtual
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Bad visibility format.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
name|via_public
operator|=
literal|0
expr_stmt|;
name|non_public_fields
operator|++
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|via_public
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* Bad visibility format.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
if|if
condition|(
name|via_virtual
condition|)
name|SET_TYPE_FIELD_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* Offset of the portion of the object corresponding to 	     this baseclass.  Always zero in the absence of 	     multiple inheritance.  */
name|offset
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|baseclass
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
comment|/* skip trailing ';' */
comment|/* Make this baseclass visible for structure-printing purposes.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|visibility
operator|=
name|via_public
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|baseclass
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|baseclass
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
name|offset
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
comment|/* this should be an unpacked field! */
name|nfields
operator|++
expr_stmt|;
block|}
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|n_baseclasses
expr_stmt|;
block|}
comment|/* Now come the fields, as NAME:?TYPENUM,BITPOS,BITSIZE; for each one.      At the end, we see a semicolon instead of a field.       In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for      a static field.       The `?' is a placeholder for one of '/2' (public visibility),      '/1' (protected visibility), '/0' (private visibility), or nothing      (C style symbol table, public visibility).  */
comment|/* We better set p right now, in case there are no fields at all...    */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Get the field name.  */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|CPLUS_MARKER
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
comment|/* GNU C++ anonymous type.  */
empty_stmt|;
comment|/* Special GNU C++ name.  */
elseif|else
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'v'
condition|)
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|context
decl_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'f'
case|:
name|prefix
operator|=
name|vptr_name
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|prefix
operator|=
name|vb_name
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|invalid_cpp_abbrev_complaint
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|"INVALID_C++_ABBREV"
expr_stmt|;
break|break;
block|}
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|context
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|maybe_this_is_fixed
comment|/* 	       * Patch from Michael N. Lipp. 	       * 9204021327.AA02196@mailhost.dtro.e-technik.th-darmstadt.de> 	       * XXX - this isn't the right way to fix it, but it will at  	       * least keep gdb from faulting. 	       */
comment|/* if the ommitted type name is the name of the struct 		 being read, the name is not yet in TYPE_NAME(context). 		 Use long_kludge_name as a quick fix. */
if|if
condition|(
name|context
operator|==
name|type
condition|)
name|name
operator|=
name|long_kludge_name
expr_stmt|;
else|else
endif|#
directive|endif
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
name|complain
argument_list|(
operator|&
name|invalid_cpp_type_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symnum
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"FOO"
expr_stmt|;
block|}
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
name|complain
argument_list|(
operator|&
name|invalid_cpp_abbrev_complaint
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the comma.  */
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
comment|/* This field is unpacked.  */
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|visibility
operator|=
literal|0
expr_stmt|;
comment|/* private */
name|non_public_fields
operator|++
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
name|complain
argument_list|(
operator|&
name|invalid_cpp_abbrev_complaint
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
comment|/* C++: Check to see if we have hit the methods yet.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
break|break;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* This means we have a visibility for a field coming. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'/'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
name|list
operator|->
name|visibility
operator|=
literal|0
expr_stmt|;
comment|/* private */
name|non_public_fields
operator|++
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|list
operator|->
name|visibility
operator|=
literal|1
expr_stmt|;
comment|/* protected */
name|non_public_fields
operator|++
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|list
operator|->
name|visibility
operator|=
literal|2
expr_stmt|;
comment|/* public */
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* normal dbx-style format.  */
name|list
operator|->
name|visibility
operator|=
literal|2
expr_stmt|;
comment|/* public */
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
name|p
operator|=
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Possible future hook for nested types. */
block|if (**pp == '!') 	    { 	      list->field.bitpos = (long)-2;
comment|/* nested type */
block|p = ++(*pp); 	    } 	  else
endif|#
directive|endif
block|{
comment|/* Static class member.  */
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
operator|(
name|long
operator|)
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
name|p
operator|++
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
operator|(
name|long
operator|)
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Bad structure-type format.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the comma.  */
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME-tiemann: Can't the compiler put out something which 	 lets us distinguish these? (or maybe just not put out anything 	 for the field).  What is the story here?  What does the compiler 	really do?  Also, patch gdb.texinfo for this case; I document 	it as a possible problem there.  Search for "DBX-style".  */
comment|/* This is wrong because this is identical to the symbols 	 produced for GCC 0-size arrays.  For example:          typedef union { 	   int num; 	   char str[0]; 	 } foo; 	 The code which dumped core in such circumstances should be 	 fixed not to dump core.  */
comment|/* g++ -g0 can put out bitpos& bitsize zero for a static 	 field.  This does not give us any way of getting its 	 class, so we can't know its name.  But we can just 	 ignore the field so we don't dump core and other nasty 	 stuff.  */
block|if (list->field.bitpos == 0&& list->field.bitsize == 0) 	{ 	  complain (&dbx_class_complaint, 0);
comment|/* Ignore this field.  */
block|list = list->next; 	}       else
endif|#
directive|endif
comment|/* 0 */
block|{
comment|/* Detect an unpacked field and mark it as such. 	     dbx gives a bit size for all fields. 	     Note that forward refs cannot be packed, 	     and treat enums as if they had the width of ints.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|list
operator|->
name|field
operator|.
name|bitsize
operator|==
literal|8
operator|*
name|TYPE_LENGTH
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
operator|(
name|list
operator|->
name|field
operator|.
name|bitsize
operator|==
literal|8
operator|*
name|TYPE_LENGTH
argument_list|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|list
operator|->
name|field
operator|.
name|bitpos
operator|%
literal|8
operator|==
literal|0
condition|)
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
comment|/* chill the list of fields: the last entry (at the head)        is a partially constructed entry which we now scrub.  */
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
comment|/* Now create the vector of fields, and record how big it is.      We need this info to record proper virtual function table information      for this class's virtual functions.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|non_public_fields
condition|)
block|{
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
name|nfields
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|n
operator|-=
literal|1
expr_stmt|;
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|list
operator|->
name|field
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|visibility
operator|==
literal|0
condition|)
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|list
operator|->
name|visibility
operator|==
literal|1
condition|)
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* Now come the method fields, as NAME::methods      where each method is of the form TYPENUM,ARGS,...:PHYSNAME;      At the end, we see a semicolon instead of a field.       For the case of overloaded operators, the format is      op$::*.methods, where $ is the CPLUS_MARKER (usually '$'),      `*' holds the place for an operator name (such as `+=')      and `.' marks the end of the operator name.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Now, read in the methods.  To simplify matters, we 	 "unread" the name that has been read, so that we can 	 start from the top.  */
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* For each list of method lists... */
do|do
block|{
name|int
name|i
decl_stmt|;
name|struct
name|next_fnfield
modifier|*
name|sublist
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|look_ahead_type
init|=
name|NULL
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|struct
name|next_fnfieldlist
modifier|*
name|new_mainlist
decl_stmt|;
name|char
modifier|*
name|main_fn_name
decl_stmt|;
name|new_mainlist
operator|=
operator|(
expr|struct
name|next_fnfieldlist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_mainlist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* read in the name.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
operator|(
operator|*
name|pp
operator|)
index|[
literal|2
index|]
operator|==
name|CPLUS_MARKER
condition|)
block|{
comment|/* This is a completely wierd case.  In order to stuff in the 		 names that might contain colons (the usual name delimiter), 		 Mike Tiemann defined a different name format which is 		 signalled if the identifier is "op$".  In that case, the 		 format is "op$::XXXX." where XXXX is the name.  This is 		 used for names like "+" or "=".  YUUUUUUUK!  FIXME!  */
comment|/* This lets the user type "break operator+". 	         We could just put in "+" as the name, but that wouldn't 		 work for "*".  */
specifier|static
name|char
name|opname
index|[
literal|32
index|]
init|=
block|{
literal|'o'
block|,
literal|'p'
block|,
name|CPLUS_MARKER
block|}
decl_stmt|;
name|char
modifier|*
name|o
init|=
name|opname
operator|+
literal|3
decl_stmt|;
comment|/* Skip past '::'.  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|main_fn_name
operator|=
name|savestring
argument_list|(
name|opname
argument_list|,
name|o
operator|-
name|opname
argument_list|)
expr_stmt|;
comment|/* Skip past '.'  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|main_fn_name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
comment|/* Skip past '::'.  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
block|}
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|main_fn_name
expr_stmt|;
do|do
block|{
name|struct
name|next_fnfield
modifier|*
name|new_sublist
init|=
operator|(
expr|struct
name|next_fnfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|new_sublist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
name|look_ahead_type
operator|==
name|NULL
condition|)
comment|/* Normal case. */
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
comment|/* Invalid symtab info for method.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
else|else
block|{
comment|/* g++ version 1 kludge */
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
operator|=
name|look_ahead_type
expr_stmt|;
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* If this is just a stub, then we don't have the 		 real name here.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Set this method's visibility fields.  */
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|-
literal|'0'
condition|)
block|{
case|case
literal|0
case|:
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_private
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_protected
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* Normal functions. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* `const' member functions. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* `volatile' member function. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* `const volatile' member function. */
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_const
operator|=
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_volatile
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* File compiled with g++ version 1 -- no info */
case|case
literal|'?'
case|:
case|case
literal|'.'
case|:
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|const_vol_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|long
operator|)
operator|*
operator|*
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* virtual member function, followed by index.  */
comment|/* The sign bit is set to distinguish pointers-to-methods 		     from virtual function indicies.  Since the array is 		     in words, the quantity must be shifted left by 1 		     on 16 bit machine, and by 2 on 32 bit machine, forcing 		     the sign bit out, and usable as a valid index into 		     the array.  Remove the sign bit here.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
operator|(
literal|0x7fffffff
operator|&
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'\0'
condition|)
comment|/* Must be g++ version 1.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Figure out from whence this virtual function came. 			 It may belong to virtual function table of 			 one of its baseclasses.  */
name|look_ahead_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
comment|/* g++ version 1 overloaded methods. */
block|}
else|else
block|{
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
name|look_ahead_type
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
else|else
operator|++
operator|*
name|pp
expr_stmt|;
name|look_ahead_type
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
comment|/* static member function.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
name|VOFFSET_STATIC
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
argument_list|,
name|main_fn_name
argument_list|,
name|strlen
argument_list|(
name|main_fn_name
argument_list|)
argument_list|)
condition|)
name|new_sublist
operator|->
name|fn_field
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* error */
name|complain
argument_list|(
operator|&
name|member_fn_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
call|(
name|long
call|)
argument_list|(
operator|*
name|pp
argument_list|)
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Fall through into normal member function.  */
case|case
literal|'.'
case|:
comment|/* normal member function.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
literal|0
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|fcontext
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|new_sublist
operator|->
name|next
operator|=
name|sublist
expr_stmt|;
name|sublist
operator|=
name|new_sublist
expr_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
do|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
init|;
operator|(
name|i
operator|--
operator|,
name|sublist
operator|)
condition|;
name|sublist
operator|=
name|sublist
operator|->
name|next
control|)
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
index|[
name|i
index|]
operator|=
name|sublist
operator|->
name|fn_field
expr_stmt|;
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|new_mainlist
operator|->
name|next
operator|=
name|mainlist
expr_stmt|;
name|mainlist
operator|=
name|new_mainlist
expr_stmt|;
name|nfn_fields
operator|++
expr_stmt|;
name|total_length
operator|+=
name|length
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
do|;
block|}
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|nfn_fields
condition|)
block|{
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfn_fields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|total_length
expr_stmt|;
block|}
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNDEF
condition|)
comment|/* @@ Memory leak on objfile->type_obstack?  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|+=
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|n
operator|=
name|nfn_fields
init|;
name|mainlist
condition|;
name|mainlist
operator|=
name|mainlist
operator|->
name|next
control|)
block|{
operator|--
name|n
expr_stmt|;
comment|/* Circumvent Sun3 compiler bug */
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
index|[
name|n
index|]
operator|=
name|mainlist
operator|->
name|fn_fieldlist
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'~'
condition|)
block|{
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'='
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'+'
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
comment|/* Obsolete flags that used to indicate the presence 	     of constructors and/or destructors. */
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Read either a '%' or the final ';'.  */
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|==
literal|'%'
condition|)
block|{
comment|/* We'd like to be able to derive the vtable pointer field 	     from the type information, but when it's inherited, that's 	     hard.  A reason it's hard is because we may read in the 	     info about a derived class before we read in info about 	     the base class that provides the vtable pointer field. 	     Once the base info has been read, we could fill in the info 	     for the derived classes, but for the fact that by then, 	     we don't remember who needs what.  */
if|#
directive|if
literal|0
block|int predicted_fieldno = -1;
endif|#
directive|endif
comment|/* Now we must record the virtual function table pointer's 	     field information.  */
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|{
comment|/* In version 2, we derive the vfield ourselves.  */
block|for (n = 0; n< nfields; n++) 	      { 		if (! strncmp (TYPE_FIELD_NAME (type, n), vptr_name,  			       sizeof (vptr_name) -1)) 		  { 		    predicted_fieldno = n; 		    break; 		  } 	      } 	    if (predicted_fieldno< 0) 	      for (n = 0; n< TYPE_N_BASECLASSES (type); n++) 		if (! TYPE_FIELD_VIRTUAL (type, n)&& TYPE_VPTR_FIELDNO (TYPE_BASECLASS (type, n))>= 0) 		  { 		    predicted_fieldno = TYPE_VPTR_FIELDNO (TYPE_BASECLASS (type, n)); 		    break; 		  } 	  }
endif|#
directive|endif
name|t
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Premature end of symbol.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME-tiemann: what's this?  */
if|#
directive|if
literal|0
block|TYPE_VPTR_FIELDNO (type) = i = TYPE_N_BASECLASSES (t);
else|#
directive|else
name|error_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|--
name|i
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|vptr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|vptr_name
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
comment|/* Virtual function table field not found.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
else|else
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VPTR_FIELDNO
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TYPE_VPTR_FIELDNO (type) != predicted_fieldno) 	    error ("TYPE_VPTR_FIELDNO miscalculated");
endif|#
directive|endif
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an array type,    and create and return a suitable type object.    Also creates a range type which represents the bounds of that    array.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_array_type
parameter_list|(
name|pp
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|index_type
decl_stmt|,
modifier|*
name|element_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|int
name|adjustable
init|=
literal|0
decl_stmt|;
comment|/* Format of an array type:      "ar<index type>;lower;upper;<array_contents_type>".  Put code in      to handle this.       Fortran adjustable arrays use Adigits or Tdigits for lower or upper;      for these, produce a type like float[][].  */
name|index_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
comment|/* Improper format of array type decl.  */
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
condition|)
block|{
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|adjustable
operator|=
literal|1
expr_stmt|;
block|}
name|lower
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
condition|)
block|{
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|adjustable
operator|=
literal|1
expr_stmt|;
block|}
name|upper
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|element_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjustable
condition|)
block|{
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|{
comment|/* Create range type.  */
name|range_type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|range_type
argument_list|)
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|range_type
argument_list|)
operator|=
name|index_type
expr_stmt|;
comment|/* This should never be needed.  */
name|TYPE_LENGTH
argument_list|(
name|range_type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|range_type
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|range_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|range_type
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|range_type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|0
argument_list|)
operator|=
name|lower
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|1
argument_list|)
operator|=
name|upper
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|element_type
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|upper
operator|-
name|lower
operator|+
literal|1
operator|)
operator|*
name|TYPE_LENGTH
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
name|range_type
expr_stmt|;
comment|/* If we have an array whose element type is not yet known, but whose      bounds *are* known, record it to be adjusted at the end of the file.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|element_type
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|adjustable
condition|)
name|add_undefined_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an enumeration type,    and create and return a suitable type object.    Also defines the symbols that represent the values of the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|(
name|pp
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|long
name|n
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|;
name|struct
name|pending
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
name|int
name|o_nsyms
decl_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME!  The stabs produced by Sun CC merrily define things that ought      to be file-scope, between N_FN entries, using N_LSYM.  What's a mother      to do?  For now, force all enum values to file scope.  */
block|if (within_function)     symlist =&local_symbols;   else
endif|#
directive|endif
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
name|o_nsyms
operator|=
name|osyms
condition|?
name|osyms
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
comment|/* Read the value-names and their values.      The input syntax is NAME:VALUE,NAME:VALUE, and so on.      A semicolon or comma instead of a NAME means the end.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|name
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|name
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|n
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the semicolon.  */
comment|/* Now fill in the fields of the type-structure.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the values and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.  */
comment|/* Note that we preserve the order of the enum constants, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
name|j
operator|=
name|o_nsyms
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|xsym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|xsym
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VALUE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
break|break;
block|}
if|#
directive|if
literal|0
comment|/* This screws up perfectly good C programs with enums.  FIXME.  */
comment|/* Is this Modula-2's BOOLEAN type?  Flag it as such if so. */
block|if(TYPE_NFIELDS(type) == 2&&      ((!strcmp(TYPE_FIELD_NAME(type,0),"TRUE")&&        !strcmp(TYPE_FIELD_NAME(type,1),"FALSE")) ||       (!strcmp(TYPE_FIELD_NAME(type,1),"TRUE")&&        !strcmp(TYPE_FIELD_NAME(type,0),"FALSE"))))      TYPE_CODE(type) = TYPE_CODE_BOOL;
endif|#
directive|endif
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Sun's ACC uses a somewhat saner method for specifying the builtin    typedefs in every file (for int, long, etc):  	type = b<signed><width>;<offset>;<nbits> 	signed = u or s.  Possible c in addition to u or s (for char?). 	offset = offset from high order bit to start bit of type. 	width is # bytes in object of this type, nbits is # bits in type.     The width/offset stuff appears to be for small objects stored in    larger ones (e.g. `shorts' in `int' registers).  We ignore it for now,    FIXME.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_sun_builtin_type
parameter_list|(
name|pp
parameter_list|,
name|typenums
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|nbits
decl_stmt|;
name|int
name|signed_type
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'s'
case|:
name|signed_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|signed_type
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* For some odd reason, all forms of char put a c here.  This is strange      because no other type has this honor.  We can safely ignore this because      we actually determine 'char'acterness by the number of bits specified in      the descriptor.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'c'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* The first number appears to be the number of bytes occupied      by this type, except that unsigned short is 4 instead of 2.      Since this information is redundant with the third number,      we will ignore it.  */
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
comment|/* The second number is always 0, so ignore it too. */
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
comment|/* The third number is the number of bits for this type. */
name|nbits
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME.  Here we should just be able to make a type of the right      number of bits and signedness.  FIXME.  */
if|if
condition|(
name|nbits
operator|==
name|TARGET_LONG_LONG_BIT
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|signed_type
condition|?
name|FT_LONG_LONG
else|:
name|FT_UNSIGNED_LONG_LONG
argument_list|)
operator|)
return|;
if|if
condition|(
name|nbits
operator|==
name|TARGET_INT_BIT
condition|)
block|{
comment|/* FIXME -- the only way to distinguish `int' from `long' 	 is to look at its name!  */
if|if
condition|(
name|signed_type
condition|)
block|{
if|if
condition|(
name|long_kludge_name
operator|&&
name|long_kludge_name
index|[
literal|0
index|]
operator|==
literal|'l'
comment|/* long */
condition|)
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_LONG
argument_list|)
return|;
else|else
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|long_kludge_name
operator|&&
operator|(
operator|(
name|long_kludge_name
index|[
literal|0
index|]
operator|==
literal|'u'
comment|/* unsigned */
operator|&&
name|long_kludge_name
index|[
literal|9
index|]
operator|==
literal|'l'
comment|/* long */
operator|)
operator|||
operator|(
name|long_kludge_name
index|[
literal|0
index|]
operator|==
literal|'l'
comment|/* long unsigned */
operator|)
operator|)
condition|)
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_LONG
argument_list|)
return|;
else|else
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|nbits
operator|==
name|TARGET_SHORT_BIT
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|signed_type
condition|?
name|FT_SHORT
else|:
name|FT_UNSIGNED_SHORT
argument_list|)
operator|)
return|;
if|if
condition|(
name|nbits
operator|==
name|TARGET_CHAR_BIT
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|signed_type
condition|?
name|FT_CHAR
else|:
name|FT_UNSIGNED_CHAR
argument_list|)
operator|)
return|;
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_sun_floating_type
parameter_list|(
name|pp
parameter_list|,
name|typenums
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|nbytes
decl_stmt|;
comment|/* The first number has more details about the type, for example      FN_COMPLEX.  See the sun stab.h.  */
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
comment|/* The second number is the number of bytes occupied by this type */
name|nbytes
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|0
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
if|if
condition|(
name|nbytes
operator|==
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
condition|)
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_FLOAT
argument_list|)
return|;
if|if
condition|(
name|nbytes
operator|==
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
condition|)
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
return|;
if|if
condition|(
name|nbytes
operator|==
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
condition|)
return|return
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_EXT_PREC_FLOAT
argument_list|)
return|;
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a number from the string pointed to by *PP.    The value of *PP is advanced over the number.    If END is nonzero, the character that ends the    number must match END, or an error happens;    and that character is skipped if it does match.    If END is zero, *PP is left pointing to that character.     If the number fits in a long, set *VALUE and set *BITS to 0.    If not, set *BITS to be the number of bits in the number.     If encounter garbage, set *BITS to -1.  */
end_comment

begin_function
specifier|static
name|void
name|read_huge_number
parameter_list|(
name|pp
parameter_list|,
name|end
parameter_list|,
name|valu
parameter_list|,
name|bits
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|end
decl_stmt|;
name|long
modifier|*
name|valu
decl_stmt|;
name|int
modifier|*
name|bits
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
name|long
name|n
init|=
literal|0
decl_stmt|;
name|int
name|radix
init|=
literal|10
decl_stmt|;
name|char
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|nbits
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|long
name|upper_limit
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Leading zero means octal.  GCC uses this to output values larger      than an int (because that would be hard in decimal).  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
name|radix
operator|=
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|upper_limit
operator|=
name|LONG_MAX
operator|/
name|radix
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
operator|(
literal|'0'
operator|+
name|radix
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|<=
name|upper_limit
condition|)
block|{
name|n
operator|*=
name|radix
expr_stmt|;
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* FIXME this overflows anyway */
block|}
else|else
name|overflow
operator|=
literal|1
expr_stmt|;
comment|/* This depends on large values being output in octal, which is 	 what GCC does. */
if|if
condition|(
name|radix
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
comment|/* Ignore leading zeroes.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'1'
condition|)
name|nbits
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'2'
operator|||
name|c
operator|==
literal|'3'
condition|)
name|nbits
operator|=
literal|2
expr_stmt|;
else|else
name|nbits
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|nbits
operator|+=
literal|3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|c
operator|&&
name|c
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
operator|*
name|bits
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
operator|--
name|p
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
block|{
comment|/* Large decimal constants are an error (because it is hard to 	     count how many bits are in them).  */
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
operator|*
name|bits
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* -0x7f is the same as 0x80.  So deal with it by adding one to 	 the number of bits.  */
if|if
condition|(
name|sign
operator|==
operator|-
literal|1
condition|)
operator|++
name|nbits
expr_stmt|;
if|if
condition|(
name|bits
condition|)
operator|*
name|bits
operator|=
name|nbits
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|valu
condition|)
operator|*
name|valu
operator|=
name|n
operator|*
name|sign
expr_stmt|;
if|if
condition|(
name|bits
condition|)
operator|*
name|bits
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_range_type
parameter_list|(
name|pp
parameter_list|,
name|typenums
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|rangenums
index|[
literal|2
index|]
decl_stmt|;
name|long
name|n2
decl_stmt|,
name|n3
decl_stmt|;
name|int
name|n2bits
decl_stmt|,
name|n3bits
decl_stmt|;
name|int
name|self_subrange
decl_stmt|;
name|struct
name|type
modifier|*
name|result_type
decl_stmt|;
comment|/* First comes a type we are a subrange of.      In C it is usually 0, 1 or the type being defined.  */
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|rangenums
argument_list|)
expr_stmt|;
name|self_subrange
operator|=
operator|(
name|rangenums
index|[
literal|0
index|]
operator|==
name|typenums
index|[
literal|0
index|]
operator|&&
name|rangenums
index|[
literal|1
index|]
operator|==
name|typenums
index|[
literal|1
index|]
operator|)
expr_stmt|;
comment|/* A semicolon should now follow; skip it.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* The remaining two operands are usually lower and upper bounds      of the range.  But in some special cases they mean something else.  */
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|n2
argument_list|,
operator|&
name|n2bits
argument_list|)
expr_stmt|;
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|n3
argument_list|,
operator|&
name|n3bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2bits
operator|==
operator|-
literal|1
operator|||
name|n3bits
operator|==
operator|-
literal|1
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
comment|/* If limits are huge, must be large integral type.  */
if|if
condition|(
name|n2bits
operator|!=
literal|0
operator|||
name|n3bits
operator|!=
literal|0
condition|)
block|{
name|char
name|got_signed
init|=
literal|0
decl_stmt|;
name|char
name|got_unsigned
init|=
literal|0
decl_stmt|;
comment|/* Number of bits in the type.  */
name|int
name|nbits
decl_stmt|;
comment|/* Range from 0 to<large number> is an unsigned large integral type.  */
if|if
condition|(
operator|(
name|n2bits
operator|==
literal|0
operator|&&
name|n2
operator|==
literal|0
operator|)
operator|&&
name|n3bits
operator|!=
literal|0
condition|)
block|{
name|got_unsigned
operator|=
literal|1
expr_stmt|;
name|nbits
operator|=
name|n3bits
expr_stmt|;
block|}
comment|/* Range from<large number> to<large number>-1 is a large signed 	 integral type.  */
elseif|else
if|if
condition|(
name|n2bits
operator|!=
literal|0
operator|&&
name|n3bits
operator|!=
literal|0
operator|&&
name|n2bits
operator|==
name|n3bits
operator|+
literal|1
condition|)
block|{
name|got_signed
operator|=
literal|1
expr_stmt|;
name|nbits
operator|=
name|n2bits
expr_stmt|;
block|}
comment|/* Check for "long long".  */
if|if
condition|(
name|got_signed
operator|&&
name|nbits
operator|==
name|TARGET_LONG_LONG_BIT
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_LONG_LONG
argument_list|)
operator|)
return|;
if|if
condition|(
name|got_unsigned
operator|&&
name|nbits
operator|==
name|TARGET_LONG_LONG_BIT
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_LONG_LONG
argument_list|)
operator|)
return|;
if|if
condition|(
name|got_signed
operator|||
name|got_unsigned
condition|)
block|{
name|result_type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
name|nbits
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_CODE_INT
expr_stmt|;
if|if
condition|(
name|got_unsigned
condition|)
name|TYPE_FLAGS
argument_list|(
name|result_type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
return|return
name|result_type
return|;
block|}
else|else
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
block|}
comment|/* A type defined as a subrange of itself, with bounds both 0, is void.  */
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|0
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
operator|)
return|;
comment|/* If n3 is zero and n2 is not, we want a floating type,      and n2 is the width in bytes.       Fortran programs appear to use this for complex types also,      and they give no way to distinguish between double and single-complex!      We don't have complex types, so we would lose on all fortran files!      So return type `double' for all of those.  It won't work right      for the complex values, but at least it makes the file loadable.       FIXME, we may be able to distinguish these by their names. FIXME.  */
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n2
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_FLOAT
argument_list|)
operator|)
return|;
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
operator|)
return|;
block|}
comment|/* If the upper bound is -1, it must really be an unsigned int.  */
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* FIXME -- the only way to distinguish `unsigned int' from `unsigned          long' is to look at its name!  */
if|if
condition|(
name|long_kludge_name
operator|&&
operator|(
operator|(
name|long_kludge_name
index|[
literal|0
index|]
operator|==
literal|'u'
comment|/* unsigned */
operator|&&
name|long_kludge_name
index|[
literal|9
index|]
operator|==
literal|'l'
comment|/* long */
operator|)
operator|||
operator|(
name|long_kludge_name
index|[
literal|0
index|]
operator|==
literal|'l'
comment|/* long unsigned */
operator|)
operator|)
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_LONG
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
operator|)
return|;
block|}
comment|/* Special case: char is defined (Who knows why) as a subrange of      itself with range 0-127.  */
elseif|else
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|127
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_CHAR
argument_list|)
operator|)
return|;
comment|/* Assumptions made here: Subrange of self is equivalent to subrange      of int.  FIXME:  Host and target type-sizes assumed the same.  */
comment|/* FIXME:  This is the *only* place in GDB that depends on comparing      some type to a builtin type with ==.  Fix it! */
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
operator|&&
operator|(
name|self_subrange
operator|||
operator|*
name|dbx_lookup_type
argument_list|(
name|rangenums
argument_list|)
operator|==
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
operator|)
condition|)
block|{
comment|/* an unsigned type */
ifdef|#
directive|ifdef
name|LONG_LONG
if|if
condition|(
name|n3
operator|==
operator|-
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_LONG_LONG
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* FIXME -- the only way to distinguish `unsigned int' from `unsigned 	 long' is to look at its name!  */
if|if
condition|(
name|n3
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|~
literal|0L
operator|&&
name|long_kludge_name
operator|&&
operator|(
operator|(
name|long_kludge_name
index|[
literal|0
index|]
operator|==
literal|'u'
comment|/* unsigned */
operator|&&
name|long_kludge_name
index|[
literal|9
index|]
operator|==
literal|'l'
comment|/* long */
operator|)
operator|||
operator|(
name|long_kludge_name
index|[
literal|0
index|]
operator|==
literal|'l'
comment|/* long unsigned */
operator|)
operator|)
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_LONG
argument_list|)
operator|)
return|;
if|if
condition|(
name|n3
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|~
literal|0L
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
operator|)
return|;
if|if
condition|(
name|n3
operator|==
operator|(
name|unsigned
name|short
operator|)
operator|~
literal|0L
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_SHORT
argument_list|)
operator|)
return|;
if|if
condition|(
name|n3
operator|==
operator|(
name|unsigned
name|char
operator|)
operator|~
literal|0L
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|LONG_LONG
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|==
operator|-
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_LONG_LONG
argument_list|)
operator|)
return|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|n2
operator|==
operator|-
name|n3
operator|-
literal|1
condition|)
block|{
comment|/* a signed type */
comment|/* FIXME -- the only way to distinguish `int' from `long' is to look 	 at its name!  */
if|if
condition|(
operator|(
name|n3
operator|==
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
argument_list|)
operator|)
operator|&&
name|long_kludge_name
operator|&&
name|long_kludge_name
index|[
literal|0
index|]
operator|==
literal|'l'
comment|/* long */
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_LONG
argument_list|)
operator|)
return|;
if|if
condition|(
name|n3
operator|==
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
operator|)
return|;
if|if
condition|(
name|n3
operator|==
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SHORT
argument_list|)
operator|)
return|;
if|if
condition|(
name|n3
operator|==
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_CHAR
argument_list|)
operator|)
return|;
block|}
comment|/* We have a real range type on our hands.  Allocate space and      return a real pointer.  */
comment|/* At this point I don't have the faintest idea how to deal with      a self_subrange type; I'm going to assume that this is used      as an idiom, and that all of them are special cases.  So . . .  */
if|if
condition|(
name|self_subrange
condition|)
return|return
name|error_type
argument_list|(
name|pp
argument_list|)
return|;
name|result_type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
operator|=
operator|*
name|dbx_lookup_type
argument_list|(
name|rangenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|complain
argument_list|(
operator|&
name|range_type_base_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rangenums
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
block|}
name|TYPE_NFIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|result_type
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|result_type
argument_list|,
literal|0
argument_list|)
operator|=
name|n2
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|result_type
argument_list|,
literal|1
argument_list|)
operator|=
name|n3
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result_type
return|;
block|}
end_function

begin_comment
comment|/* Read a number from the string pointed to by *PP.    The value of *PP is advanced over the number.    If END is nonzero, the character that ends the    number must match END, or an error happens;    and that character is skipped if it does match.    If END is zero, *PP is left pointing to that character.  */
end_comment

begin_function
name|long
name|read_number
parameter_list|(
name|pp
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|end
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
specifier|register
name|long
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
comment|/* Handle an optional leading minus sign.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Read the digits, as far as they go.  */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|c
operator|&&
name|c
operator|!=
name|end
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: invalid character \\%03o at symbol pos %d."
argument_list|,
name|c
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
else|else
operator|--
name|p
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|n
operator|*
name|sign
return|;
block|}
end_function

begin_comment
comment|/* Read in an argument list.  This is a list of types, separated by commas    and terminated with END.  Return the list of types read in, or (struct type    **)-1 if there is an error.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|read_args
parameter_list|(
name|pp
parameter_list|,
name|end
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|end
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* FIXME!  Remove this arbitrary limit!  */
name|struct
name|type
modifier|*
name|types
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
modifier|*
name|rval
decl_stmt|;
comment|/* allow for fns of 1023 parameters */
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
comment|/* Invalid argument list: no ','.  */
return|return
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
operator|-
literal|1
return|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
comment|/* Check for and handle cretinous dbx symbol name continuation! */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
name|types
index|[
name|n
operator|++
index|]
operator|=
name|read_type
argument_list|(
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
comment|/* get past `end' (the ':' character) */
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|types
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rval
operator|+
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|rval
argument_list|,
name|types
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Add a common block's start address to the offset of each symbol    declared to be in it (by being between a BCOMM/ECOMM pair that uses    the common block name).  */
end_comment

begin_function
specifier|static
name|void
name|fix_common_block
parameter_list|(
name|sym
parameter_list|,
name|valu
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|valu
decl_stmt|;
block|{
name|struct
name|pending
modifier|*
name|next
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|next
operator|->
name|nsyms
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|next
operator|->
name|symbol
index|[
name|j
index|]
argument_list|)
operator|+=
name|valu
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* What about types defined as forward references inside of a small lexical    scope?  */
end_comment

begin_comment
comment|/* Add a type to the list of undefined types to be checked through    once this file has been read in.  */
end_comment

begin_function
name|void
name|add_undefined_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|undef_types_length
operator|==
name|undef_types_allocated
condition|)
block|{
name|undef_types_allocated
operator|*=
literal|2
expr_stmt|;
name|undef_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|undef_types
argument_list|,
name|undef_types_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|undef_types
index|[
name|undef_types_length
operator|++
index|]
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through each undefined type, see if it's still undefined, and fix it    up if possible.  We have two kinds of undefined types:     TYPE_CODE_ARRAY:  Array whose target type wasn't defined yet. 			Fix:  update array length using the element bounds 			and the target type's length.    TYPE_CODE_STRUCT, TYPE_CODE_UNION:  Structure whose fields were not 			yet defined at the time a pointer to it was made.    			Fix:  Do a full lookup on the struct/union tag.  */
end_comment

begin_function
name|void
name|cleanup_undefined_types
parameter_list|()
block|{
name|struct
name|type
modifier|*
modifier|*
name|type
decl_stmt|;
for|for
control|(
name|type
operator|=
name|undef_types
init|;
name|type
operator|<
name|undef_types
operator|+
name|undef_types_length
condition|;
name|type
operator|++
control|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
block|{
comment|/* Check if it has been defined since.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
operator|*
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|struct
name|pending
modifier|*
name|ppt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Name of the type, without "struct" or "union" */
name|char
modifier|*
name|typename
init|=
name|TYPE_NAME
argument_list|(
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|typename
argument_list|,
literal|"struct "
argument_list|,
literal|7
argument_list|)
condition|)
name|typename
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|typename
argument_list|,
literal|"union "
argument_list|,
literal|6
argument_list|)
condition|)
name|typename
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|typename
argument_list|,
literal|"enum "
argument_list|,
literal|5
argument_list|)
condition|)
name|typename
operator|+=
literal|5
expr_stmt|;
for|for
control|(
name|ppt
operator|=
name|file_symbols
init|;
name|ppt
condition|;
name|ppt
operator|=
name|ppt
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|ppt
operator|->
name|symbol
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|typename
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|*
name|type
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
block|{
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Better be unknown */
goto|goto
name|badtype
goto|;
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|badtype
goto|;
name|range_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
operator|*
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|range_type
argument_list|)
operator|!=
name|TYPE_CODE_RANGE
condition|)
goto|goto
name|badtype
goto|;
comment|/* Now recompute the length of the array type, based on its 	       number of elements and the target type's length.  */
name|lower
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|upper
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
operator|*
name|type
argument_list|)
operator|=
operator|(
name|upper
operator|-
name|lower
operator|+
literal|1
operator|)
operator|*
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|badtype
label|:
name|error
argument_list|(
literal|"GDB internal error.  cleanup_undefined_types with bad type %d."
argument_list|,
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|undef_types_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan through all of the global symbols defined in the object file,    assigning values to the debugging symbols that need to be assigned    to.  Get these symbols from the minimal symbol table.  */
end_comment

begin_function
name|void
name|scan_file_globals
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|msymbols
operator|==
literal|0
condition|)
comment|/* Beware the null file.  */
return|return;
for|for
control|(
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
init|;
name|msymbol
operator|->
name|name
operator|!=
name|NULL
condition|;
name|msymbol
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* Get the hash index and check all the symbols 	 under that hash index. */
name|hash
operator|=
name|hashname
argument_list|(
name|msymbol
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
init|;
name|sym
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|msymbol
operator|->
name|name
operator|)
operator|==
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|msymbol
operator|->
name|name
operator|+
literal|1
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* Splice this symbol out of the hash chain and 		 assign the value we have to it. */
if|if
condition|(
name|prev
condition|)
block|{
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|global_sym_chain
index|[
name|hash
index|]
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see whether we need to fix up a common block.  */
comment|/* Note: this code might be executed several times for 		 the same symbol if there are multiple references.  */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
name|fix_common_block
argument_list|(
name|sym
argument_list|,
name|msymbol
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|msymbol
operator|->
name|address
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when starting to read    a fresh piece of a symbol file, e.g. reading in the stuff corresponding    to a psymtab.  */
end_comment

begin_function
name|void
name|stabsread_init
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
name|void
name|stabsread_new_init
parameter_list|()
block|{
comment|/* Empty the hash table of global syms looking for values.  */
name|memset
argument_list|(
name|global_sym_chain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|global_sym_chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing at the same time as    start_symtab() is called. */
end_comment

begin_function
name|void
name|start_stabs
parameter_list|()
block|{
name|global_stabs
operator|=
name|NULL
expr_stmt|;
comment|/* AIX COFF */
comment|/* Leave FILENUM of 0 free for builtin types and this file's types.  */
name|n_this_object_header_files
operator|=
literal|1
expr_stmt|;
name|type_vector_length
operator|=
literal|0
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call after end_symtab() */
end_comment

begin_function
name|void
name|end_stabs
parameter_list|()
block|{
if|if
condition|(
name|type_vector
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_vector
argument_list|)
expr_stmt|;
block|}
name|type_vector
operator|=
literal|0
expr_stmt|;
name|type_vector_length
operator|=
literal|0
expr_stmt|;
name|previous_stab_code
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_global_stabs
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|global_stabs
condition|)
block|{
name|patch_block_stabs
argument_list|(
name|global_symbols
argument_list|,
name|global_stabs
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|global_stabs
argument_list|)
expr_stmt|;
name|global_stabs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initializer for this module */
end_comment

begin_function
name|void
name|_initialize_stabsread
parameter_list|()
block|{
name|undef_types_allocated
operator|=
literal|20
expr_stmt|;
name|undef_types_length
operator|=
literal|0
expr_stmt|;
name|undef_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|undef_types_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

