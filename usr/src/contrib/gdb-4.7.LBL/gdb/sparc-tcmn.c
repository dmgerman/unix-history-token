begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Lawrence Berkeley Laboratory,  * Berkeley, CA.  The name of the University may not be used to  * endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: sparc-tcmn.c,v 1.2 93/02/19 15:25:05 mccanne Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/*  * Sparc instruction format per Fig 4-1 of the Sun SPARC Architecture   * Manual Part No: 800-1399-08 Rev A, Oct 22 1987.  */
end_comment

begin_union
union|union
name|sparcinsn
block|{
name|u_long
name|code
decl_stmt|;
struct|struct
block|{
name|u_int
name|op
range|:
literal|2
decl_stmt|;
name|u_int
name|disp30
range|:
literal|30
decl_stmt|;
block|}
name|f1
struct|;
struct|struct
name|insn_f2a
block|{
name|u_int
name|op
range|:
literal|2
decl_stmt|;
name|u_int
name|rd
range|:
literal|5
decl_stmt|;
name|u_int
name|op2
range|:
literal|3
decl_stmt|;
name|int
name|imm22
range|:
literal|22
decl_stmt|;
block|}
name|f2a
struct|;
struct|struct
name|insn_f2b
block|{
name|u_int
name|op
range|:
literal|2
decl_stmt|;
name|u_int
name|a
range|:
literal|1
decl_stmt|;
name|u_int
name|cond
range|:
literal|4
decl_stmt|;
name|u_int
name|op2
range|:
literal|3
decl_stmt|;
name|int
name|disp22
range|:
literal|22
decl_stmt|;
block|}
name|f2b
struct|;
struct|struct
name|insn_f3a
block|{
name|u_int
name|op
range|:
literal|2
decl_stmt|;
name|u_int
name|rd
range|:
literal|5
decl_stmt|;
name|u_int
name|op3
range|:
literal|6
decl_stmt|;
name|u_int
name|rs1
range|:
literal|5
decl_stmt|;
name|u_int
name|i
range|:
literal|1
decl_stmt|;
name|u_int
name|asi
range|:
literal|8
decl_stmt|;
name|u_int
name|rs2
range|:
literal|5
decl_stmt|;
block|}
name|f3a
struct|;
struct|struct
name|insn_f3b
block|{
name|u_int
name|op
range|:
literal|2
decl_stmt|;
name|u_int
name|rd
range|:
literal|5
decl_stmt|;
name|u_int
name|op3
range|:
literal|6
decl_stmt|;
name|u_int
name|rs1
range|:
literal|5
decl_stmt|;
name|u_int
name|i
range|:
literal|1
decl_stmt|;
name|int
name|simm13
range|:
literal|13
decl_stmt|;
block|}
name|f3b
struct|;
block|}
union|;
end_union

begin_comment
comment|/*  * For the instruction INSN at PC, return the address, other than NPC, that  * could possibly be executed next.  If the only possibility is npc, return 0.  * (There is only one such "other" possible address.)  */
end_comment

begin_function
name|CORE_ADDR
name|annulled_dest
parameter_list|(
name|insn
parameter_list|,
name|pc
parameter_list|,
name|npc
parameter_list|)
name|union
name|sparcinsn
name|insn
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|,
name|npc
decl_stmt|;
block|{
specifier|register
name|struct
name|insn_f2b
name|i
init|=
name|insn
operator|.
name|f2b
decl_stmt|;
comment|/* 	 * The only time we can branch somewhere other than npc is 	 * on a branch intruction with the anull bit set.  In this 	 * case, the other possible target is the npc + 4 (because 	 * npc was anulled and the branch was not taken) or the 	 * branch destination (because npc was anulled and it was 	 * a branch always). 	 */
if|if
condition|(
name|i
operator|.
name|op
operator|==
literal|0
operator|&&
name|i
operator|.
name|a
operator|&&
operator|(
name|i
operator|.
name|op2
operator|==
literal|2
operator|||
name|i
operator|.
name|op2
operator|==
literal|6
operator|||
name|i
operator|.
name|op2
operator|==
literal|7
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|cond
operator|==
literal|8
condition|)
return|return
operator|(
name|pc
operator|+
literal|4
operator|*
name|i
operator|.
name|disp22
operator|)
return|;
else|else
return|return
operator|(
name|npc
operator|+
literal|4
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Non-zero if we just simulated a single-step ptrace call.  This is  * needed because we cannot remove the breakpoints in the inferior  * process until after the `wait' in `wait_for_inferior'.   * Used for sun4.  */
end_comment

begin_decl_stmt
name|int
name|one_stepped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * single_step() is called just before we want to resume the inferior,  * if we want to single-step it but there is no hardware or kernel single-step  * support (as on all SPARCs).  We find all the possible targets of the  * coming instruction and breakpoint them.  *  * single_step is also called just after the inferior stops.  If we had  * set up a simulated single-step, we undo our damage.  *  * Code written by Gary Beihl (beihl@mcc.com); modified by Steven McCanne  * (mccanne@ee.lbl.gov).  */
end_comment

begin_function
name|void
name|single_step
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|union
name|sparcinsn
name|insn
decl_stmt|;
comment|/* 	 * Storage for temporary breakpoints.  XXX There should be a uniform 	 * interface for breakpoints, so that we could just set one then  	 * clear it.  Note that we need only two outstanding breakpoints, 	 * since there can be at most two possiblilities for control flow. 	 */
specifier|static
name|CORE_ADDR
name|target0
decl_stmt|;
specifier|static
name|CORE_ADDR
name|target1
decl_stmt|;
specifier|static
name|char
name|shadow0
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|char
name|shadow1
index|[
literal|4
index|]
decl_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|insn
operator|.
name|code
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|one_stepped
condition|)
block|{
comment|/* 		 * This is a hack to special case call instructions. 		 * If we are stepping over subroutines, find each call 		 * and trap on return, rather than single step until 		 * wait_for_inferior() discovers that we hit a new routine. 		 * The reason is that stepping over functions in a remote  		 * kernel can have bad results when the function being  		 * stepped over is used by the kernel in between traps. 		 * (i.e., a trap instruction gets poked into the function 		 * being stepped over). 		 */
if|if
condition|(
name|step_over_calls
operator|>
literal|0
operator|&&
operator|(
operator|(
name|insn
operator|.
name|code
operator|&
literal|0xc0000000
operator|)
operator|==
literal|0x40000000
operator|||
operator|(
name|insn
operator|.
name|code
operator|&
literal|0xfff80000
operator|)
operator|==
literal|0x9fc00000
operator|)
condition|)
block|{
name|target0
operator|=
name|PC_ADJUST
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|target1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|target0
operator|=
name|read_register
argument_list|(
name|NPC_REGNUM
argument_list|)
expr_stmt|;
name|target1
operator|=
name|annulled_dest
argument_list|(
name|insn
argument_list|,
name|pc
argument_list|,
name|target0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target1
operator|==
name|target0
condition|)
name|target1
operator|=
literal|0
expr_stmt|;
block|}
name|target_insert_breakpoint
argument_list|(
name|target0
argument_list|,
name|shadow0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target1
condition|)
name|target_insert_breakpoint
argument_list|(
name|target1
argument_list|,
name|shadow1
argument_list|)
expr_stmt|;
name|one_stepped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove breakpoints */
if|if
condition|(
name|target1
condition|)
name|target_remove_breakpoint
argument_list|(
name|target1
argument_list|,
name|shadow1
argument_list|)
expr_stmt|;
name|target_remove_breakpoint
argument_list|(
name|target0
argument_list|,
name|shadow0
argument_list|)
expr_stmt|;
name|one_stepped
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX this looks polluted */
end_comment

begin_define
define|#
directive|define
name|FRAME_SAVED_L0
value|0
end_define

begin_comment
comment|/* Byte offset from SP */
end_comment

begin_define
define|#
directive|define
name|FRAME_SAVED_I0
value|32
end_define

begin_comment
comment|/* Byte offset from SP */
end_comment

begin_comment
comment|/*  * Find the previous stack frame pointer, given the current frame.  * On a sparc, this is just the i6 register that was flushed to  * the kernel save area (pointed to by the previous frame's sp,  * which is the current frame's fp).  */
end_comment

begin_function
name|CORE_ADDR
name|sparc_frame_chain
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|retval
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|frame
operator|->
name|frame
operator|+
name|FRAME_SAVED_I0
operator|+
name|REGISTER_RAW_SIZE
argument_list|(
name|FP_REGNUM
argument_list|)
operator|*
operator|(
name|FP_REGNUM
operator|-
name|I0_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|retval
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|retval
argument_list|,
sizeof|sizeof
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the the first word after the kernel save area of the current  * frame.  This is where Sun cc puts a pointer to storage for a structure  * return value.  Return 0 on read errors.  */
end_comment

begin_function
name|CORE_ADDR
name|sparc_extract_struct_value_address
parameter_list|(
name|regs
parameter_list|)
name|char
modifier|*
name|regs
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|,
name|v
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|regs
index|[
name|REGISTER_BYTE
argument_list|(
name|SP_REGNUM
argument_list|)
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the pc saved in frame FRAME.    */
end_comment

begin_function
name|CORE_ADDR
name|frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
return|return
operator|(
name|PC_ADJUST
argument_list|(
name|read_memory_integer
argument_list|(
name|addr_of_pc
argument_list|(
name|frame
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|FRAME
name|setup_arbitrary_frame
parameter_list|(
name|fp
parameter_list|,
name|sp
parameter_list|)
name|FRAME_ADDR
name|fp
decl_stmt|,
name|sp
decl_stmt|;
block|{
name|FRAME
name|f
init|=
name|create_new_frame
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|f
operator|->
name|bottom
operator|=
name|sp
expr_stmt|;
name|f
operator|->
name|pc
operator|=
name|frame_saved_pc
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|restore_code
index|[]
init|=
block|{
literal|0x81e80000
block|,
comment|/* restore */
literal|0x91d02001
block|,
comment|/* t 1 */
literal|0x01000000
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|do_restore_insn
parameter_list|()
block|{
comment|/* From infrun.c */
specifier|extern
name|int
name|stop_after_trap
decl_stmt|;
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|sp
operator|-
sizeof|sizeof
argument_list|(
name|restore_code
argument_list|)
decl_stmt|;
name|write_memory
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|restore_code
argument_list|,
sizeof|sizeof
argument_list|(
name|restore_code
argument_list|)
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_after_trap
operator|=
literal|1
expr_stmt|;
name|proceed
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * True iff sparc insn INSN is a save instruction.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_INSN_P
parameter_list|(
name|i
parameter_list|)
value|((insn).f3b.op == 2&& (insn).f3b.op3 == 60)
end_define

begin_comment
comment|/*  * True iff sparc insn INSN is a store instruction of an input register  * into the arg overflow area, which starts at [fp + 64] and has a   * length of 24 bytes (enough for i0 through i5).  */
end_comment

begin_define
define|#
directive|define
name|ARGSTORE_INSN_P
parameter_list|(
name|insn
parameter_list|)
define|\
value|((insn).f3b.op == 3&& ((insn).f3b.op3& 0x3c) == 4&& \ 	 (insn).f3b.rs1 == FP_REGNUM&& (insn).f3b.i == 1&& \ 	 (insn).f3b.simm13>= 64&& (insn).f3b.simm13< 64 + 24)
end_define

begin_function
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|addr
parameter_list|,
name|frameless_p
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|frameless_p
decl_stmt|;
block|{
specifier|register
name|union
name|sparcinsn
name|insn
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
init|=
name|addr
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|3
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|insn
operator|.
name|code
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|SAVE_INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|frameless_p
condition|)
return|return
operator|(
name|pc
operator|)
return|;
name|insn
operator|.
name|code
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|ARGSTORE_INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
name|insn
operator|.
name|code
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pc
operator|)
return|;
block|}
comment|/* 	 * Couldn't find a save instruction. 	 */
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sparc_pop_frame
parameter_list|()
block|{
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|I7_REGNUM
argument_list|)
expr_stmt|;
name|do_restore_insn
argument_list|()
expr_stmt|;
comment|/* 	 * Return address in %i7 --  	 * adjust it, then restore PC and NPC from it. 	 */
name|pc
operator|=
name|PC_ADJUST
argument_list|(
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|pc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sun's cc leaves a hole after a call to function returning a structure  * (after the delay slot).  Given a function call at PC, return the  * address to which the called function will return.  */
end_comment

begin_function
name|CORE_ADDR
name|sparc_pc_adjust
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|u_long
name|op
decl_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
operator|+
literal|8
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|op
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|op
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
operator|~
literal|0x1ff
operator|)
operator|==
literal|0
condition|)
comment|/* 			 * The 20 high bits of this opcode are 0, which 			 * does not conform to a valid instruction.   			 * It must be the Sun structure length hack. 			 */
return|return
operator|(
name|pc
operator|+
literal|12
operator|)
return|;
block|}
return|return
operator|(
name|pc
operator|+
literal|8
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|dummy_code
index|[]
init|=
block|{
literal|0xd003a044
block|,
comment|/* ld	[%sp + 68], %o0 */
literal|0xd203a048
block|,
comment|/* ld	[%sp + 72], %o1 */
literal|0xd403a04c
block|,
comment|/* ld	[%sp + 76], %o2 */
literal|0xd603a050
block|,
comment|/* ld	[%sp + 80], %o3 */
literal|0xd803a054
block|,
comment|/* ld	[%sp + 84], %o4 */
define|#
directive|define
name|DUMMY_CALL_INDEX
value|5
literal|0x40000000
block|,
comment|/* call .		*/
literal|0xda03a058
block|,
comment|/* ld	[%sp + 88], %o5 */
define|#
directive|define
name|DUMMY_STRUCTLEN_INDEX
value|7
literal|0x01000000
block|,
comment|/* nop - extra insn for Sun cc */
literal|0x91d02001
block|,
comment|/* ta	1		*/
literal|0x01000000
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Leave room on the stack for the kernel save area and the pointer  * for structure return values.  */
end_comment

begin_define
define|#
directive|define
name|KSA_AND_STRUCT_ADJUST
value|68
end_define

begin_comment
comment|/*  * Build `dummy' call instructions on inferior's stack to cause  * it to call a subroutine.  *  * N.B. - code in wait_for_inferior requires that sp< pc< fp when  * we take the trap 2 above so it will recognize that we stopped  * at a `dummy' call.  So, after the call sp is *not* decremented  * to clean the arguments, code& other stuff we lay on the stack.  * Since the regs are restored to saved values at the breakpoint,  * sp will get reset correctly.  Also, this restore means we don't  * have to construct frame linkage info to save pc& fp.  The lack  * of frame linkage means we can't do a backtrace, etc., if the  * called function gets a fault or hits a breakpoint but code in  * run_stack_dummy makes this impossible anyway.  */
end_comment

begin_function
name|CORE_ADDR
name|setup_dummy
parameter_list|(
name|sp
parameter_list|,
name|funaddr
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|,
name|struct_return_bytes
parameter_list|,
name|gcc_p
parameter_list|)
name|CORE_ADDR
name|sp
decl_stmt|;
name|CORE_ADDR
name|funaddr
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
name|int
name|struct_return_bytes
decl_stmt|;
name|int
name|gcc_p
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|padding
decl_stmt|,
name|i
decl_stmt|;
name|CORE_ADDR
name|top
init|=
name|sp
decl_stmt|,
name|struct_addr
decl_stmt|,
name|pc
decl_stmt|;
name|pc
operator|=
name|sp
operator|-
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
expr_stmt|;
name|len
operator|=
name|value_arg_bytes
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|)
operator|+
name|KSA_AND_STRUCT_ADJUST
operator|+
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
operator|+
name|struct_return_bytes
expr_stmt|;
name|padding
operator|=
name|STACK_ALIGN
argument_list|(
name|len
argument_list|)
operator|-
name|len
expr_stmt|;
name|sp
operator|=
name|pc
operator|-
name|padding
operator|-
name|struct_return_bytes
expr_stmt|;
name|struct_addr
operator|=
name|sp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
comment|/* pushfn doesn't actually change SP_REGNUM */
name|sp
operator|=
name|value_arg_push
argument_list|(
name|sp
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sp
operator|-=
name|KSA_AND_STRUCT_ADJUST
expr_stmt|;
if|if
condition|(
name|struct_return_bytes
condition|)
block|{
name|write_memory
argument_list|(
name|sp
operator|+
name|KSA_AND_STRUCT_ADJUST
operator|-
literal|4
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|struct_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Appease Sun's twisted convention for struct returns. */
if|if
condition|(
operator|!
name|gcc_p
condition|)
name|dummy_code
index|[
name|DUMMY_STRUCTLEN_INDEX
index|]
operator|=
name|struct_return_bytes
operator|&
literal|0x1fff
expr_stmt|;
block|}
else|else
comment|/* nop */
name|dummy_code
index|[
name|DUMMY_STRUCTLEN_INDEX
index|]
operator|=
literal|0x01000000
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|dummy_code
index|[
name|DUMMY_CALL_INDEX
index|]
operator|=
literal|0x40000000
operator||
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|funaddr
operator|-
operator|(
name|pc
operator|+
literal|4
operator|*
name|DUMMY_CALL_INDEX
operator|)
argument_list|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|write_memory
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy_code
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy_code
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/*  * Only worry about KSA.  */
end_comment

begin_macro
name|frame_find_saved_regs
argument_list|(
argument|fi
argument_list|,
argument|srp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame_saved_regs
modifier|*
name|srp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|FRAME_ADDR
name|frame
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|srp
argument_list|,
sizeof|sizeof
expr|*
name|srp
argument_list|)
expr_stmt|;
name|frame
operator|=
name|fi
operator|->
name|bottom
expr_stmt|;
comment|/* XXX There's no excuse for this. */
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* ins and locals */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|frame
operator|+
operator|(
name|i
operator|-
literal|16
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
name|frame
operator|=
name|fi
operator|->
name|next
operator|->
name|bottom
expr_stmt|;
comment|/* outs */
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|srp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|frame
operator|+
name|i
operator|*
literal|4
expr_stmt|;
block|}
name|srp
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
name|addr_of_pc
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|fix_leaf_frame
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|arg1
init|=
literal|0
decl_stmt|,
name|level
decl_stmt|;
name|FRAME
name|fid
decl_stmt|,
name|nfid
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|,
modifier|*
name|nfi
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No inferior or core file."
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
while|while
condition|(
operator|*
name|arg
operator|&&
operator|*
name|arg
operator|==
literal|' '
condition|)
operator|++
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|arg
condition|)
name|arg1
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|level
operator|=
name|arg1
expr_stmt|;
name|fid
operator|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Can't find frame %d"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|fid
argument_list|)
expr_stmt|;
name|nfid
operator|=
name|create_new_frame
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
name|nfi
operator|=
name|get_frame_info
argument_list|(
name|nfid
argument_list|)
expr_stmt|;
operator|*
name|nfi
operator|=
operator|*
name|fi
expr_stmt|;
name|nfi
operator|->
name|pc
operator|=
name|read_register
argument_list|(
name|RP_REGNUM
argument_list|)
expr_stmt|;
name|nfi
operator|->
name|next
operator|=
name|fi
expr_stmt|;
name|fi
operator|->
name|prev
operator|=
name|nfi
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_sparctcmn
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"fix-leaf"
argument_list|,
name|class_stack
argument_list|,
name|fix_leaf_frame
argument_list|,
literal|"fix up the call stack to account for a leaf routine\n\ A new frame is inserted for the routine that called the leaf."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

