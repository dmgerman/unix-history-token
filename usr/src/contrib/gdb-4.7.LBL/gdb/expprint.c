begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print in infix form a struct expression.    Copyright (C) 1986, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|print_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
name|FILE
operator|*
operator|,
expr|enum
name|precedence
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_simple_m2_func
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_expression
parameter_list|(
name|exp
parameter_list|,
name|stream
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|stream
argument_list|,
name|PREC_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the subexpression of EXP that starts in position POS, on STREAM.    PREC is the precedence of the surrounding operator;    if the precedence of the main operator of this subexpression is less,    parentheses are needed here.  */
end_comment

begin_function
specifier|static
name|void
name|print_subexp
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|,
name|stream
parameter_list|,
name|prec
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|enum
name|precedence
name|prec
decl_stmt|;
block|{
specifier|register
name|unsigned
name|tem
decl_stmt|;
specifier|register
specifier|const
name|struct
name|op_print
modifier|*
name|op_print_tab
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
name|unsigned
name|nargs
decl_stmt|;
specifier|register
name|char
modifier|*
name|op_str
decl_stmt|;
name|int
name|assign_modify
init|=
literal|0
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
name|enum
name|precedence
name|myprec
decl_stmt|;
comment|/* Set to 1 for a right-associative operator.  */
name|int
name|assoc
decl_stmt|;
name|value
name|val
decl_stmt|;
name|op_print_tab
operator|=
name|exp
operator|->
name|language_defn
operator|->
name|la_op_print_tab
expr_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|opcode
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* Common ops */
case|case
name|OP_SCOPE
case|:
name|myprec
operator|=
name|PREC_PREFIX
expr_stmt|;
name|assoc
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
expr|enum
name|precedence
operator|)
operator|(
operator|(
name|int
operator|)
name|myprec
operator|+
name|assoc
operator|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" :: "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|strlen
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|1
operator|+
operator|(
name|nargs
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_LONG
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|value_print
argument_list|(
name|value_from_longest
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_DOUBLE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|value_print
argument_list|(
name|value_from_double
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|doubleconst
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_VAR_VALUE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|symbol
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_LAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_REGISTER
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%s"
argument_list|,
name|reg_names
index|[
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_INTERNALVAR
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%s"
argument_list|,
name|internalvar_name
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|internalvar
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_FUNCALL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_STRING
case|:
name|nargs
operator|=
name|strlen
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
operator|+
operator|(
name|nargs
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
name|printchar
argument_list|(
operator|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
operator|)
index|[
name|tem
index|]
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|TERNOP_COND
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_COMMA
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Print the subexpressions, forcing parentheses 	 around any binary operations within them. 	 This is more parentheses than are strictly necessary, 	 but it looks clearer.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ? "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" : "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_COMMA
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRUCTOP_STRUCT
case|:
name|tem
operator|=
name|strlen
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
operator|+
operator|(
name|tem
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
comment|/* Will not occur for Modula-2 */
case|case
name|STRUCTOP_PTR
case|:
name|tem
operator|=
name|strlen
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
operator|+
operator|(
name|tem
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"->"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_SUBSCRIPT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"["
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"]"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_POSTINCREMENT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"++"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_POSTDECREMENT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"--"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_CAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|") "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_FUNC
operator|&&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|opcode
operator|==
name|OP_LONG
condition|)
block|{
comment|/* We have a minimal symbol fn, probably.  It's encoded 	   as a UNOP_MEMVAL (function-type) of an OP_LONG (int, address). 	   Swallow the OP_LONG (including both its opcodes); ignore 	   its type; print the value in the type of the MEMVAL.  */
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
name|val
operator|=
name|value_at_lazy
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|5
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs_filtered
argument_list|(
literal|"{"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"} "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|opcode
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|myprec
operator|=
name|PREC_ASSIGN
expr_stmt|;
name|assoc
operator|=
literal|1
expr_stmt|;
name|assign_modify
operator|=
literal|1
expr_stmt|;
name|op_str
operator|=
literal|"???"
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|opcode
condition|)
block|{
name|op_str
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
expr_stmt|;
break|break;
block|}
break|break;
comment|/* C++ ops */
case|case
name|OP_THIS
case|:
operator|++
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"this"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
comment|/* Modula-2 ops */
case|case
name|BINOP_MULTI_SUBSCRIPT
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" ["
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_VAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"VAL("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_CAP
case|:
name|print_simple_m2_func
argument_list|(
literal|"CAP"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_CHR
case|:
name|print_simple_m2_func
argument_list|(
literal|"CHR"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_ORD
case|:
name|print_simple_m2_func
argument_list|(
literal|"ORD"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_ABS
case|:
name|print_simple_m2_func
argument_list|(
literal|"ABS"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_FLOAT
case|:
name|print_simple_m2_func
argument_list|(
literal|"FLOAT"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_HIGH
case|:
name|print_simple_m2_func
argument_list|(
literal|"HIGH"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_MAX
case|:
name|print_simple_m2_func
argument_list|(
literal|"MAX"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_MIN
case|:
name|print_simple_m2_func
argument_list|(
literal|"MIN"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_ODD
case|:
name|print_simple_m2_func
argument_list|(
literal|"ODD"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_TRUNC
case|:
name|print_simple_m2_func
argument_list|(
literal|"TRUNC"
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_INCL
case|:
case|case
name|BINOP_EXCL
case|:
name|error
argument_list|(
literal|"print_subexp:  Not implemented."
argument_list|)
expr_stmt|;
comment|/* Default ops */
default|default:
name|op_str
operator|=
literal|"???"
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|opcode
condition|)
block|{
name|op_str
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
expr_stmt|;
name|myprec
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|precedence
expr_stmt|;
name|assoc
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|right_assoc
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|myprec
operator|<
operator|(
name|int
operator|)
name|prec
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|opcode
operator|>
operator|(
name|int
operator|)
name|BINOP_END
condition|)
block|{
comment|/* Unary prefix operator.  */
name|fputs_filtered
argument_list|(
name|op_str
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Binary operator.  */
comment|/* Print left operand. 	 If operator is right-associative, 	 increment precedence for this operand.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
expr|enum
name|precedence
operator|)
operator|(
operator|(
name|int
operator|)
name|myprec
operator|+
name|assoc
operator|)
argument_list|)
expr_stmt|;
comment|/* Print the operator itself.  */
if|if
condition|(
name|assign_modify
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s= "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op_str
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
comment|/* Print right operand. 	 If operator is left-associative, 	 increment precedence for this operand.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
expr|enum
name|precedence
operator|)
operator|(
operator|(
name|int
operator|)
name|myprec
operator|+
operator|!
name|assoc
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|myprec
operator|<
operator|(
name|int
operator|)
name|prec
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out something of the form<s>(<arg>).    This is used to print out some builtin Modula-2    functions.    FIXME:  There is probably some way to get the precedence    rules to do this (print a unary operand with parens around it).  */
end_comment

begin_function
specifier|static
name|void
name|print_simple_m2_func
parameter_list|(
name|s
parameter_list|,
name|exp
parameter_list|,
name|pos
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s("
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the operator corresponding to opcode OP as    a string.   NULL indicates that the opcode was not found in the    current language table.  */
end_comment

begin_function
name|char
modifier|*
name|op_string
parameter_list|(
name|op
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
block|{
name|int
name|tem
decl_stmt|;
specifier|register
specifier|const
name|struct
name|op_print
modifier|*
name|op_print_tab
decl_stmt|;
name|op_print_tab
operator|=
name|current_language
operator|->
name|la_op_print_tab
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|op
condition|)
return|return
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
return|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

