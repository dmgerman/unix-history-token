begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-machine dependent code for the AMD 29000    Copyright 1990, 1991 Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by Jim Kingdon.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/*#include<sys/param.h> */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME, kludge... */
end_comment

begin_comment
comment|/* The user-settable top of the register stack in virtual memory.  We    won't attempt to access any stored registers above this address, if set    nonzero.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|rstack_high_address
init|=
name|UINT_MAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to hold cached info about function prologues.  */
end_comment

begin_struct
struct|struct
name|prologue_info
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* First addr after fn prologue */
name|unsigned
name|rsize
decl_stmt|,
name|msize
decl_stmt|;
comment|/* register stack frame size, mem stack ditto */
name|unsigned
name|mfp_used
range|:
literal|1
decl_stmt|;
comment|/* memory frame pointer used */
name|unsigned
name|rsize_valid
range|:
literal|1
decl_stmt|;
comment|/* Validity bits for the above */
name|unsigned
name|msize_valid
range|:
literal|1
decl_stmt|;
name|unsigned
name|mfp_valid
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Examine the prologue of a function which starts at PC.  Return    the first addess past the prologue.  If MSIZE is non-NULL, then    set *MSIZE to the memory stack frame size.  If RSIZE is non-NULL,    then set *RSIZE to the register stack frame size (not including    incoming arguments and the return address& frame pointer stored    with them).  If no prologue is found, *RSIZE is set to zero.    If no prologue is found, or a prologue which doesn't involve    allocating a memory stack frame, then set *MSIZE to zero.     Note that both msize and rsize are in bytes.  This is not consistent    with the _User's Manual_ with respect to rsize, but it is much more    convenient.     If MFP_USED is non-NULL, *MFP_USED is set to nonzero if a memory    frame pointer is being used.  */
end_comment

begin_function
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|pc
parameter_list|,
name|rsize
parameter_list|,
name|msize
parameter_list|,
name|mfp_used
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|unsigned
modifier|*
name|msize
decl_stmt|;
name|unsigned
modifier|*
name|rsize
decl_stmt|;
name|int
modifier|*
name|mfp_used
decl_stmt|;
block|{
name|long
name|insn
decl_stmt|;
name|CORE_ADDR
name|p
init|=
name|pc
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
name|struct
name|prologue_info
modifier|*
name|mi
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|mi
operator|=
operator|(
expr|struct
name|prologue_info
operator|*
operator|)
name|msymbol
operator|->
name|info
expr_stmt|;
if|if
condition|(
name|mi
operator|!=
literal|0
condition|)
block|{
name|int
name|valid
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rsize
operator|=
name|mi
operator|->
name|rsize
expr_stmt|;
name|valid
operator|&=
name|mi
operator|->
name|rsize_valid
expr_stmt|;
block|}
if|if
condition|(
name|msize
operator|!=
name|NULL
condition|)
block|{
operator|*
name|msize
operator|=
name|mi
operator|->
name|msize
expr_stmt|;
name|valid
operator|&=
name|mi
operator|->
name|msize_valid
expr_stmt|;
block|}
if|if
condition|(
name|mfp_used
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mfp_used
operator|=
name|mi
operator|->
name|mfp_used
expr_stmt|;
name|valid
operator|&=
name|mi
operator|->
name|mfp_valid
expr_stmt|;
block|}
if|if
condition|(
name|valid
condition|)
return|return
name|mi
operator|->
name|pc
return|;
block|}
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msize
operator|!=
name|NULL
condition|)
operator|*
name|msize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mfp_used
operator|!=
name|NULL
condition|)
operator|*
name|mfp_used
operator|=
literal|0
expr_stmt|;
comment|/* Prologue must start with subtracting a constant from gr1.      Normally this is sub gr1,gr1,<rsize * 4>.  */
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffffff00
operator|)
operator|!=
literal|0x25010100
condition|)
block|{
comment|/* If the frame is large, instead of a single instruction it 	 might be a pair of instructions: 	 const<reg>,<rsize * 4> 	 sub gr1,gr1,<reg> 	 */
name|int
name|reg
decl_stmt|;
comment|/* Possible value for rsize.  */
name|unsigned
name|int
name|rsize0
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0x03000000
condition|)
block|{
name|p
operator|=
name|pc
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|reg
operator|=
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|rsize0
operator|=
operator|(
operator|(
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffffff00
operator|)
operator|!=
literal|0x24010100
operator|||
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|!=
name|reg
condition|)
block|{
name|p
operator|=
name|pc
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|rsize0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* Next instruction must be asgeu V_SPILL,gr1,rab.      * We don't check the vector number to allow for kernel debugging.  The     * kernel will use a different trap number.     */
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00ffff
operator|)
operator|!=
operator|(
literal|0x5e000100
operator||
name|RAB_HW_REGNUM
operator|)
condition|)
block|{
name|p
operator|=
name|pc
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* Next instruction usually sets the frame pointer (lr1) by adding<size * 4> from gr1.  However, this can (and high C does) be      deferred until anytime before the first function call.  So it is      OK if we don't see anything which sets lr1.        To allow for alternate register sets (gcc -mkernel-registers)  the msp      register number is a compile time constant. */
comment|/* Normally this is just add lr1,gr1,<size * 4>.  */
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffffff00
operator|)
operator|==
literal|0x15810100
condition|)
name|p
operator|+=
literal|4
expr_stmt|;
else|else
block|{
comment|/* However, for large frames it can be 	 const<reg>,<size *4> 	 add lr1,gr1,<reg> 	 */
name|int
name|reg
decl_stmt|;
name|CORE_ADDR
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff000000
operator|)
operator|==
literal|0x03000000
condition|)
block|{
name|reg
operator|=
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|q
operator|=
name|p
operator|+
literal|4
expr_stmt|;
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|q
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffffff00
operator|)
operator|==
literal|0x14810100
operator|&&
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|==
name|reg
condition|)
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
comment|/* Next comes "add lr{<rsize-1>},msp,0", but only if a memory      frame pointer is in use.  We just check for add lr<anything>,msp,0;      we don't check this rsize against the first instruction, and      we don't check that the trace-back tag indicates a memory frame pointer      is in use.        To allow for alternate register sets (gcc -mkernel-registers)  the msp      register number is a compile time constant.       The recommended instruction is actually "sll lr<whatever>,msp,0".       We check for that, too.  Originally Jim Kingdon's code seemed      to be looking for a "sub" instruction here, but the mask was set      up to lose all the time. */
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|insn
operator|&
literal|0xff80ffff
operator|)
operator|==
operator|(
literal|0x15800000
operator||
operator|(
name|MSP_HW_REGNUM
operator|<<
literal|8
operator|)
operator|)
operator|)
comment|/* add */
operator|||
operator|(
operator|(
name|insn
operator|&
literal|0xff80ffff
operator|)
operator|==
operator|(
literal|0x81800000
operator||
operator|(
name|MSP_HW_REGNUM
operator|<<
literal|8
operator|)
operator|)
operator|)
condition|)
comment|/* sll */
block|{
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|mfp_used
operator|!=
name|NULL
condition|)
operator|*
name|mfp_used
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Next comes a subtraction from msp to allocate a memory frame,      but only if a memory frame is      being used.  We don't check msize against the trace-back tag.       To allow for alternate register sets (gcc -mkernel-registers) the msp      register number is a compile time constant.       Normally this is just      sub msp,msp,<msize>      */
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffffff00
operator|)
operator|==
operator|(
literal|0x25000000
operator||
operator|(
name|MSP_HW_REGNUM
operator|<<
literal|16
operator|)
operator||
operator|(
name|MSP_HW_REGNUM
operator|<<
literal|8
operator|)
operator|)
condition|)
block|{
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|msize
operator|!=
name|NULL
condition|)
operator|*
name|msize
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* For large frames, instead of a single instruction it might 	 be  	 const<reg>,<msize> 	 consth<reg>,<msize>     ; optional 	 sub msp,msp,<reg> 	 */
name|int
name|reg
decl_stmt|;
name|unsigned
name|msize0
decl_stmt|;
name|CORE_ADDR
name|q
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff000000
operator|)
operator|==
literal|0x03000000
condition|)
block|{
name|reg
operator|=
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|msize0
operator|=
operator|(
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|insn
operator|&
literal|0xff
operator|)
expr_stmt|;
name|q
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|q
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Check for consth.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff000000
operator|)
operator|==
literal|0x02000000
operator|&&
operator|(
name|insn
operator|&
literal|0x0000ff00
operator|)
operator|==
name|reg
condition|)
block|{
name|msize0
operator||=
operator|(
name|insn
operator|<<
literal|8
operator|)
operator|&
literal|0xff000000
expr_stmt|;
name|msize0
operator||=
operator|(
name|insn
operator|<<
literal|16
operator|)
operator|&
literal|0x00ff0000
expr_stmt|;
name|q
operator|+=
literal|4
expr_stmt|;
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|q
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Check for sub msp,msp,<reg>.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffffff00
operator|)
operator|==
operator|(
literal|0x24000000
operator||
operator|(
name|MSP_HW_REGNUM
operator|<<
literal|16
operator|)
operator||
operator|(
name|MSP_HW_REGNUM
operator|<<
literal|8
operator|)
operator|)
operator|&&
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|==
name|reg
condition|)
block|{
name|p
operator|=
name|q
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|msize
operator|!=
name|NULL
condition|)
operator|*
name|msize
operator|=
name|msize0
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mi
operator|==
literal|0
condition|)
block|{
comment|/* Add a new cache entry.  */
name|mi
operator|=
operator|(
expr|struct
name|prologue_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|prologue_info
argument_list|)
argument_list|)
expr_stmt|;
name|msymbol
operator|->
name|info
operator|=
operator|(
name|char
operator|*
operator|)
name|mi
expr_stmt|;
name|mi
operator|->
name|rsize_valid
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|msize_valid
operator|=
literal|0
expr_stmt|;
name|mi
operator|->
name|mfp_valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* else, cache entry exists, but info is incomplete.  */
name|mi
operator|->
name|pc
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
block|{
name|mi
operator|->
name|rsize
operator|=
operator|*
name|rsize
expr_stmt|;
name|mi
operator|->
name|rsize_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|msize
operator|!=
name|NULL
condition|)
block|{
name|mi
operator|->
name|msize
operator|=
operator|*
name|msize
expr_stmt|;
name|mi
operator|->
name|msize_valid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mfp_used
operator|!=
name|NULL
condition|)
block|{
name|mi
operator|->
name|mfp_used
operator|=
operator|*
name|mfp_used
expr_stmt|;
name|mi
operator|->
name|mfp_valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Advance PC across any function entry prologue instructions    to reach some "real" code.  */
end_comment

begin_function
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
name|examine_prologue
argument_list|(
name|pc
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Examine the one or two word tag at the beginning of a function.  * The tag word is expect to be at 'p', if it is not there, we fail  * by returning 0.  The documentation for the tag word was taken from  * page 7-15 of the 29050 User's Manual.  We are assuming that the  * m bit is in bit 22 of the tag word, which seems to be the agreed upon  * convention today (1/15/92).  * msize is return in bytes.  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0/1 - failure/success of finding the tag word  */
name|examine_tag
parameter_list|(
name|p
parameter_list|,
name|is_trans
parameter_list|,
name|argcount
parameter_list|,
name|msize
parameter_list|,
name|mfp_used
parameter_list|)
name|CORE_ADDR
name|p
decl_stmt|;
name|int
modifier|*
name|is_trans
decl_stmt|;
name|int
modifier|*
name|argcount
decl_stmt|;
name|unsigned
modifier|*
name|msize
decl_stmt|;
name|int
modifier|*
name|mfp_used
decl_stmt|;
block|{
name|unsigned
name|int
name|tag1
decl_stmt|,
name|tag2
decl_stmt|;
name|tag1
operator|=
name|read_memory_integer
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tag1
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0
condition|)
comment|/* Not a tag word */
return|return
literal|0
return|;
if|if
condition|(
name|tag1
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
comment|/* A two word tag */
block|{
name|tag2
operator|=
name|read_memory_integer
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|msize
condition|)
operator|*
name|msize
operator|=
name|tag2
expr_stmt|;
block|}
else|else
comment|/* A one word tag */
block|{
if|if
condition|(
name|msize
condition|)
operator|*
name|msize
operator|=
name|tag1
operator|&
literal|0x7ff
expr_stmt|;
block|}
if|if
condition|(
name|is_trans
condition|)
operator|*
name|is_trans
operator|=
operator|(
operator|(
name|tag1
operator|&
operator|(
literal|1
operator|<<
literal|21
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|argcount
condition|)
operator|*
name|argcount
operator|=
operator|(
name|tag1
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|mfp_used
condition|)
operator|*
name|mfp_used
operator|=
operator|(
operator|(
name|tag1
operator|&
operator|(
literal|1
operator|<<
literal|22
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize the frame.  In addition to setting "extra" frame info,    we also set ->frame because we use it in a nonstandard way, and ->pc    because we need to know it to get the other stuff.  See the diagram    of stacks and the frame cache in tm-29k.h for more detail.  */
end_comment

begin_function
specifier|static
name|void
name|init_frame_info
parameter_list|(
name|innermost_frame
parameter_list|,
name|fci
parameter_list|)
name|int
name|innermost_frame
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fci
decl_stmt|;
block|{
name|CORE_ADDR
name|p
decl_stmt|;
name|long
name|insn
decl_stmt|;
name|unsigned
name|rsize
decl_stmt|;
name|unsigned
name|msize
decl_stmt|;
name|int
name|mfp_used
decl_stmt|,
name|trans
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|p
operator|=
name|fci
operator|->
name|pc
expr_stmt|;
if|if
condition|(
name|innermost_frame
condition|)
name|fci
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|GR1_REGNUM
argument_list|)
expr_stmt|;
else|else
name|fci
operator|->
name|frame
operator|=
name|fci
operator|->
name|next_frame
operator|+
name|fci
operator|->
name|next
operator|->
name|rsize
expr_stmt|;
if|#
directive|if
name|CALL_DUMMY_LOCATION
operator|==
name|ON_STACK
name|This
name|wont
name|work
decl_stmt|;
else|#
directive|else
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|fci
operator|->
name|rsize
operator|=
name|DUMMY_FRAME_RSIZE
expr_stmt|;
comment|/* This doesn't matter since we never try to get locals or args 	 from a dummy frame.  */
name|fci
operator|->
name|msize
operator|=
literal|0
expr_stmt|;
comment|/* Dummy frames always use a memory frame pointer.  */
name|fci
operator|->
name|saved_msp
operator|=
name|read_register_stack_integer
argument_list|(
name|fci
operator|->
name|frame
operator|+
name|DUMMY_FRAME_RSIZE
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fci
operator|->
name|flags
operator||=
operator|(
name|TRANSPARENT
operator||
name|MFP_USED
operator|)
expr_stmt|;
return|return;
block|}
name|func
operator|=
name|find_pc_function
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
condition|)
name|p
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Search backward to find the trace-back tag.  However, 	 do not trace back beyond the start of the text segment 	 (just as a sanity check to avoid going into never-never land).  */
while|while
condition|(
name|p
operator|>=
name|text_start
operator|&&
operator|(
operator|(
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
operator|)
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0
condition|)
name|p
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|text_start
condition|)
block|{
comment|/* Couldn't find the trace-back tag. 	     Something strange is going on.  */
name|fci
operator|->
name|saved_msp
operator|=
literal|0
expr_stmt|;
name|fci
operator|->
name|rsize
operator|=
literal|0
expr_stmt|;
name|fci
operator|->
name|msize
operator|=
literal|0
expr_stmt|;
name|fci
operator|->
name|flags
operator|=
name|TRANSPARENT
expr_stmt|;
return|return;
block|}
else|else
comment|/* Advance to the first word of the function, i.e. the word 	   after the trace-back tag.  */
name|p
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* We've found the start of the function.      * Try looking for a tag word that indicates whether there is a    * memory frame pointer and what the memory stack allocation is.    * If one doesn't exist, try using a more exhaustive search of    * the prologue.  For now we don't care about the argcount or    * whether or not the routine is transparent.    */
if|if
condition|(
name|examine_tag
argument_list|(
name|p
operator|-
literal|4
argument_list|,
operator|&
name|trans
argument_list|,
name|NULL
argument_list|,
operator|&
name|msize
argument_list|,
operator|&
name|mfp_used
argument_list|)
condition|)
comment|/* Found a good tag */
name|examine_prologue
argument_list|(
name|p
argument_list|,
operator|&
name|rsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* No tag try prologue */
name|examine_prologue
argument_list|(
name|p
argument_list|,
operator|&
name|rsize
argument_list|,
operator|&
name|msize
argument_list|,
operator|&
name|mfp_used
argument_list|)
expr_stmt|;
name|fci
operator|->
name|rsize
operator|=
name|rsize
expr_stmt|;
name|fci
operator|->
name|msize
operator|=
name|msize
expr_stmt|;
name|fci
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mfp_used
condition|)
name|fci
operator|->
name|flags
operator||=
name|MFP_USED
expr_stmt|;
if|if
condition|(
name|trans
condition|)
name|fci
operator|->
name|flags
operator||=
name|TRANSPARENT
expr_stmt|;
if|if
condition|(
name|innermost_frame
condition|)
block|{
name|fci
operator|->
name|saved_msp
operator|=
name|read_register
argument_list|(
name|MSP_REGNUM
argument_list|)
operator|+
name|msize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mfp_used
condition|)
name|fci
operator|->
name|saved_msp
operator|=
name|read_register_stack_integer
argument_list|(
name|fci
operator|->
name|frame
operator|+
name|rsize
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|fci
operator|->
name|saved_msp
operator|=
name|fci
operator|->
name|next
operator|->
name|saved_msp
operator|+
name|msize
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init_extra_frame_info
parameter_list|(
name|fci
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fci
decl_stmt|;
block|{
if|if
condition|(
name|fci
operator|->
name|next
operator|==
literal|0
condition|)
comment|/* Assume innermost frame.  May produce strange results for "info frame"        but there isn't any way to tell the difference.  */
name|init_frame_info
argument_list|(
literal|1
argument_list|,
name|fci
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We're in get_prev_frame_info.          Take care of everything in init_frame_pc.  */
empty_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init_frame_pc
parameter_list|(
name|fromleaf
parameter_list|,
name|fci
parameter_list|)
name|int
name|fromleaf
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fci
decl_stmt|;
block|{
name|fci
operator|->
name|pc
operator|=
operator|(
name|fromleaf
condition|?
name|SAVED_PC_AFTER_CALL
argument_list|(
name|fci
operator|->
name|next
argument_list|)
else|:
name|fci
operator|->
name|next
condition|?
name|FRAME_SAVED_PC
argument_list|(
name|fci
operator|->
name|next
argument_list|)
else|:
name|read_pc
argument_list|()
operator|)
expr_stmt|;
name|init_frame_info
argument_list|(
name|fromleaf
argument_list|,
name|fci
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Local variables (i.e. LOC_LOCAL) are on the memory stack, with their    offsets being relative to the memory stack pointer (high C) or    saved_msp (gcc).  */
end_comment

begin_function
name|CORE_ADDR
name|frame_locals_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|if
condition|(
name|fi
operator|->
name|flags
operator|&
name|MFP_USED
condition|)
return|return
name|fi
operator|->
name|saved_msp
return|;
else|else
return|return
name|fi
operator|->
name|saved_msp
operator|-
name|fi
operator|->
name|msize
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for reading the register stack.  The caller gets to treat    the register stack as a uniform stack in memory, from address $gr1    straight through $rfb and beyond.  */
end_comment

begin_comment
comment|/* Analogous to read_memory except the length is understood to be 4.    Also, myaddr can be NULL (meaning don't bother to read), and    if actual_mem_addr is non-NULL, store there the address that it    was fetched from (or if from a register the offset within    registers).  Set *LVAL to lval_memory or lval_register, depending    on where it came from.  */
end_comment

begin_function
name|void
name|read_register_stack
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|actual_mem_addr
parameter_list|,
name|lval
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|CORE_ADDR
modifier|*
name|actual_mem_addr
decl_stmt|;
name|enum
name|lval_type
modifier|*
name|lval
decl_stmt|;
block|{
name|long
name|rfb
init|=
name|read_register
argument_list|(
name|RFB_REGNUM
argument_list|)
decl_stmt|;
name|long
name|rsp
init|=
name|read_register
argument_list|(
name|RSP_REGNUM
argument_list|)
decl_stmt|;
comment|/* If we don't do this 'info register' stops in the middle. */
if|if
condition|(
name|memaddr
operator|>=
name|rstack_high_address
condition|)
block|{
name|int
name|val
init|=
operator|-
literal|1
decl_stmt|;
comment|/* a bogus value */
comment|/* It's in a local register, but off the end of the stack.  */
name|int
name|regnum
init|=
operator|(
name|memaddr
operator|-
name|rsp
operator|)
operator|/
literal|4
operator|+
name|LR0_REGNUM
decl_stmt|;
if|if
condition|(
name|myaddr
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|myaddr
operator|=
name|val
expr_stmt|;
comment|/* Provide bogusness */
name|supply_register
argument_list|(
name|regnum
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* More bogusness */
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
if|if
condition|(
name|actual_mem_addr
operator|!=
name|NULL
condition|)
operator|*
name|actual_mem_addr
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memaddr
operator|<
name|rfb
condition|)
block|{
comment|/* It's in a register.  */
name|int
name|regnum
init|=
operator|(
name|memaddr
operator|-
name|rsp
operator|)
operator|/
literal|4
operator|+
name|LR0_REGNUM
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
name|LR0_REGNUM
operator|||
name|regnum
operator|>
name|LR0_REGNUM
operator|+
literal|127
condition|)
name|error
argument_list|(
literal|"Attempt to read register stack out of range."
argument_list|)
expr_stmt|;
if|if
condition|(
name|myaddr
operator|!=
name|NULL
condition|)
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|myaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
if|if
condition|(
name|actual_mem_addr
operator|!=
name|NULL
condition|)
operator|*
name|actual_mem_addr
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's in the memory portion of the register stack.  */
if|if
condition|(
name|myaddr
operator|!=
name|NULL
condition|)
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|actual_mem_addr
operator|!=
name|NULL
condition|)
operator|*
name|actual_mem_addr
operator|=
name|memaddr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Analogous to read_memory_integer    except the length is understood to be 4.  */
end_comment

begin_function
name|long
name|read_register_stack_integer
parameter_list|(
name|memaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|long
name|buf
decl_stmt|;
name|read_register_stack
argument_list|(
name|memaddr
argument_list|,
operator|&
name|buf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Copy 4 bytes from GDB memory at MYADDR into inferior memory    at MEMADDR and put the actual address written into in    *ACTUAL_MEM_ADDR.  */
end_comment

begin_function
specifier|static
name|void
name|write_register_stack
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|actual_mem_addr
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|CORE_ADDR
modifier|*
name|actual_mem_addr
decl_stmt|;
block|{
name|long
name|rfb
init|=
name|read_register
argument_list|(
name|RFB_REGNUM
argument_list|)
decl_stmt|;
name|long
name|rsp
init|=
name|read_register
argument_list|(
name|RSP_REGNUM
argument_list|)
decl_stmt|;
comment|/* If we don't do this 'info register' stops in the middle. */
if|if
condition|(
name|memaddr
operator|>=
name|rstack_high_address
condition|)
block|{
comment|/* It's in a register, but off the end of the stack.  */
if|if
condition|(
name|actual_mem_addr
operator|!=
name|NULL
condition|)
operator|*
name|actual_mem_addr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memaddr
operator|<
name|rfb
condition|)
block|{
comment|/* It's in a register.  */
name|int
name|regnum
init|=
operator|(
name|memaddr
operator|-
name|rsp
operator|)
operator|/
literal|4
operator|+
name|LR0_REGNUM
decl_stmt|;
if|if
condition|(
name|regnum
operator|<
name|LR0_REGNUM
operator|||
name|regnum
operator|>
name|LR0_REGNUM
operator|+
literal|127
condition|)
name|error
argument_list|(
literal|"Attempt to read register stack out of range."
argument_list|)
expr_stmt|;
if|if
condition|(
name|myaddr
operator|!=
name|NULL
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|myaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_mem_addr
operator|!=
name|NULL
condition|)
operator|*
name|actual_mem_addr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* It's in the memory portion of the register stack.  */
if|if
condition|(
name|myaddr
operator|!=
name|NULL
condition|)
name|write_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_mem_addr
operator|!=
name|NULL
condition|)
operator|*
name|actual_mem_addr
operator|=
name|memaddr
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find register number REGNUM relative to FRAME and put its    (raw) contents in *RAW_BUFFER.  Set *OPTIMIZED if the variable    was optimized out (and thus can't be fetched).  If the variable    was fetched from memory, set *ADDRP to where it was fetched from,    otherwise it was fetched from a register.     The argument RAW_BUFFER must point to aligned memory.  */
end_comment

begin_function
name|void
name|get_saved_register
parameter_list|(
name|raw_buffer
parameter_list|,
name|optimized
parameter_list|,
name|addrp
parameter_list|,
name|frame
parameter_list|,
name|regnum
parameter_list|,
name|lvalp
parameter_list|)
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|int
modifier|*
name|optimized
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|enum
name|lval_type
modifier|*
name|lvalp
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
return|return;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/* Once something has a register number, it doesn't get optimized out.  */
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|RSP_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|raw_buffer
operator|=
name|fi
operator|->
name|frame
expr_stmt|;
if|if
condition|(
name|lvalp
operator|!=
name|NULL
condition|)
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|PC_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|raw_buffer
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
comment|/* Not sure we have to do this.  */
if|if
condition|(
name|lvalp
operator|!=
name|NULL
condition|)
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|==
name|MSP_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fi
operator|->
name|next
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|raw_buffer
operator|=
name|fi
operator|->
name|next
operator|->
name|saved_msp
expr_stmt|;
else|else
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|raw_buffer
operator|=
name|read_register
argument_list|(
name|MSP_REGNUM
argument_list|)
expr_stmt|;
block|}
comment|/* The value may have been computed, not fetched.  */
if|if
condition|(
name|lvalp
operator|!=
name|NULL
condition|)
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|<
name|LR0_REGNUM
operator|||
name|regnum
operator|>=
name|LR0_REGNUM
operator|+
literal|128
condition|)
block|{
comment|/* These registers are not saved over procedure calls, 	 so just print out the current values.  */
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|raw_buffer
operator|=
name|read_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvalp
operator|!=
name|NULL
condition|)
operator|*
name|lvalp
operator|=
name|lval_register
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|fi
operator|->
name|frame
operator|+
operator|(
name|regnum
operator|-
name|LR0_REGNUM
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|read_register_stack
argument_list|(
name|addr
argument_list|,
name|raw_buffer
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvalp
operator|!=
name|NULL
condition|)
operator|*
name|lvalp
operator|=
name|lval
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Discard from the stack the innermost frame,    restoring all saved registers.  */
end_comment

begin_function
name|void
name|pop_frame
parameter_list|()
block|{
name|FRAME
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
init|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|rfb
init|=
name|read_register
argument_list|(
name|RFB_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|gr1
init|=
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|rsize
decl_stmt|;
name|CORE_ADDR
name|lr1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If popping a dummy frame, need to restore registers.  */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
name|FRAME_FP
argument_list|(
name|fi
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|lrnum
init|=
name|LR0_REGNUM
operator|+
name|DUMMY_ARG
operator|/
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DUMMY_SAVE_SR128
condition|;
operator|++
name|i
control|)
name|write_register
argument_list|(
name|SR_REGNUM
argument_list|(
name|i
operator|+
literal|128
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|lrnum
operator|++
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DUMMY_SAVE_SR160
condition|;
operator|++
name|i
control|)
name|write_register
argument_list|(
name|SR_REGNUM
argument_list|(
name|i
operator|+
literal|160
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|lrnum
operator|++
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DUMMY_SAVE_GREGS
condition|;
operator|++
name|i
control|)
name|write_register
argument_list|(
name|RETURN_REGNUM
operator|+
name|i
argument_list|,
name|read_register
argument_list|(
name|lrnum
operator|++
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the PCs.  */
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_register
argument_list|(
name|lrnum
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|read_register
argument_list|(
name|lrnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the memory stack pointer.  */
name|write_register
argument_list|(
name|MSP_REGNUM
argument_list|,
name|fi
operator|->
name|saved_msp
argument_list|)
expr_stmt|;
comment|/* Restore the register stack pointer.  */
name|write_register
argument_list|(
name|GR1_REGNUM
argument_list|,
name|gr1
argument_list|)
expr_stmt|;
comment|/* Check whether we need to fill registers.  */
name|lr1
operator|=
name|read_register
argument_list|(
name|LR0_REGNUM
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr1
operator|>
name|rfb
condition|)
block|{
comment|/* Fill.  */
name|int
name|num_bytes
init|=
name|lr1
operator|-
name|rfb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|word
decl_stmt|;
name|write_register
argument_list|(
name|RAB_REGNUM
argument_list|,
name|read_register
argument_list|(
name|RAB_REGNUM
argument_list|)
operator|+
name|num_bytes
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|RFB_REGNUM
argument_list|,
name|lr1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_bytes
condition|;
name|i
operator|+=
literal|4
control|)
block|{
comment|/* Note: word is in host byte order.  */
name|word
operator|=
name|read_memory_integer
argument_list|(
name|rfb
operator|+
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|LR0_REGNUM
operator|+
operator|(
operator|(
name|rfb
operator|-
name|gr1
operator|)
operator|%
literal|0x80
operator|)
operator|+
name|i
operator|/
literal|4
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
literal|0
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push an empty stack frame, to record the current PC, etc.  */
end_comment

begin_function
name|void
name|push_dummy_frame
parameter_list|()
block|{
name|long
name|w
decl_stmt|;
name|CORE_ADDR
name|rab
decl_stmt|,
name|gr1
decl_stmt|;
name|CORE_ADDR
name|msp
init|=
name|read_register
argument_list|(
name|MSP_REGNUM
argument_list|)
decl_stmt|;
name|int
name|lrnum
decl_stmt|,
name|i
decl_stmt|,
name|saved_lr0
decl_stmt|;
comment|/* Allocate the new frame. */
name|gr1
operator|=
name|read_register
argument_list|(
name|GR1_REGNUM
argument_list|)
operator|-
name|DUMMY_FRAME_RSIZE
expr_stmt|;
name|write_register
argument_list|(
name|GR1_REGNUM
argument_list|,
name|gr1
argument_list|)
expr_stmt|;
name|rab
operator|=
name|read_register
argument_list|(
name|RAB_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr1
operator|<
name|rab
condition|)
block|{
comment|/* We need to spill registers.  */
name|int
name|num_bytes
init|=
name|rab
operator|-
name|gr1
decl_stmt|;
name|CORE_ADDR
name|rfb
init|=
name|read_register
argument_list|(
name|RFB_REGNUM
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|word
decl_stmt|;
name|write_register
argument_list|(
name|RFB_REGNUM
argument_list|,
name|rfb
operator|-
name|num_bytes
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|RAB_REGNUM
argument_list|,
name|gr1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_bytes
condition|;
name|i
operator|+=
literal|4
control|)
block|{
comment|/* Note:  word is in target byte order.  */
name|read_register_gen
argument_list|(
name|LR0_REGNUM
operator|+
name|i
operator|/
literal|4
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|rfb
operator|-
name|num_bytes
operator|+
name|i
argument_list|,
operator|&
name|word
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There are no arguments in to the dummy frame, so we don't need      more than rsize plus the return address and lr1.  */
name|write_register
argument_list|(
name|LR0_REGNUM
operator|+
literal|1
argument_list|,
name|gr1
operator|+
name|DUMMY_FRAME_RSIZE
operator|+
literal|2
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Set the memory frame pointer.  */
name|write_register
argument_list|(
name|LR0_REGNUM
operator|+
name|DUMMY_FRAME_RSIZE
operator|/
literal|4
operator|-
literal|1
argument_list|,
name|msp
argument_list|)
expr_stmt|;
comment|/* Allocate arg_slop.  */
name|write_register
argument_list|(
name|MSP_REGNUM
argument_list|,
name|msp
operator|-
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Save registers.  */
name|lrnum
operator|=
name|LR0_REGNUM
operator|+
name|DUMMY_ARG
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DUMMY_SAVE_SR128
condition|;
operator|++
name|i
control|)
name|write_register
argument_list|(
name|lrnum
operator|++
argument_list|,
name|read_register
argument_list|(
name|SR_REGNUM
argument_list|(
name|i
operator|+
literal|128
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DUMMY_SAVE_SR160
condition|;
operator|++
name|i
control|)
name|write_register
argument_list|(
name|lrnum
operator|++
argument_list|,
name|read_register
argument_list|(
name|SR_REGNUM
argument_list|(
name|i
operator|+
literal|160
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DUMMY_SAVE_GREGS
condition|;
operator|++
name|i
control|)
name|write_register
argument_list|(
name|lrnum
operator|++
argument_list|,
name|read_register
argument_list|(
name|RETURN_REGNUM
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save the PCs.  */
name|write_register
argument_list|(
name|lrnum
operator|++
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|lrnum
argument_list|,
name|read_register
argument_list|(
name|NPC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|reginv_com
argument_list|(
argument|args
argument_list|,
argument|fromtty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fromtty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|registers_changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|fromtty
condition|)
name|printf_filtered
argument_list|(
literal|"Gdb's register cache invalidated.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* We use this mostly for debugging gdb */
end_comment

begin_function
name|void
name|_initialize_29k
parameter_list|()
block|{
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
name|add_com
argument_list|(
literal|"reginv "
argument_list|,
name|class_obscure
argument_list|,
name|reginv_com
argument_list|,
literal|"Invalidate gdb's internal register cache."
argument_list|)
expr_stmt|;
comment|/* FIXME, there should be a way to make a CORE_ADDR variable settable. */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"rstack_high_address"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rstack_high_address
argument_list|,
literal|"Set top address in memory of the register stack.\n\ Attempts to access registers saved above this address will be ignored\n\ or will produce the value -1."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* FIXME, there should be a way to make a CORE_ADDR variable settable. */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"call_scratch_address"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|text_end
argument_list|,
literal|"Set address in memory where small amounts of RAM can be used when\n\ making function calls into the inferior."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

