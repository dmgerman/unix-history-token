begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|print_string
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_print
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_print
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_output_radix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|type_print_base
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|type_print_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|type_print_varspec_suffix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|type_print_varspec_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|type_print_derivation_info
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|type_print_method_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cplus_val_print
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|,
expr|struct
name|type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|val_print_fields
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|,
expr|struct
name|type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_vtbl_member
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_vtbl_ptr_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_hex_chars
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|demangle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether to print C++ syms raw or source-form */
end_comment

begin_comment
comment|/* Maximum number of chars to print for a string pointer value    or vector contents, or UINT_MAX for no limit.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|print_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default input and output radixes, and output format letter.  */
end_comment

begin_decl_stmt
name|unsigned
name|input_radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|output_radix
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output_format
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print repeat counts if there are more than this    many repetitions of an element in an array.  */
end_comment

begin_define
define|#
directive|define
name|REPEAT_COUNT_THRESHOLD
value|10
end_define

begin_comment
comment|/* Define a mess of print controls.  */
end_comment

begin_decl_stmt
name|int
name|prettyprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of structures */
end_comment

begin_decl_stmt
name|int
name|vtblprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of vtbl's */
end_comment

begin_decl_stmt
name|int
name|unionprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of nested unions.  */
end_comment

begin_decl_stmt
name|int
name|arrayprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of arrays.  */
end_comment

begin_decl_stmt
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls pretty printing of addresses.  */
end_comment

begin_decl_stmt
name|int
name|objectprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls looking up an object's derived type 			   using what we find in its vtables.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|dont_print_obstack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.  */
end_comment

begin_function
specifier|static
name|void
name|print_string
parameter_list|(
name|stream
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|force_ellipses
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|force_ellipses
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|inspect_it
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\"\""
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining 	 to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|REPEAT_COUNT_THRESHOLD
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|REPEAT_COUNT_THRESHOLD
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a floating point value of type TYPE, pointed to in GDB by VALADDR,    on STREAM.  */
end_comment

begin_function
name|void
name|print_floating
parameter_list|(
name|valaddr
parameter_list|,
name|type
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|double
name|doub
decl_stmt|;
name|int
name|inv
decl_stmt|;
name|unsigned
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IEEE_FLOAT
argument_list|)
comment|/* Check for NaN's.  Note that this code does not depend on us being      on an IEEE conforming system.  It only depends on the target      machine using IEEE representation.  This means (a)      cross-debugging works right, and (2) IEEE_FLOAT can (and should)      be defined for systems like the 68881, which uses IEEE      representation, but is not IEEE conforming.  */
block|{
name|long
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* Is the sign bit 0?  */
name|int
name|nonnegative
decl_stmt|;
comment|/* Is it is a NaN (i.e. the exponent is all ones and        the fraction is nonzero)?  */
name|int
name|is_nan
decl_stmt|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
block|{
comment|/* It's single precision. */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|low
argument_list|,
name|valaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
comment|/* target -> host.  */
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|low
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|nonnegative
operator|=
name|low
operator|>=
literal|0
expr_stmt|;
name|is_nan
operator|=
operator|(
operator|(
operator|(
operator|(
name|low
operator|>>
literal|23
operator|)
operator|&
literal|0xFF
operator|)
operator|==
literal|0xFF
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|low
operator|&
literal|0x7FFFFF
operator|)
operator|)
expr_stmt|;
name|low
operator|&=
literal|0x7fffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* It's double precision.  Get the high and low words.  */
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|memcpy
argument_list|(
operator|&
name|low
argument_list|,
name|valaddr
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|high
argument_list|,
name|valaddr
operator|+
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
operator|&
name|low
argument_list|,
name|valaddr
operator|+
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|high
argument_list|,
name|valaddr
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|low
argument_list|,
sizeof|sizeof
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|high
argument_list|,
sizeof|sizeof
argument_list|(
name|high
argument_list|)
argument_list|)
expr_stmt|;
name|nonnegative
operator|=
name|high
operator|>=
literal|0
expr_stmt|;
name|is_nan
operator|=
operator|(
operator|(
operator|(
name|high
operator|>>
literal|20
operator|)
operator|&
literal|0x7ff
operator|)
operator|==
literal|0x7ff
operator|&&
operator|!
operator|(
operator|(
operator|(
operator|(
name|high
operator|&
literal|0xfffff
operator|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|low
operator|==
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|high
operator|&=
literal|0xfffff
expr_stmt|;
block|}
if|if
condition|(
name|is_nan
condition|)
block|{
comment|/* The meaning of the sign and fraction is not defined by IEEE. 	   But the user might know what they mean.  For example, they 	   (in an implementation-defined manner) distinguish between 	   signaling and quiet NaN's.  */
if|if
condition|(
name|high
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-NaN(0x%lx%.8lx)"
operator|+
name|nonnegative
argument_list|,
name|high
argument_list|,
name|low
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-NaN(0x%lx)"
operator|+
name|nonnegative
argument_list|,
name|low
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* IEEE_FLOAT.  */
name|doub
operator|=
name|unpack_double
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid float value>"
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|?
literal|"%.9g"
else|:
literal|"%.17g"
argument_list|,
name|doub
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VALADDR points to an integer of LEN bytes.  Print it in hex on stream.  */
end_comment

begin_function
specifier|static
name|void
name|print_hex_chars
parameter_list|(
name|stream
parameter_list|,
name|valaddr
parameter_list|,
name|len
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|unsigned
name|char
modifier|*
name|valaddr
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|p
operator|<
name|valaddr
operator|+
name|len
condition|;
name|p
operator|++
control|)
else|#
directive|else
comment|/* Little endian.  */
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
endif|#
directive|endif
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the value VAL in C-ish syntax on stream STREAM.    FORMAT is a format-letter, or 0 for print in natural format of data type.    If the object printed is a string pointer, returns    the number of string bytes printed.  */
end_comment

begin_function
name|int
name|value_print
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|pretty
parameter_list|)
name|value
name|val
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|typelen
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"<address of value unknown>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"<value optimized out>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* A "repeated" value really contains several values in a row.      They are made by the @ operator.      Print such values as if they were arrays.  */
elseif|else
if|if
condition|(
name|VALUE_REPEATED
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|n
operator|=
name|VALUE_REPETITIONS
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|typelen
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* Print arrays of characters using string syntax.  */
if|if
condition|(
name|typelen
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|format
operator|==
literal|0
condition|)
name|print_string
argument_list|(
name|stream
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
block|{
comment|/* Position of the array element we are examining to see 		 whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|n
operator|&&
operator|!
name|memcmp
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|rep1
argument_list|,
name|typelen
argument_list|)
condition|)
block|{
operator|++
name|reps
expr_stmt|;
operator|++
name|rep1
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|REPEAT_COUNT_THRESHOLD
condition|)
block|{
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|REPEAT_COUNT_THRESHOLD
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|things_printed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|n
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|n
operator|*
name|typelen
return|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
comment|/* If it is a pointer, indicate what it points to.  	 Print type also if it is a reference.           C++: if it is a member pointer, we will take care 	 of that when we print it.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Hack:  remove (char *) for char strings.  Their 	     type is indicated by the quoted string anyway. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Print nothing */
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return truth value for assertion that TYPE is of the type    "pointer to virtual function".  */
end_comment

begin_function
specifier|static
name|int
name|is_vtbl_ptr_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|typename
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
name|vtbl_ptr_name
index|[]
init|=
block|{
name|CPLUS_MARKER
block|,
literal|'v'
block|,
literal|'t'
block|,
literal|'b'
block|,
literal|'l'
block|,
literal|'_'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
literal|'_'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'p'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
return|return
operator|(
name|typename
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|typename
argument_list|,
name|vtbl_ptr_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value for the assertion that TYPE is of the type    "pointer to virtual function table".  */
end_comment

begin_function
specifier|static
name|int
name|is_vtbl_member
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
comment|/* Virtual functions tables are full of pointers to virtual functions.  */
return|return
name|is_vtbl_ptr_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mutually recursive subroutines of cplus_val_print and val_print to print out    a structure's fields: val_print_fields and cplus_val_print.     TYPE, VALADDR, STREAM, RECURSE, and PRETTY have the    same meanings as in cplus_val_print and val_print.     DONT_PRINT is an array of baseclass types that we    should not print, or zero if called from top level.  */
end_comment

begin_function
specifier|static
name|void
name|val_print_fields
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|dont_print
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|dont_print
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|n_baseclasses
decl_stmt|;
name|check_stub_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Print out baseclasses such that we don't print      duplicates of virtual baseclasses.  */
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
name|cplus_val_print
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|,
name|dont_print
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|&&
name|n_baseclasses
operator|==
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<No data fields>"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|extern
name|int
name|inspect_it
decl_stmt|;
name|int
name|fields_seen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check if static field */
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fields_seen
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"members of "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fields_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inspect_it
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|fputs_filtered
argument_list|(
literal|"\"( ptr \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\"( nodef \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprint_symbol
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\" \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprint_symbol
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\") \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprint_symbol
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|value
name|v
decl_stmt|;
comment|/* Bitfields require special handling, especially due to byte 		 order problems.  */
name|v
operator|=
name|value_from_longest
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|unpack_field_as_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Special val_print routine to avoid printing multiple copies of virtual    baseclasses.  */
end_comment

begin_function
specifier|static
name|void
name|cplus_val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|dont_print
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|dont_print
decl_stmt|;
block|{
name|struct
name|obstack
name|tmp_obstack
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|last_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_obstack
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_print
operator|==
literal|0
condition|)
block|{
comment|/* If we're at top level, carve out a completely fresh 	 chunk of the obstack and use that until this particular 	 invocation returns.  */
name|tmp_obstack
operator|=
name|dont_print_obstack
expr_stmt|;
comment|/* Bump up the high-water mark.  Now alpha is omega.  */
name|obstack_finish
argument_list|(
operator|&
name|dont_print_obstack
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|baddr
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|first_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_obstack
argument_list|)
decl_stmt|;
name|int
name|j
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_obstack
argument_list|)
operator|-
name|first_dont_print
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
if|if
condition|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|==
name|first_dont_print
index|[
name|j
index|]
condition|)
goto|goto
name|flush_it
goto|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|dont_print_obstack
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fix to use baseclass_offset instead. FIXME */
name|baddr
operator|=
name|baseclass_addr
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|baddr
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"could not find virtual baseclass `%s'\n"
argument_list|,
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"> = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid address 0x%x>"
argument_list|,
name|baddr
argument_list|)
expr_stmt|;
else|else
name|val_print_fields
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|baddr
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|flush_it
label|:
empty_stmt|;
block|}
if|if
condition|(
name|dont_print
operator|==
literal|0
condition|)
block|{
comment|/* Free the space used to deal with the printing 	 of this type from top level.  */
name|obstack_free
argument_list|(
operator|&
name|dont_print_obstack
argument_list|,
name|last_dont_print
argument_list|)
expr_stmt|;
comment|/* Reset watermark so that we can continue protecting 	 ourselves from whatever we were protecting ourselves.  */
name|dont_print_obstack
operator|=
name|tmp_obstack
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_class_member
parameter_list|(
name|valaddr
parameter_list|,
name|domain
parameter_list|,
name|stream
parameter_list|,
name|prefix
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
comment|/* VAL is a byte offset into the structure type DOMAIN.      Find the name of the field for that offset and      print it.  */
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|bits
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|domain
argument_list|)
decl_stmt|;
comment|/* @@ Make VAL into bit offset */
name|LONGEST
name|val
init|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
operator|<<
literal|3
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|domain
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|bitpos
condition|)
break|break;
if|if
condition|(
name|val
operator|<
name|bitpos
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* Somehow pointing into a field.  */
name|i
operator|-=
literal|1
expr_stmt|;
name|extra
operator|=
operator|(
name|val
operator|-
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
literal|0x7
condition|)
name|bits
operator|=
literal|1
expr_stmt|;
else|else
name|extra
operator|>>=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|type_print_base
argument_list|(
name|domain
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" + %d bytes"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" (offset in bits)"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB),    which came from the inferior at address ADDRESS,    onto stdio stream STREAM according to FORMAT    (a letter or 0 for natural format).  The data at VALADDR    is in target byte order.     If the data are a string pointer, returns the number of    sting characters printed.     if DEREF_REF is nonzero, then dereference references,    otherwise just print them like pointers.     The PRETTY parameter controls prettyprinting.  */
end_comment

begin_function
name|int
name|val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|pretty
operator|==
name|Val_pretty_default
condition|)
block|{
name|pretty
operator|=
name|prettyprint
condition|?
name|Val_prettyprint
else|:
name|Val_no_prettyprint
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
name|check_stub_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown struct>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
if|if
condition|(
name|arrayprint
condition|)
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* For an array of chars, print with string syntax.  */
if|if
condition|(
name|eltlen
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
condition|)
name|print_string
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
comment|/* If this is a virtual function table, print the 0th 		 entry specially, and the rest of the members normally.  */
if|if
condition|(
name|is_vtbl_ptr_type
argument_list|(
name|elttype
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d vtable entries"
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
block|{
comment|/* Position of the array element we are examining to see 		     whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
if|if
condition|(
name|arrayprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|len
operator|&&
operator|!
name|memcmp
argument_list|(
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
name|valaddr
operator|+
name|rep1
operator|*
name|eltlen
argument_list|,
name|eltlen
argument_list|)
condition|)
block|{
operator|++
name|reps
expr_stmt|;
operator|++
name|rep1
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|REPEAT_COUNT_THRESHOLD
condition|)
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|REPEAT_COUNT_THRESHOLD
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|things_printed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Array of unspecified length: treat like pointer to first elt.  */
name|valaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|address
expr_stmt|;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|format
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|struct
name|type
modifier|*
name|domain
decl_stmt|,
modifier|*
name|ttype
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
decl_stmt|;
name|char
modifier|*
name|kind
init|=
literal|""
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|ttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttype
operator|==
literal|0
operator|||
operator|(
name|domain
operator|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|ttype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"<bug workaround: can't print ptr to method>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|METHOD_PTR_IS_VIRTUAL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|METHOD_PTR_TO_VOFFSET
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|offset
condition|)
block|{
name|kind
operator|=
literal|"virtual "
expr_stmt|;
goto|goto
name|common
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|find_pc_function
argument_list|(
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"invalid pointer to member function"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
goto|goto
name|common
goto|;
block|}
block|}
block|}
name|common
label|:
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|type_print_varspec_prefix
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|1
index|]
operator|==
name|CPLUS_MARKER
condition|)
name|type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|+
literal|1
argument_list|,
literal|"~"
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|""
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") %d"
argument_list|,
operator|(
name|int
operator|)
name|addr
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|print_class_member
argument_list|(
name|valaddr
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CORE_ADDR
name|addr
init|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* Try to print what function it points to.  */
name|print_address_demangle
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
comment|/* Return value is irrelevant except for string pointers.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|addressprint
operator|&&
name|format
operator|!=
literal|'s'
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* For a pointer to char or unsigned char, 	     also print the string pointed to, unless pointer is null.  */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Number of characters printed.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
operator|&&
name|addr
operator|!=
literal|0
comment|/* If print_max is UINT_MAX, the alloca below will fail. 	         In that case don't try to print the string.  */
operator|&&
name|print_max
operator|<
name|UINT_MAX
condition|)
block|{
name|int
name|first_addr_err
init|=
literal|0
decl_stmt|;
name|int
name|errcode
init|=
literal|0
decl_stmt|;
comment|/* Get first character.  */
name|errcode
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
comment|/* First address out of bounds.  */
name|first_addr_err
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* A real string.  */
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|print_max
argument_list|)
decl_stmt|;
comment|/* If the loop ends by us hitting print_max characters, 		     we need to have elipses at the end.  */
name|int
name|force_ellipses
init|=
literal|1
decl_stmt|;
comment|/* This loop always fetches print_max characters, even 		     though print_string might want to print more or fewer 		     (with repeated characters).  This is so that 		     we don't spend forever fetching if we print 		     a long string consisting of the same character 		     repeated.  Also so we can do it all in one memory 		     operation, which is faster.  However, this will be 		     slower if print_max is set high, e.g. if you set 		     print_max to 1000, not only will it take a long 		     time to fetch short strings, but if you are near 		     the end of the address space, it might not work. */
name|QUIT
expr_stmt|;
name|errcode
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|string
argument_list|,
name|print_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
comment|/* Try reading just one character.  If that succeeds, 			 assume we hit the end of the address space, but 			 the initial part of the string is probably safe. */
name|char
name|x
index|[
literal|1
index|]
decl_stmt|;
name|errcode
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|force_ellipses
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|force_ellipses
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|QUIT
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|stream
argument_list|,
name|string
argument_list|,
name|i
argument_list|,
name|force_ellipses
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errcode
operator|==
name|EIO
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
operator|(
literal|"<Address 0x%x out of bounds>"
operator|+
name|first_addr_err
operator|)
argument_list|,
name|addr
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Error reading memory address 0x%x: %s."
argument_list|,
name|addr
operator|+
name|i
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* print vtbl's nicely */
if|if
condition|(
name|is_vtbl_member
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|vt_address
init|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|vt_address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|vt_address
operator|==
name|msymbol
operator|->
name|address
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|msymbol
operator|->
name|name
argument_list|,
name|stream
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|">"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vtblprint
condition|)
block|{
name|value
name|vt_val
decl_stmt|;
name|vt_val
operator|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|vt_address
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Return number of characters printed, plus one for the 	     terminating null if we have "reached the end".  */
return|return
name|i
operator|+
operator|(
name|print_max
operator|&&
name|i
operator|!=
name|print_max
operator|)
return|;
block|}
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
name|error
argument_list|(
literal|"not implemented: member type in val_print"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
block|{
name|CORE_ADDR
name|addr
init|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|print_class_member
argument_list|(
name|valaddr
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addressprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@0x%lx"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_ref
condition|)
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* De-reference the reference.  */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|target_read_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Address out of bounds>"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|value
name|deref_val
init|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|recurse
operator|&&
operator|!
name|unionprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|vtblprint
operator|&&
name|is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
name|print_address_demangle
argument_list|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|valaddr
operator|+
comment|/* FIXME bytesex */
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|VTBL_FNADDR_OFFSET
argument_list|)
operator|/
literal|8
operator|)
operator|)
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
block|}
name|val_print_fields
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|LONG_LONG
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%lld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FIXME, we should consider, at least for ANSI C language, eliminating 	 the distinction made between FUNCs and POINTERs to FUNCs.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"} "
argument_list|)
expr_stmt|;
comment|/* Try to print what function it points to, and its address.  */
name|print_address_demangle
argument_list|(
name|address
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_INT
case|:
if|if
condition|(
name|format
operator|||
name|output_format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
condition|?
name|format
else|:
name|output_format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* First figure out whether the number in fact has zeros 		 in all its bytes more significant than least significant 		 sizeof (LONGEST) ones.  */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to first (i.e. lowest address) nonzero character.  */
name|char
modifier|*
name|first_addr
decl_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
for|for
control|(
name|p
operator|=
name|valaddr
init|;
name|len
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|&&
name|p
operator|<
name|valaddr
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|;
name|p
operator|++
control|)
else|#
directive|else
comment|/* Little endian.  */
name|first_addr
operator|=
name|valaddr
expr_stmt|;
for|for
control|(
name|p
operator|=
name|valaddr
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
init|;
name|len
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|&&
name|p
operator|>=
name|valaddr
condition|;
name|p
operator|--
control|)
endif|#
directive|endif
comment|/* Little endian.  */
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|len
operator|--
expr_stmt|;
else|else
break|break;
block|}
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|first_addr
operator|=
name|p
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
comment|/* We can print it in decimal.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|LONG_LONG
argument_list|)
literal|"%llu"
argument_list|,
else|#
directive|else
literal|"%lu"
argument_list|,
endif|#
directive|endif
name|unpack_long
argument_list|(
name|BUILTIN_TYPE_LONGEST
argument_list|,
name|first_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is big, so print it in hex.  */
name|print_hex_chars
argument_list|(
name|stream
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|first_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Signed.  One could assume two's complement (a reasonable 		 assumption, I think) and do better than this.  */
name|print_hex_chars
argument_list|(
name|stream
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|PRINT_TYPELESS_INTEGER
name|PRINT_TYPELESS_INTEGER
argument_list|(
name|stream
argument_list|,
name|type
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* No format type is specified.  Just use /x for unsigned 	 and /d for signed. */
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|'x'
else|:
literal|'d'
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" '"
argument_list|)
expr_stmt|;
name|printchar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
comment|/* This happens (without TYPE_FLAG_STUB set) on systems which don't use 	 dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar" 	 and no complete type for struct foo in that file.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown struct>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* FIXME, we should not ever have to print one of these yet.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<range type>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid type code in symbol table."
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a description of a type in the format of a     typedef for the current language.    NEW is the new name for a type TYPE. */
end_comment

begin_function
name|void
name|typedef_print
parameter_list|(
name|type
parameter_list|,
name|new
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|symbol
modifier|*
name|new
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
ifdef|#
directive|ifdef
name|_LANG_c
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"typedef "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
operator|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
operator|)
argument_list|)
operator|==
literal|0
operator|||
literal|0
operator|!=
name|strcmp
argument_list|(
name|TYPE_NAME
argument_list|(
operator|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
operator|)
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LANG_m2
case|case
name|language_m2
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"TYPE "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
operator|||
name|strcmp
argument_list|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s = "
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<builtin> = "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
argument_list|(
literal|"Language not supported."
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a description of a type TYPE    in the form of a declaration of a variable named VARSTRING.    (VARSTRING is demangled if necessary.)    Output goes to STREAM (via stdio).    If SHOW is positive, we show the contents of the outermost level    of structure even if there is a type name that could be used instead.    If SHOW is negative, we never show the details of elements' types.  */
end_comment

begin_function
name|void
name|type_print
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
block|{
name|type_print_1
argument_list|(
name|type
argument_list|,
name|varstring
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LEVEL is the depth to indent lines by.  */
end_comment

begin_function
name|void
name|type_print_1
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
name|type_print_base
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|varstring
operator|&&
operator|*
name|varstring
operator|)
operator|||
comment|/* Need a space if going to print stars or brackets; 	 but not if we will print just a type name.  */
operator|(
operator|(
name|show
operator|>
literal|0
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|code
operator|==
name|TYPE_CODE_MEMBER
operator|||
name|code
operator|==
name|TYPE_CODE_REF
operator|)
operator|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|type_print_varspec_prefix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if the name has a C++ demangled equivalent, and if so, print that      instead. */
if|if
condition|(
name|demangle
condition|)
block|{
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|varstring
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
operator|(
name|demangled
operator|!=
name|NULL
operator|)
condition|?
name|demangled
else|:
name|varstring
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* For demangled function names, we have the arglist as part of the name,      so don't print an additional pair of ()'s */
name|demangled_args
operator|=
operator|(
name|demangled
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|code
operator|==
name|TYPE_CODE_FUNC
operator|)
expr_stmt|;
name|type_print_varspec_suffix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
name|demangled_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the method arguments ARGS to the file STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_method_args
parameter_list|(
name|args
parameter_list|,
name|prefix
parameter_list|,
name|varstring
parameter_list|,
name|staticp
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|,
decl|*
name|varstring
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|staticp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fputs_demangled
argument_list|(
name|prefix
argument_list|,
name|stream
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|varstring
argument_list|,
name|stream
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|args
index|[
operator|!
name|staticp
index|]
operator|&&
name|args
index|[
operator|!
name|staticp
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|i
operator|=
operator|!
name|staticp
expr_stmt|;
comment|/* skip the class variable */
while|while
condition|(
literal|1
condition|)
block|{
name|type_print
argument_list|(
name|args
index|[
name|i
operator|++
index|]
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If TYPE is a derived type, then print out derivation information.    Print only the actual base classes of this type, not the base classes    of the base classes.  I.E.  for the derivation hierarchy:  	class A { int a; }; 	class B : public A {int b; }; 	class C : public B {int c; };     Print the type of class C as:     	class C : public B { 		int c; 	}     Not as the following (like gdb used to), which is not legal C++ syntax for    derived types and may be confused with the multiple inheritance form:  	class C : public B : public A { 		int c; 	}     In general, gdb should try to print the types as closely as possible to    the form that they appear in the source code. */
end_comment

begin_function
specifier|static
name|void
name|type_print_derivation_info
parameter_list|(
name|stream
parameter_list|,
name|type
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fputs_filtered
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|": "
else|:
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s "
argument_list|,
name|BASETYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|"public"
else|:
literal|"private"
argument_list|,
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|" virtual"
else|:
literal|""
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print any asterisks or open-parentheses needed before the    variable name (to describe its type).     On outermost call, pass 0 for PASSED_A_PTR.    On outermost call, SHOW> 0 means should ignore    any typename for TYPE and show its details.    SHOW is always zero on recursive calls.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_varspec_prefix
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|passed_a_ptr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|passed_a_ptr
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_PASCAL_ARRAY
case|:
comment|/* These types need no prefix.  They are listed here so that 	 gcc -Wall will reveal any types that haven't been handled.  */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|type_print_args
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|args
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|;
name|i
operator|++
control|)
block|{
name|type_print_1
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print any array sizes, function arguments or close parentheses    needed after the variable name (to describe its type).    Args work like type_print_varspec_prefix.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_varspec_suffix
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|passed_a_ptr
parameter_list|,
name|demangled_args
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|passed_a_ptr
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|type_print_args
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|demangled_args
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_PASCAL_ARRAY
case|:
comment|/* These types do not need a suffix.  They are listed so that 	 gcc -Wall will report types that may not have been considered.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print the name of the type (or the ultimate pointer target,    function value or array element), or the description of a    structure or union.     SHOW nonzero means don't print this type as just its name;    show its real definition even if it has a name.    SHOW zero means print just typename or struct tag if there is one    SHOW negative means abbreviate structure elements.    SHOW is decremented for printing of structure elements.     LEVEL is the depth to indent by.    We increase it for some recursive calls.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_base
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|lastval
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|char
modifier|*
name|demangled_name
decl_stmt|;
enum|enum
block|{
name|s_none
block|,
name|s_public
block|,
name|s_private
block|,
name|s_protected
block|}
name|section_type
enum|;
name|QUIT
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<type unknown>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* When SHOW is zero or less, and there is a valid type name, then always      just print the type name directly from the type. */
if|if
condition|(
operator|(
name|show
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_METHOD
case|:
name|type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|?
literal|"class "
else|:
literal|"struct "
argument_list|)
expr_stmt|;
goto|goto
name|struct_union
goto|;
case|case
name|TYPE_CODE_UNION
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|struct_union
label|:
if|if
condition|(
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
else|else
block|{
name|check_stub_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_print_derivation_info
argument_list|(
name|stream
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<incomplete type>\n"
argument_list|)
expr_stmt|;
else|else
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<no data fields>\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Start off with no specific section type, so we can print 	     one for the first field we find, and use that section type 	     thereafter until we find another type. */
name|section_type
operator|=
name|s_none
expr_stmt|;
comment|/* If there is a base class for this type, 	     do not print the field that it occupies.  */
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Don't print out virtual function table.  */
if|if
condition|(
operator|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|)
index|[
literal|5
index|]
operator|==
name|CPLUS_MARKER
operator|&&
operator|!
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"_vptr"
argument_list|,
literal|5
argument_list|)
condition|)
continue|continue;
comment|/* If this is a C++ class we can print the various C++ section 		 labels. */
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected:\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private:\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public:\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
block|}
name|type_print_1
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* It is a bitfield.  This code does not attempt 		     to look at the bitpos and reconstruct filler, 		     unnamed fields.  This would lead to misleading 		     results if the compiler does not put out fields 		     for such things (I don't know what it does).  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : %d"
argument_list|,
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If there are both fields and methods, put a space between. */
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|section_type
operator|!=
name|s_none
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* C++: print out the methods */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|is_constructor
init|=
name|name
operator|&&
name|strcmp
argument_list|(
name|method_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PROTECTED
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected:\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private:\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public:\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"virtual "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Keep GDB from crashing here.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<undefined type> %s;\n"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_constructor
condition|)
block|{
name|type_print
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
comment|/* Build something we can demangle.  */
name|mangled_name
operator|=
name|gdb_mangle_name
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<badly mangled name %s>"
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|strchr
argument_list|(
name|demangled_name
argument_list|,
literal|':'
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|1
index|]
operator|==
name|CPLUS_MARKER
condition|)
name|type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|+
literal|1
argument_list|,
literal|"~"
argument_list|,
name|method_name
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|""
argument_list|,
name|method_name
argument_list|,
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintfi_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lastval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastval
operator|!=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" = %d"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lastval
operator|++
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct<unknown>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* This should not occur */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<range type>"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Handle types not explicitly handled by the other cases, 	 such as fundamental types.  For these, just print whatever 	 the type name is, as recorded in the type itself.  If there 	 is no type name, then complain. */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Invalid type code (%d) in symbol table."
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Validate an input or output radix setting, and make sure the user    knows what they really did here.  Radix setting is confusing, e.g.    setting the input radix to "10" never changes it!  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
unit|static void set_input_radix (args, from_tty, c)      char *args;      int from_tty;      struct cmd_list_element *c; {   unsigned radix = *(unsigned *)c->var;    if (from_tty)     printf_filtered ("Input radix set to decimal %d, hex %x, octal %o\n", 	radix, radix, radix); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|set_output_radix
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|unsigned
name|radix
init|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|c
operator|->
name|var
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Output radix set to decimal %d, hex %x, octal %o\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
comment|/* FIXME, we really should be able to validate the setting BEFORE      it takes effect.  */
switch|switch
condition|(
name|radix
condition|)
block|{
case|case
literal|16
case|:
name|output_format
operator|=
literal|'x'
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|output_format
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|output_format
operator|=
literal|'o'
expr_stmt|;
comment|/* octal */
break|break;
default|default:
name|output_format
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Unsupported radix ``decimal %d''; using decimal output"
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Both at once */
end_comment

begin_function
specifier|static
name|void
name|set_radix
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|unsigned
name|radix
init|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|c
operator|->
name|var
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Radix set to decimal %d, hex %x, octal %o\n"
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|input_radix
operator|=
name|radix
expr_stmt|;
name|output_radix
operator|=
name|radix
expr_stmt|;
name|set_output_radix
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|set_print
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\"set print\" must be followed by the name of a print subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setprintlist
argument_list|,
literal|"set print "
argument_list|,
operator|-
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|show_print
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|cmd_show_list
argument_list|(
name|showprintlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_valprint
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|no_class
argument_list|,
name|set_print
argument_list|,
literal|"Generic command for setting how things print."
argument_list|,
operator|&
name|setprintlist
argument_list|,
literal|"set print "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"pr"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* prefer set print 														   to     set prompt */
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|no_class
argument_list|,
name|show_print
argument_list|,
literal|"Generic command for showing print settings."
argument_list|,
operator|&
name|showprintlist
argument_list|,
literal|"show print "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"pr"
argument_list|,
literal|"print"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"elements"
argument_list|,
name|no_class
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|print_max
argument_list|,
literal|"Set limit on string chars or array elements to print.\n\ \"set print elements 0\" causes there to be no limit."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"pretty"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|prettyprint
argument_list|,
literal|"Set prettyprinting of structures."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"union"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|unionprint
argument_list|,
literal|"Set printing of unions interior to structures."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"vtbl"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vtblprint
argument_list|,
literal|"Set printing of C++ virtual function tables."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"array"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arrayprint
argument_list|,
literal|"Set prettyprinting of arrays."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"object"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|objectprint
argument_list|,
literal|"Set printing of object's derived type based on vtable info."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"address"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addressprint
argument_list|,
literal|"Set printing of addresses."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The "show radix" cmd isn't good enough to show two separate values.      The rest of the code works, but the show part is confusing, so don't      let them be set separately 'til we work out "show".  */
block|c = add_set_cmd ("input-radix", class_support, var_uinteger, 		   (char *)&input_radix, 		  "Set default input radix for entering numbers.",&setlist);   add_show_from_set (c,&showlist);   c->function = set_input_radix;    c = add_set_cmd ("output-radix", class_support, var_uinteger, 		   (char *)&output_radix, 		  "Set default output radix for printing of values.",&setlist);   add_show_from_set (c,&showlist);   c->function = set_output_radix;
endif|#
directive|endif
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"radix"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_radix
argument_list|,
literal|"Set default input and output number radix."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_radix
expr_stmt|;
comment|/* Give people the defaults which they are used to.  */
name|prettyprint
operator|=
literal|0
expr_stmt|;
name|unionprint
operator|=
literal|1
expr_stmt|;
name|vtblprint
operator|=
literal|0
expr_stmt|;
name|arrayprint
operator|=
literal|0
expr_stmt|;
name|addressprint
operator|=
literal|1
expr_stmt|;
name|objectprint
operator|=
literal|0
expr_stmt|;
name|print_max
operator|=
literal|200
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|dont_print_obstack
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

