begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Sequent Symmetry host interface, for GDB when running under Unix.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* FIXME, some 387-specific items of use taken from i387-tdep.c -- ought to be    merged back in. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|TERMINAL
value|struct sgttyb
end_define

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|pt_regset
name|regs
decl_stmt|;
name|int
name|reg_tmp
decl_stmt|,
name|i
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
if|#
directive|if
literal|0
comment|/* PREPARE_TO_STORE deals with this.  */
block|if (-1 == regno)     {
endif|#
directive|endif
name|regs
operator|.
name|pr_eax
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ebx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|5
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ecx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|2
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_edx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_esi
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|6
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_edi
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|7
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_esp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|14
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ebp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|15
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_eip
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_flags
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|17
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
block|{
name|regs
operator|.
name|pr_fpa
operator|.
name|fpa_regs
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP1_REGNUM
operator|+
name|i
argument_list|)
index|]
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|}   else     {       reg_tmp = *(int *)&registers[REGISTER_BYTE(regno)];       ptrace(XPT_RREGS, inferior_pid, (PTRACE_ARG3_TYPE)&regs, 0);       switch (regno) 	{ 	case 0: 	  regs.pr_eax = *(int *)&registers[REGISTER_BYTE(0)]; 	  break; 	case 5: 	  regs.pr_ebx = *(int *)&registers[REGISTER_BYTE(5)]; 	  break; 	case 2: 	  regs.pr_ecx = *(int *)&registers[REGISTER_BYTE(2)]; 	  break; 	case 1: 	  regs.pr_edx = *(int *)&registers[REGISTER_BYTE(1)]; 	  break; 	case 6: 	  regs.pr_esi = *(int *)&registers[REGISTER_BYTE(6)]; 	  break; 	case 7: 	  regs.pr_edi = *(int *)&registers[REGISTER_BYTE(7)]; 	  break; 	case 15: 	  regs.pr_ebp = *(int *)&registers[REGISTER_BYTE(15)]; 	  break; 	case 14: 	  regs.pr_esp = *(int *)&registers[REGISTER_BYTE(14)]; 	  break; 	case 16: 	  regs.pr_eip = *(int *)&registers[REGISTER_BYTE(16)]; 	  break; 	case 17: 	  regs.pr_flags = *(int *)&registers[REGISTER_BYTE(17)]; 	  break; 	}     }
endif|#
directive|endif
comment|/* 0 */
name|ptrace
argument_list|(
name|XPT_WREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pt_regset
name|regs
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
name|ptrace
argument_list|(
name|XPT_RREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_eax
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|5
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ebx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|2
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ecx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_edx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|6
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_esi
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|7
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_edi
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|15
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ebp
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|14
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_esp
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_eip
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|17
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FPA_NREGS
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP1_REGNUM
operator|+
name|i
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_fpa
operator|.
name|fpa_regs
index|[
name|i
index|]
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|0
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|3
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|1
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|4
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|2
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|8
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|3
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|9
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|4
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|10
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|5
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|11
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|6
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|12
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|7
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|13
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Work with core dump and executable files, for GDB.     This code would be in core.c if it weren't machine-dependent. */
end_comment

begin_function
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
comment|/* Discard all vestiges of any previous core file      and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the inferior with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 4.2-style (and perhaps also sysV-style) core dump file.  */
block|{
name|struct
name|user
name|u
decl_stmt|;
name|int
name|reg_offset
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|NBPG
operator|*
operator|(
name|u
operator|.
name|u_dsize
operator|-
name|u
operator|.
name|u_tsize
operator|)
expr_stmt|;
name|stack_start
operator|=
name|stack_end
operator|-
name|NBPG
operator|*
name|u
operator|.
name|u_ssize
expr_stmt|;
name|data_offset
operator|=
name|NBPG
operator|*
name|UPAGES
expr_stmt|;
name|stack_offset
operator|=
name|ctob
argument_list|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|-
name|u
operator|.
name|u_tsize
argument_list|)
expr_stmt|;
name|reg_offset
operator|=
operator|(
name|int
operator|)
name|u
operator|.
name|u_ar0
operator|-
name|KERNEL_U_ADDR
expr_stmt|;
name|printf
argument_list|(
literal|"u.u_tsize= %#x, u.u_dsize= %#x, u.u_ssize= %#x, stack_off= %#x\n"
argument_list|,
name|u
operator|.
name|u_tsize
argument_list|,
name|u
operator|.
name|u_dsize
argument_list|,
name|u
operator|.
name|u_ssize
argument_list|,
name|stack_offset
argument_list|)
expr_stmt|;
name|core_aouthdr
operator|.
name|a_magic
operator|=
literal|0
expr_stmt|;
comment|/* Read the register values out of the core file and store 	   them where `read_register' will find them.  */
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|corechan
argument_list|,
name|register_addr
argument_list|(
name|regno
argument_list|,
name|reg_offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      set_current_frame (read_register (FP_REGNUM));*/
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME:  This should be merged with i387-tdep.c as well. */
end_comment

begin_expr_stmt
specifier|static
name|print_fpu_status
argument_list|(
argument|ep
argument_list|)
expr|struct
name|pt_regset
name|ep
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"80387:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_ip
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" not in use.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
operator|!=
literal|0
condition|)
block|{
name|print_387_status_word
argument_list|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"last exception: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opcode 0x%x; "
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pc 0x%x:0x%x; "
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_cs
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_ip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"operand 0x%x:0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_data_offset
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_op_sel
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf
argument_list|(
literal|"regno  tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|double
name|val
decl_stmt|;
name|printf
argument_list|(
literal|"%s %d: "
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|,
name|fpreg
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
name|fpreg
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i387_to_double
argument_list|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
name|fpreg
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd1
condition|)
name|warning
argument_list|(
literal|"rsvd1 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd2
condition|)
name|warning
argument_list|(
literal|"rsvd2 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd3
condition|)
name|warning
argument_list|(
literal|"rsvd3 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd5
condition|)
name|warning
argument_list|(
literal|"rsvd5 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd5
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_1167_control_word
argument_list|(
argument|pcr
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|int
name|pcr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pcr_tmp
decl_stmt|;
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_MODE
expr_stmt|;
name|printf
argument_list|(
literal|"\tMODE= %#x; RND= %#x "
argument_list|,
name|pcr_tmp
argument_list|,
name|pcr_tmp
operator|&
literal|12
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcr_tmp
operator|&
literal|12
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"RN (Nearest Value)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"RZ (Zero)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"RP (Positive Infinity)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"RM (Negative Infinity)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"; IRND= %d "
argument_list|,
name|pcr_tmp
operator|&
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|pcr_tmp
operator|&
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"(same as RND)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(toward zero)\n"
argument_list|)
expr_stmt|;
block|}
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_EM
expr_stmt|;
name|printf
argument_list|(
literal|"\tEM= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_DM
condition|)
name|printf
argument_list|(
literal|" DM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_UOM
condition|)
name|printf
argument_list|(
literal|" UOM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_PM
condition|)
name|printf
argument_list|(
literal|" PM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_UM
condition|)
name|printf
argument_list|(
literal|" UM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_OM
condition|)
name|printf
argument_list|(
literal|" OM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_ZM
condition|)
name|printf
argument_list|(
literal|" ZM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_IM
condition|)
name|printf
argument_list|(
literal|" IM"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pcr_tmp
operator|=
name|FPA_PCR_CC
expr_stmt|;
name|printf
argument_list|(
literal|"\tCC= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_20MHZ
condition|)
name|printf
argument_list|(
literal|" 20MHZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_Z
condition|)
name|printf
argument_list|(
literal|" Z"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_C2
condition|)
name|printf
argument_list|(
literal|" C2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_C1
condition|)
name|printf
argument_list|(
literal|" C1"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcr_tmp
condition|)
block|{
case|case
name|FPA_PCR_CC_Z
case|:
name|printf
argument_list|(
literal|" (Equal)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPA_PCR_CC_C1
case|:
name|printf
argument_list|(
literal|" (Less than)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|" (Greater than)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPA_PCR_CC_Z
operator||
name|FPA_PCR_CC_C1
operator||
name|FPA_PCR_CC_C2
case|:
name|printf
argument_list|(
literal|" (Unordered)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" (Undefined)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_AE
expr_stmt|;
name|printf
argument_list|(
literal|"\tAE= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_DE
condition|)
name|printf
argument_list|(
literal|" DE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_UOE
condition|)
name|printf
argument_list|(
literal|" UOE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_PE
condition|)
name|printf
argument_list|(
literal|" PE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_UE
condition|)
name|printf
argument_list|(
literal|" UE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_OE
condition|)
name|printf
argument_list|(
literal|" OE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_ZE
condition|)
name|printf
argument_list|(
literal|" ZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_EE
condition|)
name|printf
argument_list|(
literal|" EE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_IE
condition|)
name|printf
argument_list|(
literal|" IE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_1167_regs
argument_list|(
argument|regs
argument_list|)
end_macro

begin_decl_stmt
name|long
name|regs
index|[
name|FPA_NREGS
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|double
name|d
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
block|}
name|xd
union|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|long
name|l
decl_stmt|;
block|}
name|xf
union|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FPA_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|xf
operator|.
name|l
operator|=
name|regs
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%%fp%d: raw= %#x, single= %f"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|,
name|xf
operator|.
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xd
operator|.
name|l
index|[
literal|1
index|]
operator|=
name|regs
index|[
name|i
index|]
expr_stmt|;
name|xd
operator|.
name|l
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|printf
argument_list|(
literal|", double= %f\n"
argument_list|,
name|xd
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|print_fpa_status
argument_list|(
argument|ep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pt_regset
name|ep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"WTL 1167:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_pcr
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_1167_control_word
argument_list|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_pcr
argument_list|)
expr_stmt|;
name|print_1167_regs
argument_list|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_regs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" not in use.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|i386_float_info
argument_list|()
end_macro

begin_block
block|{
name|char
name|ubuf
index|[
name|UPAGES
operator|*
name|NBPG
index|]
decl_stmt|;
name|struct
name|pt_regset
name|regset
decl_stmt|;
specifier|extern
name|int
name|corechan
decl_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|call_ptrace
argument_list|(
name|XPT_RREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lseek
argument_list|(
name|corechan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"seek on core file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
name|ubuf
argument_list|,
name|UPAGES
operator|*
name|NBPG
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"read on core file"
argument_list|)
expr_stmt|;
block|}
comment|/* only interested in the floating point registers */
name|regset
operator|.
name|pr_fpu
operator|=
operator|(
operator|(
expr|struct
name|user
operator|*
operator|)
name|ubuf
operator|)
operator|->
name|u_fpusave
expr_stmt|;
name|regset
operator|.
name|pr_fpa
operator|=
operator|(
operator|(
expr|struct
name|user
operator|*
operator|)
name|ubuf
operator|)
operator|->
name|u_fpasave
expr_stmt|;
block|}
name|print_fpu_status
argument_list|(
name|regset
argument_list|)
expr_stmt|;
name|print_fpa_status
argument_list|(
name|regset
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

