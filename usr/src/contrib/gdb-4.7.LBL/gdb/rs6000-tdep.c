begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_include
include|#
directive|include
file|<sys/ldr.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we just simulated a single step break. */
end_comment

begin_decl_stmt
name|int
name|one_stepped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Breakpoint shadows for the single step instructions will be kept here. */
end_comment

begin_struct
specifier|static
struct|struct
name|sstep_breaks
block|{
name|int
name|address
decl_stmt|;
name|int
name|data
decl_stmt|;
block|}
name|stepBreaks
index|[
literal|2
index|]
struct|;
end_struct

begin_comment
comment|/* Static function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_text_to_loadinfo
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|textaddr
operator|,
name|CORE_ADDR
name|dataaddr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|find_toc_address
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|pc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|branch_dest
name|PARAMS
argument_list|(
operator|(
name|int
name|opcode
operator|,
name|int
name|instr
operator|,
name|CORE_ADDR
name|pc
operator|,
name|CORE_ADDR
name|safety
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frame_get_cache_fsr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|frame_info
operator|*
name|fi
operator|,
expr|struct
name|aix_framedata
operator|*
name|fdatap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Calculate the destination of a branch/jump.  Return -1 if not a branch.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|branch_dest
parameter_list|(
name|opcode
parameter_list|,
name|instr
parameter_list|,
name|pc
parameter_list|,
name|safety
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|int
name|instr
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|safety
decl_stmt|;
block|{
specifier|register
name|long
name|offset
decl_stmt|;
name|CORE_ADDR
name|dest
decl_stmt|;
name|int
name|immediate
decl_stmt|;
name|int
name|absolute
decl_stmt|;
name|int
name|ext_op
decl_stmt|;
name|absolute
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|>>
literal|1
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|18
case|:
name|immediate
operator|=
operator|(
operator|(
name|instr
operator|&
operator|~
literal|3
operator|)
operator|<<
literal|6
operator|)
operator|>>
literal|6
expr_stmt|;
comment|/* br unconditional */
case|case
literal|16
case|:
if|if
condition|(
name|opcode
operator|!=
literal|18
condition|)
comment|/* br conditional */
name|immediate
operator|=
operator|(
operator|(
name|instr
operator|&
operator|~
literal|3
operator|)
operator|<<
literal|16
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|absolute
condition|)
name|dest
operator|=
name|immediate
expr_stmt|;
else|else
name|dest
operator|=
name|pc
operator|+
name|immediate
expr_stmt|;
break|break;
case|case
literal|19
case|:
name|ext_op
operator|=
operator|(
name|instr
operator|>>
literal|1
operator|)
operator|&
literal|0x3ff
expr_stmt|;
if|if
condition|(
name|ext_op
operator|==
literal|16
condition|)
comment|/* br conditional register */
name|dest
operator|=
name|read_register
argument_list|(
name|LR_REGNUM
argument_list|)
operator|&
operator|~
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|ext_op
operator|==
literal|528
condition|)
comment|/* br cond to count reg */
name|dest
operator|=
name|read_register
argument_list|(
name|CTR_REGNUM
argument_list|)
operator|&
operator|~
literal|3
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|dest
operator|<
name|TEXT_SEGMENT_BASE
operator|)
condition|?
name|safety
else|:
name|dest
return|;
block|}
end_function

begin_comment
comment|/* AIX does not support PT_STEP. Simulate it. */
end_comment

begin_function
name|void
name|single_step
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
define|#
directive|define
name|INSNLEN
parameter_list|(
name|OPCODE
parameter_list|)
value|4
specifier|static
name|char
name|breakp
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
name|int
name|ii
decl_stmt|,
name|insn
decl_stmt|,
name|ret
decl_stmt|,
name|loc
decl_stmt|;
name|int
name|breaks
index|[
literal|2
index|]
decl_stmt|,
name|opcode
decl_stmt|;
if|if
condition|(
operator|!
name|one_stepped
condition|)
block|{
name|loc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|ret
operator|=
name|read_memory
argument_list|(
name|loc
argument_list|,
operator|&
name|insn
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|printf
argument_list|(
literal|"Error in single_step()!!\n"
argument_list|)
expr_stmt|;
name|breaks
index|[
literal|0
index|]
operator|=
name|loc
operator|+
name|INSNLEN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|insn
operator|>>
literal|26
expr_stmt|;
name|breaks
index|[
literal|1
index|]
operator|=
name|branch_dest
argument_list|(
name|opcode
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|,
name|breaks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Don't put two breakpoints on the same address. */
if|if
condition|(
name|breaks
index|[
literal|1
index|]
operator|==
name|breaks
index|[
literal|0
index|]
condition|)
name|breaks
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stepBreaks
index|[
literal|1
index|]
operator|.
name|address
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|2
condition|;
operator|++
name|ii
control|)
block|{
comment|/* ignore invalid breakpoint. */
if|if
condition|(
name|breaks
index|[
name|ii
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|read_memory
argument_list|(
name|breaks
index|[
name|ii
index|]
argument_list|,
operator|&
operator|(
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|data
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write_memory
argument_list|(
name|breaks
index|[
name|ii
index|]
argument_list|,
name|breakp
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|address
operator|=
name|breaks
index|[
name|ii
index|]
expr_stmt|;
block|}
name|one_stepped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* remove step breakpoints. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|2
condition|;
operator|++
name|ii
control|)
if|if
condition|(
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|address
operator|!=
operator|-
literal|1
condition|)
name|write_memory
argument_list|(
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|address
argument_list|,
operator|&
operator|(
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|data
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|one_stepped
operator|=
literal|0
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* FIXME, don't ignore errors! */
block|}
end_function

begin_comment
comment|/* return pc value after skipping a function prologue. */
end_comment

begin_macro
name|skip_prologue
argument_list|(
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|pc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
name|unsigned
name|int
name|op
decl_stmt|;
comment|/* FIXME, assumes instruction size matches host int!!! */
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|op
argument_list|,
sizeof|sizeof
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|pc
return|;
comment|/* Can't access it -- assume no prologue. */
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|op
argument_list|,
sizeof|sizeof
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assume that subsequent fetches can fail with low probability.  */
if|if
condition|(
name|op
operator|==
literal|0x7c0802a6
condition|)
block|{
comment|/* mflr r0 */
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc00003e
operator|)
operator|==
literal|0x7c000026
condition|)
block|{
comment|/* mfcr Rx */
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x48000000
condition|)
block|{
comment|/* bl foo, to save fprs??? */
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* At this point, make sure this is not a trampoline function        (a function that simply calls another functions, and nothing else).        If the next is not a nop, this branch was part of the function        prologue. */
if|if
condition|(
name|op
operator|==
literal|0x4def7b82
operator|||
comment|/* crorc 15, 15, 15 */
name|op
operator|==
literal|0x0
condition|)
return|return
name|pc
operator|-
literal|4
return|;
comment|/* don't skip over this branch */
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xbc010000
condition|)
block|{
comment|/* stm Rx, NUM(r1) */
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
name|tmp
operator|=
name|op
operator|>>
literal|16
operator|)
operator|==
literal|0x9001
operator|)
operator|||
comment|/* st   r0, NUM(r1) */
operator|(
name|tmp
operator|==
literal|0x9421
operator|)
operator|||
comment|/* stu  r1, NUM(r1) */
operator|(
name|op
operator|==
literal|0x93e1fffc
operator|)
condition|)
comment|/* st   r31,-4(r1) */
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|tmp
operator|=
operator|(
name|op
operator|>>
literal|22
operator|)
operator|)
operator|==
literal|0x20f
condition|)
block|{
comment|/* l	r31, ... or */
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* l	r30, ...    */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* store parameters into stack */
while|while
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xd8010000
operator|||
comment|/* stfd Rx,NUM(r1) */
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0x90010000
operator|||
comment|/* st r?, NUM(r1)  */
operator|(
name|op
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0xfc000000
operator|||
comment|/* frsp, fp?, .. */
operator|(
name|op
operator|&
literal|0xd0000000
operator|)
operator|==
literal|0xd0000000
condition|)
comment|/* stfs, fp?, .. */
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* store fpr double */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
literal|0x603f0000
condition|)
block|{
comment|/* oril r31, r1, 0x0 */
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* this happens if r31 is used as */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* frame ptr. (gcc does that)	  */
name|tmp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|>>
literal|16
operator|)
operator|==
operator|(
literal|0x907f
operator|+
name|tmp
operator|)
condition|)
block|{
comment|/* st r3, NUM(r31) */
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* st r4, NUM(r31), ... */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tmp
operator|+=
literal|0x20
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* I have problems with skipping over __main() that I need to address  * sometime. Previously, I used to use misc_function_vector which  * didn't work as well as I wanted to be.  -MGO */
comment|/* If the first thing after skipping a prolog is a branch to a function,      this might be a call to an initializer in main(), introduced by gcc2.      We'd like to skip over it as well. Fortunately, xlc does some extra      work before calling a function right after a prologue, thus we can      single out such gcc2 behaviour. */
block|if ((op& 0xfc000001) == 0x48000001) {
comment|/* bl foo, an initializer function? */
block|op = read_memory_integer (pc+4, 4);      if (op == 0x4def7b82) {
comment|/* cror 0xf, 0xf, 0xf (nop) */
comment|/* check and see if we are in main. If so, skip over this initializer          function as well. */
block|tmp = find_pc_misc_function (pc);       if (tmp>= 0&& !strcmp (misc_function_vector [tmp].name, "main"))         return pc + 8;     }   }
endif|#
directive|endif
comment|/* 0 */
return|return
name|pc
return|;
block|}
end_block

begin_comment
comment|/*************************************************************************   Support for creating pushind a dummy frame into the stack, and popping   frames, etc.  *************************************************************************/
end_comment

begin_comment
comment|/* The total size of dummy frame is 436, which is;  	32 gpr's	- 128 bytes 	32 fpr's	- 256   " 	7  the rest	- 28    " 	and 24 extra bytes for the callee's link area. The last 24 bytes 	for the link area might not be necessary, since it will be taken 	care of by push_arguments(). */
end_comment

begin_define
define|#
directive|define
name|DUMMY_FRAME_SIZE
value|436
end_define

begin_define
define|#
directive|define
name|DUMMY_FRAME_ADDR_SIZE
value|10
end_define

begin_comment
comment|/* Make sure you initialize these in somewhere, in case gdb gives up what it    was debugging and starts debugging something else. FIXMEibm */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dummy_frame_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dummy_frame_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
modifier|*
name|dummy_frame_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|stop_stack_dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* push a dummy frame into stack, save all register. Currently we are saving    only gpr's and fpr's, which is not good enough! FIXMEmgo */
end_comment

begin_function
name|void
name|push_dummy_frame
parameter_list|()
block|{
name|int
name|sp
decl_stmt|,
name|pc
decl_stmt|;
comment|/* stack pointer and link register */
name|int
name|ii
decl_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_frame_count
operator|>=
name|dummy_frame_size
condition|)
block|{
name|dummy_frame_size
operator|+=
name|DUMMY_FRAME_ADDR_SIZE
expr_stmt|;
if|if
condition|(
name|dummy_frame_addr
condition|)
name|dummy_frame_addr
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|xrealloc
argument_list|(
name|dummy_frame_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
operator|*
operator|(
name|dummy_frame_size
operator|)
argument_list|)
expr_stmt|;
else|else
name|dummy_frame_addr
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
operator|*
operator|(
name|dummy_frame_size
operator|)
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|pc
operator|=
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|dummy_frame_addr
index|[
name|dummy_frame_count
operator|++
index|]
operator|=
name|sp
expr_stmt|;
comment|/* Be careful! If the stack pointer is not decremented first, then kernel       thinks he is free to use the space underneath it. And kernel actually       uses that area for IPC purposes when executing ptrace(2) calls. So       before writing register values into the new frame, decrement and update      %sp first in order to secure your frame. */
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
operator|-
name|DUMMY_FRAME_SIZE
argument_list|)
expr_stmt|;
comment|/* gdb relies on the state of current_frame. We'd better update it,      otherwise things like do_registers_info() wouldn't work properly! */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|sp
operator|-
name|DUMMY_FRAME_SIZE
argument_list|,
name|pc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save program counter in link register's space. */
name|write_memory
argument_list|(
name|sp
operator|+
literal|8
argument_list|,
operator|&
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* save all floating point and general purpose registers here. */
comment|/* fpr's, f0..f31 */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|32
condition|;
operator|++
name|ii
control|)
name|write_memory
argument_list|(
name|sp
operator|-
literal|8
operator|-
operator|(
name|ii
operator|*
literal|8
operator|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|31
operator|-
name|ii
operator|+
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* gpr's r0..r31 */
for|for
control|(
name|ii
operator|=
literal|1
init|;
name|ii
operator|<=
literal|32
condition|;
operator|++
name|ii
control|)
name|write_memory
argument_list|(
name|sp
operator|-
literal|256
operator|-
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|32
operator|-
name|ii
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* so far, 32*2 + 32 words = 384 bytes have been written.       7 extra registers in our register set: pc, ps, cnd, lr, cnt, xer, mq */
for|for
control|(
name|ii
operator|=
literal|1
init|;
name|ii
operator|<=
operator|(
name|LAST_SP_REGNUM
operator|-
name|FIRST_SP_REGNUM
operator|+
literal|1
operator|)
condition|;
operator|++
name|ii
control|)
block|{
name|write_memory
argument_list|(
name|sp
operator|-
literal|384
operator|-
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPLAST_REGNUM
operator|+
name|ii
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Save sp or so called back chain right here. */
name|write_memory
argument_list|(
name|sp
operator|-
name|DUMMY_FRAME_SIZE
argument_list|,
operator|&
name|sp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sp
operator|-=
name|DUMMY_FRAME_SIZE
expr_stmt|;
comment|/* And finally, this is the back chain. */
name|write_memory
argument_list|(
name|sp
operator|+
literal|8
argument_list|,
operator|&
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a dummy frame.     In rs6000 when we push a dummy frame, we save all of the registers. This    is usually done before user calls a function explicitly.     After a dummy frame is pushed, some instructions are copied into stack,    and stack pointer is decremented even more.  Since we don't have a frame    pointer to get back to the parent frame of the dummy, we start having    trouble poping it.  Therefore, we keep a dummy frame stack, keeping    addresses of dummy frames as such.  When poping happens and when we    detect that was a dummy frame, we pop it back to its parent by using    dummy frame stack (`dummy_frame_addr' array).   FIXME:  This whole concept is broken.  You should be able to detect a dummy stack frame *on the user's stack itself*.  When you do, then you know the format of that stack frame -- including its saved SP register!  There should *not* be a separate stack in the GDB process that keeps track of these dummy frames!  -- gnu@cygnus.com Aug92  */
end_comment

begin_macro
name|pop_dummy_frame
argument_list|()
end_macro

begin_block
block|{
name|CORE_ADDR
name|sp
decl_stmt|,
name|pc
decl_stmt|;
name|int
name|ii
decl_stmt|;
name|sp
operator|=
name|dummy_frame_addr
index|[
operator|--
name|dummy_frame_count
index|]
expr_stmt|;
comment|/* restore all fpr's. */
for|for
control|(
name|ii
operator|=
literal|1
init|;
name|ii
operator|<=
literal|32
condition|;
operator|++
name|ii
control|)
name|read_memory
argument_list|(
name|sp
operator|-
operator|(
name|ii
operator|*
literal|8
operator|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|32
operator|-
name|ii
operator|+
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* restore all gpr's */
for|for
control|(
name|ii
operator|=
literal|1
init|;
name|ii
operator|<=
literal|32
condition|;
operator|++
name|ii
control|)
block|{
name|read_memory
argument_list|(
name|sp
operator|-
literal|256
operator|-
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|32
operator|-
name|ii
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* restore the rest of the registers. */
for|for
control|(
name|ii
operator|=
literal|1
init|;
name|ii
operator|<=
operator|(
name|LAST_SP_REGNUM
operator|-
name|FIRST_SP_REGNUM
operator|+
literal|1
operator|)
condition|;
operator|++
name|ii
control|)
name|read_memory
argument_list|(
name|sp
operator|-
literal|384
operator|-
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPLAST_REGNUM
operator|+
name|ii
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|sp
operator|-
operator|(
name|DUMMY_FRAME_SIZE
operator|-
literal|8
operator|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* when a dummy frame was being pushed, we had to decrement %sp first, in       order to secure astack space. Thus, saved %sp (or %r1) value, is not the      one we should restore. Change it with the one we need. */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP_REGNUM
argument_list|)
index|]
operator|=
name|sp
expr_stmt|;
comment|/* Now we can restore all registers. */
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|sp
argument_list|,
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* pop the innermost frame, go back to the caller. */
end_comment

begin_function
name|void
name|pop_frame
parameter_list|()
block|{
name|int
name|pc
decl_stmt|,
name|lr
decl_stmt|,
name|sp
decl_stmt|,
name|prev_sp
decl_stmt|;
comment|/* %pc, %lr, %sp */
name|struct
name|aix_framedata
name|fdata
decl_stmt|;
name|FRAME
name|fr
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|int
name|addr
decl_stmt|,
name|ii
decl_stmt|;
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|sp
operator|=
name|FRAME_FP
argument_list|(
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_stack_dummy
operator|&&
name|dummy_frame_count
condition|)
block|{
name|pop_dummy_frame
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* figure out previous %pc value. If the function is frameless, it is       still in the link register, otherwise walk the frames and retrieve the      saved %pc value in the previous frame. */
name|addr
operator|=
name|get_pc_function_start
argument_list|(
name|fr
operator|->
name|pc
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
name|function_frame_info
argument_list|(
name|addr
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|sp
argument_list|,
operator|&
name|prev_sp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdata
operator|.
name|frameless
condition|)
name|lr
operator|=
name|read_register
argument_list|(
name|LR_REGNUM
argument_list|)
expr_stmt|;
else|else
name|read_memory
argument_list|(
name|prev_sp
operator|+
literal|8
argument_list|,
operator|&
name|lr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* reset %pc value. */
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|lr
argument_list|)
expr_stmt|;
comment|/* reset register values if any was saved earlier. */
name|addr
operator|=
name|prev_sp
operator|-
name|fdata
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|fdata
operator|.
name|saved_gpr
operator|!=
operator|-
literal|1
condition|)
for|for
control|(
name|ii
operator|=
name|fdata
operator|.
name|saved_gpr
init|;
name|ii
operator|<=
literal|31
condition|;
operator|++
name|ii
control|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ii
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdata
operator|.
name|saved_fpr
operator|!=
operator|-
literal|1
condition|)
for|for
control|(
name|ii
operator|=
name|fdata
operator|.
name|saved_fpr
init|;
name|ii
operator|<=
literal|31
condition|;
operator|++
name|ii
control|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ii
operator|+
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|8
expr_stmt|;
block|}
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|prev_sp
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|prev_sp
argument_list|,
name|lr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fixup the call sequence of a dummy function, with the real function address.    its argumets will be passed by gdb. */
end_comment

begin_function
name|void
name|fix_call_dummy
parameter_list|(
name|dummyname
parameter_list|,
name|pc
parameter_list|,
name|fun
parameter_list|,
name|nargs
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|dummyname
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|fun
decl_stmt|;
name|int
name|nargs
decl_stmt|;
comment|/* not used */
name|int
name|type
decl_stmt|;
comment|/* not used */
block|{
define|#
directive|define
name|TOC_ADDR_OFFSET
value|20
define|#
directive|define
name|TARGET_ADDR_OFFSET
value|28
name|int
name|ii
decl_stmt|;
name|CORE_ADDR
name|target_addr
decl_stmt|;
name|CORE_ADDR
name|tocvalue
decl_stmt|;
name|target_addr
operator|=
name|fun
expr_stmt|;
name|tocvalue
operator|=
name|find_toc_address
argument_list|(
name|target_addr
argument_list|)
expr_stmt|;
name|ii
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dummyname
operator|+
name|TOC_ADDR_OFFSET
operator|)
expr_stmt|;
name|ii
operator|=
operator|(
name|ii
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|tocvalue
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dummyname
operator|+
name|TOC_ADDR_OFFSET
operator|)
operator|=
name|ii
expr_stmt|;
name|ii
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dummyname
operator|+
name|TOC_ADDR_OFFSET
operator|+
literal|4
operator|)
expr_stmt|;
name|ii
operator|=
operator|(
name|ii
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|tocvalue
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dummyname
operator|+
name|TOC_ADDR_OFFSET
operator|+
literal|4
operator|)
operator|=
name|ii
expr_stmt|;
name|ii
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dummyname
operator|+
name|TARGET_ADDR_OFFSET
operator|)
expr_stmt|;
name|ii
operator|=
operator|(
name|ii
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|target_addr
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dummyname
operator|+
name|TARGET_ADDR_OFFSET
operator|)
operator|=
name|ii
expr_stmt|;
name|ii
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dummyname
operator|+
name|TARGET_ADDR_OFFSET
operator|+
literal|4
operator|)
expr_stmt|;
name|ii
operator|=
operator|(
name|ii
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|target_addr
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dummyname
operator|+
name|TARGET_ADDR_OFFSET
operator|+
literal|4
operator|)
operator|=
name|ii
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return information about a function frame.    in struct aix_frameinfo fdata:     - frameless is TRUE, if function does not save %pc value in its frame.     - offset is the number of bytes used in the frame to save registers.     - saved_gpr is the number of the first saved gpr.     - saved_fpr is the number of the first saved fpr.     - alloca_reg is the number of the register used for alloca() handling.       Otherwise -1.  */
end_comment

begin_function
name|void
name|function_frame_info
parameter_list|(
name|pc
parameter_list|,
name|fdata
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|aix_framedata
modifier|*
name|fdata
decl_stmt|;
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
specifier|register
name|unsigned
name|int
name|op
decl_stmt|;
name|fdata
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|fdata
operator|->
name|saved_gpr
operator|=
name|fdata
operator|->
name|saved_fpr
operator|=
name|fdata
operator|->
name|alloca_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x7c0802a6
condition|)
block|{
comment|/* mflr r0 */
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* else, this is a frameless invocation */
name|fdata
operator|->
name|frameless
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc00003e
operator|)
operator|==
literal|0x7c000026
condition|)
block|{
comment|/* mfcr Rx */
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x48000000
condition|)
block|{
comment|/* bl foo, to save fprs??? */
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* At this point, make sure this is not a trampoline function        (a function that simply calls another functions, and nothing else).        If the next is not a nop, this branch was part of the function        prologue. */
if|if
condition|(
name|op
operator|==
literal|0x4def7b82
operator|||
comment|/* crorc 15, 15, 15 */
name|op
operator|==
literal|0x0
condition|)
return|return;
comment|/* prologue is over */
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xd8010000
condition|)
block|{
comment|/* stfd Rx,NUM(r1) */
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* store floating register double */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xbc010000
condition|)
block|{
comment|/* stm Rx, NUM(r1) */
name|int
name|tmp2
decl_stmt|;
name|fdata
operator|->
name|saved_gpr
operator|=
operator|(
name|op
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|tmp2
operator|=
name|op
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|tmp2
operator|>
literal|0x7fff
condition|)
name|tmp2
operator|=
literal|0xffff0000
operator||
name|tmp2
expr_stmt|;
if|if
condition|(
name|tmp2
operator|<
literal|0
condition|)
block|{
name|tmp2
operator|=
name|tmp2
operator|*
operator|-
literal|1
expr_stmt|;
name|fdata
operator|->
name|saved_fpr
operator|=
operator|(
name|tmp2
operator|-
operator|(
operator|(
literal|32
operator|-
name|fdata
operator|->
name|saved_gpr
operator|)
operator|*
literal|4
operator|)
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|fdata
operator|->
name|saved_fpr
operator|>
literal|0
condition|)
name|fdata
operator|->
name|saved_fpr
operator|=
literal|32
operator|-
name|fdata
operator|->
name|saved_fpr
expr_stmt|;
else|else
name|fdata
operator|->
name|saved_fpr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|fdata
operator|->
name|offset
operator|=
name|tmp2
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
name|tmp
operator|=
name|op
operator|>>
literal|16
operator|)
operator|==
literal|0x9001
operator|)
operator|||
comment|/* st   r0, NUM(r1) */
operator|(
name|tmp
operator|==
literal|0x9421
operator|)
operator|||
comment|/* stu  r1, NUM(r1) */
operator|(
name|op
operator|==
literal|0x93e1fffc
operator|)
condition|)
comment|/* st   r31,-4(r1) */
block|{
comment|/* gcc takes a short cut and uses this instruction to save r31 only. */
if|if
condition|(
name|op
operator|==
literal|0x93e1fffc
condition|)
block|{
if|if
condition|(
name|fdata
operator|->
name|offset
condition|)
comment|/*        fatal ("Unrecognized prolog."); */
name|printf
argument_list|(
literal|"Unrecognized prolog!\n"
argument_list|)
expr_stmt|;
name|fdata
operator|->
name|saved_gpr
operator|=
literal|31
expr_stmt|;
name|fdata
operator|->
name|offset
operator|=
literal|4
expr_stmt|;
block|}
name|pc
operator|+=
literal|4
expr_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|tmp
operator|=
operator|(
name|op
operator|>>
literal|22
operator|)
operator|)
operator|==
literal|0x20f
condition|)
block|{
comment|/* l	r31, ... or */
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* l	r30, ...    */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* store parameters into stack */
while|while
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xd8010000
operator|||
comment|/* stfd Rx,NUM(r1) */
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0x90010000
operator|||
comment|/* st r?, NUM(r1)  */
operator|(
name|op
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0xfc000000
operator|||
comment|/* frsp, fp?, .. */
operator|(
name|op
operator|&
literal|0xd0000000
operator|)
operator|==
literal|0xd0000000
condition|)
comment|/* stfs, fp?, .. */
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* store fpr double */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
literal|0x603f0000
condition|)
comment|/* oril r31, r1, 0x0 */
name|fdata
operator|->
name|alloca_reg
operator|=
literal|31
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass the arguments in either registers, or in the stack. In RS6000, the first    eight words of the argument list (that might be less than eight parameters if    some parameters occupy more than one word) are passed in r3..r11 registers.    float and double parameters are passed in fpr's, in addition to that. Rest of    the parameters if any are passed in user stack. There might be cases in which    half of the parameter is copied into registers, the other half is pushed into    stack.     If the function is returning a structure, then the return address is passed    in r3, then the first 7 words of the parametes can be passed in registers,    starting from r4. */
end_comment

begin_function
name|CORE_ADDR
name|push_arguments
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|sp
parameter_list|,
name|struct_return
parameter_list|,
name|struct_addr
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|,
name|len
decl_stmt|;
name|int
name|argno
decl_stmt|;
comment|/* current argument number */
name|int
name|argbytes
decl_stmt|;
comment|/* current argument byte */
name|char
name|tmp_buffer
index|[
literal|50
index|]
decl_stmt|;
name|value
name|arg
decl_stmt|;
name|int
name|f_argno
init|=
literal|0
decl_stmt|;
comment|/* current floating point argno */
name|CORE_ADDR
name|saved_sp
decl_stmt|,
name|pc
decl_stmt|;
if|if
condition|(
name|dummy_frame_count
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"FATAL ERROR -push_arguments()! frame not found!!\n"
argument_list|)
expr_stmt|;
comment|/* The first eight words of ther arguments are passed in registers. Copy      them appropriately.       If the function is returning a `struct', then the first word (which       will be passed in r3) is used for struct return address. In that      case we should advance one word and start from r4 register to copy       parameters. */
name|ii
operator|=
name|struct_return
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|argno
operator|=
literal|0
operator|,
name|argbytes
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
operator|&&
name|ii
operator|<
literal|8
condition|;
operator|++
name|ii
control|)
block|{
name|arg
operator|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|argno
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
comment|/* floating point arguments are passed in fpr's, as well as gpr's.          There are 13 fpr's reserved for passing parameters. At this point          there is no way we would run out of them. */
if|if
condition|(
name|len
operator|>
literal|8
condition|)
name|printf
argument_list|(
literal|"Fatal Error: a floating point parameter #%d with a size> 8 is found!\n"
argument_list|,
name|argno
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|f_argno
argument_list|)
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|f_argno
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|4
condition|)
block|{
comment|/* Argument takes more than one register. */
while|while
condition|(
name|argbytes
operator|<
name|len
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|)
operator|+
name|argbytes
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
index|]
argument_list|,
operator|(
name|len
operator|-
name|argbytes
operator|)
operator|>
literal|4
condition|?
literal|4
else|:
name|len
operator|-
name|argbytes
argument_list|)
expr_stmt|;
operator|++
name|ii
operator|,
name|argbytes
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|ii
operator|>=
literal|8
condition|)
goto|goto
name|ran_out_of_registers_for_arguments
goto|;
block|}
name|argbytes
operator|=
literal|0
expr_stmt|;
operator|--
name|ii
expr_stmt|;
block|}
else|else
block|{
comment|/* Argument can fit in one register. No problem. */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
operator|++
name|argno
expr_stmt|;
block|}
name|ran_out_of_registers_for_arguments
label|:
comment|/* location for 8 parameters are always reserved. */
name|sp
operator|-=
literal|4
operator|*
literal|8
expr_stmt|;
comment|/* another six words for back chain, TOC register, link register, etc. */
name|sp
operator|-=
literal|24
expr_stmt|;
comment|/* if there are more arguments, allocate space for them in       the stack, then push them starting from the ninth one. */
if|if
condition|(
operator|(
name|argno
operator|<
name|nargs
operator|)
operator|||
name|argbytes
condition|)
block|{
name|int
name|space
init|=
literal|0
decl_stmt|,
name|jj
decl_stmt|;
name|value
name|val
decl_stmt|;
if|if
condition|(
name|argbytes
condition|)
block|{
name|space
operator|+=
operator|(
operator|(
name|len
operator|-
name|argbytes
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
expr_stmt|;
name|jj
operator|=
name|argno
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|jj
operator|=
name|argno
expr_stmt|;
for|for
control|(
init|;
name|jj
operator|<
name|nargs
condition|;
operator|++
name|jj
control|)
block|{
name|val
operator|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|jj
index|]
argument_list|)
expr_stmt|;
name|space
operator|+=
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
expr_stmt|;
block|}
comment|/* add location required for the rest of the parameters */
name|space
operator|=
operator|(
name|space
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
expr_stmt|;
name|sp
operator|-=
name|space
expr_stmt|;
comment|/* This is another instance we need to be concerned about securing our 	stack space. If we write anything underneath %sp (r1), we might conflict 	with the kernel who thinks he is free to use this area. So, update %sp 	first before doing anything else. */
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* if the last argument copied into the registers didn't fit there         completely, push the rest of it into stack. */
if|if
condition|(
name|argbytes
condition|)
block|{
name|write_memory
argument_list|(
name|sp
operator|+
literal|24
operator|+
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|)
operator|+
name|argbytes
argument_list|,
name|len
operator|-
name|argbytes
argument_list|)
expr_stmt|;
operator|++
name|argno
expr_stmt|;
name|ii
operator|+=
operator|(
operator|(
name|len
operator|-
name|argbytes
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
operator|/
literal|4
expr_stmt|;
block|}
comment|/* push the rest of the arguments into stack. */
for|for
control|(
init|;
name|argno
operator|<
name|nargs
condition|;
operator|++
name|argno
control|)
block|{
name|arg
operator|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|argno
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* float types should be passed in fpr's, as well as in the stack. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|f_argno
operator|<
literal|13
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|8
condition|)
name|printf
argument_list|(
literal|"Fatal Error: a floating point parameter #%d with a size> 8 is found!\n"
argument_list|,
name|argno
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|f_argno
argument_list|)
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|f_argno
expr_stmt|;
block|}
name|write_memory
argument_list|(
name|sp
operator|+
literal|24
operator|+
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ii
operator|+=
operator|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
operator|/
literal|4
expr_stmt|;
block|}
block|}
else|else
comment|/* Secure stack areas first, before doing anything else. */
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|saved_sp
operator|=
name|dummy_frame_addr
index|[
name|dummy_frame_count
operator|-
literal|1
index|]
expr_stmt|;
name|read_memory
argument_list|(
name|saved_sp
argument_list|,
name|tmp_buffer
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|tmp_buffer
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
operator|&
name|saved_sp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* set back chain properly */
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* a given return value in `regbuf' with a type `valtype', extract and copy its    value into `valbuf' */
end_comment

begin_function
name|void
name|extract_return_value
parameter_list|(
name|valtype
parameter_list|,
name|regbuf
parameter_list|,
name|valbuf
parameter_list|)
name|struct
name|type
modifier|*
name|valtype
decl_stmt|;
name|char
name|regbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|char
modifier|*
name|valbuf
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|double
name|dd
decl_stmt|;
name|float
name|ff
decl_stmt|;
comment|/* floats and doubles are returned in fpr1. fpr's have a size of 8 bytes.        We need to truncate the return value into float size (4 byte) if        necessary. */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|>
literal|4
condition|)
comment|/* this is a double */
name|bcopy
argument_list|(
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
argument_list|)
index|]
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* float */
name|bcopy
argument_list|(
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
argument_list|)
index|]
argument_list|,
operator|&
name|dd
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ff
operator|=
operator|(
name|float
operator|)
name|dd
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ff
argument_list|,
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* return value is copied starting from r3. */
name|bcopy
argument_list|(
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
literal|3
argument_list|)
index|]
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* keep structure return address in this variable.    FIXME:  This is a horrid kludge which should not be allowed to continue    living.  This only allows a single nested call to a structure-returning    function.  Come on, guys!  -- gnu@cygnus.com, Aug 92  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|rs6000_struct_return_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Throw away this debugging code. FIXMEmgo. */
end_comment

begin_function
name|void
name|print_frame
parameter_list|(
name|fram
parameter_list|)
name|int
name|fram
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|,
name|val
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|40
condition|;
operator|++
name|ii
control|)
block|{
if|if
condition|(
operator|(
name|ii
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|val
operator|=
name|read_memory_integer
argument_list|(
name|fram
operator|+
name|ii
operator|*
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x\t"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indirect function calls use a piece of trampoline code to do context    switching, i.e. to set the new TOC table. Skip such code if we are on    its first instruction (as when we have single-stepped to here).     Result is desired PC to step until, or NULL if we are not in    trampoline code.  */
end_comment

begin_function
name|CORE_ADDR
name|skip_trampoline_code
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|ii
decl_stmt|,
name|op
decl_stmt|;
specifier|static
name|unsigned
name|trampoline_code
index|[]
init|=
block|{
literal|0x800b0000
block|,
comment|/*     l   r0,0x0(r11)	*/
literal|0x90410014
block|,
comment|/*    st   r2,0x14(r1)	*/
literal|0x7c0903a6
block|,
comment|/* mtctr   r0		*/
literal|0x804b0004
block|,
comment|/*     l   r2,0x4(r11)	*/
literal|0x816b0008
block|,
comment|/*     l  r11,0x8(r11)	*/
literal|0x4e800420
block|,
comment|/*  bctr		*/
literal|0x4e800020
block|,
comment|/*    br		*/
literal|0
block|}
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|trampoline_code
index|[
name|ii
index|]
condition|;
operator|++
name|ii
control|)
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|trampoline_code
index|[
name|ii
index|]
condition|)
return|return
name|NULL
return|;
block|}
name|ii
operator|=
name|read_register
argument_list|(
literal|11
argument_list|)
expr_stmt|;
comment|/* r11 holds destination addr	*/
name|pc
operator|=
name|read_memory_integer
argument_list|(
name|ii
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* (r11) value			*/
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Determines whether the function FI has a frame on the stack or not.    Called from the FRAMELESS_FUNCTION_INVOCATION macro in tm.h.  */
end_comment

begin_function
name|int
name|frameless_function_invocation
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|CORE_ADDR
name|func_start
decl_stmt|;
name|struct
name|aix_framedata
name|fdata
decl_stmt|;
name|func_start
operator|=
name|get_pc_function_start
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
comment|/* If we failed to find the start of the function, it is a mistake      to inspect the instructions. */
if|if
condition|(
operator|!
name|func_start
condition|)
return|return
literal|0
return|;
name|function_frame_info
argument_list|(
name|func_start
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
return|return
name|fdata
operator|.
name|frameless
return|;
block|}
end_function

begin_comment
comment|/* If saved registers of frame FI are not known yet, read and cache them.&FDATAP contains aix_framedata; TDATAP can be NULL,    in which case the framedata are read.  */
end_comment

begin_function
specifier|static
name|void
name|frame_get_cache_fsr
parameter_list|(
name|fi
parameter_list|,
name|fdatap
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|aix_framedata
modifier|*
name|fdatap
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|;
name|CORE_ADDR
name|frame_addr
decl_stmt|;
name|struct
name|aix_framedata
name|work_fdata
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|cache_fsr
condition|)
return|return;
if|if
condition|(
name|fdatap
operator|==
name|NULL
condition|)
block|{
name|fdatap
operator|=
operator|&
name|work_fdata
expr_stmt|;
name|function_frame_info
argument_list|(
name|get_pc_function_start
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
argument_list|,
name|fdatap
argument_list|)
expr_stmt|;
block|}
name|fi
operator|->
name|cache_fsr
operator|=
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fi
operator|->
name|cache_fsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|prev
operator|&&
name|fi
operator|->
name|prev
operator|->
name|frame
condition|)
name|frame_addr
operator|=
name|fi
operator|->
name|prev
operator|->
name|frame
expr_stmt|;
else|else
name|frame_addr
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* if != -1, fdatap->saved_fpr is the smallest number of saved_fpr.      All fpr's from saved_fpr to fp31 are saved right underneath caller      stack pointer, starting from fp31 first. */
if|if
condition|(
name|fdatap
operator|->
name|saved_fpr
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|ii
operator|=
literal|31
init|;
name|ii
operator|>=
name|fdatap
operator|->
name|saved_fpr
condition|;
operator|--
name|ii
control|)
name|fi
operator|->
name|cache_fsr
operator|->
name|regs
index|[
name|FP0_REGNUM
operator|+
name|ii
index|]
operator|=
name|frame_addr
operator|-
operator|(
operator|(
literal|32
operator|-
name|ii
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|frame_addr
operator|-=
operator|(
literal|32
operator|-
name|fdatap
operator|->
name|saved_fpr
operator|)
operator|*
literal|8
expr_stmt|;
block|}
comment|/* if != -1, fdatap->saved_gpr is the smallest number of saved_gpr.      All gpr's from saved_gpr to gpr31 are saved right under saved fprs,      starting from r31 first. */
if|if
condition|(
name|fdatap
operator|->
name|saved_gpr
operator|>=
literal|0
condition|)
for|for
control|(
name|ii
operator|=
literal|31
init|;
name|ii
operator|>=
name|fdatap
operator|->
name|saved_gpr
condition|;
operator|--
name|ii
control|)
name|fi
operator|->
name|cache_fsr
operator|->
name|regs
index|[
name|ii
index|]
operator|=
name|frame_addr
operator|-
operator|(
operator|(
literal|32
operator|-
name|ii
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the address of a frame. This is the inital %sp value when the frame    was first allocated. For functions calling alloca(), it might be saved in    an alloca register. */
end_comment

begin_function
name|CORE_ADDR
name|frame_initial_stack_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|CORE_ADDR
name|tmpaddr
decl_stmt|;
name|struct
name|aix_framedata
name|fdata
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|callee_fi
decl_stmt|;
comment|/* if the initial stack pointer (frame address) of this frame is known,      just return it. */
if|if
condition|(
name|fi
operator|->
name|initial_sp
condition|)
return|return
name|fi
operator|->
name|initial_sp
return|;
comment|/* find out if this function is using an alloca register.. */
name|function_frame_info
argument_list|(
name|get_pc_function_start
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
comment|/* if saved registers of this frame are not known yet, read and cache them. */
if|if
condition|(
operator|!
name|fi
operator|->
name|cache_fsr
condition|)
name|frame_get_cache_fsr
argument_list|(
name|fi
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
comment|/* If no alloca register used, then fi->frame is the value of the %sp for      this frame, and it is good enough. */
if|if
condition|(
name|fdata
operator|.
name|alloca_reg
operator|<
literal|0
condition|)
block|{
name|fi
operator|->
name|initial_sp
operator|=
name|fi
operator|->
name|frame
expr_stmt|;
return|return
name|fi
operator|->
name|initial_sp
return|;
block|}
comment|/* This function has an alloca register. If this is the top-most frame      (with the lowest address), the value in alloca register is good. */
if|if
condition|(
operator|!
name|fi
operator|->
name|next
condition|)
return|return
name|fi
operator|->
name|initial_sp
operator|=
name|read_register
argument_list|(
name|fdata
operator|.
name|alloca_reg
argument_list|)
return|;
comment|/* Otherwise, this is a caller frame. Callee has usually already saved      registers, but there are exceptions (such as when the callee      has no parameters). Find the address in which caller's alloca      register is saved. */
for|for
control|(
name|callee_fi
operator|=
name|fi
operator|->
name|next
init|;
name|callee_fi
condition|;
name|callee_fi
operator|=
name|callee_fi
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|callee_fi
operator|->
name|cache_fsr
condition|)
name|frame_get_cache_fsr
argument_list|(
name|fi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* this is the address in which alloca register is saved. */
name|tmpaddr
operator|=
name|callee_fi
operator|->
name|cache_fsr
operator|->
name|regs
index|[
name|fdata
operator|.
name|alloca_reg
index|]
expr_stmt|;
if|if
condition|(
name|tmpaddr
condition|)
block|{
name|fi
operator|->
name|initial_sp
operator|=
name|read_memory_integer
argument_list|(
name|tmpaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|initial_sp
return|;
block|}
comment|/* Go look into deeper levels of the frame chain to see if any one of        the callees has saved alloca register. */
block|}
comment|/* If alloca register was not saved, by the callee (or any of its callees)      then the value in the register is still good. */
return|return
name|fi
operator|->
name|initial_sp
operator|=
name|read_register
argument_list|(
name|fdata
operator|.
name|alloca_reg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* xcoff_relocate_symtab -	hook for symbol table relocation.    also reads shared libraries.. */
end_comment

begin_macro
name|xcoff_relocate_symtab
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|MAX_LOAD_SEGS
value|64
comment|/* maximum number of load segments */
name|struct
name|ld_info
modifier|*
name|ldi
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|ldi
operator|=
operator|(
name|void
operator|*
operator|)
name|alloca
argument_list|(
name|MAX_LOAD_SEGS
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ldi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* According to my humble theory, AIX has some timing problems and        when the user stack grows, kernel doesn't update stack info in time        and ptrace calls step on user stack. That is why we sleep here a little,        and give kernel to update its internals. */
name|usleep
argument_list|(
literal|36000
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_LDINFO
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|ldi
argument_list|,
name|MAX_LOAD_SEGS
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ldi
argument_list|)
argument_list|,
name|ldi
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"ptrace ldinfo"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|vmap_ldinfo
argument_list|(
name|ldi
argument_list|)
expr_stmt|;
do|do
block|{
name|add_text_to_loadinfo
argument_list|(
name|ldi
operator|->
name|ldinfo_textorg
argument_list|,
name|ldi
operator|->
name|ldinfo_dataorg
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ldi
operator|->
name|ldinfo_next
operator|&&
operator|(
name|ldi
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ldi
operator|->
name|ldinfo_next
operator|+
operator|(
name|char
operator|*
operator|)
name|ldi
operator|)
operator|)
condition|)
do|;
if|#
directive|if
literal|0
comment|/* Now that we've jumbled things around, re-sort them.  */
block|sort_minimal_symbols ();
endif|#
directive|endif
comment|/* relocate the exec and core sections as well. */
name|vmap_exec
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Keep an array of load segment information and their TOC table addresses.    This info will be useful when calling a shared library function by hand. */
end_comment

begin_struct
struct|struct
name|loadinfo
block|{
name|CORE_ADDR
name|textorg
decl_stmt|,
name|dataorg
decl_stmt|;
name|unsigned
name|long
name|toc_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LOADINFOLEN
value|10
end_define

begin_comment
comment|/* FIXME Warning -- loadinfotextindex is used for a nefarious purpose by    tm-rs6000.h.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|loadinfo
modifier|*
name|loadinfo
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loadinfolen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loadinfotocindex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loadinfotextindex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xcoff_init_loadinfo
parameter_list|()
block|{
name|loadinfotocindex
operator|=
literal|0
expr_stmt|;
name|loadinfotextindex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|loadinfolen
operator|==
literal|0
condition|)
block|{
name|loadinfo
operator|=
operator|(
expr|struct
name|loadinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|loadinfo
argument_list|)
operator|*
name|LOADINFOLEN
argument_list|)
expr_stmt|;
name|loadinfolen
operator|=
name|LOADINFOLEN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FIXME -- this is never called!  */
end_comment

begin_function
name|void
name|free_loadinfo
parameter_list|()
block|{
if|if
condition|(
name|loadinfo
condition|)
name|free
argument_list|(
name|loadinfo
argument_list|)
expr_stmt|;
name|loadinfo
operator|=
name|NULL
expr_stmt|;
name|loadinfolen
operator|=
literal|0
expr_stmt|;
name|loadinfotocindex
operator|=
literal|0
expr_stmt|;
name|loadinfotextindex
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this is called from xcoffread.c */
end_comment

begin_function
name|void
name|xcoff_add_toc_to_loadinfo
parameter_list|(
name|unsigned
name|long
name|tocoff
parameter_list|)
block|{
while|while
condition|(
name|loadinfotocindex
operator|>=
name|loadinfolen
condition|)
block|{
name|loadinfolen
operator|+=
name|LOADINFOLEN
expr_stmt|;
name|loadinfo
operator|=
operator|(
expr|struct
name|loadinfo
operator|*
operator|)
name|xrealloc
argument_list|(
name|loadinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loadinfo
argument_list|)
operator|*
name|loadinfolen
argument_list|)
expr_stmt|;
block|}
name|loadinfo
index|[
name|loadinfotocindex
operator|++
index|]
operator|.
name|toc_offset
operator|=
name|tocoff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_text_to_loadinfo
parameter_list|(
name|textaddr
parameter_list|,
name|dataaddr
parameter_list|)
name|CORE_ADDR
name|textaddr
decl_stmt|;
name|CORE_ADDR
name|dataaddr
decl_stmt|;
block|{
while|while
condition|(
name|loadinfotextindex
operator|>=
name|loadinfolen
condition|)
block|{
name|loadinfolen
operator|+=
name|LOADINFOLEN
expr_stmt|;
name|loadinfo
operator|=
operator|(
expr|struct
name|loadinfo
operator|*
operator|)
name|xrealloc
argument_list|(
name|loadinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|loadinfo
argument_list|)
operator|*
name|loadinfolen
argument_list|)
expr_stmt|;
block|}
name|loadinfo
index|[
name|loadinfotextindex
index|]
operator|.
name|textorg
operator|=
name|textaddr
expr_stmt|;
name|loadinfo
index|[
name|loadinfotextindex
index|]
operator|.
name|dataorg
operator|=
name|dataaddr
expr_stmt|;
operator|++
name|loadinfotextindex
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME:  This assumes that the "textorg" and "dataorg" elements    of a member of this array are correlated with the "toc_offset"    element of the same member.  But they are sequentially assigned in wildly    different places, and probably there is no correlation.  FIXME!  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_toc_address
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|,
name|toc_entry
decl_stmt|,
name|tocbase
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|loadinfotextindex
condition|;
operator|++
name|ii
control|)
if|if
condition|(
name|pc
operator|>
name|loadinfo
index|[
name|ii
index|]
operator|.
name|textorg
operator|&&
name|loadinfo
index|[
name|ii
index|]
operator|.
name|textorg
operator|>
name|tocbase
condition|)
block|{
name|toc_entry
operator|=
name|ii
expr_stmt|;
name|tocbase
operator|=
name|loadinfo
index|[
name|ii
index|]
operator|.
name|textorg
expr_stmt|;
block|}
return|return
name|loadinfo
index|[
name|toc_entry
index|]
operator|.
name|dataorg
operator|+
name|loadinfo
index|[
name|toc_entry
index|]
operator|.
name|toc_offset
return|;
block|}
end_function

end_unit

