begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB routines for manipulating the minimal symbol tables.    Copyright 1992 Free Software Foundation, Inc.    Contributed by Cygnus Support, using pieces from other GDB modules.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains support routines for creating, manipulating, and    destroying minimal symbol tables.     Minimal symbol tables are used to hold some very basic information about    all defined global symbols (text, data, bss, abs, etc).  The only two    required pieces of information are the symbol's name and the address    associated with that symbol.     In many cases, even if a file was compiled with no special options for    debugging at all, as long as was not stripped it will contain sufficient    information to build useful minimal symbol tables using this structure.        Even when a file contains enough debugging information to build a full    symbol table, these minimal symbols are still useful for quickly mapping    between names and addresses, and vice versa.  They are also sometimes used    to figure out what full symbol table entries need to be read in. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* Accumulate the minimal symbols for each objfile in bunches of BUNCH_SIZE.    At the end, copy them all into one newly allocated location on an objfile's    symbol obstack.  */
end_comment

begin_define
define|#
directive|define
name|BUNCH_SIZE
value|127
end_define

begin_struct
struct|struct
name|msym_bunch
block|{
name|struct
name|msym_bunch
modifier|*
name|next
decl_stmt|;
name|struct
name|minimal_symbol
name|contents
index|[
name|BUNCH_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bunch currently being filled up.    The next field points to chain of filled bunches.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msym_bunch
modifier|*
name|msym_bunch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of slots filled in current bunch.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msym_bunch_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of minimal symbols recorded so far for the objfile.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|compare_minimal_symbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compact_minimal_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|minimal_symbol
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look through all the current minimal symbol tables and find the first    minimal symbol that matches NAME.  If OBJF is non-NULL, it specifies a    particular objfile and the search is limited to that objfile.  Returns    a pointer to the minimal symbol that matches, or NULL if no match is found.     Note:  One instance where there may be duplicate minimal symbols with    the same name is when the symbol tables for a shared library and the    symbol tables for an executable contain global symbols with the same    names (the dynamic linker deals with the duplication). */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|lookup_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|objf
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objf
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|found_symbol
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|IBM6000_TARGET
name|struct
name|minimal_symbol
modifier|*
name|trampoline_symbol
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
operator|&&
name|found_symbol
operator|==
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|objf
operator|==
name|NULL
operator|||
name|objf
operator|==
name|objfile
condition|)
block|{
for|for
control|(
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
init|;
name|msymbol
operator|!=
name|NULL
operator|&&
name|msymbol
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|found_symbol
operator|==
name|NULL
condition|;
name|msymbol
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|msymbol
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IBM6000_TARGET
comment|/* I *think* all platforms using shared libraries (and trampoline code)  * will suffer this problem. Consider a case where there are 5 shared  * libraries, each referencing `foo' with a trampoline entry. When someone  * wants to put a breakpoint on `foo' and the only info we have is minimal  * symbol vector, we want to use the real `foo', rather than one of those  * trampoline entries. MGO */
comment|/* If a trampoline symbol is found, we prefer to keep looking 	     for the *real* symbol. If the actual symbol not found, 	     then we'll use the trampoline entry. Sorry for the machine 	     dependent code here, but I hope this will benefit other 	     platforms as well. For trampoline entries, we used mst_unknown 	     earlier. Perhaps we should define a `mst_trampoline' type?? */
if|if
condition|(
name|msymbol
operator|->
name|type
operator|!=
name|mst_unknown
condition|)
name|found_symbol
operator|=
name|msymbol
expr_stmt|;
elseif|else
if|if
condition|(
name|msymbol
operator|->
name|type
operator|==
name|mst_unknown
operator|&&
operator|!
name|trampoline_symbol
condition|)
name|trampoline_symbol
operator|=
name|msymbol
expr_stmt|;
else|#
directive|else
name|found_symbol
operator|=
name|msymbol
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|IBM6000_TARGET
return|return
name|found_symbol
condition|?
name|found_symbol
else|:
name|trampoline_symbol
return|;
endif|#
directive|endif
return|return
operator|(
name|found_symbol
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search through the minimal symbol table for each objfile and find the    symbol whose address is the largest address that is still less than or    equal to PC.  Returns a pointer to the minimal symbol if such a symbol    is found, or NULL if PC is not in a suitable range.  Note that we need    to look through ALL the minimal symbol tables before deciding on the    symbol that comes closest to the specified PC. */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|lookup_minimal_symbol_by_pc
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|int
name|lo
decl_stmt|;
specifier|register
name|int
name|hi
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|best_symbol
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
comment|/* If this objfile has a minimal symbol table, go search it using 	 a binary search.  Note that a minimal symbol table always consists 	 of at least two symbols, a "real" symbol and the terminating 	 "null symbol".  If there are no real symbols, then there is no 	 minimal symbol table at all. */
if|if
condition|(
operator|(
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|objfile
operator|->
name|minimal_symbol_count
operator|-
literal|2
expr_stmt|;
comment|/* This code assumes that the minimal symbols are sorted by 	     ascending address values.  If the pc value is greater than or 	     equal to the first symbol's address, then some symbol in this 	     minimal symbol table is a suitable candidate for being the 	     "best" symbol.  This includes the last real symbol, for cases 	     where the pc value is larger than any address in this vector.  	     By iterating until the address associated with the current 	     hi index (the endpoint of the test interval) is less than 	     or equal to the desired pc value, we accomplish two things: 	     (1) the case where the pc value is larger than any minimal 	     symbol address is trivially solved, (2) the address associated 	     with the hi index is always the one we want when the interation 	     terminates.  In essence, we are iterating the test interval 	     down until the pc value is pushed out of it from the high end.  	     Warning: this code is trickier than it would appear at first. */
comment|/* Should also requires that pc is<= end of objfile.  FIXME! */
if|if
condition|(
name|pc
operator|>=
name|msymbol
index|[
name|lo
index|]
operator|.
name|address
condition|)
block|{
while|while
condition|(
name|msymbol
index|[
name|hi
index|]
operator|.
name|address
operator|>
name|pc
condition|)
block|{
comment|/* pc is still strictly less than highest address */
comment|/* Note "new" will always be>= lo */
name|new
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
index|[
name|new
index|]
operator|.
name|address
operator|>=
name|pc
operator|)
operator|||
operator|(
name|lo
operator|==
name|new
operator|)
condition|)
block|{
name|hi
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|lo
operator|=
name|new
expr_stmt|;
block|}
block|}
comment|/* The minimal symbol indexed by hi now is the best one in this 		 objfile's minimal symbol table.  See if it is the best one 		 overall. */
if|if
condition|(
operator|(
name|best_symbol
operator|==
name|NULL
operator|)
operator|||
operator|(
name|best_symbol
operator|->
name|address
operator|<
name|msymbol
index|[
name|hi
index|]
operator|.
name|address
operator|)
condition|)
block|{
name|best_symbol
operator|=
operator|&
name|msymbol
index|[
name|hi
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|best_symbol
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Prepare to start collecting minimal symbols.  Note that presetting    msym_bunch_index to BUNCH_SIZE causes the first call to save a minimal    symbol to allocate the memory for the first bunch. */
end_comment

begin_function
name|void
name|init_minimal_symbol_collection
parameter_list|()
block|{
name|msym_count
operator|=
literal|0
expr_stmt|;
name|msym_bunch
operator|=
name|NULL
expr_stmt|;
name|msym_bunch_index
operator|=
name|BUNCH_SIZE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prim_record_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|ms_type
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
block|{
specifier|register
name|struct
name|msym_bunch
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|msym_bunch_index
operator|==
name|BUNCH_SIZE
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|msym_bunch
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msym_bunch
argument_list|)
argument_list|)
expr_stmt|;
name|msym_bunch_index
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|msym_bunch
expr_stmt|;
name|msym_bunch
operator|=
name|new
expr_stmt|;
block|}
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|type
operator|=
name|ms_type
expr_stmt|;
name|msym_bunch_index
operator|++
expr_stmt|;
name|msym_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prim_record_minimal_symbol_and_info
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|ms_type
parameter_list|,
name|info
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
block|{
specifier|register
name|struct
name|msym_bunch
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|msym_bunch_index
operator|==
name|BUNCH_SIZE
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|msym_bunch
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msym_bunch
argument_list|)
argument_list|)
expr_stmt|;
name|msym_bunch_index
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|msym_bunch
expr_stmt|;
name|msym_bunch
operator|=
name|new
expr_stmt|;
block|}
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|type
operator|=
name|ms_type
expr_stmt|;
comment|/* FIXME:  This info, if it remains, needs its own field.  */
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
operator|.
name|info
operator|=
name|info
expr_stmt|;
comment|/* FIXME! */
name|msym_bunch_index
operator|++
expr_stmt|;
name|msym_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare two minimal symbols by address and return a signed result based    on unsigned comparisons, so that we sort into unsigned numeric order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_minimal_symbols
parameter_list|(
name|fn1p
parameter_list|,
name|fn2p
parameter_list|)
specifier|const
name|PTR
name|fn1p
decl_stmt|;
specifier|const
name|PTR
name|fn2p
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|minimal_symbol
modifier|*
name|fn1
decl_stmt|;
specifier|register
specifier|const
name|struct
name|minimal_symbol
modifier|*
name|fn2
decl_stmt|;
name|fn1
operator|=
operator|(
specifier|const
expr|struct
name|minimal_symbol
operator|*
operator|)
name|fn1p
expr_stmt|;
name|fn2
operator|=
operator|(
specifier|const
expr|struct
name|minimal_symbol
operator|*
operator|)
name|fn2p
expr_stmt|;
if|if
condition|(
name|fn1
operator|->
name|address
operator|<
name|fn2
operator|->
name|address
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|fn1
operator|->
name|address
operator|>
name|fn2
operator|->
name|address
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Discard the currently collected minimal symbols, if any.  If we wish    to save them for later use, we must have already copied them somewhere    else before calling this function.     FIXME:  We could allocate the minimal symbol bunches on their own    obstack and then simply blow the obstack away when we are done with    it.  Is it worth the extra trouble though? */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|discard_minimal_symbols
parameter_list|(
name|foo
parameter_list|)
name|int
name|foo
decl_stmt|;
block|{
specifier|register
name|struct
name|msym_bunch
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|msym_bunch
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|msym_bunch
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|msym_bunch
argument_list|)
expr_stmt|;
name|msym_bunch
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compact duplicate entries out of a minimal symbol table by walking    through the table and compacting out entries with duplicate addresses    and matching names.  Return the number of entries remaining.     On entry, the table resides between msymbol[0] and msymbol[mcount].    On exit, it resides between msymbol[0] and msymbol[result_count].     When files contain multiple sources of symbol information, it is    possible for the minimal symbol table to contain many duplicate entries.    As an example, SVR4 systems use ELF formatted object files, which    usually contain at least two different types of symbol tables (a    standard ELF one and a smaller dynamic linking table), as well as    DWARF debugging information for files compiled with -g.     Without compacting, the minimal symbol table for gdb itself contains    over a 1000 duplicates, about a third of the total table size.  Aside    from the potential trap of not noticing that two successive entries    identify the same location, this duplication impacts the time required    to linearly scan the table, which is done in a number of places.  So we    just do one linear scan here and toss out the duplicates.     Note that we are not concerned here about recovering the space that    is potentially freed up, because the strings themselves are allocated    on the symbol_obstack, and will get automatically freed when the symbol    table is freed.  The caller can free up the unused minimal symbols at    the end of the compacted region if their allocation strategy allows it.     Also note we only go up to the next to last entry within the loop    and then copy the last entry explicitly after the loop terminates.     Since the different sources of information for each symbol may    have different levels of "completeness", we may have duplicates    that have one entry with type "mst_unknown" and the other with a    known type.  So if the one we are leaving alone has type mst_unknown,    overwrite its type with the type from the one we are compacting out.  */
end_comment

begin_function
specifier|static
name|int
name|compact_minimal_symbols
parameter_list|(
name|msymbol
parameter_list|,
name|mcount
parameter_list|)
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|int
name|mcount
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|copyfrom
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|copyto
decl_stmt|;
if|if
condition|(
name|mcount
operator|>
literal|0
condition|)
block|{
name|copyfrom
operator|=
name|copyto
operator|=
name|msymbol
expr_stmt|;
while|while
condition|(
name|copyfrom
operator|<
name|msymbol
operator|+
name|mcount
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|copyfrom
operator|->
name|address
operator|==
operator|(
name|copyfrom
operator|+
literal|1
operator|)
operator|->
name|address
operator|&&
operator|(
name|strcmp
argument_list|(
name|copyfrom
operator|->
name|name
argument_list|,
operator|(
name|copyfrom
operator|+
literal|1
operator|)
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|copyfrom
operator|+
literal|1
operator|)
operator|->
name|type
operator|==
name|mst_unknown
condition|)
block|{
operator|(
name|copyfrom
operator|+
literal|1
operator|)
operator|->
name|type
operator|=
name|copyfrom
operator|->
name|type
expr_stmt|;
block|}
name|copyfrom
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|copyto
operator|++
operator|=
operator|*
name|copyfrom
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|copyto
operator|++
operator|=
operator|*
name|copyfrom
operator|++
expr_stmt|;
name|mcount
operator|=
name|copyto
operator|-
name|msymbol
expr_stmt|;
block|}
return|return
operator|(
name|mcount
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add the minimal symbols in the existing bunches to the objfile's    official minimal symbol table.  99% of the time, this adds the    bunches to NO existing symbols.  Once in a while for shared    libraries, we add symbols (e.g. common symbols) to an existing    objfile.  */
end_comment

begin_function
name|void
name|install_minimal_symbols
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|int
name|bindex
decl_stmt|;
specifier|register
name|int
name|mcount
decl_stmt|;
specifier|register
name|struct
name|msym_bunch
modifier|*
name|bunch
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbols
decl_stmt|;
name|int
name|alloc_count
decl_stmt|;
if|if
condition|(
name|msym_count
operator|>
literal|0
condition|)
block|{
comment|/* Allocate enough space in the obstack, into which we will gather the 	 bunches of new and existing minimal symbols, sort them, and then 	 compact out the duplicate entries.  Once we have a final table, 	 we will give back the excess space.  */
name|alloc_count
operator|=
name|msym_count
operator|+
name|objfile
operator|->
name|minimal_symbol_count
operator|+
literal|1
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|alloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|msymbols
operator|=
operator|(
expr|struct
name|minimal_symbol
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* Copy in the existing minimal symbols, if there are any.  */
if|if
condition|(
name|objfile
operator|->
name|minimal_symbol_count
condition|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msymbols
argument_list|,
operator|(
name|char
operator|*
operator|)
name|objfile
operator|->
name|msymbols
argument_list|,
name|objfile
operator|->
name|minimal_symbol_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk through the list of minimal symbol bunches, adding each symbol 	 to the new contiguous array of symbols.  Note that we start with the 	 current, possibly partially filled bunch (thus we use the current 	 msym_bunch_index for the first bunch we copy over), and thereafter 	 each bunch is full. */
name|mcount
operator|=
name|objfile
operator|->
name|minimal_symbol_count
expr_stmt|;
for|for
control|(
name|bunch
operator|=
name|msym_bunch
init|;
name|bunch
operator|!=
name|NULL
condition|;
name|bunch
operator|=
name|bunch
operator|->
name|next
control|)
block|{
for|for
control|(
name|bindex
operator|=
literal|0
init|;
name|bindex
operator|<
name|msym_bunch_index
condition|;
name|bindex
operator|++
operator|,
name|mcount
operator|++
control|)
block|{
name|msymbols
index|[
name|mcount
index|]
operator|=
name|bunch
operator|->
name|contents
index|[
name|bindex
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
if|if
condition|(
name|msymbols
index|[
name|mcount
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
name|msymbols
index|[
name|mcount
index|]
operator|.
name|name
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SOME_NAMES_HAVE_DOT
if|if
condition|(
name|msymbols
index|[
name|mcount
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|msymbols
index|[
name|mcount
index|]
operator|.
name|name
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|msym_bunch_index
operator|=
name|BUNCH_SIZE
expr_stmt|;
block|}
comment|/* Sort the minimal symbols by address.  */
name|qsort
argument_list|(
name|msymbols
argument_list|,
name|mcount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|,
name|compare_minimal_symbols
argument_list|)
expr_stmt|;
comment|/* Compact out any duplicates, and free up whatever space we are 	 no longer using.  */
name|mcount
operator|=
name|compact_minimal_symbols
argument_list|(
name|msymbols
argument_list|,
name|mcount
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
operator|(
name|mcount
operator|+
literal|1
operator|-
name|alloc_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|msymbols
operator|=
operator|(
expr|struct
name|minimal_symbol
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* We also terminate the minimal symbol table 	 with a "null symbol", which is *not* included in the size of 	 the table.  This makes it easier to find the end of the table 	 when we are handed a pointer to some symbol in the middle of it.          Zero out the fields in the "null symbol" allocated at the end 	 of the array.  Note that the symbol count does *not* include 	 this null symbol, which is why it is indexed by mcount and not 	 mcount-1. */
name|msymbols
index|[
name|mcount
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|msymbols
index|[
name|mcount
index|]
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|msymbols
index|[
name|mcount
index|]
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
name|msymbols
index|[
name|mcount
index|]
operator|.
name|type
operator|=
name|mst_unknown
expr_stmt|;
comment|/* Attach the minimal symbol table to the specified objfile. 	 The strings themselves are also located in the symbol_obstack 	 of this objfile.  */
name|objfile
operator|->
name|minimal_symbol_count
operator|=
name|mcount
expr_stmt|;
name|objfile
operator|->
name|msymbols
operator|=
name|msymbols
expr_stmt|;
block|}
block|}
end_function

end_unit

