begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  * Copyright 1990, 1992 Free Software Foundation, Inc.  *  * This code was donated by Intel Corp.  *  * Intel hereby grants you permission to copy, modify, and   * distribute this software and its documentation.  Intel grants  * this permission provided that the above copyright notice   * appears in all copies and that both the copyright notice and  * this permission notice appear in supporting documentation.  In  * addition, Intel grants this permission provided that you  * prominently mark as not part of the original any modifications  * made to this software or documentation, and that the name of   * Intel Corporation not be used in advertising or publicity   * pertaining to distribution of the software or the documentation   * without specific, written prior permission.    *  * Intel Corporation does not warrant, guarantee or make any   * representations regarding the use of, or the results of the use  * of, the software and documentation in terms of correctness,   * accuracy, reliability, currentness, or otherwise; and you rely  * on the software, documentation and results solely at your own risk.  *****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"Id: nindy.c,v 1.1.1.1 1991/03/28 16:20:57 rich Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  *  *	 		NINDY INTERFACE ROUTINES  *  * The routines in this file define and implement an interface between code  * (such as a high-level debugger) running on a remote host and the NINDY  * ROM monitor on an i960 board.  These routines are to be linked with   * and called by the host code.  *  * These routines handle both the formatting/transferring of commands to NINDY  * and the receipt/formatting of data returned in response to them.  The  * actual transfer protocol is hidden from the host programmer within them.  * For a full description of the lowest level NINDY/host transfer protocol,  * see the block header of the file gdb.c, in the NINDY source code.  *  * The caller of these routines should be aware that:  *  * (1) ninConnect() should be called to open communications with the  *     remote NINDY board before any of the other routines are invoked.  *  * (2) almost all interactions are driven by the host: nindy sends information  *     in response to host commands.  *  * (3) the lone exception to (2) is the single character DLE (^P, 0x10).  *     Receipt of a DLE from NINDY indicates that the application program  *     running under NINDY has stopped execution and that NINDY is now  *     available to talk to the host (all other communication received after  *     the application has been started should be presumed to come from the  *     application and should be passed on by the host to stdout).  *  * (4) the reason the application program stopped can be determined with the  *     ninStopWhy() function.  There are three classes of stop reasons:  *  *	(a) the application has terminated execution.  *	    The host should take appropriate action.  *  *	(b) the application had a fault or trace event.  *	    The host should take appropriate action.  *  *	(c) the application wishes to make a service request (srq) of the host;  *	    e.g., to open/close a file, read/write a file, etc.  The ninSrq()  *	    function should be called to determine the nature of the request  *	    and process it.  *  * WARNING: Changes made here should be tested in both gdb960 and comm960.  *  ******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Needed by file.h on Sys V */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* Needed on Sys V */
end_comment

begin_include
include|#
directive|include
file|"ttycntl.h"
end_include

begin_include
include|#
directive|include
file|"block_io.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"env.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"sysv.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BSD */
end_comment

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ERROR
end_ifndef

begin_define
define|#
directive|define
name|ERROR
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DLE
value|0x10
end_define

begin_comment
comment|/* ^P */
end_comment

begin_define
define|#
directive|define
name|XON
value|0x11
end_define

begin_comment
comment|/* ^Q */
end_comment

begin_define
define|#
directive|define
name|XOFF
value|0x13
end_define

begin_comment
comment|/* ^S */
end_comment

begin_define
define|#
directive|define
name|ESC
value|0x1b
end_define

begin_define
define|#
directive|define
name|REGISTER_BYTES
value|((36*4) + (4*8))
end_define

begin_define
define|#
directive|define
name|TIMEOUT
value|-1
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => stifle unnecessary messages */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nindy_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor of tty connected to 960/NINDY board*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|old_nindy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => use old (hex) communication protocol */
end_comment

begin_expr_stmt
specifier|static
name|ninStrGet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/**************************** 		 *                          * 		 *  MISCELLANEOUS UTILTIES  * 		 *                          * 		 ****************************/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/******************************************************************************  * byteswap:  *	If the host byte order is different from 960 byte order (i.e., the  *	host is big-endian), reverse the bytes in the passed value;  otherwise,  *	return the passed value unchanged.  *  ******************************************************************************/
end_comment

begin_comment
unit|static long byteswap( n )     long n; { 	long rev; 	int i; 	static short test = 0x1234;  	if (*((char *)&test) == 0x12) {
comment|/* 		 * Big-endian host, swap the bytes. 		 */
end_comment

begin_endif
unit|rev = 0; 		for ( i = 0; i< sizeof(n); i++ ){ 			rev<<= 8; 			rev |= n& 0xff; 			n>>= 8; 		} 		n = rev; 	} 	return n; }
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************  * get_int:  *	Copy the little-endian integer pointed at by 'p'  and return it in  *	the host byte order.  'p' may be an unaligned address, so do the copy  *	a byte at a time.  ******************************************************************************/
end_comment

begin_function
name|int
name|get_int
parameter_list|(
name|p
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|<<=
literal|8
expr_stmt|;
name|n
operator||=
operator|*
name|p
operator|--
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * put_int:  *	Copy the integer 'n' (which is in host byte order) to the location  *	pointed at by 'p', leaving it in little-endian byte order.  *	'p' may be an unaligned address, so do the move a byte at a time.  ******************************************************************************/
end_comment

begin_function
name|int
name|put_int
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|n
expr_stmt|;
name|n
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * say:  *	This is a printf that takes at most two arguments (in addition to the  *	format string) and that outputs nothing if verbose output has been  *	suppressed.  ******************************************************************************/
end_comment

begin_comment
comment|/* FIXME: use varargs for this.  */
end_comment

begin_expr_stmt
specifier|static
name|say
argument_list|(
argument|fmt
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
name|char
operator|*
name|fmt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf
argument_list|(
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * exists:  *	Creates a full pathname by concatenating up to three name components  *	onto a specified base name; optionally looks up the base name as a  *	runtime environment variable;  and checks to see if the file or  *	directory specified by the pathname actually exists.  *  *	Returns:  the full pathname if it exists, NULL otherwise.  *		(returned pathname is in malloc'd memory and must be freed  *		by caller).  *****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|exists
parameter_list|(
name|base
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|,
name|c3
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|;
comment|/* Base directory of path */
name|char
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|,
modifier|*
name|c3
decl_stmt|;
end_function

begin_comment
comment|/* Components (subdirectories and/or file name) to be 			 *	appended onto the base directory name.  One or 			 *	more may be omitted by passing NULL pointers. 			 */
end_comment

begin_decl_stmt
name|int
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If 1, '*base' is the name of an environment variable 			 *	to be examined for the base directory name; 			 *	otherwise, '*base' is the actual name of the 			 *	base directory. 			 */
end_comment

begin_block
block|{
name|struct
name|stat
name|buf
decl_stmt|;
comment|/* For call to 'stat' -- never examined */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pointer to full pathname (malloc'd memory) */
name|int
name|len
decl_stmt|;
comment|/* Length of full pathname (incl. terminator) */
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
if|if
condition|(
name|env
condition|)
block|{
name|base
operator|=
name|getenv
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* +4 for terminator and "/" before each component */
if|if
condition|(
name|c1
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|c1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c2
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c3
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|c3
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c2
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c3
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|c3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***************************** 		 *                           * 		 *  LOW-LEVEL COMMUNICATION  * 		 *                           * 		 *****************************/
end_comment

begin_comment
comment|/******************************************************************************  * timed_read:  *	Read up to 'n' characters (less if fewer are available) from the NINDY  *	tty. Wait up to 'timeout' seconds for something to arrive.  Return  *	the number of characters read, 0 on timeout.  ******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|saw_alarm
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|alarm_handler
parameter_list|()
block|{
name|saw_alarm
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|timed_read
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|,
name|timeout
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to put the read characters	*/
name|int
name|n
decl_stmt|;
comment|/* Max number of characters to read	*/
name|int
name|timeout
decl_stmt|;
comment|/* Timeout, in seconds			*/
block|{
name|void
function_decl|(
modifier|*
name|old_alarm
function_decl|)
parameter_list|()
function_decl|;
comment|/* Save alarm signal handler here on entry */
name|int
name|cnt
decl_stmt|;
name|old_alarm
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarm_handler
argument_list|)
expr_stmt|;
name|saw_alarm
operator|=
literal|0
expr_stmt|;
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
do|do
block|{
name|cnt
operator|=
name|n
expr_stmt|;
name|TTY_NBREAD
argument_list|(
name|nindy_fd
argument_list|,
name|cnt
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cnt
operator|<=
literal|0
operator|)
operator|&&
operator|!
name|saw_alarm
condition|)
do|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|old_alarm
argument_list|)
expr_stmt|;
return|return
name|saw_alarm
condition|?
literal|0
else|:
name|cnt
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BSD */
end_comment

begin_function
specifier|static
name|int
name|timed_read
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|,
name|timeout
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to put the read characters	*/
name|int
name|n
decl_stmt|;
comment|/* Max number of characters to read	*/
name|int
name|timeout
decl_stmt|;
comment|/* Timeout, in seconds			*/
block|{
name|struct
name|timeval
name|t
decl_stmt|;
name|fd_set
name|f
decl_stmt|;
name|t
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|timeout
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|nindy_fd
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|nindy_fd
operator|+
literal|1
argument_list|,
operator|&
name|f
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
return|return
name|read
argument_list|(
name|nindy_fd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************  * rdnin:  *	Read *exactly* 'n' characters from the NINDY tty.  Translate escape  *	sequences into single characters, counting each such sequence as   *	1 character.  *  *	An escape sequence consists of ESC and a following character.  The  *	ESC is discarded and the other character gets bit 0x40 cleared --  *	thus ESC P == ^P, ESC S == ^S, ESC [ == ESC, etc.  *  *	Return 1 if successful, 0 if more than 'timeout' seconds pass without  *	any input.  ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|rdnin
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|,
name|timeout
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Where to place characters read	*/
name|int
name|n
decl_stmt|;
comment|/* Number of characters to read		*/
name|int
name|timeout
decl_stmt|;
comment|/* Timeout, in seconds			*/
block|{
specifier|static
name|unsigned
name|char
modifier|*
name|mybuf
init|=
name|NULL
decl_stmt|;
comment|/* Dynamically allocated local buffer */
specifier|static
name|int
name|mybuflen
init|=
literal|0
decl_stmt|;
comment|/* Current size of local buffer	*/
name|int
name|escape_seen
decl_stmt|;
comment|/* 1 => last character of a read was an ESC */
name|int
name|nread
decl_stmt|;
comment|/* Number of chars returned by timed_read() */
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Make sure local buffer is big enough 	 */
if|if
condition|(
name|n
operator|>
name|mybuflen
condition|)
block|{
if|if
condition|(
name|mybuf
condition|)
block|{
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
block|}
name|mybuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|mybuflen
operator|=
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* More than one loop will be necessary if there are any 	 * escape sequences in the input 	 */
name|escape_seen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|nread
operator|=
name|timed_read
argument_list|(
name|mybuf
argument_list|,
name|n
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
comment|/* TIMED OUT */
block|}
comment|/* Copy characters from local buffer to caller's buffer, 		 * converting escape sequences as they're encountered. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nread
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|mybuf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|escape_seen
condition|)
block|{
name|escape_seen
operator|=
literal|0
expr_stmt|;
name|c
operator|&=
operator|~
literal|0x40
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|nread
condition|)
block|{
comment|/* Need to refill local buffer */
name|escape_seen
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|mybuf
index|[
name|i
index|]
operator|&
operator|~
literal|0x40
expr_stmt|;
block|}
operator|*
name|buf
operator|++
operator|=
name|c
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * getpkt:  *	Read a packet from a remote NINDY, with error checking, into the  *	indicated buffer.  *  *	Return packet status byte on success, TIMEOUT on failure.  ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|getpkt
parameter_list|(
name|buf
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|hdr
index|[
literal|3
index|]
decl_stmt|;
comment|/* Packet header: 				 *	hdr[0] = low byte of message length 				 *	hdr[1] = high byte of message length 				 *	hdr[2] = message status 				 */
name|int
name|cnt
decl_stmt|;
comment|/* Message length (status byte + data)	*/
name|unsigned
name|char
name|cs_calc
decl_stmt|;
comment|/* Checksum calculated			*/
name|unsigned
name|char
name|cs_recv
decl_stmt|;
comment|/* Checksum received			*/
specifier|static
name|char
name|errfmt
index|[]
init|=
literal|"Bad checksum (recv=0x%02x; calc=0x%02x); retrying\r\n"
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|rdnin
argument_list|(
name|hdr
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|)
condition|)
block|{
return|return
name|TIMEOUT
return|;
block|}
name|cnt
operator|=
operator|(
name|hdr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|hdr
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
comment|/* -1 for status byte (already read) */
comment|/* Caller's buffer may only be big enough for message body, 		 * without status byte and checksum, so make sure to read 		 * checksum into a separate buffer. 		 */
if|if
condition|(
operator|!
name|rdnin
argument_list|(
name|buf
argument_list|,
name|cnt
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|rdnin
argument_list|(
operator|&
name|cs_recv
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
condition|)
block|{
return|return
name|TIMEOUT
return|;
block|}
comment|/* Calculate checksum 		 */
name|cs_calc
operator|=
name|hdr
index|[
literal|0
index|]
operator|+
name|hdr
index|[
literal|1
index|]
operator|+
name|hdr
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|cs_calc
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|cs_calc
operator|==
name|cs_recv
condition|)
block|{
name|write
argument_list|(
name|nindy_fd
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|hdr
index|[
literal|2
index|]
return|;
block|}
comment|/* Bad checksum: report, send NAK, and re-receive 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|errfmt
argument_list|,
name|cs_recv
argument_list|,
name|cs_calc
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|nindy_fd
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * putpkt:  *	Send a packet to NINDY, checksumming it and converting special  *	characters to escape sequences.  ******************************************************************************/
end_comment

begin_comment
comment|/* This macro puts the character 'c' into the buffer pointed at by 'p',  * and increments the pointer.  If 'c' is one of the 4 special characters  * in the transmission protocol, it is converted into a 2-character  * escape sequence.  */
end_comment

begin_define
define|#
directive|define
name|PUTBUF
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|)
define|\
value|if ( c == DLE || c == ESC || c == XON || c == XOFF ){	\ 		*p++ = ESC;					\ 		*p++ = c | 0x40;				\ 	} else {						\ 		*p++ = c;					\ 	}
end_define

begin_expr_stmt
specifier|static
name|putpkt
argument_list|(
argument|msg
argument_list|,
argument|len
argument_list|)
name|unsigned
name|char
operator|*
name|msg
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Command to be sent, without lead ^P (\020) or checksum */
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes in message			*/
end_comment

begin_block
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
comment|/* Local buffer -- build packet here	*/
specifier|static
name|int
name|maxbuf
init|=
literal|0
decl_stmt|;
comment|/* Current length of buffer		*/
name|unsigned
name|char
name|ack
decl_stmt|;
comment|/* Response received from NINDY		*/
name|unsigned
name|char
name|checksum
decl_stmt|;
comment|/* Packet checksum			*/
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer into buffer			*/
name|int
name|lenhi
decl_stmt|,
name|lenlo
decl_stmt|;
comment|/* High and low bytes of message length	*/
name|int
name|i
decl_stmt|;
comment|/* Make sure local buffer is big enough.  Must include space for 	 * packet length, message body, and checksum.  And in the worst 	 * case, each character would expand into a 2-character escape 	 * sequence. 	 */
if|if
condition|(
name|maxbuf
operator|<
operator|(
operator|(
literal|2
operator|*
name|len
operator|)
operator|+
literal|10
operator|)
condition|)
block|{
if|if
condition|(
name|buf
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|maxbuf
operator|=
operator|(
operator|(
literal|2
operator|*
name|len
operator|)
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Attention, NINDY! 	 */
name|write
argument_list|(
name|nindy_fd
argument_list|,
literal|"\020"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lenlo
operator|=
name|len
operator|&
literal|0xff
expr_stmt|;
name|lenhi
operator|=
operator|(
name|len
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|checksum
operator|=
name|lenlo
operator|+
name|lenhi
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|PUTBUF
argument_list|(
name|lenlo
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|PUTBUF
argument_list|(
name|lenhi
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|PUTBUF
argument_list|(
name|msg
index|[
name|i
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|msg
index|[
name|i
index|]
expr_stmt|;
block|}
name|PUTBUF
argument_list|(
name|checksum
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Send checksummed message over and over until we get a positive ack 	 */
name|write
argument_list|(
name|nindy_fd
argument_list|,
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|rdnin
argument_list|(
operator|&
name|ack
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* timed out */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ACK timed out; resending\r\n"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|nindy_fd
argument_list|,
literal|"\020"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Attention, NINDY! */
name|write
argument_list|(
name|nindy_fd
argument_list|,
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ack
operator|==
literal|'+'
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|ack
operator|==
literal|'-'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote NAK; resending\r\n"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|nindy_fd
argument_list|,
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad ACK, ignored:<%c>\r\n"
argument_list|,
name|ack
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * send:  *	Send a message to a remote NINDY.  Check message status byte  *	for error responses.  If no error, return NINDY reponse (if any).  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|send
argument_list|(
argument|out
argument_list|,
argument|len
argument_list|,
argument|in
argument_list|)
name|unsigned
name|char
operator|*
name|out
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Message to be sent to NINDY			*/
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of meaningful bytes in out buffer	*/
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to put response received from NINDY	*/
end_comment

begin_block
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|status
decl_stmt|;
specifier|static
name|char
modifier|*
name|errmsg
index|[]
init|=
block|{
literal|""
block|,
comment|/* 0 */
literal|"Buffer overflow"
block|,
comment|/* 1 */
literal|"Unknown command"
block|,
comment|/* 2 */
literal|"Wrong amount of data to load register(s)"
block|,
comment|/* 3 */
literal|"Missing command argument(s)"
block|,
comment|/* 4 */
literal|"Odd number of digits sent to load memory"
block|,
comment|/* 5 */
literal|"Unknown register name"
block|,
comment|/* 6 */
literal|"No such memory segment"
block|,
comment|/* 7 */
literal|"No breakpoint available"
block|,
comment|/* 8 */
literal|"Can't set requested baud rate"
block|,
comment|/* 9 */
block|}
decl_stmt|;
define|#
directive|define
name|NUMERRS
value|( sizeof(errmsg) / sizeof(errmsg[0]) )
specifier|static
name|char
name|err1
index|[]
init|=
literal|"Unknown error response from NINDY: #%d\r\n"
decl_stmt|;
specifier|static
name|char
name|err2
index|[]
init|=
literal|"Error response #%d from NINDY: %s\r\n"
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|putpkt
argument_list|(
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|status
operator|=
name|getpkt
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|TIMEOUT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Response timed out; resending\r\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|status
condition|)
block|{
name|fmt
operator|=
name|status
operator|>
name|NUMERRS
condition|?
name|err1
else|:
name|err2
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|status
argument_list|,
name|errmsg
index|[
name|status
index|]
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/************************ 		 *                      * 		 *  BAUD RATE ROUTINES  * 		 *                      * 		 ************************/
end_comment

begin_comment
comment|/* Table of baudrates known to be acceptable to NINDY.  Each baud rate  * appears both as character string and as a Unix baud rate constant.  */
end_comment

begin_struct
struct|struct
name|baudrate
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|rate
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|baudrate
name|baudtab
index|[]
init|=
block|{
literal|"1200"
block|,
name|B1200
block|,
literal|"2400"
block|,
name|B2400
block|,
literal|"4800"
block|,
name|B4800
block|,
literal|"9600"
block|,
name|B9600
block|,
literal|"19200"
block|,
name|B19200
block|,
literal|"38400"
block|,
name|B38400
block|,
name|NULL
block|,
literal|0
comment|/* End of table */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  * parse_baudrate:  *	Look up the passed baud rate in the baudrate table.  If found, change  *	our internal record of the current baud rate, but don't do anything  *	about the tty just now.  *  *	Return pointer to baudrate structure on success, NULL on failure.  ******************************************************************************/
end_comment

begin_function
specifier|static
name|struct
name|baudrate
modifier|*
name|parse_baudrate
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Desired baud rate, as an ASCII (decimal) string */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|baudtab
index|[
name|i
index|]
operator|.
name|string
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|baudtab
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|s
argument_list|)
condition|)
block|{
return|return
operator|&
name|baudtab
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * try_baudrate:  *	Try speaking to NINDY via the specified file descriptor at the  *	specified baudrate.  Assume success if we can send an empty command  *	with a bogus checksum and receive a NAK (response of '-') back within  *	one second.  *  *	Return 1 on success, 0 on failure.  ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|try_baudrate
parameter_list|(
name|fd
parameter_list|,
name|brp
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|baudrate
modifier|*
name|brp
decl_stmt|;
block|{
name|TTY_STRUCT
name|tty
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* Set specified baud rate and flush all pending input */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|TTY_REMOTE
argument_list|(
name|tty
argument_list|,
name|brp
operator|->
name|rate
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|tty_flush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Send empty command with bad checksum, hope for NAK ('-') response */
name|write
argument_list|(
name|fd
argument_list|,
literal|"\020\0\0\001"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rdnin
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* timed out */
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|(
name|c
operator|==
literal|'-'
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************  * autobaud:  *	Get NINDY talking over the specified file descriptor at the specified  *	baud rate.  First see if NINDY's already talking at 'baudrate'.  If  *	not, run through all the legal baudrates in 'baudtab' until one works,  *	and then tell NINDY to talk at 'baudrate' instead.  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|autobaud
argument_list|(
argument|fd
argument_list|,
argument|brp
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|baudrate
modifier|*
name|brp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|TTY_STRUCT
name|tty
decl_stmt|;
name|int
name|failures
decl_stmt|;
name|say
argument_list|(
literal|"NINDY at wrong baud rate? Trying to autobaud...\n"
argument_list|)
expr_stmt|;
name|failures
operator|=
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|say
argument_list|(
literal|"\r%s...   "
argument_list|,
name|baudtab
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_baudrate
argument_list|(
name|fd
argument_list|,
operator|&
name|baudtab
index|[
name|i
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|baudtab
index|[
operator|++
name|i
index|]
operator|.
name|string
operator|==
name|NULL
condition|)
block|{
comment|/* End of table -- wraparound */
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|failures
operator|++
condition|)
block|{
name|say
argument_list|(
literal|"\nAutobaud failed again.  Giving up.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|say
argument_list|(
literal|"\nAutobaud failed. Trying again...\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Found NINDY's current baud rate;  now change it. 	 */
name|say
argument_list|(
literal|"Changing NINDY baudrate to %s\n"
argument_list|,
name|brp
operator|->
name|string
argument_list|)
expr_stmt|;
name|ninBaud
argument_list|(
name|brp
operator|->
name|string
argument_list|)
expr_stmt|;
comment|/* Change our baud rate back to rate to which we just set NINDY. 	 */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|TTY_REMOTE
argument_list|(
name|tty
argument_list|,
name|brp
operator|->
name|rate
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************  * coffstrip:  *	Passed the name of an executable object file in either b.out or  *	COFF format.  *  *	If the file is in b.out format, it is converted to little-endian  *	COFF format (i.e., the format suitable for downloading to NINDY).  *	In either case, the COFF file is then stripped of all relocation  *	and symbol information, to speed up its download.  *  * RETURNS:  *	pointer to the name of the stripped COFF file (a tmp file that has  *	been created and closed); NULL on error.  *****************************************************************************/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|STRIP
value|"bfd_strip"
end_define

begin_comment
comment|/* Name of bfd strip utility	*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NINDY_OBJ
value|"coff-Intel-little"
end_define

begin_function
name|char
modifier|*
name|coffstrip
parameter_list|(
name|fn
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
comment|/* Name of object file */
block|{
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
specifier|static
name|char
name|template
index|[]
init|=
literal|"/tmp/commXXXXXX"
decl_stmt|;
specifier|static
name|char
name|newfile
index|[
sizeof|sizeof
name|template
index|]
decl_stmt|;
name|char
modifier|*
name|strip
decl_stmt|;
comment|/* Pointer to full pathname of strip utility	*/
name|int
name|success
decl_stmt|;
comment|/* Return value					*/
name|int
name|pid
decl_stmt|;
comment|/* Process ID of xmodem transfer utility	*/
name|WAITTYPE
name|w
decl_stmt|;
comment|/* xmodem transfer completion status		*/
name|int
name|wret
decl_stmt|;
comment|/* Value returned by wait			*/
name|char
modifier|*
name|tempfile
decl_stmt|;
comment|/* Stripped copy of object file			*/
name|char
name|buf
index|[
literal|400
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|newfile
argument_list|,
name|template
argument_list|)
expr_stmt|;
name|tempfile
operator|=
name|mktemp
argument_list|(
name|newfile
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Make sure the strip utility is findable. 	 */
block|if ( ((strip = exists("G960BIN",STRIP,NULL,NULL,1)) == NULL)&&   ((strip = exists("G960BASE","bin",STRIP, NULL,1)) == NULL)
ifdef|#
directive|ifdef
name|HOST
block|&&   ((strip = exists(DEFAULT_BASE,HOST,"bin",STRIP,0)) == NULL)
endif|#
directive|endif
block|){ 		fprintf(stderr,"Can't find '%s' utility\n",STRIP); 		fprintf(stderr,"Check env variables G960BIN and G960BASE\n"); 		return NULL; 	}
endif|#
directive|endif
name|success
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cp %s %s"
argument_list|,
name|fn
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s -d %s %s"
argument_list|,
name|STRIP
argument_list|,
name|NINDY_OBJ
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|tempfile
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/********************************** 		 *				  * 		 *   NINDY INTERFACE ROUTINES	  * 		 *                            	  * 		 * ninConnect *MUST* be the first * 		 * one of these routines called.  * 		 **********************************/
end_comment

begin_comment
comment|/******************************************************************************  * ninBaud:  *	Ask NINDY to change the baud rate on its serial port.  *	Assumes we know the baud rate at which NINDY's currently talking.  ******************************************************************************/
end_comment

begin_macro
name|ninBaud
argument_list|(
argument|baudrate
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|baudrate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Desired baud rate, as a string of ASCII decimal 			 * digits. 			 */
end_comment

begin_block
block|{
name|unsigned
name|char
name|msg
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninBaud
argument_list|(
name|baudrate
argument_list|)
expr_stmt|;
return|return;
block|}
name|tty_flush
argument_list|(
name|nindy_fd
argument_list|)
expr_stmt|;
comment|/* Can't use "send" because NINDY reply will be unreadable after 	 * baud rate change. 	 */
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"z%s"
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* "+1" to send terminator too */
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninBptDel:  *	Ask NINDY to delete the specified type of *hardware* breakpoint at  *	the specified address.  If the 'addr' is -1, all breakpoints of  *	the specified type are deleted.  ******************************************************************************/
end_comment

begin_macro
name|ninBptDel
argument_list|(
argument|addr
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|long
name|addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in 960 memory	*/
end_comment

begin_decl_stmt
name|char
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'd' => data bkpt, 'i' => instruction breakpoint */
end_comment

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninBptDel
argument_list|(
name|addr
argument_list|,
name|type
operator|==
literal|'d'
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'b'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
block|{
name|send
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_int
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninBptSet:  *	Ask NINDY to set the specified type of *hardware* breakpoint at  *	the specified address.  ******************************************************************************/
end_comment

begin_macro
name|ninBptSet
argument_list|(
argument|addr
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|long
name|addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in 960 memory	*/
end_comment

begin_decl_stmt
name|char
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'd' => data bkpt, 'i' => instruction breakpoint */
end_comment

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninBptSet
argument_list|(
name|addr
argument_list|,
name|type
operator|==
literal|'d'
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'B'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|type
expr_stmt|;
name|put_int
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninConnect:  *	Open the specified tty.  Get communications working at the specified  *	baud rate.  Flush any pending I/O on the tty.  *  *	Return the file descriptor, or -1 on failure.  ******************************************************************************/
end_comment

begin_function
name|int
name|ninConnect
parameter_list|(
name|name
parameter_list|,
name|baudrate
parameter_list|,
name|brk
parameter_list|,
name|silent
parameter_list|,
name|old_protocol
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* "/dev/ttyXX" to be opened			*/
name|char
modifier|*
name|baudrate
decl_stmt|;
comment|/* baud rate: a string of ascii decimal digits (eg,"9600")*/
name|int
name|brk
decl_stmt|;
comment|/* 1 => send break to tty first thing after opening it*/
name|int
name|silent
decl_stmt|;
comment|/* 1 => stifle unnecessary messages when talking to  			 *	this tty. 			 */
name|int
name|old_protocol
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|baudrate
modifier|*
name|brp
decl_stmt|;
comment|/* We will try each of the following paths when trying to open the tty 	 */
specifier|static
name|char
modifier|*
name|prefix
index|[]
init|=
block|{
literal|""
block|,
literal|"/dev/"
block|,
literal|"/dev/tty"
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|old_protocol
condition|)
block|{
name|old_nindy
operator|=
literal|1
expr_stmt|;
return|return
name|OninConnect
argument_list|(
name|name
argument_list|,
name|baudrate
argument_list|,
name|brk
argument_list|,
name|silent
argument_list|)
return|;
block|}
name|quiet
operator|=
name|silent
expr_stmt|;
comment|/* Make global to this file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|prefix
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|prefix
index|[
name|i
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|prefix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nindy_fd
operator|=
name|open
argument_list|(
name|p
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nindy_fd
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCEXCL
comment|/* Exclusive use mode (hp9000 does not support it) */
name|ioctl
argument_list|(
name|nindy_fd
argument_list|,
name|TIOCEXCL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|brk
condition|)
block|{
name|send_break
argument_list|(
name|nindy_fd
argument_list|)
expr_stmt|;
block|}
name|brp
operator|=
name|parse_baudrate
argument_list|(
name|baudrate
argument_list|)
expr_stmt|;
if|if
condition|(
name|brp
operator|==
name|NULL
condition|)
block|{
name|say
argument_list|(
literal|"Illegal baudrate %s ignored; using 9600\n"
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
name|brp
operator|=
name|parse_baudrate
argument_list|(
literal|"9600"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|try_baudrate
argument_list|(
name|nindy_fd
argument_list|,
name|brp
argument_list|)
condition|)
block|{
name|autobaud
argument_list|(
name|nindy_fd
argument_list|,
name|brp
argument_list|)
expr_stmt|;
block|}
name|tty_flush
argument_list|(
name|nindy_fd
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|"Connected to %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|nindy_fd
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * ninDownload:  *	Ask NINDY to start up it's COFF downloader. Invoke 'sx' to perform  *	the XMODEM download from the host end.  *  *	Return 1 on success, 0 on failure.  ******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|XMODEM
value|"sx"
end_define

begin_comment
comment|/* Name of xmodem transfer utility	*/
end_comment

begin_function
name|int
name|ninDownload
parameter_list|(
name|fn
parameter_list|,
name|quiet
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
comment|/* Stripped copy of object file			*/
name|int
name|quiet
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to full pathname of sx utility	*/
name|int
name|success
decl_stmt|;
comment|/* Return value					*/
name|int
name|pid
decl_stmt|;
comment|/* Process ID of xmodem transfer utility	*/
name|WAITTYPE
name|w
decl_stmt|;
comment|/* xmodem transfer completion status		*/
name|int
name|wret
decl_stmt|;
comment|/* Value returned by wait			*/
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
return|return
name|OninDownload
argument_list|(
name|fn
argument_list|,
name|quiet
argument_list|)
return|;
block|}
comment|/* Make sure the xmodem utility is findable.  This must be done before 	 * we start up the NINDY end of the download (NINDY will hang if we 	 * don't complete the download). 	 */
if|if
condition|(
operator|(
operator|(
name|p
operator|=
name|exists
argument_list|(
literal|"G960BIN"
argument_list|,
name|XMODEM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|p
operator|=
name|exists
argument_list|(
literal|"G960BASE"
argument_list|,
literal|"bin"
argument_list|,
name|XMODEM
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|)
ifdef|#
directive|ifdef
name|HOST
operator|&&
operator|(
operator|(
name|p
operator|=
name|exists
argument_list|(
name|DEFAULT_BASE
argument_list|,
name|HOST
argument_list|,
literal|"bin"
argument_list|,
name|XMODEM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|)
endif|#
directive|endif
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find '%s' download utility\n"
argument_list|,
name|XMODEM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Check env variables G960BIN and G960BASE\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf
argument_list|(
literal|"Downloading %s\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* Reset NINDY,  wait until "reset-complete" ack, 	 * and start up the NINDY end of the download. 	 */
name|ninReset
argument_list|()
expr_stmt|;
name|putpkt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"D"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Invoke x-modem transfer, a separate process.  DON'T 	 * use system() to do this -- under system V Unix, the 	 * redirection of stdin/stdout causes the nindy tty to 	 * lose all the transmission parameters we've set up. 	 */
name|success
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_VFORK
argument_list|)
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"Can't fork process:"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* CHILD */
name|dup2
argument_list|(
name|nindy_fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Redirect stdin */
name|dup2
argument_list|(
name|nindy_fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Redirect stout */
if|if
condition|(
name|quiet
condition|)
block|{
name|execl
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
literal|"-q"
argument_list|,
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execl
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Don't get here unless execl fails */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Can't exec %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* PARENT */
do|do
block|{
name|wret
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|wret
operator|!=
name|pid
operator|&&
name|wret
operator|!=
operator|-
literal|1
condition|)
do|;
if|if
condition|(
name|wret
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"Wait failed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
operator|&&
operator|(
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|success
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * ninGdbExit:  *	Ask NINDY to leave GDB mode and print a NINDY prompt.  ******************************************************************************/
end_comment

begin_macro
name|ninGdbExit
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninGdbExit
argument_list|()
expr_stmt|;
return|return;
block|}
name|putpkt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"E"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninGo:  *	Ask NINDY to start or continue execution of an application program  *	in it's memory at the current ip.  ******************************************************************************/
end_comment

begin_macro
name|ninGo
argument_list|(
argument|step_flag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|step_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => run in single-step mode */
end_comment

begin_block
block|{
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninGo
argument_list|(
name|step_flag
argument_list|)
expr_stmt|;
return|return;
block|}
name|putpkt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|step_flag
condition|?
literal|"s"
else|:
literal|"c"
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninMemGet:  *	Read a string of bytes from NINDY's address space (960 memory).  ******************************************************************************/
end_comment

begin_macro
name|ninMemGet
argument_list|(
argument|ninaddr
argument_list|,
argument|hostaddr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|long
name|ninaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Source address, in the 960 memory space	*/
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|hostaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination address, in our memory space */
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes to read			*/
end_comment

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
name|BUFSIZE
operator|+
literal|20
index|]
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* Number of bytes in next transfer	*/
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninMemGet
argument_list|(
name|ninaddr
argument_list|,
name|hostaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|BUFSIZE
control|)
block|{
name|cnt
operator|=
name|len
operator|>
name|BUFSIZE
condition|?
name|BUFSIZE
else|:
name|len
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'m'
expr_stmt|;
name|put_int
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|ninaddr
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|cnt
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
operator|(
name|cnt
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
literal|7
argument_list|,
name|hostaddr
argument_list|)
expr_stmt|;
name|ninaddr
operator|+=
name|cnt
expr_stmt|;
name|hostaddr
operator|+=
name|cnt
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninMemPut:  *	Write a string of bytes into NINDY's address space (960 memory).  ******************************************************************************/
end_comment

begin_macro
name|ninMemPut
argument_list|(
argument|ninaddr
argument_list|,
argument|hostaddr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|long
name|ninaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination address, in NINDY memory space	*/
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|hostaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Source address, in our memory space	*/
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes to write			*/
end_comment

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
name|BUFSIZE
operator|+
literal|20
index|]
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* Number of bytes in next transfer	*/
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninMemPut
argument_list|(
name|ninaddr
argument_list|,
name|hostaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|BUFSIZE
control|)
block|{
name|cnt
operator|=
name|len
operator|>
name|BUFSIZE
condition|?
name|BUFSIZE
else|:
name|len
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'M'
expr_stmt|;
name|put_int
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|ninaddr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hostaddr
argument_list|,
name|buf
operator|+
literal|5
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|cnt
operator|+
literal|5
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ninaddr
operator|+=
name|cnt
expr_stmt|;
name|hostaddr
operator|+=
name|cnt
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninRegGet:  *	Retrieve the contents of a 960 register, and return them as a long  *	in host byte order.  *  *	THIS ROUTINE CAN ONLY BE USED TO READ THE LOCAL, GLOBAL, AND  *	ip/ac/pc/tc REGISTERS.  *  ******************************************************************************/
end_comment

begin_function
name|long
name|ninRegGet
parameter_list|(
name|regname
parameter_list|)
name|char
modifier|*
name|regname
decl_stmt|;
comment|/* Register name recognized by NINDY, subject to the 			 * above limitations. 			 */
block|{
name|unsigned
name|char
name|outbuf
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|char
name|inbuf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
return|return
name|OninRegGet
argument_list|(
name|regname
argument_list|)
return|;
block|}
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"u%s:"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|outbuf
argument_list|,
name|strlen
argument_list|(
name|outbuf
argument_list|)
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
return|return
name|get_int
argument_list|(
name|inbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * ninRegPut:  *	Set the contents of a 960 register.  *  *	THIS ROUTINE CAN ONLY BE USED TO SET THE LOCAL, GLOBAL, AND  *	ip/ac/pc/tc REGISTERS.  *  ******************************************************************************/
end_comment

begin_macro
name|ninRegPut
argument_list|(
argument|regname
argument_list|,
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|regname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register name recognized by NINDY, subject to the 			 * above limitations. 			 */
end_comment

begin_decl_stmt
name|long
name|val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New contents of register, in host byte-order	*/
end_comment

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninRegPut
argument_list|(
name|regname
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"U%s:"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|put_int
argument_list|(
operator|&
name|buf
index|[
name|len
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|len
operator|+
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninRegsGet:  *	Get a dump of the contents of the entire 960 register set.  The  *	individual registers appear in the dump in the following order:  *  *		pfp  sp   rip  r3   r4   r5   r6   r7   *		r8   r9   r10  r11  r12  r13  r14  r15   *		g0   g1   g2   g3   g4   g5   g6   g7   *		g8   g9   g10  g11  g12  g13  g14  fp   *		pc   ac   ip   tc   fp0  fp1  fp2  fp3  *  *	Each individual register comprises exactly 4 bytes, except for  *	fp0-fp3, which are 8 bytes.  All register values are in 960  *	(little-endian) byte order.  *  ******************************************************************************/
end_comment

begin_macro
name|ninRegsGet
argument_list|(
argument|regp
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|regp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to place the register dump */
end_comment

begin_block
block|{
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninRegsGet
argument_list|(
name|regp
argument_list|)
expr_stmt|;
return|return;
block|}
name|send
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"r"
argument_list|,
literal|1
argument_list|,
name|regp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninRegsPut:  *	Initialize the entire 960 register set to a specified set of values.  *	The format of the register value data should be the same as that  *	returned by ninRegsGet.  *  * WARNING:  *	All register values must be in 960 (little-endian) byte order.  *  ******************************************************************************/
end_comment

begin_macro
name|ninRegsPut
argument_list|(
argument|regp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|regp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to desired values of registers */
end_comment

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
name|REGISTER_BYTES
operator|+
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninRegsPut
argument_list|(
name|regp
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'R'
expr_stmt|;
name|bcopy
argument_list|(
name|regp
argument_list|,
name|buf
operator|+
literal|1
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|REGISTER_BYTES
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninReset:  *      Ask NINDY to perform a soft reset; wait for the reset to complete.  *  ******************************************************************************/
end_comment

begin_macro
name|ninReset
argument_list|()
end_macro

begin_block
block|{
name|unsigned
name|char
name|ack
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninReset
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|putpkt
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"X"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|rdnin
argument_list|(
operator|&
name|ack
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* Timed out */
break|break;
comment|/* Resend */
block|}
if|if
condition|(
name|ack
operator|==
literal|'+'
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninSrq:  *	Assume NINDY has stopped execution of the 960 application program in  *	order to process a host service request (srq).  Ask NINDY for the  *	srq arguments, perform the requested service, and send an "srq  *	complete" message so NINDY will return control to the application.  *  ******************************************************************************/
end_comment

begin_macro
name|ninSrq
argument_list|()
end_macro

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|unsigned
name|char
name|srqnum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|arg
index|[
name|MAX_SRQ_ARGS
index|]
decl_stmt|;
if|if
condition|(
name|old_nindy
condition|)
block|{
name|OninSrq
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Get srq number and arguments 	 */
name|send
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"!"
argument_list|,
literal|1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|srqnum
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|offset
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_SRQ_ARGS
condition|;
name|i
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|arg
index|[
name|i
index|]
operator|=
name|get_int
argument_list|(
operator|&
name|buf
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Process Srq 	 */
switch|switch
condition|(
name|srqnum
condition|)
block|{
case|case
name|BS_CLOSE
case|:
comment|/* args: file descriptor */
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|>
literal|2
condition|)
block|{
name|retcode
operator|=
name|close
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retcode
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BS_CREAT
case|:
comment|/* args: filename, mode */
name|ninStrGet
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|creat
argument_list|(
name|buf
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BS_OPEN
case|:
comment|/* args: filename, flags, mode */
name|ninStrGet
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BS_READ
case|:
comment|/* args: file descriptor, buffer, count */
name|retcode
operator|=
name|read
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|>
literal|0
condition|)
block|{
name|ninMemPut
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BS_SEEK
case|:
comment|/* args: file descriptor, offset, whence */
name|retcode
operator|=
name|lseek
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BS_WRITE
case|:
comment|/* args: file descriptor, buffer, count */
name|ninMemGet
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|write
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retcode
operator|=
name|ERROR
expr_stmt|;
break|break;
block|}
comment|/* Send request termination status to NINDY 	 */
name|buf
index|[
literal|0
index|]
operator|=
literal|'e'
expr_stmt|;
name|put_int
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
literal|5
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninStopWhy:  *	Assume the application program has stopped (i.e., a DLE was received  *	from NINDY).  Ask NINDY for status information describing the  *	reason for the halt.  *  *	Returns a non-zero value if the user program has exited, 0 otherwise.  *	Also returns the following information, through passed pointers:  *           - why: an exit code if program the exited; otherwise the reason  *			why the program halted (see stop.h for values).  *	    - contents of register ip (little-endian byte order)  *	    - contents of register sp (little-endian byte order)  *	    - contents of register fp (little-endian byte order)  ******************************************************************************/
end_comment

begin_function
name|char
name|ninStopWhy
parameter_list|(
name|whyp
parameter_list|,
name|ipp
parameter_list|,
name|fpp
parameter_list|,
name|spp
parameter_list|)
name|unsigned
name|char
modifier|*
name|whyp
decl_stmt|;
comment|/* Return the 'why' code through this pointer	*/
name|long
modifier|*
name|ipp
decl_stmt|;
comment|/* Return contents of register ip through this pointer	*/
name|long
modifier|*
name|fpp
decl_stmt|;
comment|/* Return contents of register fp through this pointer	*/
name|long
modifier|*
name|spp
decl_stmt|;
comment|/* Return contents of register sp through this pointer	*/
block|{
name|unsigned
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|extern
name|char
name|OninStopWhy
parameter_list|()
function_decl|;
if|if
condition|(
name|old_nindy
condition|)
block|{
return|return
name|OninStopWhy
argument_list|(
name|whyp
argument_list|,
name|ipp
argument_list|,
name|fpp
argument_list|,
name|spp
argument_list|)
return|;
block|}
name|send
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"?"
argument_list|,
literal|1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|whyp
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ipp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ipp
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|buf
index|[
literal|6
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fpp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ipp
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|buf
index|[
literal|10
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|spp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ipp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * ninStrGet:  *	Read a '\0'-terminated string of data out of the 960 memory space.  *  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|ninStrGet
argument_list|(
argument|ninaddr
argument_list|,
argument|hostaddr
argument_list|)
name|unsigned
name|long
name|ninaddr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Address of string in NINDY memory space */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|hostaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address of the buffer to which string should 				 *	be copied. 				 */
end_comment

begin_block
block|{
name|unsigned
name|char
name|cmd
index|[
literal|5
index|]
decl_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
literal|'"'
expr_stmt|;
name|put_int
argument_list|(
operator|&
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ninaddr
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|cmd
argument_list|,
literal|5
argument_list|,
name|hostaddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninVersion:  *	Ask NINDY for version information about itself.  *	The information is sent as an ascii string in the form "x.xx,<arch>",  *	where,  *		x.xx	is the version number  *<arch>	is the processor architecture: "KA", "KB", "MC", "CA" *  *  ******************************************************************************/
end_comment

begin_function
name|int
name|ninVersion
parameter_list|(
name|p
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Where to place version string */
block|{
if|if
condition|(
name|old_nindy
condition|)
block|{
return|return
name|OninVersion
argument_list|(
name|p
argument_list|)
return|;
block|}
name|send
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"v"
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

end_unit

