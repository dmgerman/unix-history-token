begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-machine dependent code for Hitachi H8/300, for GDB.    Copyright (C) 1988, 1990, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*   Contributed by Steve Chamberlain                 sac@cygnus.com   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_define
define|#
directive|define
name|UNSIGNED_SHORT
parameter_list|(
name|X
parameter_list|)
value|((X)& 0xffff)
end_define

begin_comment
comment|/* an easy to debug H8 stack frame looks like: 0x6df2	push	r2 0x6df3	push	r3 0x6df6	push	r6 0x	mov.w	r7,r6 	subs	stuff,sp  mov.w #x,r5 	                  subs  r5,sp   */
end_comment

begin_define
define|#
directive|define
name|IS_PUSH
parameter_list|(
name|x
parameter_list|)
value|((x& 0xff00)==0x6d00)
end_define

begin_define
define|#
directive|define
name|IS_MOVE_FP
parameter_list|(
name|x
parameter_list|)
value|(x == 0x0d76)
end_define

begin_define
define|#
directive|define
name|IS_MOV_SP_FP
parameter_list|(
name|x
parameter_list|)
value|(x == 0x0d76)
end_define

begin_define
define|#
directive|define
name|IS_SUB2_SP
parameter_list|(
name|x
parameter_list|)
value|(x==0x1b87)
end_define

begin_define
define|#
directive|define
name|IS_MOVK_R5
parameter_list|(
name|x
parameter_list|)
value|(x==0x7905)
end_define

begin_function_decl
name|CORE_ADDR
name|examine_prologue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|frame_find_saved_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|CORE_ADDR
name|h8300_skip_prologue
parameter_list|(
name|start_pc
parameter_list|)
name|CORE_ADDR
name|start_pc
decl_stmt|;
block|{
comment|/* Skip past all push insns */
name|short
name|int
name|w
decl_stmt|;
name|w
operator|=
name|read_memory_short
argument_list|(
name|start_pc
argument_list|)
expr_stmt|;
while|while
condition|(
name|IS_PUSH
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|start_pc
operator|+=
literal|2
expr_stmt|;
name|w
operator|=
name|read_memory_short
argument_list|(
name|start_pc
argument_list|)
expr_stmt|;
block|}
comment|/* Skip past a move to FP */
if|if
condition|(
name|IS_MOVE_FP
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|start_pc
operator|+=
literal|2
expr_stmt|;
name|w
operator|=
name|read_memory_short
argument_list|(
name|start_pc
argument_list|)
expr_stmt|;
block|}
return|return
name|start_pc
return|;
block|}
end_function

begin_function
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* Nothing is bigger than 8 bytes */
name|char
name|data
index|[
literal|8
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|print_insn_h8300
argument_list|(
name|memaddr
argument_list|,
name|data
argument_list|,
name|stream
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a GDB frame, determine the address of the calling function's frame.    This will be used to create a new GDB frame struct, and then    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.     For us, the frame address is its stack pointer value, so we look up    the function prologue to determine the caller's sp value, and return it.  */
end_comment

begin_function
name|FRAME_ADDR
name|FRAME_CHAIN
parameter_list|(
name|thisframe
parameter_list|)
name|FRAME
name|thisframe
decl_stmt|;
block|{
name|frame_find_saved_regs
argument_list|(
name|thisframe
argument_list|,
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|thisframe
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
return|;
block|}
end_function

begin_comment
comment|/* Put here the code to store, into a struct frame_saved_regs,    the addresses of the saved registers of frame described by FRAME_INFO.    This includes special registers such as pc and fp saved in special    ways in the stack frame.  sp is even more special:    the address we return for it IS the sp for the next frame.     We cache the result of doing this in the frame_cache_obstack, since    it is fairly expensive.  */
end_comment

begin_function
name|void
name|frame_find_saved_regs
parameter_list|(
name|fi
parameter_list|,
name|fsr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|next_addr
decl_stmt|;
specifier|register
name|CORE_ADDR
modifier|*
name|saved_regs
decl_stmt|;
specifier|register
name|int
name|regnum
decl_stmt|;
specifier|register
name|struct
name|frame_saved_regs
modifier|*
name|cache_fsr
decl_stmt|;
specifier|extern
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
name|CORE_ADDR
name|ip
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|fsr
condition|)
block|{
name|cache_fsr
operator|=
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cache_fsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|fsr
operator|=
name|cache_fsr
expr_stmt|;
comment|/* Find the start and end of the function prologue.  If the PC 	 is in the function prologue, we only consider the part that 	 has executed already.  */
name|ip
operator|=
name|get_pc_function_start
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|end
operator|<
name|fi
operator|->
name|pc
operator|)
condition|?
name|sal
operator|.
name|end
else|:
name|fi
operator|->
name|pc
expr_stmt|;
comment|/* This will fill in fields in *fi as well as in cache_fsr.  */
name|examine_prologue
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|cache_fsr
argument_list|,
name|fi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fsr
condition|)
operator|*
name|fsr
operator|=
operator|*
name|fi
operator|->
name|fsr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or    is not the address of a valid instruction, the address of the next    instruction beyond ADDR otherwise.  *PWORD1 receives the first word    of the instruction.*/
end_comment

begin_function
name|CORE_ADDR
name|NEXT_PROLOGUE_INSN
parameter_list|(
name|addr
parameter_list|,
name|lim
parameter_list|,
name|pword1
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|CORE_ADDR
name|lim
decl_stmt|;
name|short
modifier|*
name|pword1
decl_stmt|;
block|{
if|if
condition|(
name|addr
operator|<
name|lim
operator|+
literal|8
condition|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
name|pword1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pword1
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|pword1
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|addr
operator|+
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Examine the prologue of a function.  `ip' points to the first instruction.    `limit' is the limit of the prologue (e.g. the addr of the first     linenumber, or perhaps the program counter if we're stepping through).    `frame_sp' is the stack pointer value in use in this frame.      `fsr' is a pointer to a frame_saved_regs structure into which we put    info about the registers saved by this frame.      `fi' is a struct frame_info pointer; we fill in various fields in it    to reflect the offsets of the arg pointer and the locals pointer.  */
end_comment

begin_comment
comment|/* We will find two sorts of prologue, framefull and non framefull:        push   r2    push   r3    push   fp    mov    sp,fp    stack_ad      and    push   x    push   y    stack_ad  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|ip
parameter_list|,
name|limit
parameter_list|,
name|after_prolog_fp
parameter_list|,
name|fsr
parameter_list|,
name|fi
parameter_list|)
specifier|register
name|CORE_ADDR
name|ip
decl_stmt|;
specifier|register
name|CORE_ADDR
name|limit
decl_stmt|;
name|FRAME_ADDR
name|after_prolog_fp
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|next_ip
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|have_fp
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|src
decl_stmt|;
specifier|register
name|struct
name|pic_prologue_code
modifier|*
name|pcode
decl_stmt|;
name|INSN_WORD
name|insn_word
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|unsigned
name|int
name|reg_save_depth
init|=
literal|2
decl_stmt|;
comment|/* Number of things pushed onto 				      stack, starts at 2, 'cause the 				      PC is already there */
name|unsigned
name|int
name|auto_depth
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes of autos */
name|char
name|in_frame
index|[
name|NUM_REGS
index|]
decl_stmt|;
comment|/* One for each reg */
name|memset
argument_list|(
name|in_frame
argument_list|,
literal|1
argument_list|,
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_prolog_fp
operator|==
literal|0
condition|)
block|{
name|after_prolog_fp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|==
literal|0
operator|||
name|ip
operator|&
operator|~
literal|0xffff
condition|)
return|return
literal|0
return|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn_word
argument_list|)
expr_stmt|;
comment|/* Skip over any push instructions, and remember where they were saved */
while|while
condition|(
name|next_ip
operator|&&
name|IS_PUSH
argument_list|(
name|insn_word
argument_list|)
condition|)
block|{
name|ip
operator|=
name|next_ip
expr_stmt|;
name|in_frame
index|[
name|insn_word
operator|&
literal|0x7
index|]
operator|=
name|reg_save_depth
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn_word
argument_list|)
expr_stmt|;
name|reg_save_depth
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Is this a move into the fp */
if|if
condition|(
name|next_ip
operator|&&
name|IS_MOV_SP_FP
argument_list|(
name|insn_word
argument_list|)
condition|)
block|{
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn_word
argument_list|)
expr_stmt|;
name|have_fp
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Skip over any stack adjustment, happens either with a number of      sub#2,sp or a mov #x,r5 sub r5,sp */
if|if
condition|(
name|next_ip
operator|&&
name|IS_SUB2_SP
argument_list|(
name|insn_word
argument_list|)
condition|)
block|{
while|while
condition|(
name|next_ip
operator|&&
name|IS_SUB2_SP
argument_list|(
name|insn_word
argument_list|)
condition|)
block|{
name|auto_depth
operator|+=
literal|2
expr_stmt|;
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn_word
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|next_ip
operator|&&
name|IS_MOVK_R5
argument_list|(
name|insn_word
argument_list|)
condition|)
block|{
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn_word
argument_list|)
expr_stmt|;
name|auto_depth
operator|+=
name|insn_word
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
block|}
block|}
comment|/* The args are always reffed based from the stack pointer */
name|fi
operator|->
name|args_pointer
operator|=
name|after_prolog_fp
operator|-
name|auto_depth
expr_stmt|;
comment|/* Locals are always reffed based from the fp */
name|fi
operator|->
name|locals_pointer
operator|=
name|after_prolog_fp
expr_stmt|;
comment|/* The PC is at a known place */
name|fi
operator|->
name|from_pc
operator|=
name|read_memory_short
argument_list|(
name|after_prolog_fp
operator|+
name|reg_save_depth
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Rememeber any others too */
name|in_frame
index|[
name|PC_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|NUM_REGS
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|in_frame
index|[
name|r
index|]
operator|!=
literal|1
condition|)
block|{
name|fsr
operator|->
name|regs
index|[
name|r
index|]
operator|=
name|after_prolog_fp
operator|+
name|reg_save_depth
operator|-
name|in_frame
index|[
name|r
index|]
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fsr
operator|->
name|regs
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_fp
condition|)
comment|/* We keep the old FP in the SP spot */
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
operator|(
name|read_memory_short
argument_list|(
name|fsr
operator|->
name|regs
index|[
literal|6
index|]
argument_list|)
operator|)
expr_stmt|;
else|else
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
name|after_prolog_fp
operator|+
name|reg_save_depth
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_extra_frame_info
parameter_list|(
name|fromleaf
parameter_list|,
name|fi
parameter_list|)
name|int
name|fromleaf
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|fi
operator|->
name|fsr
operator|=
literal|0
expr_stmt|;
comment|/* Not yet allocated */
name|fi
operator|->
name|args_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Unknown */
name|fi
operator|->
name|locals_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Unknown */
name|fi
operator|->
name|from_pc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the saved PC from this frame.     If the frame has a memory copy of SRP_REGNUM, use that.  If not,    just use the register SRP_REGNUM itself.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
return|return
name|frame
operator|->
name|from_pc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|frame_locals_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fi
operator|->
name|locals_pointer
condition|)
block|{
name|struct
name|frame_saved_regs
name|ignore
decl_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|ignore
argument_list|)
expr_stmt|;
block|}
return|return
name|fi
operator|->
name|locals_pointer
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the argument block for the frame    described by FI.  Returns 0 if the address is unknown.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_args_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fi
operator|->
name|args_pointer
condition|)
block|{
name|struct
name|frame_saved_regs
name|ignore
decl_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|ignore
argument_list|)
expr_stmt|;
block|}
return|return
name|fi
operator|->
name|args_pointer
return|;
block|}
end_function

begin_function
name|void
name|h8300_pop_frame
parameter_list|()
block|{
name|unsigned
name|regnum
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|FRAME
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
block|{
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_short
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

