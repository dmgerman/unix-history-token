begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Symbol table lookup for the GNU debugger, GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expensive_mangler
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|find_methods
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
expr|struct
name|symbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|completion_list_add_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symbol
operator|*
index|[]
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rbreak_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|types_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|functions_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|variables_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sources_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_symbols
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_source_filename
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|operator_chars
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_line_common
name|PARAMS
argument_list|(
operator|(
expr|struct
name|linetable
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
expr|enum
name|namespace
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_demangled_partial_symbol
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|partial_symtab
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_demangled_block_symbol
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|block
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|lookup_symtab_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* The single non-language-specific builtin type */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Block in which the most recently searched-for symbol was found.    Might be better to make this a parameter to lookup_symbol and     value_of_this. */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|block
modifier|*
name|block_found
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|no_symtab_msg
index|[]
init|=
literal|"No symbol table is loaded.  Use the \"file\" command."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While the C++ support is still in flux, issue a possibly helpful hint on    using the new command completion feature on single quoted demangled C++    symbols.  Remove when loose ends are cleaned up.   FIXME -fnf */
end_comment

begin_function
name|void
name|cplusplus_hint
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"Hint: try '%s<TAB> or '%s<ESC-?>\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(Note leading single quote.)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for a symtab of a specific name; first in symtabs, then in    psymtabs.  *If* there is no '/' in the name, a match after a '/'    in the symtab filename will also work.  */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|lookup_symtab_1
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|char
modifier|*
name|slash
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|got_symtab
label|:
comment|/* First, search for an exact match */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|s
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
return|return
name|s
return|;
name|slash
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Now, search for a matching tail (only if name doesn't have any dirs) */
if|if
condition|(
operator|!
name|slash
condition|)
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|char
modifier|*
name|p
init|=
name|s
operator|->
name|filename
decl_stmt|;
name|char
modifier|*
name|tail
init|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
condition|)
name|p
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|s
return|;
block|}
comment|/* Same search rules as above apply here, but now we look thru the      psymtabs.  */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|got_psymtab
goto|;
if|if
condition|(
operator|!
name|slash
condition|)
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|char
modifier|*
name|p
init|=
name|ps
operator|->
name|filename
decl_stmt|;
name|char
modifier|*
name|tail
init|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|tail
condition|)
name|p
operator|=
name|tail
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|got_psymtab
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
name|got_psymtab
label|:
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
name|error
argument_list|(
literal|"Internal: readin %s pst for `%s' found when no symtab found."
argument_list|,
name|ps
operator|->
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* At this point, we have located the psymtab for this file, but      the conversion to a symtab has failed.  This usually happens      when we are looking up an include file.  In this case,      PSYMTAB_TO_SYMTAB doesn't return a symtab, even though one has      been created.  So, we need to run through the symtabs again in      order to find the file.      XXX - This is a crock, and should be fixed inside of the the      symbol parsing routines. */
goto|goto
name|got_symtab
goto|;
block|}
end_function

begin_comment
comment|/* Lookup the symbol table of a source file named NAME.  Try a couple    of variations if the first lookup doesn't work.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|lookup_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|copy
decl_stmt|;
name|s
operator|=
name|lookup_symtab_1
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* If name not found as specified, see if adding ".c" helps.  */
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|copy
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|copy
argument_list|,
literal|".c"
argument_list|)
expr_stmt|;
name|s
operator|=
name|lookup_symtab_1
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
comment|/* We didn't find anything; die.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lookup the partial symbol table of a source file named NAME.  This    only returns true on an exact match (ie. this semantics are    different from lookup_symtab.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|lookup_partial_symtab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Demangle a GDB method stub type.  */
end_comment

begin_function
name|char
modifier|*
name|gdb_mangle_name
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
name|int
name|mangled_name_len
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|method
init|=
operator|&
name|f
index|[
name|j
index|]
decl_stmt|;
name|char
modifier|*
name|field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_constructor
init|=
name|strcmp
argument_list|(
name|field_name
argument_list|,
name|newname
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|is_destructor
init|=
name|is_constructor
operator|&&
name|physname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|physname
index|[
literal|1
index|]
operator|==
name|CPLUS_MARKER
operator|&&
name|physname
index|[
literal|2
index|]
operator|==
literal|'_'
decl_stmt|;
comment|/* Need a new type prefix.  */
name|char
modifier|*
name|const_prefix
init|=
name|method
operator|->
name|is_const
condition|?
literal|"C"
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|volatile_prefix
init|=
name|method
operator|->
name|is_volatile
condition|?
literal|"V"
else|:
literal|""
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|GCC_MANGLE_BUG
name|int
name|len
init|=
name|strlen
argument_list|(
name|newname
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_destructor
condition|)
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
name|mangled_name
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s%d"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mangled_name_len
operator|=
operator|(
operator|(
name|is_constructor
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|field_name
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|len
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Only needed for GNU-mangled names.  ANSI-mangled names      work with the normal mechanisms.  */
if|if
condition|(
name|OPNAME_PREFIX_P
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|opname
init|=
name|cplus_mangle_opname
argument_list|(
name|field_name
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|opname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No mangling for \"%s\""
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
name|mangled_name_len
operator|+=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|mangled_name
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constructor
condition|)
name|mangled_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|opname
decl_stmt|;
if|if
condition|(
name|is_constructor
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
block|}
name|mangled_name_len
operator|=
operator|(
operator|(
name|is_constructor
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|field_name
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|physname
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Only needed for GNU-mangled names.  ANSI-mangled names      work with the normal mechanisms.  */
if|if
condition|(
name|OPNAME_PREFIX_P
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|opname
operator|=
name|cplus_mangle_opname
argument_list|(
name|field_name
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opname
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No mangling for \"%s\""
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
name|mangled_name_len
operator|+=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mangled_name
operator|+
literal|3
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mangled_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constructor
condition|)
block|{
name|mangled_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|mangled_name
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|mangled_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
return|return
operator|(
name|mangled_name
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find which partial symtab on contains PC.  Return 0 if none.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_pc_psymtab
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|pc
operator|>=
name|pst
operator|->
name|textlow
operator|&&
name|pc
operator|<
name|pst
operator|->
name|texthigh
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find which partial symbol within a psymtab contains PC.  Return 0    if none.  Check all psymtabs if PSYMTAB is 0.  */
end_comment

begin_function
name|struct
name|partial_symbol
modifier|*
name|find_pc_psymbol
parameter_list|(
name|psymtab
parameter_list|,
name|pc
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|partial_symbol
modifier|*
name|best
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|best_pc
decl_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
name|psymtab
operator|=
name|find_pc_psymtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psymtab
condition|)
return|return
literal|0
return|;
name|best_pc
operator|=
name|psymtab
operator|->
name|textlow
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
init|;
operator|(
name|p
operator|-
operator|(
name|psymtab
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|psymtab
operator|->
name|statics_offset
operator|)
operator|<
name|psymtab
operator|->
name|n_static_syms
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|p
argument_list|)
operator|==
name|VAR_NAMESPACE
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|p
argument_list|)
operator|==
name|LOC_BLOCK
operator|&&
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
operator|>
name|best_pc
condition|)
block|{
name|best_pc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|best_pc
operator|==
name|psymtab
operator|->
name|textlow
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|best
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the definition for a specified symbol name NAME    in namespace NAMESPACE, visible from lexical block BLOCK.    Returns the struct symbol pointer, or zero if no symbol is found.    If SYMTAB is non-NULL, store the symbol table in which the    symbol was found there, or NULL if not found.    C++: if IS_A_FIELD_OF_THIS is nonzero on entry, check to see if    NAME is a field of the current implied argument `this'.  If so set    *IS_A_FIELD_OF_THIS to 1, otherwise set it to zero.     BLOCK_FOUND is set to the block in which NAME is found (in the case of    a field of `this', value_of_this sets BLOCK_FOUND to the proper value.) */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_symbol
parameter_list|(
name|name
parameter_list|,
name|block
parameter_list|,
name|namespace
parameter_list|,
name|is_a_field_of_this
parameter_list|,
name|symtab
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|const
name|enum
name|namespace
name|namespace
decl_stmt|;
name|int
modifier|*
name|is_a_field_of_this
decl_stmt|;
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|gdb_completer_word_break_characters
decl_stmt|;
comment|/* If NAME contains any characters from gdb_completer_word_break_characters      then it is probably from a quoted name string.  So check to see if it      has a C++ mangled equivalent, and if so, use the mangled equivalent. */
if|if
condition|(
name|strpbrk
argument_list|(
name|name
argument_list|,
name|gdb_completer_word_break_characters
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|temp
operator|=
name|expensive_mangler
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|name
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* Search specified block and its superiors.  */
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
comment|/* Search the list of symtabs for one which contains the 		 address of the start of this block.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|found
label|:
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
block|}
return|return
operator|(
name|sym
operator|)
return|;
block|}
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* But that doesn't do any demangling for the STATIC_BLOCK.      I'm not sure whether demangling is needed in the case of      nested function in inner blocks; if so this needs to be changed.            Don't need to mess with the psymtabs; if we have a block,      that file is read in.  If we don't, then we deal later with      all the psymtab stuff that needs checking.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
operator|&&
name|block
operator|!=
name|NULL
condition|)
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
comment|/* Find the right symtab.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|sym
operator|=
name|lookup_demangled_block_symbol
argument_list|(
name|b
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
block|}
block|}
comment|/* C++: If requested to do so by the caller,       check to see if NAME is a field of `this'. */
if|if
condition|(
name|is_a_field_of_this
condition|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|value_of_this
argument_list|(
literal|0
argument_list|)
decl_stmt|;
operator|*
name|is_a_field_of_this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|check_field
argument_list|(
name|v
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|is_a_field_of_this
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Now search all global blocks.  Do the symtab's first, then      check the psymtab's */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
comment|/* Check for the possibility of the symbol being a global function      that is stored in one of the minimal symbol tables.  Eventually, all      global symbols might be resolved in this way.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
block|{
comment|/* Test each minimal symbol to see if the minimal symbol's name 	     is a C++ mangled name that matches a user visible name.  */
name|char
modifier|*
name|demangled
decl_stmt|;
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|msymbol
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
goto|goto
name|found_msym
goto|;
block|}
block|}
name|msymbol
operator|=
name|NULL
expr_stmt|;
comment|/* Not found */
block|}
name|found_msym
label|:
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|msymbol
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* If S is NULL, there are no debug symbols for this file. 	     Skip this stuff and check for matching static symbols below. */
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|msymbol
operator|->
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
comment|/* We kept static functions in minimal symbol table as well as 		 in static scope. We want to find them in the symbol table. */
if|if
condition|(
operator|!
name|sym
condition|)
block|{
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|msymbol
operator|->
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
block|}
comment|/* sym == 0 if symbol was found in the minimal symbol table 		 but not in the symtab. 		 Return 0 to use the msymbol definition of "foo_".  		 This happens for Fortran  "foo_" symbols, 		 which are "foo" in the symtab.  		 This can also happen if "asm" is used to make a 		 regular symbol but not a debugging symbol, e.g. 		 asm(".globl _main"); 		 asm("_main:"); 		 */
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: global symbol `%s' found in %s psymtab but not in symtab"
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
comment|/* Now search all per-file blocks.      Not strictly correct, but more useful than an error.      Do the symtabs first, then check the psymtabs */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|namespace
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: static symbol `%s' found in %s psymtab but not in symtab"
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
comment|/* Now search all per-file blocks for static mangled symbols.      Do the symtabs first, then check the psymtabs.  */
if|if
condition|(
name|namespace
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_demangled_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|block_found
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
operator|&&
name|lookup_demangled_partial_symbol
argument_list|(
name|ps
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_demangled_block_symbol
argument_list|(
name|block
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal: mangled static symbol `%s' found in %s psymtab but not in symtab"
argument_list|,
name|name
argument_list|,
name|ps
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|s
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for a static demangled symbol in block BLOCK.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_demangled_block_symbol
parameter_list|(
name|block
parameter_list|,
name|name
parameter_list|)
specifier|register
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|demangled
decl_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
block|}
name|bot
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look, in partial_symtab PST, for static mangled symbol NAME. */
end_comment

begin_function
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_demangled_partial_symbol
parameter_list|(
name|pst
parameter_list|,
name|name
parameter_list|)
specifier|const
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|partial_symbol
modifier|*
name|start
decl_stmt|,
modifier|*
name|psym
decl_stmt|;
name|int
name|length
init|=
name|pst
operator|->
name|n_static_syms
decl_stmt|;
name|char
modifier|*
name|demangled
decl_stmt|;
if|if
condition|(
operator|!
name|length
condition|)
return|return
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
literal|0
return|;
name|start
operator|=
name|pst
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
expr_stmt|;
for|for
control|(
name|psym
operator|=
name|start
init|;
name|psym
operator|<
name|start
operator|+
name|length
condition|;
name|psym
operator|++
control|)
block|{
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|psym
argument_list|)
operator|==
name|VAR_NAMESPACE
condition|)
block|{
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|psym
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look, in partial_symtab PST, for symbol NAME.  Check the global    symbols if GLOBAL, the static symbols if not */
end_comment

begin_function
specifier|static
name|struct
name|partial_symbol
modifier|*
name|lookup_partial_symbol
parameter_list|(
name|pst
parameter_list|,
name|name
parameter_list|,
name|global
parameter_list|,
name|namespace
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|global
decl_stmt|;
name|enum
name|namespace
name|namespace
decl_stmt|;
block|{
name|struct
name|partial_symbol
modifier|*
name|start
decl_stmt|,
modifier|*
name|psym
decl_stmt|;
name|int
name|length
init|=
operator|(
name|global
condition|?
name|pst
operator|->
name|n_global_syms
else|:
name|pst
operator|->
name|n_static_syms
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|length
condition|)
return|return
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
literal|0
return|;
name|start
operator|=
operator|(
name|global
condition|?
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
else|:
name|pst
operator|->
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
if|if
condition|(
name|global
condition|)
comment|/* This means we can use a binary */
comment|/* search.  */
block|{
name|struct
name|partial_symbol
modifier|*
name|top
decl_stmt|,
modifier|*
name|bottom
decl_stmt|,
modifier|*
name|center
decl_stmt|;
comment|/* Binary search.  This search is guaranteed to end with center          pointing at the earliest partial symbol with the correct 	 name.  At that point *all* partial symbols with that name 	 will be checked against the correct namespace. */
name|bottom
operator|=
name|start
expr_stmt|;
name|top
operator|=
name|start
operator|+
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|top
operator|>
name|bottom
condition|)
block|{
name|center
operator|=
name|bottom
operator|+
operator|(
name|top
operator|-
name|bottom
operator|)
operator|/
literal|2
expr_stmt|;
name|assert
argument_list|(
name|center
operator|<
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|center
argument_list|)
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
name|top
operator|=
name|center
expr_stmt|;
else|else
name|bottom
operator|=
name|center
operator|+
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
name|top
operator|==
name|bottom
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|top
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|top
argument_list|)
operator|==
name|namespace
condition|)
return|return
name|top
return|;
name|top
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Can't use a binary search */
for|for
control|(
name|psym
operator|=
name|start
init|;
name|psym
operator|<
name|start
operator|+
name|length
condition|;
name|psym
operator|++
control|)
if|if
condition|(
name|namespace
operator|==
name|SYMBOL_NAMESPACE
argument_list|(
name|psym
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|)
condition|)
return|return
name|psym
return|;
block|}
return|return
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the psymtab containing main(). */
end_comment

begin_comment
comment|/* FIXME:  What about languages without main() or specially linked    executables that have no main() ? */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_main_psymtab
parameter_list|()
block|{
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|lookup_partial_symbol
argument_list|(
name|pst
argument_list|,
literal|"main"
argument_list|,
literal|1
argument_list|,
name|VAR_NAMESPACE
argument_list|)
condition|)
block|{
return|return
operator|(
name|pst
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look for a symbol in block BLOCK.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|lookup_block_symbol
parameter_list|(
name|block
parameter_list|,
name|name
parameter_list|,
name|namespace
parameter_list|)
specifier|register
specifier|const
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|enum
name|namespace
name|namespace
decl_stmt|;
block|{
specifier|register
name|int
name|bot
decl_stmt|,
name|top
decl_stmt|,
name|inc
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|parameter_sym
decl_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|bot
operator|=
literal|0
expr_stmt|;
comment|/* If the blocks's symbols were sorted, start with a binary search.  */
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* First, advance BOT to not far before 	 the first symbol whose name is NAME.  */
while|while
condition|(
literal|1
condition|)
block|{
name|inc
operator|=
operator|(
name|top
operator|-
name|bot
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* No need to keep binary searching for the last few bits worth.  */
if|if
condition|(
name|inc
operator|<
literal|4
condition|)
break|break;
name|inc
operator|=
operator|(
name|inc
operator|>>
literal|1
operator|)
operator|+
name|bot
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|<
name|name
index|[
literal|0
index|]
condition|)
name|bot
operator|=
name|inc
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
name|top
operator|=
name|inc
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
name|bot
operator|=
name|inc
expr_stmt|;
else|else
name|top
operator|=
name|inc
expr_stmt|;
block|}
comment|/* Now scan forward until we run out of symbols, 	 find one whose name is greater than NAME, 	 or find one we want. 	 If there is more than one symbol with the right name and namespace, 	 we return the first one.  dbxread.c is careful to make sure 	 that if one is a register then it comes first.  */
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
name|inc
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|-
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
name|inc
operator|=
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
condition|)
return|return
name|sym
return|;
if|if
condition|(
name|inc
operator|>
literal|0
condition|)
return|return
literal|0
return|;
name|bot
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Here if block isn't sorted.      This loop is equivalent to the loop above,      but hacked greatly for speed.       Note that parameter symbols do not always show up last in the      list; this loop makes sure to take anything else other than      parameter symbols first; it only uses parameter symbols as a      last resort.  Note that this only takes up extra computation      time on a match.  */
name|parameter_sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
literal|0
expr_stmt|;
name|top
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|inc
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|bot
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|==
name|inc
operator|&&
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|namespace
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LOCAL_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REF_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
condition|)
name|parameter_sym
operator|=
name|sym
expr_stmt|;
else|else
return|return
name|sym
return|;
block|}
name|bot
operator|++
expr_stmt|;
block|}
return|return
name|parameter_sym
return|;
comment|/* Will be 0 if not found. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the symbol for the function which contains a specified    lexical block, described by a struct block BL.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|block_function
parameter_list|(
name|bl
parameter_list|)
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
block|{
while|while
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
operator|==
literal|0
operator|&&
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
operator|!=
literal|0
condition|)
name|bl
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
expr_stmt|;
return|return
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of find_pc_line */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|find_pc_symtab
parameter_list|(
name|pc
parameter_list|)
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* Search all symtabs for one whose file contains our pc */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|<=
name|pc
operator|&&
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|>
name|pc
condition|)
goto|goto
name|found
goto|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|ps
operator|=
name|find_pc_psymtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|&&
name|ps
operator|->
name|readin
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"(Internal error: pc 0x%x in read in psymtab, but not in symtab.)\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
condition|)
block|{
name|s
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
name|found
label|:
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the source file and line number for a given PC value.    Return a structure containing a symtab pointer, a line number,    and a pc range for the entire source line.    The value's .pc field is NOT the specified pc.    NOTCURRENT nonzero means, if specified pc is on a line boundary,    use the line that ends there.  Otherwise, in that case, the line    that begins there is used.  */
end_comment

begin_function
name|struct
name|symtab_and_line
name|find_pc_line
parameter_list|(
name|pc
parameter_list|,
name|notcurrent
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|notcurrent
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
decl_stmt|;
name|struct
name|symtab_and_line
name|val
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
comment|/* Info on best line seen so far, and where it starts, and its file.  */
name|int
name|best_line
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|best_pc
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|best_end
init|=
literal|0
decl_stmt|;
name|struct
name|symtab
modifier|*
name|best_symtab
init|=
literal|0
decl_stmt|;
comment|/* Store here the first line number      of a file which contains the line at the smallest pc after PC.      If we don't find a line whose range contains PC,      we will use a line one less than this,      with a range from the start of that file to the first line's pc.  */
name|int
name|alt_line
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|alt_pc
init|=
literal|0
decl_stmt|;
name|struct
name|symtab
modifier|*
name|alt_symtab
init|=
literal|0
decl_stmt|;
comment|/* Info on best line seen in this file.  */
name|int
name|prev_line
decl_stmt|;
name|CORE_ADDR
name|prev_pc
decl_stmt|;
comment|/* Info on first line of this file.  */
name|int
name|first_line
decl_stmt|;
name|CORE_ADDR
name|first_pc
decl_stmt|;
comment|/* If this pc is not from the current frame,      it is the address of the end of a call instruction.      Quite likely that is the start of the following statement.      But what we want is the statement containing the instruction.      Fudge the pc to make sure we get that.  */
if|if
condition|(
name|notcurrent
condition|)
name|pc
operator|-=
literal|1
expr_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|val
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|val
operator|.
name|end
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Look at all the symtabs that share this blockvector.      They all have the same apriori range, that we found was right;      but they have different line tables.  */
for|for
control|(
init|;
name|s
operator|&&
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
operator|==
name|bv
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Find the best line in this symtab.  */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
continue|continue;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
name|prev_line
operator|=
operator|-
literal|1
expr_stmt|;
name|first_line
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|=
operator|&
operator|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|first_line
operator|<
literal|0
condition|)
block|{
name|first_line
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|first_pc
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
comment|/* Return the last line that did not start after PC.  */
if|if
condition|(
name|pc
operator|>=
name|item
operator|->
name|pc
condition|)
block|{
name|prev_line
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|prev_pc
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Is this file's best line closer than the best in the other files? 	 If so, record this file, and its best line, as best so far.  */
if|if
condition|(
name|prev_line
operator|>=
literal|0
operator|&&
name|prev_pc
operator|>
name|best_pc
condition|)
block|{
name|best_pc
operator|=
name|prev_pc
expr_stmt|;
name|best_line
operator|=
name|prev_line
expr_stmt|;
name|best_symtab
operator|=
name|s
expr_stmt|;
comment|/* If another line is in the linetable, and its PC is closer 	     than the best_end we currently have, take it as best_end.  */
if|if
condition|(
name|i
operator|<
name|len
operator|&&
operator|(
name|best_end
operator|==
literal|0
operator|||
name|best_end
operator|>
name|item
operator|->
name|pc
operator|)
condition|)
name|best_end
operator|=
name|item
operator|->
name|pc
expr_stmt|;
block|}
comment|/* Is this file's first line closer than the first lines of other files? 	 If so, record this file, and its first line, as best alternate.  */
if|if
condition|(
name|first_line
operator|>=
literal|0
operator|&&
name|first_pc
operator|>
name|pc
operator|&&
operator|(
name|alt_pc
operator|==
literal|0
operator|||
name|first_pc
operator|<
name|alt_pc
operator|)
condition|)
block|{
name|alt_pc
operator|=
name|first_pc
expr_stmt|;
name|alt_line
operator|=
name|first_line
expr_stmt|;
name|alt_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_symtab
operator|==
literal|0
condition|)
block|{
name|val
operator|.
name|symtab
operator|=
name|alt_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|alt_line
operator|-
literal|1
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|alt_pc
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|symtab
operator|=
name|best_symtab
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|best_line
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|best_pc
expr_stmt|;
if|if
condition|(
name|best_end
operator|&&
operator|(
name|alt_pc
operator|==
literal|0
operator|||
name|best_end
operator|<
name|alt_pc
operator|)
condition|)
name|val
operator|.
name|end
operator|=
name|best_end
expr_stmt|;
elseif|else
if|if
condition|(
name|alt_pc
condition|)
name|val
operator|.
name|end
operator|=
name|alt_pc
expr_stmt|;
else|else
name|val
operator|.
name|end
operator|=
name|BLOCK_END
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the PC value for a given source file and line number.    Returns zero for invalid line number.    The source file is specified with a struct symtab.  */
end_comment

begin_function
name|CORE_ADDR
name|find_line_pc
parameter_list|(
name|symtab
parameter_list|,
name|line
parameter_list|)
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|ind
decl_stmt|;
name|int
name|dummy
decl_stmt|;
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|ind
operator|=
name|find_line_common
argument_list|(
name|l
argument_list|,
name|line
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
return|return
operator|(
name|ind
operator|>=
literal|0
operator|)
condition|?
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the range of pc values in a line.    Store the starting pc of the line into *STARTPTR    and the ending pc (start of next line) into *ENDPTR.    Returns 1 to indicate success.    Returns 0 if could not find the specified line.  */
end_comment

begin_function
name|int
name|find_line_pc_range
parameter_list|(
name|symtab
parameter_list|,
name|thisline
parameter_list|,
name|startptr
parameter_list|,
name|endptr
parameter_list|)
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|thisline
decl_stmt|;
name|CORE_ADDR
modifier|*
name|startptr
decl_stmt|,
decl|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|ind
decl_stmt|;
name|int
name|exact_match
decl_stmt|;
comment|/* did we get an exact linenumber match */
if|if
condition|(
name|symtab
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|l
operator|=
name|LINETABLE
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|ind
operator|=
name|find_line_common
argument_list|(
name|l
argument_list|,
name|thisline
argument_list|,
operator|&
name|exact_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
literal|0
condition|)
block|{
operator|*
name|startptr
operator|=
name|l
operator|->
name|item
index|[
name|ind
index|]
operator|.
name|pc
expr_stmt|;
comment|/* If we have not seen an entry for the specified line, 	 assume that means the specified line has zero bytes.  */
if|if
condition|(
operator|!
name|exact_match
operator|||
name|ind
operator|==
name|l
operator|->
name|nitems
operator|-
literal|1
condition|)
operator|*
name|endptr
operator|=
operator|*
name|startptr
expr_stmt|;
elseif|else
comment|/* Perhaps the following entry is for the following line. 	   It's worth a try.  */
if|if
condition|(
name|ind
operator|+
literal|1
operator|<
name|l
operator|->
name|nitems
operator|&&
name|l
operator|->
name|item
index|[
name|ind
operator|+
literal|1
index|]
operator|.
name|line
operator|==
name|thisline
operator|+
literal|1
condition|)
operator|*
name|endptr
operator|=
name|l
operator|->
name|item
index|[
name|ind
operator|+
literal|1
index|]
operator|.
name|pc
expr_stmt|;
else|else
operator|*
name|endptr
operator|=
name|find_line_pc
argument_list|(
name|symtab
argument_list|,
name|thisline
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Given a line table and a line number, return the index into the line    table for the pc of the nearest line whose number is>= the specified one.    Return -1 if none is found.  The value is>= 0 if it is an index.     Set *EXACT_MATCH nonzero if the value returned is an exact match.  */
end_comment

begin_function
specifier|static
name|int
name|find_line_common
parameter_list|(
name|l
parameter_list|,
name|lineno
parameter_list|,
name|exact_match
parameter_list|)
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|lineno
decl_stmt|;
name|int
modifier|*
name|exact_match
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
comment|/* BEST is the smallest linenumber> LINENO so far seen,      or 0 if none has been seen so far.      BEST_INDEX identifies the item for it.  */
name|int
name|best_index
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|best
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lineno
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|linetable_entry
modifier|*
name|item
init|=
operator|&
operator|(
name|l
operator|->
name|item
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|line
operator|==
name|lineno
condition|)
block|{
operator|*
name|exact_match
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|item
operator|->
name|line
operator|>
name|lineno
operator|&&
operator|(
name|best
operator|==
literal|0
operator|||
name|item
operator|->
name|line
operator|<
name|best
operator|)
condition|)
block|{
name|best
operator|=
name|item
operator|->
name|line
expr_stmt|;
name|best_index
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If we got here, we didn't get an exact match.  */
operator|*
name|exact_match
operator|=
literal|0
expr_stmt|;
return|return
name|best_index
return|;
block|}
end_function

begin_function
name|int
name|find_pc_line_pc_range
parameter_list|(
name|pc
parameter_list|,
name|startptr
parameter_list|,
name|endptr
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|startptr
decl_stmt|,
decl|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|startptr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
operator|*
name|endptr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
return|return
name|sal
operator|.
name|symtab
operator|!=
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* If P is of the form "operator[ \t]+..." where `...' is    some legitimate operator text, return a pointer to the    beginning of the substring of the operator text.    Otherwise, return "".  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|operator_chars
parameter_list|(
name|p
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|end
decl_stmt|;
block|{
operator|*
name|end
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"operator"
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|*
name|end
return|;
name|p
operator|+=
literal|8
expr_stmt|;
comment|/* Don't get faked out by `operator' being part of a longer      identifier.  */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|*
name|end
return|;
comment|/* Allow some whitespace between `operator' and the operator symbol.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Recognize 'operator TYPENAME'. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|||
operator|*
name|q
operator|==
literal|'$'
condition|)
name|q
operator|++
expr_stmt|;
operator|*
name|end
operator|=
name|q
expr_stmt|;
return|return
name|p
return|;
block|}
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'='
operator|||
name|p
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
condition|)
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
else|else
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'~'
case|:
case|case
literal|','
case|:
operator|*
name|end
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|')'
condition|)
name|error
argument_list|(
literal|"`operator ()' must be specified without whitespace in `()'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'?'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
name|error
argument_list|(
literal|"`operator ?:' must be specified without whitespace in `?:'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
case|case
literal|'['
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
name|error
argument_list|(
literal|"`operator []' must be specified without whitespace in `[]'"
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|p
operator|+
literal|2
expr_stmt|;
return|return
name|p
return|;
default|default:
name|error
argument_list|(
literal|"`operator %s' not supported"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|end
operator|=
literal|""
expr_stmt|;
return|return
operator|*
name|end
return|;
block|}
end_function

begin_comment
comment|/* Recursive helper function for decode_line_1.  * Look for methods named NAME in type T.  * Return number of matches.  * Put matches in PHYSNAMES and SYM_ARR (which better be big enough!).  * These allocations seem to define "big enough":  * sym_arr = (struct symbol **) alloca(TYPE_NFN_FIELDS_TOTAL (t) * sizeof(struct symbol*));  * physnames = (char **) alloca (TYPE_NFN_FIELDS_TOTAL (t) * sizeof(char*));  */
end_comment

begin_function
name|int
name|find_methods
parameter_list|(
name|t
parameter_list|,
name|name
parameter_list|,
name|physnames
parameter_list|,
name|sym_arr
parameter_list|)
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|physnames
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
block|{
name|int
name|i1
init|=
literal|0
decl_stmt|;
name|int
name|ibase
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|char
modifier|*
name|class_name
init|=
name|type_name_no_tag
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Ignore this class if it doesn't have a name.      This prevents core dumps, but is just a workaround      because we might not find the function in      certain cases, such as      struct D {virtual int f();}      struct C : D {virtual int g();}      (in this case g++ 1.35.1- does not put out a name      for D as such, it defines type 19 (for example) in      the same stab as C, and then does a      .stabs "D:T19" and a .stabs "D:t19".      Thus      "break C::f" should not be looking for field f in      the class named D,       but just for the field f in the baseclasses of C      (no matter what their names).            However, I don't know how to replace the code below      that depends on knowing the name of D.  */
if|if
condition|(
name|class_name
operator|&&
operator|(
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|class_name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|int
name|method_counter
decl_stmt|;
name|t
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
expr_stmt|;
for|for
control|(
name|method_counter
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|method_counter
operator|>=
literal|0
condition|;
operator|--
name|method_counter
control|)
block|{
name|int
name|field_counter
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|method_name
argument_list|)
condition|)
comment|/* Find all the fields with that name.  */
for|for
control|(
name|field_counter
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|)
operator|-
literal|1
init|;
name|field_counter
operator|>=
literal|0
condition|;
operator|--
name|field_counter
control|)
block|{
name|char
modifier|*
name|phys_name
decl_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|t
argument_list|,
name|method_counter
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
name|phys_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|field_counter
argument_list|)
expr_stmt|;
name|physnames
index|[
name|i1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|phys_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|physnames
index|[
name|i1
index|]
argument_list|,
name|phys_name
argument_list|)
expr_stmt|;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
else|else
block|{
name|fputs_filtered
argument_list|(
literal|"(Cannot find method "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|phys_name
argument_list|,
name|stdout
argument_list|,
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" - possibly inlined.)\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Only search baseclasses if there is no match yet,    * since names in derived classes override those in baseclasses.    */
if|if
condition|(
name|i1
condition|)
return|return
name|i1
return|;
for|for
control|(
name|ibase
operator|=
literal|0
init|;
name|ibase
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|ibase
operator|++
control|)
name|i1
operator|+=
name|find_methods
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|ibase
argument_list|)
argument_list|,
name|name
argument_list|,
name|physnames
operator|+
name|i1
argument_list|,
name|sym_arr
operator|+
name|i1
argument_list|)
expr_stmt|;
return|return
name|i1
return|;
block|}
end_function

begin_comment
comment|/* Parse a string that specifies a line number.    Pass the address of a char * variable; that variable will be    advanced over the characters actually parsed.     The string can be:     LINENUM -- that line number in current file.  PC returned is 0.    FILE:LINENUM -- that line in that file.  PC returned is 0.    FUNCTION -- line number of openbrace of that function.       PC returned is the start of the function.    VARIABLE -- line number of definition of that variable.       PC returned is 0.    FILE:FUNCTION -- likewise, but prefer functions in that file.    *EXPR -- line in which address EXPR appears.     FUNCTION may be an undebuggable function found in minimal symbol table.     If the argument FUNFIRSTLINE is nonzero, we want the first line    of real code inside a function when a function is specified.     DEFAULT_SYMTAB specifies the file to use if none is specified.    It defaults to current_source_symtab.    DEFAULT_LINE specifies the line number to use for relative    line numbers (that start with signs).  Defaults to current_source_line.     Note that it is possible to return zero for the symtab    if no file is validly specified.  Callers must check that.    Also, the line number returned may be invalid.  */
end_comment

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_1
parameter_list|(
name|argptr
parameter_list|,
name|funfirstline
parameter_list|,
name|default_symtab
parameter_list|,
name|default_line
parameter_list|)
name|char
modifier|*
modifier|*
name|argptr
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
name|struct
name|symtab
modifier|*
name|default_symtab
decl_stmt|;
name|int
name|default_line
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|;
ifdef|#
directive|ifdef
name|HPPA_COMPILER_BUG
comment|/* FIXME: The native HP 9000/700 compiler has a bug which appears      when optimizing this file with target i960-vxworks.  I haven't      been able to construct a simple test case.  The problem is that      in the second call to SKIP_PROLOGUE below, the compiler somehow      does not realize that the statement val = find_pc_line (...) will      change the values of the fields of val.  It extracts the elements      into registers at the top of the block, and does not update the      registers after the call to find_pc_line.  You can check this by      inserting a printf at the end of find_pc_line to show what values      it is returning for val.pc and val.end and another printf after      the call to see what values the function actually got (remember,      this is compiling with cc -O, with this patch removed).  You can      also examine the assembly listing: search for the second call to      skip_prologue; the LDO statement before the next call to      find_pc_line loads the address of the structure which      find_pc_line will return; if there is a LDW just before the LDO,      which fetches an element of the structure, then the compiler      still has the bug.       Setting val to volatile avoids the problem.  We must undef      volatile, because the HPPA native compiler does not define      __STDC__, although it does understand volatile, and so volatile      will have been defined away in defs.h.  */
undef|#
directive|undef
name|volatile
specifier|volatile
name|struct
name|symtab_and_line
name|val
decl_stmt|;
define|#
directive|define
name|volatile
comment|/*nothing*/
else|#
directive|else
name|struct
name|symtab_and_line
name|val
decl_stmt|;
endif|#
directive|endif
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|q1
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* The symtab that SYM was found in.  */
name|struct
name|symtab
modifier|*
name|sym_symtab
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym_class
decl_stmt|;
name|int
name|i1
decl_stmt|;
name|int
name|is_quoted
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|sym_arr
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
modifier|*
name|physnames
decl_stmt|;
name|char
modifier|*
name|saved_arg
init|=
operator|*
name|argptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|gdb_completer_quote_characters
decl_stmt|;
comment|/* Defaults have defaults.  */
if|if
condition|(
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
comment|/* See if arg is *PC */
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'*'
condition|)
block|{
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
block|}
name|pc
operator|=
name|parse_and_eval_address_1
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Maybe arg is FILE : LINENUM or FILE : FUNCTION */
name|s
operator|=
name|NULL
expr_stmt|;
name|is_quoted
operator|=
operator|(
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
operator|*
operator|*
name|argptr
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|argptr
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
break|break;
block|}
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|!
name|is_quoted
condition|)
block|{
comment|/*  C++  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Extract the class name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Discard the class name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym_class
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_class
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
condition|)
block|{
comment|/* Arg token is not digits => try it as a function name 		 Find the next token (everything up to end or next whitespace). */
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|operator_chars
argument_list|(
operator|*
name|argptr
argument_list|,
operator|&
name|q1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|-
name|q
condition|)
block|{
name|char
modifier|*
name|opname
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|alloca
argument_list|(
name|q1
operator|-
name|q
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|q
argument_list|,
name|q1
operator|-
name|q
argument_list|)
expr_stmt|;
name|tmp
index|[
name|q1
operator|-
name|q
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opname
operator|=
name|cplus_mangle_opname
argument_list|(
name|tmp
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|opname
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"no mangling for \"%s\""
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cplusplus_hint
argument_list|(
name|saved_arg
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|()
expr_stmt|;
block|}
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|opname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|copy
argument_list|,
literal|"__%s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|p
operator|=
name|q1
expr_stmt|;
block|}
else|else
block|{
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
operator|+
operator|(
name|q1
operator|-
name|q
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* no line number may be specified */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
name|sym
operator|=
literal|0
expr_stmt|;
name|i1
operator|=
literal|0
expr_stmt|;
comment|/*  counter for the symbol array */
name|t
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym_class
argument_list|)
expr_stmt|;
name|sym_arr
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|physnames
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructor_name_p
argument_list|(
name|copy
argument_list|,
name|t
argument_list|)
condition|)
block|{
comment|/* destructors are a special case.  */
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|phys_name
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|physnames
index|[
name|i1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|phys_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|physnames
index|[
name|i1
index|]
argument_list|,
name|phys_name
argument_list|)
expr_stmt|;
name|sym_arr
index|[
name|i1
index|]
operator|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym_class
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_arr
index|[
name|i1
index|]
condition|)
name|i1
operator|++
expr_stmt|;
block|}
else|else
name|i1
operator|=
name|find_methods
argument_list|(
name|t
argument_list|,
name|copy
argument_list|,
name|physnames
argument_list|,
name|sym_arr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
literal|1
condition|)
block|{
comment|/* There is exactly one field with that name.  */
name|sym
operator|=
name|sym_arr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|=
operator|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|end
operator|&&
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
operator|!=
name|pc
operator|)
condition|?
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|end
else|:
name|pc
expr_stmt|;
block|}
else|else
block|{
name|values
operator|.
name|nelts
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
block|{
comment|/* There is more than one field with that name 		     (overloaded).  Ask the user which one to use.  */
return|return
name|decode_line_2
argument_list|(
name|sym_arr
argument_list|,
name|i1
argument_list|,
name|funfirstline
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|OPNAME_PREFIX_P
argument_list|(
name|copy
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|copy
operator|+
literal|3
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|copy
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|copy
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|warning
argument_list|(
literal|"the class `%s' does not have destructor defined"
argument_list|,
name|sym_class
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"the class %s does not have any method named %s"
argument_list|,
name|sym_class
operator|->
name|name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cplusplus_hint
argument_list|(
name|saved_arg
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The quotes are important if copy is empty.  */
name|warning
argument_list|(
literal|"can't find class, struct, or union named \"%s\""
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|cplusplus_hint
argument_list|(
name|saved_arg
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*  end of C++  */
comment|/* Extract the file name.  */
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|p
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Find that file's data.  */
name|s
operator|=
name|lookup_symtab
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No source file named %s."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Discard the file name from the arg.  */
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
block|}
comment|/* S is specified file's symtab, or 0 if no file specified.      arg no longer contains the file name.  */
comment|/* Check whether arg is all digits (and sign) */
name|p
operator|=
operator|*
name|argptr
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
operator|*
name|argptr
operator|&&
operator|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|','
operator|)
condition|)
block|{
comment|/* We found a token consisting of all digits -- at least one digit.  */
enum|enum
name|sign
block|{
name|none
block|,
name|plus
block|,
name|minus
block|}
name|sign
init|=
name|none
enum|;
comment|/* This is where we need to make sure that we have good defaults. 	 We must guarantee that this section of code is never executed 	 when we are called with just a function name, since 	 select_source_symtab calls us with such an argument  */
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|default_symtab
operator|==
literal|0
condition|)
block|{
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|default_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|default_line
operator|=
name|current_source_line
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'+'
condition|)
name|sign
operator|=
name|plus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argptr
operator|==
literal|'-'
condition|)
name|sign
operator|=
name|minus
operator|,
operator|(
operator|*
name|argptr
operator|)
operator|++
expr_stmt|;
name|val
operator|.
name|line
operator|=
name|atoi
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
name|plus
case|:
if|if
condition|(
name|p
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|+
name|val
operator|.
name|line
expr_stmt|;
break|break;
case|case
name|minus
case|:
if|if
condition|(
name|p
operator|==
operator|*
name|argptr
condition|)
name|val
operator|.
name|line
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|val
operator|.
name|line
operator|=
name|default_line
operator|-
name|val
operator|.
name|line
expr_stmt|;
else|else
name|val
operator|.
name|line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|none
case|:
break|break;
comment|/* No need to adjust val.line.  */
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|s
operator|=
name|default_symtab
expr_stmt|;
name|val
operator|.
name|symtab
operator|=
name|s
expr_stmt|;
name|val
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
comment|/* Arg token is not digits => try it as a variable name      Find the next token (everything up to end or next whitespace).  */
name|p
operator|=
name|skip_quoted
argument_list|(
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|argptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
operator|*
name|argptr
argument_list|,
name|p
operator|-
operator|*
name|argptr
argument_list|)
expr_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|copy
index|[
literal|0
index|]
operator|==
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|)
operator|&&
name|strchr
argument_list|(
name|gdb_completer_quote_characters
argument_list|,
name|copy
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|copy
index|[
name|p
operator|-
operator|*
name|argptr
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|copy
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|expensive_mangler
argument_list|(
name|copy
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|copy
operator|=
name|temp
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|argptr
operator|=
name|p
expr_stmt|;
comment|/* Look up that token as a variable.      If file specified, use that file's per-file block to start with.  */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|copy
argument_list|,
operator|(
name|s
condition|?
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
else|:
name|get_selected_block
argument_list|()
operator|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|&
name|sym_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|val
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* Convex: no need to suppress code on first line, if any */
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
else|#
directive|else
comment|/* If SKIP_PROLOGUE left us in mid-line, and the next line is still 	     part of the same function: 		advance to next line,  	        recalculate its line number (might not be N+1).  */
if|if
condition|(
name|val
operator|.
name|pc
operator|!=
name|pc
operator|&&
name|val
operator|.
name|end
operator|&&
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
operator|==
name|lookup_minimal_symbol_by_pc
argument_list|(
name|val
operator|.
name|end
argument_list|)
condition|)
block|{
name|pc
operator|=
name|val
operator|.
name|end
expr_stmt|;
comment|/* First pc of next line */
name|val
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|val
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
endif|#
directive|endif
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
comment|/* I think this is always the same as the line that 	     we calculate above, but the general principle is 	     "trust the symbols more than stuff like 	     SKIP_PROLOGUE".  */
if|if
condition|(
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
condition|)
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|line
operator|=
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We know its line number.  */
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|values
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|symtab
operator|=
name|sym_symtab
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|line
operator|=
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
else|else
comment|/* This can happen if it is compiled with a compiler which doesn't 	   put out line numbers for variables.  */
name|error
argument_list|(
literal|"Line number not known for symbol \"%s\""
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|copy
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|val
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|pc
operator|=
name|msymbol
operator|->
name|address
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|val
operator|.
name|pc
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|values
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
return|return
name|values
return|;
block|}
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
operator|&&
operator|!
name|have_minimal_symbols
argument_list|()
condition|)
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Function \"%s\" not defined."
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
name|values
return|;
comment|/* for lint */
block|}
end_function

begin_function
name|struct
name|symtabs_and_lines
name|decode_line_spec
parameter_list|(
name|string
parameter_list|,
name|funfirstline
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Empty line specification."
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|string
argument_list|,
name|funfirstline
argument_list|,
name|current_source_symtab
argument_list|,
name|current_source_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification: %s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|sals
return|;
block|}
end_function

begin_comment
comment|/* Given a list of NELTS symbols in sym_arr (with corresponding    mangled names in physnames), return a list of lines to operate on    (ask user if necessary).  */
end_comment

begin_function
specifier|static
name|struct
name|symtabs_and_lines
name|decode_line_2
parameter_list|(
name|sym_arr
parameter_list|,
name|nelts
parameter_list|,
name|funfirstline
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym_arr
index|[]
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|int
name|funfirstline
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|values
decl_stmt|,
name|return_values
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|demangled
decl_stmt|;
name|values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|alloca
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"[0] cancel\n[1] all\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nelts
condition|)
block|{
if|if
condition|(
name|sym_arr
index|[
name|i
index|]
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
block|{
comment|/* Arg is the name of a function */
name|pc
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
expr_stmt|;
if|if
condition|(
name|funfirstline
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
operator|=
operator|(
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|end
operator|&&
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|pc
operator|!=
name|pc
operator|)
condition|?
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|end
else|:
name|pc
expr_stmt|;
name|demangled
operator|=
name|cplus_demangle
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%d] %s at %s:%d\n"
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|,
name|demangled
condition|?
name|demangled
else|:
name|SYMBOL_NAME
argument_list|(
name|sym_arr
index|[
name|i
index|]
argument_list|)
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|values
operator|.
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"?HERE\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prompt
operator|=
name|getenv
argument_list|(
literal|"PS2"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|prompt
operator|=
literal|">"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|args
operator|=
name|command_line_input
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"one or more choice numbers"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|int
name|num
decl_stmt|;
name|arg1
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|>=
literal|'0'
operator|&&
operator|*
name|arg1
operator|<=
literal|'9'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|&&
operator|*
name|arg1
operator|!=
literal|' '
operator|&&
operator|*
name|arg1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be choice numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cancelled"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|return_values
operator|.
name|sals
argument_list|,
name|values
operator|.
name|sals
argument_list|,
operator|(
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|return_values
operator|.
name|nelts
operator|=
name|nelts
expr_stmt|;
return|return
name|return_values
return|;
block|}
if|if
condition|(
name|num
operator|>
name|nelts
operator|+
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"No choice number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
condition|)
block|{
name|return_values
operator|.
name|sals
index|[
name|i
operator|++
index|]
operator|=
name|values
operator|.
name|sals
index|[
name|num
index|]
expr_stmt|;
name|values
operator|.
name|sals
index|[
name|num
index|]
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"duplicate request for %d ignored.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
name|args
operator|=
name|arg1
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
block|}
name|return_values
operator|.
name|nelts
operator|=
name|i
expr_stmt|;
return|return
name|return_values
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Slave routine for sources_info.  Force line breaks at ,'s.    NAME is the name to print and *FIRST is nonzero if this is the first    name printed.  Set *FIRST to zero.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_filename
parameter_list|(
name|name
parameter_list|,
name|first
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|first
decl_stmt|;
block|{
comment|/* Table of files printed so far.  Since a single source file can      result in several partial symbol tables, we need to avoid printing      it more than once.  Note: if some of the psymtabs are read in and      some are not, it gets printed both under "Source files for which      symbols have been read" and "Source files for which symbols will      be read in on demand".  I consider this a reasonable way to deal      with the situation.  I'm not sure whether this can also happen for      symtabs; it doesn't hurt to check.  */
specifier|static
name|char
modifier|*
modifier|*
name|tab
init|=
name|NULL
decl_stmt|;
comment|/* Allocated size of tab in elements.      Start with one 256-byte block (when using GNU malloc.c).      24 is the malloc overhead when range checking is in effect.  */
specifier|static
name|int
name|tab_alloc_size
init|=
operator|(
literal|256
operator|-
literal|24
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* Current size of tab in elements.  */
specifier|static
name|int
name|tab_cur_size
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|first
condition|)
block|{
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
name|tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
name|tab_cur_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Is NAME in tab?  */
for|for
control|(
name|p
operator|=
name|tab
init|;
name|p
operator|<
name|tab
operator|+
name|tab_cur_size
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* Yes; don't print it again.  */
return|return;
comment|/* No; add it to tab.  */
if|if
condition|(
name|tab_cur_size
operator|==
name|tab_alloc_size
condition|)
block|{
name|tab_alloc_size
operator|*=
literal|2
expr_stmt|;
name|tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|tab_alloc_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tab
index|[
name|tab_cur_size
operator|++
index|]
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|first
condition|)
block|{
operator|*
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sources_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
block|{
name|error
argument_list|(
name|no_symtab_msg
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Source files for which symbols have been read in:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|output_source_filename
argument_list|(
name|s
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source files for which symbols will be read in on demand:\n\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
if|if
condition|(
operator|!
name|ps
operator|->
name|readin
condition|)
block|{
name|output_source_filename
argument_list|(
name|ps
operator|->
name|filename
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|name_match
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
init|=
name|cplus_demangle
argument_list|(
name|name
argument_list|,
name|DMGL_ANSI
argument_list|)
decl_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|int
name|cond
init|=
name|re_exec
argument_list|(
name|demangled
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|cond
operator|)
return|;
block|}
return|return
operator|(
name|re_exec
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NAME_MATCH
parameter_list|(
name|NAME
parameter_list|)
value|name_match(NAME)
end_define

begin_comment
comment|/* List all symbols (if REGEXP is 0) or all symbols matching REGEXP.    If CLASS is zero, list all symbols except functions, type names, and 		     constants (enums).    If CLASS is 1, list only functions.    If CLASS is 2, list only type names.    If CLASS is 3, list only method names.     BPT is non-zero if we should set a breakpoint at the functions    we find.  */
end_comment

begin_function
specifier|static
name|void
name|list_symbols
parameter_list|(
name|regexp
parameter_list|,
name|class
parameter_list|,
name|bpt
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|bpt
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|prev_bv
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
specifier|static
name|char
modifier|*
name|classnames
index|[]
init|=
block|{
literal|"variable"
block|,
literal|"function"
block|,
literal|"type"
block|,
literal|"method"
block|}
decl_stmt|;
name|int
name|found_in_file
init|=
literal|0
decl_stmt|;
name|int
name|found_misc
init|=
literal|0
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types
index|[]
init|=
block|{
name|mst_data
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
specifier|static
name|enum
name|minimal_symbol_type
name|types2
index|[]
init|=
block|{
name|mst_bss
block|,
name|mst_text
block|,
name|mst_abs
block|,
name|mst_unknown
block|}
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype
init|=
name|types
index|[
name|class
index|]
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ourtype2
init|=
name|types2
index|[
name|class
index|]
decl_stmt|;
if|if
condition|(
name|regexp
condition|)
block|{
comment|/* Make sure spacing is right for C++ operators. 	 This is just a courtesy to make the matching less sensitive 	 to how many spaces the user leaves between 'operator' 	 and<TYPENAME> or<OPERATOR>. */
name|char
modifier|*
name|opend
decl_stmt|;
name|char
modifier|*
name|opname
init|=
name|operator_chars
argument_list|(
name|regexp
argument_list|,
operator|&
name|opend
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|opname
condition|)
block|{
name|int
name|fix
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means ok; otherwise number of spaces needed. */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|opname
argument_list|)
operator|||
operator|*
name|opname
operator|==
literal|'_'
operator|||
operator|*
name|opname
operator|==
literal|'$'
condition|)
block|{
comment|/* There should 1 space between 'operator' and 'TYPENAME'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|||
name|opname
index|[
operator|-
literal|2
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* There should 0 spaces between 'operator' and 'OPERATOR'. */
if|if
condition|(
name|opname
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|fix
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If wrong number of spaces, fix it. */
if|if
condition|(
name|fix
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|opend
operator|-
name|opname
operator|+
literal|10
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"operator%.*s%s"
argument_list|,
name|fix
argument_list|,
literal|" "
argument_list|,
name|opname
argument_list|)
expr_stmt|;
name|regexp
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|val
operator|=
name|re_comp
argument_list|(
name|regexp
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid regexp (%s): %s"
argument_list|,
name|val
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
block|}
comment|/* Search through the partial symtabs *first* for all symbols      matching the regexp.  That way we don't have to reproduce all of      the machinery below. */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
name|struct
name|partial_symbol
modifier|*
name|bound
decl_stmt|,
modifier|*
name|gbound
decl_stmt|,
modifier|*
name|sbound
decl_stmt|;
name|int
name|keep_going
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
name|gbound
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
expr_stmt|;
name|sbound
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
expr_stmt|;
name|bound
operator|=
name|gbound
expr_stmt|;
comment|/* Go through all of the symbols stored in a partial 	 symtab in one loop. */
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
expr_stmt|;
while|while
condition|(
name|keep_going
condition|)
block|{
if|if
condition|(
name|psym
operator|>=
name|bound
condition|)
block|{
if|if
condition|(
name|bound
operator|==
name|gbound
operator|&&
name|ps
operator|->
name|n_static_syms
operator|!=
literal|0
condition|)
block|{
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
expr_stmt|;
name|bound
operator|=
name|sbound
expr_stmt|;
block|}
else|else
name|keep_going
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|QUIT
expr_stmt|;
comment|/* If it would match (logic taken from loop below) 		 load the file and go on to the next one */
if|if
condition|(
operator|(
name|regexp
operator|==
literal|0
operator|||
name|NAME_MATCH
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|class
operator|==
literal|0
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|1
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|class
operator|==
literal|3
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
condition|)
block|{
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|keep_going
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|psym
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here, we search through the minimal symbol tables for functions that      match, and call find_pc_symtab on them to force their symbols to      be read.  The symbol will then be found during the scan of symtabs      below.  If find_pc_symtab fails, set found_misc so that we will      rescan to print any matching symbols without debug info.  */
if|if
condition|(
name|class
operator|==
literal|1
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|msymbol
operator|->
name|type
operator|==
name|ourtype
operator|||
name|msymbol
operator|->
name|type
operator|==
name|ourtype2
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
literal|0
operator|||
name|NAME_MATCH
argument_list|(
name|msymbol
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|msymbol
operator|->
name|address
argument_list|)
condition|)
block|{
name|found_misc
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Printout here so as to get after the "Reading in symbols"      messages which will be generated above.  */
if|if
condition|(
operator|!
name|bpt
condition|)
name|printf_filtered
argument_list|(
name|regexp
condition|?
literal|"All %ss matching regular expression \"%s\":\n"
else|:
literal|"All defined %ss:\n"
argument_list|,
name|classnames
index|[
name|class
index|]
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|found_in_file
operator|=
literal|0
expr_stmt|;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Often many files share a blockvector. 	 Scan each blockvector only once so that 	 we don't get every symbol many times. 	 It happens that the first symtab in the list 	 for any given blockvector is the main file.  */
if|if
condition|(
name|bv
operator|!=
name|prev_bv
condition|)
for|for
control|(
name|i
operator|=
name|GLOBAL_BLOCK
init|;
name|i
operator|<=
name|STATIC_BLOCK
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Skip the sort if this block is always sorted.  */
if|if
condition|(
operator|!
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|sort_block_syms
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regexp
operator|==
literal|0
operator|||
name|NAME_MATCH
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|class
operator|==
literal|0
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_CONST
operator|)
operator|||
operator|(
name|class
operator|==
literal|1
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|||
operator|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|)
operator|||
operator|(
name|class
operator|==
literal|3
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|bpt
condition|)
block|{
comment|/* Set a breakpoint here, if it's a function */
if|if
condition|(
name|class
operator|==
literal|1
condition|)
name|break_command
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|found_in_file
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\nFile "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|s
operator|->
name|filename
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|found_in_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|class
operator|!=
literal|2
operator|&&
name|i
operator|==
name|STATIC_BLOCK
condition|)
name|printf_filtered
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
comment|/* Typedef that is not a C++ class */
if|if
condition|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|!=
name|STRUCT_NAMESPACE
condition|)
name|typedef_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sym
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* variable, func, or typedef-that-is-c++-class */
elseif|else
if|if
condition|(
name|class
operator|<
literal|2
operator|||
operator|(
name|class
operator|==
literal|2
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|)
condition|)
block|{
name|type_print
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|?
literal|""
else|:
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|)
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* FIXME, why is this zapped out? */
block|char buf[1024]; 			type_print_base (TYPE_FN_FIELD_TYPE(t, i), stdout, 0, 0);  			type_print_varspec_prefix (TYPE_FN_FIELD_TYPE(t, i), stdout, 0);  			sprintf (buf, " %s::", type_name_no_tag (t)); 			type_print_method_args (TYPE_FN_FIELD_ARGS (t, i), buf, name, stdout);
endif|#
directive|endif
block|}
block|}
block|}
block|}
name|prev_bv
operator|=
name|bv
expr_stmt|;
block|}
comment|/* If there are no eyes, avoid all contact.  I mean, if there are      no debug symbols, then print directly from the msymbol_vector.  */
if|if
condition|(
name|found_misc
operator|||
name|class
operator|!=
literal|1
condition|)
block|{
name|found_in_file
operator|=
literal|0
expr_stmt|;
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|msymbol
operator|->
name|type
operator|==
name|ourtype
operator|||
name|msymbol
operator|->
name|type
operator|==
name|ourtype2
condition|)
block|{
if|if
condition|(
name|regexp
operator|==
literal|0
operator|||
name|NAME_MATCH
argument_list|(
name|msymbol
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Functions:  Look up by address. */
if|if
condition|(
name|class
operator|!=
literal|1
operator|||
operator|(
literal|0
operator|==
name|find_pc_symtab
argument_list|(
name|msymbol
operator|->
name|address
argument_list|)
operator|)
condition|)
block|{
comment|/* Variables/Absolutes:  Look up by name */
if|if
condition|(
name|lookup_symbol
argument_list|(
name|msymbol
operator|->
name|name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|found_in_file
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\nNon-debugging symbols:\n"
argument_list|)
expr_stmt|;
name|found_in_file
operator|=
literal|1
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"	%08x  %s\n"
argument_list|,
name|msymbol
operator|->
name|address
argument_list|,
name|msymbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|variables_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|functions_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|types_info
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Tiemann says: "info methods was never implemented."  */
end_comment

begin_endif
unit|static void methods_info (regexp)      char *regexp; {   list_symbols (regexp, 3, 0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Breakpoint all functions matching regular expression. */
end_comment

begin_function
specifier|static
name|void
name|rbreak_command
parameter_list|(
name|regexp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regexp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|list_symbols
argument_list|(
name|regexp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return Nonzero if block a is lexically nested within block b,    or if a and b have the same pc range.    Return zero otherwise. */
end_comment

begin_function
name|int
name|contained_in
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|block
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return
literal|0
return|;
return|return
name|BLOCK_START
argument_list|(
name|a
argument_list|)
operator|>=
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|&&
name|BLOCK_END
argument_list|(
name|a
argument_list|)
operator|<=
name|BLOCK_END
argument_list|(
name|b
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Helper routine for make_symbol_completion_list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|return_val_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_val_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|completion_list_add_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|return_val_index
operator|+
literal|3
operator|>
name|return_val_size
condition|)
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|return_val
argument_list|,
operator|(
name|return_val_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
name|return_val_index
index|]
operator|=
name|name
expr_stmt|;
name|return_val
index|[
operator|++
name|return_val_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|completion_list_check_symbol
parameter_list|(
name|symname
parameter_list|,
name|text
parameter_list|,
name|text_len
parameter_list|)
name|char
modifier|*
name|symname
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|text_len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|cplus_demangle
argument_list|(
name|symname
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"_vt$"
argument_list|,
literal|4
argument_list|)
condition|)
name|completion_list_add_name
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|symname
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|symname
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|completion_list_add_name
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of all symbols (regardless of class) which    begin by matching TEXT.  If the answer is no symbols, then the return value    is an array which contains only a NULL pointer.     Problem: All of the symbols have to be copied because readline frees them.    I'm not going to worry about this; hopefully there won't be that many.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_completion_list
parameter_list|(
name|text
parameter_list|,
name|wantclass
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|enum
name|address_class
name|wantclass
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|text_len
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|text_len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|return_val_size
operator|=
literal|100
expr_stmt|;
name|return_val_index
operator|=
literal|0
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|return_val_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Look through the partial symtabs for all symbols which begin      by matching TEXT.  Add each one that you find to the list.  */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
comment|/* If the psymtab's been read in we'll get it when we search 	 through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
comment|/* If interrupted, then quit. */
name|QUIT
expr_stmt|;
if|if
condition|(
name|wantclass
operator|&&
name|wantclass
operator|!=
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
condition|)
continue|continue;
name|completion_list_check_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|wantclass
operator|&&
name|wantclass
operator|!=
name|SYMBOL_CLASS
argument_list|(
name|psym
argument_list|)
condition|)
continue|continue;
name|completion_list_check_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point scan through the misc symbol vectors and add each      symbol you find to the list.  Eventually we want to ignore      anything that isn't a text symbol (everything else will be      handled by the psymtab code above).  */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|completion_list_check_symbol
argument_list|(
name|msymbol
operator|->
name|name
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
block|}
comment|/* Search upwards from currently selected frame (so that we can      complete on local vars.  */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|()
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elmin of dups */
block|}
comment|/* Also catch fields of types defined in this places which match our 	 text string.  Only complete on types visible from current context. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantclass
operator|&&
name|wantclass
operator|!=
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
continue|continue;
name|completion_list_check_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|c
init|=
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|TYPE_CODE_UNION
operator|||
name|c
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|j
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|completion_list_check_symbol
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantclass
operator|&&
name|wantclass
operator|!=
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
continue|continue;
name|completion_list_check_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantclass
operator|&&
name|wantclass
operator|!=
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
continue|continue;
name|completion_list_check_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|text
argument_list|,
name|text_len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|make_function_completion_list
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
return|return
operator|(
name|make_completion_list
argument_list|(
name|text
argument_list|,
name|LOC_BLOCK
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|make_symbol_completion_list
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
return|return
operator|(
name|make_completion_list
argument_list|(
name|text
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a mangled symbol that corresponds to LOOKFOR using brute force.    Basically we go munging through available symbols, demangling each one,    looking for a match on the demangled result. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|expensive_mangler
parameter_list|(
name|lookfor
parameter_list|)
specifier|const
name|char
modifier|*
name|lookfor
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|,
modifier|*
name|surrounding_static_block
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
name|char
modifier|*
name|demangled
decl_stmt|;
comment|/* Look through the partial symtabs for a symbol that matches */
name|ALL_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|ps
argument_list|)
block|{
comment|/* If the psymtab's been read in we'll get it when we search 	 through the blockvector.  */
if|if
condition|(
name|ps
operator|->
name|readin
condition|)
continue|continue;
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|globals_offset
operator|+
name|ps
operator|->
name|n_global_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* If interrupted, then quit. */
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|lookfor
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
operator|)
return|;
block|}
block|}
for|for
control|(
name|psym
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
init|;
name|psym
operator|<
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|ps
operator|->
name|statics_offset
operator|+
name|ps
operator|->
name|n_static_syms
operator|)
condition|;
name|psym
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
argument_list|,
name|lookfor
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|SYMBOL_NAME
argument_list|(
name|psym
argument_list|)
operator|)
return|;
block|}
block|}
block|}
comment|/* Scan through the misc symbol vectors looking for a match. */
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|msymbol
operator|->
name|name
argument_list|,
name|lookfor
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|msymbol
operator|->
name|name
operator|)
return|;
block|}
block|}
comment|/* Search upwards from currently selected frame looking for a match */
for|for
control|(
name|b
operator|=
name|get_selected_block
argument_list|()
init|;
name|b
condition|;
name|b
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|BLOCK_SUPERBLOCK
argument_list|(
name|b
argument_list|)
condition|)
name|surrounding_static_block
operator|=
name|b
expr_stmt|;
comment|/* For elmin of dups */
comment|/* Also catch fields of types defined in this places which 	 match our text string.  Only complete on types visible 	 from current context.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|lookfor
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|c
init|=
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|TYPE_CODE_UNION
operator|||
name|c
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
for|for
control|(
name|j
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|j
operator|<
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|,
name|lookfor
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* Go through the symtabs and check the externs and statics for      symbols which match.  */
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|lookfor
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
block|}
block|}
name|ALL_SYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|s
argument_list|)
block|{
name|QUIT
expr_stmt|;
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
comment|/* Don't do this block twice.  */
if|if
condition|(
name|b
operator|==
name|surrounding_static_block
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|demangle_and_match
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|lookfor
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
operator|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Add the type of the symbol sym to the type of the current    function whose block we are in (assumed).  The type of    this current function is contained in *TYPE.        This basically works as follows:  When we find a function    symbol (N_FUNC with a 'f' or 'F' in the symbol name), we record    a pointer to its type in the global in_function_type.  Every     time we come across a parameter symbol ('p' in its name), then    this procedure adds the name and type of that parameter    to the function type pointed to by *TYPE.  (Which should correspond    to in_function_type if it was called correctly).     Note that since we are modifying a type, the result of     lookup_function_type() should be memcpy()ed before calling    this.  When not in strict typing mode, the expression    evaluator can choose to ignore this.     Assumption:  All of a function's parameter symbols will    appear before another function symbol is found.  The parameters     appear in the same order in the argument list as they do in the    symbol table. */
end_comment

begin_endif
unit|void add_param_to_type (type,sym)    struct type **type;    struct symbol *sym; {    int num = ++(TYPE_NFIELDS(*type));     if(TYPE_NFIELDS(*type)-1)       TYPE_FIELDS(*type) = (struct field *) 	  (*current_objfile->xrealloc) ((char *)(TYPE_FIELDS(*type)), 					num*sizeof(struct field));    else       TYPE_FIELDS(*type) = (struct field *) 	  (*current_objfile->xmalloc) (num*sizeof(struct field));        TYPE_FIELD_BITPOS(*type,num-1) = num-1;    TYPE_FIELD_BITSIZE(*type,num-1) = 0;    TYPE_FIELD_TYPE(*type,num-1) = SYMBOL_TYPE(sym);    TYPE_FIELD_NAME(*type,num-1) = SYMBOL_NAME(sym); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|_initialize_symtab
parameter_list|()
block|{
name|add_info
argument_list|(
literal|"variables"
argument_list|,
name|variables_info
argument_list|,
literal|"All global and static variable names, or those matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"functions"
argument_list|,
name|functions_info
argument_list|,
literal|"All function names, or those matching REGEXP."
argument_list|)
expr_stmt|;
comment|/* FIXME:  This command has at least the following problems:      1.  It prints builtin types (in a very strange and confusing fashion).      2.  It doesn't print right, e.g. with          typedef struct foo *FOO 	 type_print prints "FOO" when we want to make it (in this situation) 	 print "struct foo *".      I also think "ptype" or "whatis" is more likely to be useful (but if      there is much disagreement "info types" can be fixed).  */
name|add_info
argument_list|(
literal|"types"
argument_list|,
name|types_info
argument_list|,
literal|"All type names, or those matching REGEXP."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_info ("methods", methods_info, 	    "All method names, or those matching REGEXP::REGEXP.\n\ If the class qualifier is omitted, it is assumed to be the current scope.\n\ If the first REGEXP is omitted, then all methods matching the second REGEXP\n\ are listed.");
endif|#
directive|endif
name|add_info
argument_list|(
literal|"sources"
argument_list|,
name|sources_info
argument_list|,
literal|"Source files in the program."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"rbreak"
argument_list|,
name|no_class
argument_list|,
name|rbreak_command
argument_list|,
literal|"Set a breakpoint for all functions matching REGEXP."
argument_list|)
expr_stmt|;
comment|/* Initialize the one built-in type that isn't language dependent... */
name|builtin_type_error
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_ERROR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"<unknown type>"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

