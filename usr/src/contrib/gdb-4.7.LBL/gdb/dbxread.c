begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read dbx symbol tables and convert to internal format, for GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This module provides three functions: dbx_symfile_init,    which initializes to read a symbol file; dbx_new_init, which     discards existing cached information when all symbols are being    discarded; and dbx_symfile_read, which reads a symbol table    from a file.     dbx_symfile_read only does the minimum work necessary for letting the    user "name" things symbolically; it does not read the entire symtab.    Instead, it reads the external and static symbols and puts them in partial    symbol tables.  When more extensive information is requested of a    file, the corresponding partial symbol table is mutated into a full    fledged symbol table by going back and reading the symbols    for real.  dbx_psymtab_to_symtab() is the function that does this */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGNUSCLIB__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_define
define|#
directive|define
name|L_INCR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
end_ifdef

begin_comment
comment|/* We don't want to use HP-UX's nlists. */
end_comment

begin_define
define|#
directive|define
name|_NLIST_INCLUDED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_FILE
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* for bfd stuff */
end_comment

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* FIXME Secret internal BFD stuff (bfd_read) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
end_ifdef

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_include
include|#
directive|include
file|"syms.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* FIXME Secret internal BFD stuff for a.out */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* We always use GNU stabs, not native, now */
end_comment

begin_comment
comment|/* Each partial symbol table entry contains a pointer to private data for the    read_symtab() function to use when expanding a partial symbol table entry    to a full symbol table entry.     For dbxread this structure contains the offset within the file symbol table    of first local symbol for this file, and length (in bytes) of the section    of the symbol table devoted to this file's symbols (actually, the section    bracketed may contain more than just this file's symbols).  It also contains    further information needed to locate the symbols if they are in an ELF file.     If ldsymlen is 0, the only reason for this thing's existence is the    dependency list.  Nothing else will happen when it is read in.  */
end_comment

begin_define
define|#
directive|define
name|LDSYMOFF
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymoff)
end_define

begin_define
define|#
directive|define
name|LDSYMLEN
parameter_list|(
name|p
parameter_list|)
value|(((struct symloc *)((p)->read_symtab_private))->ldsymlen)
end_define

begin_define
define|#
directive|define
name|SYMLOC
parameter_list|(
name|p
parameter_list|)
value|((struct symloc *)((p)->read_symtab_private))
end_define

begin_define
define|#
directive|define
name|SYMBOL_SIZE
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->symbol_size)
end_define

begin_define
define|#
directive|define
name|SYMBOL_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->symbol_offset)
end_define

begin_define
define|#
directive|define
name|STRING_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->string_offset)
end_define

begin_define
define|#
directive|define
name|FILE_STRING_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(SYMLOC(p)->file_string_offset)
end_define

begin_struct
struct|struct
name|symloc
block|{
name|int
name|ldsymoff
decl_stmt|;
name|int
name|ldsymlen
decl_stmt|;
name|int
name|symbol_size
decl_stmt|;
name|int
name|symbol_offset
decl_stmt|;
name|int
name|string_offset
decl_stmt|;
name|int
name|file_string_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macro to determine which symbols to ignore when reading the first symbol    of a file.  Some machines override this definition. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IGNORE_SYMBOL
end_ifndef

begin_comment
comment|/* This code is used on Ultrix systems.  Ignore it */
end_comment

begin_define
define|#
directive|define
name|IGNORE_SYMBOL
parameter_list|(
name|type
parameter_list|)
value|(type == (int)N_NSYMS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro for name of symbol to indicate a file compiled with gcc. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_COMPILED_FLAG_SYMBOL
end_ifndef

begin_define
define|#
directive|define
name|GCC_COMPILED_FLAG_SYMBOL
value|"gcc_compiled."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro for name of symbol to indicate a file compiled with gcc2. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC2_COMPILED_FLAG_SYMBOL
end_ifndef

begin_define
define|#
directive|define
name|GCC2_COMPILED_FLAG_SYMBOL
value|"gcc2_compiled."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define this as 1 if a pcc declaration of a char or short argument    gives the correct address.  Otherwise assume pcc gives the    address of the corresponding int, which is not the same on a    big-endian machine.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BELIEVE_PCC_PROMOTION
end_ifndef

begin_define
define|#
directive|define
name|BELIEVE_PCC_PROMOTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means give verbose info on gdb action.  From main.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The BFD for this file -- implicit parameter to next_symbol_text.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of each symbol in the symbol file (in external form).    This is set by dbx_symfile_read when building psymtabs, and by    dbx_psymtab_to_symtab when building symtabs.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|symbol_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the offset of the symbol table in the executable file */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|symbol_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the offset of the string table in the executable file */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|string_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For elf+stab executables, the n_strx field is not a simple index    into the string table.  Instead, each .o file has a base offset    in the string table, and the associated symbols contain offsets    from this base.  The following two variables contain the base    offset for the current and next .o files. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|file_string_table_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|next_file_string_table_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complaints about the symbols we have encountered.  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|lbrac_complaint
init|=
block|{
literal|"bad block start address patched"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|string_table_offset_complaint
init|=
block|{
literal|"bad string table offset in symbol %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_symtype_complaint
init|=
block|{
literal|"unknown symbol type %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|lbrac_rbrac_complaint
init|=
block|{
literal|"block start larger than block end"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|lbrac_unmatched_complaint
init|=
block|{
literal|"unmatched N_LBRAC before symtab pos %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|lbrac_mismatch_complaint
init|=
block|{
literal|"N_LBRAC/N_RBRAC symbol mismatch at symtab pos %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|repeated_header_complaint
init|=
block|{
literal|"\"repeated\" header file not previously seen, at symtab pos %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|repeated_header_name_complaint
init|=
block|{
literal|"\"repeated\" header file not previously seen, named %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* During initial symbol readin, we need to have a structure to keep    track of which psymtabs have which bincls in them.  This structure    is used during readin to setup the list of dependencies within each    partial symbol table. */
end_comment

begin_struct
struct|struct
name|header_file_location
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of header file */
name|int
name|instance
decl_stmt|;
comment|/* See above */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* Partial symtab that has the 				   BINCL/EINCL defs for this file */
block|}
struct|;
end_struct

begin_comment
comment|/* The actual list and controling variables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|header_file_location
modifier|*
name|bincl_list
decl_stmt|,
modifier|*
name|next_bincl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bincls_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|free_header_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_header_files
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pending
modifier|*
name|copy_pending
name|PARAMS
argument_list|(
operator|(
expr|struct
name|pending
operator|*
operator|,
name|int
operator|,
expr|struct
name|pending
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|read_ofile_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
name|int
operator|,
expr|struct
name|section_offsets
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_psymtab_to_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_dbx_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_bincl_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|find_corresponding_bincl_psymtab
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bincl_to_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_bincl_list
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_psymbol_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dbx_next_symbol_text
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_symbuf
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbx_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_minimal_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_new_header_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_old_header_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_this_object_header_file
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free up old header file tables */
end_comment

begin_function
specifier|static
name|void
name|free_header_files
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|header_files
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_header_files
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|header_files
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|header_files
argument_list|)
expr_stmt|;
name|header_files
operator|=
name|NULL
expr_stmt|;
name|n_header_files
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|this_object_header_files
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|this_object_header_files
argument_list|)
expr_stmt|;
name|this_object_header_files
operator|=
name|NULL
expr_stmt|;
block|}
name|n_allocated_header_files
operator|=
literal|0
expr_stmt|;
name|n_allocated_this_object_header_files
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate new header file tables */
end_comment

begin_function
specifier|static
name|void
name|init_header_files
parameter_list|()
block|{
name|n_header_files
operator|=
literal|0
expr_stmt|;
name|n_allocated_header_files
operator|=
literal|10
expr_stmt|;
name|header_files
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file
argument_list|)
argument_list|)
expr_stmt|;
name|n_allocated_this_object_header_files
operator|=
literal|10
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add header file number I for this object file    at the next successive FILENUM.  */
end_comment

begin_function
specifier|static
name|void
name|add_this_object_header_file
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|n_this_object_header_files
operator|==
name|n_allocated_this_object_header_files
condition|)
block|{
name|n_allocated_this_object_header_files
operator|*=
literal|2
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|this_object_header_files
argument_list|,
name|n_allocated_this_object_header_files
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this_object_header_files
index|[
name|n_this_object_header_files
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to this file an "old" header file, one already seen in    a previous object file.  NAME is the header file's name.    INSTANCE is its instance code, to select among multiple    symbol tables for the same header file.  */
end_comment

begin_function
specifier|static
name|void
name|add_old_header_file
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
specifier|register
name|struct
name|header_file
modifier|*
name|p
init|=
name|header_files
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_header_files
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|instance
operator|==
name|p
index|[
name|i
index|]
operator|.
name|instance
condition|)
block|{
name|add_this_object_header_file
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|complain
argument_list|(
operator|&
name|repeated_header_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symnum
argument_list|)
expr_stmt|;
name|complain
argument_list|(
operator|&
name|repeated_header_name_complaint
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to this file a "new" header file: definitions for its types follow.    NAME is the header file's name.    Most often this happens only once for each distinct header file,    but not necessarily.  If it happens more than once, INSTANCE has    a different value each time, and references to the header file    use INSTANCE values to select among them.     dbx output contains "begin" and "end" markers for each new header file,    but at this level we just need to know which files there have been;    so we record the file when its "begin" is seen and ignore the "end".  */
end_comment

begin_function
specifier|static
name|void
name|add_new_header_file
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Make sure there is room for one more header file.  */
if|if
condition|(
name|n_header_files
operator|==
name|n_allocated_header_files
condition|)
block|{
name|n_allocated_header_files
operator|*=
literal|2
expr_stmt|;
name|header_files
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|header_files
argument_list|,
operator|(
name|n_allocated_header_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create an entry for this header file.  */
name|i
operator|=
name|n_header_files
operator|++
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|instance
operator|=
name|instance
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|10
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|header_files
index|[
name|i
index|]
operator|.
name|vector
argument_list|,
literal|0
argument_list|,
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|add_this_object_header_file
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type ** explicit_lookup_type (real_filenum, index)      int real_filenum, index; {   register struct header_file *f =&header_files[real_filenum];    if (index>= f->length)     {       f->length *= 2;       f->vector = (struct type **) 	xrealloc (f->vector, f->length * sizeof (struct type *));       bzero (&f->vector[f->length / 2], 	     f->length * sizeof (struct type *) / 2);     }   return&f->vector[index]; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
specifier|static
name|void
name|record_minimal_symbol
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
switch|switch
condition|(
name|type
operator|&
operator|~
name|N_EXT
condition|)
block|{
case|case
name|N_TEXT
case|:
name|ms_type
operator|=
name|mst_text
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|N_SETV
case|case
name|N_SETV
case|:
name|ms_type
operator|=
name|mst_data
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ms_type
operator|=
name|mst_unknown
expr_stmt|;
break|break;
block|}
name|prim_record_minimal_symbol
argument_list|(
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
argument_list|,
name|address
argument_list|,
name|ms_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for a symbol file.    We have been initialized by a call to dbx_symfile_init, which     put all the relevant info into a "struct dbx_symfile_info",    hung off the objfile structure.     SECTION_OFFSETS contains offsets relative to which the symbols in the    various sections are (depending where the sections were actually loaded).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).  */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
comment|/* FIXME comments above */
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|int
name|val
decl_stmt|;
name|sym_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|val
operator|=
name|bfd_seek
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If we are reinitializing, or if we have never loaded syms yet, init */
if|if
condition|(
name|mainline
operator|||
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|==
literal|0
operator|||
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|==
literal|0
condition|)
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|symbol_size
operator|=
name|obj_dbx_symbol_entry_size
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
else|#
directive|else
name|symbol_size
operator|=
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|symbol_table_offset
operator|=
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|pending_blocks
operator|=
literal|0
expr_stmt|;
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the symbol table data of the executable file are all in core,      process them and define symbols accordingly.  */
name|read_dbx_symtab
argument_list|(
name|section_offsets
argument_list|,
name|objfile
argument_list|,
name|bfd_section_vma
argument_list|(
name|sym_bfd
argument_list|,
name|DBX_TEXT_SECT
argument_list|(
name|objfile
argument_list|)
argument_list|)
argument_list|,
name|bfd_section_size
argument_list|(
name|sym_bfd
argument_list|,
name|DBX_TEXT_SECT
argument_list|(
name|objfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_partial_symbols
argument_list|()
condition|)
block|{
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"(no debugging symbols found)..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
specifier|static
name|void
name|dbx_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dbx_symfile_init ()    is the dbx-specific initialization routine for reading symbols.    It is passed a struct objfile which contains, among other things,    the BFD for the file whose symbols are being read, and a slot for a pointer    to "private data" which we fill with goodies.     We read the string table into malloc'd space and stash a pointer to it.     Since BFD doesn't know how to read debug symbols in a format-independent    way (and may never do so...), we have to do it ourselves.  We will never    be called unless this is an a.out (or very similar) file.     FIXME, there should be a cleaner peephole into the BFD environment here.  */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|size_temp
index|[
literal|4
index|]
decl_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_private
operator|=
operator|(
name|PTR
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dbx_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME POKING INSIDE BFD DATA STRUCTURES */
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
define|#
directive|define
name|STRING_TABLE_OFFSET
value|(sym_bfd->origin + obj_dbx_str_filepos (sym_bfd))
define|#
directive|define
name|SYMBOL_TABLE_OFFSET
value|(sym_bfd->origin + obj_dbx_sym_filepos (sym_bfd))
define|#
directive|define
name|HP_STRING_TABLE_OFFSET
value|(sym_bfd->origin + obj_hp_str_filepos (sym_bfd))
define|#
directive|define
name|HP_SYMBOL_TABLE_OFFSET
value|(sym_bfd->origin + obj_hp_sym_filepos (sym_bfd))
else|#
directive|else
define|#
directive|define
name|STRING_TABLE_OFFSET
value|(sym_bfd->origin + obj_str_filepos (sym_bfd))
define|#
directive|define
name|SYMBOL_TABLE_OFFSET
value|(sym_bfd->origin + obj_sym_filepos (sym_bfd))
endif|#
directive|endif
comment|/* FIXME POKING INSIDE BFD DATA STRUCTURES */
name|DBX_SYMFILE_INFO
argument_list|(
name|objfile
argument_list|)
operator|->
name|stab_section_info
operator|=
name|NULL
expr_stmt|;
name|DBX_TEXT_SECT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DBX_TEXT_SECT
argument_list|(
name|objfile
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't find .text section in symbol file"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|HP_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|obj_hp_sym_count
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|obj_dbx_sym_count
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
else|#
directive|else
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|obj_symbol_entry_size
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_get_symcount
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|SYMBOL_TABLE_OFFSET
expr_stmt|;
comment|/* Read the string table and stash it away in the psymbol_obstack.  It is      only needed as long as we need to expand psymbols into full symbols,      so when we blow away the psymbol the string table goes away as well.      Note that gdb used to use the results of attempting to malloc the      string table, based on the size it read, as a form of sanity check      for botched byte swapping, on the theory that a byte swapped string      table size would be so totally bogus that the malloc would fail.  Now      that we put in on the psymbol_obstack, we can't do this since gdb gets      a fatal error (out of virtual memory) if the size is bogus.  We can      however at least check to see if the size is zero or some negative      value. */
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|obj_dbx_stringtab_size
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
name|HP_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|obj_hp_stringtab_size
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
else|#
directive|else
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|size_temp
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_h_get_32
argument_list|(
name|sym_bfd
argument_list|,
name|size_temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"ridiculous string table size (%d bytes)."
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
if|if
condition|(
name|HP_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"ridiculous string table size (%d bytes)."
argument_list|,
name|HP_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|HP_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|HP_STRING_TABLE_OFFSET
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|HP_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|HP_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|HP_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|HP_SYMBOL_TABLE_OFFSET
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|dbx_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
name|free_header_files
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Buffer for reading the symbol table entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|internal_nlist
name|symbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbuf_idx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbuf_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of last function encountered.  Used in Solaris to approximate    object file boundaries.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address in memory of the string table of the object file we are    reading (which might not be the "main" object file, but might be a    shared library or some other dynamically loaded thing).  This is set    by read_dbx_symtab when building psymtabs, and by read_ofile_symtab     when building symtabs, and is used only by next_symbol_text.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stringtab_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Refill the symbol table input buffer    and set the variables that control fetching entries from it.    Reports an error if no data available.    This function can read past the end of the symbol table    (into the string table) but this does no harm.  */
end_comment

begin_function
specifier|static
name|void
name|fill_symbuf
parameter_list|(
name|sym_bfd
parameter_list|)
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
block|{
name|int
name|nbytes
init|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|symbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Premature end of file reading symbol table"
argument_list|)
expr_stmt|;
name|symbuf_end
operator|=
name|nbytes
operator|/
name|symbol_size
expr_stmt|;
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
end_ifdef

begin_comment
comment|/* same as above for the HP symbol table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol_dictionary_record
name|hp_symbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hp_symbuf_idx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hp_symbuf_end
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fill_hp_symbuf
parameter_list|(
name|sym_bfd
parameter_list|)
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
block|{
name|int
name|nbytes
init|=
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|hp_symbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hp_symbuf
argument_list|)
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"error or end of file reading symbol table"
argument_list|)
expr_stmt|;
name|hp_symbuf_end
operator|=
name|nbytes
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
expr_stmt|;
name|hp_symbuf_idx
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SWAP_SYMBOL
parameter_list|(
name|symp
parameter_list|,
name|abfd
parameter_list|)
define|\
value|{ \     (symp)->n_strx = bfd_h_get_32(abfd,			\ 				(unsigned char *)&(symp)->n_strx);	\     (symp)->n_desc = bfd_h_get_16 (abfd,			\ 				(unsigned char *)&(symp)->n_desc);  	\     (symp)->n_value = bfd_h_get_32 (abfd,			\ 				(unsigned char *)&(symp)->n_value); 	\   }
end_define

begin_comment
comment|/* Invariant: The symbol pointed to by symbuf_idx is the first one    that hasn't been swapped.  Swap the symbol at the same time    that symbuf_idx is incremented.  */
end_comment

begin_comment
comment|/* dbx allows the text of a symbol name to be continued into the    next symbol name!  When such a continuation is encountered    (a \ at the end of the text of a name)    call this function to get the continuation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dbx_next_symbol_text
parameter_list|()
block|{
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|symfile_bfd
argument_list|)
expr_stmt|;
name|symnum
operator|++
expr_stmt|;
name|SWAP_SYMBOL
argument_list|(
operator|&
name|symbuf
index|[
name|symbuf_idx
index|]
argument_list|,
name|symfile_bfd
argument_list|)
expr_stmt|;
return|return
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
operator|.
name|n_strx
operator|+
name|stringtab_global
operator|+
name|file_string_table_offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initializes storage for all of the partial symbols that will be    created by read_dbx_symtab and subsidiaries.  */
end_comment

begin_function
specifier|static
name|void
name|init_psymbol_list
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* Free any previously allocated psymbol lists.  */
if|if
condition|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
condition|)
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
condition|)
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
argument_list|)
expr_stmt|;
comment|/* Current best guess is that there are approximately a twentieth      of the total symbols (in a debugging file) are global or static      oriented symbols */
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|=
operator|(
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|+
name|HP_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|)
operator|/
literal|10
expr_stmt|;
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|=
operator|(
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|+
name|HP_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|)
operator|/
literal|10
expr_stmt|;
else|#
directive|else
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|=
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|/
literal|10
expr_stmt|;
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|=
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|/
literal|10
expr_stmt|;
endif|#
directive|endif
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the list of bincls to contain none and have some    allocated.  */
end_comment

begin_function
specifier|static
name|void
name|init_bincl_list
parameter_list|(
name|number
parameter_list|,
name|objfile
parameter_list|)
name|int
name|number
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|bincls_allocated
operator|=
name|number
expr_stmt|;
name|next_bincl
operator|=
name|bincl_list
operator|=
operator|(
expr|struct
name|header_file_location
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|bincls_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file_location
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a bincl to the list.  */
end_comment

begin_function
specifier|static
name|void
name|add_bincl_to_list
parameter_list|(
name|pst
parameter_list|,
name|name
parameter_list|,
name|instance
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
if|if
condition|(
name|next_bincl
operator|>=
name|bincl_list
operator|+
name|bincls_allocated
condition|)
block|{
name|int
name|offset
init|=
name|next_bincl
operator|-
name|bincl_list
decl_stmt|;
name|bincls_allocated
operator|*=
literal|2
expr_stmt|;
name|bincl_list
operator|=
operator|(
expr|struct
name|header_file_location
operator|*
operator|)
name|xmrealloc
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bincl_list
argument_list|,
name|bincls_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file_location
argument_list|)
argument_list|)
expr_stmt|;
name|next_bincl
operator|=
name|bincl_list
operator|+
name|offset
expr_stmt|;
block|}
name|next_bincl
operator|->
name|pst
operator|=
name|pst
expr_stmt|;
name|next_bincl
operator|->
name|instance
operator|=
name|instance
expr_stmt|;
name|next_bincl
operator|++
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a name, value pair, find the corresponding    bincl in the list.  Return the partial symtab associated    with that header_file_location.  */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|find_corresponding_bincl_psymtab
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
name|struct
name|header_file_location
modifier|*
name|bincl
decl_stmt|;
for|for
control|(
name|bincl
operator|=
name|bincl_list
init|;
name|bincl
operator|<
name|next_bincl
condition|;
name|bincl
operator|++
control|)
if|if
condition|(
name|bincl
operator|->
name|instance
operator|==
name|instance
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|bincl
operator|->
name|name
argument_list|)
condition|)
return|return
name|bincl
operator|->
name|pst
return|;
return|return
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free the storage allocated for the bincl list.  */
end_comment

begin_function
specifier|static
name|void
name|free_bincl_list
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|PTR
operator|)
name|bincl_list
argument_list|)
expr_stmt|;
name|bincls_allocated
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given pointers to an a.out symbol table in core containing dbx    style data, setup partial_symtab's describing each source file for    which debugging information is available.    SYMFILE_NAME is the name of the file we are reading from    and SECTION_OFFSETS is the set of offsets for the various sections    of the file (a set of zeros if the mainline program).  */
end_comment

begin_function
specifier|static
name|void
name|read_dbx_symtab
parameter_list|(
name|section_offsets
parameter_list|,
name|objfile
parameter_list|,
name|text_addr
parameter_list|,
name|text_size
parameter_list|)
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|int
name|text_size
decl_stmt|;
block|{
specifier|register
name|struct
name|internal_nlist
modifier|*
name|bufp
init|=
literal|0
decl_stmt|;
comment|/* =0 avoids gcc -Wall glitch */
specifier|register
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
name|nsl
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|last_o_file_start
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
comment|/* HP stuff */
name|struct
name|symbol_dictionary_record
modifier|*
name|hp_bufp
decl_stmt|;
name|int
name|hp_symnum
decl_stmt|;
comment|/* A hack: the first text symbol in the debugging library */
name|int
name|dbsubc_addr
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* End of the text segment of the executable file.  */
name|CORE_ADDR
name|end_of_text_addr
decl_stmt|;
comment|/* Current partial symtab */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
comment|/* FIXME.  We probably want to change stringtab_global rather than add this      while processing every symbol entry.  FIXME.  */
name|file_string_table_offset
operator|=
literal|0
expr_stmt|;
name|next_file_string_table_offset
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|stringtab_global
operator|=
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|stringtab_global
operator|=
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_objfile
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Init bincl list */
name|init_bincl_list
argument_list|(
literal|20
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_bincl_list
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|END_OF_TEXT_DEFAULT
name|end_of_text_addr
operator|=
name|END_OF_TEXT_DEFAULT
expr_stmt|;
else|#
directive|else
name|end_of_text_addr
operator|=
name|text_addr
operator|+
name|section_offsets
operator|->
name|offsets
index|[
name|SECT_OFF_TEXT
index|]
operator|+
name|text_size
expr_stmt|;
comment|/* Relocate */
endif|#
directive|endif
name|symfile_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* For next_text_symbol */
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|symbuf_end
operator|=
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
name|next_symbol_text_func
operator|=
name|dbx_next_symbol_text
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
comment|/* On pa machines, the global symbols are all in the regular HP-UX      symbol table. Read them in first. */
name|hp_symbuf_end
operator|=
name|hp_symbuf_idx
operator|=
literal|0
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|HP_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|hp_symnum
operator|=
literal|0
init|;
name|hp_symnum
operator|<
name|HP_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|;
name|hp_symnum
operator|++
control|)
block|{
name|int
name|dbx_type
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|hp_symbuf_idx
operator|==
name|hp_symbuf_end
condition|)
name|fill_hp_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|hp_bufp
operator|=
operator|&
name|hp_symbuf
index|[
name|hp_symbuf_idx
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|hp_bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_SYM_EXT
case|:
case|case
name|ST_ARG_EXT
case|:
continue|continue;
case|case
name|ST_CODE
case|:
case|case
name|ST_PRI_PROG
case|:
case|case
name|ST_SEC_PROG
case|:
case|case
name|ST_ENTRY
case|:
case|case
name|ST_MILLICODE
case|:
name|dbx_type
operator|=
name|N_TEXT
expr_stmt|;
name|hp_bufp
operator|->
name|symbol_value
operator|&=
operator|~
literal|3
expr_stmt|;
comment|/* clear out permission bits */
break|break;
case|case
name|ST_DATA
case|:
name|dbx_type
operator|=
name|N_DATA
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|KERNELDEBUG
case|case
name|ST_ABSOLUTE
case|:
block|{
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
if|if
condition|(
operator|!
name|kernel_debugging
condition|)
continue|continue;
name|dbx_type
operator|=
name|N_ABS
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
continue|continue;
block|}
comment|/* Use the address of dbsubc to finish the last psymtab. */
if|if
condition|(
name|hp_bufp
operator|->
name|symbol_type
operator|==
name|ST_CODE
operator|&&
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
index|[
name|hp_bufp
operator|->
name|name
operator|.
name|n_strx
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strcmp
argument_list|(
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|+
name|hp_bufp
operator|->
name|name
operator|.
name|n_strx
argument_list|,
literal|"_dbsubc"
argument_list|)
condition|)
name|dbsubc_addr
operator|=
name|hp_bufp
operator|->
name|symbol_value
expr_stmt|;
if|if
condition|(
name|hp_bufp
operator|->
name|symbol_scope
operator|==
name|SS_UNIVERSAL
condition|)
block|{
if|if
condition|(
name|hp_bufp
operator|->
name|name
operator|.
name|n_strx
operator|>
name|HP_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
condition|)
name|error
argument_list|(
literal|"Invalid symbol data; bad HP string table offset: %d"
argument_list|,
name|hp_bufp
operator|->
name|name
operator|.
name|n_strx
argument_list|)
expr_stmt|;
comment|/* A hack, but gets the job done. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hp_bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|"$START$"
argument_list|)
condition|)
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|hp_bufp
operator|->
name|symbol_value
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hp_bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|"_sr4export"
argument_list|)
condition|)
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|hp_bufp
operator|->
name|symbol_value
expr_stmt|;
name|record_minimal_symbol
argument_list|(
name|hp_bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|hp_bufp
operator|->
name|symbol_value
argument_list|,
name|dbx_type
operator||
name|N_EXT
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|;
name|symnum
operator|++
control|)
block|{
comment|/* Get the symbol for this run and pull out some info */
name|QUIT
expr_stmt|;
comment|/* allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
comment|/*        * Special case to speed up readin.        */
if|if
condition|(
name|bufp
operator|->
name|n_type
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_SLINE
condition|)
continue|continue;
name|SWAP_SYMBOL
argument_list|(
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* Ok.  There is a lot of code duplicated in the rest of this          switch statement (for efficiency reasons).  Since I don't          like duplicating code, I will do my penance here, and          describe the code which is duplicated:  	 *) The assignment to namestring. 	 *) The call to strchr. 	 *) The addition of a partial symbol the the two partial 	    symbol lists.  This last is a large section of code, so 	    I've imbedded it in the following macro. 	 */
comment|/* Set namestring based on bufp.  If the string table index is invalid,     give a fake name, and print a single error message per symbol file read,    rather than abort the symbol reading or flood the user with messages.  */
comment|/*FIXME: Too many adds and indirections in here for the inner loop.  */
define|#
directive|define
name|SET_NAMESTRING
parameter_list|()
define|\
value|if (((unsigned)bufp->n_strx + file_string_table_offset)>=		\       DBX_STRINGTAB_SIZE (objfile)) {					\     complain (&string_table_offset_complaint, (char *) symnum);		\     namestring = "foo";							\   } else								\     namestring = bufp->n_strx + file_string_table_offset +		\ 		 DBX_STRINGTAB (objfile)
define|#
directive|define
name|CUR_SYMBOL_TYPE
value|bufp->n_type
define|#
directive|define
name|CUR_SYMBOL_VALUE
value|bufp->n_value
define|#
directive|define
name|DBXREAD_ONLY
define|#
directive|define
name|START_PSYMTAB
parameter_list|(
name|ofile
parameter_list|,
name|secoff
parameter_list|,
name|fname
parameter_list|,
name|low
parameter_list|,
name|symoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
define|\
value|start_psymtab(ofile, secoff, fname, low, symoff, global_syms, static_syms)
define|#
directive|define
name|END_PSYMTAB
parameter_list|(
name|pst
parameter_list|,
name|ilist
parameter_list|,
name|ninc
parameter_list|,
name|c_off
parameter_list|,
name|c_text
parameter_list|,
name|dep_list
parameter_list|,
name|n_deps
parameter_list|)
define|\
value|end_psymtab(pst,ilist,ninc,c_off,c_text,dep_list,n_deps)
include|#
directive|include
file|"partial-stab.h"
block|}
comment|/* If there's stuff to be cleaned up, clean it up.  */
ifndef|#
directive|ifndef
name|GDB_TARGET_IS_HPPA
if|if
condition|(
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|>
literal|0
comment|/* We have some syms */
comment|/*FIXME, does this have a bug at start address 0? */
operator|&&
name|last_o_file_start
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|bufp
operator|->
name|n_value
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|last_o_file_start
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|bufp
operator|->
name|n_value
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pst
condition|)
block|{
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|dbsubc_addr
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
else|#
directive|else
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|end_of_text_addr
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free_bincl_list
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|start_psymtab
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|,
name|textlow
parameter_list|,
name|ldsymoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
name|textlow
decl_stmt|;
name|int
name|ldsymoff
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|static_syms
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|result
init|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|filename
argument_list|,
name|textlow
argument_list|,
name|global_syms
argument_list|,
name|static_syms
argument_list|)
decl_stmt|;
name|result
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|result
argument_list|)
operator|=
name|ldsymoff
expr_stmt|;
name|result
operator|->
name|read_symtab
operator|=
name|dbx_psymtab_to_symtab
expr_stmt|;
name|SYMBOL_SIZE
argument_list|(
name|result
argument_list|)
operator|=
name|symbol_size
expr_stmt|;
name|SYMBOL_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|symbol_table_offset
expr_stmt|;
name|STRING_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|string_table_offset
expr_stmt|;
name|FILE_STRING_OFFSET
argument_list|(
name|result
argument_list|)
operator|=
name|file_string_table_offset
expr_stmt|;
comment|/* If we're handling an ELF file, drag some section-relocation info      for this source file out of the ELF symbol table, to compensate for      Sun brain death.  This replaces the section_offsets in this psymtab,      if successful.  */
ifdef|#
directive|ifdef
name|notdef
name|elfstab_offset_sections
argument_list|(
name|objfile
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Close off the current usage of a partial_symbol table entry.  This    involves setting the correct number of includes (with a realloc),    setting the high text mark, setting the symbol length in the    executable, and setting the length of the global and static lists    of psymbols.     The global symbols and static symbols are then seperately sorted.     Then the partial symtab is put on the global list.    *** List variables and peculiarities of same. ***    */
end_comment

begin_function
name|void
name|end_psymtab
parameter_list|(
name|pst
parameter_list|,
name|include_list
parameter_list|,
name|num_includes
parameter_list|,
name|capping_symbol_offset
parameter_list|,
name|capping_text
parameter_list|,
name|dependency_list
parameter_list|,
name|number_dependencies
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
modifier|*
name|include_list
decl_stmt|;
name|int
name|num_includes
decl_stmt|;
name|int
name|capping_symbol_offset
decl_stmt|;
name|CORE_ADDR
name|capping_text
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|number_dependencies
decl_stmt|;
comment|/*     struct partial_symbol *capping_global, *capping_static;*/
block|{
name|int
name|i
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|p1
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
if|if
condition|(
name|capping_symbol_offset
operator|!=
operator|-
literal|1
condition|)
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|=
name|capping_symbol_offset
operator|-
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|capping_text
expr_stmt|;
comment|/* Under Solaris, the N_SO symbols always have a value of 0,      instead of the usual address of the .o file.  Therefore,      we have to do some tricks to fill in texthigh and textlow.      The first trick is in partial-stab.h: if we see a static      or global function, and the textlow for the current pst      is still 0, then we use that function's address for       the textlow of the pst.       Now, to fill in texthigh, we remember the last function seen      in the .o file (also in partial-stab.h).  Also, there's a hack in      bfd/elf.c and gdb/elfread.c to pass the ELF st_size field      to here via the misc_info field.  Therefore, we can fill in      a reliable texthigh by taking the address plus size of the      last function in the file.       Unfortunately, that does not cover the case where the last function      in the file is static.  See the paragraph below for more comments      on this situation.       Finally, if we have a valid textlow for the current file, we run      down the partial_symtab_list filling in previous texthighs that      are still unknown.  */
if|if
condition|(
name|pst
operator|->
name|texthigh
operator|==
literal|0
operator|&&
name|last_function_name
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|minsym
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|last_function_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|last_function_name
expr_stmt|;
name|n
operator|=
name|p
operator|-
name|last_function_name
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|last_function_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|minsym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|minsym
condition|)
block|{
name|pst
operator|->
name|texthigh
operator|=
name|minsym
operator|->
name|address
operator|+
operator|(
name|int
operator|)
name|minsym
operator|->
name|info
expr_stmt|;
block|}
else|else
block|{
comment|/* This file ends with a static function, and it's 	 difficult to imagine how hard it would be to track down 	 the elf symbol.  Luckily, most of the time no one will notice, 	 since the next file will likely be compiled with -g, so 	 the code below will copy the first fuction's start address  	 back to our texthigh variable.  (Also, if this file is the 	 last one in a dynamically linked program, texthigh already 	 has the right value.)  If the next file isn't compiled 	 with -g, then the last function in this file winds up owning 	 all of the text space up to the next -g file, or the end (minus 	 shared libraries).  This only matters for single stepping, 	 and even then it will still work, except that it will single 	 step through all of the covered functions, instead of setting 	 breakpoints around them as it usualy does.  This makes it 	 pretty slow, but at least it doesn't fail.  	 We can fix this with a fairly big change to bfd, but we need 	 to coordinate better with Cygnus if we want to do that.  FIXME.  */
block|}
name|last_function_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* this test will be true if the last .o file is only data */
if|if
condition|(
name|pst
operator|->
name|textlow
operator|==
literal|0
condition|)
name|pst
operator|->
name|textlow
operator|=
name|pst
operator|->
name|texthigh
expr_stmt|;
comment|/* If we know our own starting text address, then walk through all other      psymtabs for this objfile, and if any didn't know their ending text      address, set it to our starting address.  Take care to not set our      own ending address to our starting address, nor to set addresses on      `dependency' files that have both textlow and texthigh zero.  */
if|if
condition|(
name|pst
operator|->
name|textlow
condition|)
block|{
name|ALL_OBJFILE_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|p1
argument_list|)
block|{
if|if
condition|(
name|p1
operator|->
name|texthigh
operator|==
literal|0
operator|&&
name|p1
operator|->
name|textlow
operator|!=
literal|0
operator|&&
name|p1
operator|!=
name|pst
condition|)
block|{
name|p1
operator|->
name|texthigh
operator|=
name|pst
operator|->
name|textlow
expr_stmt|;
comment|/* if this file has only data, then make textlow match texthigh */
if|if
condition|(
name|p1
operator|->
name|textlow
operator|==
literal|0
condition|)
name|p1
operator|->
name|textlow
operator|=
name|p1
operator|->
name|texthigh
expr_stmt|;
block|}
block|}
block|}
comment|/* End of kludge for patching Solaris textlow and texthigh.  */
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|number_of_dependencies
operator|=
name|number_dependencies
expr_stmt|;
if|if
condition|(
name|number_dependencies
condition|)
block|{
name|pst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pst
operator|->
name|dependencies
argument_list|,
name|dependency_list
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pst
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_includes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|subpst
init|=
name|allocate_psymtab
argument_list|(
name|include_list
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|subpst
operator|->
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|subpst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|subpst
argument_list|)
operator|=
name|LDSYMLEN
argument_list|(
name|subpst
argument_list|)
operator|=
name|subpst
operator|->
name|textlow
operator|=
name|subpst
operator|->
name|texthigh
operator|=
literal|0
expr_stmt|;
comment|/* We could save slight bits of space by only making one of these, 	 shared by the entire set of include files.  FIXME-someday.  */
name|subpst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|dependencies
index|[
literal|0
index|]
operator|=
name|pst
expr_stmt|;
name|subpst
operator|->
name|number_of_dependencies
operator|=
literal|1
expr_stmt|;
name|subpst
operator|->
name|globals_offset
operator|=
name|subpst
operator|->
name|n_global_syms
operator|=
name|subpst
operator|->
name|statics_offset
operator|=
name|subpst
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|symtab
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|read_symtab
operator|=
name|dbx_psymtab_to_symtab
expr_stmt|;
block|}
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this name, remove it.      (If there is a symtab, more drastic things also happen.)      This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_includes
operator|==
literal|0
operator|&&
name|number_dependencies
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
condition|)
block|{
comment|/* Throw away this psymtab, it's empty.  We can't deallocate it, since        it is on the obstack, but we can forget to chain it on the list.  */
name|struct
name|partial_symtab
modifier|*
name|prev_pst
decl_stmt|;
comment|/* First, snip it out of the psymtab chain */
if|if
condition|(
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|==
name|pst
condition|)
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|=
name|pst
operator|->
name|next
expr_stmt|;
else|else
for|for
control|(
name|prev_pst
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|prev_pst
condition|;
name|prev_pst
operator|=
name|pst
operator|->
name|next
control|)
if|if
condition|(
name|prev_pst
operator|->
name|next
operator|==
name|pst
condition|)
name|prev_pst
operator|->
name|next
operator|=
name|pst
operator|->
name|next
expr_stmt|;
comment|/* Next, put it on a free list for recycling */
name|pst
operator|->
name|next
operator|=
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|pst
operator|->
name|objfile
operator|->
name|free_psymtabs
operator|=
name|pst
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dbx_psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in all partial symtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Flush output */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|dbx_psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
condition|)
comment|/* Otherwise it's a dummy */
block|{
comment|/* Init stuff necessary for reading in symbols */
name|stabsread_init
argument_list|()
expr_stmt|;
name|buildsym_init
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|file_string_table_offset
operator|=
name|FILE_STRING_OFFSET
argument_list|(
name|pst
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|symbol_size
operator|=
name|obj_dbx_symbol_entry_size
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
else|#
directive|else
name|symbol_size
operator|=
name|SYMBOL_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Read in this file's symbols */
name|bfd_seek
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
name|SYMBOL_OFFSET
argument_list|(
name|pst
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|pst
operator|->
name|symtab
operator|=
name|read_ofile_symtab
argument_list|(
name|pst
operator|->
name|objfile
argument_list|,
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
argument_list|,
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
argument_list|,
name|pst
operator|->
name|textlow
argument_list|,
name|pst
operator|->
name|texthigh
operator|-
name|pst
operator|->
name|textlow
argument_list|,
name|pst
operator|->
name|section_offsets
argument_list|)
expr_stmt|;
name|sort_symtab_syms
argument_list|(
name|pst
operator|->
name|symtab
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all of the symbols for a given psymtab for real.    Be verbose about it if the user wants that.  */
end_comment

begin_function
specifier|static
name|void
name|dbx_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before reading the string table, 	 to avoid disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|sym_bfd
operator|=
name|pst
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
name|next_symbol_text_func
operator|=
name|dbx_next_symbol_text
expr_stmt|;
name|dbx_psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This only needs to be done once,          after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|(
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in a defined section of a specific object file's symbols.       DESC is the file descriptor for the file, positioned at the    beginning of the symtab    SYM_OFFSET is the offset within the file of    the beginning of the symbols we want to read    SYM_SIZE is the size of the symbol info to read in.    TEXT_OFFSET is the beginning of the text segment we are reading symbols for    TEXT_SIZE is the size of the text segment read in.    SECTION_OFFSETS are the relocation offsets which get added to each symbol. */
end_comment

begin_function
specifier|static
name|struct
name|symtab
modifier|*
name|read_ofile_symtab
parameter_list|(
name|objfile
parameter_list|,
name|sym_offset
parameter_list|,
name|sym_size
parameter_list|,
name|text_offset
parameter_list|,
name|text_size
parameter_list|,
name|section_offsets
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|sym_offset
decl_stmt|;
name|int
name|sym_size
decl_stmt|;
name|CORE_ADDR
name|text_offset
decl_stmt|;
name|int
name|text_size
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|namestring
decl_stmt|;
specifier|register
name|struct
name|internal_nlist
modifier|*
name|bufp
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
name|unsigned
name|max_symnum
decl_stmt|;
specifier|register
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|symtab
modifier|*
name|rtn
decl_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|subfile_stack
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|stringtab_global
operator|=
name|HP_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|stringtab_global
operator|=
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|symfile_bfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* Implicit param to next_text_symbol */
name|symbuf_end
operator|=
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
comment|/* It is necessary to actually read one symbol *before* the start      of this symtab's symbols, because the GCC_COMPILED_FLAG_SYMBOL      occurs before the N_SO symbol.       Detecting this in read_dbx_symtab      would slow down initial readin, so we look for it here instead.  */
if|if
condition|(
operator|!
name|processing_acc_compilation
operator|&&
name|sym_offset
operator|>=
operator|(
name|int
operator|)
name|symbol_size
condition|)
block|{
name|bfd_seek
argument_list|(
name|symfile_bfd
argument_list|,
name|sym_offset
operator|-
name|symbol_size
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
name|SWAP_SYMBOL
argument_list|(
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|n_type
operator|==
name|N_TEXT
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
name|processing_gcc_compilation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Try to select a C++ demangling based on the compilation unit 	 producer. */
if|if
condition|(
name|processing_gcc_compilation
condition|)
block|{
if|#
directive|if
literal|1
comment|/* Works, but is experimental.  -fnf */
if|if
condition|(
name|AUTO_DEMANGLING
condition|)
block|{
name|set_demangling_style
argument_list|(
name|GNU_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* The N_SO starting this symtab is the first symbol, so we 	 better not check the symbol before it.  I'm not this can 	 happen, but it doesn't hurt to check for it.  */
name|bfd_seek
argument_list|(
name|symfile_bfd
argument_list|,
name|sym_offset
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
index|]
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|n_type
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|N_SO
condition|)
name|error
argument_list|(
literal|"First symbol in segment of executable not a source symbol"
argument_list|)
expr_stmt|;
name|max_symnum
operator|=
name|sym_size
operator|/
name|symbol_size
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|max_symnum
condition|;
name|symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
name|SWAP_SYMBOL
argument_list|(
name|bufp
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|type
operator|=
name|bufp
operator|->
name|n_type
expr_stmt|;
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|N_STAB
condition|)
block|{
name|process_one_symbol
argument_list|(
name|type
argument_list|,
name|bufp
operator|->
name|n_desc
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|namestring
argument_list|,
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* We skip checking for a new .o or -l file; that should never          happen in this routine. */
elseif|else
if|if
condition|(
name|type
operator|==
name|N_TEXT
condition|)
block|{
comment|/* I don't think this code will ever be executed, because 	     the GCC_COMPILED_FLAG_SYMBOL usually is right before 	     the N_SO symbol which starts this source file. 	     However, there is no reason not to accept 	     the GCC_COMPILED_FLAG_SYMBOL anywhere.  */
if|if
condition|(
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
name|processing_gcc_compilation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Works, but is experimental.  -fnf */
if|if
condition|(
name|AUTO_DEMANGLING
condition|)
block|{
name|set_demangling_style
argument_list|(
name|GNU_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type
operator|&
name|N_EXT
operator|||
name|type
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_TEXT
operator|||
name|type
operator|==
operator|(
name|unsigned
name|char
operator|)
name|N_NBTEXT
condition|)
block|{
comment|/* Global symbol: see if we came across a dbx defintion for 	     a corresponding symbol.  If so, store the value.  Remove 	     syms from the chain when their values are stored, but 	     search the whole chain, as there may be several syms from 	     different files with the same name. */
comment|/* This is probably not true.  Since the files will be read 	     in one at a time, each reference to a global symbol will 	     be satisfied in each file as it appears. So we skip this 	     section. */
empty_stmt|;
block|}
block|}
name|current_objfile
operator|=
name|NULL
expr_stmt|;
comment|/* In a Solaris elf file, this variable, which comes from the      value of the N_SO symbol, will still be 0.  Luckily, text_offset,      which comes from pst->textlow is correct. */
if|if
condition|(
name|last_source_start_addr
operator|==
literal|0
condition|)
name|last_source_start_addr
operator|=
name|text_offset
expr_stmt|;
name|rtn
operator|=
name|end_symtab
argument_list|(
name|text_offset
operator|+
name|text_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
return|return
operator|(
name|rtn
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This handles a single symbol from the symbol-file, building symbols    into a GDB symtab.  It takes these arguments and an implicit argument.     TYPE is the type field of the ".stab" symbol entry.    DESC is the desc field of the ".stab" entry.    VALU is the value field of the ".stab" entry.    NAME is the symbol name, in our address space.    SECTION_OFFSETS is a set of amounts by which the sections of this object           file were relocated when it was loaded into memory.           All symbols that refer 	  to memory locations need to be offset by these amounts.    OBJFILE is the object file from which we are reading symbols.  	       It is used in end_symtab.  */
end_comment

begin_function
name|void
name|process_one_symbol
parameter_list|(
name|type
parameter_list|,
name|desc
parameter_list|,
name|valu
parameter_list|,
name|name
parameter_list|,
name|section_offsets
parameter_list|,
name|objfile
parameter_list|)
name|int
name|type
decl_stmt|,
name|desc
decl_stmt|;
name|CORE_ADDR
name|valu
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|SUN_FIXED_LBRAC_BUG
comment|/* This records the last pc address we've seen.  We depend on there being      an SLINE or FUN or SO before the first LBRAC, since the variable does      not get reset in between reads of different symbol files.  */
specifier|static
name|CORE_ADDR
name|last_pc_address
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
comment|/* This remembers the address of the start of a function.  It is used      because in Solaris 2, N_LBRAC, N_RBRAC, and N_SLINE entries are      relative to the current function's start address.  On systems      other than Solaris 2, this just holds the SECT_OFF_TEXT value, and is      used to relocate these symbol types rather than SECTION_OFFSETS.  */
specifier|static
name|CORE_ADDR
name|function_start_offset
decl_stmt|;
name|char
modifier|*
name|colon_pos
decl_stmt|;
comment|/* Something is wrong if we see real data before      seeing a source file name.  */
if|if
condition|(
name|last_source_file
operator|==
name|NULL
operator|&&
name|type
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|N_SO
condition|)
block|{
comment|/* Currently this ignores N_ENTRY on Gould machines, N_NSYM on machines 	 where that code is defined.  */
if|if
condition|(
name|IGNORE_SYMBOL
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* FIXME, this should not be an error, since it precludes extending          the symbol table information in this way...  */
name|error
argument_list|(
literal|"Invalid symbol data: does not start by identifying a source file."
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_FUN
case|:
case|case
name|N_FNAME
case|:
if|#
directive|if
literal|0
comment|/* It seems that the Sun ANSI C compiler (acc) replaces N_FUN with N_GSYM and    N_STSYM with a type code of f or F.  Can't enable this until we get some    stuff straightened out with psymtabs.  FIXME. */
block|case N_GSYM:     case N_STSYM:
endif|#
directive|endif
comment|/* 0 */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
comment|/* Either of these types of symbols indicates the start of 	 a new function.  We must process its "name" normally for dbx, 	 but also record the start of a new lexical context, and possibly 	 also the end of the lexical context for the previous function.  */
comment|/* This is not always true.  This type of symbol may indicate a          text segment variable.  */
name|colon_pos
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon_pos
operator|++
operator|||
operator|(
operator|*
name|colon_pos
operator|!=
literal|'f'
operator|&&
operator|*
name|colon_pos
operator|!=
literal|'F'
operator|)
condition|)
block|{
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|SUN_FIXED_LBRAC_BUG
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BLOCK_ADDRESS_FUNCTION_RELATIVE
comment|/* On Solaris 2.0 compilers, the block addresses and N_SLINE's 	 are relative to the start of the function.  On normal systems, 	 and when using gcc on Solaris 2.0, these addresses are just 	 absolute, or relative to the N_SO, depending on 	 BLOCK_ADDRESS_ABSOLUTE.  */
name|function_start_offset
operator|=
name|valu
expr_stmt|;
else|#
directive|else
comment|/* Default on ordinary systems */
name|function_start_offset
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|within_function
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|!=
literal|0
condition|)
name|complain
argument_list|(
operator|&
name|lbrac_unmatched_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symnum
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_LBRAC
case|:
comment|/* This "symbol" just indicates the start of an inner lexical 	 context within a function.  */
if|#
directive|if
name|defined
argument_list|(
name|BLOCK_ADDRESS_ABSOLUTE
argument_list|)
operator|||
name|defined
argument_list|(
name|BLOCK_ADDRESS_FUNCTION_RELATIVE
argument_list|)
comment|/* Relocate for dynamic loading and Sun ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
else|#
directive|else
comment|/* On most machines, the block addresses are relative to the 	 N_SO, the linker did not relocate them (sigh).  */
name|valu
operator|+=
name|last_source_start_addr
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SUN_FIXED_LBRAC_BUG
if|if
condition|(
name|valu
operator|<
name|last_pc_address
condition|)
block|{
comment|/* Patch current LBRAC pc value to match last handy pc value */
name|complain
argument_list|(
operator|&
name|lbrac_complaint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|valu
operator|=
name|last_pc_address
expr_stmt|;
block|}
endif|#
directive|endif
name|new
operator|=
name|push_context
argument_list|(
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
comment|/* This "symbol" just indicates the end of an inner lexical 	 context that was started with N_LBRAC.  */
if|#
directive|if
name|defined
argument_list|(
name|BLOCK_ADDRESS_ABSOLUTE
argument_list|)
operator|||
name|defined
argument_list|(
name|BLOCK_ADDRESS_FUNCTION_RELATIVE
argument_list|)
comment|/* Relocate for dynamic loading and Sun ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
else|#
directive|else
comment|/* On most machines, the block addresses are relative to the 	 N_SO, the linker did not relocate them (sigh).  */
name|valu
operator|+=
name|last_source_start_addr
expr_stmt|;
endif|#
directive|endif
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|new
operator|->
name|depth
condition|)
name|complain
argument_list|(
operator|&
name|lbrac_mismatch_complaint
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symnum
argument_list|)
expr_stmt|;
comment|/* Some compilers put the variable decls inside of an          LBRAC/RBRAC block.  This macro should be nonzero if this 	 is true.  DESC is N_DESC from the N_RBRAC symbol. 	 GCC_P is true if we've detected the GCC_COMPILED_SYMBOL 	 or the GCC2_COMPILED_SYMBOL.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VARIABLES_INSIDE_BLOCK
argument_list|)
define|#
directive|define
name|VARIABLES_INSIDE_BLOCK
parameter_list|(
name|desc
parameter_list|,
name|gcc_p
parameter_list|)
value|0
endif|#
directive|endif
comment|/* Can only use new->locals as local symbols here if we're in          gcc or on a machine that puts them before the lbrack.  */
if|if
condition|(
operator|!
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
comment|/* If this is not the outermost LBRAC...RBRAC pair in the 	 function, its local symbols preceded it, and are the ones 	 just recovered from the context stack.  Defined the block for them.  	 If this is the outermost LBRAC...RBRAC pair, there is no 	 need to do anything; leave the symbols that preceded it 	 to be attached to the function's own block.  However, if 	 it is so, we need to indicate that we just moved outside 	 of the function.  */
if|if
condition|(
name|local_symbols
operator|&&
operator|(
name|context_stack_depth
operator|>
operator|!
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
operator|)
condition|)
block|{
comment|/* FIXME Muzzle a compiler bug that makes end< start.  */
if|if
condition|(
name|new
operator|->
name|start_addr
operator|>
name|valu
condition|)
block|{
name|complain
argument_list|(
operator|&
name|lbrac_rbrac_complaint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|valu
expr_stmt|;
block|}
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|valu
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|within_function
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|,
name|processing_gcc_compilation
argument_list|)
condition|)
comment|/* Now pop locals of block just finished.  */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
break|break;
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
comment|/* This kind of symbol indicates the start of an object file.  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
comment|/* This type of symbol indicates the start of data 	 for one source file. 	 Finish the symbol table of the previous source file 	 (if any) and start accumulating a new symbol table.  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SUN_FIXED_LBRAC_BUG
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_SOL_BROKEN
comment|/* pcc bug, occasionally puts out SO for SOL.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|start_subfile
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|last_source_file
condition|)
block|{
comment|/* Check if previous symbol was also an N_SO (with some 	     sanity checks).  If so, that one was actually the directory 	     name, and the current one is the real file name. 	     Patch things up. */
if|if
condition|(
name|previous_stab_code
operator|==
name|N_SO
condition|)
block|{
name|patch_subfile_names
argument_list|(
name|current_subfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
comment|/* Ignore repeated SOs */
block|}
name|end_symtab
argument_list|(
name|valu
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
comment|/* This type of symbol indicates the start of data for 	 a sub-source-file, one whose contents were copied or 	 included in the compilation of the main source file 	 (whose name was given in the N_SO symbol.)  */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BINCL
case|:
name|push_subfile
argument_list|()
expr_stmt|;
name|add_new_header_file
argument_list|(
name|name
argument_list|,
name|valu
argument_list|)
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EINCL
case|:
name|start_subfile
argument_list|(
name|pop_subfile
argument_list|()
argument_list|,
name|current_subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EXCL
case|:
name|add_old_header_file
argument_list|(
name|name
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
comment|/* This type of "symbol" really just records 	 one line-number -- core-address correspondence. 	 Enter it in the line list for this symbol table.  */
comment|/* Relocate for dynamic loading and for ELF acc fn-relative syms.  */
name|valu
operator|+=
name|function_start_offset
expr_stmt|;
ifndef|#
directive|ifndef
name|SUN_FIXED_LBRAC_BUG
name|last_pc_address
operator|=
name|valu
expr_stmt|;
comment|/* Save for SunOS bug circumcision */
endif|#
directive|endif
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|desc
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BCOMM
case|:
if|if
condition|(
name|common_block
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: common within common at symtab pos %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|common_block
operator|=
name|local_symbols
expr_stmt|;
name|common_block_i
operator|=
name|local_symbols
condition|?
name|local_symbols
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|N_ECOMM
case|:
comment|/* Symbols declared since the BCOMM are to have the common block 	 start address added in when we know it.  common_block points to 	 the first symbol after the BCOMM in the local_symbols list; 	 copy the list and hang it off the symbol for the common block name 	 for later fixup.  */
block|{
name|int
name|i
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|sym
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
expr|enum
name|namespace
operator|)
operator|(
operator|(
name|long
operator|)
name|copy_pending
argument_list|(
name|local_symbols
argument_list|,
name|common_block_i
argument_list|,
name|common_block
argument_list|)
operator|)
expr_stmt|;
name|i
operator|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_CHAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|global_sym_chain
index|[
name|i
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|common_block
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* The following symbol types need to have the appropriate offset added        to their value; then we process symbol definitions in the name.  */
case|case
name|N_STSYM
case|:
comment|/* Static symbol in data seg */
case|case
name|N_LCSYM
case|:
comment|/* Static symbol in BSS seg */
case|case
name|N_ROSYM
case|:
comment|/* Static symbol in Read-only data seg */
comment|/* HORRID HACK DEPT.  However, it's Sun's furgin' fault.  FIXME. 	Solaris2's stabs-in-coff makes *most* symbols relative 	but leaves a few absolute.  N_STSYM and friends sit on the fence. 	.stab "foo:S...",N_STSYM 	is absolute (ld relocates it) 	.stab "foo:V...",N_STSYM	is relative (section base subtracted). 	This leaves us no choice but to search for the 'S' or 'V'... 	(or pass the whole section_offsets stuff down ONE MORE function 	call level, which we really don't want to do).  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'S'
condition|)
block|{
comment|/* FIXME!  We relocate it by the TEXT offset, in case the 	       whole module moved in memory.  But this is wrong, since 	       the sections can side around independently.  */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
block|}
comment|/* Since it's not the kludge case, re-dispatch to the right handler. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_STSYM
case|:
goto|goto
name|case_N_STSYM
goto|;
case|case
name|N_LCSYM
case|:
goto|goto
name|case_N_LCSYM
goto|;
case|case
name|N_ROSYM
case|:
goto|goto
name|case_N_ROSYM
goto|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|case_N_STSYM
label|:
comment|/* Static symbol in data seg */
case|case
name|N_DSLINE
case|:
comment|/* Source line number, data seg */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
name|case_N_LCSYM
label|:
comment|/* Static symbol in BSS seg */
case|case
name|N_BSLINE
case|:
comment|/* Source line number, bss seg */
comment|/*   N_BROWS:	overlaps with N_BSLINE */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
name|case_N_ROSYM
label|:
comment|/* Static symbol in Read-only data seg */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_RODATA
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
case|case
name|N_ENTRY
case|:
comment|/* Alternate entry point */
comment|/* Relocate for dynamic loading */
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
goto|goto
name|define_a_symbol
goto|;
comment|/* The following symbol types don't need the address field relocated,        since it is either unused, or is absolute.  */
name|define_a_symbol
label|:
case|case
name|N_GSYM
case|:
comment|/* Global variable */
case|case
name|N_NSYMS
case|:
comment|/* Number of symbols (ultrix) */
case|case
name|N_NOMAP
case|:
comment|/* No map?  (ultrix) */
case|case
name|N_DEFD
case|:
comment|/* Modula-2 GNU module dependency */
case|case
name|N_SSYM
case|:
comment|/* Struct or union element */
case|case
name|N_LSYM
case|:
comment|/* Local symbol in stack */
case|case
name|N_PSYM
case|:
comment|/* Parameter variable */
case|case
name|N_LENG
case|:
comment|/* Length of preceding symbol type */
if|if
condition|(
name|name
condition|)
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RSYM
case|:
comment|/* Register variable */
comment|/* XXX - bugs in gcc 2.1: the bogus name 'in$chrg' is output        * for no clear reason with totally bogus values.  We ignore        * it.  Also, when inline functions are invoked, an entry for        * their "this" pointer is output.  Unfortunately, it is usually        * output as type 'P' instead of 'r' so gdb thinks there are        * multiple 'this' arguments to the same function.  We change        * the type of all but the first 'P' to 'r' (reg var).  (Note        * that we (ab)use the fact that 'this' is the first parameter        * and, thus, the first local symbol.)        * CHECK THIS WHEN WE SWITCH TO GCC 2.2.x!        */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__in$chrg:"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|local_symbols
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"$t:P"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|name
index|[
literal|3
index|]
operator|=
literal|'r'
expr_stmt|;
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* We use N_OPT to carry the gcc2_compiled flag.  Sun uses it        for a bunch of other flags, too.  Someday we may parse their        flags; for now we ignore theirs and hope they'll ignore ours.  */
case|case
name|N_OPT
case|:
comment|/* Solaris 2:  Compiler options */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Works, but is experimental.  -fnf */
if|if
condition|(
name|AUTO_DEMANGLING
condition|)
block|{
name|set_demangling_style
argument_list|(
name|GNU_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
break|break;
comment|/* The following symbol types can be ignored.  */
case|case
name|N_OBJ
case|:
comment|/* Solaris 2:  Object file dir and name */
comment|/*   N_UNDF: 		   Solaris 2:  file separator mark */
comment|/*   N_UNDF: -- we will never encounter it, since we only process one 		    file's symbols at once.  */
case|case
name|N_ENDM
case|:
comment|/* Solaris 2:  End of module */
case|case
name|N_MAIN
case|:
comment|/* Name of main routine.  */
break|break;
comment|/* The following symbol types we don't know how to process.  Handle        them in a "default" way, but complain to people who care.  */
default|default:
case|case
name|N_CATCH
case|:
comment|/* Exception handler catcher */
case|case
name|N_EHDECL
case|:
comment|/* Exception handler name */
case|case
name|N_PC
case|:
comment|/* Global symbol in Pascal */
case|case
name|N_M2C
case|:
comment|/* Modula-2 compilation unit */
comment|/*   N_MOD2:	overlaps with N_EHDECL */
case|case
name|N_SCOPE
case|:
comment|/* Modula-2 scope information */
case|case
name|N_ECOML
case|:
comment|/* End common (local name) */
case|case
name|N_NBTEXT
case|:
comment|/* Gould Non-Base-Register symbols??? */
case|case
name|N_NBDATA
case|:
case|case
name|N_NBBSS
case|:
case|case
name|N_NBSTS
case|:
case|case
name|N_NBLCS
case|:
name|complain
argument_list|(
operator|&
name|unknown_symtype_complaint
argument_list|,
name|local_hex_string
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|define_symbol
argument_list|(
name|valu
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|previous_stab_code
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy a pending list, used to record the contents of a common    block for later fixup.  */
end_comment

begin_function
specifier|static
name|struct
name|pending
modifier|*
name|copy_pending
parameter_list|(
name|beg
parameter_list|,
name|begi
parameter_list|,
name|end
parameter_list|)
name|struct
name|pending
modifier|*
name|beg
decl_stmt|;
name|int
name|begi
decl_stmt|;
name|struct
name|pending
modifier|*
name|end
decl_stmt|;
block|{
name|struct
name|pending
modifier|*
name|new
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|beg
init|;
name|next
operator|!=
literal|0
operator|&&
operator|(
name|next
operator|!=
name|end
operator|||
name|begi
operator|<
name|end
operator|->
name|nsyms
operator|)
condition|;
name|next
operator|=
name|next
operator|->
name|next
operator|,
name|begi
operator|=
literal|0
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|begi
init|;
name|j
operator|<
name|next
operator|->
name|nsyms
condition|;
name|j
operator|++
control|)
name|add_symbol_to_list
argument_list|(
name|next
operator|->
name|symbol
index|[
name|j
index|]
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan and build partial symbols for an ELF symbol file.    This ELF file has already been processed to get its minimal symbols,    and any DWARF symbols that were in it.     This routine is the equivalent of dbx_symfile_init and dbx_symfile_read    rolled into one.     OBJFILE is the object file we are reading symbols from.    ADDR is the address relative to which the symbols are (e.g.    the base address of the text segment).    MAINLINE is true if we are reading the main symbol    table (as opposed to a shared lib or dynamically loaded file).    STABOFFSET and STABSIZE define the location in OBJFILE where the .stab    section exists.    STABSTROFFSET and STABSTRSIZE define the location in OBJFILE where the    .stabstr section exists.     This routine is mostly copied from dbx_symfile_init and dbx_symfile_read,    adjusted for elf details. */
end_comment

begin_function
name|void
name|elfstab_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|,
name|staboffset
parameter_list|,
name|stabsize
parameter_list|,
name|stabstroffset
parameter_list|,
name|stabstrsize
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|file_ptr
name|staboffset
decl_stmt|;
name|unsigned
name|int
name|stabsize
decl_stmt|;
name|file_ptr
name|stabstroffset
decl_stmt|;
name|unsigned
name|int
name|stabstrsize
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|sym_bfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|bfd_get_filename
argument_list|(
name|sym_bfd
argument_list|)
decl_stmt|;
name|struct
name|dbx_symfile_info
modifier|*
name|info
decl_stmt|;
comment|/* There is already a dbx_symfile_info allocated by our caller.      It might even contain some info from the ELF symtab to help us.  */
name|info
operator|=
operator|(
expr|struct
name|dbx_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
expr_stmt|;
name|DBX_TEXT_SECT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DBX_TEXT_SECT
argument_list|(
name|objfile
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't find .text section in symbol file"
argument_list|)
expr_stmt|;
define|#
directive|define
name|ELF_STABS_SYMBOL_SIZE
value|12
comment|/* XXX FIXME XXX */
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|ELF_STABS_SYMBOL_SIZE
expr_stmt|;
name|DBX_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabsize
operator|/
name|DBX_SYMBOL_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|stabstrsize
expr_stmt|;
name|DBX_SYMTAB_OFFSET
argument_list|(
name|objfile
argument_list|)
operator|=
name|staboffset
expr_stmt|;
if|if
condition|(
name|stabstrsize
operator|<
literal|0
condition|)
comment|/* FIXME:  stabstrsize is unsigned; never true! */
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|stabstrsize
argument_list|)
expr_stmt|;
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|stabstrsize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now read in the string table in one big gulp.  */
name|val
operator|=
name|bfd_seek
argument_list|(
name|sym_bfd
argument_list|,
name|stabstroffset
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|DBX_STRINGTAB
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|stabstrsize
argument_list|,
literal|1
argument_list|,
name|sym_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|stabstrsize
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
name|free_header_files
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|processing_acc_compilation
operator|=
literal|1
expr_stmt|;
comment|/* In an elf file, we've already installed the minimal symbols that came      from the elf (non-stab) symbol table, so always act like an      incremental load here. */
name|dbx_symfile_read
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the user's idea of an offset for dynamic linking, into our idea    of how to represent it for fast symbol reading.  */
end_comment

begin_function
name|struct
name|section_offsets
modifier|*
name|dbx_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
operator|(
name|SECT_OFF_MAX
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|section_offsets
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register our willingness to decode symbols for SunOS and a.out and    b.out files handled by BFD... */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|sunos_sym_fns
init|=
block|{
literal|"sunOs"
block|,
comment|/* sym_name: name or name prefix of BFD target type */
literal|6
block|,
comment|/* sym_namelen: number of significant sym_name chars */
name|dbx_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|dbx_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|dbx_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|dbx_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|dbx_symfile_offsets
block|,
comment|/* sym_offsets: parse user's offsets to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|aout_sym_fns
init|=
block|{
literal|"a.out"
block|,
comment|/* sym_name: name or name prefix of BFD target type */
literal|5
block|,
comment|/* sym_namelen: number of significant sym_name chars */
name|dbx_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|dbx_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|dbx_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|dbx_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|dbx_symfile_offsets
block|,
comment|/* sym_offsets: parse user's offsets to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|bout_sym_fns
init|=
block|{
literal|"b.out"
block|,
comment|/* sym_name: name or name prefix of BFD target type */
literal|5
block|,
comment|/* sym_namelen: number of significant sym_name chars */
name|dbx_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|dbx_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|dbx_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|dbx_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|dbx_symfile_offsets
block|,
comment|/* sym_offsets: parse user's offsets to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is probably a mistake.  FIXME.  Why can't the HP's use an ordinary    file format name with an -hppa suffix?  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|hppa_sym_fns
init|=
block|{
literal|"hppa"
block|,
comment|/* sym_name: name or name prefix of BFD target type */
literal|4
block|,
comment|/* sym_namelen: number of significant sym_name chars */
name|dbx_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|dbx_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|dbx_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|dbx_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|dbx_symfile_offsets
block|,
comment|/* sym_offsets: parse user's offsets to internal form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_dbxread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|sunos_sym_fns
argument_list|)
expr_stmt|;
name|add_symtab_fns
argument_list|(
operator|&
name|aout_sym_fns
argument_list|)
expr_stmt|;
name|add_symtab_fns
argument_list|(
operator|&
name|bout_sym_fns
argument_list|)
expr_stmt|;
name|add_symtab_fns
argument_list|(
operator|&
name|hppa_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

