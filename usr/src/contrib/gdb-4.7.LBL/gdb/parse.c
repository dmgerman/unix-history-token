begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse expressions for GDB.    Copyright (C) 1986, 1989, 1990, 1991 Free Software Foundation, Inc.    Modified from expread.y by the Department of Computer Science at the    State University of New York at Buffalo, 1991.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Parse an expression from text in a string,    and return the result as a  struct expression  pointer.    That structure contains arithmetic operations in reverse polish,    with constants represented by operations that are followed by special data.    See expression.h for the details of the format.    What is important here is that it can be built up sequentially    during the process of parsing; the lower levels of the tree always    come first in the result.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|prefixify_expression
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|length_of_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefixify_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
expr|struct
name|expression
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign machine-independent names to certain registers     (unless overridden by the REGISTER_NAMES table) */
end_comment

begin_decl_stmt
name|struct
name|std_regs
name|std_regs
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|PC_REGNUM
block|{
literal|"pc"
block|,
name|PC_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FP_REGNUM
block|{
literal|"fp"
block|,
name|FP_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SP_REGNUM
block|{
literal|"sp"
block|,
name|SP_REGNUM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PS_REGNUM
block|{
literal|"ps"
block|,
name|PS_REGNUM
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|num_std_regs
init|=
operator|(
sizeof|sizeof
name|std_regs
operator|/
sizeof|sizeof
name|std_regs
index|[
literal|0
index|]
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Begin counting arguments for a function call,    saving the data about any containing call.  */
end_comment

begin_function
name|void
name|start_arglist
parameter_list|()
block|{
specifier|register
name|struct
name|funcall
modifier|*
name|new
init|=
operator|(
expr|struct
name|funcall
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|funcall
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|funcall_chain
expr_stmt|;
name|new
operator|->
name|arglist_len
operator|=
name|arglist_len
expr_stmt|;
name|arglist_len
operator|=
literal|0
expr_stmt|;
name|funcall_chain
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of arguments in a function call just terminated,    and restore the data for the containing function call.  */
end_comment

begin_function
name|int
name|end_arglist
parameter_list|()
block|{
specifier|register
name|int
name|val
init|=
name|arglist_len
decl_stmt|;
specifier|register
name|struct
name|funcall
modifier|*
name|call
init|=
name|funcall_chain
decl_stmt|;
name|funcall_chain
operator|=
name|call
operator|->
name|next
expr_stmt|;
name|arglist_len
operator|=
name|call
operator|->
name|arglist_len
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|call
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Free everything in the funcall chain.    Used when there is an error inside parsing.  */
end_comment

begin_function
name|void
name|free_funcalls
parameter_list|()
block|{
specifier|register
name|struct
name|funcall
modifier|*
name|call
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|call
operator|=
name|funcall_chain
init|;
name|call
condition|;
name|call
operator|=
name|next
control|)
block|{
name|next
operator|=
name|call
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|call
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the functions for adding data to the  struct expression    being constructed.  */
end_comment

begin_comment
comment|/* Add one element to the end of the expression.  */
end_comment

begin_comment
comment|/* To avoid a bug in the Sun 4 compiler, we pass things that can fit into    a register through here */
end_comment

begin_function
name|void
name|write_exp_elt
parameter_list|(
name|expelt
parameter_list|)
name|union
name|exp_element
name|expelt
decl_stmt|;
block|{
if|if
condition|(
name|expout_ptr
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|*=
literal|2
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|expout_size
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expout
operator|->
name|elts
index|[
name|expout_ptr
operator|++
index|]
operator|=
name|expelt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_opcode
parameter_list|(
name|expelt
parameter_list|)
name|enum
name|exp_opcode
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|opcode
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_sym
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|symbol
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|symbol
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_longcst
parameter_list|(
name|expelt
parameter_list|)
name|LONGEST
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|longconst
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_dblcst
parameter_list|(
name|expelt
parameter_list|)
name|double
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|doubleconst
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_type
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|type
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|type
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_exp_elt_intern
parameter_list|(
name|expelt
parameter_list|)
name|struct
name|internalvar
modifier|*
name|expelt
decl_stmt|;
block|{
name|union
name|exp_element
name|tmp
decl_stmt|;
name|tmp
operator|.
name|internalvar
operator|=
name|expelt
expr_stmt|;
name|write_exp_elt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string constant to the end of the expression.    Follow it by its length in bytes, as a separate exp_element.  */
end_comment

begin_function
name|void
name|write_exp_string
parameter_list|(
name|str
parameter_list|)
name|struct
name|stoken
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|str
operator|.
name|length
decl_stmt|;
specifier|register
name|int
name|lenelt
init|=
operator|(
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
decl_stmt|;
name|expout_ptr
operator|+=
name|lenelt
expr_stmt|;
if|if
condition|(
name|expout_ptr
operator|>=
name|expout_size
condition|)
block|{
name|expout_size
operator|=
name|max
argument_list|(
name|expout_size
operator|*
literal|2
argument_list|,
name|expout_ptr
operator|+
literal|10
argument_list|)
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
operator|(
name|expout_size
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|expout
operator|->
name|elts
index|[
name|expout_ptr
operator|-
name|lenelt
index|]
argument_list|,
name|str
operator|.
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|expout
operator|->
name|elts
index|[
name|expout_ptr
operator|-
name|lenelt
index|]
operator|)
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a null-terminated temporary copy of the name    of a string token.  */
end_comment

begin_function
name|char
modifier|*
name|copy_name
parameter_list|(
name|token
parameter_list|)
name|struct
name|stoken
name|token
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|namecopy
argument_list|,
name|token
operator|.
name|ptr
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
name|namecopy
index|[
name|token
operator|.
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|namecopy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reverse an expression from suffix form (in which it is constructed)    to prefix form (in which we can conveniently print or execute it).  */
end_comment

begin_function
specifier|static
name|void
name|prefixify_expression
parameter_list|(
name|expr
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|expr
operator|->
name|nelts
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|inpos
init|=
name|expr
operator|->
name|nelts
decl_stmt|,
name|outpos
init|=
literal|0
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the original expression into temp.  */
name|memcpy
argument_list|(
name|temp
argument_list|,
name|expr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|prefixify_subexp
argument_list|(
name|temp
argument_list|,
name|expr
argument_list|,
name|inpos
argument_list|,
name|outpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of exp_elements in the subexpression of EXPR    whose last exp_element is at index ENDPOS - 1 in EXPR.  */
end_comment

begin_function
specifier|static
name|int
name|length_of_subexp
parameter_list|(
name|expr
parameter_list|,
name|endpos
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|int
name|endpos
decl_stmt|;
block|{
specifier|register
name|int
name|oplen
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|args
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|endpos
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"?error in length_of_subexp"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
comment|/* C++  */
case|case
name|OP_SCOPE
case|:
name|oplen
operator|=
literal|4
operator|+
operator|(
operator|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
case|case
name|OP_DOUBLE
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_VAR_VALUE
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REGISTER
case|:
case|case
name|OP_INTERNALVAR
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
expr_stmt|;
break|break;
case|case
name|UNOP_MAX
case|:
case|case
name|UNOP_MIN
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BINOP_VAL
case|:
case|case
name|UNOP_CAST
case|:
case|case
name|UNOP_MEMVAL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_TRUNC
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
name|args
operator|=
literal|1
expr_stmt|;
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_STRING
case|:
name|oplen
operator|=
literal|3
operator|+
operator|(
operator|(
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|TERNOP_COND
case|:
name|args
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* Modula-2 */
case|case
name|BINOP_MULTI_SUBSCRIPT
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|expr
operator|->
name|elts
index|[
name|endpos
operator|-
literal|2
index|]
operator|.
name|longconst
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* C++ */
case|case
name|OP_THIS
case|:
name|oplen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|args
operator|=
literal|1
operator|+
operator|(
name|i
operator|<
operator|(
name|int
operator|)
name|BINOP_END
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|args
operator|>
literal|0
condition|)
block|{
name|oplen
operator|+=
name|length_of_subexp
argument_list|(
name|expr
argument_list|,
name|endpos
operator|-
name|oplen
argument_list|)
expr_stmt|;
name|args
operator|--
expr_stmt|;
block|}
return|return
name|oplen
return|;
block|}
end_function

begin_comment
comment|/* Copy the subexpression ending just before index INEND in INEXPR    into OUTEXPR, starting at index OUTBEG.    In the process, convert it from suffix to prefix form.  */
end_comment

begin_function
specifier|static
name|void
name|prefixify_subexp
parameter_list|(
name|inexpr
parameter_list|,
name|outexpr
parameter_list|,
name|inend
parameter_list|,
name|outbeg
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|inexpr
decl_stmt|;
name|struct
name|expression
modifier|*
name|outexpr
decl_stmt|;
specifier|register
name|int
name|inend
decl_stmt|;
name|int
name|outbeg
decl_stmt|;
block|{
specifier|register
name|int
name|oplen
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|args
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|arglens
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
comment|/* Compute how long the last operation is (in OPLEN),      and also how many preceding subexpressions serve as      arguments for it (in ARGS).  */
name|opcode
operator|=
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* C++  */
case|case
name|OP_SCOPE
case|:
name|oplen
operator|=
literal|4
operator|+
operator|(
operator|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
case|case
name|OP_DOUBLE
case|:
name|oplen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_VAR_VALUE
case|:
case|case
name|OP_LAST
case|:
case|case
name|OP_REGISTER
case|:
case|case
name|OP_INTERNALVAR
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
expr_stmt|;
break|break;
case|case
name|UNOP_MIN
case|:
case|case
name|UNOP_MAX
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UNOP_CAST
case|:
case|case
name|UNOP_MEMVAL
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_TRUNC
case|:
name|oplen
operator|=
literal|1
expr_stmt|;
name|args
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
name|args
operator|=
literal|1
expr_stmt|;
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_STRING
case|:
name|oplen
operator|=
literal|3
operator|+
operator|(
operator|(
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
operator|+
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|TERNOP_COND
case|:
name|args
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* Modula-2 */
case|case
name|BINOP_MULTI_SUBSCRIPT
case|:
name|oplen
operator|=
literal|3
expr_stmt|;
name|args
operator|=
literal|1
operator|+
name|inexpr
operator|->
name|elts
index|[
name|inend
operator|-
literal|2
index|]
operator|.
name|longconst
expr_stmt|;
break|break;
comment|/* C++ */
case|case
name|OP_THIS
case|:
name|oplen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|args
operator|=
literal|1
operator|+
operator|(
operator|(
name|int
operator|)
name|opcode
operator|<
operator|(
name|int
operator|)
name|BINOP_END
operator|)
expr_stmt|;
block|}
comment|/* Copy the final operator itself, from the end of the input      to the beginning of the output.  */
name|inend
operator|-=
name|oplen
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|outexpr
operator|->
name|elts
index|[
name|outbeg
index|]
argument_list|,
operator|&
name|inexpr
operator|->
name|elts
index|[
name|inend
index|]
argument_list|,
name|oplen
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
argument_list|)
expr_stmt|;
name|outbeg
operator|+=
name|oplen
expr_stmt|;
comment|/* Find the lengths of the arg subexpressions.  */
name|arglens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|args
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|args
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|oplen
operator|=
name|length_of_subexp
argument_list|(
name|inexpr
argument_list|,
name|inend
argument_list|)
expr_stmt|;
name|arglens
index|[
name|i
index|]
operator|=
name|oplen
expr_stmt|;
name|inend
operator|-=
name|oplen
expr_stmt|;
block|}
comment|/* Now copy each subexpression, preserving the order of      the subexpressions, but prefixifying each one.      In this loop, inend starts at the beginning of      the expression this level is working on      and marches forward over the arguments.      outbeg does similarly in the output.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
condition|;
name|i
operator|++
control|)
block|{
name|oplen
operator|=
name|arglens
index|[
name|i
index|]
expr_stmt|;
name|inend
operator|+=
name|oplen
expr_stmt|;
name|prefixify_subexp
argument_list|(
name|inexpr
argument_list|,
name|outexpr
argument_list|,
name|inend
argument_list|,
name|outbeg
argument_list|)
expr_stmt|;
name|outbeg
operator|+=
name|oplen
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains the two entry points to this file.  */
end_comment

begin_comment
comment|/* Read an expression from the string *STRINGPTR points to,    parse it, and return a pointer to a  struct expression  that we malloc.    Use block BLOCK as the lexical context for variable names;    if BLOCK is zero, use the block of the selected stack frame.    Meanwhile, advance *STRINGPTR to point after the expression,    at the first nonwhite character that is not part of the expression    (possibly a null character).     If COMMA is nonzero, stop if a comma is reached.  */
end_comment

begin_function
name|struct
name|expression
modifier|*
name|parse_exp_1
parameter_list|(
name|stringptr
parameter_list|,
name|block
parameter_list|,
name|comma
parameter_list|)
name|char
modifier|*
modifier|*
name|stringptr
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|comma
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|lexptr
operator|=
operator|*
name|stringptr
expr_stmt|;
name|paren_depth
operator|=
literal|0
expr_stmt|;
name|type_stack_depth
operator|=
literal|0
expr_stmt|;
name|comma_terminates
operator|=
name|comma
expr_stmt|;
if|if
condition|(
name|lexptr
operator|==
literal|0
operator|||
operator|*
name|lexptr
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"expression to compute"
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_funcalls
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funcall_chain
operator|=
literal|0
expr_stmt|;
name|expression_context_block
operator|=
name|block
condition|?
name|block
else|:
name|get_selected_block
argument_list|()
expr_stmt|;
name|namecopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|lexptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|expout_size
operator|=
literal|10
expr_stmt|;
name|expout_ptr
operator|=
literal|0
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|expout_size
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
argument_list|)
expr_stmt|;
name|expout
operator|->
name|language_defn
operator|=
name|current_language
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expout
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_language
operator|->
name|la_parser
argument_list|()
condition|)
name|current_language
operator|->
name|la_error
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|expout
operator|->
name|nelts
operator|=
name|expout_ptr
expr_stmt|;
name|expout
operator|=
operator|(
expr|struct
name|expression
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expression
argument_list|)
operator|+
name|expout_ptr
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
argument_list|)
expr_stmt|;
name|prefixify_expression
argument_list|(
name|expout
argument_list|)
expr_stmt|;
operator|*
name|stringptr
operator|=
name|lexptr
expr_stmt|;
return|return
name|expout
return|;
block|}
end_function

begin_comment
comment|/* Parse STRING as an expression, and complain if this fails    to use up all of the contents of STRING.  */
end_comment

begin_function
name|struct
name|expression
modifier|*
name|parse_expression
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|error
argument_list|(
literal|"Junk after end of expression."
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_function
name|void
name|push_type
parameter_list|(
name|tp
parameter_list|)
name|enum
name|type_pieces
name|tp
decl_stmt|;
block|{
if|if
condition|(
name|type_stack_depth
operator|==
name|type_stack_size
condition|)
block|{
name|type_stack_size
operator|*=
literal|2
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_stack
argument_list|,
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type_stack
index|[
name|type_stack_depth
operator|++
index|]
operator|.
name|piece
operator|=
name|tp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_type_int
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|type_stack_depth
operator|==
name|type_stack_size
condition|)
block|{
name|type_stack_size
operator|*=
literal|2
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|type_stack
argument_list|,
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type_stack
index|[
name|type_stack_depth
operator|++
index|]
operator|.
name|int_val
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|type_pieces
name|pop_type
parameter_list|()
block|{
if|if
condition|(
name|type_stack_depth
condition|)
return|return
name|type_stack
index|[
operator|--
name|type_stack_depth
index|]
operator|.
name|piece
return|;
return|return
name|tp_end
return|;
block|}
end_function

begin_function
name|int
name|pop_type_int
parameter_list|()
block|{
if|if
condition|(
name|type_stack_depth
condition|)
return|return
name|type_stack
index|[
operator|--
name|type_stack_depth
index|]
operator|.
name|int_val
return|;
comment|/* "Can't happen".  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|_initialize_parse
parameter_list|()
block|{
name|type_stack_size
operator|=
literal|80
expr_stmt|;
name|type_stack_depth
operator|=
literal|0
expr_stmt|;
name|type_stack
operator|=
operator|(
expr|union
name|type_stack_elt
operator|*
operator|)
name|xmalloc
argument_list|(
name|type_stack_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|type_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

