begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic symbol file reading for the GNU debugger, GDB.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.    Contributed by Cygnus Support, using pieces from other GDB modules.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Global variables owned by this file */
end_comment

begin_decl_stmt
name|int
name|readnow_symbol_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read full symbols immediately */
end_comment

begin_comment
comment|/* External variables and functions referenced. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions this file defines */
end_comment

begin_decl_stmt
specifier|static
name|void
name|set_initial_language
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_symbol_file_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cashier_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_psymbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_symbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_sym_fns
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|clear_symtab_users_once
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all available sym_fns.  On gdb startup, each object file reader    calls add_symtab_fns() to register information on each format it is    prepared to read. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
modifier|*
name|symtab_fns
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structures with which to manage partial symbol allocation.  */
end_comment

begin_decl_stmt
name|struct
name|psymbol_allocation_list
name|global_psymbols
init|=
block|{
literal|0
block|}
decl_stmt|,
name|static_psymbols
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for whether user will be reloading symbols multiple times.    Defaults to ON for VxWorks, otherwise OFF.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMBOL_RELOADING_DEFAULT
end_ifdef

begin_decl_stmt
name|int
name|symbol_reloading
init|=
name|SYMBOL_RELOADING_DEFAULT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|symbol_reloading
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Structure to manage complaints about symbol file contents.  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|complaint_root
index|[
literal|1
index|]
init|=
block|{
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|,
name|complaint_root
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some actual complaints.  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|oldsyms_complaint
init|=
block|{
literal|"Replacing old symbols for `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|empty_symtab_complaint
init|=
block|{
literal|"Empty symbol table found for `%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* In the following sort, we always make sure that    register debug symbol declarations always come before regular    debug symbol declarations (as might happen when parameters are    then put into registers by the compiler).     Since this function is called from within qsort, in an ANSI environment    it must conform to the prototype for qsort, which specifies that the    comparison function takes two "void *" pointers. */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
name|s1p
parameter_list|,
name|s2p
parameter_list|)
specifier|const
name|PTR
name|s1p
decl_stmt|;
specifier|const
name|PTR
name|s2p
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|s1
decl_stmt|,
modifier|*
modifier|*
name|s2
decl_stmt|;
specifier|register
name|int
name|namediff
decl_stmt|;
name|s1
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|s1p
expr_stmt|;
name|s2
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|s2p
expr_stmt|;
comment|/* Compare the initial characters.  */
name|namediff
operator|=
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
index|[
literal|0
index|]
operator|-
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|namediff
operator|!=
literal|0
condition|)
return|return
name|namediff
return|;
comment|/* If they match, compare the rest of the names.  */
name|namediff
operator|=
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|namediff
operator|!=
literal|0
condition|)
return|return
name|namediff
return|;
comment|/* For symbols of the same name, registers should come first.  */
return|return
operator|(
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s2
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|-
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	compare_psymbols -- compare two partial symbols by name  DESCRIPTION  	Given pointer to two partial symbol table entries, compare 	them by name and return -N, 0, or +N (ala strcmp).  Typically 	used by sorting routines like qsort().  NOTES  	Does direct compare of first two characters before punting 	and passing to strcmp for longer compares.  Note that the 	original version had a bug whereby two null strings or two 	identically named one character strings would return the 	comparison of memory following the null byte.   */
end_comment

begin_function
specifier|static
name|int
name|compare_psymbols
parameter_list|(
name|s1p
parameter_list|,
name|s2p
parameter_list|)
specifier|const
name|PTR
name|s1p
decl_stmt|;
specifier|const
name|PTR
name|s2p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|st1
init|=
name|SYMBOL_NAME
argument_list|(
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|s1p
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|st2
init|=
name|SYMBOL_NAME
argument_list|(
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|s2p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|st1
index|[
literal|0
index|]
operator|-
name|st2
index|[
literal|0
index|]
operator|)
operator|||
operator|!
name|st1
index|[
literal|0
index|]
condition|)
block|{
return|return
operator|(
name|st1
index|[
literal|0
index|]
operator|-
name|st2
index|[
literal|0
index|]
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|st1
index|[
literal|1
index|]
operator|-
name|st2
index|[
literal|1
index|]
operator|)
operator|||
operator|!
name|st1
index|[
literal|1
index|]
condition|)
block|{
return|return
operator|(
name|st1
index|[
literal|1
index|]
operator|-
name|st2
index|[
literal|1
index|]
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|st1
operator|+
literal|2
argument_list|,
name|st2
operator|+
literal|2
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sort_pst_symbols
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* Sort the global list; don't sort the static list */
name|qsort
argument_list|(
name|pst
operator|->
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
argument_list|,
name|pst
operator|->
name|n_global_syms
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|,
name|compare_psymbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call sort_block_syms to sort alphabetically the symbols of one block.  */
end_comment

begin_function
name|void
name|sort_block_syms
parameter_list|(
name|b
parameter_list|)
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
block|{
name|qsort
argument_list|(
operator|&
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call sort_symtab_syms to sort alphabetically    the symbols of each block of one symtab.  */
end_comment

begin_function
name|void
name|sort_symtab_syms
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|int
name|nbl
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nbl
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbl
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|sort_block_syms
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sort_all_symtab_syms
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|sort_symtab_syms
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make a copy of the string at PTR with SIZE characters in the symbol obstack    (and add a null character at the end in the copy).    Returns the address of the copy.  */
end_comment

begin_function
name|char
modifier|*
name|obsavestring
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|obstackp
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Open-coded bcopy--saves function call time.      These strings are usually short.  */
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|ptr
operator|+
name|size
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|end
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Concatenate strings S1, S2 and S3; return the new string.    Space is found in the symbol_obstack.  */
end_comment

begin_function
name|char
modifier|*
name|obconcat
parameter_list|(
name|obstackp
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|val
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* Get the symbol table that corresponds to a partial_symtab.    This is fast after the first time you do it.  In fact, there    is an even faster macro PSYMTAB_TO_SYMTAB that does the fast    case inline.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
specifier|register
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* If it's been looked up before, return it. */
if|if
condition|(
name|pst
operator|->
name|symtab
condition|)
return|return
name|pst
operator|->
name|symtab
return|;
comment|/* If it has not yet been read in, read it.  */
if|if
condition|(
operator|!
name|pst
operator|->
name|readin
condition|)
block|{
call|(
modifier|*
name|pst
operator|->
name|read_symtab
call|)
argument_list|(
name|pst
argument_list|)
expr_stmt|;
block|}
return|return
name|pst
operator|->
name|symtab
return|;
block|}
end_function

begin_comment
comment|/* Initialize entry point information for this objfile. */
end_comment

begin_function
name|void
name|init_entry_point_info
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* Save startup file's range of PC addresses to help blockframe.c      decide where the bottom of the stack is.  */
if|if
condition|(
name|bfd_get_file_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|&
name|EXEC_P
condition|)
block|{
comment|/* Executable file -- record its entry point so we'll recognize 	 the startup file because it contains the entry point.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|=
name|bfd_get_start_address
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Examination of non-executable.o files.  Short-circuit this stuff.  */
comment|/* ~0 will not be in any file, we hope.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* set the startup file to be an empty range.  */
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
literal|0
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remember the lowest-addressed loadable section we've seen.      This function is called via bfd_map_over_sections.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not used yet */
end_comment

begin_comment
unit|static void find_lowest_section (abfd, sect, obj)      bfd *abfd;      asection *sect;      PTR obj; {   asection **lowest = (asection **)obj;    if (0 == (bfd_get_section_flags (abfd, sect)& SEC_LOAD))     return;   if (!*lowest)     *lowest = sect;
comment|/* First loadable section */
end_comment

begin_comment
unit|else if (bfd_section_vma (abfd, *lowest)>= bfd_section_vma (abfd, sect))     *lowest = sect;
comment|/* A lower loadable section */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.     NAME is the file name (which will be tilde-expanded and made    absolute herein) (but we don't free or modify NAME itself).    FROM_TTY says how verbose to be.  MAINLINE specifies whether this    is the main symbol file, or whether it's an extra symbol file such    as dynamically loaded code.  If !mainline, ADDR is the address    where the text segment was loaded.  If VERBO, the caller has printed    a verbose message about the symbol reading (and complaints can be    more terse about it).  */
end_comment

begin_function
name|void
name|syms_from_objfile
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|,
name|mainline
parameter_list|,
name|verbo
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|verbo
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|asection
modifier|*
name|lowest_sect
decl_stmt|;
comment|/* There is a distinction between having no symbol table      (we refuse to read the file, leaving the old set of symbols around)      and having no debugging symbols in your symbol table (we read      the file and end up with a mostly empty symbol table).       FIXME:  This strategy works correctly when the debugging symbols are      intermixed with "normal" symbols.  However, when the debugging symbols      are separate, such as with ELF/DWARF, it is perfectly plausible for      the symbol table to be missing but still have all the DWARF info      intact.  Thus in general it is wrong to assume that having no symbol      table implies no debugging information. */
if|if
condition|(
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|&
name|HAS_SYMS
operator|)
condition|)
return|return;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|find_sym_fns
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainline
condition|)
block|{
comment|/* Since no error yet, throw away the old symbol table.  */
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
block|{
name|free_objfile
argument_list|(
name|symfile_objfile
argument_list|)
expr_stmt|;
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
block|}
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_new_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Convert addr into an offset rather than an absolute address.      We find the lowest address of a loaded segment in the objfile,      and assume that<addr> is where that got loaded.  Due to historical      precedent, we warn if that doesn't happen to be the ".text"      segment.  */
if|if
condition|(
name|mainline
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* No offset from objfile addresses.  */
block|}
else|else
block|{
name|lowest_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|lowest_sect = 0;       bfd_map_over_sections (objfile->obfd, find_lowest_section, 			     (PTR)&lowest_sect);
endif|#
directive|endif
if|if
condition|(
name|lowest_sect
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"no loadable sections found in added symbol-file %s"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|bfd_get_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
operator|||
literal|0
operator|!=
name|strcmp
argument_list|(
literal|".text"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Lowest section in %s is %s at 0x%x"
argument_list|,
name|objfile
operator|->
name|name
argument_list|,
name|bfd_section_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
argument_list|,
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
condition|)
name|addr
operator|-=
name|bfd_section_vma
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lowest_sect
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize symbol reading routines for this objfile, allow complaints to      appear for this new file, and record how verbose to be, then do the      initial symbol reading for this file. */
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_init
call|)
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|clear_complaints
argument_list|(
literal|1
argument_list|,
name|verbo
argument_list|)
expr_stmt|;
name|section_offsets
operator|=
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_offsets
call|)
argument_list|(
name|objfile
argument_list|,
name|addr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|objfile
operator|->
name|sf
operator|->
name|sym_read
call|)
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
comment|/* Don't allow char * to have a typename (else would get caddr_t.)  */
comment|/* Ditto void *.  FIXME should do this for all the builtin types.  */
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Mark the objfile has having had initial symbol read attempted.  Note      that this does not mean we found any symbols... */
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SYMS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform required actions immediately after either reading in the initial    symbols for a new objfile, or mapping in the symbols from a reusable    objfile. */
end_comment

begin_function
name|void
name|new_symfile_objfile
parameter_list|(
name|objfile
parameter_list|,
name|mainline
parameter_list|,
name|verbo
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|verbo
decl_stmt|;
block|{
if|if
condition|(
name|mainline
condition|)
block|{
comment|/* OK, make it the "real" symbol file.  */
name|symfile_objfile
operator|=
name|objfile
expr_stmt|;
block|}
comment|/* If we have wiped out any old symbol tables, clean up.  */
name|clear_symtab_users_once
argument_list|()
expr_stmt|;
comment|/* We're done reading the symbol file; finish off complaints.  */
name|clear_complaints
argument_list|(
literal|0
argument_list|,
name|verbo
argument_list|)
expr_stmt|;
comment|/* Fixup all the breakpoints that may have been redefined by this      symbol file. */
name|breakpoint_re_set
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a symbol file, as either the main file or as a dynamically    loaded file.     NAME is the file name (which will be tilde-expanded and made    absolute herein) (but we don't free or modify NAME itself).    FROM_TTY says how verbose to be.  MAINLINE specifies whether this    is the main symbol file, or whether it's an extra symbol file such    as dynamically loaded code.  If !mainline, ADDR is the address    where the text segment was loaded.     Upon success, returns a pointer to the objfile that was added.    Upon failure, jumps back to command level (never returns). */
end_comment

begin_function
name|struct
name|objfile
modifier|*
name|symbol_file_add
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|addr
parameter_list|,
name|mainline
parameter_list|,
name|mapped
parameter_list|,
name|readnow
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|int
name|mapped
decl_stmt|;
name|int
name|readnow
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* Open a bfd for the file and then check to see if the file has a      symbol table.  There is a distinction between having no symbol table      (we refuse to read the file, leaving the old set of symbols around)      and having no debugging symbols in the symbol table (we read the file      and end up with a mostly empty symbol table, but with lots of stuff in      the minimal symbol table).  We need to make the decision about whether      to continue with the file before allocating and building a objfile.       FIXME:  This strategy works correctly when the debugging symbols are      intermixed with "normal" symbols.  However, when the debugging symbols      are separate, such as with ELF/DWARF, it is perfectly plausible for      the symbol table to be missing but still have all the DWARF info      intact.  Thus in general it is wrong to assume that having no symbol      table implies no debugging information. */
name|abfd
operator|=
name|symfile_bfd_open
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|HAS_SYMS
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%s has no symbol-table"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|have_full_symbols
argument_list|()
operator|||
name|have_partial_symbols
argument_list|()
operator|)
operator|&&
name|mainline
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Load new symbol table from \"%s\"? "
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|objfile
operator|=
name|allocate_objfile
argument_list|(
name|abfd
argument_list|,
name|mapped
argument_list|)
expr_stmt|;
comment|/* If the objfile uses a mapped symbol file, and we have a psymtab for      it, then skip reading any symbols at this time. */
if|if
condition|(
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_MAPPED
operator|)
operator|&&
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_SYMS
operator|)
condition|)
block|{
comment|/* We mapped in an existing symbol table file that already has had 	 initial symbol reading performed, so we can skip that part.  Notify 	 the user that instead of reading the symbols, they have been mapped. 	 */
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Mapped symbols for %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|find_sym_fns
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We either created a new mapped symbol table, mapped an existing 	 symbol table file which has not had initial symbol reading 	 performed, or need to read an unmapped symbol table. */
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading symbols from %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|syms_from_objfile
argument_list|(
name|objfile
argument_list|,
name|addr
argument_list|,
name|mainline
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
name|new_symfile_objfile
argument_list|(
name|objfile
argument_list|,
name|mainline
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* We now have at least a partial symbol table.  Check to see if the      user requested that all symbols be read on initial access via either      the gdb startup command line or on a per symbol file basis.  Expand      all partial symbol tables for this objfile if so. */
if|if
condition|(
name|readnow
operator|||
name|readnow_symbol_files
condition|)
block|{
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"expanding to full symbols..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|psymtab
operator|=
name|objfile
operator|->
name|psymtabs
init|;
name|psymtab
operator|!=
name|NULL
condition|;
name|psymtab
operator|=
name|psymtab
operator|->
name|next
control|)
block|{
name|psymtab_to_symtab
argument_list|(
name|psymtab
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_tty
operator|||
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|objfile
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the symbol-file command.  Read the file, analyze its symbols,    and add a struct symtab to a symtab list.  */
end_comment

begin_function
name|void
name|symbol_file_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|int
name|mapped
init|=
literal|0
decl_stmt|;
name|int
name|readnow
init|=
literal|0
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|have_full_symbols
argument_list|()
operator|||
name|have_partial_symbols
argument_list|()
operator|)
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Discard symbol table from `%s'? "
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|free_all_objfiles
argument_list|()
expr_stmt|;
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
name|current_source_symtab
operator|=
name|NULL
expr_stmt|;
name|current_source_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"No symbol file now.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-mapped"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mapped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-readnow"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|readnow
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
operator|*
name|argv
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"no symbol file name was specified"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
literal|1
argument_list|,
name|mapped
argument_list|,
name|readnow
argument_list|)
expr_stmt|;
name|set_initial_language
argument_list|()
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the initial language.     A better solution would be to record the language in the psymtab when reading    partial symbols, and then use it (if known) to set the language.  This would    be a win for formats that encode the language in an easily discoverable place,    such as DWARF.  For stabs, we can jump through hoops looking for specially    named symbols or try to intuit the language from the specific type of stabs    we find, but we can't do that until later when we read in full symbols.    FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|set_initial_language
parameter_list|()
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|enum
name|language
name|lang
init|=
name|language_unknown
decl_stmt|;
name|pst
operator|=
name|find_main_psymtab
argument_list|()
expr_stmt|;
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
name|lang
operator|=
name|deduce_language_from_filename
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lang
operator|==
name|language_unknown
condition|)
block|{
comment|/* Make C the default language */
name|lang
operator|=
name|language_c
expr_stmt|;
block|}
name|set_language
argument_list|(
name|lang
argument_list|)
expr_stmt|;
name|expected_language
operator|=
name|current_language
expr_stmt|;
comment|/* Don't warn the user */
block|}
block|}
end_function

begin_comment
comment|/* Open file specified by NAME and hand it off to BFD for preliminary    analysis.  Result is a newly initialized bfd *, which includes a newly    malloc'd` copy of NAME (tilde-expanded and made absolute).    In case of trouble, error() is called.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|symfile_bfd_open
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|absolute_name
decl_stmt|;
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Returns 1st new malloc'd copy */
comment|/* Look down path for it, allocate 2nd new malloc'd copy.  */
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Free 1st new malloc'd copy */
name|name
operator|=
name|absolute_name
expr_stmt|;
comment|/* Keep 2nd malloc'd copy in bfd */
comment|/* It'll be freed in free_objfile(). */
name|sym_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_bfd
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't open to read symbols: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|sym_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|bfd_close
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
comment|/* This also closes desc */
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't read symbols: %s."
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sym_bfd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Link a new symtab_fns into the global symtab_fns list.  Called on gdb    startup by the _initialize routine in each object file format reader,    to register information about each format the the reader is prepared    to handle. */
end_comment

begin_function
name|void
name|add_symtab_fns
parameter_list|(
name|sf
parameter_list|)
name|struct
name|sym_fns
modifier|*
name|sf
decl_stmt|;
block|{
name|sf
operator|->
name|next
operator|=
name|symtab_fns
expr_stmt|;
name|symtab_fns
operator|=
name|sf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize to read symbols from the symbol file sym_bfd.  It either    returns or calls error().  The result is an initialized struct sym_fns    in the objfile structure, that contains cached information about the    symbol file.  */
end_comment

begin_function
specifier|static
name|void
name|find_sym_fns
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|sym_fns
modifier|*
name|sf
decl_stmt|;
for|for
control|(
name|sf
operator|=
name|symtab_fns
init|;
name|sf
operator|!=
name|NULL
condition|;
name|sf
operator|=
name|sf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|,
name|sf
operator|->
name|sym_name
argument_list|,
name|sf
operator|->
name|sym_namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|objfile
operator|->
name|sf
operator|=
name|sf
expr_stmt|;
return|return;
block|}
block|}
comment|/* XXX What moron thought this error message was cute? */
ifdef|#
directive|ifdef
name|notdef
name|error
argument_list|(
literal|"I'm sorry, Dave, I can't do that.  Symbol format `%s' unknown."
argument_list|,
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Symbol format `%s' unknown."
argument_list|,
name|bfd_get_target
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function runs the load command of our current target.  */
end_comment

begin_function
specifier|static
name|void
name|load_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|target_load
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function allows the addition of incrementally linked object files.    It does not modify any state in the target, only in the debugger.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|add_symbol_file_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|readnow
init|=
literal|0
decl_stmt|;
name|int
name|mapped
init|=
literal|0
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"add-symbol-file takes a file name and an address"
argument_list|)
expr_stmt|;
block|}
comment|/* Make a copy of the string that we can safely write into. */
name|args
operator|=
name|strdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Pick off any -option args and the file name. */
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|(
name|name
operator|==
name|NULL
operator|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
block|}
name|arg
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
block|{
operator|*
name|args
operator|++
operator|=
literal|'\000'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
block|{
name|name
operator|=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-mapped"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mapped
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-readnow"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|readnow
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* After picking off any options and the file name, args should be      left pointing at the remainder of the command line, which should      be the address expression to evaluate. */
if|if
condition|(
operator|(
name|name
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|args
operator|==
literal|'\000'
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"add-symbol-file takes a file name and an address"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|text_addr
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"add symbol table from file \"%s\" at text_addr = %s?\n"
argument_list|,
name|name
argument_list|,
name|local_hex_string
argument_list|(
name|text_addr
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|symbol_file_add
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|text_addr
argument_list|,
literal|0
argument_list|,
name|mapped
argument_list|,
name|readnow
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Re-read symbols if a symbol-file has changed.  */
end_comment

begin_function
name|void
name|reread_symbols
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|long
name|new_modtime
decl_stmt|;
name|int
name|reread_one
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|new_statbuf
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* With the addition of shared libraries, this should be modified,      the load time should be saved in the partial symbol tables, since      different tables may come from different source files.  FIXME.      This routine should then walk down each partial symbol table      and see if the symbol table that it originates from has been changed */
name|the_big_top
label|:
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|objfile
operator|->
name|obfd
condition|)
block|{
ifdef|#
directive|ifdef
name|IBM6000_TARGET
comment|/* If this object is from a shared library, then you should         stat on the library name, not member name. */
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|->
name|my_archive
condition|)
name|res
operator|=
name|stat
argument_list|(
name|objfile
operator|->
name|obfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|,
operator|&
name|new_statbuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|res
operator|=
name|stat
argument_list|(
name|objfile
operator|->
name|name
argument_list|,
operator|&
name|new_statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME, should use print_sys_errmsg but it's not filtered. */
name|printf_filtered
argument_list|(
literal|"`%s' has disappeared; keeping its symbols.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new_modtime
operator|=
name|new_statbuf
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|new_modtime
operator|!=
name|objfile
operator|->
name|mtime
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"`%s' has changed; re-reading symbols.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* FIXME, this should use a different command...that would only  	   affect this objfile's symbols, and would reset objfile->mtime.                 (objfile->mtime = new_modtime;)  	   HOWEVER, that command isn't written yet -- so call symbol_file_ 	   command, and restart the scan from the top, because it munges 	   the object_files list.  */
name|symbol_file_command
argument_list|(
name|objfile
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reread_one
operator|=
literal|1
expr_stmt|;
goto|goto
name|the_big_top
goto|;
comment|/* Start over.  */
block|}
block|}
block|}
if|if
condition|(
name|reread_one
condition|)
name|breakpoint_re_set
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to handle complaints during symbol reading.  */
end_comment

begin_comment
comment|/* How many complaints about a particular thing should be printed before    we stop whining about it?  Default is no whining at all, since so many    systems have ill-constructed symbol files.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|stop_whining
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should each complaint be self explanatory, or should we assume that    a series of complaints is being produced?     case 0:  self explanatory message.    case 1:  First message of a series that must start off with explanation.    case 2:  Subsequent message, when user already knows we are reading             symbols and we can just state our piece.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|complaint_series
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a complaint about the input symbols, and link the complaint block    into a chain for later handling.  */
end_comment

begin_function
name|void
name|complain
parameter_list|(
name|complaint
parameter_list|,
name|val
parameter_list|)
name|struct
name|complaint
modifier|*
name|complaint
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|complaint
operator|->
name|counter
operator|++
expr_stmt|;
if|if
condition|(
name|complaint
operator|->
name|next
operator|==
literal|0
condition|)
block|{
name|complaint
operator|->
name|next
operator|=
name|complaint_root
operator|->
name|next
expr_stmt|;
name|complaint_root
operator|->
name|next
operator|=
name|complaint
expr_stmt|;
block|}
if|if
condition|(
name|complaint
operator|->
name|counter
operator|>
name|stop_whining
condition|)
return|return;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|complaint_series
operator|+
operator|(
name|info_verbose
operator|<<
literal|1
operator|)
condition|)
block|{
comment|/* Isolated messages, must be self-explanatory.  */
case|case
literal|0
case|:
name|puts_filtered
argument_list|(
literal|"During symbol reading, "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|complaint
operator|->
name|message
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
break|break;
comment|/* First of a series, without `set verbose'.  */
case|case
literal|1
case|:
name|puts_filtered
argument_list|(
literal|"During symbol reading..."
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|complaint
operator|->
name|message
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|complaint_series
operator|++
expr_stmt|;
break|break;
comment|/* Subsequent messages of a series, or messages under `set verbose'.      (We'll already have produced a "Reading in symbols for XXX..." message       and will clean up at the end with a newline.)  */
default|default:
name|printf_filtered
argument_list|(
name|complaint
operator|->
name|message
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear out all complaint counters that have ever been incremented.    If sym_reading is 1, be less verbose about successive complaints,    since the messages are appearing all together during a command that    reads symbols (rather than scattered around as psymtabs get fleshed    out into symtabs at random times).  If noisy is 1, we are in a    noisy symbol reading command, and our caller will print enough    context for the user to figure it out.  */
end_comment

begin_function
name|void
name|clear_complaints
parameter_list|(
name|sym_reading
parameter_list|,
name|noisy
parameter_list|)
name|int
name|sym_reading
decl_stmt|;
name|int
name|noisy
decl_stmt|;
block|{
name|struct
name|complaint
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|complaint_root
operator|->
name|next
init|;
name|p
operator|!=
name|complaint_root
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|p
operator|->
name|counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sym_reading
operator|&&
operator|!
name|noisy
operator|&&
name|complaint_series
operator|>
literal|1
condition|)
block|{
comment|/* Terminate previous series, since caller won't.  */
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|complaint_series
operator|=
name|sym_reading
condition|?
literal|1
operator|+
name|noisy
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|enum
name|language
name|deduce_language_from_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|c
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
empty_stmt|;
comment|/* Get default. */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|c
argument_list|,
literal|".mod"
argument_list|)
condition|)
return|return
name|language_m2
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|c
argument_list|,
literal|".c"
argument_list|)
condition|)
return|return
name|language_c
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|c
argument_list|,
literal|".cc"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|c
argument_list|,
literal|".C"
argument_list|)
condition|)
return|return
name|language_cplus
return|;
return|return
name|language_unknown
return|;
comment|/* default */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* allocate_symtab:     Allocate and partly initialize a new symbol table.  Return a pointer    to it.  error() if no space.     Caller must set these fields: 	LINETABLE(symtab) 	symtab->blockvector 	symtab->dirname 	symtab->free_code 	symtab->free_ptr 	initialize any EXTRA_SYMTAB_INFO 	possibly free_named_symtabs (symtab->filename);  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|allocate_symtab
parameter_list|(
name|filename
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|symtab
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|symtab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|filename
operator|=
name|obsavestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
name|symtab
operator|->
name|language
operator|=
name|deduce_language_from_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Hook it to the objfile it comes from */
name|symtab
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|symtab
operator|->
name|next
operator|=
name|objfile
operator|->
name|symtabs
expr_stmt|;
name|objfile
operator|->
name|symtabs
operator|=
name|symtab
expr_stmt|;
ifdef|#
directive|ifdef
name|INIT_EXTRA_SYMTAB_INFO
name|INIT_EXTRA_SYMTAB_INFO
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|symtab
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|partial_symtab
modifier|*
name|allocate_psymtab
parameter_list|(
name|filename
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|free_psymtabs
condition|)
block|{
name|psymtab
operator|=
name|objfile
operator|->
name|free_psymtabs
expr_stmt|;
name|objfile
operator|->
name|free_psymtabs
operator|=
name|psymtab
operator|->
name|next
expr_stmt|;
block|}
else|else
name|psymtab
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|psymtab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|filename
operator|=
name|obsavestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|symtab
operator|=
name|NULL
expr_stmt|;
comment|/* Hook it to the objfile it comes from */
name|psymtab
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|psymtab
operator|->
name|next
operator|=
name|objfile
operator|->
name|psymtabs
expr_stmt|;
name|objfile
operator|->
name|psymtabs
operator|=
name|psymtab
expr_stmt|;
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* clear_symtab_users_once:     This function is run after symbol reading, or from a cleanup.    If an old symbol table was obsoleted, the old symbol table    has been blown away, but the other GDB data structures that may     reference it have not yet been cleared or re-directed.  (The old    symtab was zapped, and the cleanup queued, in free_named_symtab()    below.)     This function can be queued N times as a cleanup, or called    directly; it will do all the work the first time, and then will be a    no-op until the next time it is queued.  This works by bumping a    counter at queueing time.  Much later when the cleanup is run, or at    the end of symbol processing (in case the cleanup is discarded), if    the queued count is greater than the "done-count", we do the work    and set the done-count to the queued count.  If the queued count is    less than or equal to the done-count, we just ignore the call.  This    is needed because reading a single .o file will often replace many    symtabs (one per .h file, for example), and we don't want to reset    the breakpoints N times in the user's face.     The reason we both queue a cleanup, and call it directly after symbol    reading, is because the cleanup protects us in case of errors, but is    discarded if symbol reading is successful.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clear_symtab_users_queued
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|clear_symtab_users_done
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|clear_symtab_users_once
parameter_list|()
block|{
comment|/* Enforce once-per-`do_cleanups'-semantics */
if|if
condition|(
name|clear_symtab_users_queued
operator|<=
name|clear_symtab_users_done
condition|)
return|return;
name|clear_symtab_users_done
operator|=
name|clear_symtab_users_queued
expr_stmt|;
name|printf
argument_list|(
literal|"Resetting debugger state after updating old symbol tables\n"
argument_list|)
expr_stmt|;
comment|/* Someday, we should do better than this, by only blowing away      the things that really need to be blown.  */
name|clear_value_history
argument_list|()
expr_stmt|;
name|clear_displays
argument_list|()
expr_stmt|;
name|clear_internalvars
argument_list|()
expr_stmt|;
name|breakpoint_re_set
argument_list|()
expr_stmt|;
name|set_default_breakpoint
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the specified psymtab, and any others that reference it.  */
end_comment

begin_function
specifier|static
name|void
name|cashier_psymtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|,
modifier|*
name|pprev
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find its previous psymtab in the chain */
for|for
control|(
name|ps
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ps
operator|==
name|pst
condition|)
break|break;
name|pprev
operator|=
name|ps
expr_stmt|;
block|}
if|if
condition|(
name|ps
condition|)
block|{
comment|/* Unhook it from the chain.  */
if|if
condition|(
name|ps
operator|==
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
condition|)
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
operator|=
name|ps
operator|->
name|next
expr_stmt|;
else|else
name|pprev
operator|->
name|next
operator|=
name|ps
operator|->
name|next
expr_stmt|;
comment|/* FIXME, we can't conveniently deallocate the entries in the        partial_symbol lists (global_psymbols/static_psymbols) that        this psymtab points to.  These just take up space until all        the psymtabs are reclaimed.  Ditto the dependencies list and        filename, which are all in the psymbol_obstack.  */
comment|/* We need to cashier any psymtab that has this one as a dependency... */
name|again
label|:
for|for
control|(
name|ps
operator|=
name|pst
operator|->
name|objfile
operator|->
name|psymtabs
init|;
name|ps
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ps
operator|->
name|dependencies
index|[
name|i
index|]
operator|==
name|pst
condition|)
block|{
name|cashier_psymtab
argument_list|(
name|ps
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* Must restart, chain has been munged. */
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* If a symtab or psymtab for filename NAME is found, free it along    with any dependent breakpoints, displays, etc.    Used when loading new versions of object modules with the "add-file"    command.  This is only called on the top-level symtab or psymtab's name;    it is not called for subsidiary files such as .h files.     Return value is 1 if we blew away the environment, 0 if not.    FIXME.  The return valu appears to never be used.     FIXME.  I think this is not the best way to do this.  We should    work on being gentler to the environment while still cleaning up    all stray pointers into the freed symtab.  */
end_comment

begin_function
name|int
name|free_named_symtabs
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* FIXME:  With the new method of each objfile having it's own      psymtab list, this function needs serious rethinking.  In particular,      why was it ever necessary to toss psymtabs with specific compilation      unit filenames, as opposed to all psymtabs from a particular symbol      file?  -- fnf      Well, the answer is that some systems permit reloading of particular      compilation units.  We want to blow away any old info about these      compilation units, regardless of which objfiles they arrived in. --gnu.  */
block|register struct symtab *s;   register struct symtab *prev;   register struct partial_symtab *ps;   struct blockvector *bv;   int blewit = 0;
comment|/* We only wack things if the symbol-reload switch is set.  */
block|if (!symbol_reloading)     return 0;
comment|/* Some symbol formats have trouble providing file names... */
block|if (name == 0 || *name == '\0')     return 0;
comment|/* Look for a psymtab with the specified name.  */
block|again2:   for (ps = partial_symtab_list; ps; ps = ps->next) {     if (!strcmp (name, ps->filename)) {       cashier_psymtab (ps);
comment|/* Blow it away...and its little dog, too.  */
block|goto again2;
comment|/* Must restart, chain has been munged */
block|}   }
comment|/* Look for a symtab with the specified name.  */
block|for (s = symtab_list; s; s = s->next)     {       if (!strcmp (name, s->filename)) 	break;       prev = s;     }    if (s)     {       if (s == symtab_list) 	symtab_list = s->next;       else 	prev->next = s->next;
comment|/* For now, queue a delete for all breakpoints, displays, etc., whether 	 or not they depend on the symtab being freed.  This should be 	 changed so that only those data structures affected are deleted.  */
comment|/* But don't delete anything if the symtab is empty. 	 This test is necessary due to a bug in "dbxread.c" that 	 causes empty symtabs to be created for N_SO symbols that 	 contain the pathname of the object file.  (This problem 	 has been fixed in GDB 3.9x).  */
block|bv = BLOCKVECTOR (s);       if (BLOCKVECTOR_NBLOCKS (bv)> 2 	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK)) 	  || BLOCK_NSYMS (BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK))) 	{ 	  complain (&oldsyms_complaint, name);  	  clear_symtab_users_queued++; 	  make_cleanup (clear_symtab_users_once, 0); 	  blewit = 1; 	} else { 	  complain (&empty_symtab_complaint, name); 	}        free_symtab (s);     }   else     {
comment|/* It is still possible that some breakpoints will be affected 	 even though no symtab was found, since the file might have 	 been compiled without debugging, and hence not be associated 	 with a symtab.  In order to handle this correctly, we would need 	 to keep a list of text address ranges for undebuggable files. 	 For now, we do nothing, since this is a fairly obscure case.  */
block|;     }
comment|/* FIXME, what about the minimal symbol table? */
block|return blewit;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|start_psymtab_common
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|,
name|textlow
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
name|textlow
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|static_syms
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|psymtab
decl_stmt|;
name|psymtab
operator|=
name|allocate_psymtab
argument_list|(
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|psymtab
operator|->
name|section_offsets
operator|=
name|section_offsets
expr_stmt|;
name|psymtab
operator|->
name|textlow
operator|=
name|textlow
expr_stmt|;
name|psymtab
operator|->
name|texthigh
operator|=
name|psymtab
operator|->
name|textlow
expr_stmt|;
comment|/* default */
name|psymtab
operator|->
name|globals_offset
operator|=
name|global_syms
operator|-
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
expr_stmt|;
name|psymtab
operator|->
name|statics_offset
operator|=
name|static_syms
operator|-
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
expr_stmt|;
return|return
operator|(
name|psymtab
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Debugging versions of functions that are usually inline macros    (see symfile.h).  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Don't quite work nowadays... */
end_comment

begin_comment
comment|/* Add a symbol with a long value to a psymtab.    Since one arg is a struct, we pass in a ptr and deref it (sigh).  */
end_comment

begin_comment
unit|void add_psymbol_to_list (name, namelength, namespace, class, list, val)      char *name;      int namelength;      enum namespace namespace;      enum address_class class;      struct psymbol_allocation_list *list;      long val; {   ADD_PSYMBOL_VT_TO_LIST (name, namelength, namespace, class, (*list), val, 			  SYMBOL_VALUE); }
comment|/* Add a symbol with a CORE_ADDR value to a psymtab. */
end_comment

begin_endif
unit|void add_psymbol_addr_to_list (name, namelength, namespace, class, list, val)      char *name;      int namelength;      enum namespace namespace;      enum address_class class;      struct psymbol_allocation_list *list;      CORE_ADDR val; {   ADD_PSYMBOL_VT_TO_LIST (name, namelength, namespace, class, (*list), val, 			  SYMBOL_VALUE_ADDRESS); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_function
name|void
name|_initialize_symfile
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"symbol-file"
argument_list|,
name|class_files
argument_list|,
name|symbol_file_command
argument_list|,
literal|"Load symbol table from executable file FILE.\n\ The `file' command can also load symbol tables, as well as setting the file\n\ to execute."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"add-symbol-file"
argument_list|,
name|class_files
argument_list|,
name|add_symbol_file_command
argument_list|,
literal|"Load the symbols from FILE, assuming FILE has been dynamically loaded.\n\ The second argument provides the starting address of the file's text."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"load"
argument_list|,
name|class_files
argument_list|,
name|load_command
argument_list|,
literal|"Dynamically load FILE into the running program, and record its symbols\n\ for access from GDB."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"complaints"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stop_whining
argument_list|,
literal|"Set max number of complaints about incorrect symbols."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"symbol-reloading"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbol_reloading
argument_list|,
literal|"Set dynamic symbol table reloading multiple times in one run."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

