begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Find a variable's value in memory, for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|GET_SAVED_REGISTER
argument_list|)
end_if

begin_comment
comment|/* Return the address in which frame FRAME's value of register REGNUM    has been saved in memory.  Or return zero if it has not been saved.    If REGNUM specifies the SP, the value we return is actually    the SP value, not an address where it was saved.  */
end_comment

begin_function
name|CORE_ADDR
name|find_saved_register
parameter_list|(
name|frame
parameter_list|,
name|regnum
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
name|saved_regs
decl_stmt|;
specifier|register
name|FRAME
name|frame1
init|=
literal|0
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
comment|/* No regs saved if want current frame */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_REGISTER_WINDOWS
comment|/* We assume that a register in a register window will only be saved      in one place (since the name changes and/or disappears as you go      towards inner frames), so we only call get_frame_saved_regs on      the current frame.  This is directly in contradiction to the      usage below, which assumes that registers used in a frame must be      saved in a lower (more interior) frame.  This change is a result      of working on a register window machine; get_frame_saved_regs      always returns the registers saved within a frame, within the      context (register namespace) of that frame. */
comment|/* However, note that we don't want this to return anything if      nothing is saved (if there's a frame inside of this one).  Also,      callers to this routine asking for the stack pointer want the      stack pointer saved for *this* frame; this is returned from the      next frame.  */
if|if
condition|(
name|REGISTER_IN_WINDOW_P
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|frame1
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame1
condition|)
return|return
literal|0
return|;
comment|/* Registers of this frame are 				   active.  */
comment|/* Get the SP from the next frame in; it will be this 	 current frame.  */
if|if
condition|(
name|regnum
operator|!=
name|SP_REGNUM
condition|)
name|frame1
operator|=
name|frame
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|saved_regs
argument_list|)
expr_stmt|;
return|return
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
return|;
comment|/* ... which might be zero */
block|}
endif|#
directive|endif
comment|/* HAVE_REGISTER_WINDOWS */
comment|/* Note that this next routine assumes that registers used in      frame x will be saved only in the frame that x calls and      frames interior to it.  This is not true on the sparc, but the      above macro takes care of it, so we should be all right. */
while|while
condition|(
literal|1
condition|)
block|{
name|QUIT
expr_stmt|;
name|frame1
operator|=
name|get_prev_frame
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame1
operator|==
literal|0
operator|||
name|frame1
operator|==
name|frame
condition|)
break|break;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|saved_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
name|addr
operator|=
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Find register number REGNUM relative to FRAME and put its    (raw) contents in *RAW_BUFFER.  Set *OPTIMIZED if the variable    was optimized out (and thus can't be fetched).  Set *LVAL to    lval_memory, lval_register, or not_lval, depending on whether the    value was fetched from memory, from a register, or in a strange    and non-modifiable way (e.g. a frame pointer which was calculated    rather than fetched).  Set *ADDRP to the address, either in memory    on as a REGISTER_BYTE offset into the registers array.     Note that this implementation never sets *LVAL to not_lval.  But    it can be replaced by defining GET_SAVED_REGISTER and supplying    your own.     The argument RAW_BUFFER must point to aligned memory.  */
end_comment

begin_function
name|void
name|get_saved_register
parameter_list|(
name|raw_buffer
parameter_list|,
name|optimized
parameter_list|,
name|addrp
parameter_list|,
name|frame
parameter_list|,
name|regnum
parameter_list|,
name|lval
parameter_list|)
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|int
modifier|*
name|optimized
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|enum
name|lval_type
modifier|*
name|lval
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Normal systems don't optimize out things with register numbers.  */
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|raw_buffer
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|read_memory
argument_list|(
name|addr
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
name|addr
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|raw_buffer
operator|!=
name|NULL
condition|)
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_SAVED_REGISTER.  */
end_comment

begin_comment
comment|/* Copy the bytes of register REGNUM, relative to the current stack frame,    into our memory at MYADDR, in target byte order.    The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).     Returns 1 if could not be read, 0 if could.  */
end_comment

begin_function
name|int
name|read_relative_register_raw_bytes
parameter_list|(
name|regnum
parameter_list|,
name|myaddr
parameter_list|)
name|int
name|regnum
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
block|{
name|int
name|optim
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
name|FP_REGNUM
operator|&&
name|selected_frame
condition|)
block|{
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|FRAME_FP
argument_list|(
name|selected_frame
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|myaddr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* in target order */
return|return
literal|0
return|;
block|}
name|get_saved_register
argument_list|(
name|myaddr
argument_list|,
operator|&
name|optim
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
name|selected_frame
argument_list|,
name|regnum
argument_list|,
operator|(
expr|enum
name|lval_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|optim
return|;
block|}
end_function

begin_comment
comment|/* Return a `value' with the contents of register REGNUM    in its virtual format, with the type specified by    REGISTER_VIRTUAL_TYPE.  */
end_comment

begin_function
name|value
name|value_of_register
parameter_list|(
name|regnum
parameter_list|)
name|int
name|regnum
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|optim
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
name|get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|selected_frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
name|regnum
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|val
argument_list|)
operator|=
name|optim
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Low level examining and depositing of registers.     The caller is responsible for making    sure that the inferior is stopped before calling the fetching routines,    or it will get garbage.  (a change from GDB version 3, in which    the caller got the value from the last stop).  */
end_comment

begin_comment
comment|/* Contents of the registers in target byte order.    We allocate some extra slop since we do a lot of bcopy's around `registers',    and failing-soft is better than failing hard.  */
end_comment

begin_decl_stmt
name|char
name|registers
index|[
name|REGISTER_BYTES
operator|+
comment|/* SLOP */
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if that register has been fetched.  */
end_comment

begin_decl_stmt
name|char
name|register_valid
index|[
name|NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate that registers may have changed, so invalidate the cache.  */
end_comment

begin_function
name|void
name|registers_changed
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|register_valid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicate that all registers have been fetched, so mark them all valid.  */
end_comment

begin_function
name|void
name|registers_fetched
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|register_valid
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of consecutive data from registers    starting with the REGBYTE'th byte of register data    into memory at MYADDR.  */
end_comment

begin_function
name|void
name|read_register_bytes
parameter_list|(
name|regbyte
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|regbyte
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* Fetch all registers.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|register_valid
index|[
name|i
index|]
condition|)
block|{
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|myaddr
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|registers
index|[
name|regbyte
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read register REGNO into memory at MYADDR, which must be large enough    for REGISTER_RAW_BYTES (REGNO).  Target byte-order.    If the register is known to be the size of a CORE_ADDR or smaller,    read_register can be used instead.  */
end_comment

begin_function
name|void
name|read_register_gen
parameter_list|(
name|regno
parameter_list|,
name|myaddr
parameter_list|)
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|register_valid
index|[
name|regno
index|]
condition|)
name|target_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of consecutive data from memory at MYADDR    into registers starting with the REGBYTE'th byte of register data.  */
end_comment

begin_function
name|void
name|write_register_bytes
parameter_list|(
name|regbyte
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|regbyte
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* Make sure the entire registers array is valid.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|regbyte
index|]
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the contents of register REGNO, regarding it as an integer.  */
end_comment

begin_comment
comment|/* FIXME, this loses when the REGISTER_VIRTUAL (REGNO) is true.  Also,    why is the return type CORE_ADDR rather than some integer type?  */
end_comment

begin_function
name|CORE_ADDR
name|read_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|REGISTER_TYPE
name|reg
decl_stmt|;
if|if
condition|(
operator|!
name|register_valid
index|[
name|regno
index|]
condition|)
name|target_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|reg
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* Registers we shouldn't try to store.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CANNOT_STORE_REGISTER
argument_list|)
end_if

begin_define
define|#
directive|define
name|CANNOT_STORE_REGISTER
parameter_list|(
name|regno
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Store VALUE in the register number REGNO, regarded as an integer.  */
end_comment

begin_comment
comment|/* FIXME, this loses when REGISTER_VIRTUAL (REGNO) is true.  Also,     shouldn't the val arg be a LONGEST or something?  */
end_comment

begin_function
name|void
name|write_register
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|)
name|int
name|regno
decl_stmt|,
name|val
decl_stmt|;
block|{
name|REGISTER_TYPE
name|reg
decl_stmt|;
comment|/* On the sparc, writing %g0 is a no-op, so we don't even want to change      the registers array if something writes to this register.  */
if|if
condition|(
name|CANNOT_STORE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
return|return;
name|reg
operator|=
name|val
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|target_prepare_to_store
argument_list|()
expr_stmt|;
name|register_valid
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
operator|&
name|reg
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that register REGNO contains VAL.    This is used when the value is obtained from the inferior or core dump,    so there is no need to store the value there.  */
end_comment

begin_function
name|void
name|supply_register
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|)
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|register_valid
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|val
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On some architectures, e.g. HPPA, there are a few stray bits in some      registers, that the rest of the code would like to ignore.  */
ifdef|#
directive|ifdef
name|CLEAN_UP_REGISTER_VALUE
name|CLEAN_UP_REGISTER_VALUE
argument_list|(
name|regno
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a struct symbol for a variable,    and a stack frame id, read the value of the variable    and return a (pointer to a) struct value containing the value.     If the variable cannot be found, return a zero pointer.    If FRAME is NULL, use the selected_frame.  */
end_comment

begin_function
name|value
name|read_var_value
parameter_list|(
name|var
parameter_list|,
name|frame
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
comment|/* The most likely possibility.  */
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
name|frame
operator|=
name|selected_frame
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
operator|&
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_LABEL
case|:
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_CONST_BYTES
case|:
block|{
name|char
modifier|*
name|bytes_addr
decl_stmt|;
name|bytes_addr
operator|=
name|SYMBOL_VALUE_BYTES
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|bytes_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
block|}
case|case
name|LOC_STATIC
case|:
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
if|if
condition|(
name|SYMBOL_BASEREG_VALID
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|addr
operator|=
name|FRAME_GET_BASEREG_VALUE
argument_list|(
name|frame
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addr
condition|)
block|{
return|return
literal|0
return|;
block|}
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
if|if
condition|(
name|SYMBOL_BASEREG_VALID
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|addr
operator|=
name|FRAME_GET_BASEREG_VALUE
argument_list|(
name|frame
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addr
condition|)
block|{
return|return
literal|0
return|;
block|}
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_LOCAL_ARG
case|:
if|if
condition|(
name|SYMBOL_BASEREG_VALID
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|addr
operator|=
name|FRAME_GET_BASEREG_VALUE
argument_list|(
name|frame
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|FRAME_LOCALS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|error
argument_list|(
literal|"Cannot look up value of a typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|b
operator|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|v
operator|=
name|value_from_register
argument_list|(
name|type
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|,
name|frame
argument_list|)
expr_stmt|;
comment|/* Nonzero if a struct which is located in a register or a LOC_ARG 	   really contains 	   the address of the struct, not the struct itself.  GCC_P is nonzero 	   if the function was compiled with GCC.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REG_STRUCT_HAS_ADDR
argument_list|)
define|#
directive|define
name|REG_STRUCT_HAS_ADDR
parameter_list|(
name|gcc_p
parameter_list|)
value|0
endif|#
directive|endif
if|if
condition|(
name|REG_STRUCT_HAS_ADDR
argument_list|(
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|)
condition|)
name|addr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
expr_stmt|;
else|else
return|return
name|v
return|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Cannot look up value of a botched symbol."
argument_list|)
expr_stmt|;
break|break;
block|}
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a value of type TYPE, stored in register REGNUM, in frame    FRAME. */
end_comment

begin_function
name|value
name|value_from_register
parameter_list|(
name|type
parameter_list|,
name|regnum
parameter_list|,
name|frame
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|optim
decl_stmt|;
name|value
name|v
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value_bytes
init|=
literal|0
decl_stmt|;
name|int
name|value_bytes_copied
init|=
literal|0
decl_stmt|;
name|int
name|num_storage_locs
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
name|VALUE_REGNO
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
name|num_storage_locs
operator|=
operator|(
name|len
operator|>
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
condition|?
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
operator|/
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|)
operator|+
literal|1
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|num_storage_locs
operator|>
literal|1
condition|)
block|{
comment|/* Value spread across multiple storage locations.  */
name|int
name|local_regnum
decl_stmt|;
name|int
name|mem_stor
init|=
literal|0
decl_stmt|,
name|reg_stor
init|=
literal|0
decl_stmt|;
name|int
name|mem_tracking
init|=
literal|1
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|first_addr
decl_stmt|;
name|value_bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
comment|/* Copy all of the data out, whereever it may be.  */
for|for
control|(
name|local_regnum
operator|=
name|regnum
init|;
name|value_bytes_copied
operator|<
name|len
condition|;
operator|(
name|value_bytes_copied
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|local_regnum
argument_list|)
operator|,
operator|++
name|local_regnum
operator|)
control|)
block|{
name|get_saved_register
argument_list|(
name|value_bytes
operator|+
name|value_bytes_copied
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|frame
argument_list|,
name|local_regnum
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|==
name|lval_register
condition|)
name|reg_stor
operator|++
expr_stmt|;
else|else
block|{
name|mem_stor
operator|++
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
name|local_regnum
condition|)
name|first_addr
operator|=
name|addr
expr_stmt|;
name|mem_tracking
operator|=
operator|(
name|mem_tracking
operator|&&
operator|(
name|regnum
operator|==
name|local_regnum
operator|||
name|addr
operator|==
name|last_addr
operator|)
operator|)
expr_stmt|;
block|}
name|last_addr
operator|=
name|addr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg_stor
operator|&&
name|mem_stor
operator|)
operator|||
operator|(
name|mem_stor
operator|&&
operator|!
name|mem_tracking
operator|)
condition|)
comment|/* Mixed storage; all of the hassle we just went through was 	   for some good purpose.  */
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_reg_frame_relative
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|v
argument_list|)
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|VALUE_FRAME_REGNUM
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mem_stor
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|first_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_stor
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_register
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|first_addr
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"value_from_register: Value not stored anywhere!"
argument_list|)
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|v
argument_list|)
operator|=
name|optim
expr_stmt|;
comment|/* Any structure stored in more than one register will always be 	 an integral number of registers.  Otherwise, you'd need to do 	 some fiddling with the last register copied here for little 	 endian machines.  */
comment|/* Copy into the contents section of the value.  */
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|value_bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
comment|/* Data is completely contained within a single register.  Locate the      register's contents in a real register or in core;      read the data in raw format.  */
name|get_saved_register
argument_list|(
name|raw_buffer
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|v
argument_list|)
operator|=
name|optim
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|addr
expr_stmt|;
comment|/* Convert the raw contents to virtual contents.      (Just copy them if the formats are the same.)  */
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGISTER_CONVERTIBLE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* When the raw and virtual formats differ, the virtual format 	 corresponds to a specific data type.  If we want that type, 	 copy the data into the value. 	 Otherwise, do a type-conversion.  */
if|if
condition|(
name|type
operator|!=
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* eg a variable of type `float' in a 68881 register 	     with raw type `extended' and virtual type `double'. 	     Fetch it as a `double' and then convert to `float'.  */
name|v
operator|=
name|allocate_value
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|v
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Raw and virtual formats are the same for this register.  */
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
if|if
condition|(
name|len
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* Big-endian, and we want less than full size.  */
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|-
name|len
expr_stmt|;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|virtual_buffer
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a struct symbol for a variable or function,    and a stack frame id,     return a (pointer to a) struct value containing the properly typed    address.  */
end_comment

begin_function
name|value
name|locate_var_value
parameter_list|(
name|var
parameter_list|,
name|frame
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|value
name|lazy_value
decl_stmt|;
comment|/* Evaluate it first; if the result is a memory address, we're fine.      Lazy evaluation pays off here. */
name|lazy_value
operator|=
name|read_var_value
argument_list|(
name|var
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|lazy_value
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Address of \"%s\" is unknown."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|lazy_value
argument_list|)
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|lazy_value
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
return|;
block|}
comment|/* Not a memory address; check what the problem was.  */
switch|switch
condition|(
name|VALUE_LVAL
argument_list|(
name|lazy_value
argument_list|)
condition|)
block|{
case|case
name|lval_register
case|:
case|case
name|lval_reg_frame_relative
case|:
name|error
argument_list|(
literal|"Address requested for identifier \"%s\" which is in a register."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Can't take address of \"%s\" which isn't an lvalue."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

end_unit

