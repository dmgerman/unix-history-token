begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform non-arithmetic operations on values, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|find_function_addr
name|PARAMS
argument_list|(
operator|(
name|value
operator|,
expr|struct
name|type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|value_push
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|value_arg_push
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value
name|search_struct_field
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|value
operator|,
name|int
operator|,
expr|struct
name|type
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value
name|search_struct_method
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|value
operator|*
operator|,
name|value
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_field_in
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Cast value ARG2 to type TYPE and return as a value.    More general than a C cast: accepts any two types of the same length,    and if ARG2 is an lvalue it can be cast into anything at all.  */
end_comment

begin_comment
comment|/* In C++, casts may change pointer representations.  */
end_comment

begin_function
name|value
name|value_cast
parameter_list|(
name|type
parameter_list|,
name|arg2
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|value
name|arg2
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code2
decl_stmt|;
specifier|register
name|int
name|scalar
decl_stmt|;
comment|/* Coerce arrays but not enums.  Enums will work as-is      and coercing them would cause an infinite recursion.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
name|scalar
operator|=
operator|(
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_FLT
operator|||
name|code2
operator|==
name|TYPE_CODE_ENUM
operator|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_FLT
operator|&&
name|scalar
condition|)
return|return
name|value_from_double
argument_list|(
name|type
argument_list|,
name|value_as_double
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|||
name|code1
operator|==
name|TYPE_CODE_ENUM
operator|)
operator|&&
operator|(
name|scalar
operator|||
name|code2
operator|==
name|TYPE_CODE_PTR
operator|)
condition|)
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
comment|/* Look in the type of the source to see if it contains the 	     type of the target as a superclass.  If so, we'll need to 	     offset the pointer rather than just change its type.  */
name|struct
name|type
modifier|*
name|t1
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|t2
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
operator|!=
literal|0
condition|)
comment|/* if name unknown, can't have supercl */
block|{
name|value
name|v
init|=
name|search_struct_field
argument_list|(
name|type_name_no_tag
argument_list|(
name|t1
argument_list|)
argument_list|,
name|value_ind
argument_list|(
name|arg2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|t2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|v
operator|=
name|value_addr
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
comment|/* No superclass found, just fall through to change ptr type.  */
block|}
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|arg2
return|;
block|}
elseif|else
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg2
argument_list|)
operator|==
name|lval_memory
condition|)
block|{
return|return
name|value_at_lazy
argument_list|(
name|type
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|arg2
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_VOID
condition|)
block|{
return|return
name|value_zero
argument_list|(
name|builtin_type_void
argument_list|,
name|not_lval
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Invalid cast."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create a value of type TYPE that is zero, and return it.  */
end_comment

begin_function
name|value
name|value_zero
parameter_list|(
name|type
parameter_list|,
name|lv
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|enum
name|lval_type
name|lv
decl_stmt|;
block|{
specifier|register
name|value
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lv
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a value with type TYPE located at ADDR.       Call value_at only if the data needs to be fetched immediately;    if we can be 'lazy' and defer the fetch, perhaps indefinately, call    value_at_lazy instead.  value_at_lazy simply records the address of    the data and sets the lazy-evaluation-required flag.  The lazy flag     is tested in the VALUE_CONTENTS macro, which is used if and when     the contents are actually required.  */
end_comment

begin_function
name|value
name|value_at
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
specifier|register
name|value
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a lazy value with type TYPE located at ADDR (cf. value_at).  */
end_comment

begin_function
name|value
name|value_at_lazy
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
specifier|register
name|value
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Called only from the VALUE_CONTENTS macro, if the current data for    a variable needs to be loaded into VALUE_CONTENTS(VAL).  Fetches the    data from the user's process, and clears the lazy flag to indicate    that the data in the buffer is valid.     If the value is zero-length, we avoid calling read_memory, which would    abort.  We mark the value as fetched anyway -- all 0 bytes of it.     This function returns a value because it is used in the VALUE_CONTENTS    macro as part of an expression, where a void would not work.  The    value is ignored.  */
end_comment

begin_function
name|int
name|value_fetch_lazy
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value
name|val
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
init|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
name|read_memory
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store the contents of FROMVAL into the location of TOVAL.    Return a new value with the location of TOVAL and contents of FROMVAL.  */
end_comment

begin_function
name|value
name|value_assign
parameter_list|(
name|toval
parameter_list|,
name|fromval
parameter_list|)
specifier|register
name|value
name|toval
decl_stmt|,
name|fromval
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|toval
argument_list|)
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
name|int
name|use_buffer
init|=
literal|0
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|fromval
argument_list|)
expr_stmt|;
name|COERCE_REF
argument_list|(
name|toval
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|toval
argument_list|)
operator|!=
name|lval_internalvar
condition|)
name|fromval
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|fromval
argument_list|)
expr_stmt|;
comment|/* If TOVAL is a special machine register requiring conversion      of program values to a special raw format,      convert FROMVAL's contents now, with result in `raw_buffer',      and set USE_BUFFER to the number of bytes to write.  */
if|if
condition|(
name|VALUE_REGNO
argument_list|(
name|toval
argument_list|)
operator|>=
literal|0
operator|&&
name|REGISTER_CONVERTIBLE
argument_list|(
name|VALUE_REGNO
argument_list|(
name|toval
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|regno
init|=
name|VALUE_REGNO
argument_list|(
name|toval
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|fromval
argument_list|)
operator|!=
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regno
argument_list|)
condition|)
name|fromval
operator|=
name|value_cast
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|fromval
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|virtual_buffer
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|REGISTER_CONVERT_TO_RAW
argument_list|(
name|regno
argument_list|,
name|virtual_buffer
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|use_buffer
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|VALUE_LVAL
argument_list|(
name|toval
argument_list|)
condition|)
block|{
case|case
name|lval_internalvar
case|:
name|set_internalvar
argument_list|(
name|VALUE_INTERNALVAR
argument_list|(
name|toval
argument_list|)
argument_list|,
name|fromval
argument_list|)
expr_stmt|;
break|break;
case|case
name|lval_internalvar_component
case|:
name|set_internalvar_component
argument_list|(
name|VALUE_INTERNALVAR
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
argument_list|,
name|fromval
argument_list|)
expr_stmt|;
break|break;
case|case
name|lval_memory
case|:
if|if
condition|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
condition|)
block|{
name|int
name|v
decl_stmt|;
comment|/* FIXME, this won't work for large bitfields */
name|read_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|)
expr_stmt|;
name|modify_field
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|v
argument_list|,
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_buffer
condition|)
name|write_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|use_buffer
argument_list|)
expr_stmt|;
else|else
name|write_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|lval_register
case|:
if|if
condition|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
condition|)
block|{
name|int
name|v
decl_stmt|;
name|read_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|)
expr_stmt|;
name|modify_field
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|v
argument_list|,
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|v
argument_list|,
sizeof|sizeof
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_buffer
condition|)
name|write_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|use_buffer
argument_list|)
expr_stmt|;
else|else
name|write_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|lval_reg_frame_relative
case|:
block|{
comment|/* value is stored in a series of registers in the frame 	   specified by the structure.  Copy that value out, modify 	   it, and copy it back in.  */
name|int
name|amount_to_copy
init|=
operator|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
condition|?
literal|1
else|:
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
name|int
name|reg_size
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|VALUE_FRAME_REGNUM
argument_list|(
name|toval
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|byte_offset
init|=
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
operator|%
name|reg_size
decl_stmt|;
name|int
name|reg_offset
init|=
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
operator|/
name|reg_size
decl_stmt|;
name|int
name|amount_copied
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|amount_to_copy
argument_list|)
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
comment|/* Figure out which frame this is in currently.  */
for|for
control|(
name|frame
operator|=
name|get_current_frame
argument_list|()
init|;
name|frame
operator|&&
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
operator|!=
name|VALUE_FRAME
argument_list|(
name|toval
argument_list|)
condition|;
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
name|error
argument_list|(
literal|"Value being assigned to is no longer active."
argument_list|)
expr_stmt|;
name|amount_to_copy
operator|+=
operator|(
name|reg_size
operator|-
name|amount_to_copy
operator|%
name|reg_size
operator|)
expr_stmt|;
comment|/* Copy it out.  */
for|for
control|(
operator|(
name|regno
operator|=
name|VALUE_FRAME_REGNUM
argument_list|(
name|toval
argument_list|)
operator|+
name|reg_offset
operator|,
name|amount_copied
operator|=
literal|0
operator|)
init|;
name|amount_copied
operator|<
name|amount_to_copy
condition|;
name|amount_copied
operator|+=
name|reg_size
operator|,
name|regno
operator|++
control|)
block|{
name|get_saved_register
argument_list|(
name|buffer
operator|+
name|amount_copied
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
name|frame
argument_list|,
name|regno
argument_list|,
operator|(
expr|enum
name|lval_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Modify what needs to be modified.  */
if|if
condition|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
condition|)
name|modify_field
argument_list|(
name|buffer
operator|+
name|byte_offset
argument_list|,
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|use_buffer
condition|)
name|memcpy
argument_list|(
name|buffer
operator|+
name|byte_offset
argument_list|,
name|raw_buffer
argument_list|,
name|use_buffer
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|buffer
operator|+
name|byte_offset
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy it back.  */
for|for
control|(
operator|(
name|regno
operator|=
name|VALUE_FRAME_REGNUM
argument_list|(
name|toval
argument_list|)
operator|+
name|reg_offset
operator|,
name|amount_copied
operator|=
literal|0
operator|)
init|;
name|amount_copied
operator|<
name|amount_to_copy
condition|;
name|amount_copied
operator|+=
name|reg_size
operator|,
name|regno
operator|++
control|)
block|{
name|enum
name|lval_type
name|lval
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|optim
decl_stmt|;
comment|/* Just find out where to put it.  */
name|get_saved_register
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|frame
argument_list|,
name|regno
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|optim
condition|)
name|error
argument_list|(
literal|"Attempt to assign to a value that was optimized out."
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|==
name|lval_memory
condition|)
name|write_memory
argument_list|(
name|addr
argument_list|,
name|buffer
operator|+
name|amount_copied
argument_list|,
name|reg_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lval
operator|==
name|lval_register
condition|)
name|write_register_bytes
argument_list|(
name|addr
argument_list|,
name|buffer
operator|+
name|amount_copied
argument_list|,
name|reg_size
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Attempt to assign to an unmodifiable value."
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Left side of = operation is not an lvalue."
argument_list|)
expr_stmt|;
block|}
comment|/* Return a value just like TOVAL except with the contents of FROMVAL      (except in the case of the type if TOVAL is an internalvar).  */
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|toval
argument_list|)
operator|==
name|lval_internalvar
operator|||
name|VALUE_LVAL
argument_list|(
name|toval
argument_list|)
operator|==
name|lval_internalvar_component
condition|)
block|{
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|fromval
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|val
argument_list|,
name|toval
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Extend a value VAL to COUNT repetitions of its type.  */
end_comment

begin_function
name|value
name|value_repeat
parameter_list|(
name|arg1
parameter_list|,
name|count
parameter_list|)
name|value
name|arg1
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|!=
name|lval_memory
condition|)
name|error
argument_list|(
literal|"Only values in memory can be extended with '@'."
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"Invalid number %d of repetitions."
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_repeat_value
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|value
name|value_of_variable
parameter_list|(
name|var
parameter_list|)
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
block|{
name|value
name|val
decl_stmt|;
name|val
operator|=
name|read_var_value
argument_list|(
name|var
argument_list|,
operator|(
name|FRAME
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Address of symbol \"%s\" is unknown."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Given a value which is an array, return a value which is    a pointer to its first (actually, zeroth) element.     FIXME, this should be subtracting the array's lower bound. */
end_comment

begin_function
name|value
name|value_coerce_array
parameter_list|(
name|arg1
parameter_list|)
name|value
name|arg1
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|!=
name|lval_memory
condition|)
name|error
argument_list|(
literal|"Attempt to take address of value not located in memory."
argument_list|)
expr_stmt|;
comment|/* Get type of elements.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* A phony array made by value_repeat.        Its type is the type of the elements, not an array type.  */
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a value which is a function, return a value which is a pointer    to it.  */
end_comment

begin_function
name|value
name|value_coerce_function
parameter_list|(
name|arg1
parameter_list|)
name|value
name|arg1
decl_stmt|;
block|{
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|!=
name|lval_memory
condition|)
name|error
argument_list|(
literal|"Attempt to take address of value not located in memory."
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer value for the object for which ARG1 is the contents.  */
end_comment

begin_function
name|value
name|value_addr
parameter_list|(
name|arg1
parameter_list|)
name|value
name|arg1
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Copy the value, but change the type from (T&) to (T*). 	 We keep the same location information, which is efficient, 	 and allows&(&X) to get the location containing the reference. */
name|value
name|arg2
init|=
name|value_copy
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arg2
return|;
block|}
if|if
condition|(
name|VALUE_REPEATED
argument_list|(
name|arg1
argument_list|)
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
return|return
name|value_coerce_array
argument_list|(
name|arg1
argument_list|)
return|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
return|return
name|value_coerce_function
argument_list|(
name|arg1
argument_list|)
return|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|!=
name|lval_memory
condition|)
name|error
argument_list|(
literal|"Attempt to take address of value not located in memory."
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a value of a pointer type, apply the C unary * operator to it.  */
end_comment

begin_function
name|value
name|value_ind
parameter_list|(
name|arg1
parameter_list|)
name|value
name|arg1
decl_stmt|;
block|{
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"not implemented: member types in value_ind"
argument_list|)
expr_stmt|;
comment|/* Allow * on an integer so we can cast it to whatever we want.      This returns an int, which seems like the most C-like thing      to do.  "long long" variables are rare enough that      BUILTIN_TYPE_LONGEST would seem to be a mistake.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|value_at_lazy
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
name|error
argument_list|(
literal|"Attempt to take contents of a non-pointer value."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing small parts of stack frames.  */
end_comment

begin_comment
comment|/* Push one word (the size of object that a register holds).  */
end_comment

begin_function
name|CORE_ADDR
name|push_word
parameter_list|(
name|sp
parameter_list|,
name|buffer
parameter_list|)
name|CORE_ADDR
name|sp
decl_stmt|;
name|REGISTER_TYPE
name|buffer
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
decl_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|INNER_THAN
literal|2
name|sp
operator|-=
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* stack grows upward */
name|write_memory
argument_list|(
name|sp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* stack grows upward */
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Push LEN bytes with data at BUFFER.  */
end_comment

begin_function
name|CORE_ADDR
name|push_bytes
parameter_list|(
name|sp
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|sp
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|#
directive|if
literal|1
name|INNER_THAN
literal|2
name|sp
operator|-=
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* stack grows upward */
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* stack grows upward */
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Push onto the stack the specified value VALUE.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|value_push
parameter_list|(
name|sp
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|CORE_ADDR
name|sp
decl_stmt|;
name|value
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
literal|1
name|INNER_THAN
literal|2
name|sp
operator|-=
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* stack grows upward */
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* stack grows upward */
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Perform the standard coercions that are specified    for arguments to be passed to C functions.  */
end_comment

begin_function
name|value
name|value_arg_coerce
parameter_list|(
name|arg
parameter_list|)
name|value
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
return|return
name|value_cast
argument_list|(
name|builtin_type_int
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_double
argument_list|)
condition|)
return|return
name|value_cast
argument_list|(
name|builtin_type_double
argument_list|,
name|arg
argument_list|)
return|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Push the value ARG, first coercing it as an argument    to a C function.  */
end_comment

begin_function
name|CORE_ADDR
name|value_arg_push
parameter_list|(
name|sp
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|CORE_ADDR
name|sp
decl_stmt|;
name|value
name|arg
decl_stmt|;
block|{
return|return
name|value_push
argument_list|(
name|sp
argument_list|,
name|value_arg_coerce
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine a function's address and its return type from its value.     Calls error() if the function is not valid for calling.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_function_addr
parameter_list|(
name|function
parameter_list|,
name|retval_type
parameter_list|)
name|value
name|function
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|retval_type
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|ftype
init|=
name|VALUE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|CORE_ADDR
name|funaddr
decl_stmt|;
comment|/* If it's a member function, just look at the function      part of it.  */
comment|/* Determine address to call.  */
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|funaddr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|funaddr
operator|=
name|value_as_pointer
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
operator|||
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value_type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* Handle the case of functions lacking debugging info. 	 Their values are characters since their addresses are char */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|ftype
argument_list|)
operator|==
literal|1
condition|)
name|funaddr
operator|=
name|value_as_pointer
argument_list|(
name|value_addr
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Handle integer used as address of a function.  */
name|funaddr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid data type for function to be called."
argument_list|)
expr_stmt|;
operator|*
name|retval_type
operator|=
name|value_type
expr_stmt|;
return|return
name|funaddr
return|;
block|}
end_function

begin_function
name|int
name|is_gcc_function
parameter_list|(
name|funaddr
parameter_list|)
name|CORE_ADDR
name|funaddr
decl_stmt|;
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc
argument_list|(
name|funaddr
argument_list|)
decl_stmt|;
comment|/* If compiled without -g, assume GCC.  */
return|return
operator|(
name|b
operator|==
name|NULL
operator|||
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_CALL_FUNCTION
end_ifdef

begin_function
name|int
name|value_arg_bytes
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|--
name|nargs
operator|>=
literal|0
condition|)
name|len
operator|+=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|value_arg_coerce
argument_list|(
name|args
index|[
name|nargs
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Perform a function call in the inferior.    ARGS is a vector of values of arguments (NARGS of them).    FUNCTION is a value, the function to be called.    Returns a value representing what the function returned.    May fail to return, if a breakpoint or signal is hit    during the execution of the function.  */
end_comment

begin_function
name|value
name|call_function_by_hand
parameter_list|(
name|function
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|)
name|value
name|function
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|sp
decl_stmt|,
name|pc
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|struct
name|inferior_status
name|inf_status
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
specifier|register
name|CORE_ADDR
name|funaddr
decl_stmt|;
name|int
name|struct_return_bytes
decl_stmt|;
name|int
name|gcc_p
decl_stmt|;
name|char
name|retbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|save_inferior_status
argument_list|(
operator|&
name|inf_status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|restore_inferior_status
argument_list|,
operator|&
name|inf_status
argument_list|)
expr_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|funaddr
operator|=
name|find_function_addr
argument_list|(
name|function
argument_list|,
operator|&
name|value_type
argument_list|)
expr_stmt|;
name|gcc_p
operator|=
name|is_gcc_function
argument_list|(
name|funaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Are we returning a value using a structure return or a 	 * normal value return? 	 */
if|if
condition|(
name|using_struct_return
argument_list|(
name|function
argument_list|,
name|funaddr
argument_list|,
name|value_type
argument_list|,
name|gcc_p
argument_list|)
condition|)
name|struct_return_bytes
operator|=
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
else|else
name|struct_return_bytes
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Create a call sequence customized for this function and 	 * the number of arguments for it. 	 */
name|pc
operator|=
name|setup_dummy
argument_list|(
name|sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|struct_return_bytes
argument_list|,
name|gcc_p
argument_list|)
expr_stmt|;
comment|/* 	 * Execute the stack dummy stub.  The register state will be 	 * returned in retbuf.  It is restored below. 	 */
name|run_stack_dummy
argument_list|(
name|pc
argument_list|,
name|retbuf
argument_list|)
expr_stmt|;
comment|/* 	 * This will restore the register context that existed before 	 * we called the dummy function. 	 */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* 	 * The proceed/wait_for_inferior interface is totally 	 * brain dead.  It sets the current frame using the stopped 	 * pc and there is no easier way to fix this other 	 * than starting over after we restore the registers. 	 */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_being_returned
argument_list|(
name|value_type
argument_list|,
name|retbuf
argument_list|,
name|struct_return_bytes
argument_list|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|CALL_DUMMY
argument_list|)
end_elif

begin_comment
comment|/* All this stuff with a dummy frame may seem unnecessarily complicated    (why not just save registers in GDB?).  The purpose of pushing a dummy    frame which looks just like a real frame is so that if you call a    function and then hit a breakpoint (get a signal, etc), "backtrace"    will look right.  Whether the backtrace needs to actually show the    stack at the time the inferior function was called is debatable, but    it certainly needs to not display garbage.  So if you are contemplating    making dummy frames be different from normal frames, consider that.  */
end_comment

begin_comment
comment|/* Perform a function call in the inferior.    ARGS is a vector of values of arguments (NARGS of them).    FUNCTION is a value, the function to be called.    Returns a value representing what the function returned.    May fail to return, if a breakpoint or signal is hit    during the execution of the function.  */
end_comment

begin_function
name|value
name|call_function_by_hand
parameter_list|(
name|function
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|)
name|value
name|function
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|start_sp
decl_stmt|;
comment|/* CALL_DUMMY is an array of words (REGISTER_TYPE), but each word      is in host byte order.  It is switched to target byte order before calling      FIX_CALL_DUMMY.  */
specifier|static
name|REGISTER_TYPE
name|dummy
index|[]
init|=
name|CALL_DUMMY
decl_stmt|;
name|REGISTER_TYPE
name|dummy1
index|[
sizeof|sizeof
name|dummy
operator|/
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
index|]
decl_stmt|;
name|CORE_ADDR
name|old_sp
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|unsigned
name|char
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
name|struct
name|inferior_status
name|inf_status
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|CORE_ADDR
name|funaddr
decl_stmt|;
name|int
name|using_gcc
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|noprocess
argument_list|()
expr_stmt|;
name|save_inferior_status
argument_list|(
operator|&
name|inf_status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|restore_inferior_status
argument_list|,
operator|&
name|inf_status
argument_list|)
expr_stmt|;
comment|/* PUSH_DUMMY_FRAME is responsible for saving the inferior registers      (and POP_FRAME for restoring them).  (At least on most machines)      they are saved on the stack in the inferior.  */
name|PUSH_DUMMY_FRAME
expr_stmt|;
name|old_sp
operator|=
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|INNER_THAN
literal|2
comment|/* Stack grows down */
name|sp
operator|-=
sizeof|sizeof
name|dummy
expr_stmt|;
name|start_sp
operator|=
name|sp
expr_stmt|;
else|#
directive|else
comment|/* Stack grows up */
name|start_sp
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
sizeof|sizeof
name|dummy
expr_stmt|;
endif|#
directive|endif
name|funaddr
operator|=
name|find_function_addr
argument_list|(
name|function
argument_list|,
operator|&
name|value_type
argument_list|)
expr_stmt|;
name|using_gcc
operator|=
name|is_gcc_function
argument_list|(
name|funaddr
argument_list|)
expr_stmt|;
comment|/* Are we returning a value using a structure return or a normal      value return? */
name|struct_return
operator|=
name|using_struct_return
argument_list|(
name|function
argument_list|,
name|funaddr
argument_list|,
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
comment|/* Create a call sequence customized for this function      and the number of arguments for it.  */
name|memcpy
argument_list|(
name|dummy1
argument_list|,
name|dummy
argument_list|,
sizeof|sizeof
name|dummy
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|dummy
operator|/
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
condition|;
name|i
operator|++
control|)
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|dummy1
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|REGISTER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|FIX_CALL_DUMMY
argument_list|(
name|dummy1
argument_list|,
name|start_sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
if|#
directive|if
name|CALL_DUMMY_LOCATION
operator|==
name|ON_STACK
name|write_memory
argument_list|(
name|start_sp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy1
argument_list|,
sizeof|sizeof
name|dummy
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Not on stack.  */
if|#
directive|if
name|CALL_DUMMY_LOCATION
operator|==
name|BEFORE_TEXT_END
comment|/* Convex Unix prohibits executing in the stack segment. */
comment|/* Hope there is empty room at the top of the text segment. */
block|{
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
specifier|static
name|checked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|checked
condition|)
for|for
control|(
name|start_sp
operator|=
name|text_end
operator|-
sizeof|sizeof
name|dummy
init|;
name|start_sp
operator|<
name|text_end
condition|;
operator|++
name|start_sp
control|)
if|if
condition|(
name|read_memory_integer
argument_list|(
name|start_sp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"text segment full -- no place to put call"
argument_list|)
expr_stmt|;
name|checked
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|old_sp
expr_stmt|;
name|start_sp
operator|=
name|text_end
operator|-
sizeof|sizeof
name|dummy
expr_stmt|;
name|write_memory
argument_list|(
name|start_sp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy1
argument_list|,
sizeof|sizeof
name|dummy
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* After text_end.  */
block|{
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|sp
operator|=
name|old_sp
expr_stmt|;
name|start_sp
operator|=
name|text_end
expr_stmt|;
name|errcode
operator|=
name|target_write_memory
argument_list|(
name|start_sp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy1
argument_list|,
sizeof|sizeof
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot write text segment -- call_function failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* After text_end.  */
endif|#
directive|endif
comment|/* Not on stack.  */
ifdef|#
directive|ifdef
name|lint
name|sp
operator|=
name|old_sp
expr_stmt|;
comment|/* It really is used, for some ifdef's... */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK_ALIGN
comment|/* If stack grows down, we must leave a hole at the top. */
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|/* Reserve space for the return structure to be written on the        stack, if necessary */
if|if
condition|(
name|struct_return
condition|)
name|len
operator|+=
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|len
operator|+=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|value_arg_coerce
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CALL_DUMMY_STACK_ADJUST
name|len
operator|+=
name|CALL_DUMMY_STACK_ADJUST
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
name|INNER_THAN
literal|2
name|sp
operator|-=
name|STACK_ALIGN
argument_list|(
name|len
argument_list|)
operator|-
name|len
expr_stmt|;
else|#
directive|else
name|sp
operator|+=
name|STACK_ALIGN
argument_list|(
name|len
argument_list|)
operator|-
name|len
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* STACK_ALIGN */
comment|/* Reserve space for the return structure to be written on the        stack, if necessary */
if|if
condition|(
name|struct_return
condition|)
block|{
if|#
directive|if
literal|1
name|INNER_THAN
literal|2
name|sp
operator|-=
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
name|struct_addr
operator|=
name|sp
expr_stmt|;
else|#
directive|else
name|struct_addr
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|REG_STRUCT_HAS_ADDR
argument_list|)
block|{
comment|/* This is a machine like the sparc, where we need to pass a pointer        to the structure, not the structure itself.  */
if|if
condition|(
name|REG_STRUCT_HAS_ADDR
argument_list|(
name|using_gcc
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
if|#
directive|if
operator|!
operator|(
literal|1
name|INNER_THAN
literal|2
operator|)
comment|/* The stack grows up, so the address of the thing we push 	       is the stack pointer before we push it.  */
name|addr
operator|=
name|sp
expr_stmt|;
endif|#
directive|endif
comment|/* Push the structure.  */
name|sp
operator|=
name|value_push
argument_list|(
name|sp
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|INNER_THAN
literal|2
comment|/* The stack grows down, so the address of the thing we push 	       is the stack pointer after we push it.  */
name|addr
operator|=
name|sp
expr_stmt|;
endif|#
directive|endif
comment|/* The value we're going to pass is the address of the thing 	       we just pushed.  */
name|args
index|[
name|i
index|]
operator|=
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|value_type
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* REG_STRUCT_HAS_ADDR.  */
ifdef|#
directive|ifdef
name|PUSH_ARGUMENTS
name|PUSH_ARGUMENTS
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !PUSH_ARGUMENTS */
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|sp
operator|=
name|value_arg_push
argument_list|(
name|sp
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !PUSH_ARGUMENTS */
ifdef|#
directive|ifdef
name|CALL_DUMMY_STACK_ADJUST
if|#
directive|if
literal|1
name|INNER_THAN
literal|2
name|sp
operator|-=
name|CALL_DUMMY_STACK_ADJUST
expr_stmt|;
else|#
directive|else
name|sp
operator|+=
name|CALL_DUMMY_STACK_ADJUST
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* CALL_DUMMY_STACK_ADJUST */
comment|/* Store the address at which the structure is supposed to be      written.  Note that this (and the code which reserved the space      above) assumes that gcc was used to compile this function.  Since      it doesn't cost us anything but space and if the function is pcc      it will ignore this value, we will make that assumption.       Also note that on some machines (like the sparc) pcc uses a       convention like gcc's.  */
if|if
condition|(
name|struct_return
condition|)
name|STORE_STRUCT_RETURN
argument_list|(
name|struct_addr
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Write the stack pointer.  This is here because the statements above      might fool with it.  On SPARC, this write also stores the register      window into the right place in the new stack frame, which otherwise      wouldn't happen.  (See write_inferior_registers in sparc-xdep.c.)  */
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Figure out the value returned by the function.  */
block|{
name|char
name|retbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
comment|/* Execute the stack dummy routine, calling FUNCTION.        When it is done, discard the empty frame        after storing the contents of all regs into retbuf.  */
name|run_stack_dummy
argument_list|(
name|start_sp
operator|+
name|CALL_DUMMY_START_OFFSET
argument_list|,
name|retbuf
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|value_being_returned
argument_list|(
name|value_type
argument_list|,
name|retbuf
argument_list|,
name|struct_return
argument_list|)
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no CALL_DUMMY.  */
end_comment

begin_function
name|value
name|call_function_by_hand
parameter_list|(
name|function
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|)
name|value
name|function
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Cannot invoke functions on this machine."
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no CALL_DUMMY.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Create a value for a string constant:    Call the function malloc in the inferior to get space for it,    then copy the data into that space    and then return the address with type char *.    PTR points to the string constant data; LEN is number of characters.  */
end_comment

begin_function
name|value
name|value_string
parameter_list|(
name|ptr
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|value
name|blocklen
decl_stmt|;
specifier|register
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|i
init|=
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|o
init|=
name|copy
decl_stmt|,
modifier|*
name|ibeg
init|=
name|ptr
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Copy the string into COPY, processing escapes.      We could not conveniently process them in the parser      because the string there wants to be a substring of the input.  */
while|while
condition|(
name|i
operator|-
name|ibeg
operator|<
name|len
condition|)
block|{
name|c
operator|=
operator|*
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
continue|continue;
block|}
operator|*
name|o
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|o
operator|=
literal|0
expr_stmt|;
comment|/* Get the length of the string after escapes are processed.  */
name|len
operator|=
name|o
operator|-
name|copy
expr_stmt|;
comment|/* Find the address of malloc in the inferior.  */
name|sym
operator|=
name|lookup_symbol
argument_list|(
literal|"malloc"
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
condition|)
name|error
argument_list|(
literal|"\"malloc\" exists in this program but is not a function."
argument_list|)
expr_stmt|;
name|val
operator|=
name|value_of_variable
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"malloc"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|val
operator|=
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|lookup_function_type
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
argument_list|)
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|msymbol
operator|->
name|address
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"String constants require the program to have a function \"malloc\"."
argument_list|)
expr_stmt|;
block|}
name|blocklen
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
call|(
name|LONGEST
call|)
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|call_function_by_hand
argument_list|(
name|val
argument_list|,
literal|1
argument_list|,
operator|&
name|blocklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_zerop
argument_list|(
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"No memory available for string constant."
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|value_as_pointer
argument_list|(
name|val
argument_list|)
argument_list|,
name|copy
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function used by value_struct_elt to recurse through baseclasses.    Look for a field NAME in ARG1. Adjust the address of ARG1 by OFFSET bytes,    and search in it assuming it has (class) type TYPE.    If found, return value, else return NULL.     If LOOKING_FOR_BASECLASS, then instead of looking for struct fields,    look for a baseclass named NAME.  */
end_comment

begin_function
specifier|static
name|value
name|search_struct_field
parameter_list|(
name|name
parameter_list|,
name|arg1
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|,
name|looking_for_baseclass
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|value
name|arg1
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|looking_for_baseclass
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|check_stub_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|looking_for_baseclass
condition|)
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|&&
operator|!
name|strcmp
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|value
name|v
decl_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|char
modifier|*
name|phys_name
init|=
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal error: could not find physical static variable named %s"
argument_list|,
name|phys_name
argument_list|)
expr_stmt|;
name|v
operator|=
name|value_at
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|v
operator|=
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
name|offset
argument_list|,
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"there is no field named %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|value
name|v
decl_stmt|;
comment|/* If we are looking for baseclasses, this is what we get when we 	 hit them.  */
name|int
name|found_baseclass
init|=
operator|(
name|looking_for_baseclass
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|TYPE_BASECLASS_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|value
name|v2
decl_stmt|;
comment|/* Fix to use baseclass_offset instead. FIXME */
name|baseclass_addr
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|,
operator|&
name|v2
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"virtual baseclass botch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_baseclass
condition|)
return|return
name|v2
return|;
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
name|v2
argument_list|,
literal|0
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|looking_for_baseclass
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_baseclass
condition|)
name|v
operator|=
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
name|offset
argument_list|,
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
name|arg1
argument_list|,
name|offset
operator|+
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|looking_for_baseclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
return|return
name|v
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Helper function used by value_struct_elt to recurse through baseclasses.    Look for a field NAME in ARG1. Adjust the address of ARG1 by OFFSET bytes,    and search in it assuming it has (class) type TYPE.    If found, return value, else return NULL. */
end_comment

begin_function
specifier|static
name|value
name|search_struct_method
parameter_list|(
name|name
parameter_list|,
name|arg1p
parameter_list|,
name|args
parameter_list|,
name|offset
parameter_list|,
name|static_memfuncp
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|value
modifier|*
name|arg1p
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|offset
decl_stmt|,
modifier|*
name|static_memfuncp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|check_stub_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|&&
operator|!
name|strcmp
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|int
name|j
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|-
literal|1
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
operator|&&
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cannot resolve overloaded method `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|typecmp
argument_list|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
return|return
operator|(
name|value
operator|)
name|value_virtual_fn_field
argument_list|(
name|arg1p
argument_list|,
name|f
argument_list|,
name|j
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
return|;
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|&&
name|static_memfuncp
condition|)
operator|*
name|static_memfuncp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|value_fn_field
argument_list|(
name|arg1p
argument_list|,
name|f
argument_list|,
name|j
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
return|;
block|}
name|j
operator|--
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|value
name|v
decl_stmt|;
name|int
name|base_offset
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|base_offset
operator|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
operator|*
name|arg1p
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_offset
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"virtual baseclass botch"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base_offset
operator|=
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
block|}
name|v
operator|=
name|search_struct_method
argument_list|(
name|name
argument_list|,
name|arg1p
argument_list|,
name|args
argument_list|,
name|base_offset
operator|+
name|offset
argument_list|,
name|static_memfuncp
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
block|{
comment|/* FIXME-bothner:  Why is this commented out?  Why is it here?  */
comment|/*	  *arg1p = arg1_tmp;*/
return|return
name|v
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/* Given *ARGP, a value of type (pointer to a)* structure/union,    extract the component named NAME from the ultimate target structure/union    and return it as a value with its appropriate type.    ERR is used in the error message if *ARGP's type is wrong.     C++: ARGS is a list of argument types to aid in the selection of    an appropriate method. Also, handle derived types.     STATIC_MEMFUNCP, if non-NULL, points to a caller-supplied location    where the truthvalue of whether the function that was resolved was    a static member function or not is stored.     ERR is an error message to be printed in case the field is not found.  */
end_comment

begin_function
name|value
name|value_struct_elt
parameter_list|(
name|argp
parameter_list|,
name|args
parameter_list|,
name|name
parameter_list|,
name|static_memfuncp
parameter_list|,
name|err
parameter_list|)
specifier|register
name|value
modifier|*
name|argp
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|static_memfuncp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|value
name|v
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
name|t
operator|=
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
comment|/* Follow pointers until we get to a non-pointer.  */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
operator|*
name|argp
operator|=
name|value_ind
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
comment|/* Don't coerce fn pointer to fn and then back again!  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|COERCE_ARRAY
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
name|t
operator|=
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"not implemented: member type in value_struct_elt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Attempt to extract a component of a value that is not a %s."
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* Assume it's not, unless we see that it is.  */
if|if
condition|(
name|static_memfuncp
condition|)
operator|*
name|static_memfuncp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
block|{
comment|/* if there are no arguments ...do this...  */
comment|/* Try as a field first, because if we succeed, there 	 is less work to be done.  */
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
operator|*
name|argp
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
return|return
name|v
return|;
comment|/* C++: If it was not found as a data field, then try to          return it as a pointer to a method.  */
if|if
condition|(
name|destructor_name_p
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"Cannot get value of destructor"
argument_list|)
expr_stmt|;
name|v
operator|=
name|search_struct_method
argument_list|(
name|name
argument_list|,
name|argp
argument_list|,
name|args
argument_list|,
literal|0
argument_list|,
name|static_memfuncp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"There is no member or method named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"There is no member named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
if|if
condition|(
name|destructor_name_p
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|args
index|[
literal|1
index|]
condition|)
block|{
comment|/* destructors are a special case.  */
return|return
operator|(
name|value
operator|)
name|value_fn_field
argument_list|(
name|NULL
argument_list|,
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"destructor should not have any argument"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|v
operator|=
name|search_struct_method
argument_list|(
name|name
argument_list|,
name|argp
argument_list|,
name|args
argument_list|,
literal|0
argument_list|,
name|static_memfuncp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
comment|/* See if user tried to invoke data as function.  If so, 	 hand it back.  If it's not callable (i.e., a pointer to function), 	 gdb should give an error.  */
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
operator|*
name|argp
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|v
condition|)
name|error
argument_list|(
literal|"Structure has no component named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_block

begin_comment
comment|/* C++: return 1 is NAME is a legitimate name for the destructor    of type TYPE.  If TYPE does not have a destructor, or    if NAME is inappropriate for TYPE, an error is signaled.  */
end_comment

begin_function
name|int
name|destructor_name_p
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
comment|/* destructors are a special case.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|dname
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dname
argument_list|,
name|name
operator|+
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|"name of destructor must equal name of class"
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper function for check_field: Given TYPE, a structure/union,    return 1 if the component named NAME from the ultimate    target structure/union is defined, otherwise, return 0. */
end_comment

begin_function
specifier|static
name|int
name|check_field_in
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|&&
operator|!
name|strcmp
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* C++: If it was not found as a data field, then try to      return it as a pointer to a method.  */
comment|/* Destructors are a special case.  */
if|if
condition|(
name|destructor_name_p
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|check_field_in
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* C++: Given ARG1, a value of type (pointer to a)* structure/union,    return 1 if the component named NAME from the ultimate    target structure/union is defined, otherwise, return 0.  */
end_comment

begin_function
name|int
name|check_field
parameter_list|(
name|arg1
parameter_list|,
name|name
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|t
operator|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Follow pointers until we get to a non-pointer.  */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
name|t
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"not implemented: member type in check_field"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Internal error: `this' is not an aggregate"
argument_list|)
expr_stmt|;
return|return
name|check_field_in
argument_list|(
name|t
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* C++: Given an aggregate type CURTYPE, and a member name NAME,    return the address of this member as a "pointer to member"    type.  If INTYPE is non-null, then it will be the type    of the member we are looking for.  This will help us resolve    "pointers to member functions".  This function is used    to resolve user expressions of the form "DOMAIN::NAME".  */
end_comment

begin_function
name|value
name|value_struct_elt_for_reference
parameter_list|(
name|domain
parameter_list|,
name|offset
parameter_list|,
name|curtype
parameter_list|,
name|name
parameter_list|,
name|intype
parameter_list|)
name|struct
name|type
modifier|*
name|domain
decl_stmt|,
decl|*
name|curtype
decl_stmt|,
modifier|*
name|intype
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|type
modifier|*
name|t
init|=
name|curtype
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|value
name|v
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Internal error: non-aggregate type to value_struct_elt_for_reference"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|&&
operator|!
name|strcmp
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|char
modifier|*
name|phys_name
init|=
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal error: could not find physical static variable named %s"
argument_list|,
name|phys_name
argument_list|)
expr_stmt|;
return|return
name|value_at
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_FIELD_PACKED
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|error
argument_list|(
literal|"pointers to bitfield members not allowed"
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|lookup_reference_type
argument_list|(
name|lookup_member_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|domain
argument_list|)
argument_list|)
argument_list|,
name|offset
operator|+
call|(
name|LONGEST
call|)
argument_list|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|>>
literal|3
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* C++: If it was not found as a data field, then try to      return it as a pointer to a method.  */
comment|/* Destructors are a special case.  */
if|if
condition|(
name|destructor_name_p
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"member pointers to destructors not implemented yet"
argument_list|)
expr_stmt|;
block|}
comment|/* Perform all necessary dereferencing.  */
while|while
condition|(
name|intype
operator|&&
name|TYPE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|intype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|int
name|j
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|intype
operator|==
literal|0
operator|&&
name|j
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"non-unique member `%s' requires type instantiation"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|intype
condition|)
block|{
while|while
condition|(
name|j
operator|--
condition|)
if|if
condition|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|intype
condition|)
break|break;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"no member function matches that type instantiation"
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
return|return
name|value_from_longest
argument_list|(
name|lookup_reference_type
argument_list|(
name|lookup_member_type
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|domain
argument_list|)
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|METHOD_PTR_FROM_VOFFSET
argument_list|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|symbol
modifier|*
name|s
init|=
name|lookup_symbol
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|v
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|read_var_value
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|VALUE_TYPE (v) = lookup_reference_type 		    (lookup_member_type (TYPE_FN_FIELD_TYPE (f, j), 					 domain));
endif|#
directive|endif
block|}
return|return
name|v
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|value
name|v
decl_stmt|;
name|int
name|base_offset
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|base_offset
operator|=
literal|0
expr_stmt|;
else|else
name|base_offset
operator|=
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
name|v
operator|=
name|value_struct_elt_for_reference
argument_list|(
name|domain
argument_list|,
name|offset
operator|+
name|base_offset
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|,
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
return|return
name|v
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Compare two argument lists and return the position in which they differ,    or zero if equal.     STATICP is nonzero if the T1 argument list came from a    static member function.     For non-static member functions, we ignore the first argument,    which is the type of the instance variable.  This is because we want    to handle calls with objects from derived classes.  This is not    entirely correct: we should actually check to make sure that a    requested operation is type secure, shouldn't we?  FIXME.  */
end_comment

begin_function
name|int
name|typecmp
parameter_list|(
name|staticp
parameter_list|,
name|t1
parameter_list|,
name|t2
parameter_list|)
name|int
name|staticp
decl_stmt|;
name|struct
name|type
modifier|*
name|t1
index|[]
decl_stmt|;
name|value
name|t2
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|staticp
operator|&&
name|t1
operator|==
literal|0
condition|)
return|return
name|t2
index|[
literal|1
index|]
operator|!=
literal|0
return|;
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
index|[
literal|0
index|]
operator|->
name|code
operator|==
name|TYPE_CODE_VOID
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|t1
index|[
operator|!
name|staticp
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
operator|!
name|staticp
init|;
name|t1
index|[
name|i
index|]
operator|&&
name|t1
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|t2
index|[
name|i
index|]
operator|||
name|t1
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|t2
index|[
name|i
index|]
operator|->
name|type
operator|->
name|code
comment|/* Too pessimistic:  || t1[i]->target_type != t2[i]->type->target_type */
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|t1
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
return|return
name|t2
index|[
name|i
index|]
condition|?
name|i
operator|+
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* C++: return the value of the class instance variable, if one exists.    Flag COMPLAIN signals an error if the request is made in an    inappropriate context.  */
end_comment

begin_function
name|value
name|value_of_this
parameter_list|(
name|complain
parameter_list|)
name|int
name|complain
decl_stmt|;
block|{
specifier|extern
name|FRAME
name|selected_frame
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
name|funny_this
index|[]
init|=
literal|"this"
decl_stmt|;
name|value
name|this
decl_stmt|;
if|if
condition|(
name|selected_frame
operator|==
literal|0
condition|)
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no frame selected"
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
name|func
operator|=
name|get_frame_function
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|func
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no `this' in nameless context"
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|i
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no args, no `this'"
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Calling lookup_block_symbol is necessary to get the LOC_REGISTER      symbol instead of the LOC_ARG one (if both exist).  */
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|funny_this
argument_list|,
name|VAR_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"current stack frame not in method"
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
block|}
name|this
operator|=
name|read_var_value
argument_list|(
name|sym
argument_list|,
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|==
literal|0
operator|&&
name|complain
condition|)
name|error
argument_list|(
literal|"`this' argument at unknown address"
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

end_unit

