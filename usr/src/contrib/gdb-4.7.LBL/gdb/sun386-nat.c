begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native support for Sun 386i's for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.    Changes for sun386i by Jean Daniel Fekete (jdf@litp.univ-p6-7.fr),    C2V Paris, April 89.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GDB_TARGET_IS_SUN386
argument_list|)
end_if

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Machine-dependent code which would otherwise be in core.c */
end_comment

begin_comment
comment|/* Work with core files, for GDB. */
end_comment

begin_escape
end_escape

begin_function
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
comment|/* Discard all vestiges of any previous core file      and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the inferior with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|{
name|struct
name|core
name|corestr
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|corestr
argument_list|,
sizeof|sizeof
name|corestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|corestr
operator|.
name|c_magic
operator|!=
name|CORE_MAGIC
condition|)
name|error
argument_list|(
literal|"\"%s\" does not appear to be a core dump file (magic 0x%x, expected 0x%x)"
argument_list|,
name|filename
argument_list|,
name|corestr
operator|.
name|c_magic
argument_list|,
operator|(
name|int
operator|)
name|CORE_MAGIC
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|core
argument_list|)
operator|!=
name|corestr
operator|.
name|c_len
condition|)
name|error
argument_list|(
literal|"\"%s\" has an invalid struct core length (%d, expected %d)"
argument_list|,
name|filename
argument_list|,
name|corestr
operator|.
name|c_len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|core
argument_list|)
argument_list|)
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|corestr
operator|.
name|c_dsize
expr_stmt|;
name|stack_start
operator|=
name|stack_end
operator|-
name|corestr
operator|.
name|c_ssize
expr_stmt|;
name|data_offset
operator|=
sizeof|sizeof
name|corestr
expr_stmt|;
name|stack_offset
operator|=
sizeof|sizeof
name|corestr
operator|+
name|corestr
operator|.
name|c_dsize
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|corestr
operator|.
name|c_regs
argument_list|,
name|registers
argument_list|,
sizeof|sizeof
name|corestr
operator|.
name|c_regs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|corestr
operator|.
name|c_fpu
operator|.
name|f_fpstatus
operator|.
name|f_st
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|corestr
operator|.
name|c_fpu
operator|.
name|f_fpstatus
operator|.
name|f_st
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|corestr
operator|.
name|c_fpu
operator|.
name|f_fpstatus
operator|.
name|f_ctrl
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|corestr
operator|.
name|c_fpu
operator|.
name|f_fpstatus
operator|-
sizeof|sizeof
name|corestr
operator|.
name|c_fpu
operator|.
name|f_fpstatus
operator|.
name|f_st
argument_list|)
expr_stmt|;
comment|/* the struct aouthdr of sun coff is not the struct exec stored 	   in the core file. */
name|bcopy
argument_list|(
operator|&
name|corestr
operator|.
name|c_aouthdr
argument_list|,
operator|&
name|core_aouthdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|COFF_ENCAPSULATE
name|core_aouthdr
operator|.
name|magic
operator|=
name|corestr
operator|.
name|c_aouthdr
operator|.
name|a_info
expr_stmt|;
name|core_aouthdr
operator|.
name|vstamp
operator|=
comment|/*SUNVERSION*/
literal|31252
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"Core file is from \"%s\".\n"
argument_list|,
name|corestr
operator|.
name|c_cmdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|corestr
operator|.
name|c_signo
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Program terminated with signal %d, %s.\n"
argument_list|,
name|corestr
operator|.
name|c_signo
argument_list|,
name|safe_strsignal
argument_list|(
name|corestr
operator|.
name|c_signo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|i387_to_double
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* push extended mode on 387 stack, then pop in double mode    *    * first, set exception masks so no error is generated -    * number will be rounded to inf or 0, if necessary     */
asm|asm ("pushl %eax");
comment|/* grab a stack slot */
asm|asm ("fstcw (%esp)");
comment|/* get 387 control word */
asm|asm ("movl (%esp),%eax");
comment|/* save old value */
asm|asm ("orl $0x3f,%eax");
comment|/* mask all exceptions */
asm|asm ("pushl %eax");
asm|asm ("fldcw (%esp)");
comment|/* load new value into 387 */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldt (%eax)");
comment|/* push extended number on 387 stack */
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpl (%eax)");
comment|/* pop double */
asm|asm ("fwait");
asm|asm ("popl %eax");
comment|/* flush modified control word */
asm|asm ("fnclex");
comment|/* clear exceptions */
asm|asm ("fldcw (%esp)");
comment|/* restore original control word */
asm|asm ("popl %eax");
comment|/* flush saved copy */
block|}
end_block

begin_macro
name|double_to_i387
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* push double mode on 387 stack, then pop in extended mode    * no errors are possible because every 64-bit pattern    * can be converted to an extended    */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldl (%eax)");
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpt (%eax)");
asm|asm ("fwait");
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not sun386 target.  */
end_comment

begin_comment
comment|/* These functions shouldn't be called when we're cross-debugging.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|unsigned
name|int
name|reg_addr
decl_stmt|;
comment|/* Unused in this version */
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not sun386 target.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|regs
name|inferior_registers
decl_stmt|;
name|struct
name|fp_state
name|inferior_fp_registers
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|inferior_registers
argument_list|,
name|registers
argument_list|,
sizeof|sizeof
name|inferior_registers
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|inferior_fp_registers
operator|.
name|f_st
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|f_st
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|inferior_fp_registers
operator|.
name|f_ctrl
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|-
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|f_st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|regs
name|inferior_registers
decl_stmt|;
name|struct
name|fp_state
name|inferior_fp_registers
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|bcopy
argument_list|(
name|registers
argument_list|,
operator|&
name|inferior_registers
argument_list|,
literal|20
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
name|inferior_fp_registers
operator|.
name|f_st
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|f_st
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|inferior_fp_registers
operator|.
name|f_ctrl
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|-
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|f_st
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTRACE_FP_BUG
if|if
condition|(
name|regno
operator|==
name|FP_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
comment|/* Storing the frame pointer requires a gross hack, in which an        instruction that moves eax into ebp gets single-stepped.  */
block|{
name|int
name|stack
init|=
name|inferior_registers
operator|.
name|r_reg
index|[
name|SP_REGNUM
index|]
decl_stmt|;
name|int
name|stuff
init|=
name|ptrace
argument_list|(
name|PTRACE_PEEKDATA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|stack
argument_list|)
decl_stmt|;
name|int
name|reg
init|=
name|inferior_registers
operator|.
name|r_reg
index|[
name|EAX
index|]
decl_stmt|;
name|inferior_registers
operator|.
name|r_reg
index|[
name|EAX
index|]
operator|=
name|inferior_registers
operator|.
name|r_reg
index|[
name|FP_REGNUM
index|]
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKEDATA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|stack
argument_list|,
literal|0xc589
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_SINGLESTEP
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKEDATA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|stack
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
name|inferior_registers
operator|.
name|r_reg
index|[
name|EAX
index|]
operator|=
name|reg
expr_stmt|;
block|}
endif|#
directive|endif
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

