begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Core dump and executable file functions above target vector, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*exec_file_display_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Binary file diddling handle for the core file.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|core_bfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Backward compatability with old way of specifying core files.  */
end_comment

begin_function
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NOCOREFILE
name|error
argument_list|(
literal|"GDB can't read core files on this machine."
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|extern
name|struct
name|target_ops
name|core_ops
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|t
init|=
operator|&
name|core_ops
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Either way, seems bogus. */
if|if
condition|(
operator|!
name|filename
condition|)
call|(
name|t
operator|->
name|to_detach
call|)
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
call|(
name|t
operator|->
name|to_open
call|)
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call this to specify the hook for exec_file_command to call back.    This is called from the x-window display code.  */
end_comment

begin_function_decl
name|void
name|specify_exec_file_hook
parameter_list|(
name|hook
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*hook
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|exec_file_display_hook
operator|=
name|hook
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The exec file must be closed before running an inferior.    If it is needed again after the inferior dies, it must    be reopened.  */
end_comment

begin_function
name|void
name|close_exec_file
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|FIXME
if|if
condition|(
name|exec_bfd
condition|)
name|bfd_tempclose
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|reopen_exec_file
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|FIXME
if|if
condition|(
name|exec_bfd
condition|)
name|bfd_reopen
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we have both a core file and an exec file,    print a warning if they don't go together.  */
end_comment

begin_function
name|void
name|validate_files
parameter_list|()
block|{
if|if
condition|(
name|exec_bfd
operator|&&
name|core_bfd
condition|)
block|{
if|if
condition|(
operator|!
name|core_file_matches_executable_p
argument_list|(
name|core_bfd
argument_list|,
name|exec_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"core file may not match specified executable file."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
operator|>
name|bfd_get_mtime
argument_list|(
name|core_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"exec file is newer than core file."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the name of the executable file as a string.    ERR nonzero means get error if there is none specified;    otherwise return 0 in that case.  */
end_comment

begin_function
name|char
modifier|*
name|get_exec_file
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
block|{
if|if
condition|(
name|exec_bfd
condition|)
return|return
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
return|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|NULL
return|;
name|error
argument_list|(
literal|"No executable file specified.\n\ Use the \"file\" or \"exec-file\" command."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report a memory error with error().  */
end_comment

begin_function
name|void
name|memory_error
parameter_list|(
name|status
parameter_list|,
name|memaddr
parameter_list|)
name|int
name|status
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
block|{
if|if
condition|(
name|status
operator|==
name|EIO
condition|)
block|{
comment|/* Actually, address between memaddr and memaddr + len 	 was out of bounds. */
name|error
argument_list|(
literal|"Cannot access memory at address %s."
argument_list|,
name|local_hex_string
argument_list|(
name|memaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Error accessing memory address %s: %s."
argument_list|,
name|local_hex_string
argument_list|(
name|memaddr
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Same as target_read_memory, but report an error if can't read.  */
end_comment

begin_function
name|void
name|read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as target_write_memory, but report an error if can't write.  */
end_comment

begin_function
name|void
name|write_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read an integer from debugged memory, given address and number of bytes.  */
end_comment

begin_function
name|long
name|read_memory_integer
parameter_list|(
name|memaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|cbuf
decl_stmt|;
name|short
name|sbuf
decl_stmt|;
name|int
name|ibuf
decl_stmt|;
name|long
name|lbuf
decl_stmt|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
block|{
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|&
name|cbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|cbuf
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
block|{
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sbuf
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ibuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|ibuf
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ibuf
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
condition|)
block|{
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lbuf
return|;
block|}
name|error
argument_list|(
literal|"Cannot handle integers of %d bytes."
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* for lint */
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_core
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"core-file"
argument_list|,
name|class_files
argument_list|,
name|core_file_command
argument_list|,
literal|"Use FILE as core dump for examining memory and registers.\n\ No arg means have no core file.  This command has been superseded by the\n\ `target core' and `detach' commands."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

