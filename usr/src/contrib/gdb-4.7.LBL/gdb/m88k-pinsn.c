begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print instructions for the Motorola 88000, for GDB and GNU Binutils.    Copyright 1986, 1987, 1988, 1989, 1990, 1991 Free Software Foundation, Inc.    Contributed by Data General Corporation, November 1989.    Partially derived from an earlier printcmd.c.  This file is part of GDB and the GNU Binutils.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m88k.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_function_decl
name|void
name|sprint_address
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|INSTAB
modifier|*
name|hashtable
index|[
name|HASHVAL
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *		Disassemble an M88000 Instruction * * *       This module decodes the first instruction in inbuf.  It uses the pc *	to display pc-relative displacements.  It writes the disassembled *	instruction in outbuf. * *			Revision History * *       Revision 1.0    11/08/85        Creation date by Motorola *			05/11/89	R. Trawick adapted to GDB interface. */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|20
end_define

begin_macro
name|print_insn
argument_list|(
argument|memaddr
argument_list|,
argument|stream
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|memaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
comment|/* should be expanded if disassembler prints symbol names */
name|char
name|outbuf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Instruction addresses may have low two bits set. Clear them.	*/
name|memaddr
operator|&=
literal|0xfffffffc
expr_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|n
operator|=
name|m88kdis
argument_list|(
operator|(
name|int
operator|)
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|outbuf
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * disassemble the first instruction in 'inbuf'.  * 'pc' should be the address of this instruction, it will  *   be used to print the target address if this is a relative jump or call  * 'outbuf' gets filled in with the disassembled instruction.  It should  *   be long enough to hold the longest disassembled instruction.  *   100 bytes is certainly enough, unless symbol printing is added later  * The function returns the length of this instruction in bytes.  */
end_comment

begin_function
name|int
name|m88kdis
parameter_list|(
name|pc
parameter_list|,
name|inbuf
parameter_list|,
name|outbuf
parameter_list|)
name|int
name|pc
decl_stmt|;
name|int
modifier|*
name|inbuf
decl_stmt|;
name|char
modifier|*
name|outbuf
decl_stmt|;
block|{
specifier|static
name|ihashtab_initialized
operator|=
literal|0
expr_stmt|;
name|int
name|instruction
decl_stmt|;
name|unsigned
name|int
name|opcode
decl_stmt|;
name|INSTAB
modifier|*
name|entry_ptr
decl_stmt|;
name|int
name|opmask
decl_stmt|;
name|int
name|class
decl_stmt|;
name|instruction
operator|=
operator|*
name|inbuf
expr_stmt|;
if|if
condition|(
operator|!
name|ihashtab_initialized
condition|)
block|{
name|init_disasm
argument_list|()
expr_stmt|;
block|}
comment|/* create a the appropriate mask to isolate the opcode */
name|opmask
operator|=
name|DEFMASK
expr_stmt|;
name|class
operator|=
name|instruction
operator|&
name|DEFMASK
expr_stmt|;
if|if
condition|(
operator|(
name|class
operator|>=
name|SFU0
operator|)
operator|&&
operator|(
name|class
operator|<=
name|SFU7
operator|)
condition|)
block|{
if|if
condition|(
name|instruction
operator|<
name|SFU1
condition|)
block|{
name|opmask
operator|=
name|CTRLMASK
expr_stmt|;
block|}
else|else
block|{
name|opmask
operator|=
name|SFUMASK
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|RRR
condition|)
block|{
name|opmask
operator|=
name|RRRMASK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|RRI10
condition|)
block|{
name|opmask
operator|=
name|RRI10MASK
expr_stmt|;
block|}
comment|/* isolate the opcode */
name|opcode
operator|=
name|instruction
operator|&
name|opmask
expr_stmt|;
comment|/* search the hash table with the isolated opcode */
for|for
control|(
name|entry_ptr
operator|=
name|hashtable
index|[
name|opcode
operator|%
name|HASHVAL
index|]
init|;
operator|(
name|entry_ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|entry_ptr
operator|->
name|opcode
operator|!=
name|opcode
operator|)
condition|;
name|entry_ptr
operator|=
name|entry_ptr
operator|->
name|next
control|)
block|{     }
if|if
condition|(
name|entry_ptr
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"word\t%08x"
argument_list|,
name|instruction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"%s\t"
argument_list|,
name|entry_ptr
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
name|sprintop
argument_list|(
operator|&
name|outbuf
index|[
name|strlen
argument_list|(
name|outbuf
argument_list|)
index|]
argument_list|,
operator|&
operator|(
name|entry_ptr
operator|->
name|op1
operator|)
argument_list|,
name|instruction
argument_list|,
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintop
argument_list|(
operator|&
name|outbuf
index|[
name|strlen
argument_list|(
name|outbuf
argument_list|)
index|]
argument_list|,
operator|&
operator|(
name|entry_ptr
operator|->
name|op2
operator|)
argument_list|,
name|instruction
argument_list|,
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintop
argument_list|(
operator|&
name|outbuf
index|[
name|strlen
argument_list|(
name|outbuf
argument_list|)
index|]
argument_list|,
operator|&
operator|(
name|entry_ptr
operator|->
name|op3
operator|)
argument_list|,
name|instruction
argument_list|,
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|4
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* *                      Decode an Operand of an Instruction * *			Functional Description * *       This module formats and writes an operand of an instruction to buf *       based on the operand specification.  When the first flag is set this *       is the first operand of an instruction.  Undefined operand types *       cause a<dis error> message. * *			Parameters *	char	*buf		buffer where the operand may be printed *       OPSPEC  *opptr          Pointer to an operand specification *       UINT    inst            Instruction from which operand is extracted *	UINT    pc		PC of instruction; used for pc-relative disp. *       int     first           Flag which if nonzero indicates the first *                               operand of an instruction * *			Output * *       The operand specified is extracted from the instruction and is *       written to buf in the format specified. The operand is preceded *       by a comma if it is not the first operand of an instruction and it *       is not a register indirect form.  Registers are preceded by 'r' and *       hex values by '0x'. * *			Revision History * *       Revision 1.0    11/08/85        Creation date */
end_comment

begin_macro
name|sprintop
argument_list|(
argument|buf
argument_list|,
argument|opptr
argument_list|,
argument|inst
argument_list|,
argument|pc
argument_list|,
argument|first
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OPSPEC
modifier|*
name|opptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|UINT
name|inst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|extracted_field
decl_stmt|;
name|char
modifier|*
name|cond_mask_sym
decl_stmt|;
name|char
name|cond_mask_sym_buf
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|opptr
operator|->
name|width
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|opptr
operator|->
name|type
condition|)
block|{
case|case
name|CRREG
case|:
if|if
condition|(
operator|!
name|first
condition|)
operator|*
name|buf
operator|++
operator|=
literal|','
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cr%d"
argument_list|,
name|UEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
name|opptr
operator|->
name|width
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCRREG
case|:
if|if
condition|(
operator|!
name|first
condition|)
operator|*
name|buf
operator|++
operator|=
literal|','
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"fcr%d"
argument_list|,
name|UEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
name|opptr
operator|->
name|width
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGSC
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[r%d]"
argument_list|,
name|UEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
name|opptr
operator|->
name|width
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
operator|!
name|first
condition|)
operator|*
name|buf
operator|++
operator|=
literal|','
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"r%d"
argument_list|,
name|UEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
name|opptr
operator|->
name|width
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HEX
case|:
if|if
condition|(
operator|!
name|first
condition|)
operator|*
name|buf
operator|++
operator|=
literal|','
expr_stmt|;
name|extracted_field
operator|=
name|UEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
name|opptr
operator|->
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|extracted_field
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%02x"
argument_list|,
name|extracted_field
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONDMASK
case|:
if|if
condition|(
operator|!
name|first
condition|)
operator|*
name|buf
operator|++
operator|=
literal|','
expr_stmt|;
name|extracted_field
operator|=
name|UEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
name|opptr
operator|->
name|width
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|extracted_field
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|0x1
case|:
name|cond_mask_sym
operator|=
literal|"gt0"
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
name|cond_mask_sym
operator|=
literal|"eq0"
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|cond_mask_sym
operator|=
literal|"ge0"
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
name|cond_mask_sym
operator|=
literal|"lt0"
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
name|cond_mask_sym
operator|=
literal|"ne0"
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
name|cond_mask_sym
operator|=
literal|"le0"
expr_stmt|;
break|break;
default|default:
name|cond_mask_sym
operator|=
name|cond_mask_sym_buf
expr_stmt|;
name|sprintf
argument_list|(
name|cond_mask_sym_buf
argument_list|,
literal|"%x"
argument_list|,
name|extracted_field
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|cond_mask_sym
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCREL
case|:
if|if
condition|(
operator|!
name|first
condition|)
operator|*
name|buf
operator|++
operator|=
literal|','
expr_stmt|;
name|sprint_address
argument_list|(
name|pc
operator|+
literal|4
operator|*
operator|(
name|SEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
name|opptr
operator|->
name|width
argument_list|)
operator|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONT
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d,r%d"
argument_list|,
name|UEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
literal|5
argument_list|)
argument_list|,
name|UEXT
argument_list|(
name|inst
argument_list|,
operator|(
name|opptr
operator|->
name|offset
operator|)
operator|+
literal|5
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BF
case|:
if|if
condition|(
operator|!
name|first
condition|)
operator|*
name|buf
operator|++
operator|=
literal|','
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d<%d>"
argument_list|,
name|UEXT
argument_list|(
name|inst
argument_list|,
operator|(
name|opptr
operator|->
name|offset
operator|)
operator|+
literal|5
argument_list|,
literal|5
argument_list|)
argument_list|,
name|UEXT
argument_list|(
name|inst
argument_list|,
name|opptr
operator|->
name|offset
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"<dis error: %08x>"
argument_list|,
name|inst
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* *                 Initialize the Disassembler Instruction Table * *       Initialize the hash table and instruction table for the disassembler. *       This should be called once before the first call to disasm(). * *			Parameters * *			Output * *       If the debug option is selected, certain statistics about the hashing *       distribution are written to stdout. * *			Revision History * *       Revision 1.0    11/08/85        Creation date */
end_comment

begin_macro
name|init_disasm
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHVAL
condition|;
name|i
operator|++
control|)
name|hashtable
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|size
operator|=
sizeof|sizeof
argument_list|(
name|instructions
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|INSTAB
argument_list|)
init|;
name|i
operator|<
name|size
condition|;
name|install
argument_list|(
operator|&
name|instructions
index|[
name|i
operator|++
index|]
argument_list|)
control|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/* *       Insert an instruction into the disassembler table by hashing the *       opcode and inserting it into the linked list for that hash value. * *			Parameters * *       INSTAB *instptr         Pointer to the entry in the instruction table *                               to be installed * *       Revision 1.0    11/08/85        Creation date *			05/11/89	R. TRAWICK ADAPTED FROM MOTOROLA */
end_comment

begin_macro
name|install
argument_list|(
argument|instptr
argument_list|)
end_macro

begin_decl_stmt
name|INSTAB
modifier|*
name|instptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UINT
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|instptr
operator|->
name|opcode
operator|)
operator|%
name|HASHVAL
expr_stmt|;
name|instptr
operator|->
name|next
operator|=
name|hashtable
index|[
name|i
index|]
expr_stmt|;
name|hashtable
index|[
name|i
index|]
operator|=
name|instptr
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* adapted from print_address in printcmd by R. Trawick 5/15/89.  The two should    be combined.  */
end_comment

begin_function
name|void
name|sprint_address
parameter_list|(
name|addr
parameter_list|,
name|buffer
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|symbol
modifier|*
name|fs
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|name_location
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|fs
operator|=
name|find_pc_function
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|==
name|NULL
condition|)
return|return;
comment|/* If nothing comes through, don't 					     print anything symbolic */
name|name
operator|=
name|msymbol
operator|->
name|name
expr_stmt|;
name|name_location
operator|=
name|msymbol
operator|->
name|address
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|fs
operator|->
name|name
expr_stmt|;
name|name_location
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|-
name|name_location
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"<%s+%d>"
argument_list|,
name|name
argument_list|,
name|addr
operator|-
name|name_location
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"<%s>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

