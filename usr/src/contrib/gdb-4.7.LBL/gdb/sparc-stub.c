begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  		THIS SOFTWARE IS NOT COPYRIGHTED     HP offers the following for use in the public domain.  HP makes no    warranty with regard to the software or it's performance and the    user accepts the software "AS IS" with all faults.     HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $  *  *  Module name: remcom.c $  *  Revision: 1.34 $  *  Date: 91/03/09 12:29:49 $  *  Contributor:     Lake Stevens Instrument Division$  *  *  Description:     low level support for gdb debugger. $  *  *  Considerations:  only works on target hardware $  *  *  Written by:      Glenn Engel $  *  ModuleState:     Experimental $  *  *  NOTES:           See Below $  *  *  Modified for SPARC by Stu Grossman, Cygnus Support.  *  *  To enable debugger support, two things need to happen.  One, a  *  call to set_debug_traps() is necessary in order to allow any breakpoints  *  or error conditions to be properly intercepted and reported to gdb.  *  Two, a breakpoint needs to be generated to begin communication.  This  *  is most easily accomplished by a call to breakpoint().  Breakpoint()  *  simulates a breakpoint by executing a trap #1.  *  *************  *  *    The following gdb commands are supported:  *  * command          function                               Return value  *  *    g             return the value of the CPU registers  hex data or ENN  *    G             set the value of the CPU registers     OK or ENN  *  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN  *  *    c             Resume at current address              SNN   ( signal NN)  *    cAA..AA       Continue at address AA..AA             SNN  *  *    s             Step one instruction                   SNN  *    sAA..AA       Step one instruction from AA..AA       SNN  *  *    k             kill  *  *    ?             What was the last sigval ?             SNN   (signal NN)  *  *    bBB..BB	    Set baud rate to BB..BB		   OK or BNN, then sets  *							   baud rate  *  * All commands and responses are sent with a packet which includes a  * checksum.  A packet consists of  *  * $<packet info>#<checksum>.  *  * where  *<packet info> ::<characters representing the command or response>  *<checksum>    ::< two hex digits computed as modulo 256 sum of<packetinfo>>  *  * When a packet is received, it is first acknowledged with either '+' or '-'.  * '+' indicates a successful transfer.  '-' indicates a failed transfer.  *  * Example:  *  * Host:                  Reply:  * $m0,10#2a               +$00010203040506070809101112131415#42  *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_comment
comment|/************************************************************************  *  * external low-level support routines  */
end_comment

begin_extern
extern|extern putDebugChar(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* write a single character      */
end_comment

begin_extern
extern|extern getDebugChar(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* read and return a single char */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
end_comment

begin_comment
comment|/* at least NUMREGBYTES*2 are needed for register packets */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|2048
end_define

begin_decl_stmt
specifier|static
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boolean flag. != 0 means we've been initialized */
end_comment

begin_function_decl
specifier|static
name|void
name|set_mem_fault_trap
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUMREGS
value|72
end_define

begin_comment
comment|/* Number of bytes of registers.  */
end_comment

begin_define
define|#
directive|define
name|NUMREGBYTES
value|(NUMREGS * 4)
end_define

begin_enum
enum|enum
name|regnames
block|{
name|G0
block|,
name|G1
block|,
name|G2
block|,
name|G3
block|,
name|G4
block|,
name|G5
block|,
name|G6
block|,
name|G7
block|,
name|O0
block|,
name|O1
block|,
name|O2
block|,
name|O3
block|,
name|O4
block|,
name|O5
block|,
name|SP
block|,
name|O7
block|,
name|L0
block|,
name|L1
block|,
name|L2
block|,
name|L3
block|,
name|L4
block|,
name|L5
block|,
name|L6
block|,
name|L7
block|,
name|I0
block|,
name|I1
block|,
name|I2
block|,
name|I3
block|,
name|I4
block|,
name|I5
block|,
name|FP
block|,
name|I7
block|,
name|F0
block|,
name|F1
block|,
name|F2
block|,
name|F3
block|,
name|F4
block|,
name|F5
block|,
name|F6
block|,
name|F7
block|,
name|F8
block|,
name|F9
block|,
name|F10
block|,
name|F11
block|,
name|F12
block|,
name|F13
block|,
name|F14
block|,
name|F15
block|,
name|F16
block|,
name|F17
block|,
name|F18
block|,
name|F19
block|,
name|F20
block|,
name|F21
block|,
name|F22
block|,
name|F23
block|,
name|F24
block|,
name|F25
block|,
name|F26
block|,
name|F27
block|,
name|F28
block|,
name|F29
block|,
name|F30
block|,
name|F31
block|,
name|Y
block|,
name|PSR
block|,
name|WIM
block|,
name|TBR
block|,
name|PC
block|,
name|NPC
block|,
name|FPSR
block|,
name|CPSR
block|}
enum|;
end_enum

begin_comment
comment|/***************************  ASSEMBLY CODE MACROS *************************/
end_comment

begin_comment
comment|/* 									   */
end_comment

begin_define
define|#
directive|define
name|BREAKPOINT
parameter_list|()
value|asm("   ta 1");
end_define

begin_function_decl
specifier|extern
name|unsigned
name|long
name|rdtbr
parameter_list|()
function_decl|;
end_function_decl

begin_asm
asm|asm(" 	.text 	.align 4  ! Read the TBR.  	.globl _rdtbr _rdtbr: 	retl 	mov	%tbr, %o0  ! This function is called when any SPARC trap (except window overflow or ! underflow) occurs.  It makes sure that the invalid register window is still ! available before jumping into C code.  It will also restore the world if you ! return from handle_exception.  trap_low: 	mov	%psr, %l0 	mov	%wim, %l3  	srl	%l3, %l0, %l4		! wim>> cwp 	cmp	%l4, 1 	bne	window_fine		! Branch if not in the invalid window 	nop  ! Handle window overflow  	mov	%g1, %l4		! Save g1, we use it to hold the wim 	srl	%l3, 1, %g1		! Rotate wim right 	sll	%l3, 8-1, %l5 	or	%l5, %g1, %g1  	save	%g0, %g0, %g0		! Slip into next window 	mov	%g1, %wim		! Install the new wim  	std	%l0, [%sp + 0 * 4]	! save L& I registers 	std	%l2, [%sp + 2 * 4] 	std	%l4, [%sp + 4 * 4] 	std	%l6, [%sp + 6 * 4]  	std	%i0, [%sp + 8 * 4] 	std	%i2, [%sp + 10 * 4] 	std	%i4, [%sp + 12 * 4] 	std	%i6, [%sp + 14 * 4]  	restore				! Go back to trap window. 	mov	%l4, %g1		! Restore %g1  window_fine: 	sub	%fp, (16+1+6+1+72)*4, %sp ! Make room for input& locals  					! + hidden arg + arg spill 					! + doubleword alignment 					! + registers[72] local var  	std	%g0, [%fp + (-72 + 0) * 4] ! registers[Gx] 	std	%g2, [%fp + (-72 + 2) * 4] 	std	%g4, [%fp + (-72 + 4) * 4] 	std	%g6, [%fp + (-72 + 6) * 4]  	std	%i0, [%fp + (-72 + 8) * 4] ! registers[Ox] 	std	%i2, [%fp + (-72 + 10) * 4] 	std	%i4, [%fp + (-72 + 12) * 4] 	std	%i6, [%fp + (-72 + 14) * 4] 					! F0->F31 not implemented 	mov	%y, %l4 	mov	%tbr, %l5 	st	%l4, [%fp + (-72 + 64) * 4] ! Y 	st	%l0, [%fp + (-72 + 65) * 4] ! PSR 	st	%l3, [%fp + (-72 + 66) * 4] ! WIM 	st	%l5, [%fp + (-72 + 67) * 4] ! TBR 	st	%l1, [%fp + (-72 + 68) * 4] ! PC 	st	%l2, [%fp + (-72 + 69) * 4] ! NPC  					! CPSR and FPSR not impl  	or	%l0, 0xf20, %l4 	mov	%l4, %psr		! Turn on traps, disable interrupts  	call	_handle_exception 	add	%fp, -72 * 4, %o0	! Pass address of registers  	restore				! Ensure that previous window is valid 	save	%g0, %g0, %g0		!  by causing a window_underflow trap  ! Reload all of the registers that aren't on the stack  	ld	[%fp + (-72 + 1) * 4], %g1 ! registers[Gx] 	ldd	[%fp + (-72 + 2) * 4], %g2 	ldd	[%fp + (-72 + 4) * 4], %g4 	ldd	[%fp + (-72 + 6) * 4], %g6  	ldd	[%fp + (-72 + 8) * 4], %o0 ! registers[Ox] 	ldd	[%fp + (-72 + 10) * 4], %o2 	ldd	[%fp + (-72 + 12) * 4], %o4 	ldd	[%fp + (-72 + 14) * 4], %o6  	ldd	[%fp + (-72 + 64) * 4], %l0 ! Y& PSR 	ldd	[%fp + (-72 + 68) * 4], %l2 ! PC& NPC 	mov	%l0, %y 	mov	%l1, %psr		! Make sure that traps are disabled 					! for rett 	jmpl	%l2, %g0		! Restore old PC 	rett	%l3			! Restore old nPC ");
end_asm

begin_comment
comment|/* Convert ch from a hex digit to an int */
end_comment

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|ch
parameter_list|)
name|unsigned
name|char
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* scan for the sequence $<data>#<checksum>     */
end_comment

begin_function
specifier|static
name|void
name|getpacket
parameter_list|(
name|buffer
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|xmitcsum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
do|do
block|{
comment|/* wait around for the start character, ignore all other characters */
while|while
condition|(
operator|(
name|ch
operator|=
name|getDebugChar
argument_list|()
operator|)
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|xmitcsum
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|BUFMAX
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>=
name|BUFMAX
condition|)
continue|continue;
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|xmitcsum
operator|=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|xmitcsum
operator||=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
name|putDebugChar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* failed checksum */
else|else
block|{
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
comment|/* successful transfer */
comment|/* if a sequence char is present, reply the sequence ID */
if|if
condition|(
name|buffer
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* remove sequence chars from buffer */
name|count
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
do|;
block|}
end_function

begin_comment
comment|/* send the packet in buffer.  */
end_comment

begin_function
specifier|static
name|void
name|putpacket
parameter_list|(
name|buffer
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
comment|/*  $<packet info>#<checksum>. */
do|do
block|{
name|putDebugChar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ch
operator|=
name|buffer
index|[
name|count
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|putDebugChar
argument_list|(
name|ch
argument_list|)
condition|)
return|return;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|putDebugChar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|getDebugChar
argument_list|()
operator|!=
literal|'+'
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|remcomInBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|remcomOutBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate to caller of mem2hex or hex2mem that there has been an    error.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|mem_err
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert the memory pointed to by mem into hex, placing result in buf.  * Return a pointer to the last char put in buf (null), in case of mem fault,  * return 0.  * If MAY_FAULT is non-zero, then we will handle memory faults by returning  * a 0, else treat a fault like any other fault in the stub.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|mem
parameter_list|,
name|buf
parameter_list|,
name|count
parameter_list|,
name|may_fault
parameter_list|)
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|may_fault
decl_stmt|;
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
name|set_mem_fault_trap
argument_list|(
name|may_fault
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|ch
operator|=
operator|*
name|mem
operator|++
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
return|return
literal|0
return|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|set_mem_fault_trap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* convert the hex array pointed to by buf into binary to be placed in mem  * return a pointer to the character AFTER the last byte written */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hex2mem
parameter_list|(
name|buf
parameter_list|,
name|mem
parameter_list|,
name|count
parameter_list|,
name|may_fault
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|may_fault
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|set_mem_fault_trap
argument_list|(
name|may_fault
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator||=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
operator|*
name|mem
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
return|return
literal|0
return|;
block|}
name|set_mem_fault_trap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* This table contains the mapping between SPARC hardware trap types, and    signals, which are primarily what GDB understands.  It also indicates    which hardware traps we need to commandeer when initializing the stub. */
end_comment

begin_struct
specifier|static
struct|struct
name|hard_trap_info
block|{
name|unsigned
name|char
name|tt
decl_stmt|;
comment|/* Trap type code for SPARClite */
name|unsigned
name|char
name|signo
decl_stmt|;
comment|/* Signal that we map this trap into */
block|}
name|hard_trap_info
index|[]
init|=
block|{
block|{
literal|1
block|,
name|SIGSEGV
block|}
block|,
comment|/* instruction access error */
block|{
literal|2
block|,
name|SIGILL
block|}
block|,
comment|/* privileged instruction */
block|{
literal|3
block|,
name|SIGILL
block|}
block|,
comment|/* illegal instruction */
block|{
literal|4
block|,
name|SIGEMT
block|}
block|,
comment|/* fp disabled */
block|{
literal|36
block|,
name|SIGEMT
block|}
block|,
comment|/* cp disabled */
block|{
literal|7
block|,
name|SIGBUS
block|}
block|,
comment|/* mem address not aligned */
block|{
literal|9
block|,
name|SIGSEGV
block|}
block|,
comment|/* data access exception */
block|{
literal|10
block|,
name|SIGEMT
block|}
block|,
comment|/* tag overflow */
block|{
literal|128
operator|+
literal|1
block|,
name|SIGTRAP
block|}
block|,
comment|/* ta 1 - normal breakpoint instruction */
block|{
literal|0
block|,
literal|0
block|}
comment|/* Must be last */
block|}
struct|;
end_struct

begin_comment
comment|/* Each entry in the trap vector occupies four words. */
end_comment

begin_struct
struct|struct
name|trap_entry
block|{
name|unsigned
name|long
name|ti
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|trap_entry
name|fltr_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|trap_entry
name|fltr_set_mem_err
decl_stmt|;
end_decl_stmt

begin_asm
asm|asm (" 	.data 	.globl _fltr_proto 	.align 4 _fltr_proto:			! First level trap routine prototype 	sethi %hi(trap_low), %l0 	jmpl %lo(trap_low)+%l0, %g0 	nop 	nop  ! Trap handler for memory errors.  This just sets mem_err to be non-zero.  It ! assumes that %l1 is non-zero.  This should be safe, as it is doubtful that ! 0 would ever contain code that could mem fault.  This routine will skip ! past the faulting instruction after setting mem_err.  _fltr_set_mem_err: 	sethi %hi(_mem_err), %l0 	st %l1, [%l0 + %lo(_mem_err)] 	jmpl %l2, %g0 	rett %l2+4  	.text ");
end_asm

begin_comment
comment|/* Set up exception handlers for tracing and breakpoints */
end_comment

begin_function
name|void
name|set_debug_traps
parameter_list|()
block|{
name|struct
name|trap_entry
modifier|*
name|tb
decl_stmt|;
comment|/* Trap vector base address */
name|struct
name|hard_trap_info
modifier|*
name|ht
decl_stmt|;
name|tb
operator|=
operator|(
expr|struct
name|trap_entry
operator|*
operator|)
operator|(
name|rdtbr
argument_list|()
operator|&
operator|~
literal|0xfff
operator|)
expr_stmt|;
for|for
control|(
name|ht
operator|=
name|hard_trap_info
init|;
name|ht
operator|->
name|tt
operator|&&
name|ht
operator|->
name|signo
condition|;
name|ht
operator|++
control|)
name|tb
index|[
name|ht
operator|->
name|tt
index|]
operator|=
name|fltr_proto
expr_stmt|;
comment|/* In case GDB is started before us, ack any packets (presumably      "$?#xx") sitting there.  */
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mem_fault_trap
parameter_list|(
name|enable
parameter_list|)
name|int
name|enable
decl_stmt|;
block|{
name|struct
name|trap_entry
modifier|*
name|tb
decl_stmt|;
comment|/* Trap vector base address */
name|mem_err
operator|=
literal|0
expr_stmt|;
name|tb
operator|=
operator|(
expr|struct
name|trap_entry
operator|*
operator|)
operator|(
name|rdtbr
argument_list|()
operator|&
operator|~
literal|0xfff
operator|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|tb
index|[
literal|9
index|]
operator|=
name|fltr_set_mem_err
expr_stmt|;
else|else
name|tb
index|[
literal|9
index|]
operator|=
name|fltr_proto
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the SPARC hardware trap type code to a unix signal number. */
end_comment

begin_function
specifier|static
name|int
name|computeSignal
parameter_list|(
name|tt
parameter_list|)
name|int
name|tt
decl_stmt|;
block|{
name|struct
name|hard_trap_info
modifier|*
name|ht
decl_stmt|;
for|for
control|(
name|ht
operator|=
name|hard_trap_info
init|;
name|ht
operator|->
name|tt
operator|&&
name|ht
operator|->
name|signo
condition|;
name|ht
operator|++
control|)
if|if
condition|(
name|ht
operator|->
name|tt
operator|==
name|tt
condition|)
return|return
name|ht
operator|->
name|signo
return|;
return|return
name|SIGHUP
return|;
comment|/* default for things we don't know about */
block|}
end_function

begin_comment
comment|/*  * While we find nice hex chars, build an int.  * Return number of chars processed.  */
end_comment

begin_function
specifier|static
name|int
name|hexToInt
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|intValue
parameter_list|)
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|<
literal|0
condition|)
break|break;
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function does all command procesing for interfacing to gdb.  It  * returns 1 if you should skip the instruction at the trap address, 0  * otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|handle_exception
parameter_list|(
name|registers
parameter_list|)
name|unsigned
name|long
modifier|*
name|registers
decl_stmt|;
block|{
name|int
name|tt
decl_stmt|;
comment|/* Trap type */
name|int
name|sigval
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|long
modifier|*
name|sp
decl_stmt|;
comment|/* First, we must force all of the windows to be spilled out */
asm|asm("	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	restore 	restore 	restore 	restore 	restore 	restore 	restore 	restore ");
name|sp
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|registers
index|[
name|SP
index|]
expr_stmt|;
name|tt
operator|=
operator|(
name|registers
index|[
name|TBR
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* reply to host that an exception has occurred */
name|sigval
operator|=
name|computeSignal
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|PC
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
name|sp
operator|+
literal|8
operator|+
literal|6
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FP */
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sp
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|NPC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|NPC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|NPC
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|O7
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|O7
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|O7
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|getpacket
argument_list|(
name|remcomInBuffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'?'
case|:
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|remcomOutBuffer
index|[
literal|1
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|2
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* toggle debug flag */
break|break;
case|case
literal|'g'
case|:
comment|/* return the value of the CPU registers */
block|{
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
name|ptr
argument_list|,
literal|16
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* G& O regs */
name|ptr
operator|=
name|mem2hex
argument_list|(
name|sp
operator|+
literal|0
argument_list|,
name|ptr
argument_list|,
literal|8
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* L regs */
name|ptr
operator|=
name|mem2hex
argument_list|(
name|sp
operator|+
literal|8
argument_list|,
name|ptr
argument_list|,
literal|8
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* I regs */
name|memset
argument_list|(
name|ptr
argument_list|,
literal|'0'
argument_list|,
literal|32
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* Floating point */
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|Y
index|]
argument_list|,
name|ptr
operator|+
literal|32
operator|*
literal|4
operator|*
literal|2
argument_list|,
literal|8
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Y, PSR, WIM, TBR, PC, NPC, FPSR, CPSR */
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* set the value of the CPU registers - return OK */
block|{
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
literal|16
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* G& O regs */
name|hex2mem
argument_list|(
name|ptr
operator|+
literal|16
operator|*
literal|4
operator|*
literal|2
argument_list|,
name|sp
operator|+
literal|0
argument_list|,
literal|8
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* L regs */
name|hex2mem
argument_list|(
name|ptr
operator|+
literal|24
operator|*
literal|4
operator|*
literal|2
argument_list|,
name|sp
operator|+
literal|8
argument_list|,
literal|8
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* I regs */
name|hex2mem
argument_list|(
name|ptr
operator|+
literal|64
operator|*
literal|4
operator|*
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|Y
index|]
argument_list|,
literal|8
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Y, PSR, WIM, TBR, PC, NPC, FPSR, CPSR */
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
comment|/* Try to read %x,%x.  */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|remcomOutBuffer
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E01"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
comment|/* Try to read '%x,%x:'.  */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E02"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* cAA..AA    Continue at address AA..AA(optional) */
case|case
literal|'s'
case|:
comment|/* sAA..AA   Step one instruction from AA..AA(optional) */
comment|/* try to read optional parameter, pc unchanged if no parm */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|registers
index|[
name|PC
index|]
operator|=
name|addr
expr_stmt|;
name|registers
index|[
name|NPC
index|]
operator|=
name|addr
operator|+
literal|4
expr_stmt|;
block|}
comment|/* Need to flush the instruction cache here, as we may have deposited a    breakpoint, and the icache probably has no way of knowing that a data ref to    some location may have changed something that is in the instruction cache.  */
name|flush_i_cache
argument_list|()
expr_stmt|;
return|return;
comment|/* kill the program */
case|case
literal|'k'
case|:
comment|/* do nothing */
break|break;
if|#
directive|if
literal|0
block|Disabled until we can unscrew this properly  	case 'b':
comment|/* bBB...  Set baud rate to BB... */
block|{ 	    int baudrate; 	    extern void set_timer_3();  	    ptr =&remcomInBuffer[1]; 	    if (!hexToInt(&ptr,&baudrate)) 	      { 		strcpy(remcomOutBuffer,"B01"); 		break; 	      }
comment|/* Convert baud rate to uart clock divider */
block|switch (baudrate) 	      { 	      case 38400: 		baudrate = 16; 		break; 	      case 19200: 		baudrate = 33; 		break; 	      case 9600: 		baudrate = 65; 		break; 	      default: 		strcpy(remcomOutBuffer,"B02"); 		goto x1; 	      }  	    putpacket("OK");
comment|/* Ack before changing speed */
block|set_timer_3(baudrate);
comment|/* Set it */
block|} x1:	  break;
endif|#
directive|endif
block|}
comment|/* switch */
comment|/* reply to the request */
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function will generate a breakpoint exception.  It is used at the    beginning of a program to sync up with a debugger and can be used    otherwise as a quick means to stop program execution and "break" into    the debugger. */
end_comment

begin_function
name|void
name|breakpoint
parameter_list|()
block|{
if|if
condition|(
name|initialized
condition|)
name|BREAKPOINT
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

