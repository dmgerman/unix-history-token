begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Work with executable files, for GDB.     Copyright 1988, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|add_to_section_table
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exec_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|file_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_section_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exec_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Binary File Descriptor handle for the executable file.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|exec_bfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to open exec and core files read-only or read-write.  */
end_comment

begin_decl_stmt
name|int
name|write_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Text start and end addresses (KLUDGE) if needed */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_TEXT_START_END
end_ifdef

begin_decl_stmt
name|CORE_ADDR
name|text_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|text_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward decl */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|exec_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|exec_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|bfd_close
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|exec_bfd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|exec_ops
operator|.
name|to_sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|exec_ops
operator|.
name|to_sections
argument_list|)
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|exec_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Process the first arg in ARGS as the new exec file.      Note that we have to explicitly ignore additional args, since we can     be called from file_command(), which also calls symbol_file_command()     which can take multiple args. */
end_comment

begin_function
name|void
name|exec_file_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Remove any previous exec file.  */
name|unpush_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|args
condition|)
block|{
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
comment|/* Scan through the args and pick up the first non option arg 	 as the filename. */
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|argv
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
operator|)
condition|;
name|argv
operator|++
control|)
block|{
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"no exec file name was specified"
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|write_files
condition|?
name|O_RDWR
operator||
name|O_BINARY
else|:
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exec_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|NULL
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exec_bfd
condition|)
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|exec_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_section_table
argument_list|(
name|exec_bfd
argument_list|,
operator|&
name|exec_ops
operator|.
name|to_sections
argument_list|,
operator|&
name|exec_ops
operator|.
name|to_sections_end
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|exec_bfd
operator|->
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_TEXT_START_END
comment|/* This is a KLUDGE (FIXME) because a few places in a few ports 	 (29K springs to mind) need this info for now.  */
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|exec_ops
operator|.
name|to_sections
init|;
name|p
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|".text"
argument_list|,
name|bfd_section_name
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|)
argument_list|)
condition|)
block|{
name|text_start
operator|=
name|p
operator|->
name|addr
expr_stmt|;
name|text_end
operator|=
name|p
operator|->
name|endaddr
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|validate_files
argument_list|()
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
comment|/* Kludge to set kernel debugging for "vmunix" exec file. 	 It's easy to forget -k. */
if|if
condition|(
operator|!
name|kernel_debugging
operator|&&
name|is_a_vmunix
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|kernel_debugging
operator|=
literal|1
expr_stmt|;
name|set_prompt
argument_list|(
literal|"(kgdb) "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set both the exec file and the symbol file, in one command.      What a novelty.  Why did GDB go through four major releases before this    command was added?  */
end_comment

begin_function
specifier|static
name|void
name|file_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* FIXME, if we lose on reading the symbol file, we should revert      the exec file, but that's rough.  */
name|exec_file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Locate all mappable sections of a BFD file.     table_pp_char is a char * to get it through bfd_map_over_sections;    we cast it back to its proper type.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_section_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|table_pp_char
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|PTR
name|table_pp_char
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
modifier|*
name|table_pp
init|=
operator|(
expr|struct
name|section_table
operator|*
operator|*
operator|)
name|table_pp_char
decl_stmt|;
name|flagword
name|aflag
decl_stmt|;
name|aflag
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
comment|/* FIXME, we need to handle BSS segment here...it alloc's but doesn't load */
if|if
condition|(
operator|!
operator|(
name|aflag
operator|&
name|SEC_LOAD
operator|)
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
condition|)
return|return;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|sec_ptr
operator|=
name|asect
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|addr
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|endaddr
operator|=
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|addr
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Builds a section table, given args BFD, SECTABLE_PTR, SECEND_PTR.    Returns 0 if OK, 1 on error.  */
end_comment

begin_function
name|int
name|build_section_table
parameter_list|(
name|some_bfd
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|bfd
modifier|*
name|some_bfd
decl_stmt|;
name|struct
name|section_table
modifier|*
modifier|*
name|start
decl_stmt|,
decl|*
modifier|*
name|end
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|count
decl_stmt|;
name|count
operator|=
name|bfd_count_sections
argument_list|(
name|some_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|start
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
operator|*
name|start
argument_list|)
expr_stmt|;
operator|*
name|start
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
operator|*
name|start
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|some_bfd
argument_list|,
name|add_to_section_table
argument_list|,
operator|(
name|char
operator|*
operator|)
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|>
operator|*
name|start
operator|+
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We could realloc the table, but it probably loses for most files.  */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read or write the exec file.     Args are address within a BFD file, address within gdb address-space,    length, and a flag indicating whether to read or write.     Result is a length:  	0:    We cannot handle this address and length.> 0:  We have handled N bytes starting at this address. 	      (If N == length, we did it all.)  We might be able 	      to handle more bytes beyond this length, but no 	      promises.< 0:  We cannot handle this address, but if somebody 	      else handles (-N) bytes, we can start from there.      The same routine is used to handle both core and exec files;     we just tail-call it with more arguments to select between them.  */
end_comment

begin_function
name|int
name|xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|boolean
name|res
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|nextsectaddr
decl_stmt|,
name|memend
decl_stmt|;
name|boolean
argument_list|(
argument|*xfer_fn
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memend
operator|=
name|memaddr
operator|+
name|len
expr_stmt|;
name|xfer_fn
operator|=
name|write
condition|?
name|bfd_set_section_contents
else|:
name|bfd_get_section_contents
expr_stmt|;
name|nextsectaddr
operator|=
name|memend
expr_stmt|;
for|for
control|(
name|p
operator|=
name|target
operator|->
name|to_sections
init|;
name|p
operator|<
name|target
operator|->
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|addr
operator|<=
name|memaddr
condition|)
if|if
condition|(
name|p
operator|->
name|endaddr
operator|>=
name|memend
condition|)
block|{
comment|/* Entire transfer is within this section.  */
name|res
operator|=
name|xfer_fn
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|,
name|myaddr
argument_list|,
name|memaddr
operator|-
name|p
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
name|false
operator|)
condition|?
name|len
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|endaddr
operator|<=
name|memaddr
condition|)
block|{
comment|/* This section ends before the transfer starts.  */
continue|continue;
block|}
else|else
block|{
comment|/* This section overlaps the transfer.  Just do half.  */
name|len
operator|=
name|p
operator|->
name|endaddr
operator|-
name|memaddr
expr_stmt|;
name|res
operator|=
name|xfer_fn
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|,
name|myaddr
argument_list|,
name|memaddr
operator|-
name|p
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
name|false
operator|)
condition|?
name|len
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|addr
operator|<
name|nextsectaddr
condition|)
name|nextsectaddr
operator|=
name|p
operator|->
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|nextsectaddr
operator|>=
name|memend
condition|)
return|return
literal|0
return|;
comment|/* We can't help */
else|else
return|return
operator|-
operator|(
name|nextsectaddr
operator|-
name|memaddr
operator|)
return|;
comment|/* Next boundary where we can help */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FIXME
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|REG_STACK_SEGMENT
end_ifdef

begin_comment
comment|/* MOVE TO BFD... */
end_comment

begin_comment
comment|/* Pyramids and AM29000s have an extra segment in the virtual address space        for the (control) stack of register-window frames.  The AM29000 folk        call it the "register stack" rather than the "memory stack".  */
end_comment

begin_elseif
elseif|else
if|if
condition|(
name|memaddr
operator|>=
name|reg_stack_start
operator|&&
name|memaddr
operator|<
name|reg_stack_end
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|reg_stack_end
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|memaddr
operator|-
name|reg_stack_start
operator|+
name|reg_stack_offset
expr_stmt|;
name|wanna_xfer
operator|=
name|coredata
expr_stmt|;
block|}
end_elseif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REG_STACK_SEGMENT */
end_comment

begin_endif
endif|#
directive|endif
endif|FIXME
end_endif

begin_escape
end_escape

begin_function
name|void
name|print_section_info
parameter_list|(
name|t
parameter_list|,
name|abfd
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\t`%s', "
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"file type %s.\n"
argument_list|,
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|t
operator|->
name|to_sections
init|;
name|p
operator|<
name|t
operator|->
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|p
operator|->
name|addr
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" - %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|p
operator|->
name|endaddr
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|" @ %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|p
operator|->
name|sec_ptr
operator|->
name|filepos
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is %s"
argument_list|,
name|bfd_section_name
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bfd
operator|!=
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" in %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|p
operator|->
name|bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|get_exec_file_name
parameter_list|()
block|{
if|if
condition|(
name|exec_bfd
operator|!=
literal|0
condition|)
return|return
operator|(
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exec_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|print_section_info
argument_list|(
name|t
argument_list|,
name|exec_bfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_section_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|unsigned
name|seclen
decl_stmt|;
name|unsigned
name|long
name|secaddr
decl_stmt|;
name|char
name|secprint
index|[
literal|100
index|]
decl_stmt|;
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Must specify section name and its virtual address"
argument_list|)
expr_stmt|;
comment|/* Parse out section name */
for|for
control|(
name|secname
operator|=
name|args
init|;
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|;
name|args
operator|++
control|)
empty_stmt|;
name|seclen
operator|=
name|args
operator|-
name|secname
expr_stmt|;
comment|/* Parse out new virtual address */
name|secaddr
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_ops
operator|.
name|to_sections
init|;
name|p
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|secname
argument_list|,
name|bfd_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|)
argument_list|,
name|seclen
argument_list|)
operator|&&
name|bfd_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|)
index|[
name|seclen
index|]
operator|==
literal|'\0'
condition|)
block|{
name|offset
operator|=
name|secaddr
operator|-
name|p
operator|->
name|addr
expr_stmt|;
name|p
operator|->
name|addr
operator|+=
name|offset
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|exec_files_info
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|seclen
operator|>=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
condition|)
name|seclen
operator|=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|secprint
argument_list|,
name|secname
argument_list|,
name|seclen
argument_list|)
expr_stmt|;
name|secprint
index|[
name|seclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"Section %s not found"
argument_list|,
name|secprint
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_ops
name|exec_ops
init|=
block|{
literal|"exec"
block|,
literal|"Local exec file"
block|,
literal|"Use an executable file as a target.\n\ Specify the filename of the executable file."
block|,
name|exec_file_command
block|,
name|exec_close
block|,
comment|/* open, close */
name|find_default_attach
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* attach, detach, resume, wait, */
literal|0
block|,
literal|0
block|,
comment|/* fetch_registers, store_registers, */
literal|0
block|,
comment|/* prepare_to_store, */
name|xfer_memory
block|,
name|exec_files_info
block|,
literal|0
block|,
literal|0
block|,
comment|/* insert_breakpoint, remove_breakpoint, */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* terminal stuff */
literal|0
block|,
literal|0
block|,
comment|/* kill, load */
literal|0
block|,
comment|/* lookup sym */
name|find_default_create_inferior
block|,
literal|0
block|,
comment|/* mourn_inferior */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|file_stratum
block|,
literal|0
block|,
comment|/* next */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_exec
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"file"
argument_list|,
name|class_files
argument_list|,
name|file_command
argument_list|,
literal|"Use FILE as program to be debugged.\n\ It is read for its symbols, for getting the contents of pure memory,\n\ and it is the program executed when you use the `run' command.\n\ If FILE cannot be found as specified, your execution directory path\n\ ($PATH) is searched for a command of that name.\n\ No arg means to have no executable file and no symbols."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"exec-file"
argument_list|,
name|class_files
argument_list|,
name|exec_file_command
argument_list|,
literal|"Use FILE as program for getting contents of pure memory.\n\ If FILE cannot be found as specified, your execution directory path\n\ is searched for a command of that name.\n\ No arg means have no executable file."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"section"
argument_list|,
name|class_files
argument_list|,
name|set_section_command
argument_list|,
literal|"Change the base address of section SECTION of the exec file to ADDR.\n\ This can be used if the exec file does not contain section addresses,\n\ (such as in the a.out format), or when the addresses specified in the\n\ file itself are wrong.  Each section must be changed separately.  The\n\ ``info files'' command lists all the sections and their addresses."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"write"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|write_files
argument_list|,
literal|"Set writing into executable and core files."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

