begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	BSDI $Id: i386bsd-tdep.c,v 1.1.1.1 1992/08/27 17:03:50 trent Exp $	*/
end_comment

begin_comment
comment|/*  * Machine-dependent kernel debugging support for BSD/386.  * Mainly taken from sparcbsd-tdep.c from LBL.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VM_MAXUSER_ADDRESS
value|0xfdbfe000
end_define

begin_decl_stmt
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the "thing" at address 'addr' into the space pointed to by P.  * The length of the "thing" is determined by the type of P.  * Result is non-zero if transfer fails.  */
end_comment

begin_define
define|#
directive|define
name|READMEM
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
define|\
value|(target_read_memory((CORE_ADDR)(addr), (char *)(p), sizeof(*(p))))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/*  * Return the address of the saved pc in frame.  */
end_comment

begin_function
name|CORE_ADDR
name|addr_of_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KERNELDEBUG
specifier|static
name|CORE_ADDR
name|tstart
decl_stmt|,
name|tend
decl_stmt|,
name|istart
decl_stmt|,
name|iend
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|unsigned
name|long
name|addr
decl_stmt|;
if|if
condition|(
name|kernel_debugging
operator|&&
name|frame
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|tstart
operator|==
literal|0
condition|)
block|{
name|tstart
operator|=
name|ksym_lookup
argument_list|(
literal|"Xdiv"
argument_list|)
expr_stmt|;
name|tend
operator|=
name|ksym_lookup
argument_list|(
literal|"Xsyscall"
argument_list|)
expr_stmt|;
name|istart
operator|=
name|ksym_lookup
argument_list|(
literal|"Vclk"
argument_list|)
expr_stmt|;
name|iend
operator|=
name|ksym_lookup
argument_list|(
literal|"doreti"
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|frame
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstart
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|tend
condition|)
block|{
name|struct
name|trapframe
modifier|*
name|tfr
init|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
operator|(
name|frame
operator|->
name|next
operator|->
name|frame
operator|+
literal|8
operator|)
decl_stmt|;
return|return
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|&
name|tfr
operator|->
name|tf_eip
operator|)
return|;
block|}
if|if
condition|(
name|istart
operator|<=
name|pc
operator|&&
name|pc
operator|<
name|iend
condition|)
block|{
name|struct
name|intrframe
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|intrframe
operator|*
operator|)
operator|(
name|frame
operator|->
name|next
operator|->
name|frame
operator|+
literal|8
operator|)
decl_stmt|;
return|return
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|&
name|ifr
operator|->
name|if_eip
operator|)
return|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|frame
operator|->
name|next
operator|->
name|frame
operator|+
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_comment
comment|/*  * The code below implements kernel debugging of crashdumps (or /dev/kmem)  * or remote systems (via a serial link).  For remote kernels, the remote  * context does most the work, so there is very little to do -- we just  * manage the kernel stack boundaries so we know where to stop a backtrace.  *  * The crashdump/kmem (kvm) support is a bit more grungy, but thanks to  * libkvm (see kcore.c) not too bad.  The main work is kvm_fetch_registers  * which sucks the register state out of the current processes pcb.  * There is a command that let's you set the current process -- hopefully,  * to something that's blocked (in the live kernel case).  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kernstack_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kernstack_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcb
modifier|*
name|cpcb
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|set_curproc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Return true if ADDR is a valid stack address according to the  * current boundaries (which are determined by the currently running   * user process).  */
end_comment

begin_function
name|int
name|inside_kernstack
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|cpcb
operator|==
literal|0
condition|)
name|set_curproc
argument_list|()
expr_stmt|;
return|return
operator|(
name|addr
operator|>
name|kernstack_bottom
operator|&&
name|addr
operator|<
name|kernstack_top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (re-)set the variables that make inside_kernstack() work.  */
end_comment

begin_function
specifier|static
name|void
name|set_kernel_boundaries
parameter_list|(
name|struct
name|pcb
modifier|*
name|p
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* fix this when we no longer map PCBs to a fixed address */
block|CORE_ADDR a = (CORE_ADDR)p;
else|#
directive|else
name|CORE_ADDR
name|a
init|=
operator|(
name|CORE_ADDR
operator|)
name|VM_MAXUSER_ADDRESS
decl_stmt|;
endif|#
directive|endif
name|kernstack_bottom
operator|=
name|a
expr_stmt|;
name|kernstack_top
operator|=
name|a
operator|+
name|UPAGES
operator|*
name|NBPG
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the current proc.  masterprocp points to  * current proc which points to current u area.  */
end_comment

begin_function
specifier|static
name|struct
name|pcb
modifier|*
name|fetch_cpcb
parameter_list|()
block|{
name|struct
name|pcb
modifier|*
name|p
decl_stmt|;
specifier|static
name|CORE_ADDR
name|curpcb_addr
decl_stmt|;
if|if
condition|(
operator|!
name|curpcb_addr
condition|)
name|curpcb_addr
operator|=
name|ksym_lookup
argument_list|(
literal|"curpcb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|READMEM
argument_list|(
name|curpcb_addr
argument_list|,
operator|&
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read curpcb pointer at 0x%x\n"
argument_list|,
name|curpcb_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * All code below is exclusively for support of kernel core files.  */
end_comment

begin_comment
comment|/*  * Fetch registers from a crashdump or /dev/kmem.  */
end_comment

begin_function
specifier|static
name|void
name|kvm_fetch_registers
parameter_list|(
name|p
parameter_list|)
name|struct
name|pcb
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|pcb
name|pcb
decl_stmt|;
comment|/* find the pcb for the current process */
if|if
condition|(
name|READMEM
argument_list|(
name|p
argument_list|,
operator|&
name|pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at 0x%x"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/*          * Invalidate all the registers then fill in the ones we know about.          */
name|registers_changed
argument_list|()
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_pc
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_fp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_ksp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_psl
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_eax
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_ecx
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_edx
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|3
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_ebx
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_esi
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|7
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_edi
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|10
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_cs
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|11
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_ss
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|12
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_ds
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|13
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_es
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|14
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_fs
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|15
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_tss
operator|.
name|tss_gs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from remote_wait, after the remote kernel has stopped.  * Look up the current proc, and set up boundaries.  * This is for active kernels only.  */
end_comment

begin_function
name|void
name|set_curproc
parameter_list|()
block|{
name|cpcb
operator|=
name|fetch_cpcb
argument_list|()
expr_stmt|;
name|set_kernel_boundaries
argument_list|(
name|cpcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the process context to that of the proc structure at  * system address paddr.  Read in the register state.  */
end_comment

begin_function
name|int
name|set_procaddr
parameter_list|(
name|CORE_ADDR
name|paddr
parameter_list|)
block|{
name|struct
name|pcb
modifier|*
name|ppcb
decl_stmt|;
if|if
condition|(
name|paddr
operator|==
literal|0
condition|)
name|cpcb
operator|=
name|fetch_cpcb
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|paddr
operator|!=
operator|(
name|CORE_ADDR
operator|)
name|cpcb
condition|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|paddr
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|p
operator|<
name|KERNBASE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|READMEM
argument_list|(
operator|&
name|p
operator|->
name|p_addr
argument_list|,
operator|&
name|ppcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read p_addr at 0x%x"
argument_list|,
operator|&
name|p
operator|->
name|p_addr
argument_list|)
expr_stmt|;
name|cpcb
operator|=
name|ppcb
expr_stmt|;
block|}
name|set_kernel_boundaries
argument_list|(
name|cpcb
argument_list|)
expr_stmt|;
name|kvm_fetch_registers
argument_list|(
name|cpcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the registers out of a crashdump or /dev/kmem.  * XXX This somehow belongs in kcore.c.  *  * We just get all the registers, so we don't use regno.  */
end_comment

begin_function
name|void
name|kernel_core_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/*          * Need to find current u area to get kernel stack and pcb          * where "panic" saved registers.          * (libkvm also needs to know current u area to get user          * address space mapping). 	 */
operator|(
name|void
operator|)
name|set_procaddr
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|cpcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

