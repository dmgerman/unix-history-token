begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !MAC */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MSDOS */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MAC */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RAINBOW
end_ifdef

begin_decl_stmt
name|private
name|int
name|rbwrite
name|proto
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|L_SET
end_ifndef

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXFILES
value|20
end_define

begin_comment
comment|/* good enough for my purposes */
end_comment

begin_decl_stmt
name|private
name|File
name|openfiles
index|[
name|MAXFILES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* must be zeroed initially */
end_comment

begin_function
name|File
modifier|*
name|fd_open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|buf_size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|fd
decl_stmt|,
name|buf_size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|openfiles
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXFILES
condition|;
name|i
operator|++
operator|,
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXFILES
condition|)
name|complain
argument_list|(
literal|"[Too many open files!]"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_bufsize
operator|=
name|buf_size
expr_stmt|;
name|fp
operator|->
name|f_cnt
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_fd
operator|=
name|fd
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|buffer
operator|=
name|emalloc
argument_list|(
operator|(
name|size_t
operator|)
name|buf_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_MYBUF
expr_stmt|;
block|}
name|fp
operator|->
name|f_base
operator|=
name|fp
operator|->
name|f_ptr
operator|=
name|buffer
expr_stmt|;
name|fp
operator|->
name|f_name
operator|=
name|copystr
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_block

begin_function
name|void
name|gc_openfiles
parameter_list|()
block|{
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|openfiles
init|;
name|fp
operator|<
operator|&
name|openfiles
index|[
name|MAXFILES
index|]
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|!=
literal|0
operator|&&
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|F_LOCKED
operator|)
operator|==
literal|0
condition|)
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|File
modifier|*
name|f_open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|buffer
parameter_list|,
name|buf_size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|buf_size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
switch|switch
condition|(
name|F_MODE
argument_list|(
name|flags
argument_list|)
condition|)
block|{
case|case
name|F_READ
case|:
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_APPEND
case|:
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|F_WRITE
case|:
name|fd
operator|=
name|creat
argument_list|(
name|name
argument_list|,
name|CreatMode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"invalid F_MODE"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|MSDOS
name|setmode
argument_list|(
name|fd
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
return|return
name|fd_open
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|buffer
argument_list|,
name|buf_size
argument_list|)
return|;
block|}
end_block

begin_function
name|void
name|f_close
parameter_list|(
name|fp
parameter_list|)
name|File
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_WRITE
operator||
name|F_APPEND
operator|)
condition|)
block|{
name|flushout
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_MYBUF
condition|)
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|fp
operator|->
name|f_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|fp
operator|->
name|f_name
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* indicates that we're available */
block|}
end_function

begin_function
name|int
name|filbuf
parameter_list|(
name|fp
parameter_list|)
name|File
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_EOF
operator||
name|F_ERR
operator|)
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|f_ptr
operator|=
name|fp
operator|->
name|f_base
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
do|do
block|{
endif|#
directive|endif
comment|/* MSDOS */
name|fp
operator|->
name|f_cnt
operator|=
name|read
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
operator|(
name|UnivPtr
operator|)
name|fp
operator|->
name|f_base
argument_list|,
operator|(
name|size_t
operator|)
name|fp
operator|->
name|f_bufsize
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
block|}
do|while
condition|(
name|fp
operator|->
name|f_cnt
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
name|fp
operator|->
name|f_cnt
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* I/O error -- treat as EOF */
name|writef
argument_list|(
literal|"[Read error: %s]"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_ERR
operator||
name|F_EOF
expr_stmt|;
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_cnt
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|f_flags
operator||=
name|F_EOF
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|io_chars
operator|+=
name|fp
operator|->
name|f_cnt
expr_stmt|;
return|return
name|jgetc
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|putstr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|IBMPC
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|jputchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|write_emif
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
end_function

begin_function
name|void
name|fputnchar
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|jputc
argument_list|(
operator|*
name|s
operator|++
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|flushscreen
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|IBMPC
name|flushout
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
end_function

begin_function
name|void
name|f_seek
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_WRITE
operator||
name|F_APPEND
operator|)
condition|)
name|flushout
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_cnt
operator|=
literal|0
expr_stmt|;
comment|/* next read will filbuf(), next write 				   will flush() with no bad effects */
name|lseek
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|flushout
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_READ
operator||
name|F_STRING
operator||
name|F_ERR
operator|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|!=
name|F_STRING
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* IMPOSSIBLE */
comment|/* We just banged into the end of a string. 		 * In the interests of continuing, we will cause 		 * the rest of the output to be be heaped in the 		 * last position.  Surely it will end up as a NUL. UGH! 		 */
name|fp
operator|->
name|f_cnt
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|f_ptr
operator|=
operator|&
name|fp
operator|->
name|f_base
index|[
name|fp
operator|->
name|f_bufsize
operator|-
literal|1
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|n
operator|=
operator|(
name|fp
operator|->
name|f_ptr
operator|-
name|fp
operator|->
name|f_base
operator|)
operator|)
operator|>
literal|0
operator|)
operator|&&
ifndef|#
directive|ifndef
name|RAINBOW
operator|(
name|write
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
operator|(
name|UnivPtr
operator|)
name|fp
operator|->
name|f_base
argument_list|,
operator|(
name|size_t
operator|)
name|n
argument_list|)
operator|!=
name|n
operator|)
operator|&&
else|#
directive|else
operator|(
name|rbwrite
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
name|fp
operator|->
name|f_base
argument_list|,
name|n
argument_list|)
operator|!=
name|n
operator|)
operator|&&
endif|#
directive|endif
operator|(
name|fp
operator|!=
name|stdout
operator|)
condition|)
block|{
name|fp
operator|->
name|f_flags
operator||=
name|F_ERR
expr_stmt|;
name|error
argument_list|(
literal|"[I/O error(%s); file = %s, fd = %d]"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|fp
operator|->
name|f_name
argument_list|,
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|f_cnt
operator|=
name|fp
operator|->
name|f_bufsize
expr_stmt|;
name|fp
operator|->
name|f_ptr
operator|=
name|fp
operator|->
name|f_base
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|f_gets
parameter_list|(
name|fp
parameter_list|,
name|buf
parameter_list|,
name|max
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|max
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|endp
init|=
name|buf
operator|+
name|max
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_EOF
condition|)
return|return
name|YES
return|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|jgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* We can't store NUL in our buffer, so ignore it. 			 * Of course, with a little ingenuity we could: 			 * NUL could be represented by \n! 			 */
continue|continue;
block|}
if|if
condition|(
name|cp
operator|>=
name|endp
condition|)
block|{
name|add_mess
argument_list|(
literal|" [Line too long]"
argument_list|)
expr_stmt|;
name|rbell
argument_list|()
expr_stmt|;
return|return
name|YES
return|;
block|}
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
name|add_mess
argument_list|(
literal|" [Incomplete last line]"
argument_list|)
expr_stmt|;
return|return
name|YES
return|;
block|}
ifdef|#
directive|ifdef
name|MSDOS
comment|/* a CR followed by a LF is treated as a NL. 	 * Bug: the line-buffer is effectively shortened by one character. 	 */
if|if
condition|(
name|cp
operator|!=
name|buf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|io_lines
operator|+=
literal|1
expr_stmt|;
return|return
name|NO
return|;
comment|/* this means okay */
block|}
end_function

begin_comment
comment|/* skip to beginning of next line, i.e., next read returns first    character of new line */
end_comment

begin_function
name|void
name|f_toNL
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_EOF
condition|)
return|return;
do|do
empty_stmt|;
do|while
condition|(
operator|(
operator|(
name|c
operator|=
name|jgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fp
operator|->
name|f_flags
operator||=
name|F_EOF
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|f_readn
parameter_list|(
name|fp
parameter_list|,
name|addr
parameter_list|,
name|n
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
specifier|register
name|size_t
name|nleft
decl_stmt|;
for|for
control|(
name|nleft
operator|=
name|n
init|;
name|nleft
operator|>
literal|0
condition|;
name|nleft
operator|--
control|)
block|{
name|int
name|c
init|=
name|jgetc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|f_eof
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
operator|*
name|addr
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
name|n
operator|-
name|nleft
return|;
block|}
end_function

begin_comment
comment|/* Deals with output to the terminal, setting up the amount of characters    to be buffered depending on the output baud rate.  Why it's in a    separate file I don't know ... */
end_comment

begin_decl_stmt
name|private
name|char
name|one_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|BufSize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|File
name|stdout_File
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|F_WRITE
block|,
operator|&
name|one_buf
block|,
operator|&
name|one_buf
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|File
modifier|*
name|stdout
init|=
operator|&
name|stdout_File
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RAINBOW
end_ifdef

begin_comment
comment|/*  * use the Rainbow's video output function  */
end_comment

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_function
name|private
name|int
name|rbwrite
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|union
name|REGS
name|vr
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
literal|1
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
block|{
name|vr
operator|.
name|x
operator|.
name|ax
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|di
operator|=
literal|0
expr_stmt|;
name|int86
argument_list|(
literal|0x18
argument_list|,
operator|&
name|vr
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAINBOW */
end_comment

end_unit

