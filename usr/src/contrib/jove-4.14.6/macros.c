begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_decl_stmt
name|private
name|void
name|pop_macro_stack
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SAVE
value|01
end_define

begin_comment
comment|/* this macro needs saving to a file */
end_comment

begin_decl_stmt
name|struct
name|macro
modifier|*
name|macros
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* macros */
end_comment

begin_decl_stmt
name|bool
name|InMacDefine
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|add_mac
parameter_list|(
name|new
parameter_list|)
name|struct
name|macro
modifier|*
name|new
decl_stmt|;
block|{
specifier|register
name|struct
name|macro
modifier|*
name|mp
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|macros
init|;
name|mp
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|mp
operator|,
name|mp
operator|=
name|mp
operator|->
name|m_nextm
control|)
if|if
condition|(
name|mp
operator|==
name|new
condition|)
return|return;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|m_nextm
operator|=
name|new
expr_stmt|;
else|else
name|macros
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|m_nextm
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|Type
operator|=
name|MACRO
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|del_mac
parameter_list|(
name|mac
parameter_list|)
name|struct
name|macro
modifier|*
name|mac
decl_stmt|;
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|macros
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
if|if
condition|(
name|m
operator|->
name|m_nextm
operator|==
name|mac
condition|)
block|{
name|m
operator|->
name|m_nextm
operator|=
name|mac
operator|->
name|m_nextm
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|mac
operator|->
name|Name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|mac
operator|->
name|m_body
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|mac
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|struct
name|macro
name|KeyMacro
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro used for defining */
end_comment

begin_comment
comment|/* To execute a macro, we have a "stack" of running macros.  Whenever    we execute a macro, we push it on the stack, run it, then pop it    from the stack.  */
end_comment

begin_struct
struct|struct
name|m_thread
block|{
name|struct
name|m_thread
modifier|*
name|mt_prev
decl_stmt|;
name|struct
name|macro
modifier|*
name|mt_mp
decl_stmt|;
name|int
name|mt_offset
decl_stmt|,
name|mt_count
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|struct
name|m_thread
modifier|*
name|mac_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|struct
name|m_thread
modifier|*
name|alloc_mthread
parameter_list|()
block|{
return|return
operator|(
expr|struct
name|m_thread
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|m_thread
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|free_mthread
parameter_list|(
name|t
parameter_list|)
name|struct
name|m_thread
modifier|*
name|t
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unwind_macro_stack
parameter_list|()
block|{
while|while
condition|(
name|mac_stack
operator|!=
name|NULL
condition|)
name|pop_macro_stack
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|pop_macro_stack
parameter_list|()
block|{
specifier|register
name|struct
name|m_thread
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|mac_stack
operator|)
operator|==
name|NULL
condition|)
return|return;
name|mac_stack
operator|=
name|m
operator|->
name|mt_prev
expr_stmt|;
name|free_mthread
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|push_macro_stack
parameter_list|(
name|m
parameter_list|,
name|count
parameter_list|)
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|struct
name|m_thread
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|mac_stack
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|mt_prev
control|)
if|if
condition|(
name|t
operator|->
name|mt_mp
operator|==
name|m
condition|)
name|complain
argument_list|(
literal|"[Cannot execute macro recusively]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|complain
argument_list|(
literal|"[Cannot execute macro a negative number of times]"
argument_list|)
expr_stmt|;
name|t
operator|=
name|alloc_mthread
argument_list|()
expr_stmt|;
name|t
operator|->
name|mt_prev
operator|=
name|mac_stack
expr_stmt|;
name|mac_stack
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|mt_offset
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|mt_mp
operator|=
name|m
expr_stmt|;
name|t
operator|->
name|mt_count
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_macro
parameter_list|(
name|mac
parameter_list|)
name|struct
name|macro
modifier|*
name|mac
decl_stmt|;
block|{
name|push_macro_stack
argument_list|(
name|mac
argument_list|,
name|arg_value
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|struct
name|macro
modifier|*
name|mac_exists
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|macro
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|macros
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_nextm
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|mp
operator|->
name|Name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|mac_init
parameter_list|()
block|{
name|add_mac
argument_list|(
operator|&
name|KeyMacro
argument_list|)
expr_stmt|;
name|KeyMacro
operator|.
name|Name
operator|=
literal|"keyboard-macro"
expr_stmt|;
name|KeyMacro
operator|.
name|m_len
operator|=
literal|0
expr_stmt|;
name|KeyMacro
operator|.
name|m_buflen
operator|=
literal|16
expr_stmt|;
name|KeyMacro
operator|.
name|m_body
operator|=
name|emalloc
argument_list|(
operator|(
name|size_t
operator|)
name|KeyMacro
operator|.
name|m_buflen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mac_putc
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|KeyMacro
operator|.
name|m_len
operator|>=
name|KeyMacro
operator|.
name|m_buflen
condition|)
block|{
name|KeyMacro
operator|.
name|m_buflen
operator|+=
literal|16
expr_stmt|;
name|KeyMacro
operator|.
name|m_body
operator|=
name|realloc
argument_list|(
operator|(
name|UnivPtr
operator|)
name|KeyMacro
operator|.
name|m_body
argument_list|,
operator|(
name|size_t
operator|)
name|KeyMacro
operator|.
name|m_buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|KeyMacro
operator|.
name|m_body
operator|==
name|NULL
condition|)
block|{
name|KeyMacro
operator|.
name|m_buflen
operator|=
name|KeyMacro
operator|.
name|m_len
operator|=
literal|0
expr_stmt|;
name|complain
argument_list|(
literal|"[Can't allocate storage for keyboard macro]"
argument_list|)
expr_stmt|;
block|}
block|}
name|KeyMacro
operator|.
name|m_body
index|[
name|KeyMacro
operator|.
name|m_len
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
name|int
name|in_macro
parameter_list|()
block|{
return|return
operator|(
name|mac_stack
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mac_getc
parameter_list|()
block|{
name|struct
name|m_thread
modifier|*
name|mthread
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|mthread
operator|=
name|mac_stack
operator|)
operator|==
name|NULL
condition|)
return|return
name|EOF
return|;
name|m
operator|=
name|mthread
operator|->
name|mt_mp
expr_stmt|;
if|if
condition|(
name|mthread
operator|->
name|mt_offset
operator|==
name|m
operator|->
name|m_len
condition|)
block|{
name|mthread
operator|->
name|mt_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|mthread
operator|->
name|mt_count
operator|==
literal|0
condition|)
name|pop_macro_stack
argument_list|()
expr_stmt|;
return|return
name|mac_getc
argument_list|()
return|;
block|}
return|return
name|m
operator|->
name|m_body
index|[
name|mthread
operator|->
name|mt_offset
operator|++
index|]
return|;
block|}
end_function

begin_function
name|void
name|NameMac
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|KeyMacro
operator|.
name|m_len
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No keyboard macro to name!]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_macro
argument_list|()
operator|||
name|InMacDefine
condition|)
name|complain
argument_list|(
literal|"[Can't name while defining/executing]"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|mac_exists
argument_list|(
name|name
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|KeyMacro
operator|.
name|Name
argument_list|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[Can't name it that!]"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|m
operator|->
name|Name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|UnivPtr
operator|)
name|m
operator|->
name|m_body
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|copystr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|m
operator|->
name|Type
operator|=
name|KeyMacro
operator|.
name|Type
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|KeyMacro
operator|.
name|m_len
expr_stmt|;
name|m
operator|->
name|m_buflen
operator|=
name|KeyMacro
operator|.
name|m_buflen
expr_stmt|;
name|m
operator|->
name|m_body
operator|=
name|emalloc
argument_list|(
operator|(
name|size_t
operator|)
name|m
operator|->
name|m_buflen
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
name|KeyMacro
operator|.
name|m_body
argument_list|,
name|m
operator|->
name|m_body
argument_list|,
operator|(
name|size_t
operator|)
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|SAVE
expr_stmt|;
name|m
operator|->
name|Name
operator|=
name|name
expr_stmt|;
name|add_mac
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RunMacro
parameter_list|()
block|{
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|findmac
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|do_macro
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|pr_putc
parameter_list|(
name|c
parameter_list|,
name|fp
parameter_list|)
name|int
name|c
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'^'
condition|)
block|{
name|jputc
argument_list|(
literal|'\\'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jiscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|jputc
argument_list|(
literal|'^'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|==
name|RUBOUT
operator|)
condition|?
literal|'?'
else|:
operator|(
name|c
operator|+
literal|'@'
operator|)
expr_stmt|;
block|}
name|jputc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|WriteMacs
parameter_list|()
block|{
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|file
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|iobuff
argument_list|,
name|F_WRITE
argument_list|,
name|YES
argument_list|,
name|YES
argument_list|)
expr_stmt|;
comment|/* Don't write the keyboard macro which is always the first */
for|for
control|(
name|m
operator|=
name|macros
operator|->
name|m_nextm
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
block|{
name|fwritef
argument_list|(
name|fp
argument_list|,
literal|"define-macro %s "
argument_list|,
name|m
operator|->
name|Name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|m_len
condition|;
name|i
operator|++
control|)
name|pr_putc
argument_list|(
name|m
operator|->
name|m_body
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|jputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|SAVE
expr_stmt|;
block|}
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DefKBDMac
parameter_list|()
block|{
name|char
modifier|*
name|macro_name
decl_stmt|,
modifier|*
name|macro_body
decl_stmt|,
name|nextc
decl_stmt|,
name|c
decl_stmt|,
name|macro_buffer
index|[
name|LBSIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
name|macro_name
operator|=
name|do_ask
argument_list|(
literal|" \r\n"
argument_list|,
operator|(
name|bool
argument_list|(
argument|*
argument_list|)
name|ptrproto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_name
operator|==
name|NULL
condition|)
name|complain
argument_list|(
literal|"[No default]"
argument_list|)
expr_stmt|;
name|macro_name
operator|=
name|copystr
argument_list|(
name|macro_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|mac_exists
argument_list|(
name|macro_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|del_mac
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|macro_body
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|": %f %s enter body: "
argument_list|,
name|macro_name
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|macro_body
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|nextc
operator|=
operator|*
name|macro_body
operator|++
operator|)
operator|==
name|LF
condition|)
name|complain
argument_list|(
literal|"[Premature end of line]"
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
if|if
condition|(
operator|(
name|nextc
operator|=
operator|*
name|macro_body
operator|++
operator|)
operator|==
literal|'?'
condition|)
name|c
operator|=
name|RUBOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|jisalpha
argument_list|(
name|nextc
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"@[\\]^_"
argument_list|,
name|nextc
argument_list|)
condition|)
name|c
operator|=
name|CTL
argument_list|(
name|nextc
argument_list|)
expr_stmt|;
else|else
name|complain
argument_list|(
literal|"Bad control-character: '%c'"
argument_list|,
name|nextc
argument_list|)
expr_stmt|;
block|}
name|macro_buffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|Name
operator|=
name|macro_name
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_buflen
operator|=
name|i
expr_stmt|;
name|m
operator|->
name|m_body
operator|=
name|emalloc
argument_list|(
operator|(
name|size_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|InJoverc
condition|?
literal|0
else|:
name|SAVE
expr_stmt|;
name|byte_copy
argument_list|(
name|macro_buffer
argument_list|,
name|m
operator|->
name|m_body
argument_list|,
operator|(
name|size_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|add_mac
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Remember
parameter_list|()
block|{
comment|/* We're already executing the macro; ignore any attempts 	   to define the keyboard macro while we are executing. */
if|if
condition|(
name|in_macro
argument_list|()
condition|)
return|return;
if|if
condition|(
name|InMacDefine
condition|)
name|message
argument_list|(
literal|"[Already defining ... continue with definition]"
argument_list|)
expr_stmt|;
else|else
block|{
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|InMacDefine
operator|=
name|YES
expr_stmt|;
name|KeyMacro
operator|.
name|m_len
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
literal|"Defining..."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Forget
parameter_list|()
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|macro
modifier|*
name|m
init|=
operator|&
name|KeyMacro
decl_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|InMacDefine
condition|)
block|{
name|message
argument_list|(
literal|"Keyboard macro defined."
argument_list|)
expr_stmt|;
name|InMacDefine
operator|=
name|NO
expr_stmt|;
comment|/* try and strip off the key sequence that invoked us */
name|cp
operator|=
operator|&
name|m
operator|->
name|m_body
index|[
name|m
operator|->
name|m_len
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|PrefChar
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|m
operator|->
name|m_len
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|commands
index|[
name|cp
index|[
literal|1
index|]
index|]
operator|.
name|c_proc
operator|==
name|Forget
condition|)
name|m
operator|->
name|m_len
operator|-=
literal|1
expr_stmt|;
block|}
else|else
name|complain
argument_list|(
literal|"[end-kbd-macro: not currently defining macro!]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ExecMacro
parameter_list|()
block|{
name|do_macro
argument_list|(
operator|&
name|KeyMacro
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MacInter
parameter_list|()
block|{
if|if
condition|(
name|Asking
condition|)
name|Interactive
operator|=
name|YES
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ModMacs
parameter_list|()
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|macros
operator|->
name|m_nextm
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|SAVE
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

begin_function
name|data_obj
modifier|*
name|findmac
parameter_list|(
name|prompt
parameter_list|)
specifier|const
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|strings
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|strs
init|=
name|strings
decl_stmt|;
specifier|register
name|int
name|com
decl_stmt|;
specifier|register
name|struct
name|macro
modifier|*
name|m
init|=
name|macros
decl_stmt|;
for|for
control|(
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
operator|*
name|strs
operator|++
operator|=
name|m
operator|->
name|Name
expr_stmt|;
operator|*
name|strs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|com
operator|=
name|complete
argument_list|(
name|strings
argument_list|,
name|prompt
argument_list|,
name|NOTHING
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|m
operator|=
name|macros
expr_stmt|;
while|while
condition|(
operator|--
name|com
operator|>=
literal|0
condition|)
name|m
operator|=
name|m
operator|->
name|m_nextm
expr_stmt|;
return|return
operator|(
name|data_obj
operator|*
operator|)
name|m
return|;
block|}
end_function

begin_function
name|void
name|DelMacro
parameter_list|()
block|{
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|findmac
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|m
operator|==
operator|&
name|KeyMacro
condition|)
name|complain
argument_list|(
literal|"[It's illegal to delete the keyboard-macro!]"
argument_list|)
expr_stmt|;
name|del_mac
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

