begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* (C) 1986, 1987, 1988 Ken Mitchum. This code is intended only for use with Jove. */
end_comment

begin_include
include|#
directive|include
file|"tune.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|<MacTypes.h>
end_include

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|<QuickDraw.h>
end_include

begin_include
include|#
directive|include
file|<WindowMgr.h>
end_include

begin_include
include|#
directive|include
file|<FontMgr.h>
end_include

begin_include
include|#
directive|include
file|<ListMgr.h>
end_include

begin_include
include|#
directive|include
file|<EventMgr.h>
end_include

begin_include
include|#
directive|include
file|<ControlMgr.h>
end_include

begin_include
include|#
directive|include
file|<DialogMgr.h>
end_include

begin_include
include|#
directive|include
file|<ResourceMgr.h>
end_include

begin_include
include|#
directive|include
file|<ToolboxUtil.h>
end_include

begin_include
include|#
directive|include
file|<HFS.h>
end_include

begin_include
include|#
directive|include
file|<StdFilePkg.h>
end_include

begin_include
include|#
directive|include
file|<MenuMgr.h>
end_include

begin_include
include|#
directive|include
file|<pascal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<SegmentLdr.h>
end_include

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|menu
name|Menus
index|[
name|NMENUS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|EventRecord
name|the_Event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|SetBounds
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|Set_std
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|Reset_std
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bool
name|is_dir
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bool
name|findtext
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keycodes (from Inside MacIntosh I-251). because of changes with the MacPlus, there are some duplicate codes between cursor keys and keypad keys. these can be deciphered by the corresponding character codes, which are different. this table simply translates a keycode into a character code that is appropriate. */
end_comment

begin_define
define|#
directive|define
name|NOKEY
value|(-1)
end_define

begin_define
define|#
directive|define
name|RET
value|0x0D
end_define

begin_define
define|#
directive|define
name|TAB
value|0x09
end_define

begin_define
define|#
directive|define
name|BACKSP
value|0x08
end_define

begin_define
define|#
directive|define
name|ENTERL
value|NOKEY
end_define

begin_comment
comment|/* left enter key absent on MacPlus */
end_comment

begin_define
define|#
directive|define
name|COMMAND
value|NOKEY
end_define

begin_comment
comment|/* will be no translation anyway for these */
end_comment

begin_define
define|#
directive|define
name|SHIFT
value|NOKEY
end_define

begin_define
define|#
directive|define
name|CAPSLOCK
value|NOKEY
end_define

begin_define
define|#
directive|define
name|OPTION
value|NOKEY
end_define

begin_define
define|#
directive|define
name|PADDOT
value|'.'
end_define

begin_comment
comment|/* PAD period */
end_comment

begin_define
define|#
directive|define
name|PAD0
value|'0'
end_define

begin_define
define|#
directive|define
name|PAD1
value|'1'
end_define

begin_define
define|#
directive|define
name|PAD2
value|'2'
end_define

begin_define
define|#
directive|define
name|PAD3
value|'3'
end_define

begin_define
define|#
directive|define
name|PAD4
value|'4'
end_define

begin_define
define|#
directive|define
name|PAD5
value|'5'
end_define

begin_define
define|#
directive|define
name|PAD6
value|'6'
end_define

begin_define
define|#
directive|define
name|PAD7
value|'7'
end_define

begin_define
define|#
directive|define
name|PAD8
value|'8'
end_define

begin_define
define|#
directive|define
name|PAD9
value|'9'
end_define

begin_define
define|#
directive|define
name|LEFTCURS
value|'B'
end_define

begin_comment
comment|/* jove only, make like commands */
end_comment

begin_define
define|#
directive|define
name|RIGHTCURS
value|'F'
end_define

begin_define
define|#
directive|define
name|UPCURS
value|'P'
end_define

begin_define
define|#
directive|define
name|DOWNCURS
value|'N'
end_define

begin_define
define|#
directive|define
name|PADENTER
value|RET
end_define

begin_define
define|#
directive|define
name|PADMINUS
value|'-'
end_define

begin_define
define|#
directive|define
name|CLEAR
value|0
end_define

begin_decl_stmt
name|private
name|char
name|nsh_keycodes
index|[]
init|=
block|{
literal|'a'
block|,
literal|'s'
block|,
literal|'d'
block|,
literal|'f'
block|,
literal|'h'
block|,
comment|/* 0 - 4 */
literal|'g'
block|,
literal|'z'
block|,
literal|'x'
block|,
literal|'c'
block|,
literal|'v'
block|,
comment|/* 5 - 9 */
name|NOKEY
block|,
literal|'b'
block|,
literal|'q'
block|,
literal|'w'
block|,
literal|'e'
block|,
comment|/* 10 - 14 */
literal|'r'
block|,
literal|'y'
block|,
literal|'t'
block|,
literal|'1'
block|,
literal|'2'
block|,
comment|/* 15 - 19 */
literal|'3'
block|,
literal|'4'
block|,
literal|'6'
block|,
literal|'5'
block|,
literal|'='
block|,
comment|/* 20 - 24 */
literal|'9'
block|,
literal|'7'
block|,
literal|'-'
block|,
literal|'8'
block|,
literal|'0'
block|,
comment|/* 25 - 29 */
literal|']'
block|,
literal|'O'
block|,
literal|'u'
block|,
literal|'['
block|,
literal|'i'
block|,
comment|/* 30 - 34 */
literal|'p'
block|,
name|RET
block|,
literal|'l'
block|,
literal|'j'
block|,
literal|'\''
block|,
comment|/* 35 - 39 */
literal|'k'
block|,
literal|';'
block|,
literal|'\\'
block|,
literal|','
block|,
literal|'/'
block|,
comment|/* 40 - 44 */
literal|'n'
block|,
literal|'m'
block|,
literal|'.'
block|,
name|TAB
block|,
name|NOKEY
block|,
comment|/* 45 - 49 */
literal|'`'
block|,
name|BACKSP
block|,
name|ENTERL
block|,
name|NOKEY
block|,
name|NOKEY
block|,
comment|/* 50 - 54 */
name|COMMAND
block|,
name|SHIFT
block|,
name|CAPSLOCK
block|,
name|OPTION
block|,
name|NOKEY
block|,
comment|/* 55 - 59 */
name|NOKEY
block|,
name|NOKEY
block|,
name|NOKEY
block|,
name|NOKEY
block|,
name|NOKEY
block|,
comment|/* 60 - 64 */
name|PADDOT
block|,
name|RIGHTCURS
block|,
name|NOKEY
block|,
name|NOKEY
block|,
name|NOKEY
block|,
comment|/* 65 - 69 */
name|LEFTCURS
block|,
name|CLEAR
block|,
name|DOWNCURS
block|,
name|NOKEY
block|,
name|NOKEY
block|,
comment|/* 70 - 74 */
name|NOKEY
block|,
name|PADENTER
block|,
name|UPCURS
block|,
name|PADMINUS
block|,
name|NOKEY
block|,
comment|/* 75 - 79 */
name|NOKEY
block|,
name|NOKEY
block|,
name|PAD0
block|,
name|PAD1
block|,
name|PAD2
block|,
comment|/* 80 - 84 */
name|PAD3
block|,
name|PAD4
block|,
name|PAD5
block|,
name|PAD6
block|,
name|PAD7
block|,
comment|/* 85 - 89 */
name|NOKEY
block|,
name|PAD8
block|,
name|PAD9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|sh_keycodes
index|[]
init|=
block|{
literal|'A'
block|,
literal|'S'
block|,
literal|'D'
block|,
literal|'F'
block|,
literal|'H'
block|,
comment|/* 0 - 4 */
literal|'G'
block|,
literal|'Z'
block|,
literal|'X'
block|,
literal|'C'
block|,
literal|'V'
block|,
comment|/* 5 - 9 */
name|NOKEY
block|,
literal|'B'
block|,
literal|'Q'
block|,
literal|'W'
block|,
literal|'E'
block|,
comment|/* 10 - 14 */
literal|'R'
block|,
literal|'Y'
block|,
literal|'T'
block|,
literal|'!'
block|,
literal|'@'
block|,
comment|/* 15 - 19 */
literal|'#'
block|,
literal|'$'
block|,
literal|'^'
block|,
literal|'%'
block|,
literal|'+'
block|,
comment|/* 20 - 24 */
literal|'('
block|,
literal|'&'
block|,
literal|'_'
block|,
literal|'*'
block|,
literal|')'
block|,
comment|/* 25 - 29 */
literal|'}'
block|,
literal|'O'
block|,
literal|'U'
block|,
literal|'{'
block|,
literal|'I'
block|,
comment|/* 30 - 34 */
literal|'P'
block|,
name|RET
block|,
literal|'L'
block|,
literal|'J'
block|,
literal|'\''
block|,
comment|/* 35 - 39 */
literal|'K'
block|,
literal|';'
block|,
literal|'|'
block|,
literal|'<'
block|,
literal|'?'
block|,
comment|/* 40 - 44 */
literal|'N'
block|,
literal|'M'
block|,
literal|'>'
block|,
name|TAB
block|,
name|NOKEY
block|,
comment|/* 45 - 49 */
literal|'~'
block|,
name|BACKSP
block|,
name|ENTERL
block|,
name|NOKEY
block|,
name|NOKEY
block|,
comment|/* 50 - 54 */
name|COMMAND
block|,
name|SHIFT
block|,
name|CAPSLOCK
block|,
name|OPTION
block|,
name|NOKEY
block|,
comment|/* 55 - 59 */
name|NOKEY
block|,
name|NOKEY
block|,
name|NOKEY
block|,
name|NOKEY
block|,
name|NOKEY
block|,
comment|/* 60 - 64 */
name|PADDOT
block|,
name|RIGHTCURS
block|,
name|NOKEY
block|,
name|NOKEY
block|,
name|NOKEY
block|,
comment|/* 65 - 69 */
name|LEFTCURS
block|,
name|CLEAR
block|,
name|DOWNCURS
block|,
name|NOKEY
block|,
name|NOKEY
block|,
comment|/* 70 - 74 */
name|NOKEY
block|,
name|PADENTER
block|,
name|UPCURS
block|,
name|PADMINUS
block|,
name|NOKEY
block|,
comment|/* 75 - 79 */
name|NOKEY
block|,
name|NOKEY
block|,
name|PAD0
block|,
name|PAD1
block|,
name|PAD2
block|,
comment|/* 80 - 84 */
name|PAD3
block|,
name|PAD4
block|,
name|PAD5
block|,
name|PAD6
block|,
name|PAD7
block|,
comment|/* 85 - 89 */
name|NOKEY
block|,
name|PAD8
block|,
name|PAD9
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tn.h Modified for variable screen size 11/21/87. K. Mitchum */
end_comment

begin_define
define|#
directive|define
name|SCREENSIZE
value|(wc->w_rows * ROWSIZE)
end_define

begin_define
define|#
directive|define
name|FONT
value|monaco
end_define

begin_define
define|#
directive|define
name|TEXTSIZE
value|9
end_define

begin_define
define|#
directive|define
name|HEIGHT
value|11
end_define

begin_define
define|#
directive|define
name|WIDTH
value|6
end_define

begin_define
define|#
directive|define
name|DESCENT
value|2
end_define

begin_define
define|#
directive|define
name|TWIDTH
value|CO * WIDTH
end_define

begin_define
define|#
directive|define
name|THEIGHT
value|LI * HEIGHT
end_define

begin_comment
comment|/* window specs */
end_comment

begin_define
define|#
directive|define
name|SCROLLWIDTH
value|16
end_define

begin_comment
comment|/* width of scroll bar control in pixels */
end_comment

begin_define
define|#
directive|define
name|WINDWIDTH
value|(wc->w_width - SCROLLWIDTH + 1)
end_define

begin_comment
comment|/* local coordinates */
end_comment

begin_define
define|#
directive|define
name|WINDHEIGHT
value|(wc->w_height)
end_define

begin_comment
comment|/* local coordinates */
end_comment

begin_define
define|#
directive|define
name|MAXROW
value|(LI - 1)
end_define

begin_define
define|#
directive|define
name|MAXCOL
value|(CO - 1)
end_define

begin_comment
comment|/* for keyboard routines */
end_comment

begin_define
define|#
directive|define
name|MCHARS
value|32
end_define

begin_comment
comment|/* must be power of two */
end_comment

begin_define
define|#
directive|define
name|NMASK
value|MCHARS (-1)
end_define

begin_comment
comment|/* circular buffer */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/* these normally reside in "tune.c" which we don't use */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CmdDb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* see InitMac() */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p_tempfile
init|=
literal|".jrecXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|d_tempfile
init|=
literal|".joveXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Joverc
init|=
literal|".joverc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|putcurs
argument_list|()
decl_stmt|,
name|curset
argument_list|()
decl_stmt|,
name|putp
argument_list|()
decl_stmt|,
name|dellines
argument_list|()
decl_stmt|,
name|inslines
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Rect
name|LimitRect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bounds we can't move past */
end_comment

begin_struct
struct|struct
name|wind_config
block|{
name|int
name|w_width
decl_stmt|;
comment|/* pixel width of the Mac window */
name|int
name|w_height
decl_stmt|;
name|int
name|w_rows
decl_stmt|;
comment|/* rows of characters which fit the window */
name|int
name|w_cols
decl_stmt|;
block|}
name|wc_std
struct|,
name|wc_user
struct|,
modifier|*
name|wc
struct|;
end_struct

begin_decl_stmt
name|private
name|WindowPtr
name|theScreen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|Windchange
decl_stmt|,
name|EventCmd
decl_stmt|,
name|Keyonly
decl_stmt|,
name|Bufchange
decl_stmt|,
name|Modechange
decl_stmt|,
name|Macmode
init|=
name|OFF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization Routines. */
end_comment

begin_function
name|void
name|InitBinds
parameter_list|()
block|{
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|data_obj
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|MainKeys
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|*
name|p
expr_stmt|;
name|c
operator|->
name|c_map
operator|=
name|F_MAINMAP
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
name|i
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|EscKeys
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|*
name|p
expr_stmt|;
name|c
operator|->
name|c_map
operator|=
name|F_PREF1MAP
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
name|i
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|CtlxKeys
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|*
name|p
expr_stmt|;
name|c
operator|->
name|c_map
operator|=
name|F_PREF2MAP
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
name|i
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|private
name|WindowPtr
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Rect
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|CursHandle
name|cross
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|InitEvents
parameter_list|()
block|{
name|void
name|InitSysMenu
parameter_list|()
function_decl|;
name|window
operator|=
name|theScreen
expr_stmt|;
name|InitSysMenu
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|left
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|top
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|right
operator|-
name|SCROLLWIDTH
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|bottom
operator|-
name|SCROLLWIDTH
argument_list|)
expr_stmt|;
name|cross
operator|=
name|GetCursor
argument_list|(
name|crossCursor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MacInit
parameter_list|()
block|{
name|char
modifier|*
name|gethome
parameter_list|()
function_decl|;
name|void
name|tn_init
parameter_list|()
function_decl|;
name|tn_init
argument_list|()
expr_stmt|;
name|getdir
argument_list|()
expr_stmt|;
name|gethome
argument_list|()
expr_stmt|;
comment|/* before anyone changes it */
name|CmdDb
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|gethome
argument_list|()
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* ??? better check for CmdDb == NULL -- DHR */
name|strcpy
argument_list|(
name|CmdDb
argument_list|,
name|gethome
argument_list|()
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|CmdDb
argument_list|,
literal|"/cmds.doc"
argument_list|)
expr_stmt|;
name|InitBinds
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dummy routines. */
end_comment

begin_function
name|int
name|dummy
parameter_list|()
block|{}
end_function

begin_macro
name|SIGRESULT
argument_list|(
argument|*signal(sig,func)
argument_list|)
end_macro

begin_macro
name|proto
argument_list|(
argument|(int)
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_macro
name|SIGRESULT
argument_list|(
argument|*func
argument_list|)
end_macro

begin_expr_stmt
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|&
name|dummy
return|;
block|}
end_block

begin_function
name|void
name|dorecover
parameter_list|()
block|{}
end_function

begin_comment
comment|/* Surrogate unix-style file i/o routines for Jove. These replace the    routines distributed in the libraries. They work with Jove, but may    not be general enough for other purposes. */
end_comment

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|NFILES
value|10
end_define

begin_comment
comment|/* #define fsetup(p) { \  *	(p).ioCompletion = 0; \  *	(p).ioVRefNum = cur_vol; \  *	(p).ioDirID = cur_dir; \  *	(p).ioFVersNum = 0; \  * }  * #define isetup(p) {(p).ioCompletion = 0; (p).ioVRefNum = cur_vol;}  */
end_comment

begin_decl_stmt
name|private
name|int
name|cur_vol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disk or volume number */
end_comment

begin_decl_stmt
name|private
name|long
name|cur_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory number */
end_comment

begin_decl_stmt
name|private
name|int
name|cur_vref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ugh.. Vref for volume + directory */
end_comment

begin_struct
struct|struct
name|ftab
block|{
name|int
name|inuse
decl_stmt|;
comment|/* 0 = closed 1 = binary 2 = text*/
name|int
name|refnum
decl_stmt|;
comment|/* Mac file reference number */
block|}
name|ft
index|[
name|NFILES
index|]
struct|;
end_struct

begin_function
name|private
name|void
name|fsetup
parameter_list|(
name|p
parameter_list|)
name|HParmBlkPtr
name|p
decl_stmt|;
block|{
name|byte_zero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|HParamBlockRec
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioDirID
operator|=
name|cur_dir
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|isetup
parameter_list|(
name|p
parameter_list|)
name|HIOParam
modifier|*
name|p
decl_stmt|;
block|{
name|byte_zero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|HIOParam
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kludge to convert Macintosh error codes to something like Unix. */
end_comment

begin_function
name|private
name|int
name|cvt_err
parameter_list|(
name|err
parameter_list|)
comment|/* some of these don't make sense... */
name|int
name|err
decl_stmt|;
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|noErr
case|:
name|errno
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|dirFulErr
case|:
case|case
name|dskFulErr
case|:
name|errno
operator|=
name|ENOSPC
expr_stmt|;
break|break;
case|case
name|nsvErr
case|:
case|case
name|mFulErr
case|:
case|case
name|tmfoErr
case|:
case|case
name|fnfErr
case|:
default|default:
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
case|case
name|ioErr
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|bdNamErr
case|:
case|case
name|opWrErr
case|:
case|case
name|paramErr
case|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|fnOpnErr
case|:
comment|/* dubious... */
case|case
name|rfNumErr
case|:
name|errno
operator|=
name|EBADF
expr_stmt|;
break|break;
case|case
name|eofErr
case|:
comment|/* ditto */
case|case
name|posErr
case|:
name|errno
operator|=
name|ESPIPE
expr_stmt|;
break|break;
case|case
name|wPrErr
case|:
name|errno
operator|=
name|EROFS
expr_stmt|;
break|break;
case|case
name|fLckdErr
case|:
case|case
name|permErr
case|:
name|errno
operator|=
name|EACCES
expr_stmt|;
break|break;
case|case
name|fBsyErr
case|:
name|errno
operator|=
name|EBUSY
expr_stmt|;
break|break;
case|case
name|dupFNErr
case|:
name|errno
operator|=
name|EEXIST
expr_stmt|;
break|break;
case|case
name|gfpErr
case|:
case|case
name|volOffLinErr
case|:
case|case
name|volOnLinErr
case|:
case|case
name|nsDrvErr
case|:
name|errno
operator|=
name|ENODEV
expr_stmt|;
break|break;
case|case
name|noMacDskErr
case|:
case|case
name|extFSErr
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|fsRnErr
case|:
case|case
name|badMDBErr
case|:
case|case
name|wrPermErr
case|:
name|errno
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|private
name|char
modifier|*
name|cvt_fnm
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|static
name|char
name|nm
index|[
literal|255
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|nm
argument_list|,
name|file
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* full path */
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|file
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|nm
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
comment|/* make a partial pathname */
else|else
operator|*
name|nm
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|nm
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
operator|*
name|t
operator|=
literal|':'
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
return|return
name|nm
return|;
block|}
end_function

begin_function
name|int
name|creat
parameter_list|(
name|name
parameter_list|,
name|perm
parameter_list|)
comment|/* permission mode is irrelevant on a Mac */
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|perm
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|HParamBlockRec
name|p
decl_stmt|;
if|if
condition|(
name|is_dir
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* convert filename to Mac type name */
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|NFILES
operator|&&
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
condition|;
name|fd
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|fd
operator|==
name|NFILES
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* try to delete it, whether it is there or not. */
name|p
operator|.
name|fileParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHDelete
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
operator|&&
name|err
operator|!=
name|fnfErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|do_creat
argument_list|(
operator|&
name|p
argument_list|,
name|nm
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
operator|++
expr_stmt|;
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
operator|=
name|p
operator|.
name|ioParam
operator|.
name|ioRefNum
expr_stmt|;
return|return
name|fd
operator|+
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|open
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|HParamBlockRec
name|p
decl_stmt|;
if|if
condition|(
name|is_dir
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* convert filename to Mac type name */
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|NFILES
operator|&&
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
condition|;
name|fd
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|fd
operator|==
name|NFILES
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
literal|3
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|p
operator|.
name|ioParam
operator|.
name|ioPermssn
operator|=
name|fsRdPerm
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|p
operator|.
name|ioParam
operator|.
name|ioPermssn
operator|=
name|fsWrPerm
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|p
operator|.
name|ioParam
operator|.
name|ioPermssn
operator|=
name|fsRdWrPerm
expr_stmt|;
break|break;
block|}
name|p
operator|.
name|ioParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioMisc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHOpen
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
operator|&&
name|err
operator|!=
name|fnfErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|err
operator|==
name|noErr
operator|&&
name|mode
operator|&
name|O_CREAT
operator|&&
name|mode
operator|&
name|O_EXCL
condition|)
block|{
name|PBClose
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|err
operator|==
name|fnfErr
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|O_CREAT
condition|)
block|{
if|if
condition|(
name|do_creat
argument_list|(
operator|&
name|p
argument_list|,
name|nm
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
operator|++
expr_stmt|;
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
operator|=
name|p
operator|.
name|ioParam
operator|.
name|ioRefNum
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioPosMode
operator|=
operator|(
name|mode
operator|&
name|O_APPEND
operator|)
condition|?
name|fsFromLEOF
else|:
name|fsFromStart
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioPosOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBSetFPos
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
block|{
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|fd
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|private
name|int
name|do_creat
parameter_list|(
name|p
parameter_list|,
name|nm
parameter_list|)
name|HParmBlkPtr
name|p
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|fsetup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHCreate
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
name|fsetup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHGetFInfo
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
name|p
operator|->
name|fileParam
operator|.
name|ioDirID
operator|=
name|cur_dir
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFlFndrInfo
operator|.
name|fdType
operator|=
literal|'TEXT'
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFlFndrInfo
operator|.
name|fdCreator
operator|=
literal|'JV01'
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFlFndrInfo
operator|.
name|fdFlags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|fileParam
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHSetFInfo
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
name|fsetup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|ioParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|p
operator|->
name|ioParam
operator|.
name|ioPermssn
operator|=
name|fsRdWrPerm
expr_stmt|;
name|p
operator|->
name|ioParam
operator|.
name|ioMisc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvt_err
argument_list|(
name|PBHOpen
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|close
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|HParamBlockRec
name|p
decl_stmt|;
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioRefNum
operator|=
name|ft
index|[
operator|--
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|ft
index|[
name|fd
index|]
operator|.
name|inuse
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NEVER
if|if
condition|(
name|cvt_err
argument_list|(
name|PBFlushFile
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cvt_err
argument_list|(
name|PBClose
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioParam
operator|.
name|ioNamePtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cvt_err
argument_list|(
name|PBFlushVol
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
comment|/* ??? added by DHR */
block|}
end_function

begin_comment
comment|/* Raw read, except '\n' is translated to '\r'.  * Surely this could be done better by having '\n' stand for '\015'  * as it is done in OS-9.  */
end_comment

begin_function
name|int
name|read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|IOParam
name|p
decl_stmt|;
if|if
condition|(
name|fd
operator|==
literal|0
condition|)
return|return
name|con_read
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
return|;
if|if
condition|(
name|ft
index|[
operator|--
name|fd
index|]
operator|.
name|inuse
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioBuffer
operator|=
name|buf
expr_stmt|;
name|p
operator|.
name|ioReqCount
operator|=
name|n
expr_stmt|;
name|p
operator|.
name|ioPosMode
operator|=
name|fsFromMark
expr_stmt|;
name|p
operator|.
name|ioPosOffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBRead
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
operator|&&
name|err
operator|!=
name|eofErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\r'
condition|)
operator|*
name|buf
operator|=
literal|'\n'
expr_stmt|;
comment|/* convert from Mac style */
name|buf
operator|++
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|p
operator|.
name|ioActCount
return|;
block|}
end_function

begin_comment
comment|/* Raw write, except '\n' is translated to '\r'.  * Surely this could be done better by having '\n' stand for '\015'  * as it is done in OS-9.  */
end_comment

begin_function
name|int
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|n
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NEVER
name|int
name|err
decl_stmt|;
name|IOParam
name|p
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|fd
operator|==
literal|0
condition|)
return|return
name|con_write
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
return|;
name|s
operator|=
name|obuf
operator|=
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obuf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* shouldn't happen... */
if|if
condition|(
name|ft
index|[
operator|--
name|fd
index|]
operator|.
name|inuse
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioBuffer
operator|=
name|obuf
expr_stmt|;
name|p
operator|.
name|ioReqCount
operator|=
operator|(
name|long
operator|)
name|n
expr_stmt|;
name|p
operator|.
name|ioPosMode
operator|=
name|fsFromMark
expr_stmt|;
name|p
operator|.
name|ioPosOffset
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\n'
condition|)
operator|*
name|s
operator|=
literal|'\r'
expr_stmt|;
comment|/* make it look like Mac files */
else|else
operator|*
name|s
operator|=
operator|*
name|buf
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|PBWrite
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
block|{
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|p
operator|.
name|ioActCount
return|;
else|#
directive|else
comment|/* ??? This version is untested! -- DHR 	 * It avoids a malloc for every file write! 	 */
if|if
condition|(
name|fd
operator|==
literal|0
condition|)
block|{
return|return
name|con_write
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
return|;
block|}
else|else
block|{
name|IOParam
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|ebuf
init|=
name|buf
operator|+
name|n
decl_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioPosMode
operator|=
name|fsFromMark
expr_stmt|;
while|while
condition|(
name|buf
operator|!=
name|ebuf
condition|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\n'
condition|)
block|{
name|p
operator|.
name|ioReqCount
operator|=
literal|1
name|p
operator|.
name|ioBuffer
operator|=
literal|"\r"
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|buf
while|while
condition|(
name|p
operator|!=
name|ebuf
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|.
name|ioReqCount
operator|=
name|p
operator|-
name|buf
expr_stmt|;
name|p
operator|.
name|ioBuffer
operator|=
name|buf
expr_stmt|;
block|}
name|p
operator|.
name|ioPosOffset
operator|=
literal|0L
expr_stmt|;
comment|/* bidirectional */
if|if
condition|(
operator|(
name|err
operator|=
name|PBWrite
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
name|buf
operator|+=
name|p
operator|.
name|ioActCount
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|long
name|lseek
parameter_list|(
name|fd
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
comment|/* The Mac version of this doesn't allocate new space. */
name|int
name|fd
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|unsigned
name|type
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|long
name|cur_mark
decl_stmt|,
name|eof
decl_stmt|,
name|new_mark
decl_stmt|;
name|IOParam
name|p
decl_stmt|;
if|if
condition|(
name|ft
index|[
operator|--
name|fd
index|]
operator|.
name|inuse
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBGetFPos
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
name|cur_mark
operator|=
name|p
operator|.
name|ioPosOffset
expr_stmt|;
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBGetEOF
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
name|eof
operator|=
operator|(
name|long
operator|)
name|p
operator|.
name|ioMisc
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
name|new_mark
operator|=
name|offset
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|new_mark
operator|=
name|offset
operator|+
name|cur_mark
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|new_mark
operator|=
name|offset
operator|+
name|eof
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new_mark
operator|>
name|eof
condition|)
block|{
comment|/* need more space in file */
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioMisc
operator|=
operator|(
name|Ptr
operator|)
name|new_mark
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBSetEOF
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
ifdef|#
directive|ifdef
name|NEVER
if|if
condition|(
operator|(
name|err
operator|=
name|PBAllocContig
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
endif|#
directive|endif
block|}
name|isetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|ioRefNum
operator|=
name|ft
index|[
name|fd
index|]
operator|.
name|refnum
expr_stmt|;
name|p
operator|.
name|ioPosOffset
operator|=
name|new_mark
expr_stmt|;
name|p
operator|.
name|ioPosMode
operator|=
name|fsFromStart
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBSetFPos
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|p
operator|.
name|ioPosOffset
return|;
block|}
end_function

begin_function
name|int
name|unlink
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|HParamBlockRec
name|p
decl_stmt|;
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* convert filename to Mac type name */
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|fsetup
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* try to delete it, whether it is there or not. */
name|p
operator|.
name|fileParam
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|PBHDelete
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|noErr
operator|&&
name|err
operator|!=
name|fnfErr
condition|)
return|return
name|cvt_err
argument_list|(
name|err
argument_list|)
return|;
return|return
literal|0
return|;
comment|/* ??? added by DHR */
block|}
end_function

begin_comment
comment|/* Console read and write routines */
end_comment

begin_function
name|private
name|int
name|con_write
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
while|while
condition|(
name|size
operator|--
condition|)
name|putp
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
name|private
name|int
name|con_read
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|unsigned
name|n
decl_stmt|;
name|int
name|p
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|p
operator|=
name|rawgetc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|O_META
if|if
condition|(
name|p
operator|&
literal|0x7f
condition|)
name|p
operator|&=
literal|0x7f
expr_stmt|;
comment|/* was normal ascii char */
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|p
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|rawchkc
argument_list|()
operator|&&
name|n
operator|<=
name|size
condition|)
do|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* This didn't seem to be any place else */
end_comment

begin_function
name|int
name|abs
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
name|n
operator|>=
literal|0
condition|?
name|n
else|:
operator|-
name|n
return|;
block|}
end_function

begin_comment
comment|/* Simplified stat() routine emulates what is needed most. */
end_comment

begin_function
name|int
name|stat
parameter_list|(
name|fname
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
block|{
name|CInfoPBRec
name|p
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|byte_zero
argument_list|(
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|CInfoPBRec
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|p
operator|.
name|hFileInfo
operator|.
name|ioDirID
operator|=
name|cur_dir
expr_stmt|;
switch|switch
condition|(
name|PBGetCatInfo
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|noErr
case|:
name|errno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|nsvErr
case|:
case|case
name|paramErr
case|:
case|case
name|bdNamErr
case|:
case|case
name|fnfErr
case|:
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
case|case
name|ioErr
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|buf
operator|->
name|st_dev
operator|=
name|p
operator|.
name|hFileInfo
operator|.
name|ioVRefNum
operator|+
literal|1
expr_stmt|;
comment|/* don't want 0 */
name|buf
operator|->
name|st_ino
operator|=
name|p
operator|.
name|hFileInfo
operator|.
name|ioDirID
expr_stmt|;
name|buf
operator|->
name|st_size
operator|=
name|p
operator|.
name|hFileInfo
operator|.
name|ioFlLgLen
expr_stmt|;
name|buf
operator|->
name|st_mtime
operator|=
name|p
operator|.
name|hFileInfo
operator|.
name|ioFlMdDat
expr_stmt|;
name|buf
operator|->
name|st_mode
operator|=
operator|(
name|p
operator|.
name|hFileInfo
operator|.
name|ioFlAttrib
operator|&
literal|0x10
operator|)
condition|?
name|S_IFDIR
else|:
literal|0
expr_stmt|;
name|PtoCstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
name|errno
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|private
name|bool
name|is_dir
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Directory related routines. Jove keeps track of the true Volume (disk) number and    directory number, and avoids "Working Directory Reference Numbers", which are    confusing. */
end_comment

begin_function
name|private
name|int
name|getdir
parameter_list|()
comment|/* call this only once, during startup. */
block|{
name|WDPBRec
name|p
decl_stmt|;
name|p
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|ioNamePtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|PBHGetVol
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
name|noErr
condition|)
return|return
operator|-
literal|1
return|;
comment|/* BIG trouble */
name|cur_vol
operator|=
name|p
operator|.
name|ioWDVRefNum
expr_stmt|;
name|cur_dir
operator|=
name|p
operator|.
name|ioWDDirID
expr_stmt|;
name|SFSaveDisk
operator|=
literal|0
operator|-
name|cur_vol
expr_stmt|;
comment|/* these are for SF dialogs */
name|CurDirStore
operator|=
name|cur_dir
expr_stmt|;
return|return
literal|0
return|;
comment|/* ??? added by DHR */
block|}
end_function

begin_function
name|private
name|int
name|setdir
parameter_list|(
name|vol
parameter_list|,
name|dir
parameter_list|)
name|int
name|vol
decl_stmt|;
name|long
name|dir
decl_stmt|;
block|{
name|WDPBRec
name|p
decl_stmt|;
name|p
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|ioNamePtr
operator|=
name|NULL
expr_stmt|;
name|p
operator|.
name|ioVRefNum
operator|=
name|vol
expr_stmt|;
name|p
operator|.
name|ioWDDirID
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|PBHSetVol
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
name|noErr
condition|)
return|return
operator|-
literal|1
return|;
name|cur_vol
operator|=
name|vol
expr_stmt|;
name|cur_dir
operator|=
name|dir
expr_stmt|;
name|SFSaveDisk
operator|=
literal|0
operator|-
name|vol
expr_stmt|;
comment|/* these are for SF dialogs */
name|CurDirStore
operator|=
name|dir
expr_stmt|;
block|}
end_function

begin_function
name|int
name|chdir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|CInfoPBRec
name|d
decl_stmt|;
name|WDPBRec
name|p
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* There is no root... */
name|nm
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|strcpy
argument_list|(
name|nm
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
operator|*
name|t
operator|=
literal|':'
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|':'
condition|)
name|t
operator|++
expr_stmt|;
comment|/*get rid of initial slashes */
name|strcat
argument_list|(
name|nm
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
comment|/* get the directory number */
name|d
operator|.
name|dirInfo
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|t
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioDrDirID
operator|=
literal|0
expr_stmt|;
name|PBGetCatInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|dirInfo
operator|.
name|ioResult
operator|!=
name|noErr
operator|||
operator|(
name|d
operator|.
name|dirInfo
operator|.
name|ioFlAttrib
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|||
name|setdir
argument_list|(
name|d
operator|.
name|dirInfo
operator|.
name|ioVRefNum
argument_list|,
name|d
operator|.
name|dirInfo
operator|.
name|ioDrDirID
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scandir returns the number of entries or -1 if the directory cannot    be opened or malloc fails. */
end_comment

begin_function_decl
name|int
name|jscandir
parameter_list|(
name|dir
parameter_list|,
name|nmptr
parameter_list|,
name|qualify
parameter_list|,
name|sorter
parameter_list|)
comment|/* this function has NOT been debugged */
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|nmptr
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*qualify
end_function_decl

begin_expr_stmt
unit|)
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*sorter
argument_list|)
end_macro

begin_expr_stmt
name|proto
argument_list|(
operator|(
name|UnivConstPtr
operator|,
name|UnivConstPtr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CInfoPBRec
name|d
decl_stmt|;
name|Str255
name|buf
decl_stmt|;
name|long
name|DirID
decl_stmt|;
name|char
modifier|*
modifier|*
name|ourarray
decl_stmt|,
modifier|*
name|nm
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|unsigned
name|int
name|nalloc
init|=
literal|10
decl_stmt|,
name|nentries
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* There is no root... */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|dir
operator|=
name|getwd
argument_list|()
expr_stmt|;
name|nm
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|strcpy
argument_list|(
name|nm
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
operator|*
name|t
operator|=
literal|':'
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|nm
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|':'
condition|)
name|t
operator|++
expr_stmt|;
comment|/*get rid of initial slashes */
name|strcat
argument_list|(
name|nm
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|byte_zero
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|CInfoPBRec
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
comment|/* get the directory number */
name|d
operator|.
name|dirInfo
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|t
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioFDirIndex
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioDrDirID
operator|=
literal|0
expr_stmt|;
name|PBGetCatInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|dirInfo
operator|.
name|ioResult
operator|!=
name|noErr
operator|||
operator|(
operator|(
name|d
operator|.
name|dirInfo
operator|.
name|ioFlAttrib
operator|&
literal|0x10
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|DirID
operator|=
name|d
operator|.
name|dirInfo
operator|.
name|ioDrDirID
expr_stmt|;
name|ourarray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|nalloc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|byte_zero
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|CInfoPBRec
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioCompletion
operator|=
operator|(
name|long
operator|)
literal|0
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioFVersNum
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|buf
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioFDirIndex
operator|=
name|index
operator|++
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioDrDirID
operator|=
name|DirID
expr_stmt|;
if|if
condition|(
name|PBGetCatInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
operator|!=
name|noErr
condition|)
break|break;
comment|/* we are done, then */
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEVER
if|if
condition|(
name|d
operator|.
name|dirInfo
operator|.
name|ioFlAttrib
operator|&
literal|0x10
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qualify
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|qualify
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nentries
operator|==
name|nalloc
condition|)
name|ourarray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ourarray
argument_list|,
operator|(
name|nalloc
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ourarray
index|[
name|nentries
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|null_ncpy
argument_list|(
name|ourarray
index|[
name|nentries
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|nentries
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nentries
operator|+
literal|1
operator|)
operator|!=
name|nalloc
condition|)
name|ourarray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ourarray
argument_list|,
operator|(
operator|(
name|nentries
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorter
operator|!=
name|NULL
condition|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ourarray
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|,
name|sorter
argument_list|)
expr_stmt|;
operator|*
name|nmptr
operator|=
name|ourarray
expr_stmt|;
name|ourarray
index|[
name|nentries
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* guaranteed NULL pointer */
return|return
name|nentries
return|;
block|}
end_block

begin_function
name|void
name|freedir
parameter_list|(
name|dir
parameter_list|,
name|nentries
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|dir
decl_stmt|;
name|int
name|nentries
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|ptr
init|=
operator|*
name|dir
decl_stmt|;
while|while
condition|(
name|nentries
operator|--
condition|)
name|free
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|alphacomp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|UnivConstPtr
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
return|return
name|strcmp
argument_list|(
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|a
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|b
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|chkCWD
parameter_list|(
name|name
parameter_list|)
comment|/* eventually, may check validity of cwd */
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getwd
parameter_list|()
block|{
name|CInfoPBRec
name|d
decl_stmt|;
specifier|static
name|char
name|ret
index|[
literal|255
index|]
decl_stmt|;
name|char
name|nm
index|[
literal|50
index|]
decl_stmt|,
name|tmp
index|[
literal|255
index|]
decl_stmt|;
name|ret
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioDrDirID
operator|=
name|cur_dir
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|d
operator|.
name|dirInfo
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioNamePtr
operator|=
operator|(
name|StringPtr
operator|)
name|nm
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioVRefNum
operator|=
name|cur_vol
expr_stmt|;
name|d
operator|.
name|dirInfo
operator|.
name|ioFDirIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|PBGetCatInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|dirInfo
operator|.
name|ioResult
operator|!=
name|noErr
condition|)
return|return
name|NULL
return|;
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nm
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ret
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ret
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|dirInfo
operator|.
name|ioDrDirID
operator|==
literal|2
condition|)
break|break;
comment|/* home directory */
name|d
operator|.
name|dirInfo
operator|.
name|ioDrDirID
operator|=
name|d
operator|.
name|dirInfo
operator|.
name|ioDrParID
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|private
name|char
modifier|*
name|gethome
parameter_list|()
comment|/* this will be startup directory */
block|{
specifier|static
name|char
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|item
init|=
name|getwd
argument_list|()
decl_stmt|;
name|ret
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|item
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Routines that put up and manipulate the "About Jove" dialog. */
end_comment

begin_comment
comment|/* (ORIGINALLY IN) about_j.c. */
end_comment

begin_define
define|#
directive|define
name|DLOGNAME
value|"\pABOUT_JDLOG"
end_define

begin_define
define|#
directive|define
name|DONE_ITEM
value|1
end_define

begin_define
define|#
directive|define
name|LIST_ITEM
value|2
end_define

begin_define
define|#
directive|define
name|DWIDTH
value|460
end_define

begin_comment
comment|/* there should be an easy way to get this */
end_comment

begin_define
define|#
directive|define
name|DHEIGHT
value|240
end_define

begin_comment
comment|/* from the resource file! */
end_comment

begin_function_decl
name|WindowPtr
name|makedisplay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|ListHandle
name|makelist
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|WindowPtr
name|theWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ListHandle
name|theList
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Rect
name|theListRect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|EventRecord
name|theEvent
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|about_j
parameter_list|()
block|{
name|void
name|do_list
argument_list|()
decl_stmt|,
name|do_events
argument_list|()
decl_stmt|;
name|WindowPtr
name|OldWindow
decl_stmt|;
name|GetPort
argument_list|(
operator|&
name|OldWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|theWindow
operator|=
name|makedisplay
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return;
name|SetPort
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
if|if
condition|(
name|theList
operator|=
name|makelist
argument_list|()
condition|)
block|{
name|LActivate
argument_list|(
literal|1
argument_list|,
name|theList
argument_list|)
expr_stmt|;
name|do_list
argument_list|()
expr_stmt|;
name|ShowWindow
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|do_events
argument_list|()
expr_stmt|;
block|}
name|SetPort
argument_list|(
name|OldWindow
argument_list|)
expr_stmt|;
name|LDispose
argument_list|(
name|theList
argument_list|)
expr_stmt|;
name|DisposDialog
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|WindowPtr
name|makedisplay
parameter_list|()
block|{
specifier|static
name|int
name|dlogid
init|=
literal|0
decl_stmt|;
name|DialogPtr
name|theDialog
decl_stmt|;
name|Handle
name|theHandle
decl_stmt|;
name|Handle
name|theResource
decl_stmt|;
name|Str255
name|buf
decl_stmt|;
name|long
name|itemType
decl_stmt|;
name|Rect
name|theRect
decl_stmt|;
name|short
name|dh
decl_stmt|,
name|dv
decl_stmt|;
comment|/* to center dialog on the screen */
name|Str255
name|nostring
decl_stmt|;
if|if
condition|(
name|dlogid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|theResource
operator|=
name|GetNamedResource
argument_list|(
literal|'DLOG'
argument_list|,
name|DLOGNAME
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|WindowPtr
operator|)
name|NULL
return|;
name|itemType
operator|=
literal|'DLOG'
expr_stmt|;
name|GetResInfo
argument_list|(
name|theResource
argument_list|,
operator|&
name|dlogid
argument_list|,
operator|&
name|itemType
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|theDialog
operator|=
name|GetNewDialog
argument_list|(
name|dlogid
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
operator|(
name|WindowPtr
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nostring
argument_list|,
literal|"\p"
argument_list|)
expr_stmt|;
name|ParamText
argument_list|(
literal|"\pMacJove - Copyright (C) 1986, 1987, 1988 J. Payne, K. Gegenfurtner,"
argument_list|,
literal|"\pK. Mitchum. Portions (C) THINK Technologies, Inc."
argument_list|,
name|nostring
argument_list|,
name|nostring
argument_list|)
expr_stmt|;
name|dh
operator|=
name|screenBits
operator|.
name|bounds
operator|.
name|left
operator|+
operator|(
name|screenBits
operator|.
name|bounds
operator|.
name|right
operator|-
name|DWIDTH
operator|)
operator|/
literal|2
expr_stmt|;
name|dv
operator|=
name|screenBits
operator|.
name|bounds
operator|.
name|top
operator|+
operator|(
name|screenBits
operator|.
name|bounds
operator|.
name|bottom
operator|-
name|DHEIGHT
operator|)
operator|/
literal|2
expr_stmt|;
name|MoveWindow
argument_list|(
operator|(
name|WindowPtr
operator|)
name|theDialog
argument_list|,
name|dh
argument_list|,
name|dv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ShowWindow
argument_list|(
operator|(
name|WindowPtr
operator|)
name|theDialog
argument_list|)
expr_stmt|;
name|GetDItem
argument_list|(
name|theDialog
argument_list|,
name|LIST_ITEM
argument_list|,
operator|&
name|itemType
argument_list|,
operator|&
name|theHandle
argument_list|,
operator|&
name|theRect
argument_list|)
expr_stmt|;
name|theListRect
operator|=
name|theRect
expr_stmt|;
name|theListRect
operator|.
name|right
operator|-=
literal|15
expr_stmt|;
operator|(
operator|(
name|WindowPtr
operator|)
name|theDialog
operator|)
operator|->
name|txFont
operator|=
name|FONT
expr_stmt|;
operator|(
operator|(
name|WindowPtr
operator|)
name|theDialog
operator|)
operator|->
name|txSize
operator|=
name|TEXTSIZE
expr_stmt|;
return|return
operator|(
name|WindowPtr
operator|)
name|theDialog
return|;
block|}
end_function

begin_function
name|private
name|void
name|do_display
parameter_list|()
comment|/* draw necessary controls, lines */
block|{
name|Rect
name|rViewF
decl_stmt|;
comment|/* framing rect for list */
name|int
name|offset
decl_stmt|;
name|rViewF
operator|=
name|theListRect
expr_stmt|;
name|rViewF
operator|.
name|left
operator|--
expr_stmt|;
name|rViewF
operator|.
name|top
operator|--
expr_stmt|;
name|rViewF
operator|.
name|right
operator|++
expr_stmt|;
name|rViewF
operator|.
name|bottom
operator|++
expr_stmt|;
name|FrameRect
argument_list|(
operator|&
name|rViewF
argument_list|)
expr_stmt|;
name|DrawControls
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|ListHandle
name|makelist
parameter_list|()
block|{
name|Point
name|csize
decl_stmt|;
name|Rect
name|dataBounds
decl_stmt|,
name|rView
decl_stmt|;
comment|/* list boundaries */
name|csize
operator|.
name|h
operator|=
name|csize
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|dataBounds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|LNew
argument_list|(
operator|&
name|theListRect
argument_list|,
operator|&
name|dataBounds
argument_list|,
name|csize
argument_list|,
literal|0
argument_list|,
name|theWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|do_list
parameter_list|()
block|{
name|void
name|printbind
parameter_list|()
function_decl|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|struct
name|cmd
modifier|*
name|f
decl_stmt|;
name|Str255
name|buf
decl_stmt|;
name|Point
name|theCell
decl_stmt|;
name|theCell
operator|.
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
name|commands
operator|,
name|row
operator|=
literal|0
init|;
name|f
operator|->
name|Name
condition|;
name|f
operator|++
operator|,
name|row
operator|++
control|)
block|{
name|LAddRow
argument_list|(
literal|1
argument_list|,
name|row
argument_list|,
name|theList
argument_list|)
expr_stmt|;
name|theCell
operator|.
name|v
operator|=
name|row
expr_stmt|;
name|printbind
argument_list|(
name|f
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|f
operator|->
name|Name
argument_list|)
expr_stmt|;
name|LSetCell
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
argument_list|,
name|theCell
argument_list|,
name|theList
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|printbind
parameter_list|(
name|f
parameter_list|,
name|buf
parameter_list|)
name|struct
name|cmd
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|c_map
operator|==
literal|0
operator|||
operator|(
name|c
operator|=
name|f
operator|->
name|c_key
operator|)
operator|==
literal|0x7f
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"        "
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|f
operator|->
name|c_map
condition|)
block|{
case|case
name|F_MAINMAP
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"     "
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_PREF1MAP
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|" ESC "
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_PREF2MAP
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"  ^X "
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|buf
index|[
literal|5
index|]
operator|=
literal|'^'
expr_stmt|;
comment|/* control char */
name|c
operator||=
literal|0x40
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|5
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|c
operator|&=
literal|0x5f
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|private
name|pascal
name|Boolean
name|ProcFilter
parameter_list|(
name|theDialog
parameter_list|,
name|event
parameter_list|,
name|itemHit
parameter_list|)
name|DialogPtr
name|theDialog
decl_stmt|;
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|int
modifier|*
name|itemHit
decl_stmt|;
block|{
name|theEvent
operator|=
operator|*
name|event
expr_stmt|;
if|if
condition|(
name|theEvent
operator|.
name|what
operator|==
name|keyDown
operator|&&
name|theEvent
operator|.
name|message
operator|&
name|charCodeMask
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|itemHit
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|theEvent
operator|.
name|what
operator|==
name|activateEvt
operator|&&
operator|(
name|WindowPtr
operator|)
name|theEvent
operator|.
name|message
operator|==
name|theWindow
condition|)
block|{
name|LDoDraw
argument_list|(
literal|1
argument_list|,
name|theList
argument_list|)
expr_stmt|;
name|LActivate
argument_list|(
literal|1
argument_list|,
name|theList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|theEvent
operator|.
name|what
operator|==
name|updateEvt
operator|&&
operator|(
name|WindowPtr
operator|)
name|theEvent
operator|.
name|message
operator|==
name|theWindow
condition|)
block|{
name|BeginUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|do_display
argument_list|()
expr_stmt|;
name|DrawDialog
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|LUpdate
argument_list|(
operator|(
name|GrafPtr
operator|)
name|theWindow
operator|->
name|visRgn
argument_list|,
name|theList
argument_list|)
expr_stmt|;
name|EndUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|do_events
parameter_list|()
block|{
name|int
name|item
decl_stmt|;
name|bool
name|done
init|=
name|NO
decl_stmt|;
name|Point
name|p
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|ModalDialog
argument_list|(
name|ProcFilter
argument_list|,
operator|&
name|item
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|DONE_ITEM
case|:
name|done
operator|=
name|YES
expr_stmt|;
comment|/* ??? fall through? -- DHR */
case|case
name|LIST_ITEM
case|:
name|p
operator|=
name|theEvent
operator|.
name|where
expr_stmt|;
name|GlobalToLocal
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|LClick
argument_list|(
name|p
argument_list|,
name|theEvent
operator|.
name|modifiers
argument_list|,
name|theList
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Window and Control related routines. */
end_comment

begin_comment
comment|/* (ORIGINALLY IN) tcon.c.    control handler routines for Jove. K. Mitchum 12/86 */
end_comment

begin_define
define|#
directive|define
name|MINC
value|0
end_define

begin_define
define|#
directive|define
name|MAXC
value|((int)100)
end_define

begin_define
define|#
directive|define
name|INITC
value|0
end_define

begin_define
define|#
directive|define
name|EVENTLIST
value|(mDownMask | keyDownMask )
end_define

begin_function_decl
specifier|extern
name|long
name|GetCRefCon
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* omitted in ControlMgr.h */
end_comment

begin_decl_stmt
name|private
name|Point
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|intext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mouse down in jove text */
end_comment

begin_decl_stmt
name|private
name|bool
name|wc_adjust
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|wind_config
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|docontrols
parameter_list|()
comment|/* called from redisplay routines */
block|{
name|void
name|MakeScrollBar
argument_list|()
decl_stmt|,
name|AdjustScrollBar
argument_list|()
decl_stmt|,
name|drawfluff
argument_list|()
decl_stmt|;
name|Window
modifier|*
name|w
decl_stmt|;
name|int
name|top
decl_stmt|;
name|w
operator|=
name|fwind
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_control
condition|)
name|HideControl
argument_list|(
name|w
operator|->
name|w_control
argument_list|)
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
name|w
operator|=
name|fwind
expr_stmt|;
do|do
block|{
name|w
operator|->
name|w_topline
operator|=
name|top
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_control
condition|)
name|AdjustScrollBar
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|MakeScrollBar
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|ShowControl
argument_list|(
name|w
operator|->
name|w_control
argument_list|)
expr_stmt|;
name|top
operator|+=
name|w
operator|->
name|w_height
expr_stmt|;
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
name|Windchange
operator|=
name|NO
expr_stmt|;
name|drawfluff
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MakeScrollBar
parameter_list|(
name|w
parameter_list|)
comment|/* set up control */
name|Window
modifier|*
name|w
decl_stmt|;
block|{
name|Rect
name|BarRect
decl_stmt|;
name|int
name|wheight
decl_stmt|,
name|wtop
decl_stmt|;
name|WindowPtr
name|window
init|=
name|theScreen
decl_stmt|;
name|wheight
operator|=
name|w
operator|->
name|w_height
expr_stmt|;
name|wtop
operator|=
name|w
operator|->
name|w_topline
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|BarRect
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|right
operator|-
name|SCROLLWIDTH
operator|+
literal|1
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|top
operator|-
literal|2
operator|+
name|wtop
operator|*
name|HEIGHT
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|right
operator|+
literal|1
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|top
operator|+
operator|(
operator|(
name|wheight
operator|+
name|wtop
operator|)
operator|*
name|HEIGHT
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_control
operator|=
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NewControl
argument_list|(
name|window
argument_list|,
operator|&
name|BarRect
argument_list|,
literal|"/psbar"
argument_list|,
literal|1
argument_list|,
name|INITC
argument_list|,
name|MINC
argument_list|,
name|MAXC
argument_list|,
name|scrollBarProc
argument_list|,
name|w
argument_list|)
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|AdjustScrollBar
parameter_list|(
name|w
parameter_list|)
comment|/* redo existing control */
name|Window
modifier|*
name|w
decl_stmt|;
block|{
name|int
name|wtop
decl_stmt|,
name|wheight
decl_stmt|;
name|ControlHandle
name|handle
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
name|handle
operator|=
operator|(
name|ControlHandle
operator|)
name|w
operator|->
name|w_control
expr_stmt|;
name|wtop
operator|=
name|w
operator|->
name|w_topline
expr_stmt|;
name|wheight
operator|=
name|w
operator|->
name|w_height
expr_stmt|;
name|window
operator|=
operator|(
operator|*
name|handle
operator|)
operator|->
name|contrlOwner
expr_stmt|;
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
return|return;
name|SizeControl
argument_list|(
name|handle
argument_list|,
name|SCROLLWIDTH
argument_list|,
name|wheight
operator|*
name|HEIGHT
operator|+
literal|1
argument_list|)
expr_stmt|;
name|MoveControl
argument_list|(
name|handle
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|right
operator|-
name|SCROLLWIDTH
operator|+
literal|1
argument_list|,
name|window
operator|->
name|portRect
operator|.
name|top
operator|-
literal|1
operator|+
name|wtop
operator|*
name|HEIGHT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetScrollBar
parameter_list|(
name|handle
parameter_list|)
comment|/* set value of the bar */
name|ControlHandle
name|handle
decl_stmt|;
block|{
name|SetCtlValue
argument_list|(
name|handle
argument_list|,
name|ltoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|drawfluff
parameter_list|()
comment|/* draw controls and dividers */
block|{
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
name|DrawControls
argument_list|(
name|theScreen
argument_list|)
expr_stmt|;
name|DrawGrowIcon
argument_list|(
name|theScreen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RemoveScrollBar
parameter_list|(
name|w
parameter_list|)
name|Window
modifier|*
name|w
decl_stmt|;
block|{
if|if
condition|(
name|w
operator|->
name|w_control
condition|)
name|DisposeControl
argument_list|(
name|w
operator|->
name|w_control
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_control
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|pascal
name|void
name|DScroll
parameter_list|(
name|control
parameter_list|,
name|part
parameter_list|)
name|ControlHandle
name|control
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|DownScroll
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|pascal
name|void
name|UScroll
parameter_list|(
name|control
parameter_list|,
name|part
parameter_list|)
name|ControlHandle
name|control
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|UpScroll
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|pascal
name|void
name|NPage
parameter_list|(
name|control
parameter_list|,
name|part
parameter_list|)
name|ControlHandle
name|control
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|NextPage
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|pascal
name|void
name|PPage
parameter_list|(
name|control
parameter_list|,
name|part
parameter_list|)
name|ControlHandle
name|control
decl_stmt|;
name|int
name|part
decl_stmt|;
block|{
name|PrevPage
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|long
name|npos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines in buffer */
end_comment

begin_function
name|private
name|int
name|ltoc
parameter_list|()
comment|/* calculate ctlvalue for line position */
block|{
specifier|register
name|long
name|ipos
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
init|=
name|curbuf
operator|->
name|b_first
decl_stmt|;
for|for
control|(
name|npos
operator|=
literal|1
init|;
name|lp
condition|;
name|npos
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|lp
operator|==
name|curline
condition|)
name|ipos
operator|=
name|npos
expr_stmt|;
block|}
return|return
call|(
name|int
call|)
argument_list|(
operator|(
name|ipos
operator|*
name|MAXC
operator|)
operator|/
name|npos
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|Line
modifier|*
name|ctol
parameter_list|(
name|ctlv
parameter_list|)
comment|/* find buffer line for ctlvalue */
name|int
name|ctlv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|itoa
parameter_list|()
function_decl|;
specifier|register
name|long
name|ipos
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
init|=
name|curbuf
operator|->
name|b_first
decl_stmt|;
name|ipos
operator|=
operator|(
name|npos
operator|*
name|ctlv
operator|)
operator|/
name|MAXC
expr_stmt|;
while|while
condition|(
name|ipos
operator|--
operator|&&
name|lp
operator|->
name|l_next
condition|)
name|lp
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_function
name|private
name|void
name|doWind
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
define|#
directive|define
name|track
parameter_list|()
value|TrackControl(whichControl,p,(ProcPtr)NULL)
name|ControlHandle
name|whichControl
decl_stmt|;
name|Window
modifier|*
name|jwind
decl_stmt|,
modifier|*
name|cwind
decl_stmt|;
name|int
name|notcurwind
decl_stmt|;
name|int
name|cpart
decl_stmt|;
comment|/* control part */
name|int
name|oldval
decl_stmt|,
name|newval
decl_stmt|,
name|thumb
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|event
operator|->
name|where
expr_stmt|;
name|intext
operator|=
literal|0
expr_stmt|;
name|notcurwind
operator|=
literal|0
expr_stmt|;
name|GlobalToLocal
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|what
operator|==
name|mouseDown
condition|)
block|{
if|if
condition|(
operator|(
name|cpart
operator|=
name|FindControl
argument_list|(
name|p
argument_list|,
name|window
argument_list|,
operator|&
name|whichControl
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|jwind
operator|=
operator|(
name|Window
operator|*
operator|)
operator|(
operator|*
name|whichControl
operator|)
operator|->
name|contrlRfCon
operator|)
operator|!=
name|curwind
condition|)
block|{
name|notcurwind
operator|++
expr_stmt|;
name|cwind
operator|=
name|curwind
expr_stmt|;
name|SetWind
argument_list|(
name|jwind
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cpart
condition|)
block|{
case|case
name|inUpButton
case|:
name|TrackControl
argument_list|(
name|whichControl
argument_list|,
name|p
argument_list|,
operator|(
name|ProcPtr
operator|)
name|DScroll
argument_list|)
expr_stmt|;
break|break;
case|case
name|inDownButton
case|:
name|TrackControl
argument_list|(
name|whichControl
argument_list|,
name|p
argument_list|,
operator|(
name|ProcPtr
operator|)
name|UScroll
argument_list|)
expr_stmt|;
break|break;
case|case
name|inPageUp
case|:
name|TrackControl
argument_list|(
name|whichControl
argument_list|,
name|p
argument_list|,
operator|(
name|ProcPtr
operator|)
name|PPage
argument_list|)
expr_stmt|;
break|break;
case|case
name|inPageDown
case|:
name|TrackControl
argument_list|(
name|whichControl
argument_list|,
name|p
argument_list|,
operator|(
name|ProcPtr
operator|)
name|NPage
argument_list|)
expr_stmt|;
break|break;
case|case
name|inThumb
case|:
if|if
condition|(
name|track
argument_list|()
condition|)
block|{
name|newval
operator|=
name|GetCtlValue
argument_list|(
name|whichControl
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
operator|==
name|MAXC
condition|)
name|Eof
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|newval
operator|==
name|MINC
condition|)
name|Bof
argument_list|()
expr_stmt|;
else|else
name|SetLine
argument_list|(
name|ctol
argument_list|(
name|newval
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|notcurwind
condition|)
block|{
name|SetWind
argument_list|(
name|cwind
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
name|redisplay
argument_list|()
expr_stmt|;
comment|/* again, to set the cursor */
block|}
else|else
block|{
if|if
condition|(
name|findtext
argument_list|()
condition|)
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|std_state
parameter_list|(
name|w
parameter_list|)
value|(*((WStateData **)((WindowPeek)((w)))->dataHandle))->stdState
end_define

begin_define
define|#
directive|define
name|user_state
parameter_list|(
name|w
parameter_list|)
value|(*((WStateData **)((WindowPeek)((w)))->dataHandle))->userState
end_define

begin_function
name|private
name|void
name|doDrag
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
name|Rect
name|old_std
decl_stmt|;
name|old_std
operator|=
name|std_state
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|DragWindow
argument_list|(
name|window
argument_list|,
name|event
operator|->
name|where
argument_list|,
operator|&
name|LimitRect
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
operator|&
name|wc_std
condition|)
block|{
name|wc_user
operator|=
name|wc_std
expr_stmt|;
name|user_state
argument_list|(
name|theScreen
argument_list|)
operator|=
name|std_state
argument_list|(
name|theScreen
argument_list|)
expr_stmt|;
name|ZoomWindow
argument_list|(
name|window
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wc
operator|=
operator|&
name|wc_user
expr_stmt|;
name|Reset_std
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|doGrow
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
name|long
name|size
decl_stmt|;
comment|/* zero means user didn't change anything */
if|if
condition|(
name|size
operator|=
name|GrowWindow
argument_list|(
name|window
argument_list|,
name|event
operator|->
name|where
argument_list|,
operator|&
name|LimitRect
argument_list|)
condition|)
block|{
if|if
condition|(
name|wc
operator|==
operator|&
name|wc_std
condition|)
block|{
name|wc_user
operator|=
name|wc_std
expr_stmt|;
name|user_state
argument_list|(
name|theScreen
argument_list|)
operator|=
name|std_state
argument_list|(
name|theScreen
argument_list|)
expr_stmt|;
name|ZoomWindow
argument_list|(
name|window
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wc
operator|=
operator|&
name|wc_user
expr_stmt|;
name|Reset_std
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|wc_adjust
argument_list|(
name|LoWord
argument_list|(
name|size
argument_list|)
argument_list|,
name|HiWord
argument_list|(
name|size
argument_list|)
argument_list|,
name|wc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|EraseRect
argument_list|(
operator|&
name|window
operator|->
name|portRect
argument_list|)
expr_stmt|;
name|SizeWindow
argument_list|(
name|window
argument_list|,
name|wc
operator|->
name|w_width
argument_list|,
name|wc
operator|->
name|w_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|win_reshape
argument_list|()
expr_stmt|;
comment|/* no signals here... */
block|}
block|}
block|}
end_function

begin_function
name|private
name|void
name|doZoomIn
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
if|if
condition|(
name|TrackBox
argument_list|(
name|window
argument_list|,
name|event
operator|->
name|where
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|EraseRect
argument_list|(
operator|&
name|window
operator|->
name|portRect
argument_list|)
expr_stmt|;
name|ZoomWindow
argument_list|(
name|window
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wc
operator|=
operator|&
name|wc_user
expr_stmt|;
name|win_reshape
argument_list|()
expr_stmt|;
comment|/* we do our own toggle, not ZoomWindow() */
block|}
block|}
end_function

begin_function
name|private
name|void
name|doZoomOut
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
if|if
condition|(
name|TrackBox
argument_list|(
name|window
argument_list|,
name|event
operator|->
name|where
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|EraseRect
argument_list|(
operator|&
name|window
operator|->
name|portRect
argument_list|)
expr_stmt|;
name|ZoomWindow
argument_list|(
name|window
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wc
operator|=
operator|&
name|wc_std
expr_stmt|;
name|win_reshape
argument_list|()
expr_stmt|;
comment|/* we do our own toggle, not ZoomWindow() */
block|}
block|}
end_function

begin_function
name|private
name|void
name|doGoAway
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
if|if
condition|(
name|TrackGoAway
argument_list|(
name|window
argument_list|,
name|event
operator|->
name|where
argument_list|)
condition|)
name|Leave
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|Window
modifier|*
name|rtowind
parameter_list|(
name|row
parameter_list|)
comment|/* return jove window row is in */
name|int
name|row
decl_stmt|;
block|{
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|w
operator|->
name|w_topline
operator|<=
name|row
operator|)
operator|&&
operator|(
operator|(
name|w
operator|->
name|w_height
operator|+
name|w
operator|->
name|w_topline
operator|)
operator|>
name|row
operator|)
condition|)
return|return
name|w
return|;
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|private
name|Line
modifier|*
name|windtol
parameter_list|(
name|w
parameter_list|,
name|row
parameter_list|)
comment|/* return line for row in window */
name|Window
modifier|*
name|w
decl_stmt|;
name|int
name|row
decl_stmt|;
block|{
name|Line
modifier|*
name|l
init|=
name|w
operator|->
name|w_top
decl_stmt|;
while|while
condition|(
name|row
operator|--
condition|)
if|if
condition|(
operator|(
name|l
operator|=
name|l
operator|->
name|l_next
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|l
return|;
block|}
end_function

begin_function
name|private
name|bool
name|findtext
parameter_list|()
comment|/* locate and move the point to match the mouse */
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|long
name|ticks
decl_stmt|;
name|EventRecord
name|event
decl_stmt|;
name|Window
modifier|*
name|w
decl_stmt|;
name|Line
modifier|*
name|l
decl_stmt|;
name|ticks
operator|=
name|Ticks
expr_stmt|;
name|ptoxy
argument_list|(
name|p
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|rtowind
argument_list|(
name|row
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NO
return|;
if|if
condition|(
name|w
operator|!=
name|curwind
condition|)
name|SetWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|row
operator|-=
name|w
operator|->
name|w_topline
expr_stmt|;
comment|/* now have row number in window */
if|if
condition|(
name|row
operator|>=
name|w
operator|->
name|w_height
operator|-
literal|1
condition|)
return|return
name|NO
return|;
if|if
condition|(
operator|(
name|l
operator|=
name|windtol
argument_list|(
name|w
argument_list|,
name|row
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NO
return|;
if|if
condition|(
name|l
operator|->
name|l_dline
operator|==
name|NULL_DADDR
condition|)
return|return
name|NO
return|;
name|this_cmd
operator|=
name|LINECMD
expr_stmt|;
name|SetLine
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* Curline is in linebuf now */
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
condition|)
name|col
operator|-=
literal|8
expr_stmt|;
comment|/* adjust for line numbers */
if|if
condition|(
name|col
operator|<
literal|0
condition|)
name|col
operator|=
literal|0
expr_stmt|;
name|curchar
operator|=
name|how_far
argument_list|(
name|curline
argument_list|,
name|col
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|GetNextEvent
argument_list|(
name|mUpMask
argument_list|,
operator|&
name|event
argument_list|)
operator|&&
operator|(
name|event
operator|.
name|when
operator|<
name|ticks
operator|+
name|DoubleTime
operator|)
condition|)
block|{
name|set_mark
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|Ticks
operator|-
name|ticks
operator|)
operator|<
name|DoubleTime
condition|)
do|;
return|return
name|YES
return|;
block|}
end_function

begin_function
name|private
name|int
name|ptoxy
parameter_list|(
name|p
parameter_list|,
name|row
parameter_list|,
name|col
parameter_list|)
comment|/* convert Point to terminal x,y coordinate */
name|Point
name|p
decl_stmt|;
name|int
modifier|*
name|row
decl_stmt|,
decl|*
name|col
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|row
operator|=
operator|(
name|p
operator|.
name|v
operator|/
name|HEIGHT
operator|)
expr_stmt|;
operator|*
name|col
operator|=
operator|(
name|p
operator|.
name|h
operator|/
name|WIDTH
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|row
operator|>
name|MAXROW
operator|)
operator|||
operator|(
operator|*
name|col
operator|>
name|MAXCOL
operator|)
condition|)
return|return
name|ERROR
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Event-related routines. The Event loop is CheckEvents(), and is called whenever    a console read occurs or a call to charp(). During certain activities, such as ask(),    etc. non-keyboard events are ignored. This is set by the variable Keyonly.    As an update or activate event generates a call to redisplay(), it is important    that redisplay() and related routines NOT check for keyboard characters. */
end_comment

begin_comment
comment|/* (ORIGINALLY IN) tevent.c 	event handler for Jove. K Mitchum 12/86 */
end_comment

begin_define
define|#
directive|define
name|SYS_ID
value|100
end_define

begin_define
define|#
directive|define
name|NOFUNC
value|((void (*)())NULL)
end_define

begin_define
define|#
directive|define
name|NEVENTS
value|16
end_define

begin_decl_stmt
specifier|extern
name|void
name|doMouse
argument_list|()
decl_stmt|,
name|dokeyDown
argument_list|()
decl_stmt|,
name|doUpdate
argument_list|()
decl_stmt|,
name|doActivate
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|p_refresh
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|MenuHandle
name|SysMenu
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|void
function_decl|(
modifier|*
name|eventlist
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|NOFUNC
operator|,
comment|/* nullEvent */
function_decl|doMouse
operator|,
comment|/* mouseDown */
function_decl|doMouse
operator|,
comment|/* mouseUp */
function_decl|dokeyDown
operator|,
comment|/* keyDown */
function_decl|NOFUNC
operator|,
comment|/* keyUp */
function_decl|dokeyDown
operator|,
comment|/* autoKey */
function_decl|doUpdate
operator|,
comment|/* updateEvt */
function_decl|NOFUNC
operator|,
comment|/* diskEvt */
function_decl|doActivate
operator|,
comment|/* activateEvt */
function_decl|NOFUNC
operator|,
comment|/* not  used */
function_decl|NOFUNC
operator|,
comment|/* networkEvt = 10 */
function_decl|NOFUNC
operator|,
comment|/* driverEvt */
function_decl|NOFUNC
operator|,
comment|/* app1Evt */
function_decl|NOFUNC
operator|,
comment|/* app2Evt */
function_decl|NOFUNC
operator|,
comment|/* app3Evt */
function_decl|NOFUNC
end_function_decl

begin_comment
comment|/* app4Ev */
end_comment

begin_function
unit|};
name|private
name|void
name|CheckEvents
parameter_list|()
block|{
name|void
name|SetBufMenu
argument_list|()
decl_stmt|,
name|MarkModes
argument_list|()
decl_stmt|;
specifier|static
name|EventRecord
name|theEvent
decl_stmt|;
specifier|static
name|Point
name|Mousep
decl_stmt|;
specifier|static
name|long
name|time
init|=
literal|0
decl_stmt|;
specifier|static
name|void
function_decl|(
modifier|*
name|fptr
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|FrontWindow
argument_list|()
operator|==
name|window
condition|)
block|{
name|GetMouse
argument_list|(
operator|&
name|Mousep
argument_list|)
expr_stmt|;
if|if
condition|(
name|PtInRect
argument_list|(
name|Mousep
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|SetCursor
argument_list|(
operator|*
name|cross
argument_list|)
expr_stmt|;
else|else
name|SetCursor
argument_list|(
operator|&
name|arrow
argument_list|)
expr_stmt|;
block|}
name|SystemTask
argument_list|()
expr_stmt|;
if|if
condition|(
name|EventCmd
operator|&&
operator|!
name|Keyonly
condition|)
return|return;
if|if
condition|(
name|Bufchange
condition|)
name|SetBufMenu
argument_list|()
expr_stmt|;
if|if
condition|(
name|Modechange
condition|)
name|MarkModes
argument_list|()
expr_stmt|;
while|while
condition|(
name|GetNextEvent
argument_list|(
name|everyEvent
argument_list|,
operator|&
name|theEvent
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|theEvent
operator|.
name|what
operator|<
name|NEVENTS
operator|)
operator|&&
operator|(
name|fptr
operator|=
name|eventlist
index|[
name|theEvent
operator|.
name|what
index|]
operator|)
condition|)
block|{
call|(
modifier|*
name|fptr
call|)
argument_list|(
operator|&
name|theEvent
argument_list|)
expr_stmt|;
block|}
name|SystemTask
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Ticks
operator|-
name|time
operator|)
operator|>
literal|3600
condition|)
block|{
name|time
operator|=
name|Ticks
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|InitSysMenu
parameter_list|()
block|{
name|void
name|InitLocalMenus
parameter_list|()
function_decl|;
name|SysMenu
operator|=
name|NewMenu
argument_list|(
name|SYS_ID
argument_list|,
literal|"\p\24"
argument_list|)
expr_stmt|;
name|AppendMenu
argument_list|(
name|SysMenu
argument_list|,
literal|"\pAbout Jove"
argument_list|)
expr_stmt|;
name|AddResMenu
argument_list|(
name|SysMenu
argument_list|,
literal|'DRVR'
argument_list|)
expr_stmt|;
name|InsertMenu
argument_list|(
name|SysMenu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|InitLocalMenus
argument_list|()
expr_stmt|;
name|DrawMenuBar
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|void
name|doWind
argument_list|()
decl_stmt|,
name|doGoAway
argument_list|()
decl_stmt|,
name|doSysMenu
argument_list|()
decl_stmt|,
name|doSysClick
argument_list|()
decl_stmt|,
name|doDrag
argument_list|()
decl_stmt|,
name|doGrow
argument_list|()
decl_stmt|,
name|doZoomIn
argument_list|()
decl_stmt|,
name|doZoomOut
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMEVENTS
value|9
end_define

begin_function_decl
name|private
name|void
function_decl|(
modifier|*
name|mouselist
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|NOFUNC
operator|,
comment|/* inDesk */
function_decl|doSysMenu
operator|,
comment|/* inMenuBar */
function_decl|doSysClick
operator|,
comment|/* inSysWindow */
function_decl|doWind
operator|,
comment|/* inContent */
function_decl|doDrag
operator|,
comment|/* inDrag */
function_decl|doGrow
operator|,
comment|/* inGrow */
function_decl|doGoAway
operator|,
comment|/* inGoAway */
function_decl|doZoomIn
operator|,
comment|/* inZoomIn */
function_decl|doZoomOut
end_function_decl

begin_comment
comment|/* inZoomOut */
end_comment

begin_function
unit|};
name|private
name|void
name|doMouse
parameter_list|(
name|event
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
block|{
name|WindowPtr
name|theWindow
decl_stmt|;
name|int
name|wpart
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fptr
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|Keyonly
condition|)
block|{
if|if
condition|(
name|event
operator|->
name|what
operator|==
name|mouseDown
condition|)
name|SysBeep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpart
operator|=
name|FindWindow
argument_list|(
name|event
operator|->
name|where
argument_list|,
operator|&
name|theWindow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wpart
operator|<
name|NMEVENTS
operator|)
operator|&&
operator|(
name|fptr
operator|=
name|mouselist
index|[
name|wpart
index|]
operator|)
condition|)
block|{
call|(
modifier|*
name|fptr
call|)
argument_list|(
name|event
argument_list|,
name|theWindow
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|doSysMenu
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
name|void
name|ProcMenu
parameter_list|()
function_decl|;
name|int
name|Menu
decl_stmt|,
name|Item
decl_stmt|;
name|long
name|result
init|=
name|MenuSelect
argument_list|(
name|event
operator|->
name|where
argument_list|)
decl_stmt|;
name|Menu
operator|=
operator|(
name|result
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|Item
operator|=
name|result
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|Item
operator|==
literal|0
condition|)
return|return;
comment|/* no choice made */
if|if
condition|(
name|Menu
operator|==
name|SYS_ID
condition|)
block|{
comment|/* apple menu */
name|Str255
name|Name
decl_stmt|;
name|GrafPtr
name|Port
decl_stmt|;
if|if
condition|(
name|Item
operator|==
literal|1
condition|)
name|about_j
argument_list|()
expr_stmt|;
else|else
block|{
name|GetItem
argument_list|(
name|SysMenu
argument_list|,
name|Item
argument_list|,
name|Name
argument_list|)
expr_stmt|;
name|GetPort
argument_list|(
operator|&
name|Port
argument_list|)
expr_stmt|;
name|OpenDeskAcc
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|SetPort
argument_list|(
name|Port
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ProcMenu
argument_list|(
name|Menu
argument_list|,
name|Item
argument_list|)
expr_stmt|;
name|HiliteMenu
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|EventCmd
operator|=
name|YES
expr_stmt|;
name|menus_on
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|doSysClick
parameter_list|(
name|event
parameter_list|,
name|window
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
name|WindowPtr
name|window
decl_stmt|;
block|{
name|SystemClick
argument_list|(
name|event
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|doUpdate
parameter_list|(
name|event
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
block|{
name|WindowPtr
name|theWindow
decl_stmt|,
name|oldPort
decl_stmt|;
name|theWindow
operator|=
operator|(
name|WindowPtr
operator|)
name|event
operator|->
name|message
expr_stmt|;
name|GetPort
argument_list|(
operator|&
name|oldPort
argument_list|)
expr_stmt|;
name|SetPort
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|BeginUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|p_refresh
argument_list|()
expr_stmt|;
name|drawfluff
argument_list|()
expr_stmt|;
name|EndUpdate
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|SetPort
argument_list|(
name|oldPort
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|doActivate
parameter_list|(
name|event
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
block|{
name|WindowPtr
name|theWindow
decl_stmt|;
name|ControlHandle
name|control
decl_stmt|;
name|int
name|hilite
decl_stmt|;
name|theWindow
operator|=
operator|(
name|WindowPtr
operator|)
name|event
operator|->
name|message
expr_stmt|;
name|SetPort
argument_list|(
name|theWindow
argument_list|)
expr_stmt|;
name|hilite
operator|=
operator|(
name|event
operator|->
name|modifiers
operator|&
name|activeFlag
operator|)
condition|?
literal|0
else|:
literal|255
expr_stmt|;
for|for
control|(
name|control
operator|=
call|(
name|ControlHandle
call|)
argument_list|(
operator|(
operator|(
name|WindowPeek
operator|)
name|theWindow
operator|)
operator|->
name|controlList
argument_list|)
init|;
operator|(
name|control
operator|!=
literal|0
operator|)
condition|;
name|control
operator|=
operator|(
operator|*
name|control
operator|)
operator|->
name|nextControl
control|)
block|{
name|HiliteControl
argument_list|(
name|control
argument_list|,
name|hilite
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Keyboard routines. The Option key was formerly used as a meta key.    However, to take advantage of the full (non-ASCII) character set,    this was removed. The corresponding code is ifdeffed O_META. */
end_comment

begin_comment
comment|/* (ORIGINALLY IN) tkey.c    keyboard routines for Macintosh. K Mitchum 12/86 */
end_comment

begin_decl_stmt
specifier|extern
name|jmp_buf
name|auxjmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|nchars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|charbuf
index|[
name|MCHARS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following kludges a meta key out of the option key by    sending an escape sequence back to the dispatch routines. this is    not elegant but it works, and doesn't alter escape sequences for    those that prefer them. to remap the control or meta keys,    see mackeys.h. */
end_comment

begin_function
name|private
name|void
name|dokeyDown
parameter_list|(
name|event
parameter_list|)
name|EventRecord
modifier|*
name|event
decl_stmt|;
block|{
name|unsigned
name|mods
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|static
name|int
name|cptr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MCHARS
operator|-
name|nchars
operator|<
literal|2
condition|)
return|return;
name|c
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|event
operator|->
name|message
operator|)
operator|&
operator|(
name|charCodeMask
operator|)
argument_list|)
expr_stmt|;
name|mods
operator|=
name|event
operator|->
name|modifiers
expr_stmt|;
ifdef|#
directive|ifdef
name|O_META
if|if
condition|(
name|mods
operator|&
operator|(
name|optionKey
operator||
name|cmdKey
operator||
name|controlKey
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|mods
operator|&
operator|(
name|cmdKey
operator||
name|controlKey
operator|)
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEVER
if|if
condition|(
name|mods
operator|&
name|shiftKey
condition|)
name|c
operator|=
name|sh_keycodes
index|[
operator|(
operator|(
operator|(
name|event
operator|->
name|message
operator|)
operator|&
operator|(
name|keyCodeMask
operator|)
operator|)
operator|>>
literal|8
operator|)
index|]
expr_stmt|;
else|else
name|c
operator|=
name|nsh_keycodes
index|[
operator|(
operator|(
operator|(
name|event
operator|->
name|message
operator|)
operator|&
operator|(
name|keyCodeMask
operator|)
operator|)
operator|>>
literal|8
operator|)
index|]
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_META
if|if
condition|(
name|mods
operator|&
name|optionKey
condition|)
block|{
comment|/* make escape sequence */
if|if
condition|(
name|mods
operator|&
name|cmdKey
condition|)
name|c
operator|&=
literal|0x1f
expr_stmt|;
name|charbuf
index|[
name|cptr
operator|++
index|]
operator|=
literal|'\033'
expr_stmt|;
name|cptr
operator|&=
name|NMASK
expr_stmt|;
comment|/* zero if necessary */
name|nchars
operator|++
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* command key (control key) */
if|if
condition|(
operator|(
name|c
operator|==
literal|'2'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|c
operator|==
literal|' '
operator|)
condition|)
name|c
operator|=
literal|'\0'
expr_stmt|;
comment|/* so we have a null char */
if|if
condition|(
name|c
operator|!=
literal|'`'
condition|)
name|c
operator|&=
literal|0x1f
expr_stmt|;
comment|/* make a control char */
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'`'
condition|)
name|c
operator|=
literal|'\033'
expr_stmt|;
comment|/* for those used to escapes */
block|}
name|charbuf
index|[
name|cptr
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|cptr
operator|&=
name|NMASK
expr_stmt|;
name|nchars
operator|++
expr_stmt|;
block|}
name|private
name|int
name|rawgetc
parameter_list|()
block|{
specifier|static
name|int
name|cptr
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|EventCmd
condition|)
name|longjmp
argument_list|(
name|auxjmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|nchars
operator|<=
literal|0
condition|)
block|{
name|nchars
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|EventCmd
condition|)
name|longjmp
argument_list|(
name|auxjmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CheckEvents
argument_list|()
expr_stmt|;
comment|/* ugh! WAIT for a character */
block|}
name|nchars
operator|--
expr_stmt|;
name|c
operator|=
name|charbuf
index|[
name|cptr
operator|++
index|]
expr_stmt|;
name|cptr
operator|&=
name|NMASK
expr_stmt|;
comment|/* zero if necessary */
return|return
name|c
return|;
block|}
name|bool
name|rawchkc
parameter_list|()
block|{
if|if
condition|(
name|EventCmd
condition|)
name|longjmp
argument_list|(
name|auxjmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|==
literal|0
condition|)
name|CheckEvents
argument_list|()
expr_stmt|;
comment|/* this should NOT be necessary! */
return|return
name|nchars
operator|>
literal|0
return|;
block|}
comment|/* Routines for calling the standard file dialogs, when macify is ON. If the user    changes the directory using the file dialogs, Jove's notion of the current directory    is updated. */
comment|/* (ORIGINALLY IN) tmacf.c. K. Mitchum 12/86.    Macify routines for jove. */
name|int
name|CurrentVol
decl_stmt|;
comment|/* see tfile.c */
define|#
directive|define
name|TYPES
value|(-1)
name|private
name|Point
name|px
init|=
block|{
literal|100
block|,
literal|100
block|}
decl_stmt|;
name|private
name|char
name|pmess
index|[]
init|=
literal|"\pSave file as: "
decl_stmt|;
name|private
name|pascal
name|Boolean
name|Ffilter
parameter_list|(
name|p
parameter_list|)
name|FileParam
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|ioFlFndrInfo
operator|.
name|fdType
operator|==
literal|'APPL'
condition|)
return|return
name|TRUE
return|;
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|ioNamePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|ioNamePtr
argument_list|,
name|d_tempfile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CtoPstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|ioNamePtr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|CtoPstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|ioNamePtr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|private
name|void
name|check_dir
parameter_list|()
block|{
if|if
condition|(
name|cur_vol
operator|!=
literal|0
operator|-
name|SFSaveDisk
operator|||
name|cur_dir
operator|!=
name|CurDirStore
condition|)
block|{
name|setdir
argument_list|(
literal|0
operator|-
name|SFSaveDisk
argument_list|,
name|CurDirStore
argument_list|)
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
comment|/* make sure jove knows the change */
name|Modechange
operator|=
name|YES
expr_stmt|;
name|setCWD
argument_list|(
name|getwd
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|char
modifier|*
name|gfile
parameter_list|(
name|namebuf
parameter_list|)
comment|/* return a filename to get */
name|char
modifier|*
name|namebuf
decl_stmt|;
block|{
name|SFReply
name|frec
decl_stmt|;
name|char
name|ans
index|[
name|FILESIZE
index|]
decl_stmt|;
name|SFSaveDisk
operator|=
literal|0
operator|-
name|cur_vol
expr_stmt|;
comment|/* in case a Desk Accessory changed them */
name|CurDirStore
operator|=
name|cur_dir
expr_stmt|;
name|SFGetFile
argument_list|(
name|px
argument_list|,
literal|0L
argument_list|,
name|Ffilter
argument_list|,
name|TYPES
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
operator|&
name|frec
argument_list|)
expr_stmt|;
name|check_dir
argument_list|()
expr_stmt|;
comment|/* see if any change, set if so */
if|if
condition|(
name|frec
operator|.
name|good
condition|)
block|{
name|EventRecord
name|theEvent
decl_stmt|;
do|do
empty_stmt|;
do|while
condition|(
name|GetNextEvent
argument_list|(
name|updateMask
argument_list|,
operator|&
name|theEvent
argument_list|)
operator|==
literal|0
condition|)
do|;
name|doUpdate
argument_list|(
operator|&
name|theEvent
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frec
operator|.
name|fName
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ans
argument_list|,
name|frec
operator|.
name|fName
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frec
operator|.
name|fName
argument_list|)
expr_stmt|;
name|PathParse
argument_list|(
name|ans
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
return|return
name|namebuf
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
name|char
modifier|*
name|pfile
parameter_list|(
name|namebuf
parameter_list|)
name|char
modifier|*
name|namebuf
decl_stmt|;
block|{
name|SFReply
name|frec
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|nm
decl_stmt|;
name|SFSaveDisk
operator|=
literal|0
operator|-
name|cur_vol
expr_stmt|;
comment|/* in case a Desk Accessory changed them */
name|CurDirStore
operator|=
name|cur_dir
expr_stmt|;
name|strncpy
argument_list|(
name|namebuf
argument_list|,
name|filename
argument_list|(
name|curbuf
argument_list|)
argument_list|,
literal|63
argument_list|)
expr_stmt|;
name|nm
operator|=
name|cvt_fnm
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
name|CtoPstr
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|SFPutFile
argument_list|(
name|px
argument_list|,
name|pmess
argument_list|,
name|nm
argument_list|,
literal|0L
argument_list|,
operator|&
name|frec
argument_list|)
expr_stmt|;
name|check_dir
argument_list|()
expr_stmt|;
comment|/* see if any change, set if so */
if|if
condition|(
name|frec
operator|.
name|good
condition|)
block|{
name|EventRecord
name|theEvent
decl_stmt|;
do|do
empty_stmt|;
do|while
condition|(
name|GetNextEvent
argument_list|(
name|updateMask
argument_list|,
operator|&
name|theEvent
argument_list|)
operator|==
literal|0
condition|)
do|;
name|doUpdate
argument_list|(
operator|&
name|theEvent
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|char
operator|*
operator|)
name|frec
operator|.
name|fName
expr_stmt|;
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frec
operator|.
name|fName
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|':'
condition|)
name|t
operator|++
expr_stmt|;
comment|/* convert to unix style */
name|nm
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|nm
condition|)
block|{
if|if
condition|(
operator|*
name|nm
operator|==
literal|':'
condition|)
operator|*
name|nm
operator|=
literal|'/'
expr_stmt|;
name|nm
operator|++
expr_stmt|;
block|}
name|PathParse
argument_list|(
name|t
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
return|return
name|namebuf
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
comment|/* getArgs() returns an argument list based on documents clicked on by the user. */
name|int
name|getArgs
parameter_list|(
name|avp
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|avp
decl_stmt|;
block|{
name|int
name|argc
decl_stmt|,
name|nargs
decl_stmt|,
name|type
decl_stmt|,
name|old_vol
decl_stmt|;
name|long
name|old_dir
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|AppFile
name|p
decl_stmt|;
name|WDPBRec
name|d
decl_stmt|;
name|old_vol
operator|=
name|cur_vol
expr_stmt|;
name|old_dir
operator|=
name|cur_dir
expr_stmt|;
name|CountAppFiles
argument_list|(
operator|&
name|type
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|0
condition|)
block|{
comment|/* files to open... */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|nargs
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|argc
operator|=
literal|1
init|;
name|argc
operator|<=
name|nargs
condition|;
name|argc
operator|++
control|)
block|{
name|GetAppFiles
argument_list|(
name|argc
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|PtoCstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|.
name|fName
argument_list|)
expr_stmt|;
name|d
operator|.
name|ioCompletion
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|ioNamePtr
operator|=
name|NULL
expr_stmt|;
name|d
operator|.
name|ioVRefNum
operator|=
name|p
operator|.
name|vRefNum
expr_stmt|;
name|d
operator|.
name|ioWDIndex
operator|=
literal|0
expr_stmt|;
name|PBGetWDInfo
argument_list|(
operator|&
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_vol
operator|=
name|d
operator|.
name|ioWDVRefNum
expr_stmt|;
name|cur_dir
operator|=
name|d
operator|.
name|ioWDDirID
expr_stmt|;
name|pathname
operator|=
name|getwd
argument_list|()
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|.
name|fName
argument_list|)
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|argv
index|[
name|argc
index|]
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|argv
index|[
name|argc
index|]
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|argv
index|[
name|argc
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|.
name|fName
argument_list|)
expr_stmt|;
block|}
name|ClrAppFiles
argument_list|(
name|argc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
name|argc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
block|}
name|argv
index|[
literal|0
index|]
operator|=
literal|"jove"
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|avp
operator|=
name|argv
expr_stmt|;
name|cur_dir
operator|=
name|old_dir
expr_stmt|;
name|cur_vol
operator|=
name|old_vol
expr_stmt|;
return|return
name|argc
return|;
block|}
comment|/* Limited version of getenv() */
name|char
modifier|*
name|getenv
parameter_list|(
name|item
parameter_list|)
name|char
modifier|*
name|item
decl_stmt|;
block|{
name|char
modifier|*
name|ret
init|=
name|NULL
decl_stmt|,
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|item
argument_list|,
literal|"CWD"
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|=
name|getwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|item
argument_list|,
literal|"HOME"
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|=
name|gethome
argument_list|()
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|ret
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
name|char
modifier|*
name|mktemp
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|name
return|;
block|}
comment|/* Menu routines. The menus items are set up in a similar manner as keys, and    are bound prior to runtime. See menumaps.txt, which must be run through setmaps.    Unlike keys, menu items may be bound to variables, and to buffers. Buffer binding    is only done at runtime. */
name|private
name|void
name|InitLocalMenus
parameter_list|()
block|{
name|void
name|InitMenu
argument_list|()
decl_stmt|,
name|make_edits
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
condition|;
name|i
operator|++
control|)
block|{
name|InitMenu
argument_list|(
operator|&
name|Menus
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|make_edits
argument_list|(
name|Menus
index|[
name|i
index|]
operator|.
name|menu_id
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|private
name|void
name|InitMenu
parameter_list|(
name|M
parameter_list|)
name|struct
name|menu
modifier|*
name|M
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|M
operator|->
name|menu_id
operator|==
literal|0
condition|)
return|return;
name|M
operator|->
name|Mn
operator|=
name|NewMenu
argument_list|(
name|M
operator|->
name|menu_id
argument_list|,
name|CtoPstr
argument_list|(
name|M
operator|->
name|Name
argument_list|)
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
name|M
operator|->
name|Name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUITEMS
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
name|M
operator|->
name|m
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
break|break;
comment|/* last item... */
switch|switch
condition|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
condition|)
block|{
case|case
operator|(
name|STRING
operator|)
case|:
name|AppendMenu
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|CtoPstr
argument_list|(
name|d
operator|->
name|Name
argument_list|)
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|VARIABLE
operator|)
case|:
name|SetItemMark
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
comment|/* ??? fall through? */
case|case
operator|(
name|FUNCTION
operator|)
case|:
name|CtoPstr
argument_list|(
name|name
operator|=
operator|(
operator|(
name|data_obj
operator|*
operator|)
name|d
operator|)
operator|->
name|Name
argument_list|)
expr_stmt|;
name|AppendMenu
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|PtoCstr
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|InsertMenu
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|ProcMenu
parameter_list|(
name|menuno
parameter_list|,
name|itemno
parameter_list|)
name|int
name|menuno
decl_stmt|,
name|itemno
decl_stmt|;
block|{
name|void
name|MacSetVar
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
operator|&&
name|Menus
index|[
name|i
index|]
operator|.
name|menu_id
operator|!=
name|menuno
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|NMENUS
condition|)
block|{
comment|/* found the menu */
name|itemno
operator|--
expr_stmt|;
name|d
operator|=
name|Menus
index|[
name|i
index|]
operator|.
name|m
index|[
name|itemno
index|]
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
condition|)
block|{
case|case
name|FUNCTION
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|BUFFER
case|:
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|tiewind
argument_list|(
name|curwind
argument_list|,
operator|(
name|Buffer
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
operator|(
name|Buffer
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARIABLE
case|:
name|MacSetVar
argument_list|(
operator|(
expr|struct
name|variable
operator|*
operator|)
name|d
argument_list|,
name|i
argument_list|,
name|itemno
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|private
name|void
name|make_edits
parameter_list|(
name|menu
parameter_list|)
comment|/* add dummy edit menu */
name|int
name|menu
decl_stmt|;
block|{
name|MenuHandle
name|M
decl_stmt|;
name|int
name|item
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|M
operator|=
name|NewMenu
argument_list|(
operator|(
name|menu
operator|)
argument_list|,
literal|"\pEdit"
argument_list|)
expr_stmt|;
name|AppendMenu
argument_list|(
name|M
argument_list|,
literal|"\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear;Select All;(-;Show Clipboard"
argument_list|)
expr_stmt|;
name|InsertMenu
argument_list|(
name|M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DisableItem
argument_list|(
name|M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|void
name|menus_off
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Keyonly
operator|||
name|EventCmd
condition|)
return|return;
ifdef|#
directive|ifdef
name|MENU_DISABLE
comment|/* NOBODY likes this, but it's here if you want it... */
name|DisableItem
argument_list|(
name|SysMenu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Menus
index|[
name|i
index|]
operator|.
name|Mn
condition|)
name|DisableItem
argument_list|(
name|Menus
index|[
name|i
index|]
operator|.
name|Mn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DrawMenuBar
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Keyonly
operator|=
name|YES
expr_stmt|;
block|}
name|void
name|menus_on
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|Keyonly
condition|)
return|return;
ifdef|#
directive|ifdef
name|MENU_DISABLE
name|EnableItem
argument_list|(
name|SysMenu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Menus
index|[
name|i
index|]
operator|.
name|Mn
condition|)
name|EnableItem
argument_list|(
name|Menus
index|[
name|i
index|]
operator|.
name|Mn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DrawMenuBar
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Keyonly
operator|=
name|NO
expr_stmt|;
block|}
name|private
name|char
modifier|*
name|BufMPrint
parameter_list|(
name|b
parameter_list|,
name|i
parameter_list|)
name|Buffer
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|nm
init|=
name|filename
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|char
name|t
index|[
literal|35
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|nm
argument_list|)
operator|>
literal|30
condition|)
block|{
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|t
argument_list|,
name|nm
operator|+
name|strlen
argument_list|(
name|nm
argument_list|)
operator|-
literal|30
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|t
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|nm
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|nm
condition|)
block|{
switch|switch
condition|(
operator|*
name|nm
condition|)
block|{
comment|/* ugh... these are metacharacter for Menus */
case|case
literal|'/'
case|:
operator|*
name|nm
operator|=
literal|':'
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
case|case
literal|'!'
case|:
case|case
literal|'<'
case|:
case|case
literal|'('
case|:
case|case
literal|';'
case|:
operator|*
name|nm
operator|=
literal|'.'
expr_stmt|;
break|break;
comment|/* that will confuse everybody */
block|}
name|nm
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|sprint
argument_list|(
literal|"%-2d %-11s \"%-s\""
argument_list|,
name|i
argument_list|,
name|b
operator|->
name|b_name
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|private
name|void
name|SetBufMenu
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|stop
decl_stmt|;
name|struct
name|menu
modifier|*
name|M
decl_stmt|;
name|Bufchange
operator|=
name|NO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMENUS
operator|&&
name|strcmp
argument_list|(
name|Menus
index|[
name|i
index|]
operator|.
name|Name
argument_list|,
literal|"Buffer"
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|NMENUS
condition|)
block|{
name|M
operator|=
operator|&
name|Menus
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMENUITEMS
operator|&&
operator|(
name|d
operator|=
name|Menus
index|[
name|i
index|]
operator|.
name|m
index|[
name|j
index|]
operator|)
operator|&&
operator|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
operator|)
operator|!=
name|BUFFER
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|<
name|NMENUITEMS
condition|)
block|{
for|for
control|(
name|i
operator|=
name|j
operator|,
name|b
operator|=
name|world
init|;
name|i
operator|<
name|NMENUITEMS
operator|&&
name|b
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|b
operator|=
name|b
operator|->
name|b_next
control|)
block|{
if|if
condition|(
name|M
operator|->
name|m
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|AppendMenu
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|CtoPstr
argument_list|(
name|BufMPrint
argument_list|(
name|b
argument_list|,
name|i
operator|-
name|j
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add the item */
else|else
name|SetItem
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|CtoPstr
argument_list|(
name|BufMPrint
argument_list|(
name|b
argument_list|,
name|i
operator|-
name|j
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or change it */
name|M
operator|->
name|m
index|[
name|i
index|]
operator|=
operator|(
name|data_obj
operator|*
operator|)
name|b
expr_stmt|;
block|}
name|stop
operator|=
name|i
expr_stmt|;
comment|/* out of buffers? */
for|for
control|(
init|;
name|i
operator|<
name|NMENUITEMS
operator|&&
name|M
operator|->
name|m
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|DelMenuItem
argument_list|(
name|M
operator|->
name|Mn
argument_list|,
name|stop
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* take off last item */
name|M
operator|->
name|m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
name|private
name|void
name|MacSetVar
parameter_list|(
name|vp
parameter_list|,
name|mnu
parameter_list|,
name|itm
parameter_list|)
comment|/* Set a variable from the menu */
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
comment|/* Liberally taken from SetVar() in extend.c */
name|int
name|mnu
decl_stmt|,
name|itm
decl_stmt|;
block|{
name|void
name|MarkVar
parameter_list|()
function_decl|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|prompt
operator|=
name|sprint
argument_list|(
literal|"Set %s: "
argument_list|,
name|vp
operator|->
name|Name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
condition|)
block|{
case|case
name|V_BASE10
case|:
case|case
name|V_BASE8
case|:
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|ask_int
argument_list|(
name|prompt
argument_list|,
operator|(
operator|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
operator|)
operator|==
name|V_BASE10
operator|)
condition|?
literal|10
else|:
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
name|value
expr_stmt|;
break|break;
block|}
case|case
name|V_BOOL
case|:
comment|/* toggle the value */
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
operator|(
operator|*
name|vp
operator|->
name|v_value
operator|==
name|ON
condition|?
name|OFF
else|:
name|ON
operator|)
expr_stmt|;
name|MarkVar
argument_list|(
name|vp
argument_list|,
name|mnu
argument_list|,
name|itm
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_FILENAME
case|:
case|case
name|V_STRING
case|:
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Do_ask() so you can set string to "" if you so desire. */
name|str
operator|=
name|do_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|bool
argument_list|(
argument|*
argument_list|)
name|ptrproto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|str
operator|=
name|NullStr
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* ... and hope there is enough room. */
break|break;
block|}
case|case
name|V_CHAR
case|:
name|f_mess
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
name|addgetc
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_MODELINE
condition|)
name|UpdModLine
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_CLRSCREEN
condition|)
name|ClAndRedraw
argument_list|()
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TTY_RESET
condition|)
name|tty_reset
argument_list|()
expr_stmt|;
comment|/* probably none on a Mac */
block|}
name|private
name|void
name|MarkModes
parameter_list|()
block|{
name|int
name|mnu
decl_stmt|,
name|itm
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
name|Modechange
operator|=
name|NO
expr_stmt|;
for|for
control|(
name|mnu
operator|=
literal|0
init|;
name|mnu
operator|<
name|NMENUS
condition|;
name|mnu
operator|++
control|)
for|for
control|(
name|itm
operator|=
literal|0
init|;
name|itm
operator|<
name|NMENUITEMS
condition|;
name|itm
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|Menus
index|[
name|mnu
index|]
operator|.
name|m
index|[
name|itm
index|]
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|d
operator|->
name|Type
operator|&
operator|(
name|MAJOR_MODE
operator||
name|MINOR_MODE
operator|)
operator|)
operator|||
operator|(
operator|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
operator|)
operator|==
name|BUFFER
operator|)
condition|)
block|{
name|bool
name|checked
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|Type
operator|&
operator|(
name|MAJOR_MODE
operator|)
condition|)
name|checked
operator|=
name|curbuf
operator|->
name|b_major
operator|==
operator|(
name|d
operator|->
name|Type
operator|>>
literal|8
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|Type
operator|&
operator|(
name|MINOR_MODE
operator|)
condition|)
name|checked
operator|=
operator|(
name|curbuf
operator|->
name|b_minor
operator|&
operator|(
name|d
operator|->
name|Type
operator|>>
literal|8
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
else|else
name|checked
operator|=
name|d
operator|==
operator|(
name|data_obj
operator|*
operator|)
name|curbuf
expr_stmt|;
name|CheckItem
argument_list|(
name|Menus
index|[
name|mnu
index|]
operator|.
name|Mn
argument_list|,
name|itm
operator|+
literal|1
argument_list|,
name|checked
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|MarkVar
parameter_list|(
name|vp
parameter_list|,
name|mnu
parameter_list|,
name|itm
parameter_list|)
comment|/* mark a boolean menu item */
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
name|int
name|mnu
decl_stmt|,
name|itm
decl_stmt|;
block|{
if|if
condition|(
name|mnu
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* we don't know the item... slow */
for|for
control|(
name|mnu
operator|=
literal|0
init|;
name|mnu
operator|<
name|NMENUS
condition|;
name|mnu
operator|++
control|)
block|{
for|for
control|(
name|itm
operator|=
literal|0
init|;
operator|(
name|itm
operator|<
name|NMENUITEMS
operator|)
condition|;
name|itm
operator|++
control|)
block|{
if|if
condition|(
operator|(
expr|struct
name|variable
operator|*
operator|)
operator|(
name|Menus
index|[
name|mnu
index|]
operator|.
name|m
index|[
name|itm
index|]
operator|)
operator|==
name|vp
condition|)
block|{
name|CheckItem
argument_list|(
name|Menus
index|[
name|mnu
index|]
operator|.
name|Mn
argument_list|,
name|itm
operator|+
literal|1
argument_list|,
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|==
name|ON
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
name|private
name|void
name|MarkAllVar
parameter_list|()
comment|/* slow, but only do it once */
block|{
name|int
name|mnu
decl_stmt|,
name|itm
decl_stmt|;
name|data_obj
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|mnu
operator|=
literal|0
init|;
name|mnu
operator|<
name|NMENUS
condition|;
name|mnu
operator|++
control|)
for|for
control|(
name|itm
operator|=
literal|0
init|;
name|itm
operator|<
name|NMENUITEMS
condition|;
name|itm
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|Menus
index|[
name|mnu
index|]
operator|.
name|m
index|[
name|itm
index|]
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|d
operator|->
name|Type
operator|&
name|TYPEMASK
operator|)
operator|==
name|VARIABLE
condition|)
name|MarkVar
argument_list|(
operator|(
expr|struct
name|variable
operator|*
operator|)
name|Menus
index|[
name|mnu
index|]
operator|.
name|m
index|[
name|itm
index|]
argument_list|,
name|mnu
argument_list|,
name|itm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Screen routines and driver. The Macinitosh Text Edit routines are not utilized,    as they are slow and cumbersome for a terminal emulator. Instead, direct QuickDraw    calls are used. The fastest output is obtained writing a line at a time, rather    than on a character basis, so the major output routine is writechr(), which takes    a pascal-style string as an argument. See do_sputc() in screen.c. */
name|void
name|Placur
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|CapCol
operator|=
name|col
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
name|putcurs
argument_list|(
name|line
argument_list|,
name|col
argument_list|,
name|ON
argument_list|)
expr_stmt|;
block|}
name|void
name|NPlacur
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|CapCol
operator|=
name|col
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
name|putcurs
argument_list|(
name|line
argument_list|,
name|col
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
block|}
name|void
name|i_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dellines
argument_list|(
name|num
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inslines
argument_list|(
name|num
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
block|}
name|void
name|d_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dellines
argument_list|(
name|num
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inslines
argument_list|(
name|num
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
block|}
comment|/* (ORIGINALLY IN) tn.c   */
comment|/* window driver for MacIntosh using windows. */
comment|/* K. Mitchum 9/86 */
comment|/*#define VARFONT*/
ifdef|#
directive|ifdef
name|VARFONT
name|private
name|height
decl_stmt|,
name|width
decl_stmt|,
name|theight
decl_stmt|,
name|twidth
decl_stmt|,
name|descent
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|height
value|HEIGHT
define|#
directive|define
name|width
value|WIDTH
define|#
directive|define
name|theight
value|THEIGHT
define|#
directive|define
name|twidth
value|TWIDTH
define|#
directive|define
name|descent
value|DESCENT
endif|#
directive|endif
name|private
name|int
name|trow
decl_stmt|,
name|tcol
decl_stmt|,
name|insert
decl_stmt|,
name|cursor
decl_stmt|;
name|private
name|bool
name|tattr
decl_stmt|;
comment|/* ??? never fetched */
name|private
name|Rect
name|cursor_rect
decl_stmt|;
name|private
name|char
modifier|*
name|p_scr
decl_stmt|,
modifier|*
name|p_curs
decl_stmt|;
comment|/* physical screen and cursor */
name|private
name|int
name|p_size
decl_stmt|;
name|private
name|Rect
name|vRect
decl_stmt|;
name|private
name|WindowRecord
name|myWindowRec
decl_stmt|;
define|#
directive|define
name|active
parameter_list|()
value|SetPort(theScreen)
define|#
directive|define
name|maxadjust
parameter_list|(
name|r
parameter_list|)
value|OffsetRect((r),0,2);
name|char
modifier|*
name|conv_p_curs
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
block|{
return|return
name|p_scr
operator|+
operator|(
name|row
operator|*
operator|(
name|CO
operator|)
operator|)
operator|+
name|col
return|;
block|}
name|private
name|void
name|INSmode
parameter_list|(
name|new
parameter_list|)
name|bool
name|new
decl_stmt|;
block|{
name|insert
operator|=
name|new
expr_stmt|;
block|}
name|private
name|void
name|HLmode
parameter_list|(
name|new
parameter_list|)
name|bool
name|new
decl_stmt|;
block|{
name|tattr
operator|=
name|new
expr_stmt|;
block|}
name|void
name|SO_on
parameter_list|()
block|{
name|HLmode
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|void
name|SO_off
parameter_list|()
block|{
name|HLmode
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|tn_init
parameter_list|()
block|{
name|void
name|INSmode
name|proto
argument_list|(
operator|(
name|bool
operator|)
argument_list|)
decl_stmt|,
name|init_slate
argument_list|()
decl_stmt|;
name|HLmode
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|INSmode
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|init_slate
argument_list|()
expr_stmt|;
name|ShowPen
argument_list|()
expr_stmt|;
block|}
name|void
name|clr_page
parameter_list|()
comment|/* clear and home function */
block|{
name|Rect
name|r
decl_stmt|;
name|setmem
argument_list|(
name|p_scr
argument_list|,
name|p_size
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|active
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WINDWIDTH
argument_list|,
name|WINDHEIGHT
argument_list|)
expr_stmt|;
name|EraseRect
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|OFF
expr_stmt|;
name|putcurs
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
comment|/* ??? "OFF" guess by DHR */
name|drawfluff
argument_list|()
expr_stmt|;
block|}
name|private
name|void
name|putcurs
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|,
name|vis
parameter_list|)
name|unsigned
name|row
decl_stmt|,
name|col
decl_stmt|;
name|bool
name|vis
decl_stmt|;
block|{
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|trow
operator|=
name|row
expr_stmt|;
name|tcol
operator|=
name|col
expr_stmt|;
name|curset
argument_list|(
name|vis
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|curset
parameter_list|(
name|desired
parameter_list|)
name|bool
name|desired
decl_stmt|;
block|{
name|p_curs
operator|=
name|conv_p_curs
argument_list|(
name|trow
argument_list|,
name|tcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|MoveTo
argument_list|(
name|tcol
operator|*
name|width
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|+
literal|2
operator|-
name|descent
argument_list|)
expr_stmt|;
else|else
name|MoveTo
argument_list|(
name|tcol
operator|*
name|width
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
name|descent
argument_list|)
expr_stmt|;
name|DrawChar
argument_list|(
operator|*
name|p_curs
argument_list|)
expr_stmt|;
if|if
condition|(
name|desired
condition|)
block|{
name|SetRect
argument_list|(
operator|&
name|cursor_rect
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
operator|(
name|trow
operator|)
operator|*
name|height
argument_list|,
operator|(
name|tcol
operator|+
literal|1
operator|)
operator|*
name|width
operator|-
literal|1
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|cursor_rect
argument_list|)
expr_stmt|;
name|InvertRect
argument_list|(
operator|&
name|cursor_rect
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|MoveTo
argument_list|(
name|tcol
operator|*
name|width
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|+
literal|2
operator|-
name|descent
argument_list|)
expr_stmt|;
else|else
name|MoveTo
argument_list|(
name|tcol
operator|*
name|width
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
name|descent
argument_list|)
expr_stmt|;
block|}
name|void
name|putp
parameter_list|(
name|p
parameter_list|)
comment|/* put one character, advance cursor */
name|int
name|p
decl_stmt|;
block|{
specifier|static
name|Rect
name|r
decl_stmt|;
specifier|static
name|RgnHandle
name|updateRgn
decl_stmt|;
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert
condition|)
block|{
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|WINDWIDTH
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
name|width
argument_list|,
literal|0
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
literal|'0'
condition|)
name|p
operator|=
literal|0xAF
expr_stmt|;
comment|/* slashed zero */
if|if
condition|(
name|insert
condition|)
name|BlockMove
argument_list|(
name|p_curs
argument_list|,
name|p_curs
operator|+
literal|1
argument_list|,
call|(
name|long
call|)
argument_list|(
name|MAXCOL
operator|-
name|tcol
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p_curs
operator|=
operator|(
name|char
operator|)
name|p
expr_stmt|;
name|DrawChar
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcol
operator|>=
name|MAXCOL
condition|)
name|putcurs
argument_list|(
name|trow
argument_list|,
name|MAXCOL
argument_list|,
name|ON
argument_list|)
expr_stmt|;
comment|/* ??? "ON" guess by DHR */
else|else
name|putcurs
argument_list|(
name|trow
argument_list|,
name|tcol
operator|+
literal|1
argument_list|,
name|ON
argument_list|)
expr_stmt|;
comment|/* ??? "ON" guess by DHR */
block|}
name|void
name|clr_eoln
parameter_list|()
block|{
specifier|static
name|Rect
name|r
decl_stmt|;
name|active
argument_list|()
expr_stmt|;
name|cursor
operator|=
name|OFF
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|WINDWIDTH
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|EraseRect
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|setmem
argument_list|(
name|p_curs
argument_list|,
name|CO
operator|-
name|tcol
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|curset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|delchars
parameter_list|()
block|{
specifier|static
name|Rect
name|r
decl_stmt|;
specifier|static
name|RgnHandle
name|updateRgn
decl_stmt|;
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|twidth
operator|-
name|width
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
operator|-
name|width
argument_list|,
literal|0
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
name|BlockMove
argument_list|(
name|p_curs
operator|+
literal|1
argument_list|,
name|p_curs
argument_list|,
call|(
name|long
call|)
argument_list|(
name|MAXCOL
operator|-
name|tcol
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|conv_p_curs
argument_list|(
name|trow
argument_list|,
name|MAXCOL
argument_list|)
operator|)
operator|=
literal|' '
expr_stmt|;
name|curset
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|dellines
parameter_list|(
name|n
parameter_list|,
name|bot
parameter_list|)
name|int
name|n
decl_stmt|,
name|bot
decl_stmt|;
block|{
name|Rect
name|r
decl_stmt|;
name|RgnHandle
name|updateRgn
decl_stmt|;
name|long
name|len
decl_stmt|;
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|trow
operator|)
operator|*
name|height
operator|)
argument_list|,
name|WINDWIDTH
argument_list|,
operator|(
operator|(
name|bot
operator|+
literal|1
operator|)
operator|*
name|height
operator|)
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
literal|0
operator|-
operator|(
name|n
operator|*
name|height
operator|)
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
operator|(
name|bot
operator|-
name|trow
operator|-
name|n
operator|+
literal|1
operator|)
operator|*
name|CO
operator|)
expr_stmt|;
name|BlockMove
argument_list|(
name|conv_p_curs
argument_list|(
operator|(
name|trow
operator|+
name|n
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|conv_p_curs
argument_list|(
name|trow
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|setmem
argument_list|(
name|conv_p_curs
argument_list|(
operator|(
name|bot
operator|-
name|n
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|n
operator|*
name|CO
operator|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|putcurs
argument_list|(
name|trow
argument_list|,
literal|0
argument_list|,
name|ON
argument_list|)
expr_stmt|;
comment|/* ??? "ON" guess by DHR */
block|}
name|private
name|void
name|inslines
parameter_list|(
name|n
parameter_list|,
name|bot
parameter_list|)
name|int
name|n
decl_stmt|,
name|bot
decl_stmt|;
block|{
name|Rect
name|r
decl_stmt|;
name|RgnHandle
name|updateRgn
decl_stmt|;
name|long
name|len
decl_stmt|;
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|WINDWIDTH
argument_list|,
operator|(
name|bot
operator|+
literal|1
operator|)
operator|*
name|height
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
operator|(
name|n
operator|*
name|height
operator|)
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
operator|(
name|bot
operator|-
name|trow
operator|-
name|n
operator|+
literal|1
operator|)
operator|*
name|CO
operator|)
expr_stmt|;
name|BlockMove
argument_list|(
name|conv_p_curs
argument_list|(
name|trow
argument_list|,
literal|0
argument_list|)
argument_list|,
name|conv_p_curs
argument_list|(
operator|(
name|trow
operator|+
name|n
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|setmem
argument_list|(
name|conv_p_curs
argument_list|(
name|trow
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|n
operator|*
name|CO
operator|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|putcurs
argument_list|(
name|trow
argument_list|,
literal|0
argument_list|,
name|ON
argument_list|)
expr_stmt|;
comment|/* ??? "ON" guess by DHR */
block|}
name|void
name|writechr
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
comment|/* actually, a Str255 type string */
block|{
specifier|static
name|Rect
name|r
decl_stmt|;
specifier|static
name|RgnHandle
name|updateRgn
decl_stmt|;
specifier|register
name|len
expr_stmt|;
specifier|register
name|char
name|save
decl_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|start
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
comment|/* adjusted 6/86 K. M. in td.c*/
name|active
argument_list|()
expr_stmt|;
name|curset
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert
condition|)
block|{
name|updateRgn
operator|=
name|NewRgn
argument_list|()
expr_stmt|;
name|SetRect
argument_list|(
operator|&
name|r
argument_list|,
name|tcol
operator|*
name|width
argument_list|,
name|trow
operator|*
name|height
argument_list|,
name|twidth
operator|-
name|width
operator|*
name|len
argument_list|,
operator|(
name|trow
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trow
operator|==
name|MAXROW
condition|)
name|maxadjust
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|ScrollRect
argument_list|(
operator|&
name|r
argument_list|,
name|width
operator|*
name|len
argument_list|,
literal|0
argument_list|,
name|updateRgn
argument_list|)
expr_stmt|;
name|DisposeRgn
argument_list|(
name|updateRgn
argument_list|)
expr_stmt|;
block|}
name|DrawString
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert
condition|)
name|BlockMove
argument_list|(
name|p_curs
argument_list|,
name|p_curs
operator|+
name|len
argument_list|,
call|(
name|long
call|)
argument_list|(
name|CO
operator|-
name|tcol
operator|-
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p_curs
argument_list|,
name|start
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcol
operator|>=
name|MAXCOL
condition|)
name|putcurs
argument_list|(
name|trow
argument_list|,
name|MAXCOL
argument_list|,
name|ON
argument_list|)
expr_stmt|;
comment|/* ??? "ON" guess by DHR */
else|else
name|putcurs
argument_list|(
name|trow
argument_list|,
name|tcol
operator|+
name|len
argument_list|,
name|ON
argument_list|)
expr_stmt|;
comment|/* ??? "ON" guess by DHR */
block|}
name|private
name|Rect
name|myBoundsRect
decl_stmt|;
name|private
name|void
name|init_slate
parameter_list|()
block|{
name|FontInfo
name|f
decl_stmt|;
name|char
modifier|*
name|Name
init|=
literal|"Jove "
decl_stmt|;
name|char
modifier|*
name|Title
decl_stmt|;
name|InitGraf
argument_list|(
operator|&
name|thePort
argument_list|)
expr_stmt|;
name|InitWindows
argument_list|()
expr_stmt|;
name|InitCursor
argument_list|()
expr_stmt|;
name|InitFonts
argument_list|()
expr_stmt|;
name|InitMenus
argument_list|()
expr_stmt|;
name|InitDialogs
argument_list|(
operator|(
name|ProcPtr
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* no restart proc */
comment|/* figure limiting rectangle for window moves */
name|SetRect
argument_list|(
operator|&
name|LimitRect
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|left
operator|+
literal|3
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|top
operator|+
literal|20
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|right
operator|-
literal|3
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|bottom
operator|-
literal|3
argument_list|)
expr_stmt|;
name|Set_std
argument_list|()
expr_stmt|;
name|SetBounds
argument_list|()
expr_stmt|;
comment|/* initialize char array for updates */
name|p_scr
operator|=
name|emalloc
argument_list|(
name|p_size
operator|=
name|wc_std
operator|.
name|w_cols
operator|*
name|wc_std
operator|.
name|w_rows
argument_list|)
expr_stmt|;
comment|/* only once */
name|p_curs
operator|=
name|p_scr
expr_stmt|;
name|Title
operator|=
name|sprint
argument_list|(
literal|"%s%s"
argument_list|,
name|Name
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|theScreen
operator|=
name|NewWindow
argument_list|(
operator|&
name|myWindowRec
argument_list|,
operator|&
name|myBoundsRect
argument_list|,
name|CtoPstr
argument_list|(
name|Title
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
operator|(
name|WindowPtr
operator|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* figure an initial window configuration and adjust it */
name|wc
operator|=
operator|&
name|wc_std
expr_stmt|;
name|wc_user
operator|=
name|wc_std
expr_stmt|;
comment|/* initially, only one configuration to toggle */
name|user_state
argument_list|(
name|theScreen
argument_list|)
operator|=
name|std_state
argument_list|(
name|theScreen
argument_list|)
expr_stmt|;
name|SetPort
argument_list|(
name|theScreen
argument_list|)
expr_stmt|;
operator|(
name|theScreen
operator|)
operator|->
name|txFont
operator|=
name|FONT
expr_stmt|;
operator|(
name|theScreen
operator|)
operator|->
name|txSize
operator|=
name|TEXTSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|VARFONT
name|GetFontInfo
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
name|height
operator|=
name|f
operator|.
name|ascent
operator|+
name|f
operator|.
name|descent
operator|+
name|f
operator|.
name|leading
expr_stmt|;
name|width
operator|=
name|f
operator|.
name|widMax
expr_stmt|;
name|twidth
operator|=
name|width
operator|*
name|wc
operator|->
name|w_cols
expr_stmt|;
name|theight
operator|=
name|height
operator|*
name|wc
operator|->
name|w_rows
expr_stmt|;
name|descent
operator|=
name|f
operator|.
name|descent
expr_stmt|;
endif|#
directive|endif
name|theScreen
operator|->
name|txMode
operator|=
name|patCopy
expr_stmt|;
name|theScreen
operator|->
name|pnMode
operator|=
name|patCopy
expr_stmt|;
name|PenNormal
argument_list|()
expr_stmt|;
name|cursor
operator|=
name|OFF
expr_stmt|;
block|}
name|private
name|void
name|p_refresh
parameter_list|()
block|{
name|int
name|lineno
decl_stmt|;
name|char
modifier|*
name|curs
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|emalloc
argument_list|(
name|CO
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|lineno
operator|=
literal|0
init|;
name|lineno
operator|<
name|LI
condition|;
name|lineno
operator|++
control|)
block|{
name|curs
operator|=
name|conv_p_curs
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineno
operator|==
name|MAXROW
condition|)
name|MoveTo
argument_list|(
literal|0
argument_list|,
operator|(
name|lineno
operator|+
literal|1
operator|)
operator|*
name|height
operator|+
literal|2
operator|-
name|descent
argument_list|)
expr_stmt|;
else|else
name|MoveTo
argument_list|(
literal|0
argument_list|,
operator|(
name|lineno
operator|+
literal|1
operator|)
operator|*
name|height
operator|-
name|descent
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|curs
argument_list|,
name|CO
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|CO
expr_stmt|;
name|DrawString
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|putcurs
argument_list|(
name|trow
argument_list|,
name|tcol
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|private
name|bool
name|wc_adjust
parameter_list|(
name|w
parameter_list|,
name|h
parameter_list|,
name|wcf
parameter_list|,
name|init
parameter_list|)
comment|/* adjust window config to look nice */
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
name|struct
name|wind_config
modifier|*
name|wcf
decl_stmt|;
name|int
name|init
decl_stmt|;
block|{
specifier|static
name|int
name|LIMIT_R
decl_stmt|,
name|LIMIT_C
decl_stmt|;
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|LIMIT_R
operator|=
operator|(
name|h
operator|-
literal|4
operator|)
operator|/
name|HEIGHT
expr_stmt|;
name|LIMIT_C
operator|=
operator|(
name|w
operator|-
name|SCROLLWIDTH
operator|-
literal|1
operator|)
operator|/
name|WIDTH
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|w
operator|<
name|WIDTH
operator|*
literal|40
operator|)
operator|||
operator|(
name|h
operator|<
name|HEIGHT
operator|*
literal|10
operator|)
comment|/* too small */
operator|||
operator|(
operator|(
name|rows
operator|=
operator|(
name|h
operator|-
literal|4
operator|)
operator|/
name|HEIGHT
operator|)
operator|>
name|LIMIT_R
operator|)
comment|/* too big */
operator|||
operator|(
operator|(
name|cols
operator|=
operator|(
name|w
operator|-
name|SCROLLWIDTH
operator|-
literal|1
operator|)
operator|/
name|WIDTH
operator|+
literal|1
operator|)
operator|>
name|LIMIT_C
operator|)
condition|)
return|return
name|NO
return|;
name|wcf
operator|->
name|w_rows
operator|=
name|rows
expr_stmt|;
name|wcf
operator|->
name|w_cols
operator|=
name|cols
expr_stmt|;
name|wcf
operator|->
name|w_width
operator|=
name|wcf
operator|->
name|w_cols
operator|*
name|WIDTH
operator|+
literal|1
operator|+
name|SCROLLWIDTH
expr_stmt|;
name|wcf
operator|->
name|w_height
operator|=
name|wcf
operator|->
name|w_rows
operator|*
name|HEIGHT
operator|+
literal|4
expr_stmt|;
return|return
name|YES
return|;
block|}
name|int
name|getCO
parameter_list|()
comment|/* so that jove knows params */
block|{
return|return
name|wc
operator|->
name|w_cols
return|;
block|}
name|int
name|getLI
parameter_list|()
block|{
return|return
name|wc
operator|->
name|w_rows
return|;
block|}
name|private
name|void
name|SetBounds
parameter_list|()
block|{
name|SetRect
argument_list|(
operator|&
name|myBoundsRect
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|left
operator|+
literal|3
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|top
operator|+
literal|40
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|left
operator|+
literal|3
operator|+
name|wc_std
operator|.
name|w_width
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|top
operator|+
literal|40
operator|+
name|wc_std
operator|.
name|w_height
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|Set_std
parameter_list|()
block|{
operator|(
name|void
operator|)
name|wc_adjust
argument_list|(
name|screenBits
operator|.
name|bounds
operator|.
name|right
operator|-
name|screenBits
operator|.
name|bounds
operator|.
name|left
operator|-
literal|6
argument_list|,
name|screenBits
operator|.
name|bounds
operator|.
name|bottom
operator|-
name|screenBits
operator|.
name|bounds
operator|.
name|top
operator|-
literal|42
argument_list|,
operator|&
name|wc_std
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|Reset_std
parameter_list|()
block|{
name|Set_std
argument_list|()
expr_stmt|;
name|std_state
argument_list|(
name|theScreen
argument_list|)
operator|=
name|myBoundsRect
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

end_unit

